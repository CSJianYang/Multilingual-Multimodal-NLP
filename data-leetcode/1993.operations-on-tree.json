[
    {
        "title": "Flipping an Image",
        "question_content": "Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\nTo flip an image horizontally means that each row of the image is reversed.\n\n\tFor example, flipping [1,1,0] horizontally results in [0,1,1].\n\nTo invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n\n\tFor example, inverting [0,1,1] results in [1,0,0].\n\n&nbsp;\nExample 1:\n\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\nExplanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\nThen, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\n\nExample 2:\n\nInput: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\nOutput: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\nExplanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\nThen invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n&nbsp;\nConstraints:\n\n\tn == image.length\n\tn == image[i].length\n\t1 <= n <= 20\n\timages[i][j] is either 0 or 1.",
        "solutions": [
            {
                "id": 130590,
                "title": "java-c-python-reverse-and-toggle",
                "content": "# **Explanation**:\\n1. reverse every row.\\n2. toggle every value.\\n\\nIn Java, I did both steps together:\\nCompare the `i` th and `n - i - 1` th in a row.\\nThe \"trick\" is that if the values are not the same,\\nbut you swap and flip, nothing will change.\\nSo if they are same, we toggle both, otherwise we do nothing.\\n<br>\\n\\n# **Complexity**:\\nTime `O(N^2)`\\nSpace `O(N^2)` for output\\n<br>\\n\\n**Java:**\\n```java\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int n = A.length;\\n        for (int[] row : A)\\n            for (int i = 0; i * 2 < n; i++)\\n                if (row[i] == row[n - i - 1])\\n                    row[i] = row[n - i - 1] ^= 1;\\n        return A;\\n    }\\n```\\n**C++:**\\nby @guybrush2323\\n```cpp\\n    static const vector<vector<int>>& flipAndInvertImage(vector<vector<int>>& A) {\\n        for (auto& row : A) {\\n            reverse(row.begin(), row.end());\\n            for (auto& v : row) v ^= 1;\\n        }\\n        return A;\\n    }\\n```\\n**1-line Python:**\\n```python\\n    def flipAndInvertImage(self, A):\\n        return [[1 ^ i for i in reversed(row)] for row in A]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int n = A.length;\\n        for (int[] row : A)\\n            for (int i = 0; i * 2 < n; i++)\\n                if (row[i] == row[n - i - 1])\\n                    row[i] = row[n - i - 1] ^= 1;\\n        return A;\\n    }\\n```\n```cpp\\n    static const vector<vector<int>>& flipAndInvertImage(vector<vector<int>>& A) {\\n        for (auto& row : A) {\\n            reverse(row.begin(), row.end());\\n            for (auto& v : row) v ^= 1;\\n        }\\n        return A;\\n    }\\n```\n```python\\n    def flipAndInvertImage(self, A):\\n        return [[1 ^ i for i in reversed(row)] for row in A]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 148272,
                "title": "easy-understand-one-pass-java-solution-absolutely-beat-100",
                "content": "The idea is simple. For each row, use two pointers. One is going forward and the other is going backward. \\n(1). If the two elements are the same, then make a slight change like this 0 -> 1 or 1 -> 0. \\n(2). If the two elements are different, DON\\'T do anything. Just let it go.\\n\\nOnly scan the whole matrix once.\\n\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            int lo = 0, hi = A[0].length - 1;\\n            while (lo <= hi) {\\n                if (A[i][lo] == A[i][hi]) {\\n                    A[i][lo] = 1 - A[i][lo];\\n                    A[i][hi] = A[i][lo];\\n                }\\n                lo++;\\n                hi--;\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            int lo = 0, hi = A[0].length - 1;\\n            while (lo <= hi) {\\n                if (A[i][lo] == A[i][hi]) {\\n                    A[i][lo] = 1 - A[i][lo];\\n                    A[i][hi] = A[i][lo];\\n                }\\n                lo++;\\n                hi--;\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132026,
                "title": "python-1-line",
                "content": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        return [[1-i for i in row[::-1]] for row in A]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        return [[1-i for i in row[::-1]] for row in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930378,
                "title": "c-short-and-simple-in-place-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i=0; i<A.size(); i++) {\\n            reverse(A[i].begin(), A[i].end());\\n            for (int j=0; j<A[i].size(); j++) {\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i=0; i<A.size(); i++) {\\n            reverse(A[i].begin(), A[i].end());\\n            for (int j=0; j<A[i].size(); j++) {\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230318,
                "title": "python3-beats-99-78-with-explanation",
                "content": "```\\ndef flipAndInvertImage(self, A):\\n\\tfor row in A:\\n\\t\\ti, j = 0, len(row) - 1\\n\\t\\twhile i <= j:\\n\\t\\t\\tif row[i] == row[j]:\\n\\t\\t\\t\\trow[i], row[j] = row[i]^1, row[j]^1\\n\\t\\t\\ti += 1\\n\\t\\t\\tj -= 1\\n\\treturn A\\n```\\n\\n\\nAfter reviewing some examples you will notice the following patterns:\\n\\t\\t1) Look at first and last value of row.  If they are the same (1,1 or 0,0), they will be flipped in the output.  \\n\\t\\t\\tIf they are different (1,0 or 0,1), they do not change.  Work your way inward to the middle of the list \\n\\t\\t\\tapplying this rule.\\n\\t\\t2) If the row has an odd number of entries, the middle value always flips.  For example if len(row) = 5, \\n\\t\\t\\tthen row[2] must change values.\\n\\nBitwise XOR --> 0^1 = 1, 1^1 =0 \\n\\nLet i be the index at the beginning of the row, and j be the index at the end of the row.  If the the values at \\nthese indices (row[i] and row[j]) are equal, flip their values using XOR ^.  If they values are not equal, do \\nnothing and move i and j closer to the middle.  When i == j , the code still executes as it should. \\n\\n**Edit**:\\nIf `len(A) = num_words = M` and `len(A[0]) = word_length = N`, we iterate over `(word_length / 2) * num_words` or `(N/2) * M` values.  Time complexity is `O((N/2) * M)`, but its still just linear with the input so we can generalize as `O(N)`.  Space complexity is `O(1)`.",
                "solutionTags": [],
                "code": "```\\ndef flipAndInvertImage(self, A):\\n\\tfor row in A:\\n\\t\\ti, j = 0, len(row) - 1\\n\\t\\twhile i <= j:\\n\\t\\t\\tif row[i] == row[j]:\\n\\t\\t\\t\\trow[i], row[j] = row[i]^1, row[j]^1\\n\\t\\t\\ti += 1\\n\\t\\t\\tj -= 1\\n\\treturn A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 930392,
                "title": "python-oneliner-explained",
                "content": "Let us do exactly what is asked in this problem: for each row: flip the image horizontally, then invert it. Quick way to get `0` from `1` and `1` from `0` is to use `1^q` (however tests are so small, so difference is not very big).\\n\\n**Complexity**: time complexity is `O(mn)`, where `m`, `n` are sizes of image. Space complexity is also `O(mn)` if we count output and `O(1)` space if we do not count. Note, that if we allowed to modify original image, than we can have `O(1)` space.\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[1^q for q in row[::-1]] for row in A]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[1^q for q in row[::-1]] for row in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520742,
                "title": "java-tc-o-n-2-sc-o-1-optimal-one-pass-in-place-solution",
                "content": "```java\\n/**\\n * Optimal one-pass in-place solution\\n *\\n * If the values are not same, swap and flip will not change anything.\\n * If the values are same, we will flip both.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Matrix Size\\n */\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        if (image == null || image.length == 0 || image[0].length == 0) {\\n            return image;\\n        }\\n\\n        for (int[] row : image) {\\n            int start = 0;\\n            int end = row.length - 1;\\n            while (start <= end) {\\n                if (row[start] == row[end]) {\\n                    row[start] ^= 1;\\n                    row[end] = row[start];\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Optimal one-pass in-place solution\\n *\\n * If the values are not same, swap and flip will not change anything.\\n * If the values are same, we will flip both.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Matrix Size\\n */\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        if (image == null || image.length == 0 || image[0].length == 0) {\\n            return image;\\n        }\\n\\n        for (int[] row : image) {\\n            int start = 0;\\n            int end = row.length - 1;\\n            while (start <= end) {\\n                if (row[start] == row[end]) {\\n                    row[start] ^= 1;\\n                    row[end] = row[start];\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130644,
                "title": "one-liner-javascript-solution",
                "content": "```\\nvar flipAndInvertImage = function(A) {\\n    // take each row, reverse it, then map each number in it and invert it. map returns a list\\n    return A.map(row => row.reverse().map(num => num^1));\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar flipAndInvertImage = function(A) {\\n    // take each row, reverse it, then map each number in it and invert it. map returns a list\\n    return A.map(row => row.reverse().map(num => num^1));\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 931580,
                "title": "java-easy-solution",
                "content": "```\\npublic int[][] flipAndInvertImage(int[][] A) {\\n        int row = A.length;\\n        int col = A[0].length;\\n        int[][] result = new int[row][col];\\n        \\n\\t\\t// Step 1 : revert\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                result[i][j] = A[i][col-j-1];\\n            }\\n        }\\n        // Step 2: invert\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                result[i][j] = result[i][j] == 1 ? 0 : 1;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] A) {\\n        int row = A.length;\\n        int col = A[0].length;\\n        int[][] result = new int[row][col];\\n        \\n\\t\\t// Step 1 : revert\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                result[i][j] = A[i][col-j-1];\\n            }\\n        }\\n        // Step 2: invert\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                result[i][j] = result[i][j] == 1 ? 0 : 1;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 602813,
                "title": "simple-javascript-solution",
                "content": "```\\nvar flipAndInvertImage = function(A) {\\n\\t\\tfor(let row in A) {\\n\\t\\t\\tA[row] = A[row].reverse();\\n\\t\\t\\tA[row] = A[row].map(x => 1 - x);\\n\\t\\t}\\n\\treturn A;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar flipAndInvertImage = function(A) {\\n\\t\\tfor(let row in A) {\\n\\t\\t\\tA[row] = A[row].reverse();\\n\\t\\t\\tA[row] = A[row].map(x => 1 - x);\\n\\t\\t}\\n\\treturn A;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1124348,
                "title": "c-100-fast-highly-readable-beginner-friendly",
                "content": "**Plz Upvote If You Liked This Solution - -**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            vector<int> x=image[i];\\n            reverse(x.begin(),x.end());\\n            image[i]=x;\\n        }\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size();j++)\\n                image[i][j]^=1;\\n        }\\n        \\n        return image;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            vector<int> x=image[i];\\n            reverse(x.begin(),x.end());\\n            image[i]=x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 260718,
                "title": "javascript-beats-93-1-line",
                "content": "```\\nvar flipAndInvertImage = function(A) {\\n    return A.map(a=>{return a.reverse().map(b=>b^1)})\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar flipAndInvertImage = function(A) {\\n    return A.map(a=>{return a.reverse().map(b=>b^1)})\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550889,
                "title": "the-python3-one-liner",
                "content": "```\\nreturn [[0 if x==1 else 1 for x in x][::-1] for x in A] \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nreturn [[0 if x==1 else 1 for x in x][::-1] for x in A] \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140128,
                "title": "one-pass-in-place-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int n = A.length;\\n        for(int j = 0; j < n / 2 + n % 2; j++){\\n            for(int i = 0; i < n; i++) {\\n                int tmp = A[i][j];\\n                A[i][j] = A[i][n - 1 - j] ^ 1;\\n                A[i][n - 1 - j] = tmp ^ 1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int n = A.length;\\n        for(int j = 0; j < n / 2 + n % 2; j++){\\n            for(int i = 0; i < n; i++) {\\n                int tmp = A[i][j];\\n                A[i][j] = A[i][n - 1 - j] ^ 1;\\n                A[i][n - 1 - j] = tmp ^ 1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380062,
                "title": "easy-c-solution-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- First I\\'ve copied the image array to new `ans` array.\\n- then reversed every array that is inside it`(as mentioned in question)`\\n- then replaced every `0` value to `1`.\\n- and every `1` value to `0`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n`Upvote! It only takes 1 click :)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> ans = image;\\n\\n        for(int i=0;i<n;i++) {\\n            reverse(ans[i].begin(), ans[i].end());\\n            for(int j=0;j<n;j++) {\\n                if(ans[i][j] == 0){\\n                    ans[i][j] = 1;\\n                }\\n                else{\\n                    ans[i][j] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/c8af91b5-b6f6-463d-9ff5-3bbdf63eed2e_1680625991.9136252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> ans = image;\\n\\n        for(int i=0;i<n;i++) {\\n            reverse(ans[i].begin(), ans[i].end());\\n            for(int j=0;j<n;j++) {\\n                if(ans[i][j] == 0){\\n                    ans[i][j] = 1;\\n                }\\n                else{\\n                    ans[i][j] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137586,
                "title": "java-best-solution-beats-100",
                "content": "# Approach\\n- First, Reverse Every Row.\\n- Then, Change the Value of the Elements\\n- From 1 to 0 and 0 to 1.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++) {\\n            int a = 0, r = image[0].length - 1;\\n            while (a <= r) {\\n                int temp = image[i][a];\\n                image[i][a] = image[i][r];\\n                image[i][r] = temp;\\n                a++;\\n                r--;\\n            }\\n        }\\n        for (int i = 0; i < image.length; i++) {\\n            for (int j = 0; j < image[0].length; j++) {\\n                if (image[i][j] == 0) {\\n                    image[i][j] = 1;\\n                } else {\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++) {\\n            int a = 0, r = image[0].length - 1;\\n            while (a <= r) {\\n                int temp = image[i][a];\\n                image[i][a] = image[i][r];\\n                image[i][r] = temp;\\n                a++;\\n                r--;\\n            }\\n        }\\n        for (int i = 0; i < image.length; i++) {\\n            for (int j = 0; j < image[0].length; j++) {\\n                if (image[i][j] == 0) {\\n                    image[i][j] = 1;\\n                } else {\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363051,
                "title": "python-very-very-easy-soln-3-solutions-explained-o-n-with-or-without-inbuilt-functions",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \"\"\"\\n        Simple & striaghtforward without using inbuilt functions.\\n     \\n        In actual the run time is very less as we are iterating only n/2 time\\n        for each image list.\\n        Time complexity : O(n * n/2) == O(n^2) \\n        Space complexity : O(1)\\n        \"\"\"\\n        \\n        for im in image: #Iterate through each im list in the image list.\\n            i, j = 0, len(im)-1    #Maintain two pointers one at start and one at end.\\n            while i <= j:          #Iterate while first pointer is less than or equal to second pointer.\\n                im[i], im[j] = im[j]^1, im[i]^1   #swap element at both pointer & complement them at the same time.\\n                i +=1              #increment first pointer to move forward\\n                j -=1              #decrement second pointer to move backward\\n            \\n        return image         # return same list\\n    \\n    \\n        \"\"\"\\n        Using inbuilt functions\\n        \"\"\"\\n        # for im in range(len(image)):\\n        #     image[im] = list(map(lambda a : abs(a-1), reversed(image[im])))\\n        # return image\\n    \\n        \"\"\"\\n        One liner\\n        \"\"\"\\n        return [[i^1 for i in im[::-1]] for im in image]\\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \"\"\"\\n        Simple & striaghtforward without using inbuilt functions.\\n     \\n        In actual the run time is very less as we are iterating only n/2 time\\n        for each image list.\\n        Time complexity : O(n * n/2) == O(n^2) \\n        Space complexity : O(1)\\n        \"\"\"\\n        \\n        for im in image: #Iterate through each im list in the image list.\\n            i, j = 0, len(im)-1    #Maintain two pointers one at start and one at end.\\n            while i <= j:          #Iterate while first pointer is less than or equal to second pointer.\\n                im[i], im[j] = im[j]^1, im[i]^1   #swap element at both pointer & complement them at the same time.\\n                i +=1              #increment first pointer to move forward\\n                j -=1              #decrement second pointer to move backward\\n            \\n        return image         # return same list\\n    \\n    \\n        \"\"\"\\n        Using inbuilt functions\\n        \"\"\"\\n        # for im in range(len(image)):\\n        #     image[im] = list(map(lambda a : abs(a-1), reversed(image[im])))\\n        # return image\\n    \\n        \"\"\"\\n        One liner\\n        \"\"\"\\n        return [[i^1 for i in im[::-1]] for im in image]\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737887,
                "title": "google-3-832-flipping-an-image-o-n-solution-c",
                "content": "# Approach\\nAll the approach is well explained in the question. During swapping for reversal of array used xor with 1 to flip the bit i.e inverting because 1^1=0 , 0^1=1 for simplicity of code.By combining both steps it decreases time complexity from O(N^2) to O(N).\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\nIt seems O(N^2) but the loops are running for each row and half column so Actual Time comlexity is O(rows*columns) which is equal to O(N) as N=no of elements=rows*columns(as per this question).\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<(n+1)/2;j++)\\n            {\\n                int temp=image[i][j]^1;\\n                image[i][j]=image[i][n-1-j]^1;\\n                image[i][n-1-j]=temp;\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<(n+1)/2;j++)\\n            {\\n                int temp=image[i][j]^1;\\n                image[i][j]=image[i][n-1-j]^1;\\n                image[i][n-1-j]=temp;\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763690,
                "title": "very-simple-solution-using-python",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        for i in image:\\n            res.append([x ^ 1 for x in i[::-1]])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        for i in image:\\n            res.append([x ^ 1 for x in i[::-1]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033336,
                "title": "c-easy-xor-operation",
                "content": "```\\n//kindly dry run each and every input for better understanding\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end());\\n            for(auto j=0;j<image[i].size();j++){\\n                image[i][j]^=1;\\n            }\\n        }       \\n        return image;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//kindly dry run each and every input for better understanding\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end());\\n            for(auto j=0;j<image[i].size();j++){\\n                image[i][j]^=1;\\n            }\\n        }       \\n        return image;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780606,
                "title": "python3-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            image[i] = image[i][::-1]\\n            for j in range(len(image[i])):\\n                if image[i][j] == 0:\\n                    image[i][j] = 1\\n                else:\\n                    image[i][j] = 0\\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            image[i] = image[i][::-1]\\n            for j in range(len(image[i])):\\n                if image[i][j] == 0:\\n                    image[i][j] = 1\\n                else:\\n                    image[i][j] = 0\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930613,
                "title": "clean-in-place-java-solution-one-pass-0ms",
                "content": "The logic is simular to swaping two position within an array but just done over many position. Idea is that you will perform the swap over every row of the matrix and only to the half way point of the row. When performing the swap, invert the value to achieve the invert. Inversion is done using 1 - cell value since it\\'s only 1 and 0. (1 - 1 = 0, 1 - 0 = 1).\\nHere is the code. \\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for(int i = 0; i < A.length ; i++){\\n            for(int j = 0; j < (A[0].length+1)/2; j++){\\n                int temp = 1-A[i][j];\\n                A[i][j] = 1-A[i][A[i].length-j-1];\\n                A[i][A[i].length-j-1] = temp;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```\\nIf you enjoy this solution, feel free to **upvote** it or **comment** to it if you have any question. I will be happy to answer.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for(int i = 0; i < A.length ; i++){\\n            for(int j = 0; j < (A[0].length+1)/2; j++){\\n                int temp = 1-A[i][j];\\n                A[i][j] = 1-A[i][A[i].length-j-1];\\n                A[i][A[i].length-j-1] = temp;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816547,
                "title": "java-100-faster-logical-solution",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] img) {\\n        int m=img.length,n=img[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            int l=0,r=n-1;\\n            while(l<=r)\\n            {\\n                if(img[i][l]==img[i][r])\\n                {\\n                    if(img[i][l]==0)\\n                    {\\n                        img[i][l]=1;\\n                        img[i][r]=1;\\n                    }\\n                    else\\n                    {\\n                        img[i][l]=0;\\n                        img[i][r]=0;\\n                    }\\n                }\\n                l++;\\n                r--;\\n            }\\n        }\\n        return img;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] img) {\\n        int m=img.length,n=img[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            int l=0,r=n-1;\\n            while(l<=r)\\n            {\\n                if(img[i][l]==img[i][r])\\n                {\\n                    if(img[i][l]==0)\\n                    {\\n                        img[i][l]=1;\\n                        img[i][r]=1;\\n                    }\\n                    else\\n                    {\\n                        img[i][l]=0;\\n                        img[i][r]=0;\\n                    }\\n                }\\n                l++;\\n                r--;\\n            }\\n        }\\n        return img;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044064,
                "title": "python-6-methods-with-explanation",
                "content": "**Platform**: leetcode.com\\n**832.** Flipping an Image\\n**Link**: https://leetcode.com/problems/flipping-an-image/\\n**Difficulty**: Easy\\n**Author** : hritik5102\\n**Date**: 31/1/2021\\n**Post Discussion** : https://leetcode.com/problems/flipping-an-image/discuss/1044064/python-or-6-Methods-with-explanation\\n**Submission** : https://leetcode.com/submissions/detail/450220569/\\n**(Time, Space) Complexity** : O(n), O(n)\\n\\n\\n# Method 1 : Easy and consice\\n\\n## Reverse the row and the invert the number i.e. if 1 then convert it into 0 or vice versa\\n```python\\n>> arr = [1,2,3]  \\n>> arr[::-1]   \\n>> [3,2,1]\\n```\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        for arr in A:\\n            res.append(list(map(lambda x:0 if x else 1, arr[::-1])))\\n        return res            \\n```\\n\\n# Method 02 : Create a dictionary and the same is logic\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        for arr in A:\\n            res.append(list(map(lambda x: d[x], arr[::-1])))\\n        return res            \\n```\\n\\n# Method 03 : Instead of using map and lambda function, use list comprehesion which is faster\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        for arr in A:\\n            res.append([d[i] for i in arr[::-1]])\\n        return res            \\n```\\n\\n# Method 04 : List comprehension\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        return [[d[i] for i in arr[::-1]] for arr in A]\\n```\\n        \\n# Method 05 : One liner but faster\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[1^i for i in arr[::-1]] for arr in A]\\n```\\n\\n# Method 06 : Fastest method  (Reference from : [@xieal](https://leetcode.com/xieal) )\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[l[i] ^ 1 for i in range(len(l) - 1, -1, -1)] for l in A]\\n\\nobj = Solution()\\nprint(obj.flipAndInvertImage(A = [[1,1,0],[1,0,1],[0,0,0]]))        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n>> arr = [1,2,3]  \\n>> arr[::-1]   \\n>> [3,2,1]\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        for arr in A:\\n            res.append(list(map(lambda x:0 if x else 1, arr[::-1])))\\n        return res            \\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        for arr in A:\\n            res.append(list(map(lambda x: d[x], arr[::-1])))\\n        return res            \\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        for arr in A:\\n            res.append([d[i] for i in arr[::-1]])\\n        return res            \\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        return [[d[i] for i in arr[::-1]] for arr in A]\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[1^i for i in arr[::-1]] for arr in A]\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[l[i] ^ 1 for i in range(len(l) - 1, -1, -1)] for l in A]\\n\\nobj = Solution()\\nprint(obj.flipAndInvertImage(A = [[1,1,0],[1,0,1],[0,0,0]]))        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 224813,
                "title": "rust-simple-one-liner",
                "content": "```\\nimpl Solution {\\n    pub fn flip_and_invert_image(a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        a.iter()\\n         .map(|r| r.iter().rev().map(|i| 1 - i).collect())\\n         .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn flip_and_invert_image(a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        a.iter()\\n         .map(|r| r.iter().rev().map(|i| 1 - i).collect())\\n         .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 136893,
                "title": "1-line-c",
                "content": "1 line using C# Linq\\n```\\npublic int[][] FlipAndInvertImage2(int[][] A) {\\n    return A.Select(row => row.Reverse().Select(col => col ^ 1).ToArray()).ToArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] FlipAndInvertImage2(int[][] A) {\\n    return A.Select(row => row.Reverse().Select(col => col ^ 1).ToArray()).ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1905120,
                "title": "java-0ms-100-faster-simple-easy-solution-with-o-1-space",
                "content": "![image](https://assets.leetcode.com/users/images/f42b9943-7177-4657-a40e-c32e5135d651_1648870130.589014.png)\\n***Please Upvote if you find this helpful***\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++){\\n            int s = 0;\\n            int e = image[i].length-1;\\n            while (s<e){\\n                int temp = image[i][s];\\n                image[i][s] = image[i][e];\\n                image[i][e] = temp;\\n                s++;\\n                e--;\\n            }\\n        }\\n        for(int i = 0; i < image.length; i++){\\n            for (int j = 0; j < image[i].length; j++){\\n                if(image[i][j] == 0){\\n                    image[i][j] = 1;\\n                }\\n                else if(image[i][j] == 1){\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++) {\\n            int temp = image[i].length;\\n            if (temp % 2 == 1) {\\n                image[i][temp/2] = image[i][temp/2] == 1 ? 0 : 1;\\n            }\\n            int start = 0;\\n            int end = temp - 1;\\n            while (end > start) {\\n                flip(image[i], start, end);\\n                start++;\\n                end--;\\n            }\\n        }\\n        return image;\\n    }\\n    private void flip(int[] arr, int firstIndex, int lastIndex) {\\n        int temp = arr[firstIndex];\\n        arr[firstIndex] = arr[lastIndex];\\n        arr[lastIndex] = temp;\\n        arr[firstIndex] = arr[firstIndex] == 1 ? 0 : 1;\\n        arr[lastIndex] = arr[lastIndex] == 1 ? 0 : 1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++){\\n            int s = 0;\\n            int e = image[i].length-1;\\n            while (s<e){\\n                int temp = image[i][s];\\n                image[i][s] = image[i][e];\\n                image[i][e] = temp;\\n                s++;\\n                e--;\\n            }\\n        }\\n        for(int i = 0; i < image.length; i++){\\n            for (int j = 0; j < image[i].length; j++){\\n                if(image[i][j] == 0){\\n                    image[i][j] = 1;\\n                }\\n                else if(image[i][j] == 1){\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++) {\\n            int temp = image[i].length;\\n            if (temp % 2 == 1) {\\n                image[i][temp/2] = image[i][temp/2] == 1 ? 0 : 1;\\n            }\\n            int start = 0;\\n            int end = temp - 1;\\n            while (end > start) {\\n                flip(image[i], start, end);\\n                start++;\\n                end--;\\n            }\\n        }\\n        return image;\\n    }\\n    private void flip(int[] arr, int firstIndex, int lastIndex) {\\n        int temp = arr[firstIndex];\\n        arr[firstIndex] = arr[lastIndex];\\n        arr[lastIndex] = temp;\\n        arr[firstIndex] = arr[firstIndex] == 1 ? 0 : 1;\\n        arr[lastIndex] = arr[lastIndex] == 1 ? 0 : 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439620,
                "title": "c-3-solutions-compared-and-explained-100-time-100-space",
                "content": "This problem is literally telling us what to do, so I guess there is no much to explain in terms of theory or mathematical tricks here - just fun to tackle it in multiple ways if you wish so.\\n\\nFirst of all, a simple, concise version taking each row as a reference, reversing it and then switching the bits on it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& arr) {\\n        for (auto &row: arr) {\\n            // reversing the row\\n\\t\\t\\treverse(begin(row), end(row));\\n\\t\\t\\t// flipping its bits\\n            transform(begin(row), end(row), begin(row), [](auto b){return !b;});\\n        }\\n        return arr;\\n    }\\n}\\n```\\n\\nA slightly more performance version came to me from [Abishek\\'s brilliant solution](https://leetcode.com/problems/flipping-an-image/discuss/930432/), that I tweaked a bit to see if I can make it even a bit more optimal.\\n\\nFirst of all we declare 2 support variables:\\n* `halfLen` is half the size of each row, to save recomputing it all the time;\\n* `len` is the full length of it `- 1`, again because we want to avoid recomputing the same stuff over and over again.\\n\\nAbishek\\'s idea was that things change only when the values of 2 elements with the same distance from the centre is different.\\n\\nFor example, given the row:\\n\\n```cpp\\n0 0 1 1 1 0 1\\n```\\n\\nThe first and the last element will stay the same, because you swap them and then flip them, you will still end up with `0 ... 1` at his extremes:\\n\\n```cpp\\n0 0 1 1 1 0 1\\n```\\n\\nProceeding with second and penultimate, you will see that both are equals, so this time we will have a change, which means both will flip:\\n\\n```cpp\\n0 1 1 1 1 1 1\\n```\\n\\nSimilarly with third and antepenultimate, both equal to `1`:\\n\\n```cpp\\n0 1 0 1 0 1 1\\n```\\n\\nFinally, with odd length rows, the central element is always going to be flipped:\\n\\n```cpp\\n0 1 0 0 0 1 1\\n```\\n\\nWith a nested loop, going by row first and by element later, we can easily work like that and save ourselves the pain (and computatinal cost) of a few unnecessary swaps and flips).\\n\\nOnce we are done, time to return `arr` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& arr) {\\n        // support variables\\n        int halfLen = arr[0].size() / 2, len = arr[0].size() - 1;\\n        for (auto &row: arr) {\\n            for (int i = 0; i < halfLen; i++) {\\n                // working only on equal pairss\\n                if (row[i] == row[len - i]) {\\n                    row[i] = !row[i];\\n                    row[len - i] = row[i];\\n                }\\n            }\\n            // swapping the central element for rows of odd length\\n            if (len % 2 == 0) row[halfLen] = !row[halfLen];\\n        }\\n        return arr;\\n    }\\n};\\n```\\n\\nFor comparison, the needlessly complicated solution I came up with months ago - thanks LeetCode for improving my skills to the point in which I no longer write this kind of stuff :D\\n\\nThe previous code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int i, tmp, lastPos;\\n        transform(begin(A), end(A), begin(A), [&](vector<int> e){\\n            lastPos = e.size() -1;\\n            for (i = 0; i < e.size() / 2; i++) {\\n                tmp = e[i];\\n                e[i] = !(e[lastPos - i]);\\n                e[lastPos - i] = !tmp;\\n            }\\n            if (e.size() % 2) e[e.size() / 2] = !e[e.size() / 2];\\n            return e;\\n        });\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& arr) {\\n        for (auto &row: arr) {\\n            // reversing the row\\n\\t\\t\\treverse(begin(row), end(row));\\n\\t\\t\\t// flipping its bits\\n            transform(begin(row), end(row), begin(row), [](auto b){return !b;});\\n        }\\n        return arr;\\n    }\\n}\\n```\n```cpp\\n0 0 1 1 1 0 1\\n```\n```cpp\\n0 0 1 1 1 0 1\\n```\n```cpp\\n0 1 1 1 1 1 1\\n```\n```cpp\\n0 1 0 1 0 1 1\\n```\n```cpp\\n0 1 0 0 0 1 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& arr) {\\n        // support variables\\n        int halfLen = arr[0].size() / 2, len = arr[0].size() - 1;\\n        for (auto &row: arr) {\\n            for (int i = 0; i < halfLen; i++) {\\n                // working only on equal pairss\\n                if (row[i] == row[len - i]) {\\n                    row[i] = !row[i];\\n                    row[len - i] = row[i];\\n                }\\n            }\\n            // swapping the central element for rows of odd length\\n            if (len % 2 == 0) row[halfLen] = !row[halfLen];\\n        }\\n        return arr;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int i, tmp, lastPos;\\n        transform(begin(A), end(A), begin(A), [&](vector<int> e){\\n            lastPos = e.size() -1;\\n            for (i = 0; i < e.size() / 2; i++) {\\n                tmp = e[i];\\n                e[i] = !(e[lastPos - i]);\\n                e[lastPos - i] = !tmp;\\n            }\\n            if (e.size() % 2) e[e.size() / 2] = !e[e.size() / 2];\\n            return e;\\n        });\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143191,
                "title": "python-readable",
                "content": "```\\n        for row in xrange(len(A)):\\n            A[row] = A[row][::-1] # reverse the row\\n            \\n            for invert in xrange(len(A[row])): # invert each element\\n                if A[row][invert] == 0:\\n                    A[row][invert] = 1\\n                else:\\n                    A[row][invert] = 0\\n                    \\n        return A\\n```",
                "solutionTags": [],
                "code": "```\\n        for row in xrange(len(A)):\\n            A[row] = A[row][::-1] # reverse the row\\n            \\n            for invert in xrange(len(A[row])): # invert each element\\n                if A[row][invert] == 0:\\n                    A[row][invert] = 1\\n                else:\\n                    A[row][invert] = 0\\n                    \\n        return A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2717567,
                "title": "two-pointer-solution",
                "content": "```\\n/**\\n * @param {number[][]} image\\n * @return {number[][]}\\n */\\nvar flipAndInvertImage = function(image) {\\n    for(let i = 0; i < image.length; i++){\\n        let left = 0;\\n        let right = image[i].length-1;\\n        while(left <= right){\\n            if(left === right){\\n                image[i][left] = image[i][left] === 0 ? 1 : 0\\n            }else{\\n                [image[i][left], image[i][right]] = [image[i][right], image[i][left]]\\n                image[i][left] = image[i][left] === 0 ? 1 : 0\\n                image[i][right] = image[i][right] === 0 ? 1 : 0\\n            }\\n            left++\\n            right--\\n        }\\n    }\\n    return image\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[][]} image\\n * @return {number[][]}\\n */\\nvar flipAndInvertImage = function(image) {\\n    for(let i = 0; i < image.length; i++){\\n        let left = 0;\\n        let right = image[i].length-1;\\n        while(left <= right){\\n            if(left === right){\\n                image[i][left] = image[i][left] === 0 ? 1 : 0\\n            }else{\\n                [image[i][left], image[i][right]] = [image[i][right], image[i][left]]\\n                image[i][left] = image[i][left] === 0 ? 1 : 0\\n                image[i][right] = image[i][right] === 0 ? 1 : 0\\n            }\\n            left++\\n            right--\\n        }\\n    }\\n    return image\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1548646,
                "title": "python-xor-simplest-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            start = 0\\n            end = len(image[i]) - 1\\n            while start <= end:\\n                image[i][start], image[i][end] = image[i][end]^1, image[i][start]^1\\n                start += 1\\n                end -= 1\\n        return image\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            start = 0\\n            end = len(image[i]) - 1\\n            while start <= end:\\n                image[i][start], image[i][end] = image[i][end]^1, image[i][start]^1\\n                start += 1\\n                end -= 1\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480909,
                "title": "simple-javascript-solution",
                "content": "```\\nfunction invert(arr) {\\n    return arr.reverse();\\n}\\n\\nfunction flip(arr) {\\n    for(let i = 0; i<arr.length; i++) {\\n        if(arr[i] == 1) {\\n            arr.splice(i, 1, 0);\\n        } else if(arr[i] == 0 ) {\\n            arr.splice(i, 1, 1);\\n        }\\n    }\\n    return arr;\\n}\\n\\nvar flipAndInvertImage = function(image) {\\n   return image.map(img => flip(invert(img)));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction invert(arr) {\\n    return arr.reverse();\\n}\\n\\nfunction flip(arr) {\\n    for(let i = 0; i<arr.length; i++) {\\n        if(arr[i] == 1) {\\n            arr.splice(i, 1, 0);\\n        } else if(arr[i] == 0 ) {\\n            arr.splice(i, 1, 1);\\n        }\\n    }\\n    return arr;\\n}\\n\\nvar flipAndInvertImage = function(image) {\\n   return image.map(img => flip(invert(img)));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370149,
                "title": "java-0-ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n       int i =0;\\n        for(int [] mat : image){\\n            mat = flip(mat);\\n            mat = invert(mat);\\n            image[i++] = mat;\\n        }\\n        return image;\\n    }\\n\\t//flipping \\n    public int[] flip(int [] mat){\\n        int i = 0;\\n        int j = mat.length-1;\\n        while(i < j){\\n            int temp = mat[i];\\n            mat[i++] = mat[j];\\n            mat[j--] = temp;\\n        }\\n        \\n        return mat;\\n    }\\n    //inverting\\n    public int[] invert(int [] mat){\\n       for(int i = 0; i < mat.length; i++){\\n            if(mat[i] == 1){\\n                mat[i] = 0;\\n            }\\n           else {\\n               mat[i] = 1;\\n           }\\n        }\\n        return mat;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n       int i =0;\\n        for(int [] mat : image){\\n            mat = flip(mat);\\n            mat = invert(mat);\\n            image[i++] = mat;\\n        }\\n        return image;\\n    }\\n\\t//flipping \\n    public int[] flip(int [] mat){\\n        int i = 0;\\n        int j = mat.length-1;\\n        while(i < j){\\n            int temp = mat[i];\\n            mat[i++] = mat[j];\\n            mat[j--] = temp;\\n        }\\n        \\n        return mat;\\n    }\\n    //inverting\\n    public int[] invert(int [] mat){\\n       for(int i = 0; i < mat.length; i++){\\n            if(mat[i] == 1){\\n                mat[i] = 0;\\n            }\\n           else {\\n               mat[i] = 1;\\n           }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843663,
                "title": "c-short-and-simple-in-place-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i=0; i<A.size(); i++) {\\n            reverse(A[i].begin(), A[i].end());\\n            for (int j=0; j<A[i].size(); j++) {\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i=0; i<A.size(); i++) {\\n            reverse(A[i].begin(), A[i].end());\\n            for (int j=0; j<A[i].size(); j++) {\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396821,
                "title": "multiple-simple-solutions-with-explanation-python",
                "content": "1. **Reverse each row** \\n\\n`flipped = [row[::-1] for row in A]`\\n\\n2. **Invert binary values** \\n\\nHere the trick is to use `map` as it applies a given function to all elements of the list. Here\\'s the blueprint from the official documentation:\\n\\n`map(function_to_apply, list_of_inputs)`\\n\\nDon\\'t forget to **cast it to list**!\\n\\nWe can now solve the problem with a compact expression like this:\\n\\n```\\ntranslation = {0:1, 1:0}\\nreturn [list(map(lambda x: translation[x], row[::-1])) for row in A] \\n```\\n\\nWhenever you want to operate with binary values, consider using bitwise operators. In this case \"AND\" allows us to translate 0 to 1 and viceversa:\\n\\n```\\nfor row in A:\\n  for i in range((len(row) + 1) // 2):\\n    row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1\\n    return A \\n```\\n\\nNow combining this wisdom with our previous list comprehension solution:\\n\\n```\\nreturn [[i ^ 1 for i in row[::-1]] for row in A]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ntranslation = {0:1, 1:0}\\nreturn [list(map(lambda x: translation[x], row[::-1])) for row in A] \\n```\n```\\nfor row in A:\\n  for i in range((len(row) + 1) // 2):\\n    row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1\\n    return A \\n```\n```\\nreturn [[i ^ 1 for i in row[::-1]] for row in A]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346663,
                "title": "python-3-accepted-solution",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\n        return [[abs(1-i) for i in row[::-1]] for row in A]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\n        return [[abs(1-i) for i in row[::-1]] for row in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130593,
                "title": "python-1-liner-48-ms",
                "content": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [[1 - x for x in A[i][::-1]] for i in range(len(A))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [[1 - x for x in A[i][::-1]] for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893480,
                "title": "java-solution-with-0ms-runtime-beats-100-tc-o-n-n",
                "content": "**If you found it easy to understand, Please do upvote :)\\nThankyou!!**\\n**--------------------------------------------------------------------------------------------------**\\n![Today Leetcode Pic.JPG](https://assets.leetcode.com/users/images/c219a0c5-a102-4ce7-9d88-f5a3a783acdc_1670570648.5850391.jpeg)\\n**--------------------------------------------------------------------------------------------------**\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[][] flipAndInvertImage(int[][] image) \\n    {\\n        //Flipping\\n        for(int i=0; i<image.length; i++)\\n        {            \\n            for(int left=0, right=image[i].length-1; left<=right; left++, right--)\\n            {\\n                //Two-pointer approach\\n                int temp = image[i][left];\\n                image[i][left] = image[i][right];\\n                image[i][right] = temp;\\n            }\\n        }\\n\\n        //Inverting\\n        for(int i=0; i<image.length; i++)\\n        {\\n            for(int j=0; j<image[i].length; j++)\\n            {\\n                image[i][j] = image[i][j]==0 ? 1 : 0;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[][] flipAndInvertImage(int[][] image) \\n    {\\n        //Flipping\\n        for(int i=0; i<image.length; i++)\\n        {            \\n            for(int left=0, right=image[i].length-1; left<=right; left++, right--)\\n            {\\n                //Two-pointer approach\\n                int temp = image[i][left];\\n                image[i][left] = image[i][right];\\n                image[i][right] = temp;\\n            }\\n        }\\n\\n        //Inverting\\n        for(int i=0; i<image.length; i++)\\n        {\\n            for(int j=0; j<image[i].length; j++)\\n            {\\n                image[i][j] = image[i][j]==0 ? 1 : 0;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848365,
                "title": "python-easy-solution-99-81-faster",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        m,n=len(image),len(image[0])\\n        for i in range(m):\\n            image[i]=image[i][-1::-1]\\n        for i in range(m):\\n            for j in range(n):\\n                if image[i][j]==0:\\n                    image[i][j]=1\\n                else:\\n                    image[i][j]=0\\n        return image\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        m,n=len(image),len(image[0])\\n        for i in range(m):\\n            image[i]=image[i][-1::-1]\\n        for i in range(m):\\n            for j in range(n):\\n                if image[i][j]==0:\\n                    image[i][j]=1\\n                else:\\n                    image[i][j]=0\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788649,
                "title": "c-solution-using-xor",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end()); // reverse each row\\n            for(int j=0; j<image[0].size(); j++){\\n                image[i][j] = image[i][j] ^ 1;      // flip each number\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end()); // reverse each row\\n            for(int j=0; j<image[0].size(); j++){\\n                image[i][j] = image[i][j] ^ 1;      // flip each number\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711033,
                "title": "java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int i=0;i<image.length;i++){\\n           reverse(image[i]);\\n           invert(image[i]);\\n        }\\n   \\n        // Either can use the for loop to invert the array individually or can use in single for loop\\n        // for(int i=0;i<image.length;i++){\\n        //    invert(image[i]);\\n        // }\\n        \\n        return image;\\n        \\n    }\\n    \\n    static void reverse(int []image){\\n        int s=0;\\n        int e=image.length-1;\\n        \\n        while(s<e){\\n            int temp=image[s];\\n            image[s] = image[e];\\n            image[e] = temp;\\n            s++;\\n            e--;\\n        }\\n    }\\n    \\n    static void invert(int []arr){\\n           for(int i=0;i<arr.length;i++){\\n               if(arr[i]==0){\\n                   arr[i]=1;\\n               }\\n               else{\\n                   arr[i]=0;\\n               }\\n           }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int i=0;i<image.length;i++){\\n           reverse(image[i]);\\n           invert(image[i]);\\n        }\\n   \\n        // Either can use the for loop to invert the array individually or can use in single for loop\\n        // for(int i=0;i<image.length;i++){\\n        //    invert(image[i]);\\n        // }\\n        \\n        return image;\\n        \\n    }\\n    \\n    static void reverse(int []image){\\n        int s=0;\\n        int e=image.length-1;\\n        \\n        while(s<e){\\n            int temp=image[s];\\n            image[s] = image[e];\\n            image[e] = temp;\\n            s++;\\n            e--;\\n        }\\n    }\\n    \\n    static void invert(int []arr){\\n           for(int i=0;i<arr.length;i++){\\n               if(arr[i]==0){\\n                   arr[i]=1;\\n               }\\n               else{\\n                   arr[i]=0;\\n               }\\n           }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935953,
                "title": "runtime-1ms",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int[][] magic=image;\\n        for(int i=0;i<magic.length;i++){\\n            reverse(magic[i]);\\n        }\\n        \\n        for(int i=0;i<magic.length;i++){\\n           for(int j=0;j<magic[0].length;j++){\\n               if(magic[i][j]==1){\\n                   magic[i][j]=0;\\n               }\\n               else if(magic[i][j]==0){\\n                   magic[i][j]=1;\\n               }\\n           }\\n        }\\n        return magic;\\n        \\n    }\\n    public void reverse(int[]nums){\\n        int max=nums.length-1;\\n        int half=max/2;\\n        for(int i=0;i<=half;i++){\\n            int temp=nums[i];\\n            nums[i]=nums[max-i];\\n            nums[max-i]=temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int[][] magic=image;\\n        for(int i=0;i<magic.length;i++){\\n            reverse(magic[i]);\\n        }\\n        \\n        for(int i=0;i<magic.length;i++){\\n           for(int j=0;j<magic[0].length;j++){\\n               if(magic[i][j]==1){\\n                   magic[i][j]=0;\\n               }\\n               else if(magic[i][j]==0){\\n                   magic[i][j]=1;\\n               }\\n           }\\n        }\\n        return magic;\\n        \\n    }\\n    public void reverse(int[]nums){\\n        int max=nums.length-1;\\n        int half=max/2;\\n        for(int i=0;i<=half;i++){\\n            int temp=nums[i];\\n            nums[i]=nums[max-i];\\n            nums[max-i]=temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738309,
                "title": "c-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n  = image.size();\\n        for(int i = 0 ; i < n ;i ++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j = 0 ; j < image[i].size() ; j ++)\\n                image[i][j] ^= 1;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n  = image.size();\\n        for(int i = 0 ; i < n ;i ++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j = 0 ; j < image[i].size() ; j ++)\\n                image[i][j] ^= 1;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467103,
                "title": "c-0ms-beat-100-highly-readable-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        \\n        for(int idx = 0; idx < image.size(); idx++){\\n            reverse(image[idx].begin(), image[idx].end());\\n            \\n            for(int jdx = 0; jdx < image[0].size(); jdx++){\\n                if(image[idx][jdx] == 0)\\n                    image[idx][jdx] = 1;\\n                else\\n                    image[idx][jdx] = 0;\\n            }\\n        }\\n        \\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        \\n        for(int idx = 0; idx < image.size(); idx++){\\n            reverse(image[idx].begin(), image[idx].end());\\n            \\n            for(int jdx = 0; jdx < image[0].size(); jdx++){\\n                if(image[idx][jdx] == 0)\\n                    image[idx][jdx] = 1;\\n                else\\n                    image[idx][jdx] = 0;\\n            }\\n        }\\n        \\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456179,
                "title": "c-soln",
                "content": "```class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int index = 0 ; index < image.size() ; index++)\\n        { \\n            reverse(image[index].begin() , image[index].end());\\n            for(int jindex = 0 ; jindex < image[0].size() ; jindex++)\\n            {\\n                image[index][jindex] =  !image[index][jindex];\\n            }\\n        }\\n        return image;\\n        \\n    }\\n};\\n\\n```\\nsimple reverse the row and then inverse each element",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int index = 0 ; index < image.size() ; index++)\\n        { \\n            reverse(image[index].begin() , image[index].end());\\n            for(int jindex = 0 ; jindex < image[0].size() ; jindex++)\\n            {\\n                image[index][jindex] =  !image[index][jindex];\\n            }\\n        }\\n        return image;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445622,
                "title": "java-simple-runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Kindly upvote if this solution helps you!\\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        for(int i =0; i< image.length; i++){\\n            int start =0, end=image[i].length -1;\\n\\t\\t\\t//Flipping\\n            while(start <= end){\\n                int temp = image[i][end];\\n                image[i][end] = image[i][start];\\n                image[i][start] = temp;\\n                start++;\\n                end--;\\n            }\\n\\t\\t\\t//Revert\\n            for(int j =0; j< image[i].length; j++){\\n                image[i][j] = (image[i][j] == 0) ? 1 : 0;\\n            }\\n        }\\n        return image;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        for(int i =0; i< image.length; i++){\\n            int start =0, end=image[i].length -1;\\n\\t\\t\\t//Flipping\\n            while(start <= end){\\n                int temp = image[i][end];\\n                image[i][end] = image[i][start];\\n                image[i][start] = temp;\\n                start++;\\n                end--;\\n            }\\n\\t\\t\\t//Revert\\n            for(int j =0; j< image[i].length; j++){\\n                image[i][j] = (image[i][j] == 0) ? 1 : 0;\\n            }\\n        }\\n        return image;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1057188,
                "title": "javascript",
                "content": "Runtime: 76 ms, faster than 98.04% of JavaScript online submissions for Flipping an Image.\\nMemory Usage: 40.6 MB, less than 40.43% of JavaScript online submissions for Flipping an Image.\\n\\n```\\nvar flipAndInvertImage = function(A) {\\n    var a = A.map((item)=> item.map((innerItem)=> innerItem===1? 0:1).reverse());\\n    return a;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar flipAndInvertImage = function(A) {\\n    var a = A.map((item)=> item.map((innerItem)=> innerItem===1? 0:1).reverse());\\n    return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000802,
                "title": "runtime-92-85-faster-memory-86-81-simple-walk-through",
                "content": "class Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        \\n\\t\\t# Creating horizontally flipped array\\n\\t\\thoriz = []\\n\\t\\tfor row in A:\\n\\t\\t\\t\\thoriz.append(row[::-1])\\n\\t\\t\\n\\t\\t# Since it is a binary matrix, you can subtract 1 to change 1s to 0s. \\n\\t\\t# Your 0s will become -1s  once you subtract 1 so you will need to use absolute value.\\n\\t\\tfor i in range(len(horiz)):\\n\\t\\t\\t\\thoriz[i] = [abs(x-1) for x in horiz[i]]\\n\\n\\t\\treturn horiz",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "class Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        \\n\\t\\t# Creating horizontally flipped array\\n\\t\\thoriz = []\\n\\t\\tfor row in A:\\n\\t\\t\\t\\thoriz.append(row[::-1])\\n\\t\\t\\n\\t\\t# Since it is a binary matrix, you can subtract 1 to change 1s to 0s. \\n\\t\\t# Your 0s will become -1s  once you subtract 1 so you will need to use absolute value.\\n\\t\\tfor i in range(len(horiz)):\\n\\t\\t\\t\\thoriz[i] = [abs(x-1) for x in horiz[i]]\\n\\n\\t\\treturn horiz",
                "codeTag": "Java"
            },
            {
                "id": 930868,
                "title": "simplest-and-most-intuitive-c-solution",
                "content": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int row = A.size(), col = A[0].size();\\n        for(int i = 0; i < row; i++)        \\n            for(int j = 0; j <= (col - 1) / 2; j++)\\n            {\\n                int temp = A[i][j];\\n                A[i][j] = !A[i][col - j - 1];\\n                A[i][col - j - 1] = !temp;\\n            }\\n        \\n        return A;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int row = A.size(), col = A[0].size();\\n        for(int i = 0; i < row; i++)        \\n            for(int j = 0; j <= (col - 1) / 2; j++)\\n            {\\n                int temp = A[i][j];\\n                A[i][j] = !A[i][col - j - 1];\\n                A[i][col - j - 1] = !temp;\\n            }\\n        \\n        return A;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 930805,
                "title": "flipping-an-image-java-updated",
                "content": "```\\nclass Solution \\n{\\n    /* Pretty straight foreword.  Grab one row from the matrix at a time.  Set a pointer to the \\n     * first element and the last element in the row.  If the elements pointed at are of different\\n     * values performing a swap would flip the values in the first and last pointers, then \\n     * performing an invert would flip them back.  It would be as though nothing had happened.  If\\n     * both the first and last values are the same the swap would maintain the value and the \\n     * invert would flip them.  They\\'re the same so no need to swap, just flip thier values.  Then\\n     * update pointers one step towords the center.\\n     */\\n    \\n    public int[][] flipAndInvertImage(int[][] A) \\n    {\\n        for( int[] r : A )\\n        {\\n            int     i = -1;\\n            int     j = r.length;\\n            \\n            while( ++i <= --j )\\n            {\\n                if( r[ i ] == r[ j ] )\\n                {\\n                    r[ j ] = r[ i ] = 1 ^ r[ i ];\\n                }\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    /* Pretty straight foreword.  Grab one row from the matrix at a time.  Set a pointer to the \\n     * first element and the last element in the row.  If the elements pointed at are of different\\n     * values performing a swap would flip the values in the first and last pointers, then \\n     * performing an invert would flip them back.  It would be as though nothing had happened.  If\\n     * both the first and last values are the same the swap would maintain the value and the \\n     * invert would flip them.  They\\'re the same so no need to swap, just flip thier values.  Then\\n     * update pointers one step towords the center.\\n     */\\n    \\n    public int[][] flipAndInvertImage(int[][] A) \\n    {\\n        for( int[] r : A )\\n        {\\n            int     i = -1;\\n            int     j = r.length;\\n            \\n            while( ++i <= --j )\\n            {\\n                if( r[ i ] == r[ j ] )\\n                {\\n                    r[ j ] = r[ i ] = 1 ^ r[ i ];\\n                }\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843714,
                "title": "java-simplest-in-place-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    // helper function to reverse array in-place:\\n    void rev(int[] A) {\\n        for(int i = 0; i < A.length / 2; i++)\\n        {\\n            int temp = A[i];\\n            A[i] = A[A.length - i - 1];\\n            A[A.length - i - 1] = temp;\\n        }\\n    }\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i=0; i<A.length; i++) {\\n            rev(A[i]); // reverse the array\\n            for (int j=0; j<A[i].length; j++) { // flip\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // helper function to reverse array in-place:\\n    void rev(int[] A) {\\n        for(int i = 0; i < A.length / 2; i++)\\n        {\\n            int temp = A[i];\\n            A[i] = A[A.length - i - 1];\\n            A[A.length - i - 1] = temp;\\n        }\\n    }\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i=0; i<A.length; i++) {\\n            rev(A[i]); // reverse the array\\n            for (int j=0; j<A[i].length; j++) { // flip\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720753,
                "title": "java-solution-0ms",
                "content": "```\\npublic int[][] flipAndInvertImage(int[][] A) {\\n        int[][] result = new int[A.length][A[0].length];\\n        \\n        for(int i = 0; i < A.length; i++){\\n            for(int j = A[i].length-1; j >= 0; j--){\\n                result[i][(A[i].length-1) - j] = A[i][j] ^ 1;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] A) {\\n        int[][] result = new int[A.length][A[0].length];\\n        \\n        for(int i = 0; i < A.length; i++){\\n            for(int j = A[i].length-1; j >= 0; j--){\\n                result[i][(A[i].length-1) - j] = A[i][j] ^ 1;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709751,
                "title": "python-simple-short-solution",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(A)):\\n            A[i] = list(map(lambda x: x^1,(A[i])))[::-1]\\n        \\n        return A",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(A)):\\n            A[i] = list(map(lambda x: x^1,(A[i])))[::-1]\\n        \\n        return A",
                "codeTag": "Java"
            },
            {
                "id": 688789,
                "title": "c-solution",
                "content": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n\\tfor (auto& v : A) {\\n\\t\\treverse(v.begin(), v.end());\\n\\t\\tfor (auto& n : v)\\n\\t\\t\\tn = !n;\\n\\t}\\n\\treturn A;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n\\tfor (auto& v : A) {\\n\\t\\treverse(v.begin(), v.end());\\n\\t\\tfor (auto& n : v)\\n\\t\\t\\tn = !n;\\n\\t}\\n\\treturn A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601504,
                "title": "4-ms-faster-than-100-00-of-c-1-pass-solution",
                "content": "Let us Make an observation for following row [1,0,1,1]\\n\\n1)After row is reversed [1,0,1,1] -> [1,1,0,1]\\n2)After inversion [1,1,0,1]->[0,0,1,0]\\n\\nCompleted process is\\nA=[1,0,1,1] -> [1,1,0,1]->[0,0,1,0]\\n\\nLets take index i=0 and j = len-1 = 3\\nA[i] = 1 and A[j] = 1 initially and their final values are A[i] = 0 A[j] = 0 \\nfor i = 0 and j = 2\\nA[i] =0 and A[j] = 1 initially and their final vales are A[i] = 0 A[j] = 1\\n\\n1)We can observe that when both the **values are same** there is no point in swaping to get reverse hence just **flipping the bits** is enough\\n2)If the values are different such as 0,1 or 1,0 after they are reversed they become 1,0 and o,1 and then after flipping them become 0,1 and 1,0 which are its initial values.Hence we **do not need to make any change** for these values.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int n = A.size();\\n        int m = A[0].size();\\n        int j,i;\\n        for(int k=0;k<n;k++)\\n        {\\n            i = 0;\\n            j = m-1;\\n            while(i<j)\\n            {\\n                if(A[k][i]==A[k][j]) // As bits are same we flip the bits using XOR operation\\n                {\\n                    A[k][i]^=1;\\n                    A[k][j]^=1;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if(i==j) //In case of the row length is odd flip the  middle bit  as i==j have same bit\\n                A[k][i]^=1;\\n            \\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int n = A.size();\\n        int m = A[0].size();\\n        int j,i;\\n        for(int k=0;k<n;k++)\\n        {\\n            i = 0;\\n            j = m-1;\\n            while(i<j)\\n            {\\n                if(A[k][i]==A[k][j]) // As bits are same we flip the bits using XOR operation\\n                {\\n                    A[k][i]^=1;\\n                    A[k][j]^=1;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if(i==j) //In case of the row length is odd flip the  middle bit  as i==j have same bit\\n                A[k][i]^=1;\\n            \\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500487,
                "title": "short-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int[][] FlipAndInvertImage(int[][] matrix)\\n        {\\n            \\n            for (int i = 0; i < matrix.Length; i++)\\n            {\\n                Array.Reverse(matrix[i]);\\n                for (int j = 0; j < matrix[i].Length; j++)\\n                {\\n                    matrix[i][j]++;\\n                    matrix[i][j] %= 2;\\n                }\\n            }\\n\\n            return matrix;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int[][] FlipAndInvertImage(int[][] matrix)\\n        {\\n            \\n            for (int i = 0; i < matrix.Length; i++)\\n            {\\n                Array.Reverse(matrix[i]);\\n                for (int j = 0; j < matrix[i].Length; j++)\\n                {\\n                    matrix[i][j]++;\\n                    matrix[i][j] %= 2;\\n                }\\n            }\\n\\n            return matrix;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327584,
                "title": "c-code-faster-than-100",
                "content": "```\\n\\nint** flipAndInvertImage(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes){\\n\\t*returnSize = ASize;  //\\u8FD4\\u56DE\\u5217\\u7684\\u5927\\u5C0F(\\u6709\\u5E7E\\u5217)\\n\\tint colsize = *AColSize;  //\\u884C\\u7684\\u5927\\u5C0F(\\u6709\\u5E7E\\u884C)\\n\\tint** retarr = (int**)malloc(sizeof(int*) * ASize); //\\u52D5\\u614B\\u5BA3\\u544A\\u4E00\\u500B\\u96D9\\u91CD\\u6307\\u6A19\\n\\t*returnColumnSizes = (int*)malloc(sizeof(int) * (*AColSize)); //\\u76EE\\u7684:\\u8FD4\\u56DE\\u6BCF\\u4E00\\u5217\\u6709\\u5E7E\\u884C\\n\\tfor (int i = 0; i < ASize; i ++)  //\\u5C0D\\u6BCF\\u4E00\\u5217\\u5206\\u5225\\u8655\\u7406\\n    {\\n\\t\\tint* newone = (int*)malloc(sizeof(int) * colsize);\\n\\t\\tfor (int j = 0; j < colsize; j ++) \\n        {\\n\\t\\t\\tint t = A[i][j];\\n\\t\\t\\tt^=1; //\\u5148\\u5C07t\\u76841\\u8B8A0\\uFF0C0\\u8B8A1\\u3002\\n\\t\\t\\tnewone[colsize - j - 1] = t;  //\\u4F7F\\u8A72\\u884C\\u524D\\u5F8C\\u9806\\u5E8F\\u5C0D\\u8ABF\\n\\t\\t}\\n\\t\\tretarr[i] = newone;  \\n\\t\\t(*returnColumnSizes)[i] = colsize;\\n\\t}\\n\\treturn retarr;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint** flipAndInvertImage(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes){\\n\\t*returnSize = ASize;  //\\u8FD4\\u56DE\\u5217\\u7684\\u5927\\u5C0F(\\u6709\\u5E7E\\u5217)\\n\\tint colsize = *AColSize;  //\\u884C\\u7684\\u5927\\u5C0F(\\u6709\\u5E7E\\u884C)\\n\\tint** retarr = (int**)malloc(sizeof(int*) * ASize); //\\u52D5\\u614B\\u5BA3\\u544A\\u4E00\\u500B\\u96D9\\u91CD\\u6307\\u6A19\\n\\t*returnColumnSizes = (int*)malloc(sizeof(int) * (*AColSize)); //\\u76EE\\u7684:\\u8FD4\\u56DE\\u6BCF\\u4E00\\u5217\\u6709\\u5E7E\\u884C\\n\\tfor (int i = 0; i < ASize; i ++)  //\\u5C0D\\u6BCF\\u4E00\\u5217\\u5206\\u5225\\u8655\\u7406\\n    {\\n\\t\\tint* newone = (int*)malloc(sizeof(int) * colsize);\\n\\t\\tfor (int j = 0; j < colsize; j ++) \\n        {\\n\\t\\t\\tint t = A[i][j];\\n\\t\\t\\tt^=1; //\\u5148\\u5C07t\\u76841\\u8B8A0\\uFF0C0\\u8B8A1\\u3002\\n\\t\\t\\tnewone[colsize - j - 1] = t;  //\\u4F7F\\u8A72\\u884C\\u524D\\u5F8C\\u9806\\u5E8F\\u5C0D\\u8ABF\\n\\t\\t}\\n\\t\\tretarr[i] = newone;  \\n\\t\\t(*returnColumnSizes)[i] = colsize;\\n\\t}\\n\\treturn retarr;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 310141,
                "title": "python-1-liner-with-abs",
                "content": "About 30ms \\n```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [[abs(y-1) for y in x][::-1] for x in A]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [[abs(y-1) for y in x][::-1] for x in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285571,
                "title": "c-why-is-returncolumnsizes-a-double-int-pointer",
                "content": "Since ```ASize``` is already a parameter, wouldn\\'t a 1D array (of length `ASize`) suffice to mention the length of columns for each row?\\n\\nWhy are `*returnSize`  and `returnColSize` required when `ASize` and `*AColSize` are already passed to us?",
                "solutionTags": [],
                "code": "```ASize```",
                "codeTag": "Unknown"
            },
            {
                "id": 169705,
                "title": "javascript-es6-one-liner",
                "content": "```\\nvar flipAndInvertImage = function(A) {\\n    return A.map((row) => row.reverse().map((pixel) => pixel ^ 1));\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar flipAndInvertImage = function(A) {\\n    return A.map((row) => row.reverse().map((pixel) => pixel ^ 1));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 144414,
                "title": "c-solution-in-4ms",
                "content": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** flipAndInvertImage(int** A, int ARowSize, int *AColSizes, int** columnSizes, int* returnSize) {\\n\\t*returnSize = ARowSize;\\n\\tint colsize = *AColSizes;\\n\\tint** retarr = (int**)malloc(sizeof(void*) * ARowSize);\\n\\t*columnSizes = (int*)malloc(sizeof(int) * ARowSize);\\n\\tfor (int i = 0; i < ARowSize; i ++) {\\n\\t\\tint* one = A[i];\\n\\t\\tint* newone = (int*)malloc(sizeof(int) * colsize);\\n\\t\\tfor (int j = 0; j < colsize; j ++) {\\n\\t\\t\\tint t = one[j];\\n\\t\\t\\tif (t == 1) t = 0;\\n\\t\\t\\telse t = 1;\\n\\t\\t\\tnewone[colsize - j - 1] = t;\\n\\t\\t}\\n\\t\\tretarr[i] = newone;\\n\\t\\t(*columnSizes)[i] = colsize;\\n\\t}\\n\\treturn retarr;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** flipAndInvertImage(int** A, int ARowSize, int *AColSizes, int** columnSizes, int* returnSize) {\\n\\t*returnSize = ARowSize;\\n\\tint colsize = *AColSizes;\\n\\tint** retarr = (int**)malloc(sizeof(void*) * ARowSize);\\n\\t*columnSizes = (int*)malloc(sizeof(int) * ARowSize);\\n\\tfor (int i = 0; i < ARowSize; i ++) {\\n\\t\\tint* one = A[i];\\n\\t\\tint* newone = (int*)malloc(sizeof(int) * colsize);\\n\\t\\tfor (int j = 0; j < colsize; j ++) {\\n\\t\\t\\tint t = one[j];\\n\\t\\t\\tif (t == 1) t = 0;\\n\\t\\t\\telse t = 1;\\n\\t\\t\\tnewone[colsize - j - 1] = t;\\n\\t\\t}\\n\\t\\tretarr[i] = newone;\\n\\t\\t(*columnSizes)[i] = colsize;\\n\\t}\\n\\treturn retarr;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133838,
                "title": "java-clean-and-easy-to-understand-in-7-ms",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int invertedImage[][] = new int[A.length][];\\n        for(int i = 0; i < A.length; i++)\\n        {\\n           int rev[] = reverseNum(A[i]);\\n           int inv[] = inverseNum(rev);\\n           invertedImage[i] = inv;  \\n        }\\n        return invertedImage;\\n    }\\n    \\n    private int[] reverseNum(int num[])\\n    {\\n        for(int i = 0; i < (num.length)/2; i++)\\n        {\\n            int temp = num[i];\\n            num[i]  = num[num.length - i - 1];\\n            num[num.length - i - 1] = temp;\\n        }\\n        return num;\\n    }\\n    \\n    private int[] inverseNum(int num[])\\n    {\\n        for(int i = 0; i < num.length; i++)\\n        {\\n             num[i] = num[i]^1;\\n        }\\n        return num;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int invertedImage[][] = new int[A.length][];\\n        for(int i = 0; i < A.length; i++)\\n        {\\n           int rev[] = reverseNum(A[i]);\\n           int inv[] = inverseNum(rev);\\n           invertedImage[i] = inv;  \\n        }\\n        return invertedImage;\\n    }\\n    \\n    private int[] reverseNum(int num[])\\n    {\\n        for(int i = 0; i < (num.length)/2; i++)\\n        {\\n            int temp = num[i];\\n            num[i]  = num[num.length - i - 1];\\n            num[num.length - i - 1] = temp;\\n        }\\n        return num;\\n    }\\n    \\n    private int[] inverseNum(int num[])\\n    {\\n        for(int i = 0; i < num.length; i++)\\n        {\\n             num[i] = num[i]^1;\\n        }\\n        return num;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130569,
                "title": "my-easy-5-lines-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n\\tvector<vector<int>> res(A.size());\\n\\tfor (int i = 0; i < A.size(); ++i) {\\n\\t    for (int j = A[i].size() - 1; j >= 0; --j) {\\n\\t\\tres[i].push_back(!A[i][j]);\\n\\t    }\\n\\t}\\n\\treturn res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n\\tvector<vector<int>> res(A.size());\\n\\tfor (int i = 0; i < A.size(); ++i) {\\n\\t    for (int j = A[i].size() - 1; j >= 0; --j) {\\n\\t\\tres[i].push_back(!A[i][j]);\\n\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 3088304,
                "title": "python-1-map-functools-partial-lambda-reversed-2-list-comprehension-xor-reversed-3-hybrid",
                "content": "**Solution 1: map, functools.partial, lambda, reversed**  \\nhttps://leetcode.com/submissions/detail/883403380/  \\nRuntime: **69 ms**, faster than 35.35% of Python3 online submissions for Flipping an Image.  \\nMemory Usage: 13.8 MB, less than 58.85% of Python3 online submissions for Flipping an Image.  \\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return map(partial(map, lambda x: 0 if x else 1), map(reversed, image))\\n```\\n\\n**Solution 2: list comprehension, xor, reversed**  \\nhttps://leetcode.com/submissions/detail/883408340/\\nRuntime: **50 ms**, faster than 87.19% of Python3 online submissions for Flipping an Image.  \\nMemory Usage: 13.9 MB, less than 58.85% of Python3 online submissions for Flipping an Image.  \\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [reversed([pixel^1 for pixel in row]) for row in image]\\n```\\n\\n**Solution 3: hybrid**  \\nhttps://leetcode.com/submissions/detail/883418919/  \\nRuntime: **43 ms**, faster than 98.69% of Python3 online submissions for Flipping an Image.  \\nMemory Usage: 13.9 MB, less than 58.85% of Python3 online submissions for Flipping an Image.  \\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [reversed(list(map(int, map(operator.not_, row)))) for row in image]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return map(partial(map, lambda x: 0 if x else 1), map(reversed, image))\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [reversed([pixel^1 for pixel in row]) for row in image]\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [reversed(list(map(int, map(operator.not_, row)))) for row in image]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049038,
                "title": "runtime-beats-100-memory-beats-91-26-simple-java-solution",
                "content": "# Intuition\\nThe task is to first reverse all the contents of all the sub arrays inside the given two dimentional array, then to inverse the contents of the array(ie. to replace 1 with 0 and vice versa).\\n\\n# Approach\\nInvertion is the easy part, just an if-else loop to change 1 from 0 and vice versa.\\nReversal is carried out by taking two variables each pointing to the extreme most end indices of the sub-arrays, then swapping them with the help of a temporary variable. this is carried out until the two indices variables don\\'t cross each other.\\n\\nIn case you need a detailed understanding on how the program iterates and how the value of the variables change respectively for iteration, uncomment the reference code given in the code and run. \\n\\n# Upvote if you like my solution.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int i = 0;\\n        int a = 0;\\n        int temp = 0;\\n\\n        //Reversal\\n        while(i < image.length){\\n            int b = image.length-1;\\n            while(a <= b){\\n                /*System.out.println(i);*/\\n                temp = image[i][b];\\n                image[i][b] = image[i][a];\\n                image[i][a] = temp;\\n                /*System.out.println(a+\" \"+b);*/\\n                a++;\\n                b--;\\n                /*System.out.println(a+\" \"+b);*/\\n            }\\n            a = 0;\\n            b = 0;\\n            i++;\\n        }\\n\\n//Output for reference.\\n/*for(int o=0; o<image.length; o++){\\nfor(int j=0; j<image.length; j++){\\nSystem.out.print(image[o][j]);\\n}\\nSystem.out.println();\\n}\\nSystem.out.println();*/\\n\\n        //Inverting\\n        for(int j = 0; j < image.length; j++){\\n            for(int k = 0; k < image.length; k++){\\n                if(image[j][k] == 0){\\n                    image[j][k] = 1;\\n                }else{\\n                    image[j][k] = 0;\\n                }\\n            }\\n        }\\n\\n//Output for reference.\\n/*for(int o=0; o<image.length; o++){\\nfor(int j=0; j<image.length; j++){\\nSystem.out.print(image[o][j]);\\n}\\nSystem.out.println();\\n}*/\\n\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int i = 0;\\n        int a = 0;\\n        int temp = 0;\\n\\n        //Reversal\\n        while(i < image.length){\\n            int b = image.length-1;\\n            while(a <= b){\\n                /*System.out.println(i);*/\\n                temp = image[i][b];\\n                image[i][b] = image[i][a];\\n                image[i][a] = temp;\\n                /*System.out.println(a+\" \"+b);*/\\n                a++;\\n                b--;\\n                /*System.out.println(a+\" \"+b);*/\\n            }\\n            a = 0;\\n            b = 0;\\n            i++;\\n        }\\n\\n//Output for reference.\\n/*for(int o=0; o<image.length; o++){\\nfor(int j=0; j<image.length; j++){\\nSystem.out.print(image[o][j]);\\n}\\nSystem.out.println();\\n}\\nSystem.out.println();*/\\n\\n        //Inverting\\n        for(int j = 0; j < image.length; j++){\\n            for(int k = 0; k < image.length; k++){\\n                if(image[j][k] == 0){\\n                    image[j][k] = 1;\\n                }else{\\n                    image[j][k] = 0;\\n                }\\n            }\\n        }\\n\\n//Output for reference.\\n/*for(int o=0; o<image.length; o++){\\nfor(int j=0; j<image.length; j++){\\nSystem.out.print(image[o][j]);\\n}\\nSystem.out.println();\\n}*/\\n\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868600,
                "title": "python-faster-than-97-71-memory-beats-96-95",
                "content": "# Code\\n### Credits: qiy2019, jiny2019\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        newMatrix = []\\n        for row in image:\\n            reversedRow = reversed(row)\\n            newRow = []\\n            for item in reversedRow:\\n                if item == 1: newRow.append(0)\\n                else: newRow.append(1)\\n            newMatrix.append(newRow)\\n        return newMatrix\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/17175a9a-d48f-4d01-9aeb-36bf77483609_1669957888.1098146.png)\\n![image.png](https://assets.leetcode.com/users/images/dfbc41cb-730c-4fda-8934-f44032149a83_1669957915.5076413.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        newMatrix = []\\n        for row in image:\\n            reversedRow = reversed(row)\\n            newRow = []\\n            for item in reversedRow:\\n                if item == 1: newRow.append(0)\\n                else: newRow.append(1)\\n            newMatrix.append(newRow)\\n        return newMatrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651809,
                "title": "java-easy-100-0ms-o-n",
                "content": "# Please Upvote\\n\\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        int r = image.length, c = image[0].length;\\n        int ans[][] = new int[r][c];\\n        for(int i = 0; i < r; i++)\\n            ans[i] = reverse(image[i]);\\n        return ans;\\n    }\\n    public int[] reverse(int a[]){\\n        int ans[] = new int[a.length];\\n        int n = a.length;\\n        for(int i = 0; i < n; i++)\\n            ans[i] = a[n - 1 - i] == 0 ? 1 : 0;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        int r = image.length, c = image[0].length;\\n        int ans[][] = new int[r][c];\\n        for(int i = 0; i < r; i++)\\n            ans[i] = reverse(image[i]);\\n        return ans;\\n    }\\n    public int[] reverse(int a[]){\\n        int ans[] = new int[a.length];\\n        int n = a.length;\\n        for(int i = 0; i < n; i++)\\n            ans[i] = a[n - 1 - i] == 0 ? 1 : 0;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641683,
                "title": "c-7ms-code-o-n-k-time-complexity",
                "content": "There is a two dimensional vector and it consists of a lot of subarrays. now we need to traverse the whole array using for loop and also we need to access each element of the subarrays. We have initialized the front =0 and end = image[i].size()-1, which means the size of each subarrays  that we need to traverse. \\n\\nThe question says that we need to flip the image. For flipping the image we need to reverse each element of the subarray and then changing the bits as 0 to 1 and 1 to 0.  The next i have used while loop to reverse each subarray by simply swapping it using 2 pointers. After doing this we have incremented the front part and decremented the end part.\\n\\nThe for loop that we have used in 7th line is helping us traverse through all array as whole. The first part of our question is finished.\\nNow second part of our question says that we need to reverse the bits or change the bits as 0 to 1 and 1 to 0.For that we have used a second for loop which again is traversing through an array as whole the second for loop here is simply accessing the subarray. We have used not gate and simply returned the vector \\n\\n```\\nclass Solution {\\npublic\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int front =0;\\n        int end = image[front].size()-1;\\n        for(int i=0;i<image.size();i++){\\n            front = 0;\\n            end = image[i].size()-1;\\n            while(front<=end){\\n                swap(image[i][front],image[i][end]);\\n                  front++;\\n                   end--;\\n               }\\n            }\\n         for(int i=0;i<image.size();i++){\\n             for(int j = 0; j < image[i].size();j++){\\n                 image[i][j]=!image[i][j];\\n                 \\n             }\\n         }\\n         \\n        \\n         return image;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int front =0;\\n        int end = image[front].size()-1;\\n        for(int i=0;i<image.size();i++){\\n            front = 0;\\n            end = image[i].size()-1;\\n            while(front<=end){\\n                swap(image[i][front],image[i][end]);\\n                  front++;\\n                   end--;\\n               }\\n            }\\n         for(int i=0;i<image.size();i++){\\n             for(int j = 0; j < image[i].size();j++){\\n                 image[i][j]=!image[i][j];\\n                 \\n             }\\n         }\\n         \\n        \\n         return image;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469608,
                "title": "one-pass-with-go",
                "content": "```\\nfunc flipAndInvertImage(image [][]int) [][]int {\\n    flip := func(a int) int {\\n        if a == 0 {\\n            return 1\\n        }\\n        \\n        return 0\\n    }\\n    \\n    for row := 0; row < len(image); row++ {\\n        l, r := 0, len(image[row])-1\\n        \\n        for l < r {\\n            image[row][l], image[row][r] = flip(image[row][r]), flip(image[row][l])\\n            l++\\n            r--\\n        }\\n        \\n        if l == r {\\n            image[row][r] = flip(image[row][r])\\n        }\\n    }\\n    \\n    return image\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc flipAndInvertImage(image [][]int) [][]int {\\n    flip := func(a int) int {\\n        if a == 0 {\\n            return 1\\n        }\\n        \\n        return 0\\n    }\\n    \\n    for row := 0; row < len(image); row++ {\\n        l, r := 0, len(image[row])-1\\n        \\n        for l < r {\\n            image[row][l], image[row][r] = flip(image[row][r]), flip(image[row][l])\\n            l++\\n            r--\\n        }\\n        \\n        if l == r {\\n            image[row][r] = flip(image[row][r])\\n        }\\n    }\\n    \\n    return image\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2398328,
                "title": "c-easy-to-understand-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    void change(vector<int>& arr){\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] == 0){\\n                arr[i] = 1;\\n            } else {\\n                arr[i] = 0;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i = 0; i < image.size(); i++){\\n            reverse(image[i].begin(), image[i].end());\\n            change(image[i]);\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void change(vector<int>& arr){\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] == 0){\\n                arr[i] = 1;\\n            } else {\\n                arr[i] = 0;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i = 0; i < image.size(); i++){\\n            reverse(image[i].begin(), image[i].end());\\n            change(image[i]);\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256536,
                "title": "python-very-easy-solution-simple-to-understand",
                "content": "\\n```\\n\\nflipped = []\\n\\nfor items in image:\\n\\tlst = []\\n\\tfor e in items:\\n\\t\\tif e == 1:\\n\\t\\t\\tlst.append(0)\\n\\t\\telif e == 0:\\n\\t\\t\\tlst.append(1)\\n\\tflipped.append(lst[::-1])\\n\\nreturn flipped\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nflipped = []\\n\\nfor items in image:\\n\\tlst = []\\n\\tfor e in items:\\n\\t\\tif e == 1:\\n\\t\\t\\tlst.append(0)\\n\\t\\telif e == 0:\\n\\t\\t\\tlst.append(1)\\n\\tflipped.append(lst[::-1])\\n\\nreturn flipped\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280790,
                "title": "kotlin-style-simple-one-line",
                "content": "```\\nfun flipAndInvertImage(image: Array<IntArray>) = \\n\\timage.map{ it.map{ i -> if( i == 1) 0 else 1 }.reversed()}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun flipAndInvertImage(image: Array<IntArray>) = \\n\\timage.map{ it.map{ i -> if( i == 1) 0 else 1 }.reversed()}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225285,
                "title": "32ms-python-with-comments",
                "content": "If you find this post helpful, please **Upvote** :)\\n```\\nclass Solution(object):\\n    def flipAndInvertImage(self, image):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\t\\t#create a variable to store the result\\n        result = []\\n\\t\\t#create a variable for storing the number of elements in each sublist as we need it later, saving some computation time, by declaring it as a constant\\n        length = len(image[0])\\n\\t\\t#looping through each pixel in the images list\\n        for pixel in image:\\n\\t\\t#mapping each element in the pixel with xor of 1, ^1, because it returns the opposite of 0,1!\\n\\t\\t#We also reverse the list by slicing\\n          temp = map(operator.xor,pixel,[1]*length)[::-1]\\n\\t\\t  #Add each sublist in the desired formate in the result list\\n          result.append(temp)\\n        return result\\n```\\n![image](https://assets.leetcode.com/users/images/3e28b665-f943-43f6-89b4-87068b566358_1621757552.7224703.png)\\nPlease comment if you have any doubts or suggestions :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, image):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\t\\t#create a variable to store the result\\n        result = []\\n\\t\\t#create a variable for storing the number of elements in each sublist as we need it later, saving some computation time, by declaring it as a constant\\n        length = len(image[0])\\n\\t\\t#looping through each pixel in the images list\\n        for pixel in image:\\n\\t\\t#mapping each element in the pixel with xor of 1, ^1, because it returns the opposite of 0,1!\\n\\t\\t#We also reverse the list by slicing\\n          temp = map(operator.xor,pixel,[1]*length)[::-1]\\n\\t\\t  #Add each sublist in the desired formate in the result list\\n          result.append(temp)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934987,
                "title": "c-fast-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n       vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (auto& row : A) reverse(row.begin(), row.end());\\n        for (auto& row : A) for (int& i: row) i ^= 1;\\n        return A;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n       vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (auto& row : A) reverse(row.begin(), row.end());\\n        for (auto& row : A) for (int& i: row) i ^= 1;\\n        return A;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 931245,
                "title": "python-3-solution-for-those-who-only-start-solving-leetcode-problems",
                "content": "...but it still beats 94% of all submissions.\\n\\n**Idea**:\\nFirst create a list ```flipped``` that will contain flipped rows\\nThen go through every row and every element in ```flipped``` and change ones to zeros and vice versa saving the result in ```invert```.\\n\\n```\\ndef flipAndInvertImage(A):\\n    if len(A) == 0: return []\\n    flipped = []\\n    for row in A:\\n        flipped.append(row[::-1])\\n    invert = []\\n    for row in flipped:\\n        curr = []\\n        for element in row:\\n            if element == 1:\\n                curr.append(0)\\n            else:\\n                curr.append(1)\\n        invert.append(curr)\\n    return invert\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```flipped```\n```flipped```\n```invert```\n```\\ndef flipAndInvertImage(A):\\n    if len(A) == 0: return []\\n    flipped = []\\n    for row in A:\\n        flipped.append(row[::-1])\\n    invert = []\\n    for row in flipped:\\n        curr = []\\n        for element in row:\\n            if element == 1:\\n                curr.append(0)\\n            else:\\n                curr.append(1)\\n        invert.append(curr)\\n    return invert\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 930554,
                "title": "python-one-liner-cool-clear-solution-runtime-faster-than-98-82-memory-less-than-100-00",
                "content": "\\tclass Solution:\\n\\t\\tdef flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\treturn [[num ^ 1 for num in line[::-1]] for line in A]\\n\\n        \\n\\n\\nliked? please upvote....",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\treturn [[num ^ 1 for num in line[::-1]] for line in A]\\n\\n        \\n\\n\\nliked? please upvote....",
                "codeTag": "Java"
            },
            {
                "id": 930423,
                "title": "rust-makes-this-one-too-easy",
                "content": "```\\nimpl Solution {\\n    pub fn flip_and_invert_image(mut a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        for v in a.iter_mut() {\\n            v.reverse();\\n            for l in v.iter_mut() {\\n                *l ^= 1;\\n            }\\n        }\\n        a\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn flip_and_invert_image(mut a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        for v in a.iter_mut() {\\n            v.reverse();\\n            for l in v.iter_mut() {\\n                *l ^= 1;\\n            }\\n        }\\n        a\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 930376,
                "title": "java-simplest-in-place-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    // helper function to reverse array in-place:\\n    void rev(int[] A) {\\n        for(int i = 0; i < A.length / 2; i++)\\n        {\\n            int temp = A[i];\\n            A[i] = A[A.length - i - 1];\\n            A[A.length - i - 1] = temp;\\n        }\\n    }\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i=0; i<A.length; i++) {\\n            rev(A[i]); // reverse the array\\n            for (int j=0; j<A[i].length; j++) { // flip\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // helper function to reverse array in-place:\\n    void rev(int[] A) {\\n        for(int i = 0; i < A.length / 2; i++)\\n        {\\n            int temp = A[i];\\n            A[i] = A[A.length - i - 1];\\n            A[A.length - i - 1] = temp;\\n        }\\n    }\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i=0; i<A.length; i++) {\\n            rev(A[i]); // reverse the array\\n            for (int j=0; j<A[i].length; j++) { // flip\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732337,
                "title": "c-solution-o-n-2",
                "content": "Second Solution\\n```\\nint** flipAndInvertImage(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize= ASize;\\n    *returnColumnSizes = AColSize;\\n    float col = *AColSize;\\n    col/=2;\\n    for(int i=0, tmp;i<ASize;i++)\\n        for(int j=0;j<col;j++){\\n            tmp = A[i][(*AColSize-1)-j];\\n            A[i][(*AColSize-1)-j] = !A[i][j];\\n            A[i][j] = !tmp;\\n        }\\n    return A;\\n}\\n\\n\\n\\n```\\n\\nFirst Solution\\n\\n```\\nint** flipAndInvertImage(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes){\\n    int **flipped = (int**)malloc(sizeof(int*)*(*returnSize= ASize));\\n    for(int i=0;i<ASize;i++){\\n        flipped[i] = malloc(sizeof(int)*(*(*returnColumnSizes = AColSize)));\\n        for(int j=0;j<*AColSize;j++)\\n            flipped[i][(*AColSize-1)-j] = !A[i][j];}\\n    return flipped;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** flipAndInvertImage(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize= ASize;\\n    *returnColumnSizes = AColSize;\\n    float col = *AColSize;\\n    col/=2;\\n    for(int i=0, tmp;i<ASize;i++)\\n        for(int j=0;j<col;j++){\\n            tmp = A[i][(*AColSize-1)-j];\\n            A[i][(*AColSize-1)-j] = !A[i][j];\\n            A[i][j] = !tmp;\\n        }\\n    return A;\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 507244,
                "title": "rust-1-line",
                "content": "```rust\\nimpl Solution {\\n    pub fn flip_and_invert_image(a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        a.into_iter().map(|r| r.into_iter().map(|x| x ^ 1).rev().collect::<Vec<i32>>()).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn flip_and_invert_image(a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        a.into_iter().map(|r| r.into_iter().map(|x| x ^ 1).rev().collect::<Vec<i32>>()).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 426759,
                "title": "python-1-liner-clean-and-easy-to-understand",
                "content": "```python\\ndef flipAndInvertImage(A: List[List[int]]) -> List[List[int]]:\\n      return [list(map(lambda x:1-x, reversed(l))) for l in A]\\n```",
                "solutionTags": [],
                "code": "```python\\ndef flipAndInvertImage(A: List[List[int]]) -> List[List[int]]:\\n      return [list(map(lambda x:1-x, reversed(l))) for l in A]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 367770,
                "title": "don-t-overthink-just-follow-the-description-8ms-clear-and-simple-5-lines",
                "content": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i = 0; i < A.size(); i++) {\\n            std::reverse(A[i].begin(), A[i].end()); // reverse each row\\n            for (int j = 0; j < A[i].size(); j++) {\\n                A[i][j] = A[i][j]^1; // flip the image\\n            }\\n        }\\n        return A; // return the image\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i = 0; i < A.size(); i++) {\\n            std::reverse(A[i].begin(), A[i].end()); // reverse each row\\n            for (int j = 0; j < A[i].size(); j++) {\\n                A[i][j] = A[i][j]^1; // flip the image\\n            }\\n        }\\n        return A; // return the image\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287088,
                "title": "simple-solang-solution",
                "content": "```\\nfunc flipAndInvertImage(A [][]int) [][]int {\\n    m := len(A)\\n\\tn := len(A[0])\\n\\t\\n\\tfor row:=0;row<m;row++{\\n\\t\\ti:=0\\n\\t\\tj:= n-1\\n\\t\\tfor  ; i<=j ;{\\n            A[row][i],A[row][j] = 1-A[row][j], 1-A[row][i]\\n\\t\\t\\ti++\\n\\t\\t\\tj--\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn A\\n    \\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc flipAndInvertImage(A [][]int) [][]int {\\n    m := len(A)\\n\\tn := len(A[0])\\n\\t\\n\\tfor row:=0;row<m;row++{\\n\\t\\ti:=0\\n\\t\\tj:= n-1\\n\\t\\tfor  ; i<=j ;{\\n            A[row][i],A[row][j] = 1-A[row][j], 1-A[row][i]\\n\\t\\t\\ti++\\n\\t\\t\\tj--\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn A\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 241858,
                "title": "python-100-faster-1-line",
                "content": "```class Solution:\\n    def flipAndInvertImage(self, A: \\'List[List[int]]\\') -> \\'List[List[int]]\\':\\n        return [[1-j for j in i[::-1]] for i in A]",
                "solutionTags": [],
                "code": "```class Solution:\\n    def flipAndInvertImage(self, A: \\'List[List[int]]\\') -> \\'List[List[int]]\\':\\n        return [[1-j for j in i[::-1]] for i in A]",
                "codeTag": "Java"
            },
            {
                "id": 131721,
                "title": "kt-js-py3-cpp-1-liners",
                "content": "**Synopsis:**\\n\\nFlip each value `x` of each reversed `row` of the input array `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun flipAndInvertImage(A: Array<IntArray>): Array<IntArray> {\\n        return A.map{ row -> row.reversed().map{ x -> x xor 1 }.toIntArray() }.toTypedArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet flipAndInvertImage = A => A.map(row => row.reverse().map(x => x ^ 1));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        return [[x ^ 1 for x in reversed(row)] for row in A]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VVI flipAndInvertImage(VVI& A) {\\n        for (auto& row: A) {\\n            reverse(row.begin(), row.end());\\n            transform(row.begin(), row.end(), row.begin(), [&](auto x) { return x ^ 1; });\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun flipAndInvertImage(A: Array<IntArray>): Array<IntArray> {\\n        return A.map{ row -> row.reversed().map{ x -> x xor 1 }.toIntArray() }.toTypedArray()\\n    }\\n}\\n```\n```\\nlet flipAndInvertImage = A => A.map(row => row.reverse().map(x => x ^ 1));\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        return [[x ^ 1 for x in reversed(row)] for row in A]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VVI flipAndInvertImage(VVI& A) {\\n        for (auto& row: A) {\\n            reverse(row.begin(), row.end());\\n            transform(row.begin(), row.end(), row.begin(), [&](auto x) { return x ^ 1; });\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100114,
                "title": "0-ms-solution-beats-100-java-users-simple-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i=0;i<image.length;i++){\\n            int s=0,e=image.length-1;\\n            while(s<=e){\\n                int t=(image[i][s]+1)%2;\\n                image[i][s]=(image[i][e]+1)%2;\\n                image[i][e]=t;\\n                s++;\\n                e--;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i=0;i<image.length;i++){\\n            int s=0,e=image.length-1;\\n            while(s<=e){\\n                int t=(image[i][s]+1)%2;\\n                image[i][s]=(image[i][e]+1)%2;\\n                image[i][e]=t;\\n                s++;\\n                e--;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948567,
                "title": "java-code-beginners-verithanam",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int [][] res=new int[image.length][image[0].length];\\n        for(int i=0;i<image.length;i++){\\n            int n=image.length;\\n            int idx=0;\\n            for(int j=n-1;j>=0;--j){\\n                res[i][idx++]=image[i][j];\\n            }\\n\\n        }\\n        for(int i=0;i<res.length;i++){\\n            for(int j=0;j<res[0].length;j++){\\n                if(res[i][j]==0)\\n                res[i][j]=1;\\n                else\\n                res[i][j]=0;\\n\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int [][] res=new int[image.length][image[0].length];\\n        for(int i=0;i<image.length;i++){\\n            int n=image.length;\\n            int idx=0;\\n            for(int j=n-1;j>=0;--j){\\n                res[i][idx++]=image[i][j];\\n            }\\n\\n        }\\n        for(int i=0;i<res.length;i++){\\n            for(int j=0;j<res[0].length;j++){\\n                if(res[i][j]==0)\\n                res[i][j]=1;\\n                else\\n                res[i][j]=0;\\n\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835760,
                "title": "two-pointers-and-bit-manip",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis is classic tp\\nbut i had used that rule:\\n0^1=1\\n1^1=0\\n^ is xsor\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for row in image:\\n            l, r = 0, len(row) - 1\\n            while l <= r:\\n                row[l], row[r] = row[r]^1, row[l]^1\\n                r -= 1\\n                l += 1\\n        return image\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for row in image:\\n            l, r = 0, len(row) - 1\\n            while l <= r:\\n                row[l], row[r] = row[r]^1, row[l]^1\\n                r -= 1\\n                l += 1\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824997,
                "title": "fully-explained-c-code-beats-100-in-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- The given code uses a straightforward approach to flip and invert a 2D binary image. Let\\'s break down the steps of the approach:\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Helper function to reverse an array\\n    void reverseArr(int arr[], int n){\\n        int start = 0;\\n        int end = n-1;\\n        while(start < end){\\n            swap(arr[start], arr[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    // Main function to flip and invert the input image\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size(); // Get the number of rows in the image\\n        int arr[image.size()]; // Create an integer array \\'arr\\' of the same size as the number of rows in the image\\n\\n        for(int i = 0; i < n; i++){ // Iterate through each row of the image\\n\\n            for(int j = 0; j < n; j++){ // Iterate through each element of the current row\\n\\n                // Invert the value of each element in the current row\\n                if(image[i][j] == 1)\\n                    arr[j] = 0; // If the element is 1, set arr[j] to 0 (invert 1 to 0)\\n                else\\n                    arr[j] = 1; // If the element is 0, set arr[j] to 1 (invert 0 to 1)\\n            }\\n\\n            reverseArr(arr, n); // Reverse the \\'arr\\' array using the helper function\\n\\n            for(int j = 0; j < n; j++){\\n                image[i][j] = arr[j]; // Copy the reversed and inverted values back to the image row\\n            }\\n        }\\n\\n        return image; // Return the modified image after flipping and inverting each row\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Helper function to reverse an array\\n    void reverseArr(int arr[], int n){\\n        int start = 0;\\n        int end = n-1;\\n        while(start < end){\\n            swap(arr[start], arr[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    // Main function to flip and invert the input image\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size(); // Get the number of rows in the image\\n        int arr[image.size()]; // Create an integer array \\'arr\\' of the same size as the number of rows in the image\\n\\n        for(int i = 0; i < n; i++){ // Iterate through each row of the image\\n\\n            for(int j = 0; j < n; j++){ // Iterate through each element of the current row\\n\\n                // Invert the value of each element in the current row\\n                if(image[i][j] == 1)\\n                    arr[j] = 0; // If the element is 1, set arr[j] to 0 (invert 1 to 0)\\n                else\\n                    arr[j] = 1; // If the element is 0, set arr[j] to 1 (invert 0 to 1)\\n            }\\n\\n            reverseArr(arr, n); // Reverse the \\'arr\\' array using the helper function\\n\\n            for(int j = 0; j < n; j++){\\n                image[i][j] = arr[j]; // Copy the reversed and inverted values back to the image row\\n            }\\n        }\\n\\n        return image; // Return the modified image after flipping and inverting each row\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709042,
                "title": "100-easy-java-solution",
                "content": "# Intuition\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/302aa7c7-ed02-427c-8d85-9a3a4079042b_1688310427.8130434.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int [] row:image){\\n            //Reverse this array\\n            for(int i=0;i<(image[0].length +1)/2;i++)\\n            { //swap\\n             int temp=row[i] ^1;\\n             row[i]=row[image[0].length-i-1] ^ 1;\\n             row[image[0].length-i-1]=temp;\\n             \\n\\n            }\\n        \\n     }\\n     return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int [] row:image){\\n            //Reverse this array\\n            for(int i=0;i<(image[0].length +1)/2;i++)\\n            { //swap\\n             int temp=row[i] ^1;\\n             row[i]=row[image[0].length-i-1] ^ 1;\\n             row[image[0].length-i-1]=temp;\\n             \\n\\n            }\\n        \\n     }\\n     return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629365,
                "title": "pythone-one-line-solution-beats-84-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [[1 if element == 0 else 0 for element in item[::-1] ] for item in image]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [[1 if element == 0 else 0 for element in item[::-1] ] for item in image]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586877,
                "title": "easiest-c-sol",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n        }\\n        for(int i=0;i<image.size();i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                image[i][j]^=1;\\n        }\\n\\n\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n        }\\n        for(int i=0;i<image.size();i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                image[i][j]^=1;\\n        }\\n\\n\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529520,
                "title": "easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n\\n        int[][] res=new int[image.length][image.length];\\n        for(int i=0;i<image.length;i++){\\n\\n            for(int j=0;j<image[i].length;j++){\\n                if(image[i][j] ==1){\\n                    res[i][image.length-j-1]=0;\\n                } else{\\n                    res[i][image.length-j-1]=1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n\\n        int[][] res=new int[image.length][image.length];\\n        for(int i=0;i<image.length;i++){\\n\\n            for(int j=0;j<image[i].length;j++){\\n                if(image[i][j] ==1){\\n                    res[i][image.length-j-1]=0;\\n                } else{\\n                    res[i][image.length-j-1]=1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484882,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\nprivate:\\n    void reverse(vector<int> &arr) {\\n        int mid = arr.size() / 2;\\n        for (int i = 0; i < mid; i++)\\n            swap(arr[i], arr[arr.size()-1-i]);\\n    }\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for (auto &row: image) {\\n            reverse(row);\\n            for (auto &val: row)\\n                val = val == 1 ? 0 : 1;\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for inst in image:\\n            start = 0\\n            end = len(inst) - 1\\n            while start <= end:\\n                inst[start], inst[end] = inst[end], inst[start]\\n                if inst[start] == 1:\\n                    inst[start] = 0\\n                else:\\n                    inst[start] = 1\\n                if start != end:\\n                    if inst[end] == 1:\\n                        inst[end] = 0\\n                    else:\\n                        inst[end] = 1\\n                start += 1\\n                end -= 1\\n        return image\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int [][] a = new int[image.length][image[0].length];\\n        for(int i =0;i<image.length;i++){\\n            for(int j =0;j<image[i].length;j++){\\n               if(image[i][image[i].length-1-j] == 1){\\n                   a[i][j] = 0;\\n               } else {\\n                 a[i][j] = 1;   \\n               }\\n            }\\n        }        \\n        return a;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    void reverse(vector<int> &arr) {\\n        int mid = arr.size() / 2;\\n        for (int i = 0; i < mid; i++)\\n            swap(arr[i], arr[arr.size()-1-i]);\\n    }\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for (auto &row: image) {\\n            reverse(row);\\n            for (auto &val: row)\\n                val = val == 1 ? 0 : 1;\\n        }\\n        return image;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for inst in image:\\n            start = 0\\n            end = len(inst) - 1\\n            while start <= end:\\n                inst[start], inst[end] = inst[end], inst[start]\\n                if inst[start] == 1:\\n                    inst[start] = 0\\n                else:\\n                    inst[start] = 1\\n                if start != end:\\n                    if inst[end] == 1:\\n                        inst[end] = 0\\n                    else:\\n                        inst[end] = 1\\n                start += 1\\n                end -= 1\\n        return image\\n```\n```Java []\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int [][] a = new int[image.length][image[0].length];\\n        for(int i =0;i<image.length;i++){\\n            for(int j =0;j<image[i].length;j++){\\n               if(image[i][image[i].length-1-j] == 1){\\n                   a[i][j] = 0;\\n               } else {\\n                 a[i][j] = 1;   \\n               }\\n            }\\n        }        \\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477465,
                "title": "easy-multiple-user-defined-java-solution-beats-100-explained",
                "content": "# Approach\\n- To create two user defined functions that take individual arrays and return the reversed as well as flipped bits array.\\n- Loop through each array in the array of array and pass it to both reverse as well as flip functions.\\n- Each of these functions take O(n) time given there are n elements in each array of the given array of arrays.\\n- and repeating this for m number of arrays id O(m).\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i = 0;i<image.length;i++){\\n\\n            // calling the user defined function reverse for reversal of the array\\n\\n            image[i] = reverse(image[i]);\\n\\n            // calling the user define dfunction to flip the bits in the array\\n\\n            image[i] = flip(image[i]);\\n        }\\n\\n        // returns the original array of arrays as we make changes in it\\n\\n        return image;\\n    }\\n\\n    // reverse the elements of the array\\n\\n    // for elements arranged as ---> [0][1][2][3][4]\\n                    // [0] <---> [4]\\n                    // [1] <---> [3]\\n                    // [2] <---> [2]\\n\\n    public int[] reverse(int[] arr){\\n        int ind = arr.length - 1;\\n        for(int i = 0;i<arr.length;i++){\\n            if(ind >= i){    \\n                int temp = arr[i];\\n                arr[i] = arr[ind];\\n                arr[ind] = temp;\\n                ind--;\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    // flip the bits of the array\\n\\n    // for elements arranged as ---> [0][0][1][0][1]\\n            // new array ---> [1][1][0][1][0]\\n\\n    public int[] flip(int[] arr){\\n        for(int i = 0;i<arr.length;i++){\\n            if(arr[i] == 0){\\n                arr[i] = 1;\\n            }else{\\n                arr[i] = 0;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i = 0;i<image.length;i++){\\n\\n            // calling the user defined function reverse for reversal of the array\\n\\n            image[i] = reverse(image[i]);\\n\\n            // calling the user define dfunction to flip the bits in the array\\n\\n            image[i] = flip(image[i]);\\n        }\\n\\n        // returns the original array of arrays as we make changes in it\\n\\n        return image;\\n    }\\n\\n    // reverse the elements of the array\\n\\n    // for elements arranged as ---> [0][1][2][3][4]\\n                    // [0] <---> [4]\\n                    // [1] <---> [3]\\n                    // [2] <---> [2]\\n\\n    public int[] reverse(int[] arr){\\n        int ind = arr.length - 1;\\n        for(int i = 0;i<arr.length;i++){\\n            if(ind >= i){    \\n                int temp = arr[i];\\n                arr[i] = arr[ind];\\n                arr[ind] = temp;\\n                ind--;\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    // flip the bits of the array\\n\\n    // for elements arranged as ---> [0][0][1][0][1]\\n            // new array ---> [1][1][0][1][0]\\n\\n    public int[] flip(int[] arr){\\n        for(int i = 0;i<arr.length;i++){\\n            if(arr[i] == 0){\\n                arr[i] = 1;\\n            }else{\\n                arr[i] = 0;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362083,
                "title": "c-easy-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> ans = image;\\n\\n        for(int i=0;i<n;i++) {\\n            reverse(ans[i].begin(), ans[i].end());\\n            for(int j=0;j<n;j++) {\\n                ans[i][j] = !ans[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> ans = image;\\n\\n        for(int i=0;i<n;i++) {\\n            reverse(ans[i].begin(), ans[i].end());\\n            for(int j=0;j<n;j++) {\\n                ans[i][j] = !ans[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356593,
                "title": "python-solution-flipping-an-image",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Reverse each row\\n2.invert each bits\\nFirst for loop is use to reverse each row and then second for loop is use to invert the bits.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/f597ed5f-3107-43ba-ab8a-8fe40ddf5649_1680111960.2864885.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            image[i]=image[i][::-1]\\n        for i in range(len(image)):\\n            for j in range(len(image[i])):\\n                image[i][j]^=1\\n                \\n        return image\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            image[i]=image[i][::-1]\\n        for i in range(len(image)):\\n            for j in range(len(image[i])):\\n                image[i][j]^=1\\n                \\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347522,
                "title": "understandable-naive-approach-for-beginners-best-solution-1ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int row = image.length;\\n        int col = image[0].length;\\n        int[][] res = new int[row][col];\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                res[i][j] = image[i][col-j-1];\\n            }\\n        }\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                res[i][j] = res[i][j] == 1 ? 0 : 1; \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int row = image.length;\\n        int col = image[0].length;\\n        int[][] res = new int[row][col];\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                res[i][j] = image[i][col-j-1];\\n            }\\n        }\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                res[i][j] = res[i][j] == 1 ? 0 : 1; \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334894,
                "title": "flipping-an-image-c-easy-approach-fast-simple",
                "content": "**IF YOU LIKE, PLEASE UPVOTE.**\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) \\n    {\\n        for(int i = 0; i<image.size(); i++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j = 0; j<image[i].size(); j++)\\n            {\\n                image[i][j] = !image[i][j];\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) \\n    {\\n        for(int i = 0; i<image.size(); i++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j = 0; j<image[i].size(); j++)\\n            {\\n                image[i][j] = !image[i][j];\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287497,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        vector<vector<int>>ans(n);\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=image[i].size()-1;j>=0;j--)\\n            {\\n                int cur=1-image[i][j];\\n                ans[i].push_back(cur);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        vector<vector<int>>ans(n);\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=image[i].size()-1;j>=0;j--)\\n            {\\n                int cur=1-image[i][j];\\n                ans[i].push_back(cur);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152702,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        vector<vector<int>> ans;\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> v;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(image[i][j]==1)\\n                {\\n                v.push_back(0);\\n                }\\n                else if(image[i][j]==0)\\n                {\\n                v.push_back(1);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        vector<vector<int>> ans;\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> v;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(image[i][j]==1)\\n                {\\n                v.push_back(0);\\n                }\\n                else if(image[i][j]==0)\\n                {\\n                v.push_back(1);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128156,
                "title": "c-easy-approach-97-faster-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\nPlease upvote if you found it helpful!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        vector<vector<int>> ans;\\n        int n=image.size()-1;\\n        for(int i=0;i<=n;i++){\\n            vector<int> row;\\n            for(int j=n;j>=0;j--){\\n                int digit=!image[i][j];\\n                row.push_back(digit);\\n            }\\n            ans.push_back(row);\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        vector<vector<int>> ans;\\n        int n=image.size()-1;\\n        for(int i=0;i<=n;i++){\\n            vector<int> row;\\n            for(int j=n;j>=0;j--){\\n                int digit=!image[i][j];\\n                row.push_back(digit);\\n            }\\n            ans.push_back(row);\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068874,
                "title": "easy-java-solution-1ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int n = image.length;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n/2; j++){\\n                int temp = image[i][j];\\n                image[i][j] = image[i][n - j - 1];\\n                image[i][n - j - 1] = temp;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(image[i][j] == 1)\\n                    image[i][j] -= 1;\\n                else\\n                    image[i][j] += 1;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int n = image.length;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n/2; j++){\\n                int temp = image[i][j];\\n                image[i][j] = image[i][n - j - 1];\\n                image[i][n - j - 1] = temp;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(image[i][j] == 1)\\n                    image[i][j] -= 1;\\n                else\\n                    image[i][j] += 1;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020903,
                "title": "java-easy-solution-beats-100-runtime-0ms",
                "content": "\\n# Approach\\nBit Manipulation to invert each array element by taking its XOR operation with 1 because when we perform XOR operation with 1 , the digits invert i.e. 1 changes to 0 and 0 changes to 1.\\n\\nAlso, to flip the image horizontally, we use Traversal of array and Swapping technique to flip the image horizontally(i.e column wise)\\n\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n    \\n        for(int []row: image){\\n            //reverse this array\\n            for(int col=0; col<(image[0].length+1)/2; col++){\\n                //swap to flip the image horizontally and xor each digit(0 or 1) with 1 to invert it at the same time.\\n                int temp = row[col] ^ 1;\\n                row[col] = row[image[0].length - col -1] ^ 1 ;\\n                row[image[0].length - col -1] = temp;\\n       \\n            }  \\n        }\\n        return image;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n    \\n        for(int []row: image){\\n            //reverse this array\\n            for(int col=0; col<(image[0].length+1)/2; col++){\\n                //swap to flip the image horizontally and xor each digit(0 or 1) with 1 to invert it at the same time.\\n                int temp = row[col] ^ 1;\\n                row[col] = row[image[0].length - col -1] ^ 1 ;\\n                row[image[0].length - col -1] = temp;\\n       \\n            }  \\n        }\\n        return image;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925685,
                "title": "c-easy-to-understand-solution-beat-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& img) {\\n       int n=img.size(); \\n       int p;\\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<n;j++)\\n         {\\n             if(img[i][j]==0)\\n             img[i][j]=1;\\n\\n             else\\n             img[i][j]=0;\\n         }\\n     }\\n\\n      for(int i=0;i<n;i++)\\n     {    p=n-1;\\n         for(int j=0;j<p;j++)\\n         {\\n             swap(img[i][j],img[i][p]);\\n             p--;\\n\\n         }\\n     }\\nreturn img;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& img) {\\n       int n=img.size(); \\n       int p;\\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<n;j++)\\n         {\\n             if(img[i][j]==0)\\n             img[i][j]=1;\\n\\n             else\\n             img[i][j]=0;\\n         }\\n     }\\n\\n      for(int i=0;i<n;i++)\\n     {    p=n-1;\\n         for(int j=0;j<p;j++)\\n         {\\n             swap(img[i][j],img[i][p]);\\n             p--;\\n\\n         }\\n     }\\nreturn img;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873432,
                "title": "java-simple-solution-1-ms-beats-83-40",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for( int [] row : image){\\n            for(int i=0 ; i < (image[0].length + 1)/2 ;i++){\\n                int temp = row[i] ^ 1;\\n                row[i] = row[image[0].length - i -1] ^ 1;\\n                row[image[0].length - i -1] = temp;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for( int [] row : image){\\n            for(int i=0 ; i < (image[0].length + 1)/2 ;i++){\\n                int temp = row[i] ^ 1;\\n                row[i] = row[image[0].length - i -1] ^ 1;\\n                row[image[0].length - i -1] = temp;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793358,
                "title": "2-ways-c-solution-brute-force-two-pointers-o-1-space",
                "content": "Easy C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for (auto &row: image){\\n            reverse(row.begin(),row.end());\\n            for (auto &ele : row){\\n                ele= !ele;\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nTwo Pointers Approach :-\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n= image[0].size();\\n        for (int r=0; r<image.size(); r++){\\n            int i= 0; int j= n-1;\\n            while (i<=j){\\n                swap(image[r][i],image[r][j]);\\n                int t1= image[r][i]; int t2= image[r][j];\\n                image[r][i]= !t1;\\n                image[r][j]= !t2;\\n                cout<<image[r][i]<<image[r][j]<<\"     \";\\n                i++; j--;\\n            }cout<<endl;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for (auto &row: image){\\n            reverse(row.begin(),row.end());\\n            for (auto &ele : row){\\n                ele= !ele;\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n= image[0].size();\\n        for (int r=0; r<image.size(); r++){\\n            int i= 0; int j= n-1;\\n            while (i<=j){\\n                swap(image[r][i],image[r][j]);\\n                int t1= image[r][i]; int t2= image[r][j];\\n                image[r][i]= !t1;\\n                image[r][j]= !t2;\\n                cout<<image[r][i]<<image[r][j]<<\"     \";\\n                i++; j--;\\n            }cout<<endl;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2747000,
                "title": "two-pointer-c-solution-o-n-k",
                "content": "```cpp \\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& Image) {\\n        for (int i = 0; i < Image.size(); i++) { // iterating  the matrix //{ [i==0] ,[i==1]  , [i==3] }\\n            int lo = 0, hi = Image[0].size() - 1; // now in inside the row like for i = 0 [ 0, 1 , 1 ]  -- we have to make this - rev =>110 => then 001\\n            while (lo <= hi) {                                                           // ^      ^\\n                                                                                          //    ^\\n\\n                if (Image[i][lo] == Image[i][hi]) {  // P1-i=0,lo =0,hi=2 is 0==1-no l++,h--| p2 - is 1==1 yes\\n                    Image[i][lo] = 1 - Image[i][lo];//p2 - 1----> 0 chages to 0  // Image[0] = [0 0 1]\\n                    Image[i][hi] = Image[i][lo];  // // inverting the array\\n                }\\n                lo++; //simply increasing and decreasing the pointer\\n                hi--;\\n            }\\n        }\\n\\n        return Image;\\n\\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp \\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& Image) {\\n        for (int i = 0; i < Image.size(); i++) { // iterating  the matrix //{ [i==0] ,[i==1]  , [i==3] }\\n            int lo = 0, hi = Image[0].size() - 1; // now in inside the row like for i = 0 [ 0, 1 , 1 ]  -- we have to make this - rev =>110 => then 001\\n            while (lo <= hi) {                                                           // ^      ^\\n                                                                                          //    ^\\n\\n                if (Image[i][lo] == Image[i][hi]) {  // P1-i=0,lo =0,hi=2 is 0==1-no l++,h--| p2 - is 1==1 yes\\n                    Image[i][lo] = 1 - Image[i][lo];//p2 - 1----> 0 chages to 0  // Image[0] = [0 0 1]\\n                    Image[i][hi] = Image[i][lo];  // // inverting the array\\n                }\\n                lo++; //simply increasing and decreasing the pointer\\n                hi--;\\n            }\\n        }\\n\\n        return Image;\\n\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2683098,
                "title": "java-solution-using-for-loop",
                "content": "class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n         int[][] result=new int[image.length][image[0].length];\\n        for(int i=0;i<image.length;i++)\\n        {\\n            int k=image[i].length-1;\\n            for(int j=0;j<image[i].length;j++)\\n            {\\n             \\n                \\n                result[i][j]=image[i][k--];\\n             \\n                \\n            }\\n             for(int j=0;j<image[i].length;j++)\\n           {\\n               if(result[i][j]==0)\\n                   result[i][j]=1;\\n               \\n               else\\n                   result[i][j]=0;\\n           }\\n        \\n          \\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n         int[][] result=new int[image.length][image[0].length];\\n        for(int i=0;i<image.length;i++)\\n        {\\n            int k=image[i].length-1;\\n            for(int j=0;j<image[i].length;j++)\\n            {\\n             \\n                \\n                result[i][j]=image[i][k--];\\n             \\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2672265,
                "title": "pretty-simple-java-solution-flip-2-pointers-invert-make-0-to-1-and-vice-versa",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        //flip\\n        for(int i=0; i<image.length; i++){\\n            int left=0, right=image.length-1;\\n            while(left<=right){\\n                int temp = image[i][left];\\n                image[i][left] = image[i][right];\\n                image[i][right] = temp;\\n                left++;right--;\\n            }\\n        }\\n        \\n        //invert\\n        for(int i=0; i<image.length; i++){\\n            for(int j=0; j<image.length; j++){\\n                if(image[i][j]==0) image[i][j]=1;\\n                else image[i][j]=0;\\n            }\\n        }\\n        \\n        return image;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        //flip\\n        for(int i=0; i<image.length; i++){\\n            int left=0, right=image.length-1;\\n            while(left<=right){\\n                int temp = image[i][left];\\n                image[i][left] = image[i][right];\\n                image[i][right] = temp;\\n                left++;right--;\\n            }\\n        }\\n        \\n        //invert\\n        for(int i=0; i<image.length; i++){\\n            for(int j=0; j<image.length; j++){\\n                if(image[i][j]==0) image[i][j]=1;\\n                else image[i][j]=0;\\n            }\\n        }\\n        \\n        return image;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642927,
                "title": "java-easy-explained",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int i=0;i<image.length;i++)\\n        {\\n            // now we can simply reverse the array - flipping the image horizontally\\n            \\n            int start = 0;\\n            int end = image[i].length-1;\\n\\n            while(start<=end)\\n            {\\n                int temp = image[i][start]^1;   // this xor is explained below\\n                image[i][start] = image[i][end]^1;\\n                image[i][end] = temp;\\n\\n                start++;\\n                end--;\\n            }\\n        }\\n\\n        // Now instead of putting up this loop using XOR, in the above loop itself we can incorporate it\\n\\n        // for(int i=0;i<image.length;i++)\\n        // {\\n        //     for(int j=0;j<image[i].length;j++)\\n        //     {\\n        //         image[i][j] = image[i][j]^1;\\n        //         // because we know that n^1 = complement of n\\n        //     }\\n        // }\\n\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int i=0;i<image.length;i++)\\n        {\\n            // now we can simply reverse the array - flipping the image horizontally\\n            \\n            int start = 0;\\n            int end = image[i].length-1;\\n\\n            while(start<=end)\\n            {\\n                int temp = image[i][start]^1;   // this xor is explained below\\n                image[i][start] = image[i][end]^1;\\n                image[i][end] = temp;\\n\\n                start++;\\n                end--;\\n            }\\n        }\\n\\n        // Now instead of putting up this loop using XOR, in the above loop itself we can incorporate it\\n\\n        // for(int i=0;i<image.length;i++)\\n        // {\\n        //     for(int j=0;j<image[i].length;j++)\\n        //     {\\n        //         image[i][j] = image[i][j]^1;\\n        //         // because we know that n^1 = complement of n\\n        //     }\\n        // }\\n\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618687,
                "title": "just-flip-and-reverse-c",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) \\n    {\\n        vector<vector<int>>ans;\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n           vector<int>v;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(image[i][j]==0)\\n                  v.push_back(1);\\n                else\\n                   v.push_back(0);\\n            }\\n            reverse(v.begin(),v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) \\n    {\\n        vector<vector<int>>ans;\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n           vector<int>v;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(image[i][j]==0)\\n                  v.push_back(1);\\n                else\\n                   v.push_back(0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2580012,
                "title": "java-solution-brute-force",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[][] flipAndInvertImage(int[][] image) {\\n\\t\\t\\tfor(int i=0;i<image.length;i++){\\n\\t\\t\\t\\tint n=image.length-1;\\n\\t\\t\\t   int s=0;\\n\\n\\t\\t\\t\\twhile(s<n){\\n\\t\\t\\t\\t  int temp=image[i][s];\\n\\t\\t\\t\\t\\timage[i][s]=image[i][n];\\n\\t\\t\\t\\t\\timage[i][n]=temp;\\n\\t\\t\\t\\t\\ts++;\\n\\t\\t\\t\\t\\tn--;\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t   for(int j =0;j<image[0].length;j++){\\n\\t\\t\\t\\t\\t   if(image[i][j]==0)image[i][j]=1;\\n\\t\\t\\t\\t\\t   else\\n\\t\\t\\t\\t\\t   image[i][j]=0;\\n\\t\\t\\t\\t   }\\n\\t\\t\\t}\\n\\t\\t\\treturn image;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int[][] flipAndInvertImage(int[][] image) {\\n\\t\\t\\tfor(int i=0;i<image.length;i++){\\n\\t\\t\\t\\tint n=image.length-1;\\n\\t\\t\\t   int s=0;\\n\\n\\t\\t\\t\\twhile(s<n){\\n\\t\\t\\t\\t  int temp=image[i][s];\\n\\t\\t\\t\\t\\timage[i][s]=image[i][n];\\n\\t\\t\\t\\t\\timage[i][n]=temp;\\n\\t\\t\\t\\t\\ts++;\\n\\t\\t\\t\\t\\tn--;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2573890,
                "title": "java-0ms-using-two-pointers",
                "content": "Traverse through each row, and reverse the row values.\\nWhile reversing, change the values from 1 to 0, and 0 to 1.\\n\\n```java\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int[] row : image){\\n            int l = 0;\\n            int r = row.length - 1;\\n            \\n            while(l <= r) {\\n                int t = row[l] == 1 ? 0 : 1;\\n                row[l] = row[r] == 1 ? 0 : 1;\\n                row[r] = t;\\n                \\n                ++l;\\n                --r;\\n            }\\n        }\\n        \\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int[] row : image){\\n            int l = 0;\\n            int r = row.length - 1;\\n            \\n            while(l <= r) {\\n                int t = row[l] == 1 ? 0 : 1;\\n                row[l] = row[r] == 1 ? 0 : 1;\\n                row[r] = t;\\n                \\n                ++l;\\n                --r;\\n            }\\n        }\\n        \\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556694,
                "title": "js-simple-solution-o-n-2",
                "content": "```\\nvar flipAndInvertImage = function(image) {\\n    const output = [];\\n    for (let i = 0; i < image.length; i++) {\\n        output[i] = [...image[i]];\\n        for (let j = 0; j < image[i].length; j++) {\\n            output[i][j] = image[i][image[i].length - j - 1] ? 0 : 1;\\n        }\\n    }\\n    return output;\\n};\\n```\\n\\n```\\nvar flipAndInvertImage = function(image) {\\n    for (let i = 0; i < image.length; i++) {\\n        const row = [...image[i]];\\n        for (let j = 0; j < image[i].length; j++) {\\n            image[i][j] = row[image[i].length - j - 1] ? 0 : 1;\\n        }\\n    }\\n    return image;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar flipAndInvertImage = function(image) {\\n    const output = [];\\n    for (let i = 0; i < image.length; i++) {\\n        output[i] = [...image[i]];\\n        for (let j = 0; j < image[i].length; j++) {\\n            output[i][j] = image[i][image[i].length - j - 1] ? 0 : 1;\\n        }\\n    }\\n    return output;\\n};\\n```\n```\\nvar flipAndInvertImage = function(image) {\\n    for (let i = 0; i < image.length; i++) {\\n        const row = [...image[i]];\\n        for (let j = 0; j < image[i].length; j++) {\\n            image[i][j] = row[image[i].length - j - 1] ? 0 : 1;\\n        }\\n    }\\n    return image;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2548722,
                "title": "java-solution-finding-reverse-first-and-then-finding-inverse-and-storing-it-in-o-n-2",
                "content": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n\\n        int[][] res = new int[image.length][image[0].length];\\n        for(int i=0; i<image.length; i++){\\n            for(int j=0; j<image[i].length; j++){\\n                int num = image[i][image[i].length-1-j];\\n                System.out.print(num + \" \");\\n                res[i][j] = (num == 1)? 0:1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n\\n        int[][] res = new int[image.length][image[0].length];\\n        for(int i=0; i<image.length; i++){\\n            for(int j=0; j<image[i].length; j++){\\n                int num = image[i][image[i].length-1-j];\\n                System.out.print(num + \" \");\\n                res[i][j] = (num == 1)? 0:1;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2528712,
                "title": "1liner-faster-than-60-less-memory-than-98",
                "content": "```\\n/**\\n * @param {number[][]} image\\n * @return {number[][]}\\n */\\nvar flipAndInvertImage = function(image) {\\n    return image.map((x)=>x.reverse().map((y)=>y?0:1))\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * @param {number[][]} image\\n * @return {number[][]}\\n */\\nvar flipAndInvertImage = function(image) {\\n    return image.map((x)=>x.reverse().map((y)=>y?0:1))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512279,
                "title": "java-c-solution-using-xor",
                "content": "Please upvote if it helps\\n\\nJava Solution:\\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        int n=image.length,temp;\\n        boolean odd=false;\\n        if(n%2==1){\\n            odd=true;    \\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n//if different u will get same as input after invert so only checking when both are same \\n                if(image[i][j]==image[i][n-1-j]){   \\n                    image[i][j]^=1;       //changes 0 to 1 nd viseversa\\n                    image[i][n-1-j]^=1;\\n                }\\n            }\\n            if(odd){\\n                image[i][n/2]^=1;   //to invert mid in case of odd cases\\n            }\\n        }\\n        return image;\\n    }\\n```\\nC++ Solution:\\n```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size(),temp;\\n        bool odd=false;\\n        if(n%2==1){\\n            odd=true;    \\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n//if different u will get same as input after invert so only checking when both are same \\n                if(image[i][j]==image[i][n-1-j]){   \\n                    image[i][j]^=1;       //changes 0 to 1 nd viseversa\\n                    image[i][n-1-j]^=1;\\n                }\\n            }\\n            if(odd){\\n                image[i][n/2]^=1;   //to invert mid in case of odd cases\\n            }\\n        }\\n        return image;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        int n=image.length,temp;\\n        boolean odd=false;\\n        if(n%2==1){\\n            odd=true;    \\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n//if different u will get same as input after invert so only checking when both are same \\n                if(image[i][j]==image[i][n-1-j]){   \\n                    image[i][j]^=1;       //changes 0 to 1 nd viseversa\\n                    image[i][n-1-j]^=1;\\n                }\\n            }\\n            if(odd){\\n                image[i][n/2]^=1;   //to invert mid in case of odd cases\\n            }\\n        }\\n        return image;\\n    }\\n```\n```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size(),temp;\\n        bool odd=false;\\n        if(n%2==1){\\n            odd=true;    \\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n//if different u will get same as input after invert so only checking when both are same \\n                if(image[i][j]==image[i][n-1-j]){   \\n                    image[i][j]^=1;       //changes 0 to 1 nd viseversa\\n                    image[i][n-1-j]^=1;\\n                }\\n            }\\n            if(odd){\\n                image[i][n/2]^=1;   //to invert mid in case of odd cases\\n            }\\n        }\\n        return image;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2510677,
                "title": "simple-java-code-100-faster",
                "content": "```\\n\\n   class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int A[]: image){\\n            swap(A);\\n            flip(A);\\n        }\\n        return image;\\n    }\\n    void swap(int A[]){\\n        int i=0,j=A.length-1;\\n        while(i<=j){\\n            int temp=A[i];\\n            A[i]=A[j];\\n            A[j]=temp;\\n            i++;\\n            j--;\\n        }\\n        \\n    }\\n    void flip(int A[]){\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==0)A[i]=1;\\n            else A[i]=0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n   class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int A[]: image){\\n            swap(A);\\n            flip(A);\\n        }\\n        return image;\\n    }\\n    void swap(int A[]){\\n        int i=0,j=A.length-1;\\n        while(i<=j){\\n            int temp=A[i];\\n            A[i]=A[j];\\n            A[j]=temp;\\n            i++;\\n            j--;\\n        }\\n        \\n    }\\n    void flip(int A[]){\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==0)A[i]=1;\\n            else A[i]=0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349250,
                "title": "cpp-solution-shortest-code-97-faster-simple-method",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        float m = image[0].size();\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0, k=m-1; j<ceil(m/2) ; j++,k--){\\n                int a = image[i][j], b = image[i][k];\\n                image[i][j] = !b;\\n                image[i][k] = !a;\\n            }\\n        }\\n        return image;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        float m = image[0].size();\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0, k=m-1; j<ceil(m/2) ; j++,k--){\\n                int a = image[i][j], b = image[i][k];\\n                image[i][j] = !b;\\n                image[i][k] = !a;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2282524,
                "title": "easiest-implementation-pure-stl-fastest-0ms",
                "content": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& images) {\\n        \\n        for(int i=0;i<images.size();i++)\\n        {\\n            replace(images[i].begin(),images[i].end(),0,2);\\n            replace(images[i].begin(),images[i].end(),1,0);\\n            replace(images[i].begin(),images[i].end(),2,1);\\n            reverse(images[i].begin(),images[i].end());\\n        }\\n        \\n        return images;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& images) {\\n        \\n        for(int i=0;i<images.size();i++)\\n        {\\n            replace(images[i].begin(),images[i].end(),0,2);\\n            replace(images[i].begin(),images[i].end(),1,0);\\n            replace(images[i].begin(),images[i].end(),2,1);\\n            reverse(images[i].begin(),images[i].end());\\n        }\\n        \\n        return images;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2165079,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n      int m=image.size();\\n        int n=image[0].size();\\n        for(int i=0;i<m;i++){\\n            reverse(image[i].begin(),image[i].end());\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                image[i][j]^=1;\\n            }\\n        }\\n        return image;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n      int m=image.size();\\n        int n=image[0].size();\\n        for(int i=0;i<m;i++){\\n            reverse(image[i].begin(),image[i].end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2153695,
                "title": "c-easiests-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int m=image.size();\\n        int n =image[0].size();\\n        for(int i=0;i<m;i++){\\n            reverse(image[i].begin(),image[i].end());\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                image[i][j]^=1;\\n}\\n    }\\n        return image;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int m=image.size();\\n        int n =image[0].size();\\n        for(int i=0;i<m;i++){\\n            reverse(image[i].begin(),image[i].end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2110936,
                "title": "100-faster-code",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& img) {\\n        vector<vector<int>> image=img;\\n        for(int i=0;i<image.size();i++)\\n        {   int l=image[i].size();\\n            int s=0;\\n            int e=l-1;\\n            while(s<=e)\\n            {   \\n                if(s==e)\\n                {\\n                    if(image[i][s]==0)\\n                        image[i][s]=1;\\n                    else\\n                        image[i][s]=0;\\n                    s++;\\n                    e--;\\n                    continue;\\n                }\\n                \\n                int temp=image[i][s];\\n                image[i][s]=image[i][e];\\n                image[i][e]=temp;\\n                \\n                if(image[i][e]==0)\\n                   image[i][e]=1;\\n                else\\n                    image[i][e]=0;\\n                if(image[i][s]==0)\\n                   image[i][s]=1;\\n                else\\n                    image[i][s]=0;\\n                s++;\\n                e--;\\n            }\\n        }\\n        \\n    return image;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& img) {\\n        vector<vector<int>> image=img;\\n        for(int i=0;i<image.size();i++)\\n        {   int l=image[i].size();\\n            int s=0;\\n            int e=l-1;\\n            while(s<=e)\\n            {   \\n                if(s==e)\\n                {\\n                    if(image[i][s]==0)\\n                        image[i][s]=1;\\n                    else\\n                        image[i][s]=0;\\n                    s++;\\n                    e--;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1965869,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        if (image == null || image.length == 0 || image[0].length == 0) {\\n            return image;\\n        }\\n\\n        for (int[] row : image) {\\n            int start = 0;\\n            int end = row.length - 1;\\n            while (start <= end) {\\n                if (row[start] == row[end]) {\\n                    row[start] ^= 1;\\n                    row[end] = row[start];\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n\\n        return image;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        if (image == null || image.length == 0 || image[0].length == 0) {\\n            return image;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1899750,
                "title": "2-c-solutions-with-detailed-explanation",
                "content": "As the question statement states that we are given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\\n\\nThe question itself states and tells us what we need .So we just follow what we need to do:\\n- We will first flip the image horizontally i.e. flip all its rows simply a reverse operation will do this task for each row or we could make our own reversal function using the two pointer approch\\n- Then we need to invert it this can be done in multiple ways like we can use ```image[i][j]=1-image[i][j] ``` or just a simple if else will also do the job ``` if(image[i][j]==0)\\n                    image[i][j]=1;\\n                else \\n                    image[i][j]=0; ```\\n\\t\\t\\t\\t\\tor a ternary operator ``` image[i][j] == 0 ? image[i][j] = 1 : image[i][j] = 0; ```\\n# Solution 1(using a traditional for loop)\\nWe just traverse the 2d matrix and reverse its rows first and than for each row check and reverse its value from 0 to 1 or viceversa.\\n```\\n  for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j=0;j<image[0].size();j++){\\n                if(image[i][j]==0)\\n                    image[i][j]=1;\\n                else \\n                    image[i][j]=0;\\n            }\\n        }\\n        return image;\\n```\\n# Solution 2 \\nA more cleaner solution using the same concept as mentioned in the above solution.\\n```\\n            for(auto &row:image){\\n\\t\\t\\treverse(row.begin(),row.end());\\n\\t\\t\\tfor(auto &j:row)    j==0?j=1:j=0;   }\\n\\t\\t\\treturn image;\\n```\\n\\nWhen we look at the TC and SC they will be :\\n- TC O(n*n) as it is a n x n binary matrix and we are iterating over the whole matrix every row and its values \\n- SC O(1) as we are not using any extra space we are just performing operations on the matrix itself",
                "solutionTags": [
                    "C"
                ],
                "code": "```image[i][j]=1-image[i][j] ```\n``` if(image[i][j]==0)\\n                    image[i][j]=1;\\n                else \\n                    image[i][j]=0; ```\n``` image[i][j] == 0 ? image[i][j] = 1 : image[i][j] = 0; ```\n```\\n  for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j=0;j<image[0].size();j++){\\n                if(image[i][j]==0)\\n                    image[i][j]=1;\\n                else \\n                    image[i][j]=0;\\n            }\\n        }\\n        return image;\\n```\n```\\n            for(auto &row:image){\\n\\t\\t\\treverse(row.begin(),row.end());\\n\\t\\t\\tfor(auto &j:row)    j==0?j=1:j=0;   }\\n\\t\\t\\treturn image;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1863127,
                "title": "python-two-pointers-the-most-standard-template-for-two-pointers",
                "content": "I would say: although those 1-liner solutions are fancy, but as a SWE, \\n**the step by step thinking with strict logic is essentially the most significant treasure and is precious.**\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \\n        def reverse(listt, left, right):\\n            \\n            while left < right:                \\n                listt[left], listt[right] = listt[right], listt[left]\\n                \\n                left += 1\\n                right -= 1\\n        \\n        \\n        # 1. reverse every list in image\\n        for listt in image:\\n            reverse(listt, 0, len(listt) - 1)\\n        \\n        # 2. invert every elements in the matrix\\n        for i in range(len(image)):\\n            for j in range(len(image[0])):\\n                \\n                if image[i][j] == 0:\\n                    image[i][j] = 1\\n                    \\n                elif image[i][j] == 1:\\n                    image[i][j] = 0\\n        \\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \\n        def reverse(listt, left, right):\\n            \\n            while left < right:                \\n                listt[left], listt[right] = listt[right], listt[left]\\n                \\n                left += 1\\n                right -= 1\\n        \\n        \\n        # 1. reverse every list in image\\n        for listt in image:\\n            reverse(listt, 0, len(listt) - 1)\\n        \\n        # 2. invert every elements in the matrix\\n        for i in range(len(image)):\\n            for j in range(len(image[0])):\\n                \\n                if image[i][j] == 0:\\n                    image[i][j] = 1\\n                    \\n                elif image[i][j] == 1:\\n                    image[i][j] = 0\\n        \\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753565,
                "title": "javascript-without-builtin-methods",
                "content": "Do not use builtin methods in such questions because it\\'s obvious they want to test your basic knowledge of how to reverse an array and inverse values in one pass.\\nAlso, always extract helper functions to make the code clearer.\\n```\\nconst reverse = (row) => {\\n    let start = 0;\\n    while (start < row.length / 2) {\\n        let end = row.length - 1 - start;\\n        let tmp = row[start] === 0 ? 1 : 0;\\n        row[start] = row[end] === 0 ? 1 : 0;\\n        row[end] = tmp;\\n        start++;\\n    }\\n}\\n\\nvar flipAndInvertImage = function(image) {\\n    const rows = image.length;\\n    for (let r = 0; r < rows; r++) {\\n        reverse(image[r])\\n    }\\n    \\n    return image;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst reverse = (row) => {\\n    let start = 0;\\n    while (start < row.length / 2) {\\n        let end = row.length - 1 - start;\\n        let tmp = row[start] === 0 ? 1 : 0;\\n        row[start] = row[end] === 0 ? 1 : 0;\\n        row[end] = tmp;\\n        start++;\\n    }\\n}\\n\\nvar flipAndInvertImage = function(image) {\\n    const rows = image.length;\\n    for (let r = 0; r < rows; r++) {\\n        reverse(image[r])\\n    }\\n    \\n    return image;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663756,
                "title": "javascript-in-memory-two-pointers-clean-code",
                "content": "```\\nvar flipAndInvertImage = function(image) {\\n    for (let i = 0; i < image.length; i++) {\\n        reverse(image[i])\\n        flip(image[i])\\n    }\\n    \\n    function reverse(array) {\\n        let firstIndex = 0\\n        let secondIndex = array.length - 1\\n        while(firstIndex < secondIndex) {\\n            swap(array, firstIndex, secondIndex)\\n            firstIndex++\\n            secondIndex--\\n        }\\n    }\\n    \\n    function flip(array) {\\n        for (let i = 0; i < array.length; i++) {\\n            array[i] = array[i] ^ 1\\n        }\\n    }    \\n    \\n    function swap(array, firstIndex, secondIndex) {\\n        let tmp = array[firstIndex]\\n        array[firstIndex] = array[secondIndex]\\n        array[secondIndex] = tmp\\n    }\\n\\n    return image\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar flipAndInvertImage = function(image) {\\n    for (let i = 0; i < image.length; i++) {\\n        reverse(image[i])\\n        flip(image[i])\\n    }\\n    \\n    function reverse(array) {\\n        let firstIndex = 0\\n        let secondIndex = array.length - 1\\n        while(firstIndex < secondIndex) {\\n            swap(array, firstIndex, secondIndex)\\n            firstIndex++\\n            secondIndex--\\n        }\\n    }\\n    \\n    function flip(array) {\\n        for (let i = 0; i < array.length; i++) {\\n            array[i] = array[i] ^ 1\\n        }\\n    }    \\n    \\n    function swap(array, firstIndex, secondIndex) {\\n        let tmp = array[firstIndex]\\n        array[firstIndex] = array[secondIndex]\\n        array[secondIndex] = tmp\\n    }\\n\\n    return image\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1636916,
                "title": "java-simple-100-faster",
                "content": "```\\n\\tpublic int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int []row : image) {\\n            int i = 0;\\n            int j = row.length-1;\\n            \\n            while(i <= j) {\\n                if(i != j) {\\n                    int t = row[i];\\n                    row[i] = row[j];\\n                    row[j] = t;\\n                    row[i] = 1 - row[i];\\n                    row[j] = 1 - row[j];\\n                } else {\\n                    row[i] = 1 - row[i];   \\n                }\\n                i++;\\n                j--;\\n                \\n            }\\n        }\\n        return image;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int []row : image) {\\n            int i = 0;\\n            int j = row.length-1;\\n            \\n            while(i <= j) {\\n                if(i != j) {\\n                    int t = row[i];\\n                    row[i] = row[j];\\n                    row[j] = t;\\n                    row[i] = 1 - row[i];\\n                    row[j] = 1 - row[j];\\n                } else {\\n                    row[i] = 1 - row[i];   \\n                }\\n                i++;\\n                j--;\\n                \\n            }\\n        }\\n        return image;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556941,
                "title": "python-very-fast-one-liner-with-nested-list-comprehension-comments",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n\\t\\t# row[::-1] reverts rows/ flips horizontally\\n\\t\\t# 1-i inverts zeros and ones\\n        return [[1-i for i in row[::-1]] for row in image]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n\\t\\t# row[::-1] reverts rows/ flips horizontally\\n\\t\\t# 1-i inverts zeros and ones\\n        return [[1-i for i in row[::-1]] for row in image]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496136,
                "title": "simple-and-easy-to-understand-for-beginners-java-solution-0ms-runtime-38-8mb-memory-usage",
                "content": "0ms runtime. \\n38.8MB memory usage.\\n\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i=0; i<image.length; i++){\\n            int start = 0;\\n            int end = image[i].length-1;\\n            while(start<end){\\n                int temp = image[i][start];\\n                image[i][start] = image[i][end];\\n                image[i][end] = temp;\\n                start++;\\n                end--;\\n            }\\n            for(int j=0; j<image[i].length; j++){\\n                if(image[i][j] == 0){\\n                    image[i][j] = 1;\\n                } else {\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i=0; i<image.length; i++){\\n            int start = 0;\\n            int end = image[i].length-1;\\n            while(start<end){\\n                int temp = image[i][start];\\n                image[i][start] = image[i][end];\\n                image[i][end] = temp;\\n                start++;\\n                end--;\\n            }\\n            for(int j=0; j<image[i].length; j++){\\n                if(image[i][j] == 0){\\n                    image[i][j] = 1;\\n                } else {\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487556,
                "title": "naive-and-optimized-approach-100-java",
                "content": "**# Naive Approach (19ms) & Optimized Solution(0ms) -- Main Concepts covered**\\n\\n***Naive Solution***\\nThe idea is simple we first have to reverse each array and then we change the each element 1-->0 & 0-->1\\n\\nFor reversing the array  we use **2-pointer apparoch**  where we keep a low and high pointer at two ends of the array and start swapping both the pointer till (low<high) and increase the low pointer by 1 (i.e. low+=1) and reduce the high pointer by 1 (i.e. high-=1) \\nNow the swap function without using temporary varibale we have 3 common approaches :\\n1.    `x = x + y;\\n        y = x - y;\\n        x = x - y;`\\n\\t\\t\\n2.    `x = x * y; \\n        y = x / y; \\n        x = x / y; ` \\n\\t\\t**2nd approach cannot be performed as we are dealing with 1 & 0 and we might end up getting                    ArithmeticException**\\n\\t3.  Using ***Bitwise XOR*** operator which simply does the following operation **(1^1=0 , 0^0=0 , 1^0=1 , 0^1=1)**.\\n\\t\\t Eg. Code to swap x=5 i.e. (0101) and y=10 i.e. (1010)\\n\\t\\t\\t`x = x ^ y;`     x now becomes 15 (1111)\\n\\t\\t\\t`y = x ^ y;`     y becomes 5 (0101)\\n\\t\\t\\t`x = x ^ y;`   x becomes 10 (1010)\\n\\t\\t\\nAfter reversing the array we have to flip 1--->0  &  0 --->1, we do that using same bitwise XOR. \\nTo change  1-->0 and 0-->1 most elegant way is to bitwise XOR the number with 1.\\n\\t**0 ^ 1 = 1\\n\\t1 ^ 1 = 0**\\n\\n**Naive Solution :- Time complexity: O(n^3)  Space Complexity: O(n^2)**\\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n            for(int i=0;i<image.length;i++){\\n            int low=0;\\n            int high=image[i].length-1;\\n            while(low<high){\\n            swap(image[i][low],image[i][high],image,i,low,high);\\n            low++;\\n            high--;\\n            }\\n            for(int j=0;j<image[i].length;j++){\\n                image[i][j]=image[i][j]^1;\\n            }\\n        }\\n        return image;\\n    }\\n    public static void swap(int a,int b,int image[][],int i,int low,int high){\\n        System.out.println(a+\" \"+b);\\n        a=a+b;\\n        b=a-b;\\n        a=a-b;\\n        image[i][low]=a;\\n        image[i][high]=b;\\n    }\\n```\\n\\n**Optimized Solution Time Complexity : O(n^2) Space Complexity : O(n^2)**\\n\\nHere we again use 2 pointer to check the two ends of the array whether they are same or not. If same we store the XOR at these pointer places and move the pointer respectively as mentioned above.\\n\\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n\\t\\tint len=image.length;\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j*2<image[i].length;j++){\\n                if(image[i][j]==image[i][len-j-1]){\\n                    image[i][len-j-1]^=1;\\n                    image[i][j]=image[i][len-j-1];\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n```\\n\\n**Understanding the naive approach helps in breaking the problem into smaller problems which eventually helps in understanding how it can be optimized. of how code work is important\\nUpvote if  it was helpful \\uD83D\\uDC4D.**\\n\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n            for(int i=0;i<image.length;i++){\\n            int low=0;\\n            int high=image[i].length-1;\\n            while(low<high){\\n            swap(image[i][low],image[i][high],image,i,low,high);\\n            low++;\\n            high--;\\n            }\\n            for(int j=0;j<image[i].length;j++){\\n                image[i][j]=image[i][j]^1;\\n            }\\n        }\\n        return image;\\n    }\\n    public static void swap(int a,int b,int image[][],int i,int low,int high){\\n        System.out.println(a+\" \"+b);\\n        a=a+b;\\n        b=a-b;\\n        a=a-b;\\n        image[i][low]=a;\\n        image[i][high]=b;\\n    }\\n```\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n\\t\\tint len=image.length;\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j*2<image[i].length;j++){\\n                if(image[i][j]==image[i][len-j-1]){\\n                    image[i][len-j-1]^=1;\\n                    image[i][j]=image[i][len-j-1];\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313425,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i = 0; i < image.size(); i++) {\\n            reverse(image[i].begin(), image[i].end());\\n            for(int j = 0; j < image[i].size(); j++) image[i][j] ^= 1;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i = 0; i < image.size(); i++) {\\n            reverse(image[i].begin(), image[i].end());\\n            for(int j = 0; j < image[i].size(); j++) image[i][j] ^= 1;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313100,
                "title": "python-fast-and-simple-one-liner",
                "content": "Here\\'s the solution:\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [[0 if x==1 else 1 for x in row[::-1]] for row in image]\\n```\\nExplanation:\\n`row[::-1]]` - reverses the list\\n`[0 if x==1 else 1 for x in LIST]` - changes zeros to ones and vice versa for the given LIST. You could also use `1-x` or `1^x`, which would give the same result.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [[0 if x==1 else 1 for x in row[::-1]] for row in image]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287794,
                "title": "python3-96-time-one-liner-with-list-comprehension-explained",
                "content": "First thing is to reverse each item in image with this simple list comprehension:\\n`flipped = [item[::-1] for item in image]` where [::-1] reverse the list\\n\\nThen one can use a short if for each item inside the image with\\n`[0 if n else 1 for n in i]`\\nThis work because n can be only 1 or 0 so it can be use instead of True or False\\n\\nThis list have to be inserted inside another list comprehension who cycle trought all list in image:\\n`inverted = [[0 if n else 1 for n in i] for i in flipped]`\\n\\nThen all this list can be joined togheder in this way:\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \\n        return [[0 if n else 1 for n in i] for i in [item[::-1] for item in image]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \\n        return [[0 if n else 1 for n in i] for i in [item[::-1] for item in image]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257679,
                "title": "java-solution-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int[][] ar = new int[image.length][image.length];\\n        for(int i=0; i<image.length; i++) {\\n            int[]temp_ar = new int[image.length];\\n            for(int j=image.length-1,k=0; j>=0; j--) {      //flipping and reversing at the same time\\n                if(image[i][j]==0) {\\n                    temp_ar[k] = 1;\\n                }\\n                k++;\\n            }\\n            ar[i] = temp_ar;\\n        }\\n        return ar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int[][] ar = new int[image.length][image.length];\\n        for(int i=0; i<image.length; i++) {\\n            int[]temp_ar = new int[image.length];\\n            for(int j=image.length-1,k=0; j>=0; j--) {      //flipping and reversing at the same time\\n                if(image[i][j]==0) {\\n                    temp_ar[k] = 1;\\n                }\\n                k++;\\n            }\\n            ar[i] = temp_ar;\\n        }\\n        return ar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060969,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for(int[] arr:A)\\n        {\\n            int j = 0;\\n            int i = arr.length-1;\\n            while(j<i)\\n            {\\n                int temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n                i--;\\n                j++;\\n            }\\n        }\\n        \\n        for(int[] arr:A)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]==1)\\n                    arr[i] = 0;\\n                else\\n                    arr[i] = 1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for(int[] arr:A)\\n        {\\n            int j = 0;\\n            int i = arr.length-1;\\n            while(j<i)\\n            {\\n                int temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n                i--;\\n                j++;\\n            }\\n        }\\n        \\n        for(int[] arr:A)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]==1)\\n                    arr[i] = 0;\\n                else\\n                    arr[i] = 1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930883,
                "title": "efficient-scala-solution",
                "content": "```scala\\ndef flipAndInvertImage(A: Array[Array[Int]]): Array[Array[Int]] = \\n  A.map(_.view.map(_ ^ 1).reverse.toArray)\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ndef flipAndInvertImage(A: Array[Array[Int]]): Array[Array[Int]] = \\n  A.map(_.view.map(_ ^ 1).reverse.toArray)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 930518,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        return [[1-e for e in reversed(row)] for row in A]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        return [[1-e for e in reversed(row)] for row in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835269,
                "title": "c-simple-and-clean",
                "content": "Inverse only if values on both ends of the row are same:\\n\\n```\\npublic class Solution {\\n    public int[][] FlipAndInvertImage(int[][] A) {\\n        foreach(int[] row in A)\\n        {\\n            int i = 0, j = row.Length-1;\\n            while(i <= j)\\n            {\\n                if(row[i] == row[j])\\n                    row[i] = row[j] ^=1;\\n                i++;\\n                j--;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] FlipAndInvertImage(int[][] A) {\\n        foreach(int[] row in A)\\n        {\\n            int i = 0, j = row.Length-1;\\n            while(i <= j)\\n            {\\n                if(row[i] == row[j])\\n                    row[i] = row[j] ^=1;\\n                i++;\\n                j--;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650612,
                "title": "java-0ms-faster-than-100-00-of-java-o-m-n-simple-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int[][] result = new int[A.length][A.length];\\n        for (int i = 0; i < A.length; i++) {\\n            int j = 0;\\n            int k = A.length - 1;\\n            while (j < A.length && k >= 0) {\\n                result[i][j] = A[i][k] == 0 ? 1 : 0;\\n                j++;\\n                k--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int[][] result = new int[A.length][A.length];\\n        for (int i = 0; i < A.length; i++) {\\n            int j = 0;\\n            int k = A.length - 1;\\n            while (j < A.length && k >= 0) {\\n                result[i][j] = A[i][k] == 0 ? 1 : 0;\\n                j++;\\n                k--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638219,
                "title": "javascript-one-liners",
                "content": "```\\n// One-Liners\\nconst flipAndInvertImage = A => A.map(arr => arr.reverse().map(num => num === 0 ? 1 : 0));\\n\\n// Faster\\nconst flipAndInvertImage = A => {\\n  for (arr of A) {\\n    let x = Math.round(arr.length / 2)\\n    for (i = 0 ; i < x; i++) {\\n      let y = arr[i] === 0 ? 1 : 0;\\n      arr[i] = arr[arr.length - 1 - i] === 0 ? 1 : 0;\\n      arr[arr.length - 1 - i] = y;\\n    }\\n  }\\n  return A;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/metha/image_1589774165.png)\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// One-Liners\\nconst flipAndInvertImage = A => A.map(arr => arr.reverse().map(num => num === 0 ? 1 : 0));\\n\\n// Faster\\nconst flipAndInvertImage = A => {\\n  for (arr of A) {\\n    let x = Math.round(arr.length / 2)\\n    for (i = 0 ; i < x; i++) {\\n      let y = arr[i] === 0 ? 1 : 0;\\n      arr[i] = arr[arr.length - 1 - i] === 0 ? 1 : 0;\\n      arr[arr.length - 1 - i] = y;\\n    }\\n  }\\n  return A;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568803,
                "title": "python3-solution-beats-99",
                "content": "Notice:\\n1. Reverse the list inside by list[::-1] than traverse it is much faster than traverse the list reversely by using reverse index straightforward in this question\\n2. Bitwise method is faster than decimal computation in most cases\\n\\nCode:\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        ans = []\\n        for item in A:\\n            inside = []\\n            item = item[::-1]\\n            for digit in item:\\n\\t\\t\\t\\t# bitwise method ,equal to inside.append(1 - digit) in this problem\\n                inside.append(digit ^ 1)\\n            ans.append(inside)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        ans = []\\n        for item in A:\\n            inside = []\\n            item = item[::-1]\\n            for digit in item:\\n\\t\\t\\t\\t# bitwise method ,equal to inside.append(1 - digit) in this problem\\n                inside.append(digit ^ 1)\\n            ans.append(inside)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508595,
                "title": "python-oneliner-fast-90-and-easy-to-understand",
                "content": "While it\\'s only a single line of code, logically it can be divided into 3 tasks:\\n\\n1. \" ... for l in A\" - this part reads matrix X line by line\\n2. \" ... for i in l[::-1]\" - this part return numbers in a line in reverse order\\n3. \" ... int (not i) \" - this part swaps 0s and 1s\\n\\nThe [ [ ... ] ... ] structure is used to form a return 2d matrix.\\n\\nThis is pretty much it.\\n\\n```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [ [ int (not i) for i in l[::-1] ] for l in A ]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [ [ int (not i) for i in l[::-1] ] for l in A ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448725,
                "title": "python-using-list-comprehensions",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        rev = [row[::-1] for row in A]\\n        inv = [[int(not x) for x in row] for row in rev]\\n        return inv\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        rev = [row[::-1] for row in A]\\n        inv = [[int(not x) for x in row] for row in rev]\\n        return inv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425928,
                "title": "simple-and-elegant-java-solution",
                "content": "##### Refresher\\n##### Bitwise Operations\\n* 1 ^ 1 = 0\\n* 0 ^ 1 = 1\\n```java\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        // base case \\n        if(A == null || A[0].length != A.length) return null;\\n        \\n        int len = A.length;\\n        int b = A[0].length;\\n        \\n        // iterate through all the rows\\n        for(int i=0; i<len; i++) {\\n            // iterate only half through the columns as the remainder will undo what \\n\\t\\t\\t// we did and return back the original input with inverted values\\n            for(int j=0; j<b/2; j++) {\\n                int temp = A[i][b-j-1];\\n\\t\\t\\t\\t// apply bitwise operation to invert the values\\n                A[i][b-j-1] = A[i][j] ^ 1;\\n                A[i][j] = temp ^ 1;\\n            }\\n             \\n            // if the matrix is odd in length then we\\'d skip the middle element as per the above logic,\\n\\t\\t\\t// so inverting the value explicitly\\n            if(len%2 == 1) {\\n                A[i][len/2] = A[i][len/2] ^ 1;\\n            }\\n        }\\n        \\n        return A;\\n    }\\n```\\n#### Complexity Analysis\\n* Time Complexity: O(m * n), where m is the no of columns and n is the number of rows\\n* Space Complexity: O(m * n)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```java\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        // base case \\n        if(A == null || A[0].length != A.length) return null;\\n        \\n        int len = A.length;\\n        int b = A[0].length;\\n        \\n        // iterate through all the rows\\n        for(int i=0; i<len; i++) {\\n            // iterate only half through the columns as the remainder will undo what \\n\\t\\t\\t// we did and return back the original input with inverted values\\n            for(int j=0; j<b/2; j++) {\\n                int temp = A[i][b-j-1];\\n\\t\\t\\t\\t// apply bitwise operation to invert the values\\n                A[i][b-j-1] = A[i][j] ^ 1;\\n                A[i][j] = temp ^ 1;\\n            }\\n             \\n            // if the matrix is odd in length then we\\'d skip the middle element as per the above logic,\\n\\t\\t\\t// so inverting the value explicitly\\n            if(len%2 == 1) {\\n                A[i][len/2] = A[i][len/2] ^ 1;\\n            }\\n        }\\n        \\n        return A;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 424808,
                "title": "very-clean-python-solution",
                "content": "```\\ndef flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\treturn [[0 if x else 1 for x in reversed(row)] for row in A]\\n```",
                "solutionTags": [],
                "code": "```\\ndef flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\treturn [[0 if x else 1 for x in reversed(row)] for row in A]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 418184,
                "title": "python-1-line",
                "content": "Merely a good problem to practice list comprehension\\n\\n```\\nreturn [[1-x for x in row[::-1] ] for row in A]\\n```",
                "solutionTags": [],
                "code": "```\\nreturn [[1-x for x in row[::-1] ] for row in A]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358992,
                "title": "java-one-pass-beats-100",
                "content": "While we can do it in-place, it will require some extra work for exchanging elements. Actually faster will be to create new matrix directly with correct values. Also usually resulting structure doesn\\'t count as an extra space.\\n\\n```\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int rows = A.length;\\n        int cols = A[0].length;\\n        \\n        int[][] res = new int[rows][cols];\\n        \\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++ ) {\\n                res[r][cols - 1 - c] = A[r][c] == 1 ? 0 : 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int rows = A.length;\\n        int cols = A[0].length;\\n        \\n        int[][] res = new int[rows][cols];\\n        \\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++ ) {\\n                res[r][cols - 1 - c] = A[r][c] == 1 ? 0 : 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566528,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1671031,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1572003,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1984748,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1710712,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1916702,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1844702,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1787276,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1743797,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1740762,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1566528,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1671031,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1572003,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1984748,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1710712,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1916702,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1844702,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1787276,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1743797,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1740762,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Moves to Reach Target with Rotations",
        "question_content": "<p>In an&nbsp;<code>n*n</code>&nbsp;grid, there is a snake that spans 2 cells and starts moving from the top left corner at <code>(0, 0)</code> and <code>(0, 1)</code>. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at&nbsp;<code>(n-1, n-2)</code>&nbsp;and&nbsp;<code>(n-1, n-1)</code>.</p>\n\n<p>In one move the snake can:</p>\n\n<ul>\n\t<li>Move one cell to the right&nbsp;if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li>\n\t<li>Move down one cell&nbsp;if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li>\n\t<li>Rotate clockwise if it&#39;s in a horizontal position and the two cells under it are both empty. In that case the snake moves from&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r, c+1)</code>&nbsp;to&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r+1, c)</code>.<br />\n\t<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/24/image-2.png\" style=\"width: 300px; height: 134px;\" /></li>\n\t<li>Rotate counterclockwise&nbsp;if it&#39;s in a vertical position and the two cells to its right are both empty. In that case the snake moves from&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r+1, c)</code>&nbsp;to&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r, c+1)</code>.<br />\n\t<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/24/image-1.png\" style=\"width: 300px; height: 121px;\" /></li>\n</ul>\n\n<p>Return the minimum number of moves to reach the target.</p>\n\n<p>If there is no way to reach the target, return&nbsp;<code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/24/image.png\" style=\"width: 400px; height: 439px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,0,0,0,0,1],\n               [1,1,0,0,1,0],\n&nbsp;              [0,0,0,0,1,1],\n&nbsp;              [0,0,1,0,1,0],\n&nbsp;              [0,1,1,0,0,0],\n&nbsp;              [0,1,1,0,0,0]]\n<strong>Output:</strong> 11\n<strong>Explanation:\n</strong>One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,0,1,1,1,1],\n&nbsp;              [0,0,0,0,1,1],\n&nbsp;              [1,1,0,0,0,1],\n&nbsp;              [1,1,1,0,0,1],\n&nbsp;              [1,1,1,0,0,1],\n&nbsp;              [1,1,1,0,0,0]]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>\n\t<li>It is guaranteed that the snake starts at empty cells.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 392940,
                "title": "python-level-by-level-bfs-solution-similar-problems-listed",
                "content": "Level-by-level BFS visit can be used to solve a lot of problems of finding discrete shortest distance.\\nPlease see and vote for my solutions for these similar problems\\n[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1651394/Python-level-by-level-BFS-Solution)\\n[127. Word Ladder](https://leetcode.com/problems/word-ladder/discuss/352659/Simple-Python-BFS-solution)\\n[126. Word Ladder II](https://leetcode.com/problems/word-ladder-ii/discuss/352661/Simple-Python-BFS-solution)\\n[301. Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/discuss/327481/Python-DFS-solution-with-pruning-(28-ms-beat-99.56)-%2B-BFS-solution)\\n[317. Shortest Distance from All Buildings](https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/331983/Python-BFS-solution-(52-ms-beat-98.27))\\n[529. Minesweeper](https://leetcode.com/problems/minesweeper/discuss/1651414/python-level-by-level-bfs-solution)\\n[773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/discuss/412586/Standard-Python-BFS-solution-(level-by-level-traversal))\\n[815. Bus Routes](https://leetcode.com/problems/bus-routes/discuss/1651399/Python-Level-by-level-BFS-solution)\\n[854. K-Similar Strings](https://leetcode.com/problems/k-similar-strings/discuss/420506/Python-BFS-solution)\\n[864. Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/discuss/364604/Simple-Python-BFS-Solution-(292-ms-beat-97.78))\\n[1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313229/Python-BFS-solution)\\n[1210. Minimum Moves to Reach Target with Rotations](https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/392940/Standard-Python-BFS-solution)\\n[1263. Minimum Moves to Move a Box to Their Target Location](https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431138/Python-straightforward-BFS-solution)\\n[1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/discuss/1651383/Python-level-by-level-BFS-Solution)\\n\\n\\n```\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        start = (0, 0, 0, 1)\\n        end = (n - 1, n - 2, n - 1, n - 1)\\n        curr_level = {start}\\n        moves = 0\\n        visited = set()\\n        while curr_level:\\n            if end in curr_level:\\n                return moves\\n            next_level = set()\\n            for pos in curr_level:\\n                visited.add(pos)\\n                r1, c1, r2, c2 = pos\\n                if c1 + 1 < n and grid[r1][c1+1] == 0 and c2 + 1 < n and grid[r2][c2+1] == 0:\\n                    if (r1, c1 + 1, r2, c2 + 1) not in visited:\\n                        next_level.add((r1, c1 + 1, r2, c2 + 1))\\n                if r1 + 1 < n and grid[r1+1][c1] == 0 and r2 + 1 < n and grid[r2+1][c2] == 0:\\n                    if (r1 + 1, c1, r2 + 1, c1) not in visited:\\n                        next_level.add((r1 + 1, c1, r2 + 1, c2))\\n                if r1 == r2 and c2 == c1 + 1 and r1 + 1 < n and grid[r1+1][c1] + grid[r1+1][c1+1] == 0 :\\n                    if (r1, c1, r1 + 1, c1) not in visited:\\n                        next_level.add((r1, c1, r1 + 1, c1))\\n                if c1 == c2 and r2 == r1 + 1 and c1 + 1 < n and grid[r1][c1+1] + grid[r1+1][c1+1] == 0:\\n                    if (r1, c1, r1, c1 + 1) not in visited:\\n                        next_level.add((r1, c1, r1, c1 + 1))\\n            curr_level = next_level\\n            moves += 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        start = (0, 0, 0, 1)\\n        end = (n - 1, n - 2, n - 1, n - 1)\\n        curr_level = {start}\\n        moves = 0\\n        visited = set()\\n        while curr_level:\\n            if end in curr_level:\\n                return moves\\n            next_level = set()\\n            for pos in curr_level:\\n                visited.add(pos)\\n                r1, c1, r2, c2 = pos\\n                if c1 + 1 < n and grid[r1][c1+1] == 0 and c2 + 1 < n and grid[r2][c2+1] == 0:\\n                    if (r1, c1 + 1, r2, c2 + 1) not in visited:\\n                        next_level.add((r1, c1 + 1, r2, c2 + 1))\\n                if r1 + 1 < n and grid[r1+1][c1] == 0 and r2 + 1 < n and grid[r2+1][c2] == 0:\\n                    if (r1 + 1, c1, r2 + 1, c1) not in visited:\\n                        next_level.add((r1 + 1, c1, r2 + 1, c2))\\n                if r1 == r2 and c2 == c1 + 1 and r1 + 1 < n and grid[r1+1][c1] + grid[r1+1][c1+1] == 0 :\\n                    if (r1, c1, r1 + 1, c1) not in visited:\\n                        next_level.add((r1, c1, r1 + 1, c1))\\n                if c1 == c2 and r2 == r1 + 1 and c1 + 1 < n and grid[r1][c1+1] + grid[r1+1][c1+1] == 0:\\n                    if (r1, c1, r1, c1 + 1) not in visited:\\n                        next_level.add((r1, c1, r1, c1 + 1))\\n            curr_level = next_level\\n            moves += 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 393511,
                "title": "java-python-3-25-and-17-liner-clean-bfs-codes-w-brief-explanation-and-analysis",
                "content": "1. Use the coordinate of the snake tail (up/left part), `r, c`, and the row difference between head and tail, `dr`, to describe the position of the snake. Obviously, `dr = 0` and `dr = 1` indicate that the snake is in `horizontal` and `vertical` positions, respectively;\\n2. Use a Queue and a HashSet to perform BFS traversal and prune duplicates;\\n3. In order to create hash for HashSet, use `r + \",\" + c + \",\" + dr` to encode snake position.\\n\\n\\n```java\\n    public int minimumMoves(int[][] g) {\\n        int n = g.length;\\n        int[] start = {0, 0, 0, 0}, target = {n - 1, n - 2, 0};\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        Set<String> seen = new HashSet<>();\\n        while (!q.isEmpty()) {\\n            int[] pos = q.poll();\\n            int r = pos[0], c = pos[1], dr = pos[2], steps = pos[3];        // snake tail row, column, row difference, steps.\\n            if (Arrays.equals(Arrays.copyOf(pos, 3), target))               // reach target.\\n                return steps;\\n            if (seen.add(r + \",\" + c + \",\" + dr)) {                         // prune duplicates.\\n                if (dr == 0) {                                              // horizontal position.\\n                    if (r + 1 < n && g[r + 1][c] + g[r + 1][c + 1] == 0)    // the two cells below are empty: down and colock-wise rotation.\\n                        q.addAll(Arrays.asList(new int[]{r + 1, c, 0, steps + 1}, new int[]{r, c, 1, steps + 1}));\\n                    if (c + 2 < n && g[r][c + 2] == 0)                      // the right cell is empty.\\n                        q.offer(new int[]{r, c + 1, 0, steps + 1});         // right.\\n                }else {                                                     // vertical position.\\n                    if (c + 1 < n && g[r][c + 1] + g[r + 1][c + 1] == 0)    // the two cells right are empty: right and counterclock-wise rotation.\\n                        q.addAll(Arrays.asList(new int[]{r, c + 1, 1, steps + 1}, new int[]{r, c, 0, steps + 1}));\\n                    if (r + 2 < n && g[r + 2][c] == 0)                      // the below cell is empty.\\n                        q.offer(new int[]{r + 1, c, 1, steps + 1});         // down.\\n                }                    \\n            }\\n        }\\n        return -1;\\n    }\\n```\\n```python\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        q, seen, target = [(0, 0, 0, 0)], set(), (n - 1, n - 2, 0)              # row, column, row difference.\\n        for r, c, dr, steps in q:\\n            if (r, c, dr) == target: return steps                               # reach target.\\n            if (r, c, dr) not in seen:                                          # prune duplicates.\\n                seen.add((r, c, dr))\\n                if dr:                                                          # vertical position. \\n                    if c + 1 < n and grid[r][c + 1] + grid[r + 1][c + 1] == 0:  # the two cells right are emtpty.\\n                        q += [(r, c + 1, 1, steps + 1), (r, c, 0, steps + 1)]   # right and counter-colock-wise rotate.\\n                    if r + 2 < n and grid[r + 2][c] == 0:                       # the below cell is empty.\\n                        q += [(r + 1, c, 1, steps + 1)]                         # down.\\n                else:                                                           # horizontal position\\n                    if r + 1 < n and grid[r + 1][c] + grid[r + 1][c + 1] == 0:  # the two cells below are empty.\\n                        q += [(r + 1, c, 0, steps + 1), (r, c, 1, steps + 1)]   # down and colock-wise rotate.\\n                    if c + 2 < n and grid[r][c + 2] == 0:                       # right cell is empty.\\n                        q += [(r, c + 1, 0, steps + 1)]                         # right.\\n        return -1\\n```\\n\\n\\n\\n**Analysis:**\\n\\nFor each cell, the snake tail corresponds to at most 4 positions. Therefore,\\n\\nTime & space: `O(n ^ 2)`, where `n = grid.length`.\\n\\n----\\nBelow is the **old post content**:\\n\\nQ: why the 23rd test case expects -1, NOT 29?\\n\\nPlease give me a hand to explain why the 23rd test case expects `-1`, NOT `29`? I use `a-za-c` to indicate the snake path.\\n```\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],\\n [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,0,0,0,0,0,0,0]]\\n\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [a,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [b,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [c,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [d,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [e,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [f,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [g,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [h,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [i,k,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [j,k,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,l,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,m,O,p,q,r,s,t,u,v,0,0,0,1,0],\\n [1,n,O,p,0,0,1,0,w,w,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,x,x,y,z,a,b,c]]\\n```\\ncredit to **@QuentinHe** and **@chuckdchen**\\nA: \\nIt will fail on the first step. the snake is cornered by the two `1s` on the right and bottom `[0,3]` and `[1,1]`, you can\\'t rotate when `[1,1]` is a blocker.",
                "solutionTags": [],
                "code": "```java\\n    public int minimumMoves(int[][] g) {\\n        int n = g.length;\\n        int[] start = {0, 0, 0, 0}, target = {n - 1, n - 2, 0};\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        Set<String> seen = new HashSet<>();\\n        while (!q.isEmpty()) {\\n            int[] pos = q.poll();\\n            int r = pos[0], c = pos[1], dr = pos[2], steps = pos[3];        // snake tail row, column, row difference, steps.\\n            if (Arrays.equals(Arrays.copyOf(pos, 3), target))               // reach target.\\n                return steps;\\n            if (seen.add(r + \",\" + c + \",\" + dr)) {                         // prune duplicates.\\n                if (dr == 0) {                                              // horizontal position.\\n                    if (r + 1 < n && g[r + 1][c] + g[r + 1][c + 1] == 0)    // the two cells below are empty: down and colock-wise rotation.\\n                        q.addAll(Arrays.asList(new int[]{r + 1, c, 0, steps + 1}, new int[]{r, c, 1, steps + 1}));\\n                    if (c + 2 < n && g[r][c + 2] == 0)                      // the right cell is empty.\\n                        q.offer(new int[]{r, c + 1, 0, steps + 1});         // right.\\n                }else {                                                     // vertical position.\\n                    if (c + 1 < n && g[r][c + 1] + g[r + 1][c + 1] == 0)    // the two cells right are empty: right and counterclock-wise rotation.\\n                        q.addAll(Arrays.asList(new int[]{r, c + 1, 1, steps + 1}, new int[]{r, c, 0, steps + 1}));\\n                    if (r + 2 < n && g[r + 2][c] == 0)                      // the below cell is empty.\\n                        q.offer(new int[]{r + 1, c, 1, steps + 1});         // down.\\n                }                    \\n            }\\n        }\\n        return -1;\\n    }\\n```\n```python\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        q, seen, target = [(0, 0, 0, 0)], set(), (n - 1, n - 2, 0)              # row, column, row difference.\\n        for r, c, dr, steps in q:\\n            if (r, c, dr) == target: return steps                               # reach target.\\n            if (r, c, dr) not in seen:                                          # prune duplicates.\\n                seen.add((r, c, dr))\\n                if dr:                                                          # vertical position. \\n                    if c + 1 < n and grid[r][c + 1] + grid[r + 1][c + 1] == 0:  # the two cells right are emtpty.\\n                        q += [(r, c + 1, 1, steps + 1), (r, c, 0, steps + 1)]   # right and counter-colock-wise rotate.\\n                    if r + 2 < n and grid[r + 2][c] == 0:                       # the below cell is empty.\\n                        q += [(r + 1, c, 1, steps + 1)]                         # down.\\n                else:                                                           # horizontal position\\n                    if r + 1 < n and grid[r + 1][c] + grid[r + 1][c + 1] == 0:  # the two cells below are empty.\\n                        q += [(r + 1, c, 0, steps + 1), (r, c, 1, steps + 1)]   # down and colock-wise rotate.\\n                    if c + 2 < n and grid[r][c + 2] == 0:                       # right cell is empty.\\n                        q += [(r, c + 1, 0, steps + 1)]                         # right.\\n        return -1\\n```\n```\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],\\n [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,0,0,0,0,0,0,0]]\\n\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [a,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [b,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [c,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [d,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [e,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [f,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [g,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [h,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [i,k,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [j,k,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,l,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,m,O,p,q,r,s,t,u,v,0,0,0,1,0],\\n [1,n,O,p,0,0,1,0,w,w,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,x,x,y,z,a,b,c]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 392872,
                "title": "c-bfs",
                "content": "# Intuition\\nThis looks like BFS problem, where horizontal and vertical paths are independent (but can be transitioned to and from). So, we need to track \\'visited\\' state independently for horizontal and vertical orientations.\\n# Modified BFS\\nThis type of problems is not hard, but it could be trickly to get the code right. I created three helper functions to make it a bit easier.\\n\\n1. Use a queue to store the tail coordinates and orientation.\\n2. For every element in the queue, check the visited flag and move up, down or rotate, if possible.\\n> Here, I am using second and third bit (2 and 4) to track the state directly in the grid.\\n3. Return the number of steps in BFS if we reach the target; otherwise return ```-1```\\n```\\nbool canRotate(vector<vector<int>>& g, int i, int j) {\\n  return i < g.size() - 1 && j < g[i].size() - 1\\n    && (g[i + 1][j] & 1) == 0 && (g[i][j + 1] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nbool canGoDown(vector<vector<int>>& g, int i, int j, bool vertical) {\\n  if (vertical) return i < g.size() - 2 && (g[i + 2][j] & 1) == 0;\\n  return i < g.size() - 1 && (g[i + 1][j] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nbool canGoRight(vector<vector<int>>& g, int i, int j, bool vertical) {\\n  if (!vertical) return j < g[i].size() - 2 && (g[i][j + 2] & 1) == 0;\\n  return j < g[i].size() - 1 && (g[i][j + 1] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nint minimumMoves(vector<vector<int>>& grid, int steps = 0) {\\n  queue<array<int, 3>> q1, q2;\\n  q1.push({ 0, 0, false }); // not vertical.\\n  while (!q1.empty()) {\\n    while (!q1.empty()) {\\n      auto& a = q1.front();\\n      if (a[0] == grid.size() - 1 && a[1] == grid[a[0]].size() - 2) return steps;\\n      if ((grid[a[0]][a[1]] & (a[2] ? 2 : 4)) == 0) {\\n        grid[a[0]][a[1]] = grid[a[0]][a[1]] | (a[2] ? 2 : 4);\\n        if (canGoDown(grid, a[0], a[1], a[2])) q2.push({ a[0] + 1, a[1], a[2] });\\n        if (canGoRight(grid, a[0], a[1], a[2])) q2.push({ a[0], a[1] + 1, a[2] });\\n        if (canRotate(grid, a[0], a[1])) q2.push({ a[0], a[1], a[2] ? false : true });\\n      }\\n      q1.pop();\\n    }\\n    ++steps;\\n    swap(q1, q2);\\n  }\\n  return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```-1```\n```\\nbool canRotate(vector<vector<int>>& g, int i, int j) {\\n  return i < g.size() - 1 && j < g[i].size() - 1\\n    && (g[i + 1][j] & 1) == 0 && (g[i][j + 1] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nbool canGoDown(vector<vector<int>>& g, int i, int j, bool vertical) {\\n  if (vertical) return i < g.size() - 2 && (g[i + 2][j] & 1) == 0;\\n  return i < g.size() - 1 && (g[i + 1][j] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nbool canGoRight(vector<vector<int>>& g, int i, int j, bool vertical) {\\n  if (!vertical) return j < g[i].size() - 2 && (g[i][j + 2] & 1) == 0;\\n  return j < g[i].size() - 1 && (g[i][j + 1] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nint minimumMoves(vector<vector<int>>& grid, int steps = 0) {\\n  queue<array<int, 3>> q1, q2;\\n  q1.push({ 0, 0, false }); // not vertical.\\n  while (!q1.empty()) {\\n    while (!q1.empty()) {\\n      auto& a = q1.front();\\n      if (a[0] == grid.size() - 1 && a[1] == grid[a[0]].size() - 2) return steps;\\n      if ((grid[a[0]][a[1]] & (a[2] ? 2 : 4)) == 0) {\\n        grid[a[0]][a[1]] = grid[a[0]][a[1]] | (a[2] ? 2 : 4);\\n        if (canGoDown(grid, a[0], a[1], a[2])) q2.push({ a[0] + 1, a[1], a[2] });\\n        if (canGoRight(grid, a[0], a[1], a[2])) q2.push({ a[0], a[1] + 1, a[2] });\\n        if (canRotate(grid, a[0], a[1])) q2.push({ a[0], a[1], a[2] ? false : true });\\n      }\\n      q1.pop();\\n    }\\n    ++steps;\\n    swap(q1, q2);\\n  }\\n  return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 393791,
                "title": "c-short-bfs-no-brainer-version",
                "content": "**Observation**\\nThe two parts of the snake (head and tail) together define it\\'s position and thus we need to BFS keeping that in mind.\\n\\n**Solution**\\nSince this is a no brainer version, we keep track of visited nodes just as regular BFS keeping in mind that 1 node is defined by the 2 positions (Snake\\'s head and snake\\'s tail).\\nSince C++ doesn\\'t provide a hash function for a vector by default we can use `set<vector<int>>` (This increases the time complexity) as our way to keep track of visited nodes.\\nWe can now run a simle BFS using `queue<vector<int>>` and iterate on all possible neighbours for that node by adding them to the queue and keep repeating until we find the target or the queue gets empty.\\n```c++\\nclass Solution {\\npublic:\\n    set<vector<int>> visited;\\n    queue<vector<int>> q;\\n    void commonMoves(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[3]+1<grid.size()&&!grid[pos[2]][pos[3]+1]&&!grid[pos[0]][pos[1]+1]&&!visited.count({pos[0],pos[1]+1,pos[2],pos[3]+1}))     //Move right\\n            visited.insert({pos[0],pos[1]+1,pos[2],pos[3]+1}),q.push({pos[0],pos[1]+1,pos[2],pos[3]+1});\\n        if(pos[2]+1<grid.size()&&!grid[pos[2]+1][pos[3]]&&!grid[pos[0]+1][pos[1]]&&!visited.count({pos[0]+1,pos[1],pos[2]+1,pos[3]}))       //Move down\\n            visited.insert({pos[0]+1,pos[1],pos[2]+1,pos[3]}),q.push({pos[0]+1,pos[1],pos[2]+1,pos[3]});\\n    }\\n    void horizontal(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[0]+1<grid.size()&&!grid[pos[0]+1][pos[1]]&&!grid[pos[2]+1][pos[3]]&&!visited.count({pos[0],pos[1],pos[0]+1,pos[1]}))         //Rotate clockwise\\n            visited.insert({pos[0],pos[1],pos[0]+1,pos[1]}),q.push({pos[0],pos[1],pos[0]+1,pos[1]});\\n    }\\n    void vertical(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[1]+1<grid.size()&&!grid[pos[0]][pos[1]+1]&&!grid[pos[2]][pos[3]+1]&&!visited.count({pos[0],pos[1],pos[0],pos[1]+1}))      //Rotate counter-clockwise\\n            visited.insert({pos[0],pos[1],pos[0],pos[1]+1}),q.push({pos[0],pos[1],pos[0],pos[1]+1});\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        vector<int> target={grid.size()-1,grid.size()-2,grid.size()-1,grid.size()-1}; \\n        q.push({0,0,0,1});\\n        visited.insert({0,0,0,1});\\n        int size,moves=0;\\n        while(!q.empty())\\n        {\\n            size=q.size();\\n            while(size--)\\n            {\\n                if(q.front()==target)                             //Reached target\\n                    return moves;\\n                if(q.front()[0]==q.front()[2])                 //When snake is horizontal\\n                    horizontal(grid,q.front());\\n                else                                                   //When snake is vertical\\n                    vertical(grid,q.front());\\n\\t\\tcommonMoves(grid,q.front());                 //Common moves (Right and down)\\n                q.pop();\\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Note**\\nTo further reduce the time complexity, we can use an `unordered_set` with a custom implementation of hash function for a vector, this would reduce complexity of adding and searching on `visited` nodes from O(nlogn) to O(n).",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    set<vector<int>> visited;\\n    queue<vector<int>> q;\\n    void commonMoves(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[3]+1<grid.size()&&!grid[pos[2]][pos[3]+1]&&!grid[pos[0]][pos[1]+1]&&!visited.count({pos[0],pos[1]+1,pos[2],pos[3]+1}))     //Move right\\n            visited.insert({pos[0],pos[1]+1,pos[2],pos[3]+1}),q.push({pos[0],pos[1]+1,pos[2],pos[3]+1});\\n        if(pos[2]+1<grid.size()&&!grid[pos[2]+1][pos[3]]&&!grid[pos[0]+1][pos[1]]&&!visited.count({pos[0]+1,pos[1],pos[2]+1,pos[3]}))       //Move down\\n            visited.insert({pos[0]+1,pos[1],pos[2]+1,pos[3]}),q.push({pos[0]+1,pos[1],pos[2]+1,pos[3]});\\n    }\\n    void horizontal(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[0]+1<grid.size()&&!grid[pos[0]+1][pos[1]]&&!grid[pos[2]+1][pos[3]]&&!visited.count({pos[0],pos[1],pos[0]+1,pos[1]}))         //Rotate clockwise\\n            visited.insert({pos[0],pos[1],pos[0]+1,pos[1]}),q.push({pos[0],pos[1],pos[0]+1,pos[1]});\\n    }\\n    void vertical(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[1]+1<grid.size()&&!grid[pos[0]][pos[1]+1]&&!grid[pos[2]][pos[3]+1]&&!visited.count({pos[0],pos[1],pos[0],pos[1]+1}))      //Rotate counter-clockwise\\n            visited.insert({pos[0],pos[1],pos[0],pos[1]+1}),q.push({pos[0],pos[1],pos[0],pos[1]+1});\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        vector<int> target={grid.size()-1,grid.size()-2,grid.size()-1,grid.size()-1}; \\n        q.push({0,0,0,1});\\n        visited.insert({0,0,0,1});\\n        int size,moves=0;\\n        while(!q.empty())\\n        {\\n            size=q.size();\\n            while(size--)\\n            {\\n                if(q.front()==target)                             //Reached target\\n                    return moves;\\n                if(q.front()[0]==q.front()[2])                 //When snake is horizontal\\n                    horizontal(grid,q.front());\\n                else                                                   //When snake is vertical\\n                    vertical(grid,q.front());\\n\\t\\tcommonMoves(grid,q.front());                 //Common moves (Right and down)\\n                q.pop();\\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392904,
                "title": "java-bfs-solution-very-clean-code-easy-to-understand",
                "content": "```java\\npublic class Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        SnakePos src = new SnakePos(new Cell(0, 0), new Cell(0, 1));\\n        SnakePos dst = new SnakePos(new Cell(n - 1, n - 2), new Cell(n - 1, n - 1));\\n\\n        HashSet<String> visited = new HashSet<>();\\n        Queue<SnakePos> queue = new LinkedList<>();\\n        queue.add(src);\\n        visited.add(src.getKey());\\n\\n        ArrayList<SnakePos> nextMoves = new ArrayList<>(4);\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                SnakePos top = queue.remove();\\n                if (top.equals(dst))\\n                    return steps;\\n\\n                nextMoves.clear();\\n                nextMoves.add(tryMoveRight(top, grid));\\n                nextMoves.add(tryMoveDown(top, grid));\\n                nextMoves.add(tryMoveClockwise(top, grid));\\n                nextMoves.add(tryMoveCounterClockwise(top, grid));\\n\\n                for (SnakePos next : nextMoves) {\\n                    if (next != null && !visited.contains(next.getKey())) {\\n                        visited.add(next.getKey());\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    SnakePos tryMoveRight(SnakePos curr, int[][] grid) {\\n        SnakePos next = new SnakePos(\\n                new Cell(curr.cell1.r, curr.cell1.c + 1),\\n                new Cell(curr.cell2.r, curr.cell2.c + 1)\\n        );\\n        if (valid(next, grid))\\n            return next;\\n        return null;\\n    }\\n\\n    SnakePos tryMoveDown(SnakePos curr, int[][] grid) {\\n        SnakePos next = new SnakePos(\\n                new Cell(curr.cell1.r + 1, curr.cell1.c),\\n                new Cell(curr.cell2.r + 1, curr.cell2.c)\\n        );\\n        if (valid(next, grid))\\n            return next;\\n        return null;\\n    }\\n\\n    SnakePos tryMoveClockwise(SnakePos curr, int[][] grid) {\\n        if (curr.cell1.r == curr.cell2.r) {\\n            SnakePos next = new SnakePos(\\n                    new Cell(curr.cell1.r, curr.cell1.c),\\n                    new Cell(curr.cell2.r + 1, curr.cell2.c - 1)\\n            );\\n            if (valid(next.cell2, grid)\\n                    && valid(new Cell(curr.cell1.r + 1, curr.cell1.c + 1), grid)) {\\n                return next;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    SnakePos tryMoveCounterClockwise(SnakePos curr, int[][] grid) {\\n        if (curr.cell1.c == curr.cell2.c) {\\n            SnakePos next = new SnakePos(\\n                    new Cell(curr.cell1.r, curr.cell1.c),\\n                    new Cell(curr.cell2.r - 1, curr.cell2.c + 1)\\n            );\\n            if (valid(next.cell2, grid)\\n                    && valid(new Cell(curr.cell1.r + 1, curr.cell1.c + 1), grid)) {\\n                return next;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    boolean valid(int r, int c, int[][] grid) {\\n        int n = grid.length;\\n        return r >= 0 && r < n && c >= 0 && c < n && grid[r][c] == 0;\\n    }\\n\\n    boolean valid(Cell cell, int[][] grid) {\\n        return valid(cell.r, cell.c, grid);\\n    }\\n\\n    boolean valid(SnakePos snakePos, int[][] grid) {\\n        return valid(snakePos.cell1, grid) && valid(snakePos.cell2, grid);\\n    }\\n\\n    // For testing and debug on IDE purpose\\n    public static void main(String[] args) {\\n        int[][] grid = {\\n                {0, 0, 0, 0, 0, 1},\\n                {1, 1, 0, 0, 1, 0},\\n                {0, 0, 0, 0, 1, 1},\\n                {0, 0, 1, 0, 1, 0},\\n                {0, 1, 1, 0, 0, 0},\\n                {0, 1, 1, 0, 0, 0}\\n        };\\n\\n        Solution sol = new Solution();\\n        System.out.println(sol.minimumMoves(grid));\\n    }\\n}\\n\\nclass Cell {\\n    int r, c;\\n\\n    public Cell(int r, int c) {\\n        this.r = r;\\n        this.c = c;\\n    }\\n\\n    public String getKey() {\\n        return r + \",\" + c;\\n    }\\n\\n    @Override\\n    public boolean equals(Object obj) {\\n        Cell cell = (Cell) obj;\\n        return r == cell.r && c == cell.c;\\n    }\\n}\\n\\nclass SnakePos {\\n    Cell cell1, cell2;\\n\\n    public SnakePos(Cell cell1, Cell cell2) {\\n        this.cell1 = cell1;\\n        this.cell2 = cell2;\\n    }\\n\\n    public String getKey() {\\n        return cell1.getKey() + \":\" + cell2.getKey();\\n    }\\n\\n    @Override\\n    public boolean equals(Object obj) {\\n        SnakePos snakePos = (SnakePos) obj;\\n        return snakePos.cell1.equals(cell1) && snakePos.cell2.equals(cell2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\npublic class Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        SnakePos src = new SnakePos(new Cell(0, 0), new Cell(0, 1));\\n        SnakePos dst = new SnakePos(new Cell(n - 1, n - 2), new Cell(n - 1, n - 1));\\n\\n        HashSet<String> visited = new HashSet<>();\\n        Queue<SnakePos> queue = new LinkedList<>();\\n        queue.add(src);\\n        visited.add(src.getKey());\\n\\n        ArrayList<SnakePos> nextMoves = new ArrayList<>(4);\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                SnakePos top = queue.remove();\\n                if (top.equals(dst))\\n                    return steps;\\n\\n                nextMoves.clear();\\n                nextMoves.add(tryMoveRight(top, grid));\\n                nextMoves.add(tryMoveDown(top, grid));\\n                nextMoves.add(tryMoveClockwise(top, grid));\\n                nextMoves.add(tryMoveCounterClockwise(top, grid));\\n\\n                for (SnakePos next : nextMoves) {\\n                    if (next != null && !visited.contains(next.getKey())) {\\n                        visited.add(next.getKey());\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    SnakePos tryMoveRight(SnakePos curr, int[][] grid) {\\n        SnakePos next = new SnakePos(\\n                new Cell(curr.cell1.r, curr.cell1.c + 1),\\n                new Cell(curr.cell2.r, curr.cell2.c + 1)\\n        );\\n        if (valid(next, grid))\\n            return next;\\n        return null;\\n    }\\n\\n    SnakePos tryMoveDown(SnakePos curr, int[][] grid) {\\n        SnakePos next = new SnakePos(\\n                new Cell(curr.cell1.r + 1, curr.cell1.c),\\n                new Cell(curr.cell2.r + 1, curr.cell2.c)\\n        );\\n        if (valid(next, grid))\\n            return next;\\n        return null;\\n    }\\n\\n    SnakePos tryMoveClockwise(SnakePos curr, int[][] grid) {\\n        if (curr.cell1.r == curr.cell2.r) {\\n            SnakePos next = new SnakePos(\\n                    new Cell(curr.cell1.r, curr.cell1.c),\\n                    new Cell(curr.cell2.r + 1, curr.cell2.c - 1)\\n            );\\n            if (valid(next.cell2, grid)\\n                    && valid(new Cell(curr.cell1.r + 1, curr.cell1.c + 1), grid)) {\\n                return next;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    SnakePos tryMoveCounterClockwise(SnakePos curr, int[][] grid) {\\n        if (curr.cell1.c == curr.cell2.c) {\\n            SnakePos next = new SnakePos(\\n                    new Cell(curr.cell1.r, curr.cell1.c),\\n                    new Cell(curr.cell2.r - 1, curr.cell2.c + 1)\\n            );\\n            if (valid(next.cell2, grid)\\n                    && valid(new Cell(curr.cell1.r + 1, curr.cell1.c + 1), grid)) {\\n                return next;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    boolean valid(int r, int c, int[][] grid) {\\n        int n = grid.length;\\n        return r >= 0 && r < n && c >= 0 && c < n && grid[r][c] == 0;\\n    }\\n\\n    boolean valid(Cell cell, int[][] grid) {\\n        return valid(cell.r, cell.c, grid);\\n    }\\n\\n    boolean valid(SnakePos snakePos, int[][] grid) {\\n        return valid(snakePos.cell1, grid) && valid(snakePos.cell2, grid);\\n    }\\n\\n    // For testing and debug on IDE purpose\\n    public static void main(String[] args) {\\n        int[][] grid = {\\n                {0, 0, 0, 0, 0, 1},\\n                {1, 1, 0, 0, 1, 0},\\n                {0, 0, 0, 0, 1, 1},\\n                {0, 0, 1, 0, 1, 0},\\n                {0, 1, 1, 0, 0, 0},\\n                {0, 1, 1, 0, 0, 0}\\n        };\\n\\n        Solution sol = new Solution();\\n        System.out.println(sol.minimumMoves(grid));\\n    }\\n}\\n\\nclass Cell {\\n    int r, c;\\n\\n    public Cell(int r, int c) {\\n        this.r = r;\\n        this.c = c;\\n    }\\n\\n    public String getKey() {\\n        return r + \",\" + c;\\n    }\\n\\n    @Override\\n    public boolean equals(Object obj) {\\n        Cell cell = (Cell) obj;\\n        return r == cell.r && c == cell.c;\\n    }\\n}\\n\\nclass SnakePos {\\n    Cell cell1, cell2;\\n\\n    public SnakePos(Cell cell1, Cell cell2) {\\n        this.cell1 = cell1;\\n        this.cell2 = cell2;\\n    }\\n\\n    public String getKey() {\\n        return cell1.getKey() + \":\" + cell2.getKey();\\n    }\\n\\n    @Override\\n    public boolean equals(Object obj) {\\n        SnakePos snakePos = (SnakePos) obj;\\n        return snakePos.cell1.equals(cell1) && snakePos.cell2.equals(cell2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393459,
                "title": "java-short-and-easy-to-understand-bfs",
                "content": "We can treat the grid as 1d array and use the position as the identifiers. Introduce a hashset to check if the snake span is visisted with the format of `first-second`. The position of first and second cell of the span is x1, y1 and x2, y2 respectively. The move them as needed just like regular BFS.\\n\\ne.g. The positions of the grid in the example are 0 - 35, we add the span [0, 1] to queue, then move the snake right by one step to [1,2], then further right to [2, 3], now rotates clockwise to be [2, 2 + n] which is [2, 8]. At this point, the coordinates of the span is (0,2) (1,2) and the snake is heading down. Now move the snake to the right as a whole to [2 +1, 8 +1] which is [3, 9]. Then move down four times till the bottom of the grid to [27, 33]. Now the snake\\'s coordinates is (27 / n = **4**, 27 % n = **3**) and (33 / n = **5**, 33 % n = **3**). rotate counter clockwise to [27, 27 +1], to the right [27 + 1, 28 +1], finally going down to [28 + n, 29 +n] which is [34, 35].\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, moves = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<String> seen = new HashSet<>();\\n        q.offer(new int[] {0, 1});\\n        seen.add(\"0-1\");\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] span = q.poll();\\n                int first = span[0], second = span[1], x1 = first / n, y1 = first % n, x2 = second / n, y2 = second % n;\\n                if (x1 == n - 1 && y1 == n - 2 && x2 == n - 1 && y2 == n - 1) return moves;\\n                \\n                if (x1 == x2) { // horizontal\\n                    if (y2 + 1 < n && grid[x2][y2 + 1] == 0) move(q, second, second + 1, seen); // right\\n                    if (x2 + 1 < n && grid[x1 + 1][y1] == 0 && grid[x2 + 1][y2] == 0) {\\n                        move(q, first + n, second + n, seen); // down\\n                        move(q, first, first + n, seen); // clockwise\\n                    }\\n                } \\n                \\n                if (y1 == y2) { // vertical\\n                    if (x2 + 1 < n && grid[x2 + 1][y2] == 0) move(q, second, second + n, seen); // down\\n                    if (y2 + 1 < n && grid[x1][y1 + 1] == 0 && grid[x2][y2 + 1] == 0) {\\n                        move(q, first + 1, second + 1, seen); // right\\n                        move(q, first, first + 1, seen); // counter clockwise\\n                    }\\n                } \\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n    \\n    private void move(Queue<int[]> q, int first, int second, Set<String> seen) {\\n        if (!seen.contains(first + \"-\" + second)) {\\n            q.offer(new int[] { first, second });\\n            seen.add(first + \"-\" + second);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, moves = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<String> seen = new HashSet<>();\\n        q.offer(new int[] {0, 1});\\n        seen.add(\"0-1\");\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] span = q.poll();\\n                int first = span[0], second = span[1], x1 = first / n, y1 = first % n, x2 = second / n, y2 = second % n;\\n                if (x1 == n - 1 && y1 == n - 2 && x2 == n - 1 && y2 == n - 1) return moves;\\n                \\n                if (x1 == x2) { // horizontal\\n                    if (y2 + 1 < n && grid[x2][y2 + 1] == 0) move(q, second, second + 1, seen); // right\\n                    if (x2 + 1 < n && grid[x1 + 1][y1] == 0 && grid[x2 + 1][y2] == 0) {\\n                        move(q, first + n, second + n, seen); // down\\n                        move(q, first, first + n, seen); // clockwise\\n                    }\\n                } \\n                \\n                if (y1 == y2) { // vertical\\n                    if (x2 + 1 < n && grid[x2 + 1][y2] == 0) move(q, second, second + n, seen); // down\\n                    if (y2 + 1 < n && grid[x1][y1 + 1] == 0 && grid[x2][y2 + 1] == 0) {\\n                        move(q, first + 1, second + 1, seen); // right\\n                        move(q, first, first + 1, seen); // counter clockwise\\n                    }\\n                } \\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n    \\n    private void move(Queue<int[]> q, int first, int second, Set<String> seen) {\\n        if (!seen.contains(first + \"-\" + second)) {\\n            q.offer(new int[] { first, second });\\n            seen.add(first + \"-\" + second);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393042,
                "title": "python-3-bfs-dfs-and-dp-with-explanation-beats-100-00",
                "content": "(Note to Reader: It will be helpful to have the code at the bottom visible separately on your screen while reading this explanation)\\n\\n_**BFS Explanation:**_\\n\\nThis program uses a BFS approach starting out from the top left corner. The program starts by saving the first position of the snake into list S. You do not need to know three pieces of information to know precisely where the snake is. From the three pieces of information (location of the snake\\'s head, location of the snake\\'s tail, and its orientation), you really only need to know two pieces of information. In this porgram, we only look at the position of the snake\\'s tail and its orientation (horizontal = \\'h\\', or vertical = \\'v\\').\\n\\nThe program starts by finding the size of the square grid and stores the value as N which is important because we do not want the snake to go out of bounds. The starting location of the snake is put inside the list S. The snake\\'s tail starts at (0,0) and its orientation is horizontal. Thus S contains the tuple (0,0,\\'h\\'). T is initialized as an empty list. In each iteration of the while loop, T will contain the new positions that the snake can go to based on the entire set of current positions it is at, which is stored in S. So the list S contains all of the snakes current positions after c moves and the list T will contain all of the snakes permissible positions after c + 1 moves. The variable c is the number of moves the snake has made thus far and c is initialized to 0 since the snake has not moved yet. The set V is a set which will contain all the previously visited positions of the snake, where the positions are encoded into tuples of length 3.\\n\\nThe while loop will continue as long as there are new positions for the snake to go and the snake has not reached its destination. Note that the destination position is (N-1,N-2,\\'h\\') as given in the problem description. If there are no new positions for the snake to go and the destination has not been reached, the while loop will end and -1 is returned. The for loop iterates through every current position of the snake which is in the list S. Remember that in a BFS search you expand outward from the starting point. So you can imagine that S contains the outer expanding front of all the places that the snake could have gotten to after c moves. As the for loop iterates through S, if it finds a point in S that the snake has already visited, that point is ignored as there is no point in going in that direction again. This step is essential as otherwise the snake could potentially go in circles. An example of this is that the snake can just go clockwise, counter clockwise, clockwise, counter clockwise, over and over and over. This will cause an exponential increase in the size of S which can slow things down tremendously.\\n\\nProvided that the position we are currently analyzing in S has not been visited, the program continues onto the next line. This position tuple is stored in _i_ from the for loop. If the position tuple _i_ equals the destination tuple, the program returns c. Since we want the shortest path, there is no point in searching after the first path to the destination is reached as it can only have a larger c. For ease of coding, the row and column positions of the snake\\'s tail are called _a_ and _b_ respectively and the orientation is stored as the letter _o_. We also add the position tuple to the set of visited tuples so that we do not visit it again in the future.\\n\\nThe next part of the code looks at where the snake can move given its current location. The first if statement examines the possible next moves if the snake is currently in a horizontal position. Recall that (a,b) is the location of the snake\\'s tail. The next if statement (inside the first one) sees if the snake can move to the right horizontally. This requires checking to make sure that the snake\\'s head isn\\'t at the right edge of the grid and that there is an open space ahead of the snake\\'s head. If both conditions hold, the new location of the snake\\'s tail is added to T. Recall that T is the list of all the new potential locations that the snake can go to in move c + 1. The next if statement checks to see if there are a horizontal pair of zeros directly under the horizontally oriented snake and that the snake is not on the bottom edge of the grid. If these conditions hold then the snake has two permissible moves. It can move down, maintaining its horizontal position, or it can rotate clockwise. These lead to two new positions which are added to the growing list T. Note that when the snake rotates, its orientation changes.\\n\\nThe next if statement examines the possible next moves if the snake is currently in a vertical position. In a similar fashion it checks to see if the snake is at the right or bottom edge of the grid or if there are open spaces for it to move. If there are, it will add the new locations to T.\\n\\nAfter all of the new potential locations have been added to T, the list S is overwritten by the list T and list T is emptied. The count of the number of moves, stored in c, is increased by 1. The while loop then continues with a new list S to iterate through in the for loop. If during a for loop, as the program iterates through S, not a single new permissible position can be found, then nothing will be appended to the empty list T. If T stays empty, then S will be overwritten by it and the while loop which only runs if S is nonempty will stop and -1 will be returned.\\n\\n_**BFS Code:**_ (beats 100.00%) ( 270 ms )\\n```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, S, T, V, c = len(G), [(0, 0, \\'h\\')], [], set(), 0\\n    \\twhile S:\\n    \\t\\tfor i in S:\\n    \\t\\t\\tif i in V: continue\\n    \\t\\t\\tif i == (N-1, N-2, \\'h\\'): return c\\n    \\t\\t\\t(a, b, o), _ = i, V.add(i)\\n\\t    \\t\\tif o == \\'h\\':\\n    \\t\\t\\t\\tif b + 2 != N and G[a][b+2] == 0: T.append((a, b+1, o))\\n    \\t\\t\\t\\tif a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: T.append((a+1, b, o)), T.append((a, b, \\'v\\'))\\n    \\t\\t\\telif o == \\'v\\':\\n    \\t\\t\\t\\tif a + 2 != N and G[a+2][b] == 0: T.append((a+1, b, o))\\n    \\t\\t\\t\\tif b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: T.append((a, b+1, o)), T.append((a, b, \\'h\\'))\\n    \\t\\tS, T, c = T, [], c + 1\\n    \\treturn -1\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n```\\n_**DFS Code:**_ (Time Limit Exceeded on Test Case 12 / 42 ) (A 20 x 20 Grid takes too long with DFS)\\n```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, V, M, self.t, self.m = len(G), set(), collections.defaultdict(int), 0, math.inf\\n    \\tprint(N)\\n    \\tdef dfs(a,b,o):\\n    \\t\\tif (a,b,o) in V or M[(a,b,o)] == 2 or self.t > self.m: return\\n    \\t\\tif (a,b,o) == (N-1,N-2,\\'h\\'):\\n    \\t\\t\\tself.m = min(self.m,self.t)\\n    \\t\\t\\tfor i in V: M[i] = 1\\n    \\t\\t\\treturn\\n    \\t\\tself.t, _ = self.t + 1, V.add((a,b,o))\\n    \\t\\tif o == \\'h\\':\\n    \\t\\t\\tif b + 2 != N and G[a][b+2] == 0: dfs(a, b+1, o)\\n    \\t\\t\\tif a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: dfs(a+1, b, o), dfs(a, b, \\'v\\')\\n    \\t\\telif o == \\'v\\':\\n    \\t\\t\\tif a + 2 != N and G[a+2][b] == 0: dfs(a+1, b, o)\\n    \\t\\t\\tif b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: dfs(a, b+1, o), dfs(a, b, \\'h\\')\\n    \\t\\tif M[(a,b,o)] == 0: M[(a,b,o)] = 2\\n    \\t\\tself.t, _ = self.t - 1, V.remove((a,b,o))\\n    \\tdfs(0,0,\\'h\\')\\n    \\treturn -1 if self.m == math.inf else self.m\\n\\n\\n```\\n_**DP Code:**_ (beats ~50%) ( 420 ms )\\n```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, I, DP = len(G)-1, math.inf, [[math.inf]*2 for i in range(len(G)+1)]\\n    \\tDP[N-1][0] = I if 1 in [G[N][N],G[N][N-1]] else 0\\n    \\tfor j in range(N-2,-1,-1): DP[j][0] = (DP[j+1][0] + 1) if G[N][j] == 0 else I\\n    \\tfor i,j in itertools.product(range(N-1,-1,-1),range(N,-1,-1)):\\n    \\t\\tn = [G[i][j],G[i][min(j+1,N)],G[min(i+1,N)][j],G[min(i+1,N)][min(j+1,N)]]\\n    \\t\\tDP[j][0], DP[j][1] = min(1+DP[j+1][0],1+DP[j][0]), min(1+DP[j+1][1],1+DP[j][1])\\n    \\t\\tif 1 not in n: DP[j][0], DP[j][1] = min(DP[j][0],2+DP[j+1][1],1+DP[j][1]), min(DP[j][1],2+DP[j+1][0],1+DP[j][0])\\n    \\t\\tif 1 in [n[0],n[1]]: DP[j][0] = I\\n    \\t\\tif 1 in [n[0],n[2]]: DP[j][1] = I\\n    \\treturn -1 if DP[0][0] == I else DP[0][0]\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, S, T, V, c = len(G), [(0, 0, \\'h\\')], [], set(), 0\\n    \\twhile S:\\n    \\t\\tfor i in S:\\n    \\t\\t\\tif i in V: continue\\n    \\t\\t\\tif i == (N-1, N-2, \\'h\\'): return c\\n    \\t\\t\\t(a, b, o), _ = i, V.add(i)\\n\\t    \\t\\tif o == \\'h\\':\\n    \\t\\t\\t\\tif b + 2 != N and G[a][b+2] == 0: T.append((a, b+1, o))\\n    \\t\\t\\t\\tif a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: T.append((a+1, b, o)), T.append((a, b, \\'v\\'))\\n    \\t\\t\\telif o == \\'v\\':\\n    \\t\\t\\t\\tif a + 2 != N and G[a+2][b] == 0: T.append((a+1, b, o))\\n    \\t\\t\\t\\tif b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: T.append((a, b+1, o)), T.append((a, b, \\'h\\'))\\n    \\t\\tS, T, c = T, [], c + 1\\n    \\treturn -1\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, V, M, self.t, self.m = len(G), set(), collections.defaultdict(int), 0, math.inf\\n    \\tprint(N)\\n    \\tdef dfs(a,b,o):\\n    \\t\\tif (a,b,o) in V or M[(a,b,o)] == 2 or self.t > self.m: return\\n    \\t\\tif (a,b,o) == (N-1,N-2,\\'h\\'):\\n    \\t\\t\\tself.m = min(self.m,self.t)\\n    \\t\\t\\tfor i in V: M[i] = 1\\n    \\t\\t\\treturn\\n    \\t\\tself.t, _ = self.t + 1, V.add((a,b,o))\\n    \\t\\tif o == \\'h\\':\\n    \\t\\t\\tif b + 2 != N and G[a][b+2] == 0: dfs(a, b+1, o)\\n    \\t\\t\\tif a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: dfs(a+1, b, o), dfs(a, b, \\'v\\')\\n    \\t\\telif o == \\'v\\':\\n    \\t\\t\\tif a + 2 != N and G[a+2][b] == 0: dfs(a+1, b, o)\\n    \\t\\t\\tif b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: dfs(a, b+1, o), dfs(a, b, \\'h\\')\\n    \\t\\tif M[(a,b,o)] == 0: M[(a,b,o)] = 2\\n    \\t\\tself.t, _ = self.t - 1, V.remove((a,b,o))\\n    \\tdfs(0,0,\\'h\\')\\n    \\treturn -1 if self.m == math.inf else self.m\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247505,
                "title": "java-dynamic-programing-13-ms-faster-than-95",
                "content": "Here I use a 3-dimension dp table to solve the problem, \\nI regard the position of snake as \"HEAD\" and \"DIRECTION\" (0 as left-right and 1 as up-down)\\nFor the status of snake (i,j,k),\\nThe status transforming formular can be written below:\\ndp[i][j][k] = Math.min(dp[i-1][j][k],dp[i][k-1][k],dp[i][j][k^1])------left,up,and rotate\\nThe base cases can be a little complicated.\\n\\n```\\nClass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][][] dp = new int[n][n][2];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<2;k++){\\n                    if(i==0&&j==0&&k==0)\\n                        dp[i][j][k]=0;\\n                    else if(grid[i][j]==1)\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else if(k==0&&(j+1>=n||grid[i][j+1]==1))\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else if(k==1&&(i+1>=n||grid[i+1][j]==1))\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else{\\n                        int choice1 = i-1>=0? dp[i-1][j][k]:Integer.MAX_VALUE;//go down\\n                        int choice2 = j-1>=0? dp[i][j-1][k]:Integer.MAX_VALUE;//go right\\n                        int tempMinChoice = Math.min(choice1,choice2);\\n                        dp[i][j][k] = tempMinChoice==Integer.MAX_VALUE? tempMinChoice:(tempMinChoice+1);\\n                    }\\n                }\\n                //rotate\\n                if(i+1<n&&j+1<n&&grid[i][j+1]!=1&&grid[i+1][j+1]!=1&&dp[i][j][1]!=Integer.MAX_VALUE&&dp[i][j][0]>dp[i][j][1]+1) \\n                    dp[i][j][0]=dp[i][j][1]+1;\\n                if(i+1<n&&j+1<n&&grid[i+1][j]!=1&&grid[i+1][j+1]!=1&&dp[i][j][0]!=Integer.MAX_VALUE&&dp[i][j][1]>dp[i][j][0]+1) \\n                    dp[i][j][1]=dp[i][j][0]+1;\\n            }\\n        }\\n        return dp[n-1][n-2][0]==Integer.MAX_VALUE? -1:dp[n-1][n-2][0];\\n    }\\n}\\n```\\nVote if it helps you :) Thx",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nClass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][][] dp = new int[n][n][2];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<2;k++){\\n                    if(i==0&&j==0&&k==0)\\n                        dp[i][j][k]=0;\\n                    else if(grid[i][j]==1)\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else if(k==0&&(j+1>=n||grid[i][j+1]==1))\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else if(k==1&&(i+1>=n||grid[i+1][j]==1))\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else{\\n                        int choice1 = i-1>=0? dp[i-1][j][k]:Integer.MAX_VALUE;//go down\\n                        int choice2 = j-1>=0? dp[i][j-1][k]:Integer.MAX_VALUE;//go right\\n                        int tempMinChoice = Math.min(choice1,choice2);\\n                        dp[i][j][k] = tempMinChoice==Integer.MAX_VALUE? tempMinChoice:(tempMinChoice+1);\\n                    }\\n                }\\n                //rotate\\n                if(i+1<n&&j+1<n&&grid[i][j+1]!=1&&grid[i+1][j+1]!=1&&dp[i][j][1]!=Integer.MAX_VALUE&&dp[i][j][0]>dp[i][j][1]+1) \\n                    dp[i][j][0]=dp[i][j][1]+1;\\n                if(i+1<n&&j+1<n&&grid[i+1][j]!=1&&grid[i+1][j+1]!=1&&dp[i][j][0]!=Integer.MAX_VALUE&&dp[i][j][1]>dp[i][j][0]+1) \\n                    dp[i][j][1]=dp[i][j][0]+1;\\n            }\\n        }\\n        return dp[n-1][n-2][0]==Integer.MAX_VALUE? -1:dp[n-1][n-2][0];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220110,
                "title": "easy-bfs-c",
                "content": "We can solve this problem using bfs. In queue of bfs we store 3 things. Snake\\'s x coordinate,Snake\\'s y coordinate and the direction(true for horizontal, false for vertical). We don\\'t need to store head of snake as we can easily find it if we are given these 3 variables.\\n\\nWe also maintain a visited set of same 3 things(x,y,direction) which will tell us if we have visited the orientation or not. If we have already visited we simply return.\\n\\nInititally the snake\\'s tail is at (0,0) and direction is horizontal so we push (0,0,true) to our queue.\\nThen we follow simple bfs and check if we can visit left,right or rotate it and if yes we push it to the queue.\\n\\nWe need to use two loops for bfs as the inner loop is providing us options in which we can move but eventually we are going to move in just one direction so we have to count whole inner loop once only.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    set<vector<int>> visited;\\n    bool candown(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(!hor){\\n            if(x+2<n && grid[x+1][y]==0 && grid[x+2][y]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canright(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+2<n && grid[x][y+1]==0 && grid[x][y+2]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(y+1<n && x+1<n && grid[x][y+1]==0 && grid[x+1][y+1]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canrot(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+1<n && x+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x][y+1]==0 &&grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        queue<array<int, 3>> q;\\n        q.push({0,0,true});\\n        int ans=0;\\n        n=grid.size();\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto a=q.front();\\n                q.pop();\\n                if(visited.count({a[0],a[1],a[2]})){\\n                    continue;\\n                }\\n                visited.insert({a[0],a[1],a[2]});\\n                int x=a[0];\\n                int y=a[1];\\n                if(x==n-1 && y==n-2 && a[2]==1){\\n                    return ans;\\n                }\\n                if(candown(grid,x,y,a[2])){\\n                    q.push({x+1,y,a[2]});\\n                }\\n                if(canrot(grid,x,y,a[2])){\\n                    q.push({x,y,!a[2]});\\n                }\\n                if(canright(grid,x,y,a[2])){\\n                    q.push({x,y+1,a[2]});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please upvote if you liked the solution.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    set<vector<int>> visited;\\n    bool candown(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(!hor){\\n            if(x+2<n && grid[x+1][y]==0 && grid[x+2][y]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canright(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+2<n && grid[x][y+1]==0 && grid[x][y+2]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(y+1<n && x+1<n && grid[x][y+1]==0 && grid[x+1][y+1]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canrot(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+1<n && x+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x][y+1]==0 &&grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        queue<array<int, 3>> q;\\n        q.push({0,0,true});\\n        int ans=0;\\n        n=grid.size();\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto a=q.front();\\n                q.pop();\\n                if(visited.count({a[0],a[1],a[2]})){\\n                    continue;\\n                }\\n                visited.insert({a[0],a[1],a[2]});\\n                int x=a[0];\\n                int y=a[1];\\n                if(x==n-1 && y==n-2 && a[2]==1){\\n                    return ans;\\n                }\\n                if(candown(grid,x,y,a[2])){\\n                    q.push({x+1,y,a[2]});\\n                }\\n                if(canrot(grid,x,y,a[2])){\\n                    q.push({x,y,!a[2]});\\n                }\\n                if(canright(grid,x,y,a[2])){\\n                    q.push({x,y+1,a[2]});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393922,
                "title": "java-dp-memorization-search-11ms",
                "content": "* horizontal direction: dp[x][y][0] means the min move times when the snake tail is at (x, y) and its direction is horizontal.\\n * vertical direction: dp[x][y][1] means the min move times when the snake tail is at (x, y) and its direction is vertical.\\n\\n**state transfer:**\\n\\n1.  for horizontal direction, the snake can move right, move down or rotate clock-wise\\n\\n\\t* \\t right:               precondition -> grid[x][y+2]=0\\n\\t*   down:                precondition -> grid[x+1][y]=0 & grid[x+1][y+1]=0\\n\\t*  rotate clock-wise:   precondition -> grid[x+1][y]=0 & grid[x+1][y+1]=0\\n\\t\\n\\t**if all satisfy these three conditions\\n    dp[x][y][0] = Math.min(dp[x+1][y][0], dp[x+1][y][0], dp[x][y][1]) + 1**\\n\\n2. for vertical direction, the snake can move right, move down or rotate counterclockwise\\n\\n\\t *  down: precondition -> grid[x+2][y]=0\\n\\t *  right: precondition -> grid[x][y+1]=0 & grid[x+1][y+1]=0\\n\\t * rotate counterclockwise -> grid[x][y+1]=0 & grid[x+1][y+1]=0\\n\\t \\n\\t**if all satisfy these three conditions\\n\\tdp[x][y][1] = Math.min(dp[x+1][y][1], dp[x][y+1][1], dp[x][y][0])+1**\\n\\n**attention**: to prevent same position go repeated rotate clockwise or counterclockwise, need set visited symbol.\\n\\n```\\nprivate int search(int[][] grid, int x, int y, boolean isH, Integer[][][] mem, boolean[][][] vis) {\\n\\t\\t// invalid state\\n        if (x < 0 || y < 0 || x >= m || y >= n) return Integer.MAX_VALUE;\\n        if (isH && y >= n-1) return Integer.MAX_VALUE;\\n        if (!isH && x >= m-1) return Integer.MAX_VALUE;\\n        // reach the aim ending point.\\n        if (isH && x==m-1 && y==n-2) return 0;\\n\\t\\t// caculated\\n        if (mem[x][y][isH ? 0 : 1] != null) {\\n            return mem[x][y][isH ? 0 : 1];\\n        }\\n\\t\\t// has been visited, this means this state is caculating\\n        if (vis[x][y][isH ? 0: 1]) return Integer.MAX_VALUE;\\n        // set visit symbol\\n        vis[x][y][isH ? 0: 1] = true;\\n        int ans = Integer.MAX_VALUE;\\n        // horizontal\\n        if (isH) {\\n            // right\\n            if (y+2 < n && grid[x][y+2]==0) {\\n                ans = Math.min(ans, search(grid, x, y+1, isH, mem, vis));\\n            }\\n            // down and rotate clock-wise\\n            if (x+1 < m && grid[x+1][y]==0 && grid[x+1][y+1]==0) {\\n                int way1 = search(grid, x+1, y, isH, mem, vis);   // down\\n                int way2 = search(grid, x, y, !isH, mem, vis); // rotate clockwise\\n                ans = Math.min(ans, Math.min(way1, way2));\\n            }\\n        } else {\\n            // down\\n            if (x+2 < m && grid[x+2][y] == 0) {\\n                ans = Math.min(ans, search(grid, x+1, y, isH, mem, vis));\\n            }\\n            // right or rotate counterclockwise\\n            if (y+1 < n && grid[x][y+1]==0 && grid[x+1][y+1]==0) {\\n                int way1 = search(grid, x, y+1, isH, mem, vis); // right\\n                int way2 = search(grid, x, y, !isH, mem, vis); // rotate counterclockwise\\n                ans = Math.min(ans, Math.min(way1, way2));\\n            }\\n        }\\n\\t\\t// ans= Integer.MAX_VALUE means no solution to move to aim ending.\\n        if (ans < Integer.MAX_VALUE) {\\n            ans += 1;\\n        }\\n        mem[x][y][isH ? 0:1] = ans;\\n        return ans;\\n    }\\n    public int minimumMoves(int[][] grid) {\\n        if ((m=grid.length)<=1 || (n=grid[0].length)<=1) return -1;\\n        Integer[][][] mem = new Integer[m][n][2];\\n        boolean[][][] vis = new boolean[m][n][2];\\n        if (grid[0][0]==1 || grid[0][1] == 1) {\\n            return -1;\\n        }\\n        int ans = search(grid, 0, 0, true, mem, vis);\\n        return ans==Integer.MAX_VALUE ? -1: ans;\\n\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nprivate int search(int[][] grid, int x, int y, boolean isH, Integer[][][] mem, boolean[][][] vis) {\\n\\t\\t// invalid state\\n        if (x < 0 || y < 0 || x >= m || y >= n) return Integer.MAX_VALUE;\\n        if (isH && y >= n-1) return Integer.MAX_VALUE;\\n        if (!isH && x >= m-1) return Integer.MAX_VALUE;\\n        // reach the aim ending point.\\n        if (isH && x==m-1 && y==n-2) return 0;\\n\\t\\t// caculated\\n        if (mem[x][y][isH ? 0 : 1] != null) {\\n            return mem[x][y][isH ? 0 : 1];\\n        }\\n\\t\\t// has been visited, this means this state is caculating\\n        if (vis[x][y][isH ? 0: 1]) return Integer.MAX_VALUE;\\n        // set visit symbol\\n        vis[x][y][isH ? 0: 1] = true;\\n        int ans = Integer.MAX_VALUE;\\n        // horizontal\\n        if (isH) {\\n            // right\\n            if (y+2 < n && grid[x][y+2]==0) {\\n                ans = Math.min(ans, search(grid, x, y+1, isH, mem, vis));\\n            }\\n            // down and rotate clock-wise\\n            if (x+1 < m && grid[x+1][y]==0 && grid[x+1][y+1]==0) {\\n                int way1 = search(grid, x+1, y, isH, mem, vis);   // down\\n                int way2 = search(grid, x, y, !isH, mem, vis); // rotate clockwise\\n                ans = Math.min(ans, Math.min(way1, way2));\\n            }\\n        } else {\\n            // down\\n            if (x+2 < m && grid[x+2][y] == 0) {\\n                ans = Math.min(ans, search(grid, x+1, y, isH, mem, vis));\\n            }\\n            // right or rotate counterclockwise\\n            if (y+1 < n && grid[x][y+1]==0 && grid[x+1][y+1]==0) {\\n                int way1 = search(grid, x, y+1, isH, mem, vis); // right\\n                int way2 = search(grid, x, y, !isH, mem, vis); // rotate counterclockwise\\n                ans = Math.min(ans, Math.min(way1, way2));\\n            }\\n        }\\n\\t\\t// ans= Integer.MAX_VALUE means no solution to move to aim ending.\\n        if (ans < Integer.MAX_VALUE) {\\n            ans += 1;\\n        }\\n        mem[x][y][isH ? 0:1] = ans;\\n        return ans;\\n    }\\n    public int minimumMoves(int[][] grid) {\\n        if ((m=grid.length)<=1 || (n=grid[0].length)<=1) return -1;\\n        Integer[][][] mem = new Integer[m][n][2];\\n        boolean[][][] vis = new boolean[m][n][2];\\n        if (grid[0][0]==1 || grid[0][1] == 1) {\\n            return -1;\\n        }\\n        int ans = search(grid, 0, 0, true, mem, vis);\\n        return ans==Integer.MAX_VALUE ? -1: ans;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392865,
                "title": "python-bfs-solution-with-explaination",
                "content": "hx and hy refer to x and y of the head, tx and ty refer to x and y of the tail. For each move, we check if the two blocks under the snake are available (if the snake is in vertical direction, then the block under the tail is always available). If so, we can choose either to rotate in clockwise direction, or to move downward for one cell. Similarly, we check the two cells to the right of the snake, and let the snake rotate counterclockwise or move rightward.\\n\\nNote: the tuple in seen represents the postion of (x of the snake head, y of the snake head, x of the snake tail, y of the snake tail). Once the snake has already reach a position, it is not necessary for the snake to visit it again. Maybe bits manipulation could save more space for my solution.\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        q = collections.deque([(0,0,1,0,0)])\\n        seen = {(0,1,0,0)}\\n        while q:\\n            t, hx, hy, tx, ty = q.popleft()\\n            if hx == hy == tx == n - 1 and ty == n - 2:\\n                return t\\n            #Check the ceils under the snake\\n            if hx + 1 < n and not grid[hx + 1][hy] and not grid[tx + 1][ty]:\\n                #try to move downward\\n                if (hx + 1, hy, tx + 1, ty) not in seen:\\n                    q += (t + 1, hx + 1, hy, tx + 1, ty),\\n                    seen.add((hx + 1, hy, tx + 1, ty))\\n                #try to rotate clockwise\\n                if tx == hx and (tx + 1, ty, tx, ty) not in seen:\\n                    q += (t + 1, tx + 1, ty, tx, ty),\\n                    seen.add((tx + 1, ty, tx, ty))\\n            #Check the ceils to the right\\n            if hy + 1 < n and not grid[hx][hy + 1] and not grid[tx][1 + ty]:\\n                #try to move rightward\\n                if (hx, 1 + hy, tx, 1 + ty) not in seen:\\n                    q +=(t + 1, hx, 1 + hy, tx, 1 + ty),\\n                    seen.add((hx, hy + 1, tx, 1 + ty))\\n                #try to rotate counterclockwise\\n                if ty == hy and (tx, ty + 1, tx, ty) not in seen:\\n                    q += (t + 1, tx, ty + 1, tx, ty),\\n                    seen.add((tx, 1 + ty, tx, ty))\\n        return -1",
                "solutionTags": [],
                "code": "class Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        q = collections.deque([(0,0,1,0,0)])\\n        seen = {(0,1,0,0)}",
                "codeTag": "Java"
            },
            {
                "id": 696488,
                "title": "test-through-39-and-the-follow-one-wrong-answer-and-i-find-it-can-make-it",
                "content": "input:\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,1,1,0,0,1,0,0,0,0,1,0,0],[0,1,0,0,0,0,1,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[0,0,1,0,1,0,0,0,0,0,0,0,0,0,0]]\\n0,0,1,0,0,0,0,0,0,0,0,0,0,0,0\\n0,1,0,1,1,0,0,1,0,0,0,0,1,0,0\\n0,1,0,0,0,0,1,0,0,1,0,0,0,0,0\\n0,0,0,0,0,0,1,0,0,0,0,0,0,0,0\\n0,0,0,0,0,0,1,1,0,0,0,0,0,0,0\\n0,0,0,0,0,0,0,0,0,1,0,1,0,0,0\\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\n0,0,0,1,0,1,0,0,1,0,0,0,1,0,0\\n0,0,0,0,1,0,0,0,0,0,0,0,0,1,0\\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\n0,0,0,1,0,0,0,0,0,0,0,0,0,0,0\\n1,0,1,1,0,0,0,0,0,0,0,0,0,0,0\\n0,0,0,0,0,0,0,0,0,0,0,0,0,1,0\\n1,0,0,0,0,0,1,0,0,0,1,0,0,0,1\\n0,0,1,0,1,0,0,0,0,0,0,0,0,0,0\\nmy code is as follow:\\nclass Solution {\\npublic:\\n    int minimumMoves(std::vector<std::vector<int>> const & grid) {\\n        int rowSize = grid.size();\\n        if (0 == rowSize) {\\n            return 0;\\n        }\\n\\n        int colSize = grid[0].size();\\n        if (0 == colSize) {\\n            return 0;\\n        }\\n\\n        std::unordered_map<int, int> visited;\\n        std::queue<int> todo;\\n        int code = encode(0, 1, 0, 0);\\n        todo.emplace(code);\\n        visited[code] = 0;\\n        int res = INT_MAX;\\n        while (todo.size()) {\\n            int cur = todo.front(); todo.pop();\\n            if (visited[cur] > res) {\\n                continue;\\n            }\\n            int headRow = 0, headCol = 0, endRow = 0, endCol = 0;\\n            decode(cur, headRow, headCol, endRow, endCol);\\n            if (headRow == rowSize - 1 && headCol == colSize - 1 &&\\n                    endRow == headRow && endCol == headCol - 1) {\\n                res = std::min(res, visited[cur]);\\n            }\\n            if (canRight(grid, headRow, headCol, endRow, endCol)) {\\n                int newCode = encode(headRow, headCol, endRow, endCol);\\n                if (visited.find(newCode) == visited.end() || visited[newCode] > visited[cur] + 1) {\\n                    todo.emplace(newCode);\\n                    visited[newCode] = visited[cur] + 1;\\n                }\\n            }\\n\\n            decode(cur, headRow, headCol, endRow, endCol);\\n            if (canDown(grid, headRow, headCol, endRow, endCol)) {\\n                int newCode = encode(headRow, headCol, endRow, endCol);\\n                if (visited.find(newCode) == visited.end() || visited[newCode] > visited[cur] + 1) {\\n                    todo.emplace(newCode);\\n                    visited[newCode] = visited[cur] + 1;\\n                }\\n            }\\n\\n            decode(cur, headRow, headCol, endRow, endCol);\\n            if (canClockWise(grid, headRow, headCol, endRow, endCol)) {\\n                int newCode = encode(headRow, headCol, endRow, endCol);\\n                if (visited.find(newCode) == visited.end() || visited[newCode] > visited[cur] + 1) {\\n                    todo.emplace(newCode);\\n                    visited[newCode] = visited[cur] + 1;\\n                }\\n            }\\n\\n            decode(cur, headRow, headCol, endRow, endCol);\\n            if (canCounterClockWise(grid, headRow, headCol, endRow, endCol)) {\\n                int newCode = encode(headRow, headCol, endRow, endCol);\\n                if (visited.find(newCode) == visited.end() || visited[newCode] > visited[cur] + 1) {\\n                    todo.emplace(newCode);\\n                    visited[newCode] = visited[cur] + 1;\\n                }\\n            }\\n        }\\n        return INT_MAX == res ? -1 : res;\\n    }\\nprivate:\\n    int encode(int headRow, int headCol, int endRow, int endCol) {\\n        return (headRow << 24) | (headCol << 16) | (endRow << 8) | (endCol);\\n    }\\n\\n    void decode(int res, int & headRow, int & headCol, int & endRow, int & endCol) {\\n        headRow = (res >> 24) & 0xFF;\\n        headCol = (res >> 16) & 0xFF;\\n        endRow = (res >> 8) & 0xFF;\\n        endCol = res & 0xFF;\\n    }\\n\\n    bool canRight(std::vector<std::vector<int>> const & grid,\\n            int & headRow, int & headCol, int & endRow, int & endCol) {\\n        int newHeadCol = headCol + 1;\\n        if (newHeadCol >= grid[headRow].size() || 1 == grid[headRow][newHeadCol]) {\\n            return false;\\n        }\\n        int newEndCol = newHeadCol;\\n        if (headCol == endCol) {\\n            if (1 == grid[endRow][newEndCol]) {\\n                return false;\\n            }\\n        } else {\\n            newEndCol = headCol;\\n        }\\n        headCol = newHeadCol;\\n        endCol = newEndCol;\\n        return true;\\n    }\\n\\n    bool canDown(std::vector<std::vector<int>> const & grid,\\n            int & headRow, int & headCol, int & endRow, int & endCol) {\\n        int newHeadRow = headRow + 1;\\n        if (newHeadRow >= grid.size() || 1 == grid[newHeadRow][headCol]) {\\n            return false;\\n        }\\n        int newEndRow = newHeadRow;\\n        if (headRow == endRow) {\\n            if (1 == grid[newEndRow][endCol]) {\\n                return false;\\n            }\\n        } else {\\n            newEndRow = headRow;\\n        }\\n        headRow = newHeadRow;\\n        endRow = newEndRow;\\n        return true;\\n    }\\n\\n    bool canClockWise(std::vector<std::vector<int>> const & grid,\\n            int & headRow, int & headCol, int & endRow, int & endCol) {\\n        if (headRow != endRow) {\\n            return false;\\n        }\\n        int newHeadRow = endRow + 1;\\n        if (newHeadRow >= grid.size() || 1 == grid[newHeadRow][endCol]) {\\n            return false;\\n        }\\n        headRow = newHeadRow;\\n        headCol = endCol;\\n        return true;\\n    }\\n\\n    bool canCounterClockWise(std::vector<std::vector<int>> const & grid,\\n            int & headRow, int & headCol, int & endRow, int & endCol) {\\n        if (headCol != endCol) {\\n            return false;\\n        }\\n        int newHeadCol = endCol + 1;\\n        if (newHeadCol >= grid[endRow].size() || 1 == grid[endRow][newHeadCol]) {\\n            return false;\\n        }\\n        headRow = endRow;\\n        headCol = newHeadCol;\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumMoves(std::vector<std::vector<int>> const & grid) {\\n        int rowSize = grid.size();\\n        if (0 == rowSize) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 393145,
                "title": "javascript-easy-to-understand-bfs-128ms",
                "content": "Since we need to find out the minimum steps from one fixed point to another fixed point. The straight forward solution to do this is BFS.\\n\\n- Maintain a `visited` set to prevent endless loop\\n- Use `x`, `y` and `status` to identifies a status uniquely\\n- Traversal all possible status for current step and get the possible status for next step\\n- Finally get the answer\\n\\n```js\\nconst minimumMoves = grid => {\\n  const visited = new Set();\\n  const n = grid.length;\\n  let queue = [[0, 0, \"h\"]];\\n  let step = 0;\\n  while (queue.length) {\\n    let next = [];\\n    for (let i = 0; i < queue.length; ++i) {\\n      const key = queue[i].join(\"-\");\\n      if (visited.has(key)) continue;\\n      visited.add(key);\\n      const [x, y, status] = queue[i];\\n      if (x === n - 1 && y === n - 2 && status === \"h\") return step;\\n      if (status === \"h\") {\\n        x + 1 < n && grid[x + 1][y] === 0 && grid[x + 1][y + 1] === 0 && next.push([x, y, \"v\"]) && next.push([x + 1, y, \"h\"]);\\n        y + 2 < n && grid[x][y + 2] === 0 && next.push([x, y + 1, \"h\"]);\\n      } else {\\n        y + 1 < n && grid[x][y + 1] === 0 && grid[x + 1][y + 1] === 0 && next.push([x, y, \"h\"]) && next.push([x, y + 1, \"v\"]);\\n        x + 2 < n && grid[x + 2][y] === 0 && next.push([x + 1, y, \"v\"]);\\n      }\\n    }\\n    ++step;\\n    queue = next;\\n  }\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst minimumMoves = grid => {\\n  const visited = new Set();\\n  const n = grid.length;\\n  let queue = [[0, 0, \"h\"]];\\n  let step = 0;\\n  while (queue.length) {\\n    let next = [];\\n    for (let i = 0; i < queue.length; ++i) {\\n      const key = queue[i].join(\"-\");\\n      if (visited.has(key)) continue;\\n      visited.add(key);\\n      const [x, y, status] = queue[i];\\n      if (x === n - 1 && y === n - 2 && status === \"h\") return step;\\n      if (status === \"h\") {\\n        x + 1 < n && grid[x + 1][y] === 0 && grid[x + 1][y + 1] === 0 && next.push([x, y, \"v\"]) && next.push([x + 1, y, \"h\"]);\\n        y + 2 < n && grid[x][y + 2] === 0 && next.push([x, y + 1, \"h\"]);\\n      } else {\\n        y + 1 < n && grid[x][y + 1] === 0 && grid[x + 1][y + 1] === 0 && next.push([x, y, \"h\"]) && next.push([x, y + 1, \"v\"]);\\n        x + 2 < n && grid[x + 2][y] === 0 && next.push([x + 1, y, \"v\"]);\\n      }\\n    }\\n    ++step;\\n    queue = next;\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2616203,
                "title": "c-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>&grid){\\n        int n=grid.size(),ans=0;\\n        map<pair<int,pair<int,int>>,int>mp;\\n        queue<pair<int,pair<int,int>>>q;\\n        \\n        q.push({0,{0,1}});\\n        mp[{0,{0,1}}]++;\\n        int i=0;\\n        while(q.size()>0){\\n            int m=q.size();\\n            while(m--)\\n            {\\n                int x=q.front().second.first,y=q.front().second.second,pos=q.front().first;\\n                q.pop();\\n                if(x==n-1 && y==n-1 && pos==0)return ans;\\n                if(pos==0)\\n                {\\n                    if(y+1<n && grid[x][y+1]==0 && mp.find({0,{x,y+1}})==mp.end()){\\n                        q.push({0,{x,y+1}});\\n                        mp[{0,{x,y+1}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({0,{x+1,y}})==mp.end()){\\n                        q.push({0,{x+1,y}});\\n                        mp[{0,{x+1,y}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({1,{x+1,y-1}})==mp.end()){\\n                        q.push({1,{x+1,y-1}});\\n                        mp[{1,{x+1,y-1}}]++;\\n                    }\\n                }else{\\n                    if(x+1<n && grid[x+1][y]==0 && mp.find({1,{x+1,y}})==mp.end()){\\n                        q.push({1,{x+1,y}});\\n                        mp[{1,{x+1,y}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({1,{x,y+1}})==mp.end()){\\n                         q.push({1,{x,y+1}});\\n                         mp[{1,{x,y+1}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({0,{x-1,y+1}})==mp.end()){\\n                         q.push({0,{x-1,y+1}});\\n                         mp[{0,{x-1,y+1}}]++;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>&grid){\\n        int n=grid.size(),ans=0;\\n        map<pair<int,pair<int,int>>,int>mp;\\n        queue<pair<int,pair<int,int>>>q;\\n        \\n        q.push({0,{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 1134913,
                "title": "python3-dijkstra-s-algo",
                "content": "\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        dist = {(0, 0, 0, 1): 0}\\n        pq = [(0, 0, 0, 0, 1)]\\n        while pq: \\n            x, i, j, ii, jj = heappop(pq)\\n            if i == n-1 and j == n-2 and ii == n-1 and jj == n-1: return x\\n            if ii+1 < n and grid[i+1][j] == grid[ii+1][jj] == 0 and x+1 < dist.get((i+1, j, ii+1, jj), inf): \\n                heappush(pq, (x+1, i+1, j, ii+1, jj))\\n                dist[i+1, j, ii+1, jj] = x + 1\\n            if jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and x+1 < dist.get((i, j+1, ii, jj+1), inf): \\n                heappush(pq, (x+1, i, j+1, ii, jj+1))\\n                dist[i, j+1, ii, jj+1] = x + 1\\n            if i == ii and ii+1 < n and grid[i+1][j] == grid[i+1][jj] == 0 and x+1 < dist.get((i, j, i+1, j), inf): \\n                heappush(pq, (x+1, i, j, i+1, j))\\n                dist[i, j, i+1, j] = x + 1\\n            if j == jj and jj+1 < n and grid[i][j+1] == grid[ii][j+1] == 0 and x+1 < dist.get((i, j, i, j+1), inf): \\n                heappush(pq, (x+1, i, j, i, j+1))\\n                dist[i, j, i, j+1] = x + 1\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        dist = {(0, 0, 0, 1): 0}\\n        pq = [(0, 0, 0, 0, 1)]\\n        while pq: \\n            x, i, j, ii, jj = heappop(pq)\\n            if i == n-1 and j == n-2 and ii == n-1 and jj == n-1: return x\\n            if ii+1 < n and grid[i+1][j] == grid[ii+1][jj] == 0 and x+1 < dist.get((i+1, j, ii+1, jj), inf): \\n                heappush(pq, (x+1, i+1, j, ii+1, jj))\\n                dist[i+1, j, ii+1, jj] = x + 1\\n            if jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and x+1 < dist.get((i, j+1, ii, jj+1), inf): \\n                heappush(pq, (x+1, i, j+1, ii, jj+1))\\n                dist[i, j+1, ii, jj+1] = x + 1\\n            if i == ii and ii+1 < n and grid[i+1][j] == grid[i+1][jj] == 0 and x+1 < dist.get((i, j, i+1, j), inf): \\n                heappush(pq, (x+1, i, j, i+1, j))\\n                dist[i, j, i+1, j] = x + 1\\n            if j == jj and jj+1 < n and grid[i][j+1] == grid[ii][j+1] == 0 and x+1 < dist.get((i, j, i, j+1), inf): \\n                heappush(pq, (x+1, i, j, i, j+1))\\n                dist[i, j, i, j+1] = x + 1\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 741472,
                "title": "java-bfs",
                "content": "```\\n    public int minimumMoves(int[][] g) {\\n        int n = g.length, step = 0;\\n        Set<Integer> vs = new HashSet<>();\\n        Queue<int[]> q = new LinkedList<>();\\n        if (g[0][0] == 1 || g[0][1] == 1) return -1;\\n        q.offer(new int[]{0, 1, 0});\\n        vs.add(2);\\n        int[][] dir = new int[][]{{0, 1}, {1, 0}};\\n        while (!q.isEmpty()) {\\n            for (int i = 0, len = q.size(); i < len; i++) {\\n                int[] curr = q.poll();\\n                if (curr[0] == n - 1 && curr[1] == n - 1 && curr[2] == 0) return step;\\n                int r = curr[0] + dir[curr[2]][0], c = curr[1] + dir[curr[2]][1], hash = (r * n + c) * 2 + curr[2];\\n                if (r < n && c < n && g[r][c] == 0 && !vs.contains(hash)) {\\n                    vs.add(hash);\\n                    q.offer(new int[]{r, c, curr[2]});\\n                }\\n                if (curr[2] == 0 && curr[1] > 0) {\\n                    r = curr[0] + 1; c = curr[1] - 1; hash = (r * n + c) * 2 + 1;\\n                    if (r < n && g[r][curr[1]] == 0 && g[r][c] == 0) {\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 1});\\n                        }\\n                        hash = (r * n + ++c) * 2 + 0;\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 0});\\n                        }\\n                    }\\n                }\\n                if (curr[2] == 1 && curr[0] > 0) {\\n                    r = curr[0] - 1; c = curr[1] + 1; hash = (r * n + c) * 2 + 0;\\n                    if (c < n && g[curr[0]][c] == 0 && g[r][c] == 0 ) {\\n                        if (!vs.contains(hash)){\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 0});\\n                        }\\n                        hash = (++r * n + c) * 2 + 1;\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 1});\\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minimumMoves(int[][] g) {\\n        int n = g.length, step = 0;\\n        Set<Integer> vs = new HashSet<>();\\n        Queue<int[]> q = new LinkedList<>();\\n        if (g[0][0] == 1 || g[0][1] == 1) return -1;\\n        q.offer(new int[]{0, 1, 0});\\n        vs.add(2);\\n        int[][] dir = new int[][]{{0, 1}, {1, 0}};\\n        while (!q.isEmpty()) {\\n            for (int i = 0, len = q.size(); i < len; i++) {\\n                int[] curr = q.poll();\\n                if (curr[0] == n - 1 && curr[1] == n - 1 && curr[2] == 0) return step;\\n                int r = curr[0] + dir[curr[2]][0], c = curr[1] + dir[curr[2]][1], hash = (r * n + c) * 2 + curr[2];\\n                if (r < n && c < n && g[r][c] == 0 && !vs.contains(hash)) {\\n                    vs.add(hash);\\n                    q.offer(new int[]{r, c, curr[2]});\\n                }\\n                if (curr[2] == 0 && curr[1] > 0) {\\n                    r = curr[0] + 1; c = curr[1] - 1; hash = (r * n + c) * 2 + 1;\\n                    if (r < n && g[r][curr[1]] == 0 && g[r][c] == 0) {\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 1});\\n                        }\\n                        hash = (r * n + ++c) * 2 + 0;\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 0});\\n                        }\\n                    }\\n                }\\n                if (curr[2] == 1 && curr[0] > 0) {\\n                    r = curr[0] - 1; c = curr[1] + 1; hash = (r * n + c) * 2 + 0;\\n                    if (c < n && g[curr[0]][c] == 0 && g[r][c] == 0 ) {\\n                        if (!vs.contains(hash)){\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 0});\\n                        }\\n                        hash = (++r * n + c) * 2 + 1;\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 1});\\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 457270,
                "title": "c-bfs-50-runtime-100-memory",
                "content": "BFS, tries for all possible states, tracks which ones have been visited with State\\'s id so we don\\'t visit those again\\n\\n\\n\\'\\'\\'\\nclass Solution {\\n    public:\\n        int N;\\n    const int dir[4][2] = { {-1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\\n    struct State {\\n        int r, c, d, moves, id;\\n        State(int r, int c, int d, int moves): r(r), c(c), d(d), moves(moves), id(r * 10000 + c * 100 + d) {}\\n    };\\n\\n    int minimumMoves(vector < vector < int >> & grid) {\\n        N = grid.size();\\n        int res = INT_MAX;\\n        queue < State > que;\\n        unordered_set < int > vis;\\n        que.push(State(0, 0, 1, 0)); //original state\\n        while (!que.empty()) {\\n            State curr = que.front();\\n            que.pop();\\n            int d = curr.d, tr = curr.r, tc = curr.c, hr = tr + dir[d][0], hc = tc + dir[d][1];\\n            if (out(tr) || out(tc) || out(hr) || out(hc) || grid[hr][hc] == 1 || grid[tr][tc] == 1 || vis.count(curr.id)) continue; //bad conditions\\n            if (reachEnd(curr)) { //yay!\\n                res = min(res, curr.moves);\\n                continue;\\n            }\\n            vis.insert(curr.id);\\n            que.push(State(tr, tc + 1, d, curr.moves + 1)); //shift right\\n            que.push(State(tr + 1, tc, d, curr.moves + 1)); //shift down\\n            if (tr == hr && tr != N - 1 && grid[tr + 1][tc] == 0 && grid[hr + 1][hc] == 0) que.push(State(tr, tc, (d + 1) % 4, curr.moves +\\n            1)); //horizontal? inbound? both cells below are 0? then rotate clockwise\\n            if (tc == hc && tc != N - 1 && grid[tr][tc + 1] == 0 && grid[hr][hc + 1] == 0) que.push(State(tr, tc, (d + 3) % 4, curr.moves +\\n            1)); //vertical? inbound? both cells right are 0? rotate ccw\\n        }\\n        return res == INT_MAX ? -1 : res; //we were never able to reach the end\\n    }\\n\\n    bool out(int curr) {\\n        return curr < 0 || curr >= N;\\n    }\\n\\n    bool reachEnd(State curr) {\\n        int tr = curr.r, tc = curr.c, hr = tr + dir[curr.d][0], hc = tc + dir[curr.d][1];\\n        return tr == N - 1 && hr == N - 1 && hc == N - 1 && tc == N - 2;\\n    }\\n\\n\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int N;\\n    const int dir[4][2] = { {-1, 0 }",
                "codeTag": "Java"
            },
            {
                "id": 393584,
                "title": "java-organized-bfs-solution-beats-100-both-time-and-space-complexity",
                "content": "Create a class to represent the Position of the snake and the number of moves it took to reach that Position.\\n\\nTraverse BFS to traverse the closest positions FIRST, and saving the already traversed Positions in a Visited Set to avoid traversing them again. This works because the first traversal of a Position WILL be the SHORTEST since we\\'re using BFS.\\n\\nFor each iteration, check to see if position has reached the target, if true, then return the saved number of Moves. No need to explore more paths since with the given number of moves (Right, Down, CounterClockwise, Clockwise) with no repeated positions allowed, if the snake reaches the end, it will always be in the same number of moves.\\nE.g: If the Snake reaches the end in 11 moves, it won\\'t be able to reach the end in more or less moves if another solution exists.\\n\\n```\\nclass Position {\\n    int x1 = 0;\\n    int y1 = 0;\\n    int x2 = 0;\\n    int y2 = 0;\\n    int moves;\\n    // (x1, y1) is front\\n    // (x2, y2) is behind\\n    public Position(int x1, int y1, int x2, int y2) {\\n        this.x1 = x1;\\n        this.x2 = x2;\\n        this.y1 = y1;\\n        this.y2 = y2;\\n        this.moves = 0;\\n    }\\n    \\n    public Position(int x1, int y1, int x2, int y2, int moves) {\\n        this.x1 = x1;\\n        this.x2 = x2;\\n        this.y1 = y1;\\n        this.y2 = y2;\\n        this.moves = moves;\\n    }\\n    \\n    // Used to compare Positions within Set to avoid duplicates\\n    @Override \\n    public boolean equals(Object o) {\\n        if (this == o) return true;\\n        if (o == null) return false;\\n        if (!(o instanceof Position)) {\\n            return false;\\n        }\\n        Position p = (Position) o;\\n        return (p.x1 == this.x1 && p.y1 == this.y1\\n           && p.x2 == this.x2 && p.y2 == this.y2);\\n    }\\n    @Override\\n    public int hashCode() {\\n        int result = 17;\\n        result = 31 * result + this.x1;\\n        result = 31 * result + this.x2;\\n        result = 31 * result + this.y1;\\n        result = 31 * result + this.y2;\\n        return result;\\n        \\n    }\\n}\\npublic class Solution {\\n    private int n;\\n    private Set<Position> visited;\\n    public int minimumMoves(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return -1;\\n        \\n        // Initializing variables, setup \\n        n = grid.length;\\n        visited = new HashSet<Position>();\\n        Position position = new Position(0, 1, 0, 0);\\n        Queue<Position> q = new LinkedList<>();\\n        \\n        q.offer(position);\\n        if (!validateValidP(grid, position)) {\\n            return -1;\\n        }\\n        \\n        // BFS\\n        while (!q.isEmpty()) {\\n            Position cur = q.poll();\\n            Position right = moveRight(grid, cur, cur.moves);\\n            Position down = moveDown(grid, cur, cur.moves);\\n            Position clock = moveClock(grid, cur, cur.moves);\\n            Position counterClock = moveCounterClock(grid, cur, cur.moves);\\n            if (validateWin(cur)) {\\n                return cur.moves;\\n            }\\n            if (right != null) {\\n                q.offer(right);\\n            }\\n            if (down != null) {\\n                q.offer(down);\\n            }\\n            if (clock != null) {\\n                q.offer(clock);\\n            }\\n            if (counterClock != null) {\\n                q.offer(counterClock);\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    private Position moveRight(int[][] grid, Position p, int moves) {\\n        Position rightP = new Position(p.x1, p.y1 + 1, p.x2, p.y2 + 1, moves + 1);\\n        if (validateValidP(grid, rightP)) {\\n            return rightP;\\n        }\\n        return null;\\n    }\\n    private Position moveDown(int[][] grid, Position p, int moves) {\\n        Position downP = new Position(p.x1 + 1, p.y1, p.x2 + 1, p.y2, moves + 1);\\n        if (validateValidP(grid, downP)) {\\n            return downP;\\n        }\\n        return null;\\n    }\\n    private Position moveClock(int[][] grid, Position p, int moves) {\\n        // Not horizontal\\n        if (p.y1 != p.y2 + 1) {\\n            return null;\\n        }\\n        if (p.x1 + 1 >= n || grid[p.x1 + 1][p.y1] == 1 || p.x2 + 1 >= n || grid[p.x2 + 1][p.y2] == 1) {\\n            return null; // Blocker\\n        }\\n        Position clockP = new Position(p.x1 + 1, p.y1 - 1, p.x2, p.y2, moves + 1);\\n        // Cannot move back to same position in next position\\n        if (validateValidP(grid, clockP)) {\\n            return clockP;\\n        }\\n        return null;\\n    }\\n    private Position moveCounterClock(int[][] grid, Position p, int moves) {\\n        // Not Vertical\\n        if (p.x1 != p.x2 + 1) {\\n            return null;\\n        }\\n        if (p.y1 + 1 >= n || grid[p.x1][p.y1 + 1] == 1 || p.y2 + 1 >= n || grid[p.x2][p.y2 + 1] == 1) {\\n            return null; // Blocker\\n        }\\n        Position counterClockP = new Position(p.x1 - 1, p.y1 + 1, p.x2, p.y2, moves + 1);\\n        if (validateValidP(grid, counterClockP)) {\\n            return counterClockP;\\n        }\\n        return null;\\n    }\\n    private boolean validateWin(Position p) {\\n        if (p.x1 == n - 1 && p.y1 == n - 1\\n            && p.x2 == n - 1 && p.y2 == n - 2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    private boolean validateValidP(int[][] grid, Position p) {\\n        if (p.x1 < 0 || p.x1 >= n \\n            || p.x2 < 0 || p.x2 >= n\\n           || p.y1 < 0 || p.y1 >= n\\n            || p.y2 < 0 || p.y2 >= n) {\\n            return false;\\n        }\\n        if (grid[p.x1][p.y1] == 1 || grid[p.x2][p.y2] == 1) {\\n            return false;\\n        }\\n        return visited.add(p);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Position {\\n    int x1 = 0;\\n    int y1 = 0;\\n    int x2 = 0;\\n    int y2 = 0;\\n    int moves;\\n    // (x1, y1) is front\\n    // (x2, y2) is behind\\n    public Position(int x1, int y1, int x2, int y2) {\\n        this.x1 = x1;\\n        this.x2 = x2;\\n        this.y1 = y1;\\n        this.y2 = y2;\\n        this.moves = 0;\\n    }\\n    \\n    public Position(int x1, int y1, int x2, int y2, int moves) {\\n        this.x1 = x1;\\n        this.x2 = x2;\\n        this.y1 = y1;\\n        this.y2 = y2;\\n        this.moves = moves;\\n    }\\n    \\n    // Used to compare Positions within Set to avoid duplicates\\n    @Override \\n    public boolean equals(Object o) {\\n        if (this == o) return true;\\n        if (o == null) return false;\\n        if (!(o instanceof Position)) {\\n            return false;\\n        }\\n        Position p = (Position) o;\\n        return (p.x1 == this.x1 && p.y1 == this.y1\\n           && p.x2 == this.x2 && p.y2 == this.y2);\\n    }\\n    @Override\\n    public int hashCode() {\\n        int result = 17;\\n        result = 31 * result + this.x1;\\n        result = 31 * result + this.x2;\\n        result = 31 * result + this.y1;\\n        result = 31 * result + this.y2;\\n        return result;\\n        \\n    }\\n}\\npublic class Solution {\\n    private int n;\\n    private Set<Position> visited;\\n    public int minimumMoves(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return -1;\\n        \\n        // Initializing variables, setup \\n        n = grid.length;\\n        visited = new HashSet<Position>();\\n        Position position = new Position(0, 1, 0, 0);\\n        Queue<Position> q = new LinkedList<>();\\n        \\n        q.offer(position);\\n        if (!validateValidP(grid, position)) {\\n            return -1;\\n        }\\n        \\n        // BFS\\n        while (!q.isEmpty()) {\\n            Position cur = q.poll();\\n            Position right = moveRight(grid, cur, cur.moves);\\n            Position down = moveDown(grid, cur, cur.moves);\\n            Position clock = moveClock(grid, cur, cur.moves);\\n            Position counterClock = moveCounterClock(grid, cur, cur.moves);\\n            if (validateWin(cur)) {\\n                return cur.moves;\\n            }\\n            if (right != null) {\\n                q.offer(right);\\n            }\\n            if (down != null) {\\n                q.offer(down);\\n            }\\n            if (clock != null) {\\n                q.offer(clock);\\n            }\\n            if (counterClock != null) {\\n                q.offer(counterClock);\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    private Position moveRight(int[][] grid, Position p, int moves) {\\n        Position rightP = new Position(p.x1, p.y1 + 1, p.x2, p.y2 + 1, moves + 1);\\n        if (validateValidP(grid, rightP)) {\\n            return rightP;\\n        }\\n        return null;\\n    }\\n    private Position moveDown(int[][] grid, Position p, int moves) {\\n        Position downP = new Position(p.x1 + 1, p.y1, p.x2 + 1, p.y2, moves + 1);\\n        if (validateValidP(grid, downP)) {\\n            return downP;\\n        }\\n        return null;\\n    }\\n    private Position moveClock(int[][] grid, Position p, int moves) {\\n        // Not horizontal\\n        if (p.y1 != p.y2 + 1) {\\n            return null;\\n        }\\n        if (p.x1 + 1 >= n || grid[p.x1 + 1][p.y1] == 1 || p.x2 + 1 >= n || grid[p.x2 + 1][p.y2] == 1) {\\n            return null; // Blocker\\n        }\\n        Position clockP = new Position(p.x1 + 1, p.y1 - 1, p.x2, p.y2, moves + 1);\\n        // Cannot move back to same position in next position\\n        if (validateValidP(grid, clockP)) {\\n            return clockP;\\n        }\\n        return null;\\n    }\\n    private Position moveCounterClock(int[][] grid, Position p, int moves) {\\n        // Not Vertical\\n        if (p.x1 != p.x2 + 1) {\\n            return null;\\n        }\\n        if (p.y1 + 1 >= n || grid[p.x1][p.y1 + 1] == 1 || p.y2 + 1 >= n || grid[p.x2][p.y2 + 1] == 1) {\\n            return null; // Blocker\\n        }\\n        Position counterClockP = new Position(p.x1 - 1, p.y1 + 1, p.x2, p.y2, moves + 1);\\n        if (validateValidP(grid, counterClockP)) {\\n            return counterClockP;\\n        }\\n        return null;\\n    }\\n    private boolean validateWin(Position p) {\\n        if (p.x1 == n - 1 && p.y1 == n - 1\\n            && p.x2 == n - 1 && p.y2 == n - 2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    private boolean validateValidP(int[][] grid, Position p) {\\n        if (p.x1 < 0 || p.x1 >= n \\n            || p.x2 < 0 || p.x2 >= n\\n           || p.y1 < 0 || p.y1 >= n\\n            || p.y2 < 0 || p.y2 >= n) {\\n            return false;\\n        }\\n        if (grid[p.x1][p.y1] == 1 || grid[p.x2][p.y2] == 1) {\\n            return false;\\n        }\\n        return visited.add(p);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393176,
                "title": "java-19ms-concise-bfs-solution-with-explanation-please-comment-if-you-see-things-can-improve",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        if(grid == null || grid.length < 1 || grid[0].length < 2) {\\n            return -1;\\n        } \\n        \\n        int n = grid.length, moves = 0;\\n        if(grid[n - 1][n-2] == 1 || grid[n-1][n-1] == 1) {\\n            return -1;\\n        }\\n        \\n        boolean[][][] visited = new boolean[n][n][2];                 // location of the tail and two directions\\n        Deque<Position> frontier = new LinkedList<Position>(), newFrontier = null;\\n        Position target = new Position(n - 1, n - 2, 0), newP = null;\\n        frontier.add(new Position(0, 0, 0));\\n        visited[0][0][0] = true;\\n        while(frontier.size() > 0) {\\n           ++moves;\\n            newFrontier = new LinkedList<Position>();\\n            for(Position cur : frontier) {\\n                /// scenairo one moving along the snake\\n                int newHeadX = cur.tailX + 2 * dirs[cur.direction][0];\\n                int newHeadY = cur.tailY + 2 * dirs[cur.direction][1]; \\n                if(newHeadX < n && newHeadY < n && grid[newHeadX][newHeadY] == 0) {\\n                    newP = new Position(cur.tailX + dirs[cur.direction][0], cur.tailY + dirs[cur.direction][1], cur.direction);\\n                    if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                        visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                        newFrontier.add(newP);\\n                    }\\n                }\\n                \\n                // scneario two rotate or moving perpendicular\\n                int oDirec = 1 - cur.direction;   // 1 -> 0 or 0 - > 1\\n                newHeadX = cur.tailX + dirs[oDirec][0];\\n                newHeadY = cur.tailY + dirs[oDirec][1];\\n                if(newHeadX < n && newHeadY < n) {\\n                    if(grid[newHeadX][newHeadY] == 0\\n                       && grid[newHeadX + dirs[cur.direction][0]][newHeadY + dirs[cur.direction][1]] == 0) {\\n                        // rotation\\n                        newP = new Position(cur.tailX, cur.tailY, oDirec);\\n                        if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                            visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                            newFrontier.add(newP);\\n                        }\\n                        \\n                        // moving the entire stack perpendicular to its direction\\n                        newP = new Position(newHeadX, newHeadY, cur.direction);\\n                        if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                            visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                            newFrontier.add(newP);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(visited[target.tailX][target.tailY][target.direction]) {\\n                return moves;    \\n            }\\n            \\n            frontier = newFrontier;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int[][] dirs = new int[][] {{0,1}, {1,0}};\\n    public class Position {\\n        public int tailX;\\n        public int tailY;\\n        public int direction;\\n        \\n        public Position(int x, int y, int direction) {\\n            this.tailX = x;\\n            this.tailY = y;\\n            this.direction = direction;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        if(grid == null || grid.length < 1 || grid[0].length < 2) {\\n            return -1;\\n        } \\n        \\n        int n = grid.length, moves = 0;\\n        if(grid[n - 1][n-2] == 1 || grid[n-1][n-1] == 1) {\\n            return -1;\\n        }\\n        \\n        boolean[][][] visited = new boolean[n][n][2];                 // location of the tail and two directions\\n        Deque<Position> frontier = new LinkedList<Position>(), newFrontier = null;\\n        Position target = new Position(n - 1, n - 2, 0), newP = null;\\n        frontier.add(new Position(0, 0, 0));\\n        visited[0][0][0] = true;\\n        while(frontier.size() > 0) {\\n           ++moves;\\n            newFrontier = new LinkedList<Position>();\\n            for(Position cur : frontier) {\\n                /// scenairo one moving along the snake\\n                int newHeadX = cur.tailX + 2 * dirs[cur.direction][0];\\n                int newHeadY = cur.tailY + 2 * dirs[cur.direction][1]; \\n                if(newHeadX < n && newHeadY < n && grid[newHeadX][newHeadY] == 0) {\\n                    newP = new Position(cur.tailX + dirs[cur.direction][0], cur.tailY + dirs[cur.direction][1], cur.direction);\\n                    if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                        visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                        newFrontier.add(newP);\\n                    }\\n                }\\n                \\n                // scneario two rotate or moving perpendicular\\n                int oDirec = 1 - cur.direction;   // 1 -> 0 or 0 - > 1\\n                newHeadX = cur.tailX + dirs[oDirec][0];\\n                newHeadY = cur.tailY + dirs[oDirec][1];\\n                if(newHeadX < n && newHeadY < n) {\\n                    if(grid[newHeadX][newHeadY] == 0\\n                       && grid[newHeadX + dirs[cur.direction][0]][newHeadY + dirs[cur.direction][1]] == 0) {\\n                        // rotation\\n                        newP = new Position(cur.tailX, cur.tailY, oDirec);\\n                        if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                            visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                            newFrontier.add(newP);\\n                        }\\n                        \\n                        // moving the entire stack perpendicular to its direction\\n                        newP = new Position(newHeadX, newHeadY, cur.direction);\\n                        if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                            visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                            newFrontier.add(newP);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(visited[target.tailX][target.tailY][target.direction]) {\\n                return moves;    \\n            }\\n            \\n            frontier = newFrontier;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int[][] dirs = new int[][] {{0,1}, {1,0}};\\n    public class Position {\\n        public int tailX;\\n        public int tailY;\\n        public int direction;\\n        \\n        public Position(int x, int y, int direction) {\\n            this.tailX = x;\\n            this.tailY = y;\\n            this.direction = direction;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393082,
                "title": "java-concise-bfs-solution-with-comments",
                "content": "```Java\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int res = 0;\\n        int[][] start = {{0, 0}, {0, 1}};\\n        Queue<int[][]> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        q.add(start);\\n        visited.add(toString(start));\\n        while (!q.isEmpty()) {\\n            for (int size = q.size(); size > 0; size--) {\\n                int[][] cur = q.poll();\\n                if (cur[0][0] == n - 1 && cur[0][1] == n - 2 && cur[1][0] == n - 1 && cur[1][1] == n - 1) return res;\\n                int[] tail = cur[0], head = cur[1];\\n                int x = tail[0], y = tail[1];\\n                if (tail[0] == head[0]) { // horizontal\\n                    if (x < n - 1 && grid[x+1][y] == 0 && grid[x+1][y+1] == 0) {\\n                        int[][] down = {{x + 1, y}, {x + 1, y + 1}}; // down\\n                        int[][] turn = {{x, y}, {x + 1, y}}; // clockwise\\n                        if (visited.add(toString(down))) q.offer(down);\\n                        if (visited.add(toString(turn))) q.offer(turn);\\n                    }\\n                    if (y + 2 < n && grid[x][y+2] == 0) {\\n                        int[][] right = {{x, y + 1}, {x, y + 2}}; // right\\n                        if (visited.add(toString(right))) q.offer(right);\\n                    } \\n                } else { // vertical\\n                    if (y < n - 1 && grid[x][y+1] == 0 && grid[x+1][y+1] == 0) {\\n                        int[][] right = {{x, y + 1}, {x + 1, y + 1}}; // right\\n                        int[][] turn = {{x,y}, {x, y + 1}}; // counterclockwise\\n                        if (visited.add(toString(right))) q.offer(right);\\n                        if (visited.add(toString(turn))) q.offer(turn);\\n                    }\\n                    \\n                    if (x + 2 < n && grid[x+2][y] == 0) {\\n                        int[][] down = {{x+1, y}, {x+2, y}}; // down\\n                        if (visited.add(toString(down))) q.offer(down);\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    private String toString(int[][] pos) {\\n        return pos[0][0] + \":\" + pos[0][1] + \":\" + pos[1][0] + \":\" + pos[1][1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int res = 0;\\n        int[][] start = {{0, 0}, {0, 1}};\\n        Queue<int[][]> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        q.add(start);\\n        visited.add(toString(start));\\n        while (!q.isEmpty()) {\\n            for (int size = q.size(); size > 0; size--) {\\n                int[][] cur = q.poll();\\n                if (cur[0][0] == n - 1 && cur[0][1] == n - 2 && cur[1][0] == n - 1 && cur[1][1] == n - 1) return res;\\n                int[] tail = cur[0], head = cur[1];\\n                int x = tail[0], y = tail[1];\\n                if (tail[0] == head[0]) { // horizontal\\n                    if (x < n - 1 && grid[x+1][y] == 0 && grid[x+1][y+1] == 0) {\\n                        int[][] down = {{x + 1, y}, {x + 1, y + 1}}; // down\\n                        int[][] turn = {{x, y}, {x + 1, y}}; // clockwise\\n                        if (visited.add(toString(down))) q.offer(down);\\n                        if (visited.add(toString(turn))) q.offer(turn);\\n                    }\\n                    if (y + 2 < n && grid[x][y+2] == 0) {\\n                        int[][] right = {{x, y + 1}, {x, y + 2}}; // right\\n                        if (visited.add(toString(right))) q.offer(right);\\n                    } \\n                } else { // vertical\\n                    if (y < n - 1 && grid[x][y+1] == 0 && grid[x+1][y+1] == 0) {\\n                        int[][] right = {{x, y + 1}, {x + 1, y + 1}}; // right\\n                        int[][] turn = {{x,y}, {x, y + 1}}; // counterclockwise\\n                        if (visited.add(toString(right))) q.offer(right);\\n                        if (visited.add(toString(turn))) q.offer(turn);\\n                    }\\n                    \\n                    if (x + 2 < n && grid[x+2][y] == 0) {\\n                        int[][] down = {{x+1, y}, {x+2, y}}; // down\\n                        if (visited.add(toString(down))) q.offer(down);\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    private String toString(int[][] pos) {\\n        return pos[0][0] + \":\" + pos[0][1] + \":\" + pos[1][0] + \":\" + pos[1][1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393032,
                "title": "java-bfs-with-snake-class-easy-to-understand",
                "content": "The idea is to use BFS to find the shortest path to the destination. \\n\\nWe traverse all snake position (stored in the queue with recorded size) after each step. For each possible snake position, we could try 4 moves, right, down, clockwise, counter clockwise in the next move. If the next move is valid, we add it to the queue.\\n\\nif the destination (note: must be horizontal position) is found during the traversal, return the step. If the destination is not found and the queue is empty (no more possible snake position), it means that the destination is not reachable therefore return false.\\n\\n`Snake` class is declared to store the position (horizontal/vertical) , the head position, and an id (avoid duplicate snake added to the queue).\\n\\nWe reocrd the snake id to dedupe the snake position we have visited in the previous steps (less steps, shorter path). \\n\\n\\xB7\\xB7\\xB7\\n\\n\\tclass Solution {\\n\\t\\tpublic int minimumMoves(int[][] grid) {\\n\\t\\t\\tint rowCnt = grid.length, colCnt = grid[0].length;\\n\\t\\t\\tint[] des = {rowCnt - 1, colCnt - 1};\\n\\t\\t\\tQueue<Snake> level = new LinkedList<>();\\n\\t\\t\\tSnake origin = new Snake(true, new int[] {0, 1});\\n\\t\\t\\tSet<String> visited = new HashSet<>();\\n\\t\\t\\tlevel.offer(origin);\\n\\t\\t\\tvisited.add(origin.id);\\n\\t\\t\\tint step = -1;\\n\\n\\t\\t\\twhile (!level.isEmpty()) {\\n\\t\\t\\t\\t// record the current queue size, these are all possible snake positions after \"step\" steps. We reocrd the size here because we could add more snake positions into the queue during iterations.\\n\\t\\t\\t\\tint size = level.size();\\n\\t\\t\\t\\tfor (int i = 0; i < size; i++) {  \\n\\t\\t\\t\\t\\tSnake curr = level.poll();\\n\\t\\t\\t\\t\\tif (curr.isHor && curr.headPos[0] == des[0] && curr.headPos[1] == des[1]) {\\n\\t\\t\\t\\t\\t\\treturn step + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tSnake r = moveRight(curr, grid);\\n\\t\\t\\t\\t\\tSnake d = moveDown(curr, grid);\\n\\t\\t\\t\\t\\tSnake c = moveClock(curr, grid);\\n\\t\\t\\t\\t\\tSnake cc = moveCounter(curr, grid);\\n\\t\\t\\t\\t\\tif (!visited.contains(r.id) && r.headPos[0] != -1) {\\n\\t\\t\\t\\t\\t\\tlevel.offer(r);\\n\\t\\t\\t\\t\\t\\tvisited.add(r.id);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!visited.contains(d.id) && d.headPos[0] != -1) {\\n\\t\\t\\t\\t\\t\\tlevel.offer(d);\\n\\t\\t\\t\\t\\t\\tvisited.add(d.id);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!visited.contains(c.id) && c.headPos[0] != -1) {\\n\\t\\t\\t\\t\\t\\tlevel.offer(c);\\n\\t\\t\\t\\t\\t\\tvisited.add(c.id);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!visited.contains(cc.id) && cc.headPos[0] != -1) {\\n\\t\\t\\t\\t\\t\\tlevel.offer(cc);\\n\\t\\t\\t\\t\\t\\tvisited.add(cc.id);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstep++;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tprivate Snake moveRight(Snake s, int[][] grid) {\\n\\t\\t\\tSnake success = new Snake(s.isHor, new int[] {s.headPos[0], s.headPos[1] + 1});\\n\\t\\t\\tif (isValid(success, grid)) {\\n\\t\\t\\t\\tif (s.isHor && grid[s.headPos[0]][s.headPos[1] + 1] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t} else if (!s.isHor\\n\\t\\t\\t\\t   && grid[s.headPos[0]][s.headPos[1] + 1] == 0\\n\\t\\t\\t\\t   && grid[s.headPos[0] - 1][s.headPos[1] + 1] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn new Snake(s.isHor, new int[] {-1, -1}); \\n\\t\\t}\\n\\n\\t\\tprivate Snake moveDown(Snake s, int[][] grid) {\\n\\t\\t\\tSnake success = new Snake(s.isHor, new int[] {s.headPos[0] + 1, s.headPos[1]});\\n\\t\\t\\tif (isValid(success, grid)) {\\n\\t\\t\\t\\tif (!s.isHor\\n\\t\\t\\t\\t   && grid[s.headPos[0] + 1][s.headPos[1]] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t} else if (s.isHor\\n\\t\\t\\t\\t   && grid[s.headPos[0] + 1][s.headPos[1]] == 0\\n\\t\\t\\t\\t   && grid[s.headPos[0] + 1][s.headPos[1] - 1] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn new Snake(s.isHor, new int[] {-1, -1}); \\n\\t\\t}\\n\\n\\t\\tprivate Snake moveClock(Snake s, int[][] grid) {\\n\\t\\t\\tSnake success = new Snake(!s.isHor, new int[] {s.headPos[0] + 1, s.headPos[1] - 1});\\n\\t\\t\\tif (isValid(success, grid)) {\\n\\t\\t\\t\\tif (s.isHor && grid[s.headPos[0] + 1][s.headPos[1]] == 0\\n\\t\\t\\t\\t   && grid[s.headPos[0] + 1][s.headPos[1] - 1] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn new Snake(s.isHor, new int[] {-1, -1});  \\n\\t\\t}\\n\\n\\t\\tprivate Snake moveCounter(Snake s, int[][] grid) {\\n\\t\\t\\tSnake success = new Snake(!s.isHor, new int[] {s.headPos[0] - 1, s.headPos[1] + 1});\\n\\t\\t\\tif (isValid(success, grid)) { \\n\\t\\t\\t\\tif (!s.isHor\\n\\t\\t\\t\\t   && grid[s.headPos[0] - 1][s.headPos[1] + 1] == 0\\n\\t\\t\\t\\t   && grid[s.headPos[0]][s.headPos[1] + 1] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn new Snake(s.isHor, new int[] {-1, -1}); \\n\\t\\t}\\n\\n\\t\\tprivate boolean isValid(Snake s, int[][] grid) {\\n\\t\\t\\tif (s.headPos[0] >= 0 && s.headPos[0] < grid.length \\n\\t\\t\\t\\t&& s.headPos[1] >= 0 && s.headPos[1] < grid[0].length) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tclass Snake {\\n\\t\\tboolean isHor;\\n\\t\\tint[] headPos;\\n\\t\\tString id;\\n\\n\\t\\tpublic Snake(boolean isHor, int[] headPos) {\\n\\t\\t\\tthis.isHor = isHor;\\n\\t\\t\\tthis.headPos = headPos;\\n\\t\\t\\tthis.id = isHor + \"_\" + headPos[0] + \"_\" + headPos[1];\\n\\t\\t}\\n\\t}\\n\\t\\n\\xB7\\xB7\\xB7",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minimumMoves(int[][] grid) {\\n\\t\\t\\tint rowCnt = grid.length, colCnt = grid[0].length;\\n\\t\\t\\tint[] des = {rowCnt - 1, colCnt - 1}",
                "codeTag": "Java"
            },
            {
                "id": 392942,
                "title": "python-concise-bfs",
                "content": "```\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        cur,cnt, n, seen = [(0,0,0)], 0 , len(grid),set([(0,0,0)])      #(tail_row,tail_col,horizontal_or_verticle)\\n        while cur and (n-1,n-2,0) not in cur:\\n            cnt,tmp = cnt+1, []\\n            for x,y,dx in cur:\\n                if dx==0:\\n                    if y+2 < n and grid[x][y+2] == 0: tmp += [(x,y+1,dx)]\\n                    if x+1 < n and (grid[x+1][y] + grid[x+1][y+1]) == 0: tmp += [(x,y,1),(x+1,y,0)]\\n                else:\\n                    if x+2 < n and grid[x+2][y] == 0: tmp += [(x+1,y,dx)]\\n                    if y+1 < n and (grid[x][y+1] + grid[x+1][y+1]) == 0: tmp += [(x,y,0),(x,y+1,1)]\\n            cur = set(tmp) - seen\\n            seen |= cur\\n        return cnt if cur else -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        cur,cnt, n, seen = [(0,0,0)], 0 , len(grid),set([(0,0,0)])      #(tail_row,tail_col,horizontal_or_verticle)\\n        while cur and (n-1,n-2,0) not in cur:\\n            cnt,tmp = cnt+1, []\\n            for x,y,dx in cur:\\n                if dx==0:\\n                    if y+2 < n and grid[x][y+2] == 0: tmp += [(x,y+1,dx)]\\n                    if x+1 < n and (grid[x+1][y] + grid[x+1][y+1]) == 0: tmp += [(x,y,1),(x+1,y,0)]\\n                else:\\n                    if x+2 < n and grid[x+2][y] == 0: tmp += [(x+1,y,dx)]\\n                    if y+1 < n and (grid[x][y+1] + grid[x+1][y+1]) == 0: tmp += [(x,y,0),(x,y+1,1)]\\n            cur = set(tmp) - seen\\n            seen |= cur\\n        return cnt if cur else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 392932,
                "title": "python-dp-solution",
                "content": "dp[i][j][k]: minimum moves make snake tail to grid[i][j], where k = 0 means horizontal and k = 1 means vertical\\n\\n```\\ndef minimumMoves(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        if grid[-1][-1] == 1:\\n            return -1\\n        dp = [[[float(\\'inf\\'), float(\\'inf\\')] for i in xrange(n)] for j in xrange(n)]\\n        dp[0][0][0] = 0\\n        for j in xrange(1, n - 1):\\n            if grid[0][j + 1] == 0:\\n                dp[0][j][0] = dp[0][j - 1][0] + 1\\n            else:\\n                break\\n        for i in xrange(n):\\n            for j in xrange(n):\\n                if j < n - 1 and grid[i][j + 1] == 0:\\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)\\n                    if grid[i][j] == 0:\\n                        dp[i][j][0] = min(dp[i][j][0],dp[i - 1][j][0] + 1)\\n                if i < n - 1 and grid[i + 1][j] == 0:\\n                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)\\n                    if grid[i][j] == 0:\\n                        dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)\\n                if i < n - 1 and j < n - 1 and grid[i][j + 1] == grid[i + 1][j] == grid[i + 1][j + 1] == 0:\\n                    dp[i][j][0], dp[i][j][1] = min(dp[i][j][0], dp[i][j][1] + 1), min(dp[i][j][1], dp[i][j][0] + 1)\\n        return dp[n - 1][n - 2][0] if dp[n - 1][n - 2][0] < float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ndef minimumMoves(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        if grid[-1][-1] == 1:\\n            return -1\\n        dp = [[[float(\\'inf\\'), float(\\'inf\\')] for i in xrange(n)] for j in xrange(n)]\\n        dp[0][0][0] = 0\\n        for j in xrange(1, n - 1):\\n            if grid[0][j + 1] == 0:\\n                dp[0][j][0] = dp[0][j - 1][0] + 1\\n            else:\\n                break\\n        for i in xrange(n):\\n            for j in xrange(n):\\n                if j < n - 1 and grid[i][j + 1] == 0:\\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)\\n                    if grid[i][j] == 0:\\n                        dp[i][j][0] = min(dp[i][j][0],dp[i - 1][j][0] + 1)\\n                if i < n - 1 and grid[i + 1][j] == 0:\\n                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)\\n                    if grid[i][j] == 0:\\n                        dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)\\n                if i < n - 1 and j < n - 1 and grid[i][j + 1] == grid[i + 1][j] == grid[i + 1][j + 1] == 0:\\n                    dp[i][j][0], dp[i][j][1] = min(dp[i][j][0], dp[i][j][1] + 1), min(dp[i][j][1], dp[i][j][0] + 1)\\n        return dp[n - 1][n - 2][0] if dp[n - 1][n - 2][0] < float(\\'inf\\') else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3973547,
                "title": "breadth-first-search-o-n-m-faster-than-50-clean-java-code",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass State {\\n    int x;\\n    int y;\\n    int other_x;\\n    int other_y;\\n    boolean isHorizontal;\\n\\n    public State(int x, int y, boolean isHorizontal) {\\n        this.x = x;\\n        this.y = y;\\n        this.isHorizontal = isHorizontal;\\n        int[] otherCell = getOtherCell();\\n        other_x = otherCell[0];\\n        other_y = otherCell[1];\\n    }\\n\\n    public int[] getOtherCell() {\\n        if (isHorizontal) return new int[] {x, y + 1};\\n        else return new int[] {x + 1, y};\\n    }\\n\\n    public State rotate() {\\n        return new State(x, y, !isHorizontal);\\n    }\\n}\\n\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{0, 1},\\n            new Integer[]{1, 0}\\n    );\\n    private final Queue<State> queue = new ArrayDeque<>();\\n    private boolean[][][] visited;\\n\\n    public int minimumMoves(int[][] grid) {\\n        queue.add(new State(0, 0, true));\\n        visited = new boolean[grid.length][grid[0].length][2];\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int count = 0; count < size; count++) {\\n                State curr = queue.remove();\\n                if (isTarget(curr, grid)) return steps;\\n                int i = curr.x, j = curr.y, k = curr.isHorizontal ? 0 : 1;\\n                if (visited[i][j][k]) continue;\\n                visited[i][j][k] = true;\\n                for (Integer[] direction: directions) {\\n                    State newState = new State(i + direction[0], j + direction[1], curr.isHorizontal);\\n                    addCell(newState, grid);\\n                }\\n                State rotated = curr.rotate();\\n                if (isValidPivot(rotated, grid))\\n                    addCell(rotated, grid);\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean isTarget(State curr, int[][] grid) {\\n        return curr.x == grid.length - 1 && curr.y == grid[0].length - 2 && curr.isHorizontal;\\n    }\\n\\n    private void addCell(State state, int[][] grid) {\\n        int k = state.isHorizontal ? 0 : 1;\\n        if (isValidCell(state.x, state.y, grid) && isValidCell(state.other_x, state.other_y, grid) &&\\n                !visited[state.x][state.y][k]) {\\n            queue.add(state);\\n        }\\n    }\\n\\n    private boolean isValidCell(int x, int y, int[][] grid) {\\n        return isValidCoordinates(x, y, grid) && grid[x][y] != 1;\\n    }\\n\\n    private boolean isValidCoordinates(int i, int j, int[][] grid) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n\\n    private boolean isValidPivot(State state, int[][] grid) {\\n        int x = state.x + 1, y = state.y + 1;\\n        return isValidCoordinates(x, y, grid) && grid[x][y] != 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass State {\\n    int x;\\n    int y;\\n    int other_x;\\n    int other_y;\\n    boolean isHorizontal;\\n\\n    public State(int x, int y, boolean isHorizontal) {\\n        this.x = x;\\n        this.y = y;\\n        this.isHorizontal = isHorizontal;\\n        int[] otherCell = getOtherCell();\\n        other_x = otherCell[0];\\n        other_y = otherCell[1];\\n    }\\n\\n    public int[] getOtherCell() {\\n        if (isHorizontal) return new int[] {x, y + 1};\\n        else return new int[] {x + 1, y};\\n    }\\n\\n    public State rotate() {\\n        return new State(x, y, !isHorizontal);\\n    }\\n}\\n\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{0, 1},\\n            new Integer[]{1, 0}\\n    );\\n    private final Queue<State> queue = new ArrayDeque<>();\\n    private boolean[][][] visited;\\n\\n    public int minimumMoves(int[][] grid) {\\n        queue.add(new State(0, 0, true));\\n        visited = new boolean[grid.length][grid[0].length][2];\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int count = 0; count < size; count++) {\\n                State curr = queue.remove();\\n                if (isTarget(curr, grid)) return steps;\\n                int i = curr.x, j = curr.y, k = curr.isHorizontal ? 0 : 1;\\n                if (visited[i][j][k]) continue;\\n                visited[i][j][k] = true;\\n                for (Integer[] direction: directions) {\\n                    State newState = new State(i + direction[0], j + direction[1], curr.isHorizontal);\\n                    addCell(newState, grid);\\n                }\\n                State rotated = curr.rotate();\\n                if (isValidPivot(rotated, grid))\\n                    addCell(rotated, grid);\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean isTarget(State curr, int[][] grid) {\\n        return curr.x == grid.length - 1 && curr.y == grid[0].length - 2 && curr.isHorizontal;\\n    }\\n\\n    private void addCell(State state, int[][] grid) {\\n        int k = state.isHorizontal ? 0 : 1;\\n        if (isValidCell(state.x, state.y, grid) && isValidCell(state.other_x, state.other_y, grid) &&\\n                !visited[state.x][state.y][k]) {\\n            queue.add(state);\\n        }\\n    }\\n\\n    private boolean isValidCell(int x, int y, int[][] grid) {\\n        return isValidCoordinates(x, y, grid) && grid[x][y] != 1;\\n    }\\n\\n    private boolean isValidCoordinates(int i, int j, int[][] grid) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n\\n    private boolean isValidPivot(State state, int[][] grid) {\\n        int x = state.x + 1, y = state.y + 1;\\n        return isValidCoordinates(x, y, grid) && grid[x][y] != 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012925,
                "title": "python-bfs",
                "content": "deque is defined as follows- \\n(snake head x corrdinate, snake head y corrdinate, direction, iteration number)\\nTime Complexity - O(n^2)\\n\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        seen=set()\\n        dq=deque()\\n        dq.append((0,1,\"r\",0))\\n        seen.add((0,1,\"r\"))\\n        while dq:\\n            i,j,pos,val=dq.popleft()\\n            if i==n-1 and j==n-1 and pos==\"r\": return val \\n            #move right\\n            if j+1<n and grid[i][j+1]==0 and (i,j+1,pos) not in seen:\\n                if pos==\"r\" or pos==\"d\" and grid[i-1][j+1]==0:\\n                    dq.append((i,j+1,pos,val+1))\\n                    seen.add((i,j+1,pos))\\n            #move down\\n            if i+1<n and grid[i+1][j]==0 and (i+1,j,pos) not in seen:\\n                if pos==\"d\" or pos==\"r\" and grid[i+1][j-1]==0:\\n                    dq.append((i+1,j,pos,val+1))\\n                    seen.add((i+1,j,pos))\\n            #change dir to down if curr is right\\n            if pos==\"r\" and j-1>=0 and i+1<n and grid[i+1][j]==grid[i+1][j-1]==0 and (i+1,j-1,\"d\") not in seen:\\n                dq.append((i+1,j-1,\"d\",val+1))\\n                seen.add((i+1,j-1,\"d\"))\\n            #change dir to right if curr is down\\n            if pos==\"d\" and i-1>=0 and j+1<n and grid[i-1][j+1]==grid[i][j+1]==0 and (i-1,j+1,\"r\") not in seen:\\n                dq.append((i-1,j+1,\"r\",val+1))\\n                seen.add((i-1,j+1,\"r\"))\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        seen=set()\\n        dq=deque()\\n        dq.append((0,1,\"r\",0))\\n        seen.add((0,1,\"r\"))\\n        while dq:\\n            i,j,pos,val=dq.popleft()\\n            if i==n-1 and j==n-1 and pos==\"r\": return val \\n            #move right\\n            if j+1<n and grid[i][j+1]==0 and (i,j+1,pos) not in seen:\\n                if pos==\"r\" or pos==\"d\" and grid[i-1][j+1]==0:\\n                    dq.append((i,j+1,pos,val+1))\\n                    seen.add((i,j+1,pos))\\n            #move down\\n            if i+1<n and grid[i+1][j]==0 and (i+1,j,pos) not in seen:\\n                if pos==\"d\" or pos==\"r\" and grid[i+1][j-1]==0:\\n                    dq.append((i+1,j,pos,val+1))\\n                    seen.add((i+1,j,pos))\\n            #change dir to down if curr is right\\n            if pos==\"r\" and j-1>=0 and i+1<n and grid[i+1][j]==grid[i+1][j-1]==0 and (i+1,j-1,\"d\") not in seen:\\n                dq.append((i+1,j-1,\"d\",val+1))\\n                seen.add((i+1,j-1,\"d\"))\\n            #change dir to right if curr is down\\n            if pos==\"d\" and i-1>=0 and j+1<n and grid[i-1][j+1]==grid[i][j+1]==0 and (i-1,j+1,\"r\") not in seen:\\n                dq.append((i-1,j+1,\"r\",val+1))\\n                seen.add((i-1,j+1,\"r\"))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517340,
                "title": "java-bfs-soln",
                "content": "The main intution of the question is to store the cordinates of tail of the snake and position and travel according to it.\\nAs we have to find the minimum setps BFS is the first thing that comes to mind.\\nSo here is its implementaion - \\n```\\nclass Solution {\\n    \\n    public class Pair{\\n        int x;\\n        int y;\\n        int pos;\\n        int st;\\n        \\n        Pair(int x, int y, int pos, int st){\\n            this.x = x;\\n            this.y = y;\\n            this.pos = pos;\\n            this.st = st;\\n        }\\n    }\\n    \\n    public void Add_Neighbours(int[][] grid, Queue<Pair> Q, Pair rem){\\n        \\n        int n = grid.length;\\n        int pos = rem.pos;\\n        int x = rem.x;\\n        int y = rem.y;\\n        \\n        if(pos == 0){\\n            if(y + 2 < n && grid[x][y + 2] == 0){\\n                Q.add(new Pair(x , y + 1, pos, rem.st + 1));\\n            }\\n            if(x + 1 < n && grid[x + 1][y]  == 0 && grid[x + 1][y + 1] == 0){\\n                Q.add(new Pair(x + 1, y, pos, rem.st + 1));\\n                Q.add(new Pair(x, y, 1, rem.st + 1));\\n            }\\n        }\\n        else{\\n            if(y + 1 < n && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0){\\n                Q.add(new Pair(x, y + 1, pos, rem.st + 1));\\n                Q.add(new Pair(x, y, 0, rem.st + 1));\\n            }\\n            \\n            if(x + 2 < n && grid[x + 2][y] == 0){\\n                Q.add(new Pair(x + 1, y, pos, rem.st + 1));\\n            }\\n        }\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;\\n        \\n        Queue<Pair> Q = new LinkedList();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        \\n        Q.add(new Pair(0, 0, 0, 0));\\n        \\n        while(Q.size() > 0){    \\n            Pair rem = Q.remove();\\n            \\n            if(visited[rem.x][rem.y][rem.pos] == true)   continue;\\n            \\n            visited[rem.x][rem.y][rem.pos] = true;\\n            \\n            if(rem.x == n - 1 && rem.y == n - 2 && rem.pos == 0)    return rem.st;\\n            \\n            Add_Neighbours(grid, Q, rem);\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public class Pair{\\n        int x;\\n        int y;\\n        int pos;\\n        int st;\\n        \\n        Pair(int x, int y, int pos, int st){\\n            this.x = x;\\n            this.y = y;\\n            this.pos = pos;\\n            this.st = st;\\n        }\\n    }\\n    \\n    public void Add_Neighbours(int[][] grid, Queue<Pair> Q, Pair rem){\\n        \\n        int n = grid.length;\\n        int pos = rem.pos;\\n        int x = rem.x;\\n        int y = rem.y;\\n        \\n        if(pos == 0){\\n            if(y + 2 < n && grid[x][y + 2] == 0){\\n                Q.add(new Pair(x , y + 1, pos, rem.st + 1));\\n            }\\n            if(x + 1 < n && grid[x + 1][y]  == 0 && grid[x + 1][y + 1] == 0){\\n                Q.add(new Pair(x + 1, y, pos, rem.st + 1));\\n                Q.add(new Pair(x, y, 1, rem.st + 1));\\n            }\\n        }\\n        else{\\n            if(y + 1 < n && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0){\\n                Q.add(new Pair(x, y + 1, pos, rem.st + 1));\\n                Q.add(new Pair(x, y, 0, rem.st + 1));\\n            }\\n            \\n            if(x + 2 < n && grid[x + 2][y] == 0){\\n                Q.add(new Pair(x + 1, y, pos, rem.st + 1));\\n            }\\n        }\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;\\n        \\n        Queue<Pair> Q = new LinkedList();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        \\n        Q.add(new Pair(0, 0, 0, 0));\\n        \\n        while(Q.size() > 0){    \\n            Pair rem = Q.remove();\\n            \\n            if(visited[rem.x][rem.y][rem.pos] == true)   continue;\\n            \\n            visited[rem.x][rem.y][rem.pos] = true;\\n            \\n            if(rem.x == n - 1 && rem.y == n - 2 && rem.pos == 0)    return rem.st;\\n            \\n            Add_Neighbours(grid, Q, rem);\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137776,
                "title": "c-simple-bfs-state-management-clean-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    queue<vector<int>> q;\\n    \\n    void down(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(r1 < n - 1 && !g[r1 + 1][c1] && r2 < n - 1 && !g[r2 + 1][c2])\\n            q.push({r1 + 1, c1, r2 + 1, c2});\\n    }\\n    void right(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(c1 < n - 1 && !g[r1][c1 + 1] && c2 < n - 1 && !g[r2][c2 + 1])\\n            q.push({r1, c1 + 1, r2, c2 + 1});\\n    }\\n    \\n    void clockwise(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(r1 != r2) return;\\n        if(r1 < n - 1 && !g[r1 + 1][c1] && !g[r1 + 1][c2])\\n            q.push({r1, c1, r1 + 1, c1});\\n    }\\n    void counterClockwise(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(c1 != c2) return;\\n        if(c1 < n - 1 && !g[r1][c1 + 1] && !g[r2][c1 + 1])\\n            q.push({r1, c1, r1, c1 + 1});\\n    }\\n    set<vector<int>> set;\\n    \\n    int minimumMoves(vector<vector<int>>& g) {\\n        n = g.size();\\n        q.push({0, 0, 0, 1});\\n        int level = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++){\\n                auto A = q.front();\\n                q.pop();\\n                if(set.find(A) != set.end()) continue;\\n                set.insert(A);\\n                int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n                if(r1 == n - 1 && c1 == n - 2 && r2 == n - 1 && c2 == n - 1)    return level;\\n                down(g, A); right(g, A);\\n                clockwise(g, A); counterClockwise(g, A);\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    queue<vector<int>> q;\\n    \\n    void down(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(r1 < n - 1 && !g[r1 + 1][c1] && r2 < n - 1 && !g[r2 + 1][c2])\\n            q.push({r1 + 1, c1, r2 + 1, c2});\\n    }\\n    void right(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(c1 < n - 1 && !g[r1][c1 + 1] && c2 < n - 1 && !g[r2][c2 + 1])\\n            q.push({r1, c1 + 1, r2, c2 + 1});\\n    }\\n    \\n    void clockwise(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(r1 != r2) return;\\n        if(r1 < n - 1 && !g[r1 + 1][c1] && !g[r1 + 1][c2])\\n            q.push({r1, c1, r1 + 1, c1});\\n    }\\n    void counterClockwise(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(c1 != c2) return;\\n        if(c1 < n - 1 && !g[r1][c1 + 1] && !g[r2][c1 + 1])\\n            q.push({r1, c1, r1, c1 + 1});\\n    }\\n    set<vector<int>> set;\\n    \\n    int minimumMoves(vector<vector<int>>& g) {\\n        n = g.size();\\n        q.push({0, 0, 0, 1});\\n        int level = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++){\\n                auto A = q.front();\\n                q.pop();\\n                if(set.find(A) != set.end()) continue;\\n                set.insert(A);\\n                int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n                if(r1 == n - 1 && c1 == n - 2 && r2 == n - 1 && c2 == n - 1)    return level;\\n                down(g, A); right(g, A);\\n                clockwise(g, A); counterClockwise(g, A);\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964865,
                "title": "c-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public:\\n    \\n    int n;\\n    set<vector<int>> visited;\\n    bool candown(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(!hor){\\n            if(x+2<n && grid[x+1][y]==0 && grid[x+2][y]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canright(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+2<n && grid[x][y+1]==0 && grid[x][y+2]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(y+1<n && x+1<n && grid[x][y+1]==0 && grid[x+1][y+1]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canrot(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+1<n && x+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x][y+1]==0 &&grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        queue<array<int, 3>> q;\\n        q.push({0,0,true});\\n        int ans=0;\\n        n=grid.size();\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto a=q.front();\\n                q.pop();\\n                if(visited.count({a[0],a[1],a[2]})){\\n                    continue;\\n                }\\n                visited.insert({a[0],a[1],a[2]});\\n                int x=a[0];\\n                int y=a[1];\\n                if(x==n-1 && y==n-2 && a[2]==1){\\n                    return ans;\\n                }\\n                if(candown(grid,x,y,a[2])){\\n                    q.push({x+1,y,a[2]});\\n                }\\n                if(canrot(grid,x,y,a[2])){\\n                    q.push({x,y,!a[2]});\\n                }\\n                if(canright(grid,x,y,a[2])){\\n                    q.push({x,y+1,a[2]});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\n    public:\\n    \\n    int n;\\n    set<vector<int>> visited;\\n    bool candown(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(!hor){\\n            if(x+2<n && grid[x+1][y]==0 && grid[x+2][y]==0 && !visited.count({x+1,y,hor}",
                "codeTag": "Java"
            },
            {
                "id": 1863160,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& nums) {\\n        map<tuple<int,int,int>,int> mp;  // tuple stores 3 parameter\\n                                         // {row of head of snake, col of head of snake, alignment of snake}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // alignment = 0 mean horizontal, alignment = 1 means vertical\\n        queue<vector<int>> q;  //stores {row of head of snake, col of head of snake, alignment of snake}\\n        q.push({0,1,0}); mp[{0,1,0}]++;\\n        int l = 0,n=nums.size();\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                vector<int> t = q.front(); q.pop();\\n                int i = t[0], j =t[1];\\n                if(i==n-1 && j==n-1 && t[2]==0) return l; // check the destination, and return currenet level if found\\n                if(t[2]==0){  // if direction is horizontal\\n                    if(j+1<n && nums[i][j+1]==0 && mp.find({i,j+1,0})==mp.end()){ // check if it can move to right \\n                        mp[{i,j+1,0}]++; q.push({i,j+1,0});\\n                    }\\n                    if(i+1<n && nums[i+1][j]==0 && nums[i+1][j-1]==0){\\n                        if(mp.find({i+1,j,0})==mp.end()){  // check if it can move to down \\n                           mp[{i+1,j,0}]++; q.push({i+1,j,0}); \\n                        }\\n                        if(mp.find({i+1,j-1,1})==mp.end()){   // check if it can rotate clockwise \\n                            mp[{i+1,j-1,1}]++; q.push({i+1,j-1,1}); \\n                        }\\n                    }\\n                }\\n                else{    // if direction is vertical \\n                    if(i+1<n && nums[i+1][j]==0 && mp.find({i+1,j,1})==mp.end()) {  // check if it can move to down \\n                        mp[{i+1,j,1}]++; q.push({i+1,j,1});\\n                    }\\n                    if(j+1<n && nums[i][j+1]==0 && nums[i-1][j+1]==0){\\n                        if(mp.find({i,j+1,1})==mp.end()){   // check if it can move to right \\n                            mp[{i,j+1,1}]++; q.push({i,j+1,1});\\n                        }\\n                        if(mp.find({i-1,j+1,0})==mp.end()){   // check if it can rotate anticlockwise\\n                            mp[{i-1,j+1,0}]++; q.push({i-1,j+1,0});\\n                        }\\n                    } \\n                }\\n            }\\n            l++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Upvote if it helps**",
                "solutionTags": [
                    "C",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& nums) {\\n        map<tuple<int,int,int>,int> mp;  // tuple stores 3 parameter\\n                                         // {row of head of snake, col of head of snake, alignment of snake}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // alignment = 0 mean horizontal, alignment = 1 means vertical\\n        queue<vector<int>> q;  //stores {row of head of snake, col of head of snake, alignment of snake}\\n        q.push({0,1,0}); mp[{0,1,0}]++;\\n        int l = 0,n=nums.size();\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                vector<int> t = q.front(); q.pop();\\n                int i = t[0], j =t[1];\\n                if(i==n-1 && j==n-1 && t[2]==0) return l; // check the destination, and return currenet level if found\\n                if(t[2]==0){  // if direction is horizontal\\n                    if(j+1<n && nums[i][j+1]==0 && mp.find({i,j+1,0})==mp.end()){ // check if it can move to right \\n                        mp[{i,j+1,0}]++; q.push({i,j+1,0});\\n                    }\\n                    if(i+1<n && nums[i+1][j]==0 && nums[i+1][j-1]==0){\\n                        if(mp.find({i+1,j,0})==mp.end()){  // check if it can move to down \\n                           mp[{i+1,j,0}]++; q.push({i+1,j,0}); \\n                        }\\n                        if(mp.find({i+1,j-1,1})==mp.end()){   // check if it can rotate clockwise \\n                            mp[{i+1,j-1,1}]++; q.push({i+1,j-1,1}); \\n                        }\\n                    }\\n                }\\n                else{    // if direction is vertical \\n                    if(i+1<n && nums[i+1][j]==0 && mp.find({i+1,j,1})==mp.end()) {  // check if it can move to down \\n                        mp[{i+1,j,1}]++; q.push({i+1,j,1});\\n                    }\\n                    if(j+1<n && nums[i][j+1]==0 && nums[i-1][j+1]==0){\\n                        if(mp.find({i,j+1,1})==mp.end()){   // check if it can move to right \\n                            mp[{i,j+1,1}]++; q.push({i,j+1,1});\\n                        }\\n                        if(mp.find({i-1,j+1,0})==mp.end()){   // check if it can rotate anticlockwise\\n                            mp[{i-1,j+1,0}]++; q.push({i-1,j+1,0});\\n                        }\\n                    } \\n                }\\n            }\\n            l++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227484,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool valid(int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=n || j>=n)\\n            return false;\\n        return true;\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        int state=0;  //Horizontal-0    Vertical-1\\n        n=grid.size();\\n        queue<vector<int>>q;\\n        vector<vector<bool>>vish(n,vector<bool>(n,false)),visv(n,vector<bool>(n,false));\\n        \\n        q.push({0,1,state});\\n        vish[0][1]=true;\\n        int res=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int i=q.front()[0],j=q.front()[1],state=q.front()[2];\\n                q.pop();\\n                if(i==n-1 && j==n-1 && state==0)\\n                    return res;\\n                if(state==0)\\n                {\\n                    int x=i,y=j+1;\\n                    if(valid(x,y) && grid[x][y]==0 && !vish[x][y])  //Right\\n                    {\\n                        q.push({x,y,0});\\n                        vish[x][y]=true;\\n                    }\\n                    \\n                    int x1=i+1,y1=j-1,x2=i+1,y2=j;\\n                    if(valid(x1,y1) && valid(x2,y2) && grid[x1][y1]==0 && grid[x2][y2]==0 && !vish[x2][y2])  //Down\\n                    {\\n                        q.push({x2,y2,0});\\n                        vish[x2][y2]=true;\\n                    }\\n                    \\n                    x=i+1,y=j-1;\\n                    if(valid(x,y) && valid(x,y+1) && grid[x][y]==0 && grid[x][y+1]==0 && !visv[x][y])  // Rotate clockwise\\n                    {\\n                        q.push({x,y,1});\\n                        visv[x][y]=true;\\n                    }\\n                }\\n                else\\n                {\\n                    int x1=i-1,y1=j+1,x2=i,y2=j+1;\\n                    if(valid(x1,y1) && valid(x2,y2) && grid[x1][y1]==0 && grid[x2][y2]==0 && !visv[x2][y2])  //Right\\n                    {\\n                        q.push({x2,y2,1});\\n                        visv[x2][y2]=true;\\n                    }\\n                    \\n                    int x=i+1,y=j;\\n                    if(valid(x,y) && grid[x][y]==0 && !visv[x][y])  //Down\\n                    {\\n                        visv[x][y]=true;\\n                        q.push({x,y,1});\\n                    }\\n                    \\n                    x=i-1,y=j+1;\\n                    if(valid(x,y) && valid(x+1,y) && grid[x][y]==0 && grid[x+1][y]==0 && !vish[x][y])  // Rotate anticlockwise\\n                    {\\n                        q.push({x,y,0});\\n                        vish[x][y]=true;\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool valid(int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=n || j>=n)\\n            return false;\\n        return true;\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        int state=0;  //Horizontal-0    Vertical-1\\n        n=grid.size();\\n        queue<vector<int>>q;\\n        vector<vector<bool>>vish(n,vector<bool>(n,false)),visv(n,vector<bool>(n,false));\\n        \\n        q.push({0,1,state});\\n        vish[0][1]=true;\\n        int res=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int i=q.front()[0],j=q.front()[1],state=q.front()[2];\\n                q.pop();\\n                if(i==n-1 && j==n-1 && state==0)\\n                    return res;\\n                if(state==0)\\n                {\\n                    int x=i,y=j+1;\\n                    if(valid(x,y) && grid[x][y]==0 && !vish[x][y])  //Right\\n                    {\\n                        q.push({x,y,0});\\n                        vish[x][y]=true;\\n                    }\\n                    \\n                    int x1=i+1,y1=j-1,x2=i+1,y2=j;\\n                    if(valid(x1,y1) && valid(x2,y2) && grid[x1][y1]==0 && grid[x2][y2]==0 && !vish[x2][y2])  //Down\\n                    {\\n                        q.push({x2,y2,0});\\n                        vish[x2][y2]=true;\\n                    }\\n                    \\n                    x=i+1,y=j-1;\\n                    if(valid(x,y) && valid(x,y+1) && grid[x][y]==0 && grid[x][y+1]==0 && !visv[x][y])  // Rotate clockwise\\n                    {\\n                        q.push({x,y,1});\\n                        visv[x][y]=true;\\n                    }\\n                }\\n                else\\n                {\\n                    int x1=i-1,y1=j+1,x2=i,y2=j+1;\\n                    if(valid(x1,y1) && valid(x2,y2) && grid[x1][y1]==0 && grid[x2][y2]==0 && !visv[x2][y2])  //Right\\n                    {\\n                        q.push({x2,y2,1});\\n                        visv[x2][y2]=true;\\n                    }\\n                    \\n                    int x=i+1,y=j;\\n                    if(valid(x,y) && grid[x][y]==0 && !visv[x][y])  //Down\\n                    {\\n                        visv[x][y]=true;\\n                        q.push({x,y,1});\\n                    }\\n                    \\n                    x=i-1,y=j+1;\\n                    if(valid(x,y) && valid(x+1,y) && grid[x][y]==0 && grid[x+1][y]==0 && !vish[x][y])  // Rotate anticlockwise\\n                    {\\n                        q.push({x,y,0});\\n                        vish[x][y]=true;\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901062,
                "title": "kotlin-bfs-fun-game-isn-t-it",
                "content": "The idea was \"stolen\" from [this post](https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/393511/JavaPython-3-25-and-17-liner-clean-BFS-codes-w-brief-explanation-and-analysis.) by @rock. I just made limited modifications with some comments and constants.\\n\\nTo whom this might concern:\\nI spent about one hour figuring out why my solution was wrong, only to find that the rotation operation requires <b>2 empty cells</b> in the corresponding positions, instead of 1.\\n\\nSolution - [github](https://github.com/An7One/leetcode-solutions-kotlin-an7one/tree/main/src/main/kotlin/com/an7one/leetcode/lvl4/lc1210)\\n\\n<b>Problem List</b>\\n#BFS - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/search/breath_first_search)\\n\\n```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/\\n *\\n * Time Complexity:     O(`n` ^ 2)\\n * Space Complexity:    O(`n` ^ 2)\\n *\\n * Reference:\\n * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/393511/JavaPython-3-25-and-17-liner-clean-BFS-codes-w-brief-explanation-and-analysis.\\n */\\nclass Solution {\\n    private companion object {\\n        private const val EMPTY = 0\\n\\n        // not used\\n        // private const val BLOCKED = 1\\n    }\\n\\n    fun minimumMoves(grid: Array<IntArray>): Int {\\n        val n = grid.size\\n\\n        val start = State(0, 0, Facing.RIGHT)\\n        val target = State(n - 1, n - 2, Facing.RIGHT)\\n\\n        // to keep track of the tail of the snake,\\n        // so it is required to check 2 steps in the front, to move towards the facing direction\\n        val queue = ArrayDeque<State>().also{\\n            it.addLast(start)\\n        }\\n\\n        val seen = HashSet<String>()\\n\\n        var steps = 0\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n\\n            for (sz in 0 until size) {\\n                val cur = queue.removeFirst()\\n                if (cur == target) return steps\\n\\n                val row = cur.row\\n                val col = cur.col\\n                val dir = cur.dir\\n\\n                if (!seen.add(cur.toHash())) continue\\n\\n                if (dir == Facing.RIGHT) { // facing right\\n                    if (row + 1 < n && grid[row + 1][col] == EMPTY && grid[row + 1][col + 1] == EMPTY) { // to check if both cells down are available (while facing right)\\n                        queue.offer(State(row, col, Facing.DOWN)) // to rotate clockwise (while facing right)\\n                        queue.offer(State(row + 1, col, Facing.RIGHT)) // to move down (while facing right)\\n                    }\\n\\n                    if (col + 2 < n && grid[row][col + 2] == EMPTY) { // to check if the cell in front of the snake head is available (while facing right)\\n                        queue.offer(State(row, col + 1, Facing.RIGHT)) // to move right (while facing right)\\n                    }\\n\\n                }\\n\\n                if (dir == Facing.DOWN) { // facing down\\n                    if (col + 1 < n && grid[row][col + 1] == EMPTY && grid[row + 1][col + 1] == EMPTY) { // to check if both cells right are available (while facing down)\\n                        queue.offer(State(row, col, Facing.RIGHT)) // to rotate anti-clockwise (while facing down)\\n                        queue.offer(State(row, col + 1, Facing.DOWN)) // to move right (while facing down)\\n                    }\\n\\n                    if (row + 2 < n && grid[row + 2][col] == EMPTY) { // to check if the cell in front of the snake head is available (while facing down)\\n                        queue.offer(State(row + 1, col, Facing.DOWN)) // to move down (while facing down)\\n                    }\\n                }\\n            }\\n\\n            ++steps\\n        }\\n\\n        return -1\\n    }\\n\\n    private data class State(val row: Int, val col: Int, val dir: Facing) {\\n\\n        fun toHash(): String = \"$row#$col#$dir\"\\n\\n        override fun equals(other: Any?) = (other is State) && row == other.row && col == other.col && dir == other.dir\\n\\n        override fun hashCode(): Int {\\n            return super.hashCode()\\n        }\\n    }\\n\\n    private enum class Facing {\\n        DOWN, RIGHT\\n    }\\n}\\n```\\n\\nWhat a @rock!\\nWhat a fun game!\\nWhat a practice for BFS!\\n\\nI love algorithm!\\nI love Kotlin!",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/\\n *\\n * Time Complexity:     O(`n` ^ 2)\\n * Space Complexity:    O(`n` ^ 2)\\n *\\n * Reference:\\n * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/393511/JavaPython-3-25-and-17-liner-clean-BFS-codes-w-brief-explanation-and-analysis.\\n */\\nclass Solution {\\n    private companion object {\\n        private const val EMPTY = 0\\n\\n        // not used\\n        // private const val BLOCKED = 1\\n    }\\n\\n    fun minimumMoves(grid: Array<IntArray>): Int {\\n        val n = grid.size\\n\\n        val start = State(0, 0, Facing.RIGHT)\\n        val target = State(n - 1, n - 2, Facing.RIGHT)\\n\\n        // to keep track of the tail of the snake,\\n        // so it is required to check 2 steps in the front, to move towards the facing direction\\n        val queue = ArrayDeque<State>().also{\\n            it.addLast(start)\\n        }\\n\\n        val seen = HashSet<String>()\\n\\n        var steps = 0\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n\\n            for (sz in 0 until size) {\\n                val cur = queue.removeFirst()\\n                if (cur == target) return steps\\n\\n                val row = cur.row\\n                val col = cur.col\\n                val dir = cur.dir\\n\\n                if (!seen.add(cur.toHash())) continue\\n\\n                if (dir == Facing.RIGHT) { // facing right\\n                    if (row + 1 < n && grid[row + 1][col] == EMPTY && grid[row + 1][col + 1] == EMPTY) { // to check if both cells down are available (while facing right)\\n                        queue.offer(State(row, col, Facing.DOWN)) // to rotate clockwise (while facing right)\\n                        queue.offer(State(row + 1, col, Facing.RIGHT)) // to move down (while facing right)\\n                    }\\n\\n                    if (col + 2 < n && grid[row][col + 2] == EMPTY) { // to check if the cell in front of the snake head is available (while facing right)\\n                        queue.offer(State(row, col + 1, Facing.RIGHT)) // to move right (while facing right)\\n                    }\\n\\n                }\\n\\n                if (dir == Facing.DOWN) { // facing down\\n                    if (col + 1 < n && grid[row][col + 1] == EMPTY && grid[row + 1][col + 1] == EMPTY) { // to check if both cells right are available (while facing down)\\n                        queue.offer(State(row, col, Facing.RIGHT)) // to rotate anti-clockwise (while facing down)\\n                        queue.offer(State(row, col + 1, Facing.DOWN)) // to move right (while facing down)\\n                    }\\n\\n                    if (row + 2 < n && grid[row + 2][col] == EMPTY) { // to check if the cell in front of the snake head is available (while facing down)\\n                        queue.offer(State(row + 1, col, Facing.DOWN)) // to move down (while facing down)\\n                    }\\n                }\\n            }\\n\\n            ++steps\\n        }\\n\\n        return -1\\n    }\\n\\n    private data class State(val row: Int, val col: Int, val dir: Facing) {\\n\\n        fun toHash(): String = \"$row#$col#$dir\"\\n\\n        override fun equals(other: Any?) = (other is State) && row == other.row && col == other.col && dir == other.dir\\n\\n        override fun hashCode(): Int {\\n            return super.hashCode()\\n        }\\n    }\\n\\n    private enum class Facing {\\n        DOWN, RIGHT\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875906,
                "title": "rust-translated-8ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn minimum_moves(mut grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n\\n        fn can_rotate(g: &[Vec<i32>], r: i32, c: i32) -> bool {\\n            r < g.len() as i32 - 1\\n                && c < g[0].len() as i32 - 1\\n                && (g[r as usize + 1][c as usize] & 1) == 0\\n                && (g[r as usize][c as usize + 1] & 1) == 0\\n                && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n        }\\n\\n        fn can_go_down(g: &[Vec<i32>], r: i32, c: i32, vertical: bool) -> bool {\\n            if vertical {\\n                r < g.len() as i32 - 2 && (g[r as usize + 2][c as usize] & 1) == 0\\n            } else {\\n                r < g.len() as i32 - 1\\n                    && (g[r as usize + 1][c as usize] & 1) == 0\\n                    && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n            }\\n        }\\n\\n        fn can_go_right(g: &[Vec<i32>], r: i32, c: i32, vertical: bool) -> bool {\\n            if !vertical {\\n                c < g[0].len() as i32 - 2 && (g[r as usize][c as usize + 2] & 1) == 0\\n            } else {\\n                c < g[0].len() as i32 - 1\\n                    && (g[r as usize][c as usize + 1] & 1) == 0\\n                    && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n            }\\n        }\\n\\n        let mut steps = 0;\\n        let mut q = VecDeque::<(i32, i32, bool)>::new();\\n        q.push_back((0, 0, false));\\n        while !q.is_empty() {\\n            let size = q.len();\\n            for _ in 0..size {\\n                let (r, c, vertical) = q.pop_front().unwrap();\\n                if r == grid.len() as i32 - 1 && c == grid[0].len() as i32 - 2 {\\n                    return steps;\\n                }\\n                if grid[r as usize][c as usize] & (if vertical { 2 } else { 4 }) == 0 {\\n                    grid[r as usize][c as usize] |= if vertical { 2 } else { 4 };\\n                    if can_go_down(&grid, r, c, vertical) {\\n                        q.push_back((r + 1, c, vertical));\\n                    }\\n                    if can_go_right(&grid, r, c, vertical) {\\n                        q.push_back((r, c + 1, vertical));\\n                    }\\n                    if can_rotate(&grid, r, c) {\\n                        q.push_back((r, c, !vertical));\\n                    }\\n                }\\n            }\\n            steps += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_minimum_moves() {\\n        assert_eq!(\\n            Solution::minimum_moves(vec![\\n                vec![0, 0, 0, 0, 0, 1],\\n                vec![1, 1, 0, 0, 1, 0],\\n                vec![0, 0, 0, 0, 1, 1],\\n                vec![0, 0, 1, 0, 1, 0],\\n                vec![0, 1, 1, 0, 0, 0],\\n                vec![0, 1, 1, 0, 0, 0]\\n            ]),\\n            11\\n        );\\n    }\\n\\n    #[test]\\n    fn test_minimum_moves_02() {\\n        assert_eq!(\\n            Solution::minimum_moves(vec![\\n                vec![0, 0, 1, 1, 1, 1],\\n                vec![0, 0, 0, 0, 1, 1],\\n                vec![1, 1, 0, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 0]\\n            ]),\\n            9\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn minimum_moves(mut grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n\\n        fn can_rotate(g: &[Vec<i32>], r: i32, c: i32) -> bool {\\n            r < g.len() as i32 - 1\\n                && c < g[0].len() as i32 - 1\\n                && (g[r as usize + 1][c as usize] & 1) == 0\\n                && (g[r as usize][c as usize + 1] & 1) == 0\\n                && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n        }\\n\\n        fn can_go_down(g: &[Vec<i32>], r: i32, c: i32, vertical: bool) -> bool {\\n            if vertical {\\n                r < g.len() as i32 - 2 && (g[r as usize + 2][c as usize] & 1) == 0\\n            } else {\\n                r < g.len() as i32 - 1\\n                    && (g[r as usize + 1][c as usize] & 1) == 0\\n                    && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n            }\\n        }\\n\\n        fn can_go_right(g: &[Vec<i32>], r: i32, c: i32, vertical: bool) -> bool {\\n            if !vertical {\\n                c < g[0].len() as i32 - 2 && (g[r as usize][c as usize + 2] & 1) == 0\\n            } else {\\n                c < g[0].len() as i32 - 1\\n                    && (g[r as usize][c as usize + 1] & 1) == 0\\n                    && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n            }\\n        }\\n\\n        let mut steps = 0;\\n        let mut q = VecDeque::<(i32, i32, bool)>::new();\\n        q.push_back((0, 0, false));\\n        while !q.is_empty() {\\n            let size = q.len();\\n            for _ in 0..size {\\n                let (r, c, vertical) = q.pop_front().unwrap();\\n                if r == grid.len() as i32 - 1 && c == grid[0].len() as i32 - 2 {\\n                    return steps;\\n                }\\n                if grid[r as usize][c as usize] & (if vertical { 2 } else { 4 }) == 0 {\\n                    grid[r as usize][c as usize] |= if vertical { 2 } else { 4 };\\n                    if can_go_down(&grid, r, c, vertical) {\\n                        q.push_back((r + 1, c, vertical));\\n                    }\\n                    if can_go_right(&grid, r, c, vertical) {\\n                        q.push_back((r, c + 1, vertical));\\n                    }\\n                    if can_rotate(&grid, r, c) {\\n                        q.push_back((r, c, !vertical));\\n                    }\\n                }\\n            }\\n            steps += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_minimum_moves() {\\n        assert_eq!(\\n            Solution::minimum_moves(vec![\\n                vec![0, 0, 0, 0, 0, 1],\\n                vec![1, 1, 0, 0, 1, 0],\\n                vec![0, 0, 0, 0, 1, 1],\\n                vec![0, 0, 1, 0, 1, 0],\\n                vec![0, 1, 1, 0, 0, 0],\\n                vec![0, 1, 1, 0, 0, 0]\\n            ]),\\n            11\\n        );\\n    }\\n\\n    #[test]\\n    fn test_minimum_moves_02() {\\n        assert_eq!(\\n            Solution::minimum_moves(vec![\\n                vec![0, 0, 1, 1, 1, 1],\\n                vec![0, 0, 0, 0, 1, 1],\\n                vec![1, 1, 0, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 0]\\n            ]),\\n            9\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788678,
                "title": "c-dp-with-speed-99-memory-91",
                "content": "Top-down dynamic programming. `dp[i][j]` is a `pair<int, int>` where `dp[i][j].first` is the minimum moves from starting point to (i, j) with head in (i, j) and tail in (i, j-1) (horizontal), and `dp[i][j].second` is the minimum moves from starting point to (i, j) with head in (i, j) and tail in (i-1, j) (vertical). If it\\'s impossible for the snake to be in that position, set the value to be `-1`. For either horizontal or vertical position, there\\'re 3 ways for the snake to move from last position to new positon: move down, move right, rotate. Calculate the minimum move for each way and store the smallest one in `dp[i][j]`.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<pair<int, int>>> dp(n, vector<pair<int,int>>(n));\\n        int ho, ho1, ho2, ho3, ve, ve1, ve2, ve3;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j <= 1) dp[i][j] = {0, -1};\\n                else if (grid[i][j] == 1) dp[i][j] = {-1, -1};\\n                else if (i == 0) {\\n                    if (dp[i][j-1].first==-1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {dp[i][j-1].first+1, -1};\\n                }\\n                else if (i == 1 && j == 0) {\\n                    if (grid[1][1] == 1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {-1,1};\\n                }\\n                else if (j == 0) {\\n                    if (dp[i-1][j].second==-1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {-1, dp[i-1][j].second+1};\\n                }\\n                else {\\n                    ho1 = dp[i][j-1].first==-1?-1:dp[i][j-1].first+1;\\n                    ho2 = (dp[i-1][j].first==-1||grid[i][j-1]==1)?-1:dp[i-1][j].first+1;\\n                    if (i==n-1 || grid[i+1][j]==1 || grid[i+1][j-1]==1 || dp[i][j-1].second == -1) ho3 = -1;\\n                    else ho3 = dp[i][j-1].second + 2;\\n                    if (ho1 == -1 && ho2 == -1) ho = ho3;\\n                    else if (ho1 == -1) ho = ho2;\\n                    else if (ho2 == -1) ho = ho1;\\n                    else ho = min(ho1, ho2);\\n                    if (grid[i-1][j] == 1) ve = -1;\\n                    else {\\n                        ve1 = dp[i-1][j].second==-1?-1:dp[i-1][j].second+1;\\n                        if (j == n-1 || grid[i][j+1]==1||dp[i-1][j+1].first==-1) ve2 = -1;\\n                        else ve2 = dp[i-1][j+1].first+1;\\n                        ve3 = dp[i][j-1].second== -1?-1:dp[i][j-1].second+1;\\n                        if (ve1 == -1 && ve3 == -1) ve = ve2;\\n                        else if (ve1 == -1) ve = ve3;\\n                        else if (ve3 == -1) ve = ve1;\\n                        else ve = min(ve1, ve3);\\n                    }\\n                    dp[i][j] = {ho, ve};\\n                }\\n            }\\n        }\\n        return dp[n-1][n-1].first;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5c882116-21d5-4323-861e-0f0ad9f2907c_1597283162.628977.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<pair<int, int>>> dp(n, vector<pair<int,int>>(n));\\n        int ho, ho1, ho2, ho3, ve, ve1, ve2, ve3;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j <= 1) dp[i][j] = {0, -1};\\n                else if (grid[i][j] == 1) dp[i][j] = {-1, -1};\\n                else if (i == 0) {\\n                    if (dp[i][j-1].first==-1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {dp[i][j-1].first+1, -1};\\n                }\\n                else if (i == 1 && j == 0) {\\n                    if (grid[1][1] == 1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {-1,1};\\n                }\\n                else if (j == 0) {\\n                    if (dp[i-1][j].second==-1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {-1, dp[i-1][j].second+1};\\n                }\\n                else {\\n                    ho1 = dp[i][j-1].first==-1?-1:dp[i][j-1].first+1;\\n                    ho2 = (dp[i-1][j].first==-1||grid[i][j-1]==1)?-1:dp[i-1][j].first+1;\\n                    if (i==n-1 || grid[i+1][j]==1 || grid[i+1][j-1]==1 || dp[i][j-1].second == -1) ho3 = -1;\\n                    else ho3 = dp[i][j-1].second + 2;\\n                    if (ho1 == -1 && ho2 == -1) ho = ho3;\\n                    else if (ho1 == -1) ho = ho2;\\n                    else if (ho2 == -1) ho = ho1;\\n                    else ho = min(ho1, ho2);\\n                    if (grid[i-1][j] == 1) ve = -1;\\n                    else {\\n                        ve1 = dp[i-1][j].second==-1?-1:dp[i-1][j].second+1;\\n                        if (j == n-1 || grid[i][j+1]==1||dp[i-1][j+1].first==-1) ve2 = -1;\\n                        else ve2 = dp[i-1][j+1].first+1;\\n                        ve3 = dp[i][j-1].second== -1?-1:dp[i][j-1].second+1;\\n                        if (ve1 == -1 && ve3 == -1) ve = ve2;\\n                        else if (ve1 == -1) ve = ve3;\\n                        else if (ve3 == -1) ve = ve1;\\n                        else ve = min(ve1, ve3);\\n                    }\\n                    dp[i][j] = {ho, ve};\\n                }\\n            }\\n        }\\n        return dp[n-1][n-1].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736930,
                "title": "python-bfs-annotated",
                "content": "**Legend:**\\nr, c : current row/column\\nR, C : number of rows/columns in grid\\nd : the distance the snake has traveled\\nq : queue that stores (distance traveled to current position (d), current row (r), curren column (c), orientation (o))\\no : orientation (0 is horizontal and 1 is vertical) - please forgive the use of o as a variable name\\n\\n**Notes:**\\nNothing too out of the oridnary here as far as BFS goes.  The exception being that visited contains two dictionaries.  \\n\\nBoth dictionaries keep track of how far the snake traveled (d) to get to the location (r,c).  However, the first one only records when the snake is in the horizontal position, and the second one only records when the snake is in the vertical position.  \\n\\nBecause the snake must reach the finish in the horizontal position, we check visited[0][target] to see if the snake made it to the finish, and how many \"steps\" it took.\\n\\n```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        self.grid = grid\\n        self.R, self.C = len(grid), len(grid[0])\\n        target = (self.R-1, self.C-1)\\n        \\n        q = [(0,0,1,0)]           #(distance traveled, row, column, orientation)\\n        visited = [{(0,1): 0},{}] #visited in horizontal state, visited in vertical state\\n        \\n        while q:\\n            \\n            d, r, c, o = heapq.heappop(q)\\n            \\n            #Check if snake can shift down, shift right, or rotate\\n            shift_d, shift_r, rot = self.shift_down(r,c,o), self.shift_right(r,c,o), self.rotate(r,c,o)\\n            \\n            #increment distance traveled by 1\\n            d += 1\\n            \\n            #Update the queue and visited after the snake has shifted down, right, or rotated\\n            if shift_d:\\n                i,j = shift_d\\n                if d < visited[o].get((i,j),float(\\'inf\\')):\\n                    visited[o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,o))\\n                    \\n            if shift_r:\\n                i,j = shift_r\\n                if d < visited[o].get((i,j),float(\\'inf\\')):\\n                    visited[o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,o))\\n                    \\n            if rot:\\n                i,j = rot\\n                if d < visited[1-o].get((i,j),float(\\'inf\\')):\\n                    visited[1-o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,1-o))\\n            \\n        return visited[0].get(target,-1)\\n    \\n    \\n    def shift_right(self, r, c, orient):\\n        \\'\\'\\'returns False if snake cannot move to the right, otherwise returns new head position\\'\\'\\'\\n        if (orient == 0) and ((c == self.C-1) or self.grid[r][c+1]): return False\\n        if (orient == 1) and ((c == self.C-1) or self.grid[r][c+1] or self.grid[r-1][c+1]): return False\\n        return (r, c+1)\\n\\n    def shift_down(self, r, c, orient):\\n        \\'\\'\\'returns False if snake cannot move downwards, otherwise returns new head position\\'\\'\\'\\n        if (orient == 1) and ((r == self.R-1) or self.grid[r+1][c]): return False\\n        if (orient == 0) and ((r == self.R-1) or self.grid[r+1][c] or self.grid[r+1][c-1]): return False\\n        return (r+1, c)\\n    \\n    def rotate(self, r, c, orient):\\n        \\'\\'\\'returns False if the snake is blocked from rotating, otherwise returns new head position (r,c)\\'\\'\\'\\n        #horizontal to vertical CW rotation\\n        if (orient == 0) and ((r == self.R-1) or self.grid[r+1][c] or self.grid[r+1][c-1]): return False\\n        if (orient == 0): return (r+1,c-1)\\n        \\n        #vertical to horizontal CCW rotation\\n        if (c == self.C-1) or self.grid[r][c+1] or self.grid[r-1][c+1]: return False\\n        return (r-1,c+1) \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        self.grid = grid\\n        self.R, self.C = len(grid), len(grid[0])\\n        target = (self.R-1, self.C-1)\\n        \\n        q = [(0,0,1,0)]           #(distance traveled, row, column, orientation)\\n        visited = [{(0,1): 0},{}] #visited in horizontal state, visited in vertical state\\n        \\n        while q:\\n            \\n            d, r, c, o = heapq.heappop(q)\\n            \\n            #Check if snake can shift down, shift right, or rotate\\n            shift_d, shift_r, rot = self.shift_down(r,c,o), self.shift_right(r,c,o), self.rotate(r,c,o)\\n            \\n            #increment distance traveled by 1\\n            d += 1\\n            \\n            #Update the queue and visited after the snake has shifted down, right, or rotated\\n            if shift_d:\\n                i,j = shift_d\\n                if d < visited[o].get((i,j),float(\\'inf\\')):\\n                    visited[o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,o))\\n                    \\n            if shift_r:\\n                i,j = shift_r\\n                if d < visited[o].get((i,j),float(\\'inf\\')):\\n                    visited[o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,o))\\n                    \\n            if rot:\\n                i,j = rot\\n                if d < visited[1-o].get((i,j),float(\\'inf\\')):\\n                    visited[1-o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,1-o))\\n            \\n        return visited[0].get(target,-1)\\n    \\n    \\n    def shift_right(self, r, c, orient):\\n        \\'\\'\\'returns False if snake cannot move to the right, otherwise returns new head position\\'\\'\\'\\n        if (orient == 0) and ((c == self.C-1) or self.grid[r][c+1]): return False\\n        if (orient == 1) and ((c == self.C-1) or self.grid[r][c+1] or self.grid[r-1][c+1]): return False\\n        return (r, c+1)\\n\\n    def shift_down(self, r, c, orient):\\n        \\'\\'\\'returns False if snake cannot move downwards, otherwise returns new head position\\'\\'\\'\\n        if (orient == 1) and ((r == self.R-1) or self.grid[r+1][c]): return False\\n        if (orient == 0) and ((r == self.R-1) or self.grid[r+1][c] or self.grid[r+1][c-1]): return False\\n        return (r+1, c)\\n    \\n    def rotate(self, r, c, orient):\\n        \\'\\'\\'returns False if the snake is blocked from rotating, otherwise returns new head position (r,c)\\'\\'\\'\\n        #horizontal to vertical CW rotation\\n        if (orient == 0) and ((r == self.R-1) or self.grid[r+1][c] or self.grid[r+1][c-1]): return False\\n        if (orient == 0): return (r+1,c-1)\\n        \\n        #vertical to horizontal CCW rotation\\n        if (c == self.C-1) or self.grid[r][c+1] or self.grid[r-1][c+1]: return False\\n        return (r-1,c+1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 469631,
                "title": "c-beat-100",
                "content": "```\\npublic class Solution {\\n    public int MinimumMoves(int[][] grid) {\\n        \\n        Queue<int> q = new Queue<int>();\\n        Queue<bool> pos = new Queue<bool>();\\n        \\n        HashSet<int> v = new HashSet<int>();\\n        HashSet<int> h = new HashSet<int>();\\n        \\n        int n = grid.Length;\\n        int start = n * 0 + 1;\\n        \\n        // horizontal = true / vertical = false\\n        q.Enqueue(start);\\n        pos.Enqueue(true);\\n        \\n        int[] rows = new int[4] { 0, -1, 0, 1 };\\n        int[] cols = new int[4] { -1, 0, 1, 0 };\\n        \\n        int move = 0;\\n        while(q.Count() > 0)\\n        {\\n            int count = q.Count();\\n            for (int i = 0; i < count; i++)\\n            {\\n                int num = q.Dequeue();\\n                bool d = pos.Dequeue();\\n                int r = num / n;\\n                int c = num % n;\\n                \\n                if (r == n -1 && c == n - 1 && d == true)\\n                {\\n                    return move;\\n                }\\n                \\n                if (d == true) // horizontal\\n                {\\n                    if (c < n - 1 && grid[r][c + 1] == 0 && !h.Contains(r * n + c + 1))\\n                    {\\n                        q.Enqueue(r * n + c + 1);\\n                        pos.Enqueue(true);\\n                        h.Add(r * n + c + 1);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0 && !h.Contains((r + 1) * n + c))\\n                    {\\n                        q.Enqueue((r + 1) * n + c);\\n                        pos.Enqueue(true);\\n                        h.Add((r + 1) * n + c);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0 && !v.Contains((r + 1) * n + c - 1))\\n                    {\\n                        q.Enqueue((r + 1) * n + c - 1);\\n                        pos.Enqueue(false);\\n                        v.Add((r + 1) * n + c - 1);\\n                    }\\n                }\\n                else\\n                {\\n                    if (c < n - 1 && grid[r - 1][c + 1] == 0 && grid[r][c + 1] == 0 && !v.Contains(r * n + c + 1))\\n                    {\\n                        q.Enqueue(r * n + c + 1);\\n                        pos.Enqueue(false);\\n                        v.Add(r * n + c + 1);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && !v.Contains((r + 1) * n + c))\\n                    {\\n                        q.Enqueue((r + 1) * n + c);\\n                        pos.Enqueue(false);\\n                        v.Add((r + 1) * n + c);\\n                    }\\n                    \\n                    if (c < n - 1 && grid[r - 1][c + 1] == 0 && grid[r][c + 1] == 0 && !h.Contains((r - 1) * n + c + 1))\\n                    {\\n                        q.Enqueue((r - 1) * n + c + 1);\\n                        pos.Enqueue(true);\\n                        h.Add((r - 1) * n + c + 1);\\n                    }\\n                }\\n            }\\n            \\n            move++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinimumMoves(int[][] grid) {\\n        \\n        Queue<int> q = new Queue<int>();\\n        Queue<bool> pos = new Queue<bool>();\\n        \\n        HashSet<int> v = new HashSet<int>();\\n        HashSet<int> h = new HashSet<int>();\\n        \\n        int n = grid.Length;\\n        int start = n * 0 + 1;\\n        \\n        // horizontal = true / vertical = false\\n        q.Enqueue(start);\\n        pos.Enqueue(true);\\n        \\n        int[] rows = new int[4] { 0, -1, 0, 1 };\\n        int[] cols = new int[4] { -1, 0, 1, 0 };\\n        \\n        int move = 0;\\n        while(q.Count() > 0)\\n        {\\n            int count = q.Count();\\n            for (int i = 0; i < count; i++)\\n            {\\n                int num = q.Dequeue();\\n                bool d = pos.Dequeue();\\n                int r = num / n;\\n                int c = num % n;\\n                \\n                if (r == n -1 && c == n - 1 && d == true)\\n                {\\n                    return move;\\n                }\\n                \\n                if (d == true) // horizontal\\n                {\\n                    if (c < n - 1 && grid[r][c + 1] == 0 && !h.Contains(r * n + c + 1))\\n                    {\\n                        q.Enqueue(r * n + c + 1);\\n                        pos.Enqueue(true);\\n                        h.Add(r * n + c + 1);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0 && !h.Contains((r + 1) * n + c))\\n                    {\\n                        q.Enqueue((r + 1) * n + c);\\n                        pos.Enqueue(true);\\n                        h.Add((r + 1) * n + c);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0 && !v.Contains((r + 1) * n + c - 1))\\n                    {\\n                        q.Enqueue((r + 1) * n + c - 1);\\n                        pos.Enqueue(false);\\n                        v.Add((r + 1) * n + c - 1);\\n                    }\\n                }\\n                else\\n                {\\n                    if (c < n - 1 && grid[r - 1][c + 1] == 0 && grid[r][c + 1] == 0 && !v.Contains(r * n + c + 1))\\n                    {\\n                        q.Enqueue(r * n + c + 1);\\n                        pos.Enqueue(false);\\n                        v.Add(r * n + c + 1);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && !v.Contains((r + 1) * n + c))\\n                    {\\n                        q.Enqueue((r + 1) * n + c);\\n                        pos.Enqueue(false);\\n                        v.Add((r + 1) * n + c);\\n                    }\\n                    \\n                    if (c < n - 1 && grid[r - 1][c + 1] == 0 && grid[r][c + 1] == 0 && !h.Contains((r - 1) * n + c + 1))\\n                    {\\n                        q.Enqueue((r - 1) * n + c + 1);\\n                        pos.Enqueue(true);\\n                        h.Add((r - 1) * n + c + 1);\\n                    }\\n                }\\n            }\\n            \\n            move++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449888,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MinimumMoves(int[][] grid) \\n    {\\n        int r = grid.Length, c = grid[0].Length;\\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[] {0, 0, 0});\\n        var visited = new bool[r,c,2];\\n        visited[0, 0, 0] = true;\\n        int depth = 0;\\n        while(queue.Count != 0)\\n        {\\n            var count = queue.Count();\\n            while(count-- != 0)\\n            {\\n                var curr = queue.Dequeue();\\n                int x = curr[0], y = curr[1], dir = curr[2];\\n                if((x == r - 1 && y == c - 2 && dir == 0))\\n                    return depth;\\n                List<int[]> next = new List<int[]>();\\n                if(dir == 0)\\n                {\\n                    if(y + 2 < c && grid[x][y + 2] == 0)\\n                        next.Add(new[] {x, y + 1, 0});\\n                    if(x + 1 < r && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0)\\n                    {\\n                        next.Add(new[] {x, y, 1});\\n                        next.Add(new[] {x + 1, y, 0});\\n                    }\\n                }\\n                else\\n                {\\n                    if(x + 2 < r && grid[x + 2][y] == 0)\\n                        next.Add(new[] {x + 1, y, 1});\\n                    if(y + 1 < c && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0)\\n                    {\\n                        next.Add(new[] {x, y, 0});\\n                        next.Add(new[] {x, y + 1, 1});\\n                    }\\n                }\\n                    \\n                foreach(var n in next)\\n                {\\n                    if(!visited[n[0], n[1], n[2]])\\n                    {\\n                        visited[n[0], n[1], n[2]] = true;\\n                        queue.Enqueue(n);\\n                    }\\n                }\\n            }\\n            \\n            depth++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinimumMoves(int[][] grid) \\n    {\\n        int r = grid.Length, c = grid[0].Length;\\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[] {0, 0, 0});\\n        var visited = new bool[r,c,2];\\n        visited[0, 0, 0] = true;\\n        int depth = 0;\\n        while(queue.Count != 0)\\n        {\\n            var count = queue.Count();\\n            while(count-- != 0)\\n            {\\n                var curr = queue.Dequeue();\\n                int x = curr[0], y = curr[1], dir = curr[2];\\n                if((x == r - 1 && y == c - 2 && dir == 0))\\n                    return depth;\\n                List<int[]> next = new List<int[]>();\\n                if(dir == 0)\\n                {\\n                    if(y + 2 < c && grid[x][y + 2] == 0)\\n                        next.Add(new[] {x, y + 1, 0});\\n                    if(x + 1 < r && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0)\\n                    {\\n                        next.Add(new[] {x, y, 1});\\n                        next.Add(new[] {x + 1, y, 0});\\n                    }\\n                }\\n                else\\n                {\\n                    if(x + 2 < r && grid[x + 2][y] == 0)\\n                        next.Add(new[] {x + 1, y, 1});\\n                    if(y + 1 < c && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0)\\n                    {\\n                        next.Add(new[] {x, y, 0});\\n                        next.Add(new[] {x, y + 1, 1});\\n                    }\\n                }\\n                    \\n                foreach(var n in next)\\n                {\\n                    if(!visited[n[0], n[1], n[2]])\\n                    {\\n                        visited[n[0], n[1], n[2]] = true;\\n                        queue.Enqueue(n);\\n                    }\\n                }\\n            }\\n            \\n            depth++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410716,
                "title": "python-bfs-solution",
                "content": "\\n```\\nfrom collections import deque\\n\\nclass Snake(object):\\n    def __init__(self, x = 0, y = 0 , orientation=0):\\n        self.x = x\\n        self.y = y\\n        self.orientation = orientation\\n        self.num_moves = 0\\n        self.prev_move = \\'\\'\\n        self.visited = {(0,0,0)}\\n        \\n    def move(self, move):\\n        if move == \\'r\\':\\n            self.y += 1\\n        elif move == \\'d\\':\\n            self.x += 1\\n        elif move == \\'cw\\':\\n            self.orientation = 1\\n        elif move == \\'ccw\\':\\n            self.orientation = 0\\n        else:\\n            assert 0, \"Undefined move\"\\n        \\n        if (self.x, self.y, self.orientation) in self.visited:\\n            return 1\\n        \\n        self.visited.add((self.x, self.y, self.orientation))\\n        \\n        self.num_moves += 1\\n            \\n    def is_target(self, n):\\n        if self.x == n-1 and self.y == n - 2 and self.orientation == 0:\\n            return True\\n        return False\\n    \\n    def get_info(self):\\n        return (self.x, self.y, self.orientation, self.num_moves, self.visited)\\n\\n    def set_info(self, info):\\n        self.x, self.y, self.orientation, self.num_moves, self.visited = info\\n        \\n    \\n\\nclass Solution(object):\\n    def minimumMoves(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.grid = grid\\n        self.n = len(grid)\\n        \\n        # moves = [\\'r\\', \\'d\\', \\'cw\\', \\'ccw\\']   \\n        snake = Snake()\\n        \\n        m = self._get_allowed_moves(snake)\\n        q = deque(m)\\n        qinf = deque([snake.get_info()]*len(m))\\n\\n        while q:\\n            m = q.popleft()\\n            info = qinf.popleft()\\n            snake.set_info(info)\\n            visited = snake.move(m)\\n            if visited: continue\\n\\n            m = self._get_allowed_moves(snake)\\n            q.extend(m)\\n            qinf.extend([snake.get_info()]*len(m))\\n            \\n            if snake.is_target(self.n):\\n                return snake.num_moves\\n\\n        return -1\\n            \\n        \\n    def _get_allowed_moves(self, snake):\\n        allowed_move = []\\n        \\n        if snake.orientation==0:\\n            if snake.y+2<self.n and self.grid[snake.x][snake.y+2]==0:\\n                allowed_move.append(\\'r\\')\\n            if snake.x+1<self.n and self.grid[snake.x+1][snake.y]==0 and self.grid[snake.x+1][snake.y+1]==0:\\n                allowed_move.append(\\'d\\')\\n                allowed_move.append(\\'cw\\')\\n                \\n        if snake.orientation==1:\\n            if snake.y+1<self.n and self.grid[snake.x][snake.y+1]==0 and self.grid[snake.x+1][snake.y+1]==0:\\n                allowed_move.append(\\'r\\')\\n                allowed_move.append(\\'ccw\\')\\n            if snake.x+2<self.n and self.grid[snake.x+2][snake.y]==0:\\n                allowed_move.append(\\'d\\')\\n                \\n        return allowed_move\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Snake(object):\\n    def __init__(self, x = 0, y = 0 , orientation=0):\\n        self.x = x\\n        self.y = y\\n        self.orientation = orientation\\n        self.num_moves = 0\\n        self.prev_move = \\'\\'\\n        self.visited = {(0,0,0)}\\n        \\n    def move(self, move):\\n        if move == \\'r\\':\\n            self.y += 1\\n        elif move == \\'d\\':\\n            self.x += 1\\n        elif move == \\'cw\\':\\n            self.orientation = 1\\n        elif move == \\'ccw\\':\\n            self.orientation = 0\\n        else:\\n            assert 0, \"Undefined move\"\\n        \\n        if (self.x, self.y, self.orientation) in self.visited:\\n            return 1\\n        \\n        self.visited.add((self.x, self.y, self.orientation))\\n        \\n        self.num_moves += 1\\n            \\n    def is_target(self, n):\\n        if self.x == n-1 and self.y == n - 2 and self.orientation == 0:\\n            return True\\n        return False\\n    \\n    def get_info(self):\\n        return (self.x, self.y, self.orientation, self.num_moves, self.visited)\\n\\n    def set_info(self, info):\\n        self.x, self.y, self.orientation, self.num_moves, self.visited = info\\n        \\n    \\n\\nclass Solution(object):\\n    def minimumMoves(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.grid = grid\\n        self.n = len(grid)\\n        \\n        # moves = [\\'r\\', \\'d\\', \\'cw\\', \\'ccw\\']   \\n        snake = Snake()\\n        \\n        m = self._get_allowed_moves(snake)\\n        q = deque(m)\\n        qinf = deque([snake.get_info()]*len(m))\\n\\n        while q:\\n            m = q.popleft()\\n            info = qinf.popleft()\\n            snake.set_info(info)\\n            visited = snake.move(m)\\n            if visited: continue\\n\\n            m = self._get_allowed_moves(snake)\\n            q.extend(m)\\n            qinf.extend([snake.get_info()]*len(m))\\n            \\n            if snake.is_target(self.n):\\n                return snake.num_moves\\n\\n        return -1\\n            \\n        \\n    def _get_allowed_moves(self, snake):\\n        allowed_move = []\\n        \\n        if snake.orientation==0:\\n            if snake.y+2<self.n and self.grid[snake.x][snake.y+2]==0:\\n                allowed_move.append(\\'r\\')\\n            if snake.x+1<self.n and self.grid[snake.x+1][snake.y]==0 and self.grid[snake.x+1][snake.y+1]==0:\\n                allowed_move.append(\\'d\\')\\n                allowed_move.append(\\'cw\\')\\n                \\n        if snake.orientation==1:\\n            if snake.y+1<self.n and self.grid[snake.x][snake.y+1]==0 and self.grid[snake.x+1][snake.y+1]==0:\\n                allowed_move.append(\\'r\\')\\n                allowed_move.append(\\'ccw\\')\\n            if snake.x+2<self.n and self.grid[snake.x+2][snake.y]==0:\\n                allowed_move.append(\\'d\\')\\n                \\n        return allowed_move\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394602,
                "title": "java-concise-dfs-with-explanation-8-ms-beats-99-runtime-and-100-memory",
                "content": "The idea is to use two memoization and visited tables - one each for horizontal and vertical position of the snake.\\n\\n```\\n\\tpublic int minimumMoves(int[][] grid) {\\n        if(grid == null) return -1;\\n        int n = grid.length;\\n        int result = minimumMoves(0, 0, 0, 1, grid, new int[n][n][2], new boolean[n][n][2]);\\n        return (result == Integer.MAX_VALUE) ? -1 : result;\\n    }\\n    \\n    private int minimumMoves(int x1, int y1, int x2, int y2, int[][] grid, int[][][] memo, boolean[][][] visited){\\n        int n = grid.length;\\n\\t\\t/*return error if this position is invalid*/\\n        if(x1 >= n || x2 >= n || y1 >= n || y2 >= n || grid[x1][y1] == 1 || grid[x2][y2] == 1) return Integer.MAX_VALUE;\\n        if(x1 == n-1 && y1 == n-2 && x2 == n-1 && y2 == n-1) return 0; //return 0 if we reached target\\n        \\n        int index = (x1 == x2) ? 0 : 1; //determine the index of memo or visited table to look into\\n        if(memo[x1][y1][index] != 0) return memo[x1][y1][index]; //if memo already contains valid value, return it\\n        if(visited[x1][y1][index]) return Integer.MAX_VALUE; //else it is already visited, we did not find any valid path from this position\\n        \\n        visited[x1][y1][index] = true;        \\n        int result = Integer.MAX_VALUE;\\n        \\n\\t\\t/*Determine the number of minimum moves from this position depending on whether it is vertical or horizontal*/\\n\\t\\t//horizontal\\n        if(x1 == x2){\\n            result = Math.min(result, minimumMoves(x2, y2, x2, y2+1, grid, memo, visited)); //right\\n            result = Math.min(result, minimumMoves(x1+1, y1, x2+1, y2, grid, memo, visited)); //down\\n            if(x1+1 < n && y1+1 < n && grid[x1+1][y1+1] == 0){\\n                result = Math.min(result, minimumMoves(x1, y1, x1+1, y1, grid, memo, visited)); //rotation\\n            }\\n        }\\n\\t\\t//vertical\\n        else{\\n            result = Math.min(result, minimumMoves(x2, y2, x2+1, y2, grid, memo, visited)); //down\\n            result = Math.min(result, minimumMoves(x1, y1+1, x2, y2+1, grid, memo, visited)); //right\\n            if(x1+1 < n && y1+1 < n && grid[x1+1][y1+1] == 0){\\n                result = Math.min(result, minimumMoves(x1, y1, x1, y1+1, grid, memo, visited)); //rotation\\n            }\\n        }\\n        \\n        if(result < Integer.MAX_VALUE) result++; //increment the result as we need to consider a move from current position\\n        memo[x1][y1][index] = result; //store the result in the appropriate memo table\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "The idea is to use two memoization and visited tables - one each for horizontal and vertical position of the snake.\\n\\n```\\n\\tpublic int minimumMoves(int[][] grid) {\\n        if(grid == null) return -1;\\n        int n = grid.length;\\n        int result = minimumMoves(0, 0, 0, 1, grid, new int[n][n][2], new boolean[n][n][2]);\\n        return (result == Integer.MAX_VALUE) ? -1 : result;\\n    }\\n    \\n    private int minimumMoves(int x1, int y1, int x2, int y2, int[][] grid, int[][][] memo, boolean[][][] visited){\\n        int n = grid.length;\\n\\t\\t/*return error if this position is invalid*/\\n        if(x1 >= n || x2 >= n || y1 >= n || y2 >= n || grid[x1][y1] == 1 || grid[x2][y2] == 1) return Integer.MAX_VALUE;\\n        if(x1 == n-1 && y1 == n-2 && x2 == n-1 && y2 == n-1) return 0; //return 0 if we reached target\\n        \\n        int index = (x1 == x2) ? 0 : 1; //determine the index of memo or visited table to look into\\n        if(memo[x1][y1][index] != 0) return memo[x1][y1][index]; //if memo already contains valid value, return it\\n        if(visited[x1][y1][index]) return Integer.MAX_VALUE; //else it is already visited, we did not find any valid path from this position\\n        \\n        visited[x1][y1][index] = true;        \\n        int result = Integer.MAX_VALUE;\\n        \\n\\t\\t/*Determine the number of minimum moves from this position depending on whether it is vertical or horizontal*/\\n\\t\\t//horizontal\\n        if(x1 == x2){\\n            result = Math.min(result, minimumMoves(x2, y2, x2, y2+1, grid, memo, visited)); //right\\n            result = Math.min(result, minimumMoves(x1+1, y1, x2+1, y2, grid, memo, visited)); //down\\n            if(x1+1 < n && y1+1 < n && grid[x1+1][y1+1] == 0){\\n                result = Math.min(result, minimumMoves(x1, y1, x1+1, y1, grid, memo, visited)); //rotation\\n            }\\n        }\\n\\t\\t//vertical\\n        else{\\n            result = Math.min(result, minimumMoves(x2, y2, x2+1, y2, grid, memo, visited)); //down\\n            result = Math.min(result, minimumMoves(x1, y1+1, x2, y2+1, grid, memo, visited)); //right\\n            if(x1+1 < n && y1+1 < n && grid[x1+1][y1+1] == 0){\\n                result = Math.min(result, minimumMoves(x1, y1, x1, y1+1, grid, memo, visited)); //rotation\\n            }\\n        }\\n        \\n        if(result < Integer.MAX_VALUE) result++; //increment the result as we need to consider a move from current position\\n        memo[x1][y1][index] = result; //store the result in the appropriate memo table\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 394159,
                "title": "java-bfs-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        if(n == 0) return -1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0, 0, 1});\\n        Set<String> visited = new HashSet<>();\\n        visited.add(\"0,0,0,1\");\\n        int count = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n\\t\\t\\t\\t//curr[0] is the row of first cell, curr[1] is the col of the first cell;\\n\\t\\t\\t\\t//curr[2] is the row of the second cell, curr[3] is the col of the second cell.\\n                int[] curr = q.poll();\\n                if(curr[0] == n - 1 && curr[1] == n - 2 && curr[2] == n - 1 && curr[3] == n - 1) {\\n                    return count;\\n                }\\n                //be horizontal and move right.\\n                if(isHorizontal(curr) && curr[3] < n - 1 && grid[curr[0]][curr[3] + 1] == 0) {\\n                    int r1 = curr[2], c1 = curr[3], r2 = r1, c2 = c1 + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and move down.\\n                if(isVertical(curr) && curr[2] < n - 1 && grid[curr[2] + 1][curr[3]] == 0) {\\n                    int r1 = curr[2], c1 = curr[3], r2 = r1 + 1, c2 = c1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be horizontal and rotate clockwise.\\n                if(isHorizontal(curr) && curr[0] < n - 1 && grid[curr[0] + 1][curr[1]] == 0 && grid[curr[0] + 1][curr[3]] == 0) {\\n                    int r1 = curr[0], c1 = curr[1], r2 = curr[2] + 1, c2 = c1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and rotate counterclockwise.\\n                if(isVertical(curr) && curr[1] < n - 1 && grid[curr[0]][curr[1] + 1] == 0 && grid[curr[2]][curr[1] + 1] == 0) {\\n                    int r1 = curr[0], c1 = curr[1], r2 = r1, c2 = curr[3] + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be horizontal and move down.\\n                if(isHorizontal(curr) && curr[0] < n - 1 && grid[curr[0] + 1][curr[1]] == 0 && grid[curr[0] + 1][curr[3]] == 0) {\\n                    int r1 = curr[0] + 1, c1 = curr[1], r2 = curr[2] + 1, c2 = curr[3];\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and move right.\\n                if(isVertical(curr) && curr[1] < n - 1 && grid[curr[0]][curr[1] + 1] == 0 && grid[curr[2]][curr[1] + 1] == 0) {\\n                    int r1 = curr[0], c1 = curr[1] + 1, r2 = curr[2], c2 = curr[3] + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n    \\n    public boolean isHorizontal(int[] loc) {\\n        return loc[0] == loc[2];\\n    }\\n    public boolean isVertical(int[] loc) {\\n        return loc[1] == loc[3];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        if(n == 0) return -1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0, 0, 1});\\n        Set<String> visited = new HashSet<>();\\n        visited.add(\"0,0,0,1\");\\n        int count = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n\\t\\t\\t\\t//curr[0] is the row of first cell, curr[1] is the col of the first cell;\\n\\t\\t\\t\\t//curr[2] is the row of the second cell, curr[3] is the col of the second cell.\\n                int[] curr = q.poll();\\n                if(curr[0] == n - 1 && curr[1] == n - 2 && curr[2] == n - 1 && curr[3] == n - 1) {\\n                    return count;\\n                }\\n                //be horizontal and move right.\\n                if(isHorizontal(curr) && curr[3] < n - 1 && grid[curr[0]][curr[3] + 1] == 0) {\\n                    int r1 = curr[2], c1 = curr[3], r2 = r1, c2 = c1 + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and move down.\\n                if(isVertical(curr) && curr[2] < n - 1 && grid[curr[2] + 1][curr[3]] == 0) {\\n                    int r1 = curr[2], c1 = curr[3], r2 = r1 + 1, c2 = c1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be horizontal and rotate clockwise.\\n                if(isHorizontal(curr) && curr[0] < n - 1 && grid[curr[0] + 1][curr[1]] == 0 && grid[curr[0] + 1][curr[3]] == 0) {\\n                    int r1 = curr[0], c1 = curr[1], r2 = curr[2] + 1, c2 = c1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and rotate counterclockwise.\\n                if(isVertical(curr) && curr[1] < n - 1 && grid[curr[0]][curr[1] + 1] == 0 && grid[curr[2]][curr[1] + 1] == 0) {\\n                    int r1 = curr[0], c1 = curr[1], r2 = r1, c2 = curr[3] + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be horizontal and move down.\\n                if(isHorizontal(curr) && curr[0] < n - 1 && grid[curr[0] + 1][curr[1]] == 0 && grid[curr[0] + 1][curr[3]] == 0) {\\n                    int r1 = curr[0] + 1, c1 = curr[1], r2 = curr[2] + 1, c2 = curr[3];\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and move right.\\n                if(isVertical(curr) && curr[1] < n - 1 && grid[curr[0]][curr[1] + 1] == 0 && grid[curr[2]][curr[1] + 1] == 0) {\\n                    int r1 = curr[0], c1 = curr[1] + 1, r2 = curr[2], c2 = curr[3] + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n    \\n    public boolean isHorizontal(int[] loc) {\\n        return loc[0] == loc[2];\\n    }\\n    public boolean isVertical(int[] loc) {\\n        return loc[1] == loc[3];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394020,
                "title": "java-easy-readable-bfs-solution",
                "content": "It\\'s common to use BFS to find a shortest path, the difference is the rule of how to expand each step to a new one.\\n```\\npublic int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        if (grid[n - 1][n - 2] != 0 || grid[n - 1][n - 1] != 0) {\\n            return -1;\\n        }\\n        int step = 0;\\n        int[] start = new int[]{0, 0, 0, 1};\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        Set<String> visited = new HashSet<>();\\n        visited.add(pos2Str(start));\\n\\n        while (!q.isEmpty()) {\\n            for (int cnt = q.size(); cnt > 0; cnt--) {\\n                int[] cur = q.poll();\\n                if (cur[0] == n - 1 && cur[1] == n - 2 && cur[2] == n - 1 && cur[3] == n - 1) {\\n                    return step;\\n                }\\n                // expand\\n                List<int[]> nextList = expand(grid, cur);\\n                for (int[] next : nextList) {\\n                    String posStr = pos2Str(next);\\n                    if (!visited.contains(posStr)) {\\n                        visited.add(posStr);\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n\\n    private List<int[]> expand(int[][] grid, int[] cur) {\\n        List<int[]> result = new ArrayList<>();\\n        int n = grid.length;\\n\\n        int[] next;\\n        if (cur[0] == cur[2]) {  // cur horizon\\n            // right\\n            if (cur[3] + 1 < n && grid[cur[0]][cur[3] + 1] == 0) {\\n                next = new int[]{cur[0], cur[1] + 1, cur[0], cur[3] + 1};\\n                result.add(next);\\n            }\\n\\n            if (cur[0] + 1 < n && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[0] + 1][cur[3]] == 0) {\\n                // down\\n                next = new int[]{cur[0] + 1, cur[1], cur[0] + 1, cur[3]};\\n                result.add(next);\\n                // clock wise\\n                next = new int[]{cur[0], cur[1], cur[0] + 1, cur[1]};\\n                result.add(next);\\n            }\\n        } else { // vertical\\n            if (cur[1] + 1 < n && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[2]][cur[1] + 1] == 0) {\\n                // right\\n                next = new int[]{cur[0], cur[1] + 1, cur[2], cur[1] + 1};\\n                result.add(next);\\n                //counterclockwise\\n                next = new int[]{cur[0], cur[1], cur[0], cur[1] + 1};\\n                result.add(next);\\n            }\\n            // down\\n            if (cur[2] + 1 < n && grid[cur[2] + 1][cur[1]] == 0) {\\n                next = new int[]{cur[0] + 1, cur[1], cur[2] + 1, cur[1]};\\n                result.add(next);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private String pos2Str(int[] pos) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < pos.length; i++) {\\n            sb.append(pos[i]);\\n            sb.append(\\'@\\');\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "It\\'s common to use BFS to find a shortest path, the difference is the rule of how to expand each step to a new one.\\n```\\npublic int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        if (grid[n - 1][n - 2] != 0 || grid[n - 1][n - 1] != 0) {\\n            return -1;\\n        }\\n        int step = 0;\\n        int[] start = new int[]{0, 0, 0, 1};\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        Set<String> visited = new HashSet<>();\\n        visited.add(pos2Str(start));\\n\\n        while (!q.isEmpty()) {\\n            for (int cnt = q.size(); cnt > 0; cnt--) {\\n                int[] cur = q.poll();\\n                if (cur[0] == n - 1 && cur[1] == n - 2 && cur[2] == n - 1 && cur[3] == n - 1) {\\n                    return step;\\n                }\\n                // expand\\n                List<int[]> nextList = expand(grid, cur);\\n                for (int[] next : nextList) {\\n                    String posStr = pos2Str(next);\\n                    if (!visited.contains(posStr)) {\\n                        visited.add(posStr);\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n\\n    private List<int[]> expand(int[][] grid, int[] cur) {\\n        List<int[]> result = new ArrayList<>();\\n        int n = grid.length;\\n\\n        int[] next;\\n        if (cur[0] == cur[2]) {  // cur horizon\\n            // right\\n            if (cur[3] + 1 < n && grid[cur[0]][cur[3] + 1] == 0) {\\n                next = new int[]{cur[0], cur[1] + 1, cur[0], cur[3] + 1};\\n                result.add(next);\\n            }\\n\\n            if (cur[0] + 1 < n && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[0] + 1][cur[3]] == 0) {\\n                // down\\n                next = new int[]{cur[0] + 1, cur[1], cur[0] + 1, cur[3]};\\n                result.add(next);\\n                // clock wise\\n                next = new int[]{cur[0], cur[1], cur[0] + 1, cur[1]};\\n                result.add(next);\\n            }\\n        } else { // vertical\\n            if (cur[1] + 1 < n && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[2]][cur[1] + 1] == 0) {\\n                // right\\n                next = new int[]{cur[0], cur[1] + 1, cur[2], cur[1] + 1};\\n                result.add(next);\\n                //counterclockwise\\n                next = new int[]{cur[0], cur[1], cur[0], cur[1] + 1};\\n                result.add(next);\\n            }\\n            // down\\n            if (cur[2] + 1 < n && grid[cur[2] + 1][cur[1]] == 0) {\\n                next = new int[]{cur[0] + 1, cur[1], cur[2] + 1, cur[1]};\\n                result.add(next);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private String pos2Str(int[] pos) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < pos.length; i++) {\\n            sb.append(pos[i]);\\n            sb.append(\\'@\\');\\n        }\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 393743,
                "title": "java-bfs-beats-100-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid[0].length;\\n        Queue<head> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        head start = new head(0,1,0);\\n        q.add(start);\\n        q.add(null);\\n        int moves = 0;\\n        \\n        while(!q.isEmpty()){\\n          head temp = q.poll();\\n            if(temp == null){\\n              if(!q.isEmpty()){\\n                  q.add(null);\\n              }\\n              moves++;\\n            } else {\\n            \\n            int x = temp.headx;\\n            int y = temp.heady;\\n            int status = temp.status;\\n            String currKey = x + \":\"+y+\":\"+status;\\n            if(visited.contains(currKey)){\\n                continue;\\n            }\\n            visited.add(currKey);\\n            if(x == n-1 && y == n-1 && status == 0){\\n                return moves;\\n            }\\n            //r\\n            if(y+1 < n  && grid[x][y+1] == 0 && grid[x-status][y+1] == 0){\\n                q.add(new head(x,y+1,status));\\n            }\\n            //d\\n            if(isDownPossible(x,y,status,grid)){\\n                q.add(new head(x+1,y,status));\\n            }\\n            // rotate\\n            if(status == 0 && x+1 < n && grid[x+1][y-1] == 0 && grid[x+1][y] == 0 ){\\n                  q.add(new head(x+1,y-1,1));\\n            }\\n            // counter \\n            if(status == 1 && y+1 < n && grid[x][y+1] == 0 && grid[x-1][y+1] == 0){\\n                  q.add(new head(x-1,y+1,0));\\n            }\\n        }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private boolean isDownPossible(int x , int y, int status, int[][] grid){\\n       \\n        int n = grid[0].length;\\n        if(x + 1 < n){\\n            if(status ==0){\\n                if(grid[x+1][y-1] == 0 && grid[x+1][y] == 0){\\n                    return true;\\n                }\\n            }else{\\n                if(grid[x+1][y] == 0 ) {\\n                    return true;\\n                }\\n            }\\n         }\\n        return false;\\n    }\\n    \\n    class head {\\n        int headx ;\\n        int heady;\\n        int status;\\n        public head(int x, int y, int status){\\n            this.headx =x;\\n            this.heady = y;\\n            this.status = status;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid[0].length;\\n        Queue<head> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        head start = new head(0,1,0);\\n        q.add(start);\\n        q.add(null);\\n        int moves = 0;\\n        \\n        while(!q.isEmpty()){\\n          head temp = q.poll();\\n            if(temp == null){\\n              if(!q.isEmpty()){\\n                  q.add(null);\\n              }\\n              moves++;\\n            } else {\\n            \\n            int x = temp.headx;\\n            int y = temp.heady;\\n            int status = temp.status;\\n            String currKey = x + \":\"+y+\":\"+status;\\n            if(visited.contains(currKey)){\\n                continue;\\n            }\\n            visited.add(currKey);\\n            if(x == n-1 && y == n-1 && status == 0){\\n                return moves;\\n            }\\n            //r\\n            if(y+1 < n  && grid[x][y+1] == 0 && grid[x-status][y+1] == 0){\\n                q.add(new head(x,y+1,status));\\n            }\\n            //d\\n            if(isDownPossible(x,y,status,grid)){\\n                q.add(new head(x+1,y,status));\\n            }\\n            // rotate\\n            if(status == 0 && x+1 < n && grid[x+1][y-1] == 0 && grid[x+1][y] == 0 ){\\n                  q.add(new head(x+1,y-1,1));\\n            }\\n            // counter \\n            if(status == 1 && y+1 < n && grid[x][y+1] == 0 && grid[x-1][y+1] == 0){\\n                  q.add(new head(x-1,y+1,0));\\n            }\\n        }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private boolean isDownPossible(int x , int y, int status, int[][] grid){\\n       \\n        int n = grid[0].length;\\n        if(x + 1 < n){\\n            if(status ==0){\\n                if(grid[x+1][y-1] == 0 && grid[x+1][y] == 0){\\n                    return true;\\n                }\\n            }else{\\n                if(grid[x+1][y] == 0 ) {\\n                    return true;\\n                }\\n            }\\n         }\\n        return false;\\n    }\\n    \\n    class head {\\n        int headx ;\\n        int heady;\\n        int status;\\n        public head(int x, int y, int status){\\n            this.headx =x;\\n            this.heady = y;\\n            this.status = status;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393614,
                "title": "45-lines-java-with-dp-and-explaination-faster-than-100-100",
                "content": "* dp[i][j][0] means the minimum step to move to (i,j) and the snake is horizontal now.\\n* dp[i][j][1] means the minimum step to move to (i,j) and the snake is vertical now.\\n\\nstate transfer function: \\n* dp[i][j][0] = Min(dp[i-1][j][0], dp[i][j-1][0], dp[i+1][j-1][1]) + 1 // down, right, counterclockwise\\n* dp[i][j][1] = Min(dp[i-1][j][1], dp[i][j-1][1], dp[i-1][j+1][0]) + 1 // down, right, clockwise\\n\\nPlease note each operation needs to check some limitations carefully.\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][][] dp = new int[n][n][2];\\n        // initial\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                dp[i][j][0] = dp[i][j][1] = Integer.MAX_VALUE;\\n            }\\n        }\\n        // base case\\n        dp[0][1][0] = 0;\\n        if(grid[1][0] == 0 && grid[1][1] == 0) dp[1][0][1] = 1;\\n        for(int i=2; i<n; i++){\\n            if(grid[0][i] == 0 && dp[0][i-1][0] != Integer.MAX_VALUE) dp[0][i][0] = dp[0][i-1][0] + 1;\\n            if(grid[i][0] == 0 && dp[i-1][0][1] != Integer.MAX_VALUE) dp[i][0][1] = dp[i-1][0][1] + 1;\\n        }\\n        \\n        // start dp, k is the length of diagonal line from bottom left to upper right\\n        for(int k=2; k<=2*n-2; k++){\\n            for(int j=k<=n-1? 1: k-n+1; j<n && j<k; j++){\\n                int i = k-j;\\n                // when the snake is horizontal with head at (i,j)\\n                if(grid[i][j] == 0 && grid[i][j-1] == 0){\\n                    dp[i][j][0] = Math.min(dp[i][j-1][0], dp[i-1][j][0]);\\n                    if(i<n-1 && grid[i+1][j] == 0) dp[i][j][0] = Math.min(dp[i][j][0], dp[i+1][j-1][1]);\\n                    // If it\\'s possible to move to (i,j) with horizontal body\\n                    if(dp[i][j][0] != Integer.MAX_VALUE){\\n                        dp[i][j][0] += 1;\\n                        if(i<n-1 && grid[i+1][j] == 0 && grid[i+1][j-1] == 0){\\n                            dp[i+1][j-1][1] = Math.min(dp[i][j][0]+1, dp[i+1][j-1][1]);\\n                        }\\n                    }\\n                }\\n                // when the snake is vertical with head at (i,j)\\n                if(grid[i][j] == 0 && grid[i-1][j] == 0){\\n                    dp[i][j][1] = Math.min(dp[i-1][j][1], dp[i][j-1][1]);\\n                    if(j<n-1 && grid[i][j+1] == 0) dp[i][j][1] = Math.min(dp[i][j][1], dp[i-1][j+1][0]);\\n                    // If it\\'s possible to move to (i,j) with vertical body\\n                    if(dp[i][j][1] != Integer.MAX_VALUE){\\n                        dp[i][j][1] += 1;\\n                        if(j<n-1 && grid[i][j+1] == 0 && grid[i-1][j+1] == 0){\\n                            dp[i-1][j+1][0] = Math.min(dp[i][j][1]+1, dp[i-1][j+1][0]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n-1][n-1][0] == Integer.MAX_VALUE? -1: dp[n-1][n-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][][] dp = new int[n][n][2];\\n        // initial\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                dp[i][j][0] = dp[i][j][1] = Integer.MAX_VALUE;\\n            }\\n        }\\n        // base case\\n        dp[0][1][0] = 0;\\n        if(grid[1][0] == 0 && grid[1][1] == 0) dp[1][0][1] = 1;\\n        for(int i=2; i<n; i++){\\n            if(grid[0][i] == 0 && dp[0][i-1][0] != Integer.MAX_VALUE) dp[0][i][0] = dp[0][i-1][0] + 1;\\n            if(grid[i][0] == 0 && dp[i-1][0][1] != Integer.MAX_VALUE) dp[i][0][1] = dp[i-1][0][1] + 1;\\n        }\\n        \\n        // start dp, k is the length of diagonal line from bottom left to upper right\\n        for(int k=2; k<=2*n-2; k++){\\n            for(int j=k<=n-1? 1: k-n+1; j<n && j<k; j++){\\n                int i = k-j;\\n                // when the snake is horizontal with head at (i,j)\\n                if(grid[i][j] == 0 && grid[i][j-1] == 0){\\n                    dp[i][j][0] = Math.min(dp[i][j-1][0], dp[i-1][j][0]);\\n                    if(i<n-1 && grid[i+1][j] == 0) dp[i][j][0] = Math.min(dp[i][j][0], dp[i+1][j-1][1]);\\n                    // If it\\'s possible to move to (i,j) with horizontal body\\n                    if(dp[i][j][0] != Integer.MAX_VALUE){\\n                        dp[i][j][0] += 1;\\n                        if(i<n-1 && grid[i+1][j] == 0 && grid[i+1][j-1] == 0){\\n                            dp[i+1][j-1][1] = Math.min(dp[i][j][0]+1, dp[i+1][j-1][1]);\\n                        }\\n                    }\\n                }\\n                // when the snake is vertical with head at (i,j)\\n                if(grid[i][j] == 0 && grid[i-1][j] == 0){\\n                    dp[i][j][1] = Math.min(dp[i-1][j][1], dp[i][j-1][1]);\\n                    if(j<n-1 && grid[i][j+1] == 0) dp[i][j][1] = Math.min(dp[i][j][1], dp[i-1][j+1][0]);\\n                    // If it\\'s possible to move to (i,j) with vertical body\\n                    if(dp[i][j][1] != Integer.MAX_VALUE){\\n                        dp[i][j][1] += 1;\\n                        if(j<n-1 && grid[i][j+1] == 0 && grid[i-1][j+1] == 0){\\n                            dp[i-1][j+1][0] = Math.min(dp[i][j][1]+1, dp[i-1][j+1][0]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n-1][n-1][0] == Integer.MAX_VALUE? -1: dp[n-1][n-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393581,
                "title": "c-bfs-hash",
                "content": "```\\npublic class Solution {\\n    \\n    public class Snake\\n    {\\n        const int MAX = 10000;\\n        \\n        public static int n;\\n        \\n        public Pos head;\\n        public Pos tail;\\n        \\n        public Snake()\\n        {\\n            head = new Pos();\\n            tail = new Pos();\\n        }\\n        \\n        public void SetHead(int r, int c)\\n        {\\n            head.row = r;\\n            head.col = c;\\n        }\\n        \\n        public void SetTail(int r, int c)\\n        {\\n            tail.row = r;\\n            tail.col = c;\\n        }\\n        \\n        public int HashValue\\n        {\\n            get\\n            {\\n                return tail.row*n + tail.col + (head.row*n + head.col)*MAX;\\n            }\\n        }\\n        \\n        public bool IsDes()\\n        {\\n            return (head.row == n-1 && head.col == n-1 && tail.row == n-1 && tail.col == n-2)\\n                || (head.row == n-1 && head.col == n-2 && tail.row == n-1 && tail.col == n-1);\\n        }\\n        \\n        public bool IsVertical()\\n        {\\n            return head.col == tail.col;\\n        }\\n    }\\n    \\n    public class Pos\\n    {\\n        public int row;\\n        public int col;\\n    }\\n    \\n    //bfs\\n    public int MinimumMoves(int[][] grid) {\\n        \\n        int n = grid.Length;\\n        Snake.n = grid.Length;\\n        \\n        Queue<Snake> queue = new Queue<Snake>();\\n        HashSet<int> hs = new HashSet<int>();\\n        \\n        Snake snake = new Snake();\\n        snake.SetHead(0, 1);\\n        snake.SetTail(0, 0);\\n        \\n        hs.Add(snake.HashValue);\\n        queue.Enqueue(snake);\\n        \\n        int res = 0;\\n        \\n        while(queue.Count > 0)\\n        {\\n            int cnt = queue.Count;\\n            \\n            for(int i=0; i<cnt; i++)\\n            {\\n                Snake cur = queue.Dequeue();\\n                \\n                if(cur.IsDes())\\n                {\\n                    return res;\\n                }\\n                \\n                //right\\n                if(cur.head.col + 1 < n && cur.tail.col + 1 < n \\n                   && grid[cur.head.row][cur.head.col + 1] == 0 \\n                   && grid[cur.tail.row][cur.tail.col + 1] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row, cur.head.col + 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col + 1);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //down\\n                if(cur.head.row + 1 < n && cur.tail.row + 1 < n \\n                   && grid[cur.head.row + 1][cur.head.col] == 0 \\n                   && grid[cur.tail.row + 1][cur.tail.col] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row + 1, cur.head.col);\\n                    next.SetTail(cur.tail.row + 1, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //clockwise\\n                if(!cur.IsVertical() && cur.head.row + 1 < n\\n                   && grid[cur.head.row + 1][cur.head.col] == 0 \\n                   && grid[cur.tail.row + 1][cur.tail.col] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row + 1, cur.head.col - 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //counterclockwise\\n                if(cur.IsVertical() && cur.head.col + 1 < n\\n                   && grid[cur.head.row][cur.head.col + 1] == 0 \\n                   && grid[cur.tail.row][cur.tail.col + 1] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row - 1, cur.head.col + 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n            }\\n            \\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public class Snake\\n    {\\n        const int MAX = 10000;\\n        \\n        public static int n;\\n        \\n        public Pos head;\\n        public Pos tail;\\n        \\n        public Snake()\\n        {\\n            head = new Pos();\\n            tail = new Pos();\\n        }\\n        \\n        public void SetHead(int r, int c)\\n        {\\n            head.row = r;\\n            head.col = c;\\n        }\\n        \\n        public void SetTail(int r, int c)\\n        {\\n            tail.row = r;\\n            tail.col = c;\\n        }\\n        \\n        public int HashValue\\n        {\\n            get\\n            {\\n                return tail.row*n + tail.col + (head.row*n + head.col)*MAX;\\n            }\\n        }\\n        \\n        public bool IsDes()\\n        {\\n            return (head.row == n-1 && head.col == n-1 && tail.row == n-1 && tail.col == n-2)\\n                || (head.row == n-1 && head.col == n-2 && tail.row == n-1 && tail.col == n-1);\\n        }\\n        \\n        public bool IsVertical()\\n        {\\n            return head.col == tail.col;\\n        }\\n    }\\n    \\n    public class Pos\\n    {\\n        public int row;\\n        public int col;\\n    }\\n    \\n    //bfs\\n    public int MinimumMoves(int[][] grid) {\\n        \\n        int n = grid.Length;\\n        Snake.n = grid.Length;\\n        \\n        Queue<Snake> queue = new Queue<Snake>();\\n        HashSet<int> hs = new HashSet<int>();\\n        \\n        Snake snake = new Snake();\\n        snake.SetHead(0, 1);\\n        snake.SetTail(0, 0);\\n        \\n        hs.Add(snake.HashValue);\\n        queue.Enqueue(snake);\\n        \\n        int res = 0;\\n        \\n        while(queue.Count > 0)\\n        {\\n            int cnt = queue.Count;\\n            \\n            for(int i=0; i<cnt; i++)\\n            {\\n                Snake cur = queue.Dequeue();\\n                \\n                if(cur.IsDes())\\n                {\\n                    return res;\\n                }\\n                \\n                //right\\n                if(cur.head.col + 1 < n && cur.tail.col + 1 < n \\n                   && grid[cur.head.row][cur.head.col + 1] == 0 \\n                   && grid[cur.tail.row][cur.tail.col + 1] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row, cur.head.col + 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col + 1);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //down\\n                if(cur.head.row + 1 < n && cur.tail.row + 1 < n \\n                   && grid[cur.head.row + 1][cur.head.col] == 0 \\n                   && grid[cur.tail.row + 1][cur.tail.col] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row + 1, cur.head.col);\\n                    next.SetTail(cur.tail.row + 1, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //clockwise\\n                if(!cur.IsVertical() && cur.head.row + 1 < n\\n                   && grid[cur.head.row + 1][cur.head.col] == 0 \\n                   && grid[cur.tail.row + 1][cur.tail.col] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row + 1, cur.head.col - 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //counterclockwise\\n                if(cur.IsVertical() && cur.head.col + 1 < n\\n                   && grid[cur.head.row][cur.head.col + 1] == 0 \\n                   && grid[cur.tail.row][cur.tail.col + 1] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row - 1, cur.head.col + 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n            }\\n            \\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393453,
                "title": "java-concise-bfs-solution-take-snake-positions-as-a-node",
                "content": "When it comes to minimum moves, it is not hard to think about using BFS. If we take this as a search problem in a graph, the key is the defintion of nodes and edges in the graph . In this case, we can take snake\\'s position(as the snake is taking two positions in the grid, we should use two locations) as a node, and a move(RIGHT, DOWN, ROTATE CLOCKWISE, ROTATE ANTI-CLOCKWISE) as an edge, then we can proceed with BFS.\\n\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // r1-c1-r2-c2 as a node\\n        Set<String> visited = new HashSet<>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        int[][] moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\n        \\n        int n = grid.length;\\n        int steps = 0;\\n        \\n        queue.add(new int[] {0, 0, 0, 1});\\n        visited.add(\"0-0-0-1\");\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            steps++;\\n            for (int k = 0; k < size; k++) {\\n                int[] node = queue.poll();\\n                \\n                // moves;\\n                for (int i = 0; i < moves.length; i++) {\\n                    int r1 = node[0] + moves[i][0], c1 = node[1] + moves[i][1];\\n                    int r2 = node[2] + moves[i][2], c2 = node[3] + moves[i][3];\\n                    String id = r1 + \"-\" + c1 + \"-\" + r2 + \"-\" + c2;\\n                    \\n                    if (!isValid(r1, c1, grid) || !isValid(r2, c2, grid)) {\\n                        continue;\\n                    } else if (r1 == n - 1 && c1 == n - 2 && r2 == n - 1 && c2 == n - 1) {\\n                        return steps;\\n                    } else if (!visited.contains(id)) {\\n                        if (i < 2 || (isH(node) && i == 2 || !isH(node) && i == 3) && isValid(r1 + 1, c1 + 1, grid)) {\\n                            visited.add(id);\\n                            queue.add(new int[] {r1, c1, r2, c2});    \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    boolean isH(int[] node) {\\n        return node[0] == node[2];\\n    }\\n    \\n    boolean isValid(int r, int c, int[][] grid) {\\n        int n = grid.length;\\n        \\n        return r >= 0 && c >= 0 && r < n && c < n && grid[r][c] == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // r1-c1-r2-c2 as a node\\n        Set<String> visited = new HashSet<>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        int[][] moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\n        \\n        int n = grid.length;\\n        int steps = 0;\\n        \\n        queue.add(new int[] {0, 0, 0, 1});\\n        visited.add(\"0-0-0-1\");\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            steps++;\\n            for (int k = 0; k < size; k++) {\\n                int[] node = queue.poll();\\n                \\n                // moves;\\n                for (int i = 0; i < moves.length; i++) {\\n                    int r1 = node[0] + moves[i][0], c1 = node[1] + moves[i][1];\\n                    int r2 = node[2] + moves[i][2], c2 = node[3] + moves[i][3];\\n                    String id = r1 + \"-\" + c1 + \"-\" + r2 + \"-\" + c2;\\n                    \\n                    if (!isValid(r1, c1, grid) || !isValid(r2, c2, grid)) {\\n                        continue;\\n                    } else if (r1 == n - 1 && c1 == n - 2 && r2 == n - 1 && c2 == n - 1) {\\n                        return steps;\\n                    } else if (!visited.contains(id)) {\\n                        if (i < 2 || (isH(node) && i == 2 || !isH(node) && i == 3) && isValid(r1 + 1, c1 + 1, grid)) {\\n                            visited.add(id);\\n                            queue.add(new int[] {r1, c1, r2, c2});    \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    boolean isH(int[] node) {\\n        return node[0] == node[2];\\n    }\\n    \\n    boolean isValid(int r, int c, int[][] grid) {\\n        int n = grid.length;\\n        \\n        return r >= 0 && c >= 0 && r < n && c < n && grid[r][c] == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393163,
                "title": "python-bfs-extended-with-comments",
                "content": "**Approach**\\n1) use a named tuple Part to keep track of tail and head\\n2) use a named tuple Snake to keep track of the whole body\\n3) calculate finish snake state\\n4) enqueue initial snake state\\n5) use BFS to traverse the board and get to the end in as few steps as possible\\n\\n**Complexity analysis**\\ntime: O(V + E)\\nspace: O(V + E)\\n\\n```python\\nPart = collections.namedtuple(\\'Part\\', \\'ri ci\\')\\nSnake = collections.namedtuple(\\'Snake\\', \\'tail head\\')\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        def moves(tail, head):\\n            ok = 0 # it\\'s unblocked\\n            is_horiz = tail.ri == head.ri\\n            \\n            # currently horizontal\\n            if is_horiz and head.ci < N-1 and grid[head.ri][head.ci+1] == ok:\\n\\t\\t\\t  # move right\\n                yield Snake(Part(tail.ri, tail.ci+1), Part(head.ri, head.ci+1))\\n                \\n            #  currently horizontal, can move two ways\\n            if is_horiz and head.ri + 1 < N and grid[head.ri+1][head.ci] == ok and grid[tail.ri+1][tail.ci] == ok:\\n                # move down\\n                yield Snake(Part(tail.ri+1, tail.ci), Part(head.ri+1, head.ci)) \\n                # rotate clockwise\\n                yield Snake(tail, Part(tail.ri+1, tail.ci))\\n\\n            # currently vertical, can move two ways\\n            if not is_horiz and tail.ci + 1 < N and grid[tail.ri][tail.ci+1] == ok and grid[head.ri][head.ci+1] == ok:\\n                # move right\\n                yield Snake(Part(tail.ri, tail.ci+1), Part(head.ri, head.ci+1))\\n                # rotate counter-clockwise\\n                yield Snake(tail, Part(tail.ri, tail.ci+1))\\n                \\n            # currently vertical\\n            if not is_horiz and head.ri+1 < N and grid[head.ri+1][head.ci] == ok:\\n\\t\\t\\t\\t# move down\\n                yield Snake(Part(tail.ri+1, tail.ci), Part(head.ri+1, head.ci))\\n                    \\n            \\n            \\n        N = len(grid)\\n        visited = set()\\n        finish = Snake(Part(N-1, N-2), Part(N-1, N-1))\\n        snake = Snake(Part(0, 0), Part(0, 1))\\n        item = (snake, 0) # keep track of snake position and number of moves so far\\n        q = collections.deque([item])\\n        \\n        while q:\\n            snake, count = q.popleft()\\n            \\n            for snake2 in moves(*snake):\\n\\t\\t\\t\\t# early exit\\n                if snake2 == finish:\\n                    return count + 1\\n                \\n                if snake2 not in visited:\\n                    visited.add(snake2)\\n                    item = (snake2, count+1)\\n                    q.append(item)\\n                    \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nPart = collections.namedtuple(\\'Part\\', \\'ri ci\\')\\nSnake = collections.namedtuple(\\'Snake\\', \\'tail head\\')\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        def moves(tail, head):\\n            ok = 0 # it\\'s unblocked\\n            is_horiz = tail.ri == head.ri\\n            \\n            # currently horizontal\\n            if is_horiz and head.ci < N-1 and grid[head.ri][head.ci+1] == ok:\\n\\t\\t\\t  # move right\\n                yield Snake(Part(tail.ri, tail.ci+1), Part(head.ri, head.ci+1))\\n                \\n            #  currently horizontal, can move two ways\\n            if is_horiz and head.ri + 1 < N and grid[head.ri+1][head.ci] == ok and grid[tail.ri+1][tail.ci] == ok:\\n                # move down\\n                yield Snake(Part(tail.ri+1, tail.ci), Part(head.ri+1, head.ci)) \\n                # rotate clockwise\\n                yield Snake(tail, Part(tail.ri+1, tail.ci))\\n\\n            # currently vertical, can move two ways\\n            if not is_horiz and tail.ci + 1 < N and grid[tail.ri][tail.ci+1] == ok and grid[head.ri][head.ci+1] == ok:\\n                # move right\\n                yield Snake(Part(tail.ri, tail.ci+1), Part(head.ri, head.ci+1))\\n                # rotate counter-clockwise\\n                yield Snake(tail, Part(tail.ri, tail.ci+1))\\n                \\n            # currently vertical\\n            if not is_horiz and head.ri+1 < N and grid[head.ri+1][head.ci] == ok:\\n\\t\\t\\t\\t# move down\\n                yield Snake(Part(tail.ri+1, tail.ci), Part(head.ri+1, head.ci))\\n                    \\n            \\n            \\n        N = len(grid)\\n        visited = set()\\n        finish = Snake(Part(N-1, N-2), Part(N-1, N-1))\\n        snake = Snake(Part(0, 0), Part(0, 1))\\n        item = (snake, 0) # keep track of snake position and number of moves so far\\n        q = collections.deque([item])\\n        \\n        while q:\\n            snake, count = q.popleft()\\n            \\n            for snake2 in moves(*snake):\\n\\t\\t\\t\\t# early exit\\n                if snake2 == finish:\\n                    return count + 1\\n                \\n                if snake2 not in visited:\\n                    visited.add(snake2)\\n                    item = (snake2, count+1)\\n                    q.append(item)\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392975,
                "title": "simple-dijkstra-solution-c",
                "content": "Simple dijkstra Algorithm C++\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        map<pair<pair<int,int>,pair<int,int>>,int>vis;            //marks all visited states\\n        set<pair<int,pair<pair<int,int>,pair<int,int>>>>q;              // works as priority queue first element is cost \\n        q.insert({0,{{0,0},{0,1}}});\\n        while(!q.empty()){\\n            auto it=q.begin();\\n            int x1=it->second.first.first;\\n            int y1=it->second.first.second;\\n            int x2=it->second.second.first;\\n            int y2=it->second.second.second;\\n            int cost=it->first;\\n            if(x1==n-1 && y1==n-2 && x2==n-1 && y2==n-1){                 //goal found\\n                return cost;\\n            }\\n            if(vis[{{x1,y1},{x2,y2}}]==0){   //check if already visited\\n                if(y1+1<n && y2+1<n && grid[x1][y1+1]!=1 && grid[x2][y2+1]!=1){        //can go down\\n                    q.insert({cost+1,{{x1,y1+1},{x2,y2+1}}});\\n                }\\n                if(x1+1<n && x2+1<n && grid[x1+1][y1]!=1 && grid[x2+1][y2]!=1){        //can go right\\n                    q.insert({cost+1,{{x1+1,y1},{x2+1,y2}}});\\n                }\\n                if(x1==x2 && x1+1<n && y1+1<n && x2+1<n && y2-1>=0 && grid[x2+1][y2-1]!=1 && grid[x1+1][y1+1]!=1){    //can rotate clockwise\\n                    q.insert({cost+1,{{x1,y1},{x2+1,y2-1}}});\\n                }\\n                if(y1==y2 && x1+1<n && y1+1<n && x2-1>=0 && y2+1<n && grid[x2-1][y2+1]!=1 && grid[x1+1][y1+1]!=1){    //can rotate anticlockwise\\n                    q.insert({cost+1,{{x1,y1},{x2-1,y2+1}}});\\n                }\\n                vis[{{x1,y1},{x2,y2}}]=1;          //mark state as visited\\n            }\\n            q.erase(it);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        map<pair<pair<int,int>,pair<int,int>>,int>vis;            //marks all visited states\\n        set<pair<int,pair<pair<int,int>,pair<int,int>>>>q;              // works as priority queue first element is cost \\n        q.insert({0,{{0,0},{0,1}}});\\n        while(!q.empty()){\\n            auto it=q.begin();\\n            int x1=it->second.first.first;\\n            int y1=it->second.first.second;\\n            int x2=it->second.second.first;\\n            int y2=it->second.second.second;\\n            int cost=it->first;\\n            if(x1==n-1 && y1==n-2 && x2==n-1 && y2==n-1){                 //goal found\\n                return cost;\\n            }\\n            if(vis[{{x1,y1},{x2,y2}}]==0){   //check if already visited\\n                if(y1+1<n && y2+1<n && grid[x1][y1+1]!=1 && grid[x2][y2+1]!=1){        //can go down\\n                    q.insert({cost+1,{{x1,y1+1},{x2,y2+1}}});\\n                }\\n                if(x1+1<n && x2+1<n && grid[x1+1][y1]!=1 && grid[x2+1][y2]!=1){        //can go right\\n                    q.insert({cost+1,{{x1+1,y1},{x2+1,y2}}});\\n                }\\n                if(x1==x2 && x1+1<n && y1+1<n && x2+1<n && y2-1>=0 && grid[x2+1][y2-1]!=1 && grid[x1+1][y1+1]!=1){    //can rotate clockwise\\n                    q.insert({cost+1,{{x1,y1},{x2+1,y2-1}}});\\n                }\\n                if(y1==y2 && x1+1<n && y1+1<n && x2-1>=0 && y2+1<n && grid[x2-1][y2+1]!=1 && grid[x1+1][y1+1]!=1){    //can rotate anticlockwise\\n                    q.insert({cost+1,{{x1,y1},{x2-1,y2+1}}});\\n                }\\n                vis[{{x1,y1},{x2,y2}}]=1;          //mark state as visited\\n            }\\n            q.erase(it);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392885,
                "title": "not-sure-why-i-m-getting-this-found-my-mistake",
                "content": "Update:\\nFirst move of rotating is not allowed becasue (1,1) is not empty.  I didn\\'t read the rotation carefully.\\n\\n---\\nMy program says that the sname makes it to the end in 29 moves but the answer is -1.  When I tried check it out visual, it makes sense that the snake can make it to the end.  Could anyone help me with this test case? \\n```\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],\\n [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,0,0,0,0,0,0,0]]\\n \\n```\\n\\nI\\'ve attached my BFS search:\\n```\\n0\\n[0, 0, 0, 1]\\n1\\n[0, 0, 1, 0]\\n2\\n[1, 0, 2, 0]\\n3\\n[2, 0, 3, 0]\\n4\\n[3, 0, 4, 0]\\n5\\n[3, 1, 4, 1]\\n[4, 0, 5, 0]\\n[3, 0, 3, 1]\\n6\\n[3, 2, 4, 2]\\n[4, 1, 5, 1]\\n[3, 1, 3, 2]\\n[5, 0, 6, 0]\\n[4, 0, 4, 1]\\n7\\n[3, 3, 4, 3]\\n[4, 2, 5, 2]\\n[3, 2, 3, 3]\\n[5, 1, 6, 1]\\n[4, 1, 4, 2]\\n[6, 0, 7, 0]\\n[5, 0, 5, 1]\\n8\\n[3, 4, 4, 4]\\n[4, 3, 5, 3]\\n[3, 3, 3, 4]\\n[5, 2, 6, 2]\\n[4, 2, 4, 3]\\n[6, 1, 7, 1]\\n[5, 1, 5, 2]\\n[7, 0, 8, 0]\\n[6, 0, 6, 1]\\n9\\n[3, 5, 4, 5]\\n[4, 4, 5, 4]\\n[3, 4, 3, 5]\\n[5, 3, 6, 3]\\n[4, 3, 4, 4]\\n[6, 2, 7, 2]\\n[5, 2, 5, 3]\\n[7, 1, 8, 1]\\n[6, 1, 6, 2]\\n[8, 0, 9, 0]\\n[7, 0, 7, 1]\\n10\\n[4, 5, 5, 5]\\n[5, 4, 6, 4]\\n[4, 4, 4, 5]\\n[5, 3, 5, 4]\\n[7, 2, 8, 2]\\n[6, 2, 6, 3]\\n[8, 1, 9, 1]\\n[7, 1, 7, 2]\\n[9, 0, 10, 0]\\n[8, 0, 8, 1]\\n11\\n[5, 5, 6, 5]\\n[6, 4, 7, 4]\\n[5, 4, 5, 5]\\n[6, 3, 6, 4]\\n[8, 2, 9, 2]\\n[9, 1, 10, 1]\\n[8, 1, 8, 2]\\n[9, 0, 9, 1]\\n12\\n[5, 6, 6, 6]\\n[5, 5, 5, 6]\\n[6, 4, 6, 5]\\n[8, 3, 9, 3]\\n[9, 2, 10, 2]\\n[8, 2, 8, 3]\\n[10, 1, 11, 1]\\n[9, 1, 9, 2]\\n[10, 0, 10, 1]\\n13\\n[5, 7, 6, 7]\\n[6, 6, 7, 6]\\n[5, 6, 5, 7]\\n[6, 5, 6, 6]\\n[9, 2, 9, 3]\\n[11, 1, 12, 1]\\n[10, 1, 10, 2]\\n14\\n[5, 8, 6, 8]\\n[6, 7, 7, 7]\\n[5, 7, 5, 8]\\n[7, 6, 8, 6]\\n[6, 6, 6, 7]\\n[9, 3, 9, 4]\\n[12, 1, 13, 1]\\n15\\n[7, 7, 8, 7]\\n[6, 7, 6, 8]\\n[8, 6, 9, 6]\\n[7, 6, 7, 7]\\n[9, 4, 9, 5]\\n[12, 2, 13, 2]\\n[13, 1, 14, 1]\\n[12, 1, 12, 2]\\n16\\n[8, 7, 9, 7]\\n[6, 8, 6, 9]\\n[9, 6, 10, 6]\\n[8, 6, 8, 7]\\n[9, 5, 9, 6]\\n[10, 4, 10, 5]\\n[9, 4, 10, 4]\\n[12, 3, 13, 3]\\n[12, 2, 12, 3]\\n[13, 1, 13, 2]\\n17\\n[8, 8, 9, 8]\\n[9, 7, 10, 7]\\n[8, 7, 8, 8]\\n[6, 9, 6, 10]\\n[10, 6, 11, 6]\\n[9, 6, 9, 7]\\n[10, 5, 10, 6]\\n[9, 5, 10, 5]\\n[11, 4, 11, 5]\\n[10, 4, 11, 4]\\n[12, 4, 13, 4]\\n[13, 3, 14, 3]\\n[12, 3, 12, 4]\\n[13, 2, 13, 3]\\n18\\n[8, 9, 9, 9]\\n[9, 8, 10, 8]\\n[8, 8, 8, 9]\\n[10, 7, 11, 7]\\n[9, 7, 9, 8]\\n[6, 10, 6, 11]\\n[7, 9, 7, 10]\\n[6, 9, 7, 9]\\n[11, 6, 12, 6]\\n[10, 6, 10, 7]\\n[11, 5, 11, 6]\\n[10, 5, 11, 5]\\n[12, 4, 12, 5]\\n[11, 4, 12, 4]\\n[12, 5, 13, 5]\\n[13, 3, 13, 4]\\n19\\n[8, 10, 9, 10]\\n[9, 9, 10, 9]\\n[8, 9, 8, 10]\\n[10, 8, 11, 8]\\n[9, 8, 9, 9]\\n[11, 7, 12, 7]\\n[10, 7, 10, 8]\\n[6, 11, 6, 12]\\n[7, 10, 7, 11]\\n[6, 10, 7, 10]\\n[7, 9, 8, 9]\\n[11, 6, 11, 7]\\n[12, 5, 12, 6]\\n[11, 5, 12, 5]\\n[13, 4, 13, 5]\\n[13, 5, 14, 5]\\n20\\n[8, 11, 9, 11]\\n[9, 10, 10, 10]\\n[8, 10, 8, 11]\\n[10, 9, 11, 9]\\n[9, 9, 9, 10]\\n[11, 8, 12, 8]\\n[10, 8, 10, 9]\\n[12, 7, 13, 7]\\n[11, 7, 11, 8]\\n[6, 12, 6, 13]\\n[6, 11, 7, 11]\\n[7, 10, 8, 10]\\n[12, 6, 12, 7]\\n21\\n[8, 12, 9, 12]\\n[9, 11, 10, 11]\\n[8, 11, 8, 12]\\n[10, 10, 11, 10]\\n[9, 10, 9, 11]\\n[11, 9, 12, 9]\\n[10, 9, 10, 10]\\n[12, 8, 13, 8]\\n[11, 8, 11, 9]\\n[13, 7, 14, 7]\\n[12, 7, 12, 8]\\n[6, 13, 6, 14]\\n[7, 11, 8, 11]\\n22\\n[9, 12, 10, 12]\\n[10, 11, 11, 11]\\n[9, 11, 9, 12]\\n[11, 10, 12, 10]\\n[10, 10, 10, 11]\\n[12, 9, 13, 9]\\n[11, 9, 11, 10]\\n[13, 8, 14, 8]\\n[12, 8, 12, 9]\\n[13, 7, 13, 8]\\n[7, 13, 7, 14]\\n[6, 13, 7, 13]\\n23\\n[9, 13, 10, 13]\\n[10, 12, 11, 12]\\n[9, 12, 9, 13]\\n[11, 11, 12, 11]\\n[10, 11, 10, 12]\\n[11, 10, 11, 11]\\n[13, 9, 14, 9]\\n[12, 9, 12, 10]\\n[13, 8, 13, 9]\\n[14, 7, 14, 8]\\n[6, 14, 7, 14]\\n24\\n[9, 14, 10, 14]\\n[10, 13, 11, 13]\\n[9, 13, 9, 14]\\n[11, 12, 12, 12]\\n[10, 12, 10, 13]\\n[12, 11, 13, 11]\\n[11, 11, 11, 12]\\n[12, 10, 12, 11]\\n[14, 8, 14, 9]\\n[7, 14, 8, 14]\\n25\\n[10, 14, 11, 14]\\n[10, 13, 10, 14]\\n[12, 12, 13, 12]\\n[11, 12, 11, 13]\\n[13, 11, 14, 11]\\n[12, 11, 12, 12]\\n[14, 9, 14, 10]\\n[8, 14, 9, 14]\\n26\\n[11, 14, 12, 14]\\n[11, 13, 11, 14]\\n[13, 12, 14, 12]\\n[13, 11, 13, 12]\\n[14, 10, 14, 11]\\n27\\n[13, 13, 14, 13]\\n[13, 12, 13, 13]\\n[14, 11, 14, 12]\\n28\\n[14, 12, 14, 13]\\n29\\n[14, 13, 14, 14]\\n29\\n```",
                "solutionTags": [],
                "code": "```\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],\\n [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,0,0,0,0,0,0,0]]\\n \\n```\n```\\n0\\n[0, 0, 0, 1]\\n1\\n[0, 0, 1, 0]\\n2\\n[1, 0, 2, 0]\\n3\\n[2, 0, 3, 0]\\n4\\n[3, 0, 4, 0]\\n5\\n[3, 1, 4, 1]\\n[4, 0, 5, 0]\\n[3, 0, 3, 1]\\n6\\n[3, 2, 4, 2]\\n[4, 1, 5, 1]\\n[3, 1, 3, 2]\\n[5, 0, 6, 0]\\n[4, 0, 4, 1]\\n7\\n[3, 3, 4, 3]\\n[4, 2, 5, 2]\\n[3, 2, 3, 3]\\n[5, 1, 6, 1]\\n[4, 1, 4, 2]\\n[6, 0, 7, 0]\\n[5, 0, 5, 1]\\n8\\n[3, 4, 4, 4]\\n[4, 3, 5, 3]\\n[3, 3, 3, 4]\\n[5, 2, 6, 2]\\n[4, 2, 4, 3]\\n[6, 1, 7, 1]\\n[5, 1, 5, 2]\\n[7, 0, 8, 0]\\n[6, 0, 6, 1]\\n9\\n[3, 5, 4, 5]\\n[4, 4, 5, 4]\\n[3, 4, 3, 5]\\n[5, 3, 6, 3]\\n[4, 3, 4, 4]\\n[6, 2, 7, 2]\\n[5, 2, 5, 3]\\n[7, 1, 8, 1]\\n[6, 1, 6, 2]\\n[8, 0, 9, 0]\\n[7, 0, 7, 1]\\n10\\n[4, 5, 5, 5]\\n[5, 4, 6, 4]\\n[4, 4, 4, 5]\\n[5, 3, 5, 4]\\n[7, 2, 8, 2]\\n[6, 2, 6, 3]\\n[8, 1, 9, 1]\\n[7, 1, 7, 2]\\n[9, 0, 10, 0]\\n[8, 0, 8, 1]\\n11\\n[5, 5, 6, 5]\\n[6, 4, 7, 4]\\n[5, 4, 5, 5]\\n[6, 3, 6, 4]\\n[8, 2, 9, 2]\\n[9, 1, 10, 1]\\n[8, 1, 8, 2]\\n[9, 0, 9, 1]\\n12\\n[5, 6, 6, 6]\\n[5, 5, 5, 6]\\n[6, 4, 6, 5]\\n[8, 3, 9, 3]\\n[9, 2, 10, 2]\\n[8, 2, 8, 3]\\n[10, 1, 11, 1]\\n[9, 1, 9, 2]\\n[10, 0, 10, 1]\\n13\\n[5, 7, 6, 7]\\n[6, 6, 7, 6]\\n[5, 6, 5, 7]\\n[6, 5, 6, 6]\\n[9, 2, 9, 3]\\n[11, 1, 12, 1]\\n[10, 1, 10, 2]\\n14\\n[5, 8, 6, 8]\\n[6, 7, 7, 7]\\n[5, 7, 5, 8]\\n[7, 6, 8, 6]\\n[6, 6, 6, 7]\\n[9, 3, 9, 4]\\n[12, 1, 13, 1]\\n15\\n[7, 7, 8, 7]\\n[6, 7, 6, 8]\\n[8, 6, 9, 6]\\n[7, 6, 7, 7]\\n[9, 4, 9, 5]\\n[12, 2, 13, 2]\\n[13, 1, 14, 1]\\n[12, 1, 12, 2]\\n16\\n[8, 7, 9, 7]\\n[6, 8, 6, 9]\\n[9, 6, 10, 6]\\n[8, 6, 8, 7]\\n[9, 5, 9, 6]\\n[10, 4, 10, 5]\\n[9, 4, 10, 4]\\n[12, 3, 13, 3]\\n[12, 2, 12, 3]\\n[13, 1, 13, 2]\\n17\\n[8, 8, 9, 8]\\n[9, 7, 10, 7]\\n[8, 7, 8, 8]\\n[6, 9, 6, 10]\\n[10, 6, 11, 6]\\n[9, 6, 9, 7]\\n[10, 5, 10, 6]\\n[9, 5, 10, 5]\\n[11, 4, 11, 5]\\n[10, 4, 11, 4]\\n[12, 4, 13, 4]\\n[13, 3, 14, 3]\\n[12, 3, 12, 4]\\n[13, 2, 13, 3]\\n18\\n[8, 9, 9, 9]\\n[9, 8, 10, 8]\\n[8, 8, 8, 9]\\n[10, 7, 11, 7]\\n[9, 7, 9, 8]\\n[6, 10, 6, 11]\\n[7, 9, 7, 10]\\n[6, 9, 7, 9]\\n[11, 6, 12, 6]\\n[10, 6, 10, 7]\\n[11, 5, 11, 6]\\n[10, 5, 11, 5]\\n[12, 4, 12, 5]\\n[11, 4, 12, 4]\\n[12, 5, 13, 5]\\n[13, 3, 13, 4]\\n19\\n[8, 10, 9, 10]\\n[9, 9, 10, 9]\\n[8, 9, 8, 10]\\n[10, 8, 11, 8]\\n[9, 8, 9, 9]\\n[11, 7, 12, 7]\\n[10, 7, 10, 8]\\n[6, 11, 6, 12]\\n[7, 10, 7, 11]\\n[6, 10, 7, 10]\\n[7, 9, 8, 9]\\n[11, 6, 11, 7]\\n[12, 5, 12, 6]\\n[11, 5, 12, 5]\\n[13, 4, 13, 5]\\n[13, 5, 14, 5]\\n20\\n[8, 11, 9, 11]\\n[9, 10, 10, 10]\\n[8, 10, 8, 11]\\n[10, 9, 11, 9]\\n[9, 9, 9, 10]\\n[11, 8, 12, 8]\\n[10, 8, 10, 9]\\n[12, 7, 13, 7]\\n[11, 7, 11, 8]\\n[6, 12, 6, 13]\\n[6, 11, 7, 11]\\n[7, 10, 8, 10]\\n[12, 6, 12, 7]\\n21\\n[8, 12, 9, 12]\\n[9, 11, 10, 11]\\n[8, 11, 8, 12]\\n[10, 10, 11, 10]\\n[9, 10, 9, 11]\\n[11, 9, 12, 9]\\n[10, 9, 10, 10]\\n[12, 8, 13, 8]\\n[11, 8, 11, 9]\\n[13, 7, 14, 7]\\n[12, 7, 12, 8]\\n[6, 13, 6, 14]\\n[7, 11, 8, 11]\\n22\\n[9, 12, 10, 12]\\n[10, 11, 11, 11]\\n[9, 11, 9, 12]\\n[11, 10, 12, 10]\\n[10, 10, 10, 11]\\n[12, 9, 13, 9]\\n[11, 9, 11, 10]\\n[13, 8, 14, 8]\\n[12, 8, 12, 9]\\n[13, 7, 13, 8]\\n[7, 13, 7, 14]\\n[6, 13, 7, 13]\\n23\\n[9, 13, 10, 13]\\n[10, 12, 11, 12]\\n[9, 12, 9, 13]\\n[11, 11, 12, 11]\\n[10, 11, 10, 12]\\n[11, 10, 11, 11]\\n[13, 9, 14, 9]\\n[12, 9, 12, 10]\\n[13, 8, 13, 9]\\n[14, 7, 14, 8]\\n[6, 14, 7, 14]\\n24\\n[9, 14, 10, 14]\\n[10, 13, 11, 13]\\n[9, 13, 9, 14]\\n[11, 12, 12, 12]\\n[10, 12, 10, 13]\\n[12, 11, 13, 11]\\n[11, 11, 11, 12]\\n[12, 10, 12, 11]\\n[14, 8, 14, 9]\\n[7, 14, 8, 14]\\n25\\n[10, 14, 11, 14]\\n[10, 13, 10, 14]\\n[12, 12, 13, 12]\\n[11, 12, 11, 13]\\n[13, 11, 14, 11]\\n[12, 11, 12, 12]\\n[14, 9, 14, 10]\\n[8, 14, 9, 14]\\n26\\n[11, 14, 12, 14]\\n[11, 13, 11, 14]\\n[13, 12, 14, 12]\\n[13, 11, 13, 12]\\n[14, 10, 14, 11]\\n27\\n[13, 13, 14, 13]\\n[13, 12, 13, 13]\\n[14, 11, 14, 12]\\n28\\n[14, 12, 14, 13]\\n29\\n[14, 13, 14, 14]\\n29\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392828,
                "title": "java-bfs-solution",
                "content": "int[4] to record snake position\\nv1[][] record visited horizontal positions\\nv2[][] record visited vertical positions\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int ind = 0;\\n        int n = grid.length;\\n        int[][] v1 = new int[n][n];\\n        int[][] v2 = new int[n][n];\\n        if (grid[0][0] == 1 || grid[0][1] == 1) return -1;\\n        int[] s = new int[]{0, 0, 0, 1};\\n        Deque<int[]> queue = new ArrayDeque<>();\\n        queue.offerLast(s);\\n        while (queue.size() > 0) {\\n            ind++;\\n            System.out.println(ind);\\n            int k = queue.size();\\n            for (int i = 0; i < k; i++) {\\n                int[] temp = queue.pollFirst();\\n                if (temp[3] > temp[1]) {\\n                    if (temp[3] == n - 1 && temp[2] == n - 1) return ind - 1;\\n                    if ((temp[3] + 1 < n) && grid[temp[0]][temp[3] + 1] != 1) {\\n                        if (v1[temp[0]][temp[3]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[3], temp[0], temp[3] + 1});\\n                        v1[temp[0]][temp[3]] = 1;\\n                    }\\n                    if ((temp[0] + 1 < n) && grid[temp[0] + 1][temp[1]] != 1 && grid[temp[0] + 1][temp[3]] != 1) {\\n                        if (v2[temp[0]][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1], temp[0] + 1, temp[1]});\\n                        v2[temp[0]][temp[1]] = 1;\\n                    }\\n                    \\n                    if ((temp[0] + 1 < n) && grid[temp[0] + 1][temp[1]] != 1  && grid[temp[0] + 1][temp[3]] != 1) {\\n                        if (v1[temp[0] + 1][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0] + 1, temp[1], temp[0] + 1, temp[3]});\\n                        v1[temp[0] + 1][temp[1]] = 1;\\n                    }\\n                }\\n                else if (temp[2] > temp[0]) {\\n                    if ((temp[2] + 1 < n) && grid[temp[2] + 1][temp[1]] != 1) {\\n                        if (v2[temp[2]][temp[3]] != 1)\\n                        queue.offerLast(new int[]{temp[2], temp[3], temp[2] + 1, temp[3]});\\n                        v2[temp[2]][temp[3]] = 1;\\n                    }\\n                    \\n                    if ((temp[1] + 1 < n) && grid[temp[0]][temp[1] + 1] != 1 && grid[temp[2]][temp[1] + 1] != 1) {\\n                        if (v1[temp[0]][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1], temp[0], temp[1] + 1});\\n                        v1[temp[0]][temp[1]] = 1;\\n                    }\\n                    \\n                    if ((temp[1] + 1 < n) && grid[temp[0]][temp[1] + 1] != 1 && grid[temp[2]][temp[3] + 1] != 1) {\\n                        if (v2[temp[0]][temp[1] + 1] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1] + 1, temp[2], temp[3] + 1});\\n                        v2[temp[0]][temp[1] + 1] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int ind = 0;\\n        int n = grid.length;\\n        int[][] v1 = new int[n][n];\\n        int[][] v2 = new int[n][n];\\n        if (grid[0][0] == 1 || grid[0][1] == 1) return -1;\\n        int[] s = new int[]{0, 0, 0, 1};\\n        Deque<int[]> queue = new ArrayDeque<>();\\n        queue.offerLast(s);\\n        while (queue.size() > 0) {\\n            ind++;\\n            System.out.println(ind);\\n            int k = queue.size();\\n            for (int i = 0; i < k; i++) {\\n                int[] temp = queue.pollFirst();\\n                if (temp[3] > temp[1]) {\\n                    if (temp[3] == n - 1 && temp[2] == n - 1) return ind - 1;\\n                    if ((temp[3] + 1 < n) && grid[temp[0]][temp[3] + 1] != 1) {\\n                        if (v1[temp[0]][temp[3]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[3], temp[0], temp[3] + 1});\\n                        v1[temp[0]][temp[3]] = 1;\\n                    }\\n                    if ((temp[0] + 1 < n) && grid[temp[0] + 1][temp[1]] != 1 && grid[temp[0] + 1][temp[3]] != 1) {\\n                        if (v2[temp[0]][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1], temp[0] + 1, temp[1]});\\n                        v2[temp[0]][temp[1]] = 1;\\n                    }\\n                    \\n                    if ((temp[0] + 1 < n) && grid[temp[0] + 1][temp[1]] != 1  && grid[temp[0] + 1][temp[3]] != 1) {\\n                        if (v1[temp[0] + 1][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0] + 1, temp[1], temp[0] + 1, temp[3]});\\n                        v1[temp[0] + 1][temp[1]] = 1;\\n                    }\\n                }\\n                else if (temp[2] > temp[0]) {\\n                    if ((temp[2] + 1 < n) && grid[temp[2] + 1][temp[1]] != 1) {\\n                        if (v2[temp[2]][temp[3]] != 1)\\n                        queue.offerLast(new int[]{temp[2], temp[3], temp[2] + 1, temp[3]});\\n                        v2[temp[2]][temp[3]] = 1;\\n                    }\\n                    \\n                    if ((temp[1] + 1 < n) && grid[temp[0]][temp[1] + 1] != 1 && grid[temp[2]][temp[1] + 1] != 1) {\\n                        if (v1[temp[0]][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1], temp[0], temp[1] + 1});\\n                        v1[temp[0]][temp[1]] = 1;\\n                    }\\n                    \\n                    if ((temp[1] + 1 < n) && grid[temp[0]][temp[1] + 1] != 1 && grid[temp[2]][temp[3] + 1] != 1) {\\n                        if (v2[temp[0]][temp[1] + 1] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1] + 1, temp[2], temp[3] + 1});\\n                        v2[temp[0]][temp[1] + 1] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023595,
                "title": "best-solution-bfs-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n^2)$$ \\n\\n```\\nTerminology used in Code :-\\ntr    -> tailRow\\ntc    -> tailCol\\nhr    -> headRow\\nhc    -> headCol\\nnewTr -> new tailRow\\nnewTc -> new tailCol\\nnewHr -> new headRow\\nnewHc -> new headCol\\n```\\n# Code\\n```\\nclass Solution {\\n   bool isValid(int tr, int tc, int hr, int hc, vector<vector<int>>& grid)\\n   {\\n      int n = grid.size();\\n      return tr < n && tc < n && hr < n && hc < n && grid[tr][tc] == 0 && grid[hr][hc] == 0;\\n   }\\n public:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        unordered_map<string,bool> vis;\\n        int n = grid.size(), moves = 0;\\n        queue<vector<int>> q;\\n\\n        q.push({0,0,1});\\n        while(!q.empty())\\n        {\\n           int size = q.size();\\n           while(size--)\\n           {\\n               auto curr = q.front(); \\n                q.pop();\\n\\n              int tr = curr[0], tc = curr[1], isHorizontal = curr[2], hr, hc;\\n              string state = to_string(tr) + \\'$\\' + to_string(tc) + \\'$\\' + to_string(isHorizontal);\\n              if(vis[state]) continue; //do not visit already visited states\\n              vis[state] = true;\\n\\n              if(tr == n-1 && tc == n-2 && isHorizontal) //termination condition\\n               return moves;\\n\\n               int newTr,newTc,newHr,newHc;\\n                if(isHorizontal == 1)\\n                {\\n                //CASE 1: move right\\n                newTr = tr, newTc = tc, newHr = tr, newHc = tc + 2;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                  q.push({tr,tc+1,1}); \\n\\n                //CASE 2: move down \\n                newTr = tr+1, newTc = tc, newHr = tr+1, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr+1,tc,1});\\n\\n                //CASE 3: rotate clock-wiae\\n                newTr = tr, newTc = tc, newHr = tr+1, newHc = tc;\\n                if(isValid(newTr,newTc,newHr,newHc,grid) && grid[tr+1][tc+1] == 0) \\n                   q.push({tr,tc,0}); \\n                }\\n               else\\n               {//CASE 1: move right\\n                newTr = tr, newTc = tc+1, newHr = tr+1, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr,tc+1,0}); \\n\\n                //CASE 2: move down\\n                newTr = tr+1, newTc = tc, newHr = tr+2, newHc = tc;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr+1,tc,0}); \\n\\n                //CASE 3: move anti clock-wise\\n                newTr = tr, newTc = tc, newHr = tr, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid) && grid[tr+1][tc+1] == 0)  \\n                   q.push({tr,tc,1});  \\n               }    \\n            }\\n         moves++;\\n        }\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nTerminology used in Code :-\\ntr    -> tailRow\\ntc    -> tailCol\\nhr    -> headRow\\nhc    -> headCol\\nnewTr -> new tailRow\\nnewTc -> new tailCol\\nnewHr -> new headRow\\nnewHc -> new headCol\\n```\n```\\nclass Solution {\\n   bool isValid(int tr, int tc, int hr, int hc, vector<vector<int>>& grid)\\n   {\\n      int n = grid.size();\\n      return tr < n && tc < n && hr < n && hc < n && grid[tr][tc] == 0 && grid[hr][hc] == 0;\\n   }\\n public:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        unordered_map<string,bool> vis;\\n        int n = grid.size(), moves = 0;\\n        queue<vector<int>> q;\\n\\n        q.push({0,0,1});\\n        while(!q.empty())\\n        {\\n           int size = q.size();\\n           while(size--)\\n           {\\n               auto curr = q.front(); \\n                q.pop();\\n\\n              int tr = curr[0], tc = curr[1], isHorizontal = curr[2], hr, hc;\\n              string state = to_string(tr) + \\'$\\' + to_string(tc) + \\'$\\' + to_string(isHorizontal);\\n              if(vis[state]) continue; //do not visit already visited states\\n              vis[state] = true;\\n\\n              if(tr == n-1 && tc == n-2 && isHorizontal) //termination condition\\n               return moves;\\n\\n               int newTr,newTc,newHr,newHc;\\n                if(isHorizontal == 1)\\n                {\\n                //CASE 1: move right\\n                newTr = tr, newTc = tc, newHr = tr, newHc = tc + 2;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                  q.push({tr,tc+1,1}); \\n\\n                //CASE 2: move down \\n                newTr = tr+1, newTc = tc, newHr = tr+1, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr+1,tc,1});\\n\\n                //CASE 3: rotate clock-wiae\\n                newTr = tr, newTc = tc, newHr = tr+1, newHc = tc;\\n                if(isValid(newTr,newTc,newHr,newHc,grid) && grid[tr+1][tc+1] == 0) \\n                   q.push({tr,tc,0}); \\n                }\\n               else\\n               {//CASE 1: move right\\n                newTr = tr, newTc = tc+1, newHr = tr+1, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr,tc+1,0}); \\n\\n                //CASE 2: move down\\n                newTr = tr+1, newTc = tc, newHr = tr+2, newHc = tc;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr+1,tc,0}); \\n\\n                //CASE 3: move anti clock-wise\\n                newTr = tr, newTc = tc, newHr = tr, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid) && grid[tr+1][tc+1] == 0)  \\n                   q.push({tr,tc,1});  \\n               }    \\n            }\\n         moves++;\\n        }\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974560,
                "title": "3d-dp-solution-python",
                "content": "# Intuition\\n    please use bfs approach,my solution works but not optimize.\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def check(self,dp,grid,i,j,k,n):\\n        if(i==n-1 and j==n-1 and k==0):return 0\\n        if(min(i,j)<0 or max(i,j)>=n or grid[i][j]==1 or grid[i][j]==-1):return n*n\\n        # print(i,j,k,dp[i][j][k],\"------\")\\n        if(dp[i][j][k]!=-1):return dp[i][j][k]\\n        ans=n*n\\n        pre=grid[i][j]\\n        grid[i][j]=-1\\n        if(k==0):\\n            if(i+1<n and grid[i+1][j-1]!=1 and grid[i+1][j]!=1):\\n                ans=min(ans,self.check(dp,grid,i+1,j,k,n)+1)\\n                ans=min(ans,self.check(dp,grid,i+1,j-1,k^1,n)+1)\\n            ans=min(ans,self.check(dp,grid,i,j+1,k,n)+1)\\n        else:\\n            ans=min(ans,self.check(dp,grid,i+1,j,k,n)+1)\\n            if(j+1<n and grid[i-1][j+1]!=1 and  grid[i][j+1]!=1):\\n                ans=min(ans,self.check(dp,grid,i,j+1,k,n)+1)\\n                ans=min(ans,self.check(dp,grid,i-1,j+1,k^1,n)+1)\\n        dp[i][j][k]=ans\\n        grid[i][j]=pre\\n        # print(i,j,k,dp[i][j][k])\\n        return dp[i][j][k]\\n\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        dp=[[[-1 for k in range(2)] for i in range(n)] for j in range(n)]\\n        ans=self.check(dp,grid,0,1,0,n)\\n        if(ans>=n*n):return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n\\n    def check(self,dp,grid,i,j,k,n):\\n        if(i==n-1 and j==n-1 and k==0):return 0\\n        if(min(i,j)<0 or max(i,j)>=n or grid[i][j]==1 or grid[i][j]==-1):return n*n\\n        # print(i,j,k,dp[i][j][k],\"------\")\\n        if(dp[i][j][k]!=-1):return dp[i][j][k]\\n        ans=n*n\\n        pre=grid[i][j]\\n        grid[i][j]=-1\\n        if(k==0):\\n            if(i+1<n and grid[i+1][j-1]!=1 and grid[i+1][j]!=1):\\n                ans=min(ans,self.check(dp,grid,i+1,j,k,n)+1)\\n                ans=min(ans,self.check(dp,grid,i+1,j-1,k^1,n)+1)\\n            ans=min(ans,self.check(dp,grid,i,j+1,k,n)+1)\\n        else:\\n            ans=min(ans,self.check(dp,grid,i+1,j,k,n)+1)\\n            if(j+1<n and grid[i-1][j+1]!=1 and  grid[i][j+1]!=1):\\n                ans=min(ans,self.check(dp,grid,i,j+1,k,n)+1)\\n                ans=min(ans,self.check(dp,grid,i-1,j+1,k^1,n)+1)\\n        dp[i][j][k]=ans\\n        grid[i][j]=pre\\n        # print(i,j,k,dp[i][j][k])\\n        return dp[i][j][k]\\n\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        dp=[[[-1 for k in range(2)] for i in range(n)] for j in range(n)]\\n        ans=self.check(dp,grid,0,1,0,n)\\n        if(ans>=n*n):return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925656,
                "title": "c-dfs-memo-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s *generally* better to use BFS for search problems like this. However, given the constraints for this problem, DFS+memo is more than adequate; in fact it is both simpler and faster.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS with two 2D arrays for memoization: `hmemo` for when we\\'re horizontal, and `vmemo` for when we\\'re vertical. While we\\'re running DFS on a point, we can set its memo to `INT_MAX-1` so the code will short-circuit if we attempt anything that could cause a cycle. I also return `INT_MAX-1` if the target is unreachable. (`INT_MAX-1` avoids overflow when doing `1+dfs(...)`).\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, 17ms beats 100% apparently!\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> hmemo, vmemo;\\n    vector<vector<int>> *gridp;\\n\\n    int dfs(bool h, int r, int c) {\\n        vector<vector<int>> & grid = *gridp;\\n        if (h && r == n-1 && c == n-2)\\n            return 0;\\n        int res = INT_MAX-1;\\n        if (h) {\\n            if (hmemo[r][c] > 0) {\\n                return hmemo[r][c];\\n            }\\n            hmemo[r][c] = INT_MAX-1;\\n            if (c+2 < n && grid[r][c+2] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(true, r, c+1));\\n            }\\n            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(true, r+1, c));\\n                // rotate clockwise\\n                res = min(res, 1+dfs(false, r, c));\\n            }\\n            hmemo[r][c] = res;\\n            return res;\\n        } else {\\n            if (vmemo[r][c] > 0) {\\n                return vmemo[r][c];\\n            }\\n            vmemo[r][c] = INT_MAX-1;\\n            if (r+2 < n && grid[r+2][c] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(false, r+1, c));\\n            }\\n            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(false, r, c+1));\\n                // rotate counterclockwise\\n                res = min(res, 1+dfs(true, r, c));\\n            }\\n            vmemo[r][c] = res;\\n            return res;\\n        }\\n    }\\n\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        this->gridp = &grid;\\n        n = grid.size();\\n        hmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        vmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        int res = dfs(true, 0, 0);\\n        return res < INT_MAX-1 ? res : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> hmemo, vmemo;\\n    vector<vector<int>> *gridp;\\n\\n    int dfs(bool h, int r, int c) {\\n        vector<vector<int>> & grid = *gridp;\\n        if (h && r == n-1 && c == n-2)\\n            return 0;\\n        int res = INT_MAX-1;\\n        if (h) {\\n            if (hmemo[r][c] > 0) {\\n                return hmemo[r][c];\\n            }\\n            hmemo[r][c] = INT_MAX-1;\\n            if (c+2 < n && grid[r][c+2] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(true, r, c+1));\\n            }\\n            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(true, r+1, c));\\n                // rotate clockwise\\n                res = min(res, 1+dfs(false, r, c));\\n            }\\n            hmemo[r][c] = res;\\n            return res;\\n        } else {\\n            if (vmemo[r][c] > 0) {\\n                return vmemo[r][c];\\n            }\\n            vmemo[r][c] = INT_MAX-1;\\n            if (r+2 < n && grid[r+2][c] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(false, r+1, c));\\n            }\\n            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(false, r, c+1));\\n                // rotate counterclockwise\\n                res = min(res, 1+dfs(true, r, c));\\n            }\\n            vmemo[r][c] = res;\\n            return res;\\n        }\\n    }\\n\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        this->gridp = &grid;\\n        n = grid.size();\\n        hmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        vmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        int res = dfs(true, 0, 0);\\n        return res < INT_MAX-1 ? res : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735145,
                "title": "super-fast-and-readable-python-solution-using-breadth-first-search",
                "content": "# Intuition\\nThis looks like a variation of the basic path planning problem where we must navigate a grid with obstacles. These are classically solved with breadth first search BFS as BFS reveals the shortest path to a node the very first time you reach it.\\n\\nThe twist here is that we have a snake that takes up two squares instead of the usual one. This slightly complicates the graph representation of the problem.\\n\\n# Approach\\nWe create a graph as follows:\\n* A vertex V is a triple of the form (row, column, orientation) where orientation is 0 if the snake is horizontal and 1 if the snake is vertical. As an example (3, 5, 0) means that the snake is taking up grid positions (3, 5) and (3, 6) and (3, 5, 1) means that the snake is taking up grid positions (3, 5) and (4, 5).\\n* A directed edge exists between two vertices V1 and V2 if it is possible to go from V1 to V2 with a single move (right, down, clockwise rotation, or counter-clockwise rotation).\\n* The resulting graph G can be more easily represented by its two subgraphs GH and GV with each consisting of horizontally- and vertically-oriented vertices. We create two matrices Hnodes and Vnodes to store the minimum distance to each node. A sentinel value of infinity (inf) is used to represent nodes that have not been reached yet. If a node remains infinity after the algorithm terminates, then it is unreachable via the allowed moves.\\n* Now apply a BFS traversal of G using a queue.\\n\\nNote that as of this writing, this solution was the fastest running submission and also the submission using the least memory.\\n\\n\\n# Complexity\\n- Time complexity:\\n$O(n^2)$ where $n$ is the length of the side of the square grid. Note that general BFS can be much slower, especially for densely connected graphs; however, we take advantage of the fact the local connectedness topology.\\n\\n- Space complexity:\\n$O(n^2)$ from the matrices we used to store distances.\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        inf = 10000\\n        N = len(grid)\\n        Hnodes = [[inf for col in range(N-1)] for row in range(N)]\\n        Vnodes = [[inf for col in range(N)] for row in range(N-1)]\\n        nodeQueue = deque()\\n\\n        # Starting position\\n        Hnodes[0][0] = 0\\n        nodeQueue.append((0, 0, 0)) # row, col, orientation\\n\\n        while len(nodeQueue) > 0:\\n            node = nodeQueue.popleft()\\n            row = node[0]\\n            col = node[1]\\n            orientation = node[2]\\n            # horizontal case\\n            if orientation == 0:\\n                minMoves = Hnodes[row][col]\\n                # move right case\\n                if col + 2 < N and grid[row][col + 2] == 0 and Hnodes[row][col + 1] == inf:\\n                    Hnodes[row][col + 1] = minMoves + 1\\n                    nodeQueue.append((row, col + 1, 0))\\n                # move down case or rotate clockwise case\\n                if row + 1 < N and grid[row + 1][col] == 0 and grid[row + 1][col + 1] == 0:\\n                    # move down\\n                    if Hnodes[row + 1][col] == inf:\\n                        Hnodes[row + 1][col] = minMoves + 1\\n                        nodeQueue.append((row + 1, col, 0))\\n                    # rotate clockwise\\n                    if Vnodes[row][col] == inf:\\n                        Vnodes[row][col] = minMoves + 1\\n                        nodeQueue.append((row, col, 1))\\n            # vertical case\\n            else:\\n                minMoves = Vnodes[row][col]\\n                # move down case\\n                if row + 2 < N and grid[row + 2][col] == 0 and Vnodes[row + 1][col] == inf:\\n                    Vnodes[row + 1][col] = minMoves + 1\\n                    nodeQueue.append((row + 1, col, 1))\\n                # move right or rotate counter clockwise case\\n                if col + 1 < N and grid[row][col + 1] == 0 and grid[row + 1][col + 1] == 0:\\n                    # move right\\n                    if Vnodes[row][col + 1] == inf:\\n                        Vnodes[row][col + 1] = minMoves + 1\\n                        nodeQueue.append((row, col + 1, 1))\\n                    # rotate counter clockwise\\n                    if Hnodes[row][col] == inf:\\n                        Hnodes[row][col] = minMoves + 1\\n                        nodeQueue.append((row, col, 0))\\n\\n        minDist = Hnodes[N - 1][N - 2]\\n        return minDist if minDist < inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        inf = 10000\\n        N = len(grid)\\n        Hnodes = [[inf for col in range(N-1)] for row in range(N)]\\n        Vnodes = [[inf for col in range(N)] for row in range(N-1)]\\n        nodeQueue = deque()\\n\\n        # Starting position\\n        Hnodes[0][0] = 0\\n        nodeQueue.append((0, 0, 0)) # row, col, orientation\\n\\n        while len(nodeQueue) > 0:\\n            node = nodeQueue.popleft()\\n            row = node[0]\\n            col = node[1]\\n            orientation = node[2]\\n            # horizontal case\\n            if orientation == 0:\\n                minMoves = Hnodes[row][col]\\n                # move right case\\n                if col + 2 < N and grid[row][col + 2] == 0 and Hnodes[row][col + 1] == inf:\\n                    Hnodes[row][col + 1] = minMoves + 1\\n                    nodeQueue.append((row, col + 1, 0))\\n                # move down case or rotate clockwise case\\n                if row + 1 < N and grid[row + 1][col] == 0 and grid[row + 1][col + 1] == 0:\\n                    # move down\\n                    if Hnodes[row + 1][col] == inf:\\n                        Hnodes[row + 1][col] = minMoves + 1\\n                        nodeQueue.append((row + 1, col, 0))\\n                    # rotate clockwise\\n                    if Vnodes[row][col] == inf:\\n                        Vnodes[row][col] = minMoves + 1\\n                        nodeQueue.append((row, col, 1))\\n            # vertical case\\n            else:\\n                minMoves = Vnodes[row][col]\\n                # move down case\\n                if row + 2 < N and grid[row + 2][col] == 0 and Vnodes[row + 1][col] == inf:\\n                    Vnodes[row + 1][col] = minMoves + 1\\n                    nodeQueue.append((row + 1, col, 1))\\n                # move right or rotate counter clockwise case\\n                if col + 1 < N and grid[row][col + 1] == 0 and grid[row + 1][col + 1] == 0:\\n                    # move right\\n                    if Vnodes[row][col + 1] == inf:\\n                        Vnodes[row][col + 1] = minMoves + 1\\n                        nodeQueue.append((row, col + 1, 1))\\n                    # rotate counter clockwise\\n                    if Hnodes[row][col] == inf:\\n                        Hnodes[row][col] = minMoves + 1\\n                        nodeQueue.append((row, col, 0))\\n\\n        minDist = Hnodes[N - 1][N - 2]\\n        return minDist if minDist < inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686930,
                "title": "very-simple-solution-using-bfs-in-c",
                "content": "# Intuition\\n  The problem is really easy if you can walk yourself through example test case 1 and example test case 2. Just follow how you can travel right, right, counter clockwise like the way example explains, and you will understand the problem.\\n\\n# Approach\\n Breadth first search\\n\\n# Complexity\\n- Time complexity:\\n  O(NxM)\\n\\n- Space complexity:\\n  O(NxM)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumMoves(int[][] grid) {\\n        //the problem is easy if we can understand how\\n        //the snakes position changes in each//\\n        //right, down, and rotate moves\\n        int n = grid.Length;\\n        Queue<(int r1, int c1, int r2, int c2, int move)> q = \\n        new Queue<(int,int,int,int,int)>();\\n        q.Enqueue((0,0,0,1,0));\\n        HashSet<string> map = new HashSet<string>();\\n        while(q.Count > 0){\\n            int r1 = q.Peek().r1;\\n            int c1 = q.Peek().c1;\\n            int r2 = q.Peek().r2;\\n            int c2 = q.Peek().c2;\\n            int move = q.Peek().move;\\n            if(r1 == n-1 && c1 == n-2 && r2 ==n-1 && c2 == n-1) {\\n                return move;\\n            }\\n\\n            q.Dequeue();\\n            string key = \"R1C1-\"+r1+\"-\"+c1+\"-R2C2-\"+r2+\"-\"+c2;\\n            if(map.Contains(key)) continue;\\n            map.Add(key);\\n            //when snake is flat or in right position\\n            if(r1 == r2){\\n                if(c2+1 < n && c1+1 < n &&  grid[r1][c1+1]== 0 &&grid[r2][c2+1] == 0){\\n                    q.Enqueue((r1,c1+1,r2, c2+1,move+1));\\n                }\\n                //check down position\\n                if(r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0){\\n                    q.Enqueue((r1+1, c1, r2+1, c2, move+1));\\n                    //we can also do rotate clockwise - intuition careful observation from example 1 test case\\n                    q.Enqueue((r1, c1, r2+1, c1, move+1));\\n                }\\n            }\\n            //when snake is in vertical position\\n            if(c1 == c2){\\n                if(c2+1 < n && c1+1 < n &&  grid[r1][c1+1]== 0 && grid[r2][c2+1] == 0){\\n                    q.Enqueue((r1,c1+1,r2, c2+1,move+1));\\n                    //this is rotate counter clockwise\\n                    q.Enqueue((r1,c1, r1, c2+1,move+1));\\n                }\\n                //check down position\\n                if(r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0){\\n                    q.Enqueue((r1+1, c1, r2+1, c2, move+1));\\n                }                \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumMoves(int[][] grid) {\\n        //the problem is easy if we can understand how\\n        //the snakes position changes in each//\\n        //right, down, and rotate moves\\n        int n = grid.Length;\\n        Queue<(int r1, int c1, int r2, int c2, int move)> q = \\n        new Queue<(int,int,int,int,int)>();\\n        q.Enqueue((0,0,0,1,0));\\n        HashSet<string> map = new HashSet<string>();\\n        while(q.Count > 0){\\n            int r1 = q.Peek().r1;\\n            int c1 = q.Peek().c1;\\n            int r2 = q.Peek().r2;\\n            int c2 = q.Peek().c2;\\n            int move = q.Peek().move;\\n            if(r1 == n-1 && c1 == n-2 && r2 ==n-1 && c2 == n-1) {\\n                return move;\\n            }\\n\\n            q.Dequeue();\\n            string key = \"R1C1-\"+r1+\"-\"+c1+\"-R2C2-\"+r2+\"-\"+c2;\\n            if(map.Contains(key)) continue;\\n            map.Add(key);\\n            //when snake is flat or in right position\\n            if(r1 == r2){\\n                if(c2+1 < n && c1+1 < n &&  grid[r1][c1+1]== 0 &&grid[r2][c2+1] == 0){\\n                    q.Enqueue((r1,c1+1,r2, c2+1,move+1));\\n                }\\n                //check down position\\n                if(r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0){\\n                    q.Enqueue((r1+1, c1, r2+1, c2, move+1));\\n                    //we can also do rotate clockwise - intuition careful observation from example 1 test case\\n                    q.Enqueue((r1, c1, r2+1, c1, move+1));\\n                }\\n            }\\n            //when snake is in vertical position\\n            if(c1 == c2){\\n                if(c2+1 < n && c1+1 < n &&  grid[r1][c1+1]== 0 && grid[r2][c2+1] == 0){\\n                    q.Enqueue((r1,c1+1,r2, c2+1,move+1));\\n                    //this is rotate counter clockwise\\n                    q.Enqueue((r1,c1, r1, c2+1,move+1));\\n                }\\n                //check down position\\n                if(r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0){\\n                    q.Enqueue((r1+1, c1, r2+1, c2, move+1));\\n                }                \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513592,
                "title": "c-simple-bfs",
                "content": "# Approach\\nUsual BFS where graph vertices are described by the following struct\\n```\\nstruct Position {\\n    vector<int> a; //tail of the snake\\n    vector<int> b; //head\\n}\\n``` \\nTo keep track of visited vertices, use a hash function.\\n\\n# Complexity\\n- Time complexity: $$O(nm)$$\\n\\n- Space complexity: $$O(nm)$$\\n\\n# Code\\n```\\nusing lli = long long int;\\nconst lli base = 101;\\nconst lli mod = 1e9+7;\\n\\nstruct Position {\\n    vector<int> a;\\n    vector<int> b;\\n};\\n\\nbool ver(Position& pos) {\\n    return (pos.b[0]-pos.a[0] == 1);\\n}\\n\\nbool hor(Position& pos) {\\n    return (pos.b[1]-pos.a[1] == 1);\\n}\\n\\nlli myhash(Position& pos) {\\n    lli k = 1;\\n    lli h = 0;\\n    for (int x : pos.a) {\\n        h = (h + k*((lli)x))%mod;\\n        k = (k*base)%mod;\\n    }\\n    for (int x : pos.b) {\\n        h = (h + k*((lli)x))%mod;\\n        k = (k*base)%mod;\\n    }\\n    return h; \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        function<vector<Position>(Position&)> neighbors = [&](Position& pos) -> vector<Position> {\\n            vector<Position> res;\\n            Position down = pos;\\n            down.a[0]++;\\n            down.b[0]++;\\n            if (down.a[0] < m && down.b[0] < m && grid[down.a[0]][down.a[1]] == 0 && grid[down.b[0]][down.b[1]] == 0) {\\n                res.push_back(down);\\n                if (hor(pos)) res.push_back({pos.a, {pos.a[0]+1, pos.a[1]}}); \\n            }\\n            Position right = pos;\\n            right.a[1]++;\\n            right.b[1]++; \\n            if (right.a[1] < n && right.b[1] < n && grid[right.a[0]][right.a[1]] == 0 && grid[right.b[0]][right.b[1]] == 0) {\\n                res.push_back(right);\\n                if (ver(pos)) res.push_back({pos.a, {pos.a[0], pos.a[1]+1}}); \\n            }\\n            return res;\\n        };\\n        unordered_map<lli,int> dist;\\n        deque<Position> q(1, {{0,0},{0,1}});\\n        dist[myhash(q[0])] = 0; \\n        while(!q.empty()) {\\n            Position pos = q[0];\\n            lli curh = myhash(q[0]); \\n            q.pop_front();\\n            vector<Position> ngh = neighbors(pos);\\n            for (Position& nxt : ngh) {\\n                lli h = myhash(nxt);\\n                if (dist.find(h) == dist.end()) {\\n                    dist[h] = dist[curh]+1;\\n                    q.push_back(nxt); \\n                }\\n            }\\n        }\\n        Position t = {{n-1, n-2}, {n-1, n-1}}; \\n        lli th = myhash(t);\\n        if (dist.find(th) == dist.end()) return -1;\\n        return dist[th]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Position {\\n    vector<int> a; //tail of the snake\\n    vector<int> b; //head\\n}\\n```\n```\\nusing lli = long long int;\\nconst lli base = 101;\\nconst lli mod = 1e9+7;\\n\\nstruct Position {\\n    vector<int> a;\\n    vector<int> b;\\n};\\n\\nbool ver(Position& pos) {\\n    return (pos.b[0]-pos.a[0] == 1);\\n}\\n\\nbool hor(Position& pos) {\\n    return (pos.b[1]-pos.a[1] == 1);\\n}\\n\\nlli myhash(Position& pos) {\\n    lli k = 1;\\n    lli h = 0;\\n    for (int x : pos.a) {\\n        h = (h + k*((lli)x))%mod;\\n        k = (k*base)%mod;\\n    }\\n    for (int x : pos.b) {\\n        h = (h + k*((lli)x))%mod;\\n        k = (k*base)%mod;\\n    }\\n    return h; \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        function<vector<Position>(Position&)> neighbors = [&](Position& pos) -> vector<Position> {\\n            vector<Position> res;\\n            Position down = pos;\\n            down.a[0]++;\\n            down.b[0]++;\\n            if (down.a[0] < m && down.b[0] < m && grid[down.a[0]][down.a[1]] == 0 && grid[down.b[0]][down.b[1]] == 0) {\\n                res.push_back(down);\\n                if (hor(pos)) res.push_back({pos.a, {pos.a[0]+1, pos.a[1]}}); \\n            }\\n            Position right = pos;\\n            right.a[1]++;\\n            right.b[1]++; \\n            if (right.a[1] < n && right.b[1] < n && grid[right.a[0]][right.a[1]] == 0 && grid[right.b[0]][right.b[1]] == 0) {\\n                res.push_back(right);\\n                if (ver(pos)) res.push_back({pos.a, {pos.a[0], pos.a[1]+1}}); \\n            }\\n            return res;\\n        };\\n        unordered_map<lli,int> dist;\\n        deque<Position> q(1, {{0,0},{0,1}});\\n        dist[myhash(q[0])] = 0; \\n        while(!q.empty()) {\\n            Position pos = q[0];\\n            lli curh = myhash(q[0]); \\n            q.pop_front();\\n            vector<Position> ngh = neighbors(pos);\\n            for (Position& nxt : ngh) {\\n                lli h = myhash(nxt);\\n                if (dist.find(h) == dist.end()) {\\n                    dist[h] = dist[curh]+1;\\n                    q.push_back(nxt); \\n                }\\n            }\\n        }\\n        Position t = {{n-1, n-2}, {n-1, n-1}}; \\n        lli th = myhash(t);\\n        if (dist.find(th) == dist.end()) return -1;\\n        return dist[th]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452663,
                "title": "easy-to-understand-faster-simple-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, I, DP = len(G)-1, math.inf, [[math.inf]*2 for i in range(len(G)+1)]\\n    \\tDP[N-1][0] = I if 1 in [G[N][N],G[N][N-1]] else 0\\n    \\tfor j in range(N-2,-1,-1): DP[j][0] = (DP[j+1][0] + 1) if G[N][j] == 0 else I\\n    \\tfor i,j in itertools.product(range(N-1,-1,-1),range(N,-1,-1)):\\n    \\t\\tn = [G[i][j],G[i][min(j+1,N)],G[min(i+1,N)][j],G[min(i+1,N)][min(j+1,N)]]\\n    \\t\\tDP[j][0], DP[j][1] = min(1+DP[j+1][0],1+DP[j][0]), min(1+DP[j+1][1],1+DP[j][1])\\n    \\t\\tif 1 not in n: DP[j][0], DP[j][1] = min(DP[j][0],2+DP[j+1][1],1+DP[j][1]), min(DP[j][1],2+DP[j+1][0],1+DP[j][0])\\n    \\t\\tif 1 in [n[0],n[1]]: DP[j][0] = I\\n    \\t\\tif 1 in [n[0],n[2]]: DP[j][1] = I\\n    \\treturn -1 if DP[0][0] == I else DP[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, I, DP = len(G)-1, math.inf, [[math.inf]*2 for i in range(len(G)+1)]\\n    \\tDP[N-1][0] = I if 1 in [G[N][N],G[N][N-1]] else 0\\n    \\tfor j in range(N-2,-1,-1): DP[j][0] = (DP[j+1][0] + 1) if G[N][j] == 0 else I\\n    \\tfor i,j in itertools.product(range(N-1,-1,-1),range(N,-1,-1)):\\n    \\t\\tn = [G[i][j],G[i][min(j+1,N)],G[min(i+1,N)][j],G[min(i+1,N)][min(j+1,N)]]\\n    \\t\\tDP[j][0], DP[j][1] = min(1+DP[j+1][0],1+DP[j][0]), min(1+DP[j+1][1],1+DP[j][1])\\n    \\t\\tif 1 not in n: DP[j][0], DP[j][1] = min(DP[j][0],2+DP[j+1][1],1+DP[j][1]), min(DP[j][1],2+DP[j+1][0],1+DP[j][0])\\n    \\t\\tif 1 in [n[0],n[1]]: DP[j][0] = I\\n    \\t\\tif 1 in [n[0],n[2]]: DP[j][1] = I\\n    \\treturn -1 if DP[0][0] == I else DP[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389753,
                "title": "time-o-n2-o-n2-space-o-n2-o-n2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom enum import IntEnum\\n\\n\\nclass Pos(IntEnum):\\n  kHorizontal = 0\\n  kVertical = 1\\n\\n\\nclass Solution:\\n  def minimumMoves(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    ans = 0\\n    # State of (x, y, pos)\\n    # Pos := 0 (horizontal) // 1 (vertical)\\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\\n    seen = {(0, 0, Pos.kHorizontal)}\\n\\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\\n      if pos == Pos.kHorizontal:\\n        return y + 2 < n and not grid[x][y + 2]\\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\\n\\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\\n      if pos == Pos.kVertical:\\n        return x + 2 < n and not grid[x + 2][y]\\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\\n\\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\\n      return pos == Pos.kHorizontal and x + 1 < n and \\\\\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\\n\\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\\n      return pos == Pos.kVertical and y + 1 < n and \\\\\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\\n\\n    while q:\\n      for _ in range(len(q)):\\n        x, y, pos = q.popleft()\\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\\n          return ans\\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\\n          q.append((x, y + 1, pos))\\n          seen.add((x, y + 1, pos))\\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\\n          q.append((x + 1, y, pos))\\n          seen.add((x + 1, y, pos))\\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and \\\\\\n                (x, y, newPos) not in seen:\\n          q.append((x, y, newPos))\\n          seen.add((x, y, newPos))\\n      ans += 1\\n\\n    return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom enum import IntEnum\\n\\n\\nclass Pos(IntEnum):\\n  kHorizontal = 0\\n  kVertical = 1\\n\\n\\nclass Solution:\\n  def minimumMoves(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    ans = 0\\n    # State of (x, y, pos)\\n    # Pos := 0 (horizontal) // 1 (vertical)\\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\\n    seen = {(0, 0, Pos.kHorizontal)}\\n\\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\\n      if pos == Pos.kHorizontal:\\n        return y + 2 < n and not grid[x][y + 2]\\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\\n\\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\\n      if pos == Pos.kVertical:\\n        return x + 2 < n and not grid[x + 2][y]\\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\\n\\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\\n      return pos == Pos.kHorizontal and x + 1 < n and \\\\\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\\n\\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\\n      return pos == Pos.kVertical and y + 1 < n and \\\\\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\\n\\n    while q:\\n      for _ in range(len(q)):\\n        x, y, pos = q.popleft()\\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\\n          return ans\\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\\n          q.append((x, y + 1, pos))\\n          seen.add((x, y + 1, pos))\\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\\n          q.append((x + 1, y, pos))\\n          seen.add((x + 1, y, pos))\\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and \\\\\\n                (x, y, newPos) not in seen:\\n          q.append((x, y, newPos))\\n          seen.add((x, y, newPos))\\n      ans += 1\\n\\n    return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281652,
                "title": "python-simple-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumMoves(self, grid):\\n        n = len(grid)\\n        dict1, stack = {(0,0,0,1):0}, [(0,0,0,0,1)]\\n\\n        while stack:\\n            steps,i,j,ii,jj = heappop(stack)\\n            if i == n-1 and j == n-2 and ii == n-1 and jj == n-1: return steps\\n            if ii+1 < n and grid[i+1][j] == grid[ii+1][jj] == 0 and steps + 1 < dict1.get((i+1,j,ii+1,jj),float(\"inf\")):\\n                heappush(stack,(steps+1,i+1,j,ii+1,jj))\\n                dict1[(i+1,j,ii+1,jj)] = steps + 1\\n            if jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and steps + 1 < dict1.get((i,j+1,ii,jj+1),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j+1,ii,jj+1))\\n                dict1[(i,j+1,ii,jj+1)] = steps + 1\\n            if i == ii and ii+1 < n and grid[i+1][j] == grid[i+1][jj] == 0 and steps + 1 < dict1.get((i,j,i+1,j),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j,i+1,j))\\n                dict1[(i,j,i+1,j)] = steps + 1\\n            if j == jj and jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and steps + 1 < dict1.get((i,j,i,j+1),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j,i,j+1))\\n                dict1[(i,j,i,j+1)] = steps + 1\\n\\n        return -1\\n            \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid):\\n        n = len(grid)\\n        dict1, stack = {(0,0,0,1):0}, [(0,0,0,0,1)]\\n\\n        while stack:\\n            steps,i,j,ii,jj = heappop(stack)\\n            if i == n-1 and j == n-2 and ii == n-1 and jj == n-1: return steps\\n            if ii+1 < n and grid[i+1][j] == grid[ii+1][jj] == 0 and steps + 1 < dict1.get((i+1,j,ii+1,jj),float(\"inf\")):\\n                heappush(stack,(steps+1,i+1,j,ii+1,jj))\\n                dict1[(i+1,j,ii+1,jj)] = steps + 1\\n            if jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and steps + 1 < dict1.get((i,j+1,ii,jj+1),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j+1,ii,jj+1))\\n                dict1[(i,j+1,ii,jj+1)] = steps + 1\\n            if i == ii and ii+1 < n and grid[i+1][j] == grid[i+1][jj] == 0 and steps + 1 < dict1.get((i,j,i+1,j),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j,i+1,j))\\n                dict1[(i,j,i+1,j)] = steps + 1\\n            if j == jj and jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and steps + 1 < dict1.get((i,j,i,j+1),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j,i,j+1))\\n                dict1[(i,j,i,j+1)] = steps + 1\\n\\n        return -1\\n            \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130672,
                "title": "java-ez-2-understand",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n=grid.length;\\n        Queue<State> queue=new LinkedList<>();\\n        boolean vis[][][]=new boolean[n+1][n+1][2];\\n        //1 hori\\n        //0 vert\\n        State strt=new State(0,1,1),end=new State(n-1,n-1,1);\\n        queue.add(strt);\\n        int level=0;\\n        while(queue.size()!=0){\\n            int len=queue.size();\\n            while(len-->0){\\n                State temp=queue.remove();\\n                int i=temp.r,j=temp.c;\\n               // System.out.print(i+\" \"+j+\" \"+temp.ori+\" level \"+level);\\n                if(temp.r==end.r && temp.c==end.c && temp.ori==end.ori)\\n                    return level;\\n                if(temp.ori==1){\\n                    //rotate\\n                    if(i+1<n && j-1>=0 && grid[i+1][j]==0 && grid[i+1][j-1]==0 && !vis[i+1][j-1][0]){\\n                        queue.add(new State(i+1,j-1,0));\\n                        vis[i+1][j-1][0]=true;\\n                    }\\n                    //right\\n                    if(j+1<n && !vis[i][j+1][temp.ori] && grid[i][j+1]==0){\\n                        queue.add(new State(i,j+1,1));\\n                        vis[i][j+1][1]=true;\\n                    }\\n                    //down\\n                    if(j-1>=0 && i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && !vis[i+1][j][1]){\\n                        queue.add(new State(i+1,j,1));\\n                        vis[i+1][j][1]=true;\\n                    }\\n                    \\n                }else{\\n                    //rotate\\n                     if(i-1>=0 && j+1<n && grid[i-1][j+1]==0 && grid[i][j+1]==0 && !vis[i-1][j+1][1]){\\n                        queue.add(new State(i-1,j+1,1));\\n                         vis[i-1][j+1][1]=true;\\n                     }\\n                     //down\\n                     if(i+1<n && !vis[i+1][j][temp.ori] && grid[i+1][j]==0){\\n                         queue.add(new State(i+1,j,0));\\n                         vis[i+1][j][0]=true;\\n                     }\\n                    //right\\n                    if(j+1<n && i-1>=0 && grid[i-1][j+1]==0 && grid[i][j+1]==0 && !vis[i][j+1][temp.ori]){\\n                        queue.add(new State(i,j+1,temp.ori));\\n                        vis[i][j+1][temp.ori]=true;\\n                    }\\n                }\\n            }\\n            //System.out.println();\\n            level++;\\n        }\\n        return -1;\\n        \\n    }\\n    class State{\\n        int r;\\n        int c;\\n        int ori;\\n        State(int r,int c,int ori){\\n            this.r=r;\\n            this.c=c;\\n            this.ori=ori;\\n        }\\n    }\\n}```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n=grid.length;\\n        Queue<State> queue=new LinkedList<>();\\n        boolean vis[][][]=new boolean[n+1][n+1][2];\\n        //1 hori\\n        //0 vert\\n        State strt=new State(0,1,1),end=new State(n-1,n-1,1);\\n        queue.add(strt);\\n        int level=0;\\n        while(queue.size()!=0){\\n            int len=queue.size();\\n            while(len-->0){\\n                State temp=queue.remove();\\n                int i=temp.r,j=temp.c;\\n               // System.out.print(i+\" \"+j+\" \"+temp.ori+\" level \"+level);\\n                if(temp.r==end.r && temp.c==end.c && temp.ori==end.ori)\\n                    return level;\\n                if(temp.ori==1){\\n                    //rotate\\n                    if(i+1<n && j-1>=0 && grid[i+1][j]==0 && grid[i+1][j-1]==0 && !vis[i+1][j-1][0]){\\n                        queue.add(new State(i+1,j-1,0));\\n                        vis[i+1][j-1][0]=true;\\n                    }\\n                    //right\\n                    if(j+1<n && !vis[i][j+1][temp.ori] && grid[i][j+1]==0){\\n                        queue.add(new State(i,j+1,1));\\n                        vis[i][j+1][1]=true;\\n                    }\\n                    //down\\n                    if(j-1>=0 && i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && !vis[i+1][j][1]){\\n                        queue.add(new State(i+1,j,1));\\n                        vis[i+1][j][1]=true;\\n                    }\\n                    \\n                }else{\\n                    //rotate\\n                     if(i-1>=0 && j+1<n && grid[i-1][j+1]==0 && grid[i][j+1]==0 && !vis[i-1][j+1][1]){\\n                        queue.add(new State(i-1,j+1,1));\\n                         vis[i-1][j+1][1]=true;\\n                     }\\n                     //down\\n                     if(i+1<n && !vis[i+1][j][temp.ori] && grid[i+1][j]==0){\\n                         queue.add(new State(i+1,j,0));\\n                         vis[i+1][j][0]=true;\\n                     }\\n                    //right\\n                    if(j+1<n && i-1>=0 && grid[i-1][j+1]==0 && grid[i][j+1]==0 && !vis[i][j+1][temp.ori]){\\n                        queue.add(new State(i,j+1,temp.ori));\\n                        vis[i][j+1][temp.ori]=true;\\n                    }\\n                }\\n            }\\n            //System.out.println();\\n            level++;\\n        }\\n        return -1;\\n        \\n    }\\n    class State{\\n        int r;\\n        int c;\\n        int ori;\\n        State(int r,int c,int ori){\\n            this.r=r;\\n            this.c=c;\\n            this.ori=ori;\\n        }\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3067724,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::{HashMap, VecDeque};\\n        let n = grid.len();\\n        let mut ans = 0;\\n        let mut mp = HashMap::<(i32, (i32, i32)), i32>::new();\\n        let mut q = VecDeque::new();\\n        q.push_back((0, (0, 1)));\\n        mp.insert((0, (0, 1)), 1);\\n        while !q.is_empty() {\\n            let mut m = q.len();\\n            while m > 0 {\\n                let (pos, (x, y)) = q.pop_front().unwrap();\\n                if x == (n - 1) as i32 && y == (n - 1) as i32 && pos == 0 {\\n                    return ans;\\n                }\\n                if pos == 0 {\\n                    if y + 1 < n as i32 && grid[x as usize][y as usize + 1] == 0 && mp.get(&(0, (x, y + 1))).is_none() {\\n                        q.push_back((0, (x, y + 1)));\\n                        mp.insert((0, (x, y + 1)), 1);\\n                    }\\n                    if x + 1 < n as i32\\n                        && grid[x as usize + 1][y as usize] == 0\\n                        && grid[x as usize + 1][y as usize - 1] == 0\\n                        && mp.get(&(0, (x + 1, y))).is_none()\\n                    {\\n                        q.push_back((0, (x + 1, y)));\\n                        mp.insert((0, (x + 1, y)), 1);\\n                    }\\n                    if x + 1 < n as i32\\n                        && grid[x as usize + 1][y as usize] == 0\\n                        && grid[x as usize + 1][y as usize - 1] == 0\\n                        && mp.get(&(1, (x + 1, y - 1))).is_none()\\n                    {\\n                        q.push_back((1, (x + 1, y - 1)));\\n                        mp.insert((1, (x + 1, y - 1)), 1);\\n                    }\\n                } else {\\n                    if x + 1 < n as i32 && grid[x as usize + 1][y as usize] == 0 && mp.get(&(1, (x + 1, y))).is_none() {\\n                        q.push_back((1, (x + 1, y)));\\n                        mp.insert((1, (x + 1, y)), 1);\\n                    }\\n                    if y + 1 < n as i32\\n                        && grid[x as usize][y as usize + 1] == 0\\n                        && grid[x as usize - 1][y as usize + 1] == 0\\n                        && mp.get(&(1, (x, y + 1))).is_none()\\n                    {\\n                        q.push_back((1, (x, y + 1)));\\n                        mp.insert((1, (x, y + 1)), 1);\\n                    }\\n                    if y + 1 < n as i32\\n                        && grid[x as usize][y as usize + 1] == 0\\n                        && grid[x as usize - 1][y as usize + 1] == 0\\n                        && mp.get(&(0, (x - 1, y + 1))).is_none()\\n                    {\\n                        q.push_back((0, (x - 1, y + 1)));\\n                        mp.insert((0, (x - 1, y + 1)), 1);\\n                    }\\n                }\\n                m -= 1;\\n            }\\n            ans += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::{HashMap, VecDeque};\\n        let n = grid.len();\\n        let mut ans = 0;\\n        let mut mp = HashMap::<(i32, (i32, i32)), i32>::new();\\n        let mut q = VecDeque::new();\\n        q.push_back((0, (0, 1)));\\n        mp.insert((0, (0, 1)), 1);\\n        while !q.is_empty() {\\n            let mut m = q.len();\\n            while m > 0 {\\n                let (pos, (x, y)) = q.pop_front().unwrap();\\n                if x == (n - 1) as i32 && y == (n - 1) as i32 && pos == 0 {\\n                    return ans;\\n                }\\n                if pos == 0 {\\n                    if y + 1 < n as i32 && grid[x as usize][y as usize + 1] == 0 && mp.get(&(0, (x, y + 1))).is_none() {\\n                        q.push_back((0, (x, y + 1)));\\n                        mp.insert((0, (x, y + 1)), 1);\\n                    }\\n                    if x + 1 < n as i32\\n                        && grid[x as usize + 1][y as usize] == 0\\n                        && grid[x as usize + 1][y as usize - 1] == 0\\n                        && mp.get(&(0, (x + 1, y))).is_none()\\n                    {\\n                        q.push_back((0, (x + 1, y)));\\n                        mp.insert((0, (x + 1, y)), 1);\\n                    }\\n                    if x + 1 < n as i32\\n                        && grid[x as usize + 1][y as usize] == 0\\n                        && grid[x as usize + 1][y as usize - 1] == 0\\n                        && mp.get(&(1, (x + 1, y - 1))).is_none()\\n                    {\\n                        q.push_back((1, (x + 1, y - 1)));\\n                        mp.insert((1, (x + 1, y - 1)), 1);\\n                    }\\n                } else {\\n                    if x + 1 < n as i32 && grid[x as usize + 1][y as usize] == 0 && mp.get(&(1, (x + 1, y))).is_none() {\\n                        q.push_back((1, (x + 1, y)));\\n                        mp.insert((1, (x + 1, y)), 1);\\n                    }\\n                    if y + 1 < n as i32\\n                        && grid[x as usize][y as usize + 1] == 0\\n                        && grid[x as usize - 1][y as usize + 1] == 0\\n                        && mp.get(&(1, (x, y + 1))).is_none()\\n                    {\\n                        q.push_back((1, (x, y + 1)));\\n                        mp.insert((1, (x, y + 1)), 1);\\n                    }\\n                    if y + 1 < n as i32\\n                        && grid[x as usize][y as usize + 1] == 0\\n                        && grid[x as usize - 1][y as usize + 1] == 0\\n                        && mp.get(&(0, (x - 1, y + 1))).is_none()\\n                    {\\n                        q.push_back((0, (x - 1, y + 1)));\\n                        mp.insert((0, (x - 1, y + 1)), 1);\\n                    }\\n                }\\n                m -= 1;\\n            }\\n            ans += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3062624,
                "title": "multi-source-bfs-c-simple-clean-short-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    vector<vector<ll>>dx={{0,1},{0,-1},{0,0},{1,1}},dy={{0,-1},{0,1},{1,1},{0,0}};\\n\\n    bool issafe(ll a,ll b,ll c,ll d,ll n,ll m,vector<vector<int>>&grid){\\n        return a>=0 && a<n && b>=0 && b<n && c>=0 && c<m && d>=0 && d<m && grid[a][c]==0 && grid[b][d]==0;\\n    }\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        ll n=grid.size(),m=grid[0].size(),dist=0;\\n        queue<vector<ll>>q;q.push({0,0,0,1});\\n        vector<vector<vector<bool>>>visited(n,vector<vector<bool>>(n,vector<bool>(2,false)));\\n        while(!q.empty()){\\n            ll size=q.size();\\n            while(size--){\\n                auto temp=q.front();q.pop();\\n                if(visited[temp[2]][temp[3]][(temp[2]==temp[0]?0:1)]==true){\\n                    continue;\\n                }\\n                if(temp[0]==n-1 && temp[1]==m-2 && temp[2]==n-1 && temp[3]==m-1){\\n                    return dist;\\n                }    \\n                for(ll i=0;i<4;i++){\\n                    if((temp[0]==temp[2] && i==1) || (temp[1]==temp[3] && i==0)){\\n                        continue;\\n                    }\\n                    ll x1=temp[0]+dx[i][0],x2=temp[2]+dx[i][1],y1=temp[1]+dy[i][0],y2=temp[3]+dy[i][1];\\n                    if(issafe(x1,x2,y1,y2,n,m,grid) && visited[x2][y2][(x2==x1?0:1)]==false){\\n                        if(i<=1){\\n                            if(grid[temp[0]+1][temp[1]+1]==1){\\n                                continue;\\n                            }\\n                        }\\n                        q.push({x1,y1,x2,y2});\\n                    }\\n                }\\n                visited[temp[2]][temp[3]][(temp[2]==temp[0]?0:1)]=true;\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    vector<vector<ll>>dx={{0,1},{0,-1},{0,0},{1,1}},dy={{0,-1},{0,1},{1,1},{0,0}};\\n\\n    bool issafe(ll a,ll b,ll c,ll d,ll n,ll m,vector<vector<int>>&grid){\\n        return a>=0 && a<n && b>=0 && b<n && c>=0 && c<m && d>=0 && d<m && grid[a][c]==0 && grid[b][d]==0;\\n    }\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        ll n=grid.size(),m=grid[0].size(),dist=0;\\n        queue<vector<ll>>q;q.push({0,0,0,1});\\n        vector<vector<vector<bool>>>visited(n,vector<vector<bool>>(n,vector<bool>(2,false)));\\n        while(!q.empty()){\\n            ll size=q.size();\\n            while(size--){\\n                auto temp=q.front();q.pop();\\n                if(visited[temp[2]][temp[3]][(temp[2]==temp[0]?0:1)]==true){\\n                    continue;\\n                }\\n                if(temp[0]==n-1 && temp[1]==m-2 && temp[2]==n-1 && temp[3]==m-1){\\n                    return dist;\\n                }    \\n                for(ll i=0;i<4;i++){\\n                    if((temp[0]==temp[2] && i==1) || (temp[1]==temp[3] && i==0)){\\n                        continue;\\n                    }\\n                    ll x1=temp[0]+dx[i][0],x2=temp[2]+dx[i][1],y1=temp[1]+dy[i][0],y2=temp[3]+dy[i][1];\\n                    if(issafe(x1,x2,y1,y2,n,m,grid) && visited[x2][y2][(x2==x1?0:1)]==false){\\n                        if(i<=1){\\n                            if(grid[temp[0]+1][temp[1]+1]==1){\\n                                continue;\\n                            }\\n                        }\\n                        q.push({x1,y1,x2,y2});\\n                    }\\n                }\\n                visited[temp[2]][temp[3]][(temp[2]==temp[0]?0:1)]=true;\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928090,
                "title": "python-straight-bfs-solution-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust have right, down, clockwise and counter-clockwise as directions in the direction array and run a BFS\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        side, queue = len(grid), deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], [(0, 0), (-1, 1)]]\\n\\n        def validate(row1: int, col1: int, row2: int, col2: int, dirIndex: int) -> bool:\\n            if not (0 <= row1 < side and 0 <= col1 < side and 0 <= row2 < side and 0 <= col2 < side):\\n                return False\\n            if grid[row1][col1] != 0 or grid[row2][col2] != 0:\\n                return False\\n            if dirIndex >= 2:  # Edge Case 1\\n                if grid[row1 + 1][col1 + 1] == 1:\\n                    return False\\n            return True\\n        \\n        while queue:\\n            (row1, col1), (row2, col2), step = queue.popleft()\\n            if row1 == side - 1 and col1 == side - 2 and row2 == side - 1 and col2 == side - 1:\\n                return step\\n            for dirIndex in range(len(directions)):\\n                if dirIndex == 2:\\n                    if row1 != row2:\\n                        continue\\n                if dirIndex == 3:\\n                    if col1 != col2:\\n                        continue\\n                (drow1, dcol1), (drow2, dcol2) = directions[dirIndex]\\n                newRow1, newCol1 = row1 + drow1, col1 + dcol1\\n                newRow2, newCol2 = row2 + drow2, col2 + dcol2\\n                if validate(newRow1, newCol1, newRow2, newCol2, dirIndex) and ((newRow1, newCol1), (newRow2, newCol2)) not in visited:\\n                    visited.add(((newRow1, newCol1), (newRow2, newCol2)))\\n                    queue.append(((newRow1, newCol1), (newRow2, newCol2), step + 1))\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        side, queue = len(grid), deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], [(0, 0), (-1, 1)]]\\n\\n        def validate(row1: int, col1: int, row2: int, col2: int, dirIndex: int) -> bool:\\n            if not (0 <= row1 < side and 0 <= col1 < side and 0 <= row2 < side and 0 <= col2 < side):\\n                return False\\n            if grid[row1][col1] != 0 or grid[row2][col2] != 0:\\n                return False\\n            if dirIndex >= 2:  # Edge Case 1\\n                if grid[row1 + 1][col1 + 1] == 1:\\n                    return False\\n            return True\\n        \\n        while queue:\\n            (row1, col1), (row2, col2), step = queue.popleft()\\n            if row1 == side - 1 and col1 == side - 2 and row2 == side - 1 and col2 == side - 1:\\n                return step\\n            for dirIndex in range(len(directions)):\\n                if dirIndex == 2:\\n                    if row1 != row2:\\n                        continue\\n                if dirIndex == 3:\\n                    if col1 != col2:\\n                        continue\\n                (drow1, dcol1), (drow2, dcol2) = directions[dirIndex]\\n                newRow1, newCol1 = row1 + drow1, col1 + dcol1\\n                newRow2, newCol2 = row2 + drow2, col2 + dcol2\\n                if validate(newRow1, newCol1, newRow2, newCol2, dirIndex) and ((newRow1, newCol1), (newRow2, newCol2)) not in visited:\\n                    visited.add(((newRow1, newCol1), (newRow2, newCol2)))\\n                    queue.append(((newRow1, newCol1), (newRow2, newCol2), step + 1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856122,
                "title": "bfs-using-direction-array-clean-code",
                "content": "```\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        queue = deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], \\n                      [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], \\n                      [(0, 0), (-1, 1)]]\\n\\n        def validate(i1, j1, i2, j2, index):\\n            if not (0 <= i1 < n and 0 <= j1 < n and 0 <= i2 < n and 0 <= j2 < n):\\n                return False\\n            \\n            if grid[i1][j1] != 0 or grid[i2][j2] != 0:\\n                return False\\n            \\n            if index >= 2:  # Edge Case 1\\n                if grid[i1+1][j1+1] == 1:\\n                    return False\\n            \\n            return True\\n\\n        \\n        while queue:\\n            \\n            c1, c2, step = queue.popleft()\\n            i1, j1 = c1\\n            i2, j2 = c2\\n\\n            if i1 == n-1 and j1 == n-2 and i2 == n-1 and j2 == n-1:\\n                return step\\n\\n            for index in range(len(directions)):\\n                if index == 2:\\n                    if i1 != i2:\\n                        continue\\n                if index == 3:\\n                    if j1 != j2:\\n                        continue\\n                c1_drn, c2_drn = directions[index]\\n                i1_drn, j1_drn = c1_drn\\n                i2_drn, j2_drn = c2_drn\\n\\n                new_i1 = i1+i1_drn\\n                new_j1 = j1+j1_drn\\n\\n                new_i2 = i2+i2_drn\\n                new_j2 = j2+j2_drn\\n                if validate(new_i1, new_j1, new_i2, new_j2, index) and ((new_i1, new_j1), (new_i2, new_j2)) not in visited:\\n                    visited.add(((new_i1, new_j1), (new_i2, new_j2)))\\n                    # print(step, ((new_i1, new_j1), (new_i2, new_j2), step+1))\\n                    queue.append(((new_i1, new_j1), (new_i2, new_j2), step+1))\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        queue = deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], \\n                      [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], \\n                      [(0, 0), (-1, 1)]]\\n\\n        def validate(i1, j1, i2, j2, index):\\n            if not (0 <= i1 < n and 0 <= j1 < n and 0 <= i2 < n and 0 <= j2 < n):\\n                return False\\n            \\n            if grid[i1][j1] != 0 or grid[i2][j2] != 0:\\n                return False\\n            \\n            if index >= 2:  # Edge Case 1\\n                if grid[i1+1][j1+1] == 1:\\n                    return False\\n            \\n            return True\\n\\n        \\n        while queue:\\n            \\n            c1, c2, step = queue.popleft()\\n            i1, j1 = c1\\n            i2, j2 = c2\\n\\n            if i1 == n-1 and j1 == n-2 and i2 == n-1 and j2 == n-1:\\n                return step\\n\\n            for index in range(len(directions)):\\n                if index == 2:\\n                    if i1 != i2:\\n                        continue\\n                if index == 3:\\n                    if j1 != j2:\\n                        continue\\n                c1_drn, c2_drn = directions[index]\\n                i1_drn, j1_drn = c1_drn\\n                i2_drn, j2_drn = c2_drn\\n\\n                new_i1 = i1+i1_drn\\n                new_j1 = j1+j1_drn\\n\\n                new_i2 = i2+i2_drn\\n                new_j2 = j2+j2_drn\\n                if validate(new_i1, new_j1, new_i2, new_j2, index) and ((new_i1, new_j1), (new_i2, new_j2)) not in visited:\\n                    visited.add(((new_i1, new_j1), (new_i2, new_j2)))\\n                    # print(step, ((new_i1, new_j1), (new_i2, new_j2), step+1))\\n                    queue.append(((new_i1, new_j1), (new_i2, new_j2), step+1))\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759889,
                "title": "bfs-memoization",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Queue<int[]> q=new LinkedList<>();\\n        q.add(new int[]{0,0,0,1,0,0});\\n        int n=grid.length;\\n        boolean[][][] vis=new boolean[n][n][2];\\n        while(!q.isEmpty()){\\n            int[] cur=q.remove();\\n            int position=cur[4];\\n            // System.out.println(cur[0]+\",\"+cur[1]+\" | \"+cur[2]+\",\"+cur[3]+\" \"+(position==0?\"horizontal\":\"vertical\"));\\n            if(vis[cur[2]][cur[3]][position]){\\n                continue;\\n            }\\n            // System.out.println(cur[0]+\",\"+cur[1]+\" | \"+cur[2]+\",\"+cur[3]);\\n            vis[cur[2]][cur[3]][position]=true;\\n            if(cur[0]==n-1 && cur[1]==n-2 && cur[2]==n-1 && cur[3]==n-1){\\n                return cur[5];\\n            }\\n            //horizontal\\n            if(position==0){\\n                if(cur[2]+1<n && grid[cur[2]+1][cur[3]-1]+grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[0],cur[1],cur[2]+1,cur[3]-1,(position+1)%2,cur[5]+1});\\n                }\\n                if(cur[3]+1<n && grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[2],cur[3],cur[2],cur[3]+1,position,cur[5]+1});\\n                }\\n                if(cur[0]+1<n && cur[2]+1<n && grid[cur[0]+1][cur[1]]+grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[0]+1,cur[1],cur[2]+1,cur[3],position,cur[5]+1});\\n                }\\n            }\\n            //vertical\\n            else{\\n                if(cur[3]+1<n && grid[cur[2]-1][cur[3]+1]+grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[0],cur[1],cur[2]-1,cur[3]+1,(position+1)%2,cur[5]+1});\\n                }\\n                if(cur[2]+1<n && grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[2],cur[3],cur[2]+1,cur[3],position,cur[5]+1});\\n                }\\n                if(cur[1]+1<n && cur[3]+1<n && grid[cur[0]][cur[1]+1]+grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[0],cur[1]+1,cur[2],cur[3]+1,position,cur[5]+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    boolean isValid(int[] cur, int n){\\n        return cur[0]<n && cur[2]<n && cur[1]<n && cur[3]<n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Queue<int[]> q=new LinkedList<>();\\n        q.add(new int[]{0,0,0,1,0,0});\\n        int n=grid.length;\\n        boolean[][][] vis=new boolean[n][n][2];\\n        while(!q.isEmpty()){\\n            int[] cur=q.remove();\\n            int position=cur[4];\\n            // System.out.println(cur[0]+\",\"+cur[1]+\" | \"+cur[2]+\",\"+cur[3]+\" \"+(position==0?\"horizontal\":\"vertical\"));\\n            if(vis[cur[2]][cur[3]][position]){\\n                continue;\\n            }\\n            // System.out.println(cur[0]+\",\"+cur[1]+\" | \"+cur[2]+\",\"+cur[3]);\\n            vis[cur[2]][cur[3]][position]=true;\\n            if(cur[0]==n-1 && cur[1]==n-2 && cur[2]==n-1 && cur[3]==n-1){\\n                return cur[5];\\n            }\\n            //horizontal\\n            if(position==0){\\n                if(cur[2]+1<n && grid[cur[2]+1][cur[3]-1]+grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[0],cur[1],cur[2]+1,cur[3]-1,(position+1)%2,cur[5]+1});\\n                }\\n                if(cur[3]+1<n && grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[2],cur[3],cur[2],cur[3]+1,position,cur[5]+1});\\n                }\\n                if(cur[0]+1<n && cur[2]+1<n && grid[cur[0]+1][cur[1]]+grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[0]+1,cur[1],cur[2]+1,cur[3],position,cur[5]+1});\\n                }\\n            }\\n            //vertical\\n            else{\\n                if(cur[3]+1<n && grid[cur[2]-1][cur[3]+1]+grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[0],cur[1],cur[2]-1,cur[3]+1,(position+1)%2,cur[5]+1});\\n                }\\n                if(cur[2]+1<n && grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[2],cur[3],cur[2]+1,cur[3],position,cur[5]+1});\\n                }\\n                if(cur[1]+1<n && cur[3]+1<n && grid[cur[0]][cur[1]+1]+grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[0],cur[1]+1,cur[2],cur[3]+1,position,cur[5]+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    boolean isValid(int[] cur, int n){\\n        return cur[0]<n && cur[2]<n && cur[1]<n && cur[3]<n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720413,
                "title": "python-dp-solution-intuitive-with-comments",
                "content": "```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        dp = [[[114514, 114514] for i in range(n)] for j in range(m)]\\n        # dp[i][j][0]: the number of minimum moves that the snake\\'s tail can reach (i, j) and positioned horizontally\\n        # dp[i][j][1]: the number of minimum moves that the snake\\'s tail can reach (i, j) and positioned vertically\\n        \\n        dp[0][0][0] = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # dp[i][j][0] = min(dp[i][j - 1][0], dp[i - 1][j][0], dp[i][j][1]) + 1\\n                # dp[i][j][1] = min(dp[i][j - 1][1], dp[i - 1][j][1], dp[i][j][0]) + 1\\n                \\n                hori = [] # tail horizontally placed in (i, j)\\n                if j < n - 1 and j > 0 and grid[i][j] != 1 and grid[i][j + 1] != 1: # moved right to (i, j)\\n                    hori.append(dp[i][j - 1][0])\\n                if j < n - 1 and i > 0 and grid[i][j] != 1 and grid[i][j + 1] != 1: # moved down to (i, j)\\n                    hori.append(dp[i - 1][j][0])\\n                if j < n - 1 and i < m - 1 and grid[i][j] != 1 and grid[i][j + 1] != 1 and grid[i + 1][j + 1] != 1: # rotate counterclockwise\\n                    hori.append(dp[i][j][1])\\n                if hori:\\n                    dp[i][j][0] = min(hori + [dp[i][j][0]]) + 1\\n                    \\n                vert = [] # tail vertically placed in (i, j)\\n                if i < m - 1 and j > 0 and grid[i][j] != 1 and grid[i + 1][j] != 1: # moved right to (i, j)\\n                    vert.append(dp[i][j - 1][1])\\n                if i < m - 1 and i > 0 and grid[i][j] != 1 and grid[i + 1][j] != 1: # moved down to (i, j)\\n                    hori.append(dp[i - 1][j][0])\\n                    vert.append(dp[i - 1][j][1])\\n                if i < m - 1 and j < n - 1 and grid[i][j] != 1 and grid[i + 1][j] != 1 and grid[i + 1][j + 1] != 1: # rotate clockwise\\n                    vert.append(dp[i][j][0])\\n                if vert:\\n                    dp[i][j][1] = min(vert + [dp[i][j][1]]) + 1\\n                    \\n                if j < n - 1 and i < m - 1 and grid[i][j] != 1 and grid[i][j + 1] != 1 and grid[i + 1][j + 1] != 1: # update dp[i][j][0] again after dp[i][j][1] has changed\\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j][1] + 1)\\n                    \\n        return -1 if dp[-1][-2][0] >= 114514 else dp[-1][-2][0] - dp[0][0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        dp = [[[114514, 114514] for i in range(n)] for j in range(m)]\\n        # dp[i][j][0]: the number of minimum moves that the snake\\'s tail can reach (i, j) and positioned horizontally\\n        # dp[i][j][1]: the number of minimum moves that the snake\\'s tail can reach (i, j) and positioned vertically\\n        \\n        dp[0][0][0] = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # dp[i][j][0] = min(dp[i][j - 1][0], dp[i - 1][j][0], dp[i][j][1]) + 1\\n                # dp[i][j][1] = min(dp[i][j - 1][1], dp[i - 1][j][1], dp[i][j][0]) + 1\\n                \\n                hori = [] # tail horizontally placed in (i, j)\\n                if j < n - 1 and j > 0 and grid[i][j] != 1 and grid[i][j + 1] != 1: # moved right to (i, j)\\n                    hori.append(dp[i][j - 1][0])\\n                if j < n - 1 and i > 0 and grid[i][j] != 1 and grid[i][j + 1] != 1: # moved down to (i, j)\\n                    hori.append(dp[i - 1][j][0])\\n                if j < n - 1 and i < m - 1 and grid[i][j] != 1 and grid[i][j + 1] != 1 and grid[i + 1][j + 1] != 1: # rotate counterclockwise\\n                    hori.append(dp[i][j][1])\\n                if hori:\\n                    dp[i][j][0] = min(hori + [dp[i][j][0]]) + 1\\n                    \\n                vert = [] # tail vertically placed in (i, j)\\n                if i < m - 1 and j > 0 and grid[i][j] != 1 and grid[i + 1][j] != 1: # moved right to (i, j)\\n                    vert.append(dp[i][j - 1][1])\\n                if i < m - 1 and i > 0 and grid[i][j] != 1 and grid[i + 1][j] != 1: # moved down to (i, j)\\n                    hori.append(dp[i - 1][j][0])\\n                    vert.append(dp[i - 1][j][1])\\n                if i < m - 1 and j < n - 1 and grid[i][j] != 1 and grid[i + 1][j] != 1 and grid[i + 1][j + 1] != 1: # rotate clockwise\\n                    vert.append(dp[i][j][0])\\n                if vert:\\n                    dp[i][j][1] = min(vert + [dp[i][j][1]]) + 1\\n                    \\n                if j < n - 1 and i < m - 1 and grid[i][j] != 1 and grid[i][j + 1] != 1 and grid[i + 1][j + 1] != 1: # update dp[i][j][0] again after dp[i][j][1] has changed\\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j][1] + 1)\\n                    \\n        return -1 if dp[-1][-2][0] >= 114514 else dp[-1][-2][0] - dp[0][0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478930,
                "title": "bfs-c-superfast-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>&grid){\\n        int n=grid.size(),ans=0;\\n        map<pair<int,pair<int,int>>,int>mp;\\n        queue<pair<int,pair<int,int>>>q;\\n        \\n        q.push({0,{0,1}});\\n        mp[{0,{0,1}}]++;\\n        int i=0;\\n        while(q.size()>0){\\n            int m=q.size();\\n            while(m--)\\n            {\\n                int x=q.front().second.first,y=q.front().second.second,pos=q.front().first;\\n                q.pop();\\n                if(x==n-1 && y==n-1 && pos==0)return ans;\\n                if(pos==0)\\n                {\\n                    if(y+1<n && grid[x][y+1]==0 && mp.find({0,{x,y+1}})==mp.end()){\\n                        q.push({0,{x,y+1}});\\n                        mp[{0,{x,y+1}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({0,{x+1,y}})==mp.end()){\\n                        q.push({0,{x+1,y}});\\n                        mp[{0,{x+1,y}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({1,{x+1,y-1}})==mp.end()){\\n                        q.push({1,{x+1,y-1}});\\n                        mp[{1,{x+1,y-1}}]++;\\n                    }\\n                }else{\\n                    if(x+1<n && grid[x+1][y]==0 && mp.find({1,{x+1,y}})==mp.end()){\\n                        q.push({1,{x+1,y}});\\n                        mp[{1,{x+1,y}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({1,{x,y+1}})==mp.end()){\\n                         q.push({1,{x,y+1}});\\n                         mp[{1,{x,y+1}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({0,{x-1,y+1}})==mp.end()){\\n                         q.push({0,{x-1,y+1}});\\n                         mp[{0,{x-1,y+1}}]++;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>&grid){\\n        int n=grid.size(),ans=0;\\n        map<pair<int,pair<int,int>>,int>mp;\\n        queue<pair<int,pair<int,int>>>q;\\n        \\n        q.push({0,{0,1}});\\n        mp[{0,{0,1}}]++;\\n        int i=0;\\n        while(q.size()>0){\\n            int m=q.size();\\n            while(m--)\\n            {\\n                int x=q.front().second.first,y=q.front().second.second,pos=q.front().first;\\n                q.pop();\\n                if(x==n-1 && y==n-1 && pos==0)return ans;\\n                if(pos==0)\\n                {\\n                    if(y+1<n && grid[x][y+1]==0 && mp.find({0,{x,y+1}})==mp.end()){\\n                        q.push({0,{x,y+1}});\\n                        mp[{0,{x,y+1}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({0,{x+1,y}})==mp.end()){\\n                        q.push({0,{x+1,y}});\\n                        mp[{0,{x+1,y}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({1,{x+1,y-1}})==mp.end()){\\n                        q.push({1,{x+1,y-1}});\\n                        mp[{1,{x+1,y-1}}]++;\\n                    }\\n                }else{\\n                    if(x+1<n && grid[x+1][y]==0 && mp.find({1,{x+1,y}})==mp.end()){\\n                        q.push({1,{x+1,y}});\\n                        mp[{1,{x+1,y}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({1,{x,y+1}})==mp.end()){\\n                         q.push({1,{x,y+1}});\\n                         mp[{1,{x,y+1}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({0,{x-1,y+1}})==mp.end()){\\n                         q.push({0,{x-1,y+1}});\\n                         mp[{0,{x-1,y+1}}]++;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478923,
                "title": "dfs-c-superfast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,pair<int,int>>,int>mp;\\n    int dp[101][101][3];\\n    int solve(vector<vector<int>>&grid,int n,int m,int i,int j,int pos){\\n        if(i>=n || j>=m)return INT_MAX;\\n\\t\\t//f i ans j are at right bottom end and rotaion is 0 then we return \\n        if(i==n-1 && j==n-1 && pos==0)return 0;\\n        int ans=INT_MAX,first=i,second=j;\\n        \\n        if(dp[i][j][pos]!=-1)return dp[i][j][pos];\\n        if(pos==0){\\n            if(j+1<m && grid[i][j+1]==0 && mp.find({0,{i,j+1}})==mp.end()){\\n\\t\\t\\t//to avoid runtime erroe vis the same node again\\n                mp[{0,{i,j+1}}]++;\\n                int c=solve(grid,n,m,i,j+1,pos);\\n\\t\\t\\t\\t//backtrack\\n                mp.erase({0,{i,j+1}});\\n                if(c!=INT_MAX)ans=min(ans,1+c);\\n            }\\n            if(i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && mp.find({0,{i+1,j}})==mp.end()){\\n                mp[{0,{i+1,j}}]++;\\n                int e=solve(grid,n,m,i+1,j,pos);\\n                mp.erase({0,{i+1,j}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && mp.find({1,{i+1,j-1}})==mp.end()){\\n                mp[{1,{i+1,j-1}}]++;\\n                int e=solve(grid,n,m,i+1,j-1,1);\\n                mp.erase({1,{i+1,j-1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n        }else{\\n            if(i+1<n && grid[i+1][j]==0 && mp.find({1,{i+1,j}})==mp.end()){\\n                mp[{1,{i+1,j}}]++;\\n                int e=solve(grid,n,m,i+1,j,1);\\n                mp.erase({1,{i+1,j}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(j+1<n && grid[i][j+1]==0 && grid[i-1][j+1]==0 && mp.find({1,{i,j+1}})==mp.end()){\\n                mp[{1,{i,j+1}}]++;\\n                int e=solve(grid,n,m,i,j+1,1);\\n                mp.erase({1,{i,j+1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(j+1<n && grid[i][j+1]==0 && grid[i-1][j+1]==0 && mp.find({0,{i-1,j+1}})==mp.end()){\\n                mp[{0,{i-1,j+1}}]++;\\n                int e=solve(grid,n,m,i-1,j+1,0);\\n                mp.erase({0,{i-1,j+1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n        }\\n        return dp[i][j][pos]=ans;\\n    }\\n    int minimumMoves(vector<vector<int>>&grid){\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(grid,grid.size(),grid[0].size(),0,1,0);\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,pair<int,int>>,int>mp;\\n    int dp[101][101][3];\\n    int solve(vector<vector<int>>&grid,int n,int m,int i,int j,int pos){\\n        if(i>=n || j>=m)return INT_MAX;\\n\\t\\t//f i ans j are at right bottom end and rotaion is 0 then we return \\n        if(i==n-1 && j==n-1 && pos==0)return 0;\\n        int ans=INT_MAX,first=i,second=j;\\n        \\n        if(dp[i][j][pos]!=-1)return dp[i][j][pos];\\n        if(pos==0){\\n            if(j+1<m && grid[i][j+1]==0 && mp.find({0,{i,j+1}})==mp.end()){\\n\\t\\t\\t//to avoid runtime erroe vis the same node again\\n                mp[{0,{i,j+1}}]++;\\n                int c=solve(grid,n,m,i,j+1,pos);\\n\\t\\t\\t\\t//backtrack\\n                mp.erase({0,{i,j+1}});\\n                if(c!=INT_MAX)ans=min(ans,1+c);\\n            }\\n            if(i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && mp.find({0,{i+1,j}})==mp.end()){\\n                mp[{0,{i+1,j}}]++;\\n                int e=solve(grid,n,m,i+1,j,pos);\\n                mp.erase({0,{i+1,j}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && mp.find({1,{i+1,j-1}})==mp.end()){\\n                mp[{1,{i+1,j-1}}]++;\\n                int e=solve(grid,n,m,i+1,j-1,1);\\n                mp.erase({1,{i+1,j-1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n        }else{\\n            if(i+1<n && grid[i+1][j]==0 && mp.find({1,{i+1,j}})==mp.end()){\\n                mp[{1,{i+1,j}}]++;\\n                int e=solve(grid,n,m,i+1,j,1);\\n                mp.erase({1,{i+1,j}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(j+1<n && grid[i][j+1]==0 && grid[i-1][j+1]==0 && mp.find({1,{i,j+1}})==mp.end()){\\n                mp[{1,{i,j+1}}]++;\\n                int e=solve(grid,n,m,i,j+1,1);\\n                mp.erase({1,{i,j+1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(j+1<n && grid[i][j+1]==0 && grid[i-1][j+1]==0 && mp.find({0,{i-1,j+1}})==mp.end()){\\n                mp[{0,{i-1,j+1}}]++;\\n                int e=solve(grid,n,m,i-1,j+1,0);\\n                mp.erase({0,{i-1,j+1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n        }\\n        return dp[i][j][pos]=ans;\\n    }\\n    int minimumMoves(vector<vector<int>>&grid){\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(grid,grid.size(),grid[0].size(),0,1,0);\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469360,
                "title": "swift-solution",
                "content": "```\\nClass Solution {\\n    func minimumMoves(_ grid: [[Int]]) -> Int {\\n        let n = grid.count\\n        var dp = Array(repeating: Array(repeating: Array(repeating: 0, count: 2), count: n), count: n)\\n        \\n        for i in 0..<n {\\n            for j in 0..<n {\\n                for k in 0..<2 {\\n                    if i == 0 && j == 0 && k == 0 {\\n                        dp[i][j][k] = 0\\n                    } else if grid[i][j] == 1 {\\n                        dp[i][j][k] = Int.max\\n                    } else if k == 0 && (j + 1 >= n || grid[i][j + 1] == 1) {\\n                        dp[i][j][k] = Int.max\\n                    } else if k == 1 && (i + 1 >= n || grid[i + 1][j] == 1) {\\n                        dp[i][j][k] = Int.max\\n                    } else {\\n                        let choice1 = i - 1 >= 0 ? dp[i - 1][j][k] : Int.max\\n                        let choice2 = j - 1 >= 0 ? dp[i][j - 1][k] : Int.max\\n                        let tempMinChoice = min(choice1, choice2)\\n                        dp[i][j][k] = tempMinChoice == Int.max ? tempMinChoice : (tempMinChoice + 1)\\n                    }\\n                }\\n                //rotate\\n                if i + 1 < n && j + 1 < n && grid[i][j + 1] != 1 && grid[i + 1][j + 1] != 1 && dp[i][j][1] != Int.max && dp[i][j][0] > dp[i][j][1] + 1 {\\n                    dp[i][j][0] = dp[i][j][1] + 1\\n                }\\n                if i + 1 < n && j + 1 < n && grid[i + 1][j] != 1 && grid[i + 1][j + 1] != 1 && dp[i][j][0] != Int.max && dp[i][j][1] > dp[i][j][0] + 1 {\\n                    dp[i][j][1] = dp[i][j][0] + 1\\n                }\\n            }\\n        }\\n        return dp[n - 1][n - 2][0] == Int.max ? -1 : dp[n - 1][n - 2][0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nClass Solution {\\n    func minimumMoves(_ grid: [[Int]]) -> Int {\\n        let n = grid.count\\n        var dp = Array(repeating: Array(repeating: Array(repeating: 0, count: 2), count: n), count: n)\\n        \\n        for i in 0..<n {\\n            for j in 0..<n {\\n                for k in 0..<2 {\\n                    if i == 0 && j == 0 && k == 0 {\\n                        dp[i][j][k] = 0\\n                    } else if grid[i][j] == 1 {\\n                        dp[i][j][k] = Int.max\\n                    } else if k == 0 && (j + 1 >= n || grid[i][j + 1] == 1) {\\n                        dp[i][j][k] = Int.max\\n                    } else if k == 1 && (i + 1 >= n || grid[i + 1][j] == 1) {\\n                        dp[i][j][k] = Int.max\\n                    } else {\\n                        let choice1 = i - 1 >= 0 ? dp[i - 1][j][k] : Int.max\\n                        let choice2 = j - 1 >= 0 ? dp[i][j - 1][k] : Int.max\\n                        let tempMinChoice = min(choice1, choice2)\\n                        dp[i][j][k] = tempMinChoice == Int.max ? tempMinChoice : (tempMinChoice + 1)\\n                    }\\n                }\\n                //rotate\\n                if i + 1 < n && j + 1 < n && grid[i][j + 1] != 1 && grid[i + 1][j + 1] != 1 && dp[i][j][1] != Int.max && dp[i][j][0] > dp[i][j][1] + 1 {\\n                    dp[i][j][0] = dp[i][j][1] + 1\\n                }\\n                if i + 1 < n && j + 1 < n && grid[i + 1][j] != 1 && grid[i + 1][j + 1] != 1 && dp[i][j][0] != Int.max && dp[i][j][1] > dp[i][j][0] + 1 {\\n                    dp[i][j][1] = dp[i][j][0] + 1\\n                }\\n            }\\n        }\\n        return dp[n - 1][n - 2][0] == Int.max ? -1 : dp[n - 1][n - 2][0]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2318417,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        q=deque([([0,1],0,0)])\\n        def inb(p):return p[0]>=0 and p[0]<len(grid) and p[1]>=0 and p[1]<len(grid[0]) and grid[p[0]][p[1]]==0\\n        u=set()\\n        while q:\\n            p,v,c=q.popleft()\\n            if p[0]==len(grid)-1 and p[1]==len(grid[0])-1 and v==0:return c\\n            k=(p[0],p[1],v)\\n            if k in u:continue\\n            u.add(k)\\n            if v==0:\\n                pn=[p[0],p[1]+1]\\n                if inb(pn):q.append((pn,v,c+1))\\n                pn=[p[0]+1,p[1]]\\n                if inb(pn) and inb([p[0]+1,p[1]-1]):q.append((pn,v,c+1))\\n                pn=[p[0]+1,p[1]-1]\\n                if inb(pn) and inb([p[0]+1,p[1]]):q.append((pn,1,c+1))\\n            elif v==1:\\n                pn=[p[0]+1,p[1]]\\n                if inb(pn) and grid[pn[0]][pn[1]]!=1:q.append((pn,v,c+1))\\n                pn=[p[0],p[1]+1]\\n                if inb(pn) and inb([p[0]-1,p[1]+1]):q.append((pn,v,c+1))\\n                pn=[p[0]-1,p[1]+1]\\n                if inb(pn) and inb([p[0],p[1]+1]):q.append((pn,0,c+1))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        q=deque([([0,1],0,0)])\\n        def inb(p):return p[0]>=0 and p[0]<len(grid) and p[1]>=0 and p[1]<len(grid[0]) and grid[p[0]][p[1]]==0\\n        u=set()\\n        while q:\\n            p,v,c=q.popleft()\\n            if p[0]==len(grid)-1 and p[1]==len(grid[0])-1 and v==0:return c\\n            k=(p[0],p[1],v)\\n            if k in u:continue\\n            u.add(k)\\n            if v==0:\\n                pn=[p[0],p[1]+1]\\n                if inb(pn):q.append((pn,v,c+1))\\n                pn=[p[0]+1,p[1]]\\n                if inb(pn) and inb([p[0]+1,p[1]-1]):q.append((pn,v,c+1))\\n                pn=[p[0]+1,p[1]-1]\\n                if inb(pn) and inb([p[0]+1,p[1]]):q.append((pn,1,c+1))\\n            elif v==1:\\n                pn=[p[0]+1,p[1]]\\n                if inb(pn) and grid[pn[0]][pn[1]]!=1:q.append((pn,v,c+1))\\n                pn=[p[0],p[1]+1]\\n                if inb(pn) and inb([p[0]-1,p[1]+1]):q.append((pn,v,c+1))\\n                pn=[p[0]-1,p[1]+1]\\n                if inb(pn) and inb([p[0],p[1]+1]):q.append((pn,0,c+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317313,
                "title": "python-100-fastest-sol-bfs-hashmap-fully-explained",
                "content": "# Runtime: 233 ms, faster than 100.00% of Python3 online submissions for Minimum Moves to Reach Target with Rotations.\\n# Memory Usage: 16 MB, less than 56.06% of Python3 online submissions for Minimum Moves to Reach Target with Rotations.\\n\\n# EXPLANATION\\nThe idea is very simple \\nKeep track of the cell of head of the snake as well as the direction head is facing\\n\\n\\nWhen snake is positioned horizontally:\\n1. we can move right\\n2. we can move down\\n3. make snake vertical\\n\\nWhen snake is positioned vertically:\\n1. we can move right\\n2. we can move down\\n3. make snake vertical\\n\\n\\nSince there can be multiple solutions possible and we need solution with minimum numbers of steps we use BFS\\n\\nOnce a cell is visited in a direction we don\\'t visit the cell in the same direction again to avoid \\nrepeatition\\n# CODE\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        queue , vis , n = [(0,1,0,0)] , {} , len(grid)\\n        while queue:\\n            x,y,pos,moves = queue.pop(0)\\n            if x == y == n-1 and pos == 0: return moves\\n            if pos == 0:\\n                if y + 1 < n and grid[x][y+1] == 0 and (x,y+1,0) not in vis:\\n                    vis[(x,y+1,0)] = True\\n                    queue.append((x,y+1,0,moves+1))\\n                \\n                if x + 1 < n and grid[x+1][y-1] == 0 and grid[x+1][y] == 0:\\n                    if (x+1,y-1,1) not in vis:\\n                        vis[(x+1,y-1,1)] = True\\n                        queue.append((x+1,y-1,1,moves+1))\\n                    if (x+1,y,0) not in vis:\\n                        vis[(x+1,y,0)] = True\\n                        queue.append((x+1,y,0,moves+1))\\n            else:\\n                if x + 1 < n and grid[x+1][y] == 0 and (x+1,y,1) not in vis:\\n                    vis[(x+1,y,1)] = True\\n                    queue.append((x+1,y,1,moves+1))\\n                if y + 1 < n and grid[x-1][y+1] == grid[x][y+1] == 0:\\n                    if (x-1,y+1,0) not in vis:\\n                        vis[(x-1,y+1,0)] = True\\n                        queue.append((x-1,y+1,0,moves+1))\\n                    if (x,y+1,1) not in vis:\\n                        vis[(x,y+1,1)] = True\\n                        queue.append((x,y+1,1,moves+1))\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        queue , vis , n = [(0,1,0,0)] , {} , len(grid)\\n        while queue:\\n            x,y,pos,moves = queue.pop(0)\\n            if x == y == n-1 and pos == 0: return moves\\n            if pos == 0:\\n                if y + 1 < n and grid[x][y+1] == 0 and (x,y+1,0) not in vis:\\n                    vis[(x,y+1,0)] = True\\n                    queue.append((x,y+1,0,moves+1))\\n                \\n                if x + 1 < n and grid[x+1][y-1] == 0 and grid[x+1][y] == 0:\\n                    if (x+1,y-1,1) not in vis:\\n                        vis[(x+1,y-1,1)] = True\\n                        queue.append((x+1,y-1,1,moves+1))\\n                    if (x+1,y,0) not in vis:\\n                        vis[(x+1,y,0)] = True\\n                        queue.append((x+1,y,0,moves+1))\\n            else:\\n                if x + 1 < n and grid[x+1][y] == 0 and (x+1,y,1) not in vis:\\n                    vis[(x+1,y,1)] = True\\n                    queue.append((x+1,y,1,moves+1))\\n                if y + 1 < n and grid[x-1][y+1] == grid[x][y+1] == 0:\\n                    if (x-1,y+1,0) not in vis:\\n                        vis[(x-1,y+1,0)] = True\\n                        queue.append((x-1,y+1,0,moves+1))\\n                    if (x,y+1,1) not in vis:\\n                        vis[(x,y+1,1)] = True\\n                        queue.append((x,y+1,1,moves+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161680,
                "title": "java-dp-beats-100",
                "content": "```\\npublic int minimumMoves(int[][] grid) {\\n\\tint n = grid.length;\\n\\tint[][][] dp = new int[n+1][n+1][2];\\n\\t//[i,j,0]=> horizontal\\n\\t//[i,j,1]=> vertical\\n\\tfor(int i = 0; i <= n; i++){\\n\\t\\tfor(int j = 0; j <= n; j++){\\n\\t\\t\\tdp[i][j][0] = Integer.MAX_VALUE/2;\\n\\t\\t\\tdp[i][j][1] = Integer.MAX_VALUE/2;\\n\\t\\t}\\n\\t}\\n\\t//to make the initial position dp[1][1][0] as 0;\\n\\tdp[0][1][0] = -1;\\n\\tdp[1][0][0] = -1;\\n\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tfor(int j = 1; j <= n; j++){\\n\\t\\t\\tboolean possibleFromRotate = false;\\n\\t\\t\\tboolean possibleFromAntiRotate = false;\\n\\t\\t\\t//could be from left\\n\\t\\t\\tif(grid[i-1][j-1] == 0 && j < n && grid[i-1][j] == 0){\\n\\t\\t\\t\\tdp[i][j][0] = Math.min(dp[i][j-1][0], dp[i-1][j][0]) + 1;\\n\\t\\t\\t\\tpossibleFromAntiRotate = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(grid[i-1][j-1] == 0 && i < n && grid[i][j-1] == 0){\\n\\t\\t\\t\\tdp[i][j][1] = Math.min(dp[i-1][j][1], dp[i][j-1][1]) + 1;\\n\\t\\t\\t\\tpossibleFromRotate = true;\\n\\t\\t\\t}\\n\\t\\t\\t//could be from anti-rotate\\n\\t\\t\\tif(possibleFromAntiRotate && i<n && grid[i][j] == 0){\\n\\t\\t\\t\\tdp[i][j][0] = Math.min(dp[i][j][0], dp[i][j][1]+1);\\n\\t\\t\\t}\\n\\t\\t\\t//could be from rotate\\n\\t\\t\\tif(possibleFromRotate && j<n && grid[i][j] == 0){\\n\\t\\t\\t\\tdp[i][j][1] = Math.min(dp[i][j][1], dp[i][j][0]+1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn (dp[n][n-1][0] >= (Integer.MAX_VALUE/2)) ? -1 : dp[n][n-1][0];       \\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int minimumMoves(int[][] grid) {\\n\\tint n = grid.length;\\n\\tint[][][] dp = new int[n+1][n+1][2];\\n\\t//[i,j,0]=> horizontal\\n\\t//[i,j,1]=> vertical\\n\\tfor(int i = 0; i <= n; i++){\\n\\t\\tfor(int j = 0; j <= n; j++){\\n\\t\\t\\tdp[i][j][0] = Integer.MAX_VALUE/2;\\n\\t\\t\\tdp[i][j][1] = Integer.MAX_VALUE/2;\\n\\t\\t}\\n\\t}\\n\\t//to make the initial position dp[1][1][0] as 0;\\n\\tdp[0][1][0] = -1;\\n\\tdp[1][0][0] = -1;\\n\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tfor(int j = 1; j <= n; j++){\\n\\t\\t\\tboolean possibleFromRotate = false;\\n\\t\\t\\tboolean possibleFromAntiRotate = false;\\n\\t\\t\\t//could be from left\\n\\t\\t\\tif(grid[i-1][j-1] == 0 && j < n && grid[i-1][j] == 0){\\n\\t\\t\\t\\tdp[i][j][0] = Math.min(dp[i][j-1][0], dp[i-1][j][0]) + 1;\\n\\t\\t\\t\\tpossibleFromAntiRotate = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(grid[i-1][j-1] == 0 && i < n && grid[i][j-1] == 0){\\n\\t\\t\\t\\tdp[i][j][1] = Math.min(dp[i-1][j][1], dp[i][j-1][1]) + 1;\\n\\t\\t\\t\\tpossibleFromRotate = true;\\n\\t\\t\\t}\\n\\t\\t\\t//could be from anti-rotate\\n\\t\\t\\tif(possibleFromAntiRotate && i<n && grid[i][j] == 0){\\n\\t\\t\\t\\tdp[i][j][0] = Math.min(dp[i][j][0], dp[i][j][1]+1);\\n\\t\\t\\t}\\n\\t\\t\\t//could be from rotate\\n\\t\\t\\tif(possibleFromRotate && j<n && grid[i][j] == 0){\\n\\t\\t\\t\\tdp[i][j][1] = Math.min(dp[i][j][1], dp[i][j][0]+1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn (dp[n][n-1][0] >= (Integer.MAX_VALUE/2)) ? -1 : dp[n][n-1][0];       \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081462,
                "title": "java-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int n;\\n    public int minimumMoves(int[][] grid) {\\n        n = grid.length; \\n        boolean[][][] visited = new boolean[n][n][2];//[x][y][0]: right, [x][y][1] : down\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0,1});\\n        visited[0][0][0] = true;\\n        int moves = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size -- > 0) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == n - 1 && cur[1] == n - 2 && cur[2] == n - 1 && cur[3] == n - 1) {\\n                    return moves;\\n                }\\n                //next moves\\n                // rule move #1\\n                int a = cur[0], b = cur[1] + 1, c = cur[2], d = cur[3] + 1;\\n                if (isValid(a, b) && grid[a][b] == 0 && isValid(c,d) && grid[c][d] == 0) {\\n                    if (a == c) {// horizontial\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    } else { // vertial\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][1] = true;\\n                        }\\n                    }\\n                }\\n                // rule move #2\\n                a = cur[0] + 1; b = cur[1]; c = cur[2] + 1; d = cur[3];\\n                if (isValid(a, b) && grid[a][b] == 0 && isValid(c,d) && grid[c][d] == 0) {\\n                    if (a == c) {// horizontial\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    } else { // vertial\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][1] = true;\\n                        }\\n                    }\\n                }\\n                // rule move #3\\n                if (cur[0] == cur[2]) { // horizontial\\n                    if (isValid(cur[0] + 1, cur[1]) && isValid(cur[2] + 1, cur[3]) && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[2] + 1][cur[3]] == 0) {\\n                        a = cur[0]; b = cur[1]; c = cur[0] + 1; d = cur[1];\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    }\\n                } else { // vertial\\n                    if (isValid(cur[0], cur[1] + 1) && isValid(cur[2], cur[3] + 1) && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[2]][cur[3] + 1] == 0) {\\n                        a = cur[0]; b = cur[1]; c = cur[0]; d = cur[1] + 1;\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            moves ++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    boolean isValid(int x, int y) {\\n        if (x >= 0 && x < n && y >= 0 && y < n) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    public int minimumMoves(int[][] grid) {\\n        n = grid.length; \\n        boolean[][][] visited = new boolean[n][n][2];//[x][y][0]: right, [x][y][1] : down\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0,1});\\n        visited[0][0][0] = true;\\n        int moves = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size -- > 0) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == n - 1 && cur[1] == n - 2 && cur[2] == n - 1 && cur[3] == n - 1) {\\n                    return moves;\\n                }\\n                //next moves\\n                // rule move #1\\n                int a = cur[0], b = cur[1] + 1, c = cur[2], d = cur[3] + 1;\\n                if (isValid(a, b) && grid[a][b] == 0 && isValid(c,d) && grid[c][d] == 0) {\\n                    if (a == c) {// horizontial\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    } else { // vertial\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][1] = true;\\n                        }\\n                    }\\n                }\\n                // rule move #2\\n                a = cur[0] + 1; b = cur[1]; c = cur[2] + 1; d = cur[3];\\n                if (isValid(a, b) && grid[a][b] == 0 && isValid(c,d) && grid[c][d] == 0) {\\n                    if (a == c) {// horizontial\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    } else { // vertial\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][1] = true;\\n                        }\\n                    }\\n                }\\n                // rule move #3\\n                if (cur[0] == cur[2]) { // horizontial\\n                    if (isValid(cur[0] + 1, cur[1]) && isValid(cur[2] + 1, cur[3]) && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[2] + 1][cur[3]] == 0) {\\n                        a = cur[0]; b = cur[1]; c = cur[0] + 1; d = cur[1];\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    }\\n                } else { // vertial\\n                    if (isValid(cur[0], cur[1] + 1) && isValid(cur[2], cur[3] + 1) && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[2]][cur[3] + 1] == 0) {\\n                        a = cur[0]; b = cur[1]; c = cur[0]; d = cur[1] + 1;\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            moves ++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    boolean isValid(int x, int y) {\\n        if (x >= 0 && x < n && y >= 0 && y < n) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007905,
                "title": "javascript-bfs",
                "content": "**Format 1**\\n```\\nvar minimumMoves = function(grid) {\\n    let queue = [{ head: [0, 0], tail: [0, -1], isHorizontal: true }], steps = 0;\\n    const visited = new Set([\"0,0,0,-1\"]);\\n    const n = grid.length;\\n    const finalPosition = `${n - 1},${n - 1},${n - 1},${n - 2}`;\\n    const dirs = [\\n        { headMove: [0, 1], tailMove: [0, 1], extraCheckForHead: [] },\\n        { headMove: [1, 0], tailMove: [1 ,0], extraCheckForHead: [] },\\n        { headMove: [1, -1], tailMove: [0, 0], extraCheckForHead: [[1, 0]], isRotate: true, horizontal: true },\\n        { headMove: [-1, 1], tailMove: [0, 0], extraCheckForHead: [[0, 1]], isRotate: true, horizontal: false }\\n    ];\\n\\n    while (queue.length > 0) {\\n        const nextPositions = [];\\n\\n        for (const { head, tail, isHorizontal } of queue) {\\n            for (const { headMove, tailMove, extraCheckForHead, isRotate, horizontal } of dirs) {\\n                if (horizontal !== undefined && isHorizontal !== horizontal)\\n                    continue;\\n\\n                const nextHeadX = head[0] + headMove[0], nextHeadY = head[1] + headMove[1];\\n                const nextTailX = tail[0] + tailMove[0], nextTailY = tail[1] + tailMove[1];\\n                const hashCode = `${nextHeadX},${nextHeadY},${nextTailX},${nextTailY}`;\\n\\n                if (hashCode === finalPosition)\\n                    return steps;\\n\\n                if (\\n                    grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n                    grid[nextTailX] && grid[nextTailX][nextTailY] == 0 &&\\n                    !visited.has(hashCode) && \\n                    extraCheckForHead.every(([xDir, yDir]) =>\\n                        grid[xDir + head[0]] && grid[xDir + head[0]][yDir + head[1]] == 0)\\n                ) {\\n                    nextPositions.push({\\n                        head: [nextHeadX, nextHeadY],\\n                        tail: [nextTailX, nextTailY],\\n                        isHorizontal: isRotate ? !isHorizontal : isHorizontal\\n                    })\\n                    visited.add(hashCode);                    \\n                }\\n            }\\n        }\\n\\n        steps++;\\n        queue = nextPositions;\\n    }\\n    \\n    return -1;\\n};\\n```\\n**Format 2**\\n```\\nvar minimumMoves = function(grid) {\\n    let queue = [{ tail: [0, 0], isHorizontal: true }], steps = 0;\\n    const visited = new Set([\"0,0,true\"]);\\n    const n = grid.length;\\n\\n    const rotate = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] + 1 : tail[0];\\n        const nextHeadY = isHorizontal ? tail[1] : tail[1] + 1;\\n        const hashCode = `${tail[0]},${tail[1]},${!isHorizontal}`;\\n\\n        if (\\n            grid[tail[0] + 1] && grid[tail[0] + 1][tail[1] + 1] == 0 &&\\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail, isHorizontal: !isHorizontal });\\n        }\\n    };\\n    \\n    const downMove = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] + 1 : tail[0] + 2;\\n        const nextHeadY = isHorizontal ? tail[1] + 1 : tail[1];\\n        const nextTailX = tail[0] + 1, nextTailY = tail[1];\\n        const hashCode = `${nextTailX},${nextTailY},${isHorizontal}`;\\n\\n        if (\\n            grid[nextTailX] && grid[nextTailX][nextTailY] == 0 && \\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail: [nextTailX, nextTailY], isHorizontal });\\n        }\\n    };\\n    \\n    const rightMove = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] : tail[0] + 1;\\n        const nextHeadY = isHorizontal ? tail[1] + 2 : tail[1] + 1;\\n        const nextTailX = tail[0], nextTailY = tail[1] + 1;\\n        const hashCode = `${nextTailX},${nextTailY},${isHorizontal}`;\\n\\n        if (\\n            grid[nextTailX] && grid[nextTailX][nextTailY] == 0 &&\\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail: [nextTailX, nextTailY], isHorizontal });\\n        }\\n    };\\n\\n    while (queue.length > 0) {\\n        const nextPositions = [];\\n\\n        for (const { tail, isHorizontal } of queue) {\\n            if (tail[0] === n - 1 && tail[1] === n - 2)\\n                return steps;\\n\\n            rightMove(tail, isHorizontal, nextPositions), \\n            downMove(tail, isHorizontal, nextPositions), \\n            rotate(tail, isHorizontal, nextPositions)\\n        }\\n       \\n        steps++;\\n        queue = nextPositions;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minimumMoves = function(grid) {\\n    let queue = [{ head: [0, 0], tail: [0, -1], isHorizontal: true }], steps = 0;\\n    const visited = new Set([\"0,0,0,-1\"]);\\n    const n = grid.length;\\n    const finalPosition = `${n - 1},${n - 1},${n - 1},${n - 2}`;\\n    const dirs = [\\n        { headMove: [0, 1], tailMove: [0, 1], extraCheckForHead: [] },\\n        { headMove: [1, 0], tailMove: [1 ,0], extraCheckForHead: [] },\\n        { headMove: [1, -1], tailMove: [0, 0], extraCheckForHead: [[1, 0]], isRotate: true, horizontal: true },\\n        { headMove: [-1, 1], tailMove: [0, 0], extraCheckForHead: [[0, 1]], isRotate: true, horizontal: false }\\n    ];\\n\\n    while (queue.length > 0) {\\n        const nextPositions = [];\\n\\n        for (const { head, tail, isHorizontal } of queue) {\\n            for (const { headMove, tailMove, extraCheckForHead, isRotate, horizontal } of dirs) {\\n                if (horizontal !== undefined && isHorizontal !== horizontal)\\n                    continue;\\n\\n                const nextHeadX = head[0] + headMove[0], nextHeadY = head[1] + headMove[1];\\n                const nextTailX = tail[0] + tailMove[0], nextTailY = tail[1] + tailMove[1];\\n                const hashCode = `${nextHeadX},${nextHeadY},${nextTailX},${nextTailY}`;\\n\\n                if (hashCode === finalPosition)\\n                    return steps;\\n\\n                if (\\n                    grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n                    grid[nextTailX] && grid[nextTailX][nextTailY] == 0 &&\\n                    !visited.has(hashCode) && \\n                    extraCheckForHead.every(([xDir, yDir]) =>\\n                        grid[xDir + head[0]] && grid[xDir + head[0]][yDir + head[1]] == 0)\\n                ) {\\n                    nextPositions.push({\\n                        head: [nextHeadX, nextHeadY],\\n                        tail: [nextTailX, nextTailY],\\n                        isHorizontal: isRotate ? !isHorizontal : isHorizontal\\n                    })\\n                    visited.add(hashCode);                    \\n                }\\n            }\\n        }\\n\\n        steps++;\\n        queue = nextPositions;\\n    }\\n    \\n    return -1;\\n};\\n```\n```\\nvar minimumMoves = function(grid) {\\n    let queue = [{ tail: [0, 0], isHorizontal: true }], steps = 0;\\n    const visited = new Set([\"0,0,true\"]);\\n    const n = grid.length;\\n\\n    const rotate = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] + 1 : tail[0];\\n        const nextHeadY = isHorizontal ? tail[1] : tail[1] + 1;\\n        const hashCode = `${tail[0]},${tail[1]},${!isHorizontal}`;\\n\\n        if (\\n            grid[tail[0] + 1] && grid[tail[0] + 1][tail[1] + 1] == 0 &&\\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail, isHorizontal: !isHorizontal });\\n        }\\n    };\\n    \\n    const downMove = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] + 1 : tail[0] + 2;\\n        const nextHeadY = isHorizontal ? tail[1] + 1 : tail[1];\\n        const nextTailX = tail[0] + 1, nextTailY = tail[1];\\n        const hashCode = `${nextTailX},${nextTailY},${isHorizontal}`;\\n\\n        if (\\n            grid[nextTailX] && grid[nextTailX][nextTailY] == 0 && \\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail: [nextTailX, nextTailY], isHorizontal });\\n        }\\n    };\\n    \\n    const rightMove = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] : tail[0] + 1;\\n        const nextHeadY = isHorizontal ? tail[1] + 2 : tail[1] + 1;\\n        const nextTailX = tail[0], nextTailY = tail[1] + 1;\\n        const hashCode = `${nextTailX},${nextTailY},${isHorizontal}`;\\n\\n        if (\\n            grid[nextTailX] && grid[nextTailX][nextTailY] == 0 &&\\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail: [nextTailX, nextTailY], isHorizontal });\\n        }\\n    };\\n\\n    while (queue.length > 0) {\\n        const nextPositions = [];\\n\\n        for (const { tail, isHorizontal } of queue) {\\n            if (tail[0] === n - 1 && tail[1] === n - 2)\\n                return steps;\\n\\n            rightMove(tail, isHorizontal, nextPositions), \\n            downMove(tail, isHorizontal, nextPositions), \\n            rotate(tail, isHorizontal, nextPositions)\\n        }\\n       \\n        steps++;\\n        queue = nextPositions;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1877807,
                "title": "js-bfs",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumMoves = function (grid) {\\n\\tconst bfs = [[0, 1, 0], null],\\n\\t\\tn = grid.length,\\n\\t\\tdir = [\\n\\t\\t\\t[\\n\\t\\t\\t\\t//horizantal\\n\\t\\t\\t\\t[0, 1, 1], //right => h\\n\\t\\t\\t\\t[1, -1, 3], //rotate clockwise => v\\n\\t\\t\\t\\t[1, 0, 5], //jump down i j-1 => h\\n\\t\\t\\t],\\n\\t\\t\\t[\\n\\t\\t\\t\\t//vertical\\n\\t\\t\\t\\t[1, 0, 2], //down => v\\n\\t\\t\\t\\t[-1, 1, 4], //rotate counter clockwise => h\\n\\t\\t\\t\\t[0, 1, 6], //jump right i-1 j => v\\n\\t\\t\\t],\\n\\t\\t],\\n\\t\\thor = [1, 4, 5],\\n\\t\\tvisited = {},\\n\\t\\tcanVisit = (i, j, dir) =>\\n\\t\\t\\tdir < 3\\n\\t\\t\\t\\t? true\\n\\t\\t\\t\\t: dir === 3\\n\\t\\t\\t\\t? j + 1 !== n && !grid[i][j + 1]\\n\\t\\t\\t\\t: dir === 4\\n\\t\\t\\t\\t? i + 1 !== n && !grid[i + 1][j]\\n\\t\\t\\t\\t: dir === 5\\n\\t\\t\\t\\t? j && !grid[i][j - 1]\\n\\t\\t\\t\\t: i && !grid[i - 1][j],\\n\\t\\tvisit = (i, j, d) => {\\n\\t\\t\\tconst isVer = hor.includes(d) ? 0 : 1;\\n\\t\\t\\tconst key = i + \",\" + j + \",\" + isVer;\\n\\t\\t\\tif (\\n\\t\\t\\t\\ti === n ||\\n\\t\\t\\t\\tj === n ||\\n\\t\\t\\t\\ti === -1 ||\\n\\t\\t\\t\\tj === -1 ||\\n\\t\\t\\t\\tvisited[key] ||\\n\\t\\t\\t\\tgrid[i][j] ||\\n\\t\\t\\t\\t!canVisit(i, j, d)\\n\\t\\t\\t)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tvisited[key] = true;\\n\\t\\t\\tbfs.push([i, j, isVer]);\\n\\t\\t\\treturn i === n - 1 && j === n - 1 && !isVer;\\n\\t\\t};\\n\\tlet dist = 1, i = -1;\\n\\tvisited[\"0,1,0\"] = true;\\n\\t\\n\\twhile (++i < bfs.length) {\\n\\t\\tif (!bfs[i]) {\\n\\t\\t\\tdist++;\\n\\t\\t\\tif (i + 1 < bfs.length) bfs.push(null);\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tfor (const [x, y, d] of dir[bfs[i][2]])\\n\\t\\t\\tif (visit(bfs[i][0] + x, bfs[i][1] + y, d)) \\n\\t\\t\\t\\treturn dist;\\n\\t}\\n\\t\\n\\treturn -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumMoves = function (grid) {\\n\\tconst bfs = [[0, 1, 0], null],\\n\\t\\tn = grid.length,\\n\\t\\tdir = [\\n\\t\\t\\t[\\n\\t\\t\\t\\t//horizantal\\n\\t\\t\\t\\t[0, 1, 1], //right => h\\n\\t\\t\\t\\t[1, -1, 3], //rotate clockwise => v\\n\\t\\t\\t\\t[1, 0, 5], //jump down i j-1 => h\\n\\t\\t\\t],\\n\\t\\t\\t[\\n\\t\\t\\t\\t//vertical\\n\\t\\t\\t\\t[1, 0, 2], //down => v\\n\\t\\t\\t\\t[-1, 1, 4], //rotate counter clockwise => h\\n\\t\\t\\t\\t[0, 1, 6], //jump right i-1 j => v\\n\\t\\t\\t],\\n\\t\\t],\\n\\t\\thor = [1, 4, 5],\\n\\t\\tvisited = {},\\n\\t\\tcanVisit = (i, j, dir) =>\\n\\t\\t\\tdir < 3\\n\\t\\t\\t\\t? true\\n\\t\\t\\t\\t: dir === 3\\n\\t\\t\\t\\t? j + 1 !== n && !grid[i][j + 1]\\n\\t\\t\\t\\t: dir === 4\\n\\t\\t\\t\\t? i + 1 !== n && !grid[i + 1][j]\\n\\t\\t\\t\\t: dir === 5\\n\\t\\t\\t\\t? j && !grid[i][j - 1]\\n\\t\\t\\t\\t: i && !grid[i - 1][j],\\n\\t\\tvisit = (i, j, d) => {\\n\\t\\t\\tconst isVer = hor.includes(d) ? 0 : 1;\\n\\t\\t\\tconst key = i + \",\" + j + \",\" + isVer;\\n\\t\\t\\tif (\\n\\t\\t\\t\\ti === n ||\\n\\t\\t\\t\\tj === n ||\\n\\t\\t\\t\\ti === -1 ||\\n\\t\\t\\t\\tj === -1 ||\\n\\t\\t\\t\\tvisited[key] ||\\n\\t\\t\\t\\tgrid[i][j] ||\\n\\t\\t\\t\\t!canVisit(i, j, d)\\n\\t\\t\\t)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tvisited[key] = true;\\n\\t\\t\\tbfs.push([i, j, isVer]);\\n\\t\\t\\treturn i === n - 1 && j === n - 1 && !isVer;\\n\\t\\t};\\n\\tlet dist = 1, i = -1;\\n\\tvisited[\"0,1,0\"] = true;\\n\\t\\n\\twhile (++i < bfs.length) {\\n\\t\\tif (!bfs[i]) {\\n\\t\\t\\tdist++;\\n\\t\\t\\tif (i + 1 < bfs.length) bfs.push(null);\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tfor (const [x, y, d] of dir[bfs[i][2]])\\n\\t\\t\\tif (visit(bfs[i][0] + x, bfs[i][1] + y, d)) \\n\\t\\t\\t\\treturn dist;\\n\\t}\\n\\t\\n\\treturn -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836261,
                "title": "golang-bfs-solution",
                "content": "```go\\nconst (\\n\\thorizontal = 1\\n\\tvertical   = 2\\n)\\n\\nfunc minimumMoves(grid [][]int) int {\\n\\t// [rowOfTail, colOfTail, direction]\\n\\tcurrent := [3]int{0, 0, horizontal}\\n\\ttarget := [3]int{len(grid) - 1, len(grid) - 2, horizontal}\\n\\tfootprint := map[[3]int]bool{current: true}\\n\\treturn bfs(grid, footprint, [][3]int{current}, target)\\n}\\n\\nfunc bfs(grid [][]int, footprint map[[3]int]bool, current [][3]int, target [3]int) int {\\n\\tstep := 0\\n\\tfor len(current) != 0 {\\n\\t\\tnext := make([][3]int, 0, len(current))\\n\\t\\tstep++\\n\\t\\tfor _, v := range current {\\n\\t\\t\\trowTail, colTail, direction := v[0], v[1], v[2]\\n\\t\\t\\tif direction == horizontal {\\n\\t\\t\\t\\tnextRight := [3]int{rowTail, colTail + 1, direction}\\n\\t\\t\\t\\t// col of head will be colTail+2\\n\\t\\t\\t\\tif colTail+2 < len(grid) && grid[rowTail][colTail+2] == 0 && footprint[nextRight] == false {\\n\\t\\t\\t\\t\\tfootprint[nextRight] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextRight)\\n\\t\\t\\t\\t\\tif nextRight == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextDown := [3]int{rowTail + 1, colTail, direction}\\n\\t\\t\\t\\tif rowTail+1 < len(grid) && grid[rowTail+1][colTail]+grid[rowTail+1][colTail+1] == 0 && footprint[nextDown] == false {\\n\\t\\t\\t\\t\\tfootprint[nextDown] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextDown)\\n\\t\\t\\t\\t\\tif nextDown == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// change direction\\n\\t\\t\\t\\tnextTurn := [3]int{rowTail, colTail, vertical}\\n\\t\\t\\t\\tif rowTail+1 < len(grid) && grid[rowTail+1][colTail]+grid[rowTail+1][colTail+1] == 0 && footprint[nextTurn] == false {\\n\\t\\t\\t\\t\\tfootprint[nextTurn] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextTurn)\\n\\t\\t\\t\\t\\tif nextTurn == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnextDown := [3]int{rowTail + 1, colTail, direction}\\n\\t\\t\\t\\tif rowTail+2 < len(grid) && grid[rowTail+2][colTail] == 0 && footprint[nextDown] == false {\\n\\t\\t\\t\\t\\tfootprint[nextDown] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextDown)\\n\\t\\t\\t\\t\\tif nextDown == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextRight := [3]int{rowTail, colTail + 1, direction}\\n\\t\\t\\t\\tif colTail+1 < len(grid) && grid[rowTail][colTail+1]+grid[rowTail+1][colTail+1] == 0 && footprint[nextRight] == false {\\n\\t\\t\\t\\t\\tfootprint[nextRight] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextRight)\\n\\t\\t\\t\\t\\tif nextRight == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextTurn := [3]int{rowTail, colTail, horizontal}\\n\\t\\t\\t\\tif colTail+1 < len(grid) && grid[rowTail][colTail+1]+grid[rowTail+1][colTail+1] == 0 && footprint[nextTurn] == false {\\n\\t\\t\\t\\t\\tfootprint[nextTurn] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextTurn)\\n\\t\\t\\t\\t\\tif nextTurn == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```go\\nconst (\\n\\thorizontal = 1\\n\\tvertical   = 2\\n)\\n\\nfunc minimumMoves(grid [][]int) int {\\n\\t// [rowOfTail, colOfTail, direction]\\n\\tcurrent := [3]int{0, 0, horizontal}\\n\\ttarget := [3]int{len(grid) - 1, len(grid) - 2, horizontal}\\n\\tfootprint := map[[3]int]bool{current: true}\\n\\treturn bfs(grid, footprint, [][3]int{current}, target)\\n}\\n\\nfunc bfs(grid [][]int, footprint map[[3]int]bool, current [][3]int, target [3]int) int {\\n\\tstep := 0\\n\\tfor len(current) != 0 {\\n\\t\\tnext := make([][3]int, 0, len(current))\\n\\t\\tstep++\\n\\t\\tfor _, v := range current {\\n\\t\\t\\trowTail, colTail, direction := v[0], v[1], v[2]\\n\\t\\t\\tif direction == horizontal {\\n\\t\\t\\t\\tnextRight := [3]int{rowTail, colTail + 1, direction}\\n\\t\\t\\t\\t// col of head will be colTail+2\\n\\t\\t\\t\\tif colTail+2 < len(grid) && grid[rowTail][colTail+2] == 0 && footprint[nextRight] == false {\\n\\t\\t\\t\\t\\tfootprint[nextRight] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextRight)\\n\\t\\t\\t\\t\\tif nextRight == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextDown := [3]int{rowTail + 1, colTail, direction}\\n\\t\\t\\t\\tif rowTail+1 < len(grid) && grid[rowTail+1][colTail]+grid[rowTail+1][colTail+1] == 0 && footprint[nextDown] == false {\\n\\t\\t\\t\\t\\tfootprint[nextDown] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextDown)\\n\\t\\t\\t\\t\\tif nextDown == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// change direction\\n\\t\\t\\t\\tnextTurn := [3]int{rowTail, colTail, vertical}\\n\\t\\t\\t\\tif rowTail+1 < len(grid) && grid[rowTail+1][colTail]+grid[rowTail+1][colTail+1] == 0 && footprint[nextTurn] == false {\\n\\t\\t\\t\\t\\tfootprint[nextTurn] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextTurn)\\n\\t\\t\\t\\t\\tif nextTurn == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnextDown := [3]int{rowTail + 1, colTail, direction}\\n\\t\\t\\t\\tif rowTail+2 < len(grid) && grid[rowTail+2][colTail] == 0 && footprint[nextDown] == false {\\n\\t\\t\\t\\t\\tfootprint[nextDown] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextDown)\\n\\t\\t\\t\\t\\tif nextDown == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextRight := [3]int{rowTail, colTail + 1, direction}\\n\\t\\t\\t\\tif colTail+1 < len(grid) && grid[rowTail][colTail+1]+grid[rowTail+1][colTail+1] == 0 && footprint[nextRight] == false {\\n\\t\\t\\t\\t\\tfootprint[nextRight] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextRight)\\n\\t\\t\\t\\t\\tif nextRight == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextTurn := [3]int{rowTail, colTail, horizontal}\\n\\t\\t\\t\\tif colTail+1 < len(grid) && grid[rowTail][colTail+1]+grid[rowTail+1][colTail+1] == 0 && footprint[nextTurn] == false {\\n\\t\\t\\t\\t\\tfootprint[nextTurn] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextTurn)\\n\\t\\t\\t\\t\\tif nextTurn == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821124,
                "title": "c-bfs-o-n2",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n    \\n        int n=grid.size();\\n\\n        queue<array<int,4>> q;\\n        \\n        q.push({0,0,0,1});\\n        \\n        int ans=0;\\n        \\n        set<array<int,4>> st;\\n        \\n        st.insert({0,0,0,1});\\n        \\n        while(!q.empty()){\\n            \\n        \\n            int sz=q.size();\\n            \\n            while(sz--){\\n                array<int,4> ar=q.front();\\n                \\n                q.pop();\\n                \\n                if(ar[0]==n-1 and ar[1]==n-2 and ar[2]==n-1 and ar[3]==n-1)\\n                    return ans;\\n                \\n                if(ar[1]!=ar[3]){\\n                    if(ar[3]+1<n and grid[ar[2]][ar[3]+1]==0 and !st.count({ar[0],ar[1]+1,ar[2],ar[3]+1}))\\n                    {\\n                        q.push({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                        st.insert({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                    }\\n                    \\n                    if(ar[0]+1<n and grid[ar[0]+1][ar[1]]==0 and grid[ar[2]+1][ar[3]]==0 and !st.count({ar[0]+1,ar[1],ar[2]+1,ar[3]}))\\n                    {\\n                        q.push({ar[0]+1,ar[1],ar[2]+1,ar[3]});\\n                        st.insert({ar[0]+1,ar[1],ar[2]+1,ar[3]});\\n                    }\\n                    \\n                    if(ar[0]+1<n and grid[ar[0]+1][ar[1]]==0  and grid[ar[0]+1][ar[3]]==0 and !st.count({ar[0],ar[1],ar[0]+1,ar[1]}))\\n                    {\\n                        q.push({ar[0],ar[1],ar[0]+1,ar[1]});\\n                        st.insert({ar[0],ar[1],ar[0]+1,ar[1]});\\n                    }\\n                }\\n                else{\\n                    if(ar[2]+1<n and grid[ar[2]+1][ar[3]]==0 and !st.count({ar[2],ar[3],ar[2]+1,ar[3]}))\\n                    {\\n                        q.push({ar[2],ar[3],ar[2]+1,ar[3]});\\n                        st.insert({ar[2],ar[3],ar[2]+1,ar[3]});\\n                    }\\n                    \\n                    if(ar[1]+1<n and grid[ar[0]][ar[1]+1]==0 and grid[ar[2]][ar[3]+1]==0 and !st.count({ar[0],ar[1]+1,ar[2],ar[3]+1}))\\n                    {\\n                        q.push({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                        st.insert({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                    }\\n                    \\n                    if(ar[1]+1<n and grid[ar[0]][ar[1]+1]==0 and grid[ar[2]][ar[1]+1]==0 and !st.count({ar[0],ar[1],ar[0],ar[1]+1}))\\n                    {\\n                        q.push({ar[0],ar[1],ar[0],ar[1]+1});\\n                        st.insert({ar[0],ar[1],ar[0],ar[1]+1});\\n                    }\\n                }\\n                \\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n    \\n        int n=grid.size();\\n\\n        queue<array<int,4>> q;\\n        \\n        q.push({0,0,0,1});\\n        \\n        int ans=0;\\n        \\n        set<array<int,4>> st;\\n        \\n        st.insert({0,0,0,1});\\n        \\n        while(!q.empty()){\\n            \\n        \\n            int sz=q.size();\\n            \\n            while(sz--){\\n                array<int,4> ar=q.front();\\n                \\n                q.pop();\\n                \\n                if(ar[0]==n-1 and ar[1]==n-2 and ar[2]==n-1 and ar[3]==n-1)\\n                    return ans;\\n                \\n                if(ar[1]!=ar[3]){\\n                    if(ar[3]+1<n and grid[ar[2]][ar[3]+1]==0 and !st.count({ar[0],ar[1]+1,ar[2],ar[3]+1}))\\n                    {\\n                        q.push({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                        st.insert({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                    }\\n                    \\n                    if(ar[0]+1<n and grid[ar[0]+1][ar[1]]==0 and grid[ar[2]+1][ar[3]]==0 and !st.count({ar[0]+1,ar[1],ar[2]+1,ar[3]}))\\n                    {\\n                        q.push({ar[0]+1,ar[1],ar[2]+1,ar[3]});\\n                        st.insert({ar[0]+1,ar[1],ar[2]+1,ar[3]});\\n                    }\\n                    \\n                    if(ar[0]+1<n and grid[ar[0]+1][ar[1]]==0  and grid[ar[0]+1][ar[3]]==0 and !st.count({ar[0],ar[1],ar[0]+1,ar[1]}))\\n                    {\\n                        q.push({ar[0],ar[1],ar[0]+1,ar[1]});\\n                        st.insert({ar[0],ar[1],ar[0]+1,ar[1]});\\n                    }\\n                }\\n                else{\\n                    if(ar[2]+1<n and grid[ar[2]+1][ar[3]]==0 and !st.count({ar[2],ar[3],ar[2]+1,ar[3]}))\\n                    {\\n                        q.push({ar[2],ar[3],ar[2]+1,ar[3]});\\n                        st.insert({ar[2],ar[3],ar[2]+1,ar[3]});\\n                    }\\n                    \\n                    if(ar[1]+1<n and grid[ar[0]][ar[1]+1]==0 and grid[ar[2]][ar[3]+1]==0 and !st.count({ar[0],ar[1]+1,ar[2],ar[3]+1}))\\n                    {\\n                        q.push({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                        st.insert({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                    }\\n                    \\n                    if(ar[1]+1<n and grid[ar[0]][ar[1]+1]==0 and grid[ar[2]][ar[1]+1]==0 and !st.count({ar[0],ar[1],ar[0],ar[1]+1}))\\n                    {\\n                        q.push({ar[0],ar[1],ar[0],ar[1]+1});\\n                        st.insert({ar[0],ar[1],ar[0],ar[1]+1});\\n                    }\\n                }\\n                \\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746351,
                "title": "c-bottom-up-dp-recursive-relation-explanation-o-n-2",
                "content": "**State( {i,j}, orientation)** - {i,j} is position of tail, orientation is either 0 (horizontal) or 1(vertical)\\n**T( state )** = minimum number of steps to reach the end from this state.\\n**T( state )** = min_i ( T (  state_i ) ) + 1 , where state_i is a neighbor of state\\n\\n**state( (i,j) , horizontal ) neighbors** :\\n\\t\\tstate( (i,j+1), horizontal ) *Move right horizontally*\\n\\t\\tstate( (i+1,j), horizontal ) *Move down horizontally*\\n\\t\\tstate( (i,j)    , vertical      ) *Rotate clockwise*\\n\\t\\n**state( (i,j), vertical ) neighbors** :\\n\\t\\tstate( (i+1,j), vertical ) *Move down vertically*\\n\\t\\tstate( (i,j+1), vertical ) *Move right vertically*\\n\\t\\tstate( (i,j)    , horizontal ) *Rotate counter clockwise*\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        unsigned int d[n][n][2];\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<n; j++)\\n                for(int k=0; k<2; k++)\\n                    d[i][j][k] = INT_MAX;\\n        \\n        if(grid[n-1][n-1] == 1 || grid[n-1][n-2] == 1)\\n            return -1;\\n        \\n        d[n-1][n-2][0] = 0;\\n        \\n        for(int i = n-1; i>=0; i--){\\n            for(int j = n-1; j>=0; j--){\\n                if(grid[i][j] == 1)\\n                    continue;\\n                //Move right horizontally\\n                if(j+2 < n && grid[i][j+1] == 0 && grid[i][j+2] == 0)\\n                    d[i][j][0] = min({d[i][j][0], d[i][j+1][0] + 1, (unsigned int)INT_MAX});\\n                \\n                //Move right vertically or Move down horizontally\\n                if(i+1 < n && j+1 < n && grid[i][j+1] == 0 && grid[i+1][j] == 0 && grid[i+1][j+1] == 0){\\n                    d[i][j][1] = min({d[i][j][1], d[i][j+1][1] + 1, (unsigned int)INT_MAX});\\n                    d[i][j][0] = min({d[i][j][0], d[i+1][j][0] + 1, (unsigned int)INT_MAX});\\n                }\\n                \\n                //Move down vertically\\n                if(i+2 < n && grid[i+1][j] == 0 && grid[i+2][j] == 0)\\n                    d[i][j][1] = min({d[i][j][1], d[i+1][j][1] + 1, (unsigned int)INT_MAX});\\n                \\n                //Rotate\\n                if(i+1 < n && j+1 < n && grid[i][j+1] == 0 && grid[i+1][j] == 0 && grid[i+1][j+1] == 0){\\n                    d[i][j][0] = min({d[i][j][0],d[i][j][1] + 1, (unsigned int)INT_MAX});\\n                    d[i][j][1] = min({d[i][j][1],d[i][j][0] + 1, (unsigned int)INT_MAX});\\n                }\\n            }\\n        }\\n                \\n        if(d[0][0][0] == INT_MAX)\\n            return -1;\\n        else\\n            return d[0][0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        unsigned int d[n][n][2];\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<n; j++)\\n                for(int k=0; k<2; k++)\\n                    d[i][j][k] = INT_MAX;\\n        \\n        if(grid[n-1][n-1] == 1 || grid[n-1][n-2] == 1)\\n            return -1;\\n        \\n        d[n-1][n-2][0] = 0;\\n        \\n        for(int i = n-1; i>=0; i--){\\n            for(int j = n-1; j>=0; j--){\\n                if(grid[i][j] == 1)\\n                    continue;\\n                //Move right horizontally\\n                if(j+2 < n && grid[i][j+1] == 0 && grid[i][j+2] == 0)\\n                    d[i][j][0] = min({d[i][j][0], d[i][j+1][0] + 1, (unsigned int)INT_MAX});\\n                \\n                //Move right vertically or Move down horizontally\\n                if(i+1 < n && j+1 < n && grid[i][j+1] == 0 && grid[i+1][j] == 0 && grid[i+1][j+1] == 0){\\n                    d[i][j][1] = min({d[i][j][1], d[i][j+1][1] + 1, (unsigned int)INT_MAX});\\n                    d[i][j][0] = min({d[i][j][0], d[i+1][j][0] + 1, (unsigned int)INT_MAX});\\n                }\\n                \\n                //Move down vertically\\n                if(i+2 < n && grid[i+1][j] == 0 && grid[i+2][j] == 0)\\n                    d[i][j][1] = min({d[i][j][1], d[i+1][j][1] + 1, (unsigned int)INT_MAX});\\n                \\n                //Rotate\\n                if(i+1 < n && j+1 < n && grid[i][j+1] == 0 && grid[i+1][j] == 0 && grid[i+1][j+1] == 0){\\n                    d[i][j][0] = min({d[i][j][0],d[i][j][1] + 1, (unsigned int)INT_MAX});\\n                    d[i][j][1] = min({d[i][j][1],d[i][j][0] + 1, (unsigned int)INT_MAX});\\n                }\\n            }\\n        }\\n                \\n        if(d[0][0][0] == INT_MAX)\\n            return -1;\\n        else\\n            return d[0][0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666800,
                "title": "java-bfs",
                "content": "The head of the snake is at r,c \\n\\n```\\nclass Solution {\\n    \\n    class Data {\\n\\n        int r, c;\\n        int pos;\\n        int steps;\\n\\n        public Data(int row, int col, int pos, int steps) {\\n            this.r = row;\\n            this.c = col;\\n            this.pos = pos;\\n            this.steps = steps;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Data{\" +\\n                    \"r=\" + r +\\n                    \", c=\" + c +\\n                    \\'}\\';\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Data data = (Data) o;\\n            return r == data.r && c == data.c && pos == data.pos;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(r, c, pos);\\n        }\\n    }\\n\\n    private boolean inside(int row, int col, int[][] grid) {\\n        return row >= 0 && col >= 0 && row < grid.length && col < grid[row].length;\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n        Queue<Data> queue = new LinkedList<>();\\n        int n = grid.length;\\n        queue.add(new Data(0, 1, 0, 0));\\n        HashSet<Data> visited = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            Data curr = queue.poll();\\n            if (curr.r == n - 1 && curr.c == n - 1 && curr.pos == 0) {\\n                return curr.steps;\\n            }\\n            //System.out.println(curr + \" \" + curr.pos);\\n            if (!visited.contains(curr)) {\\n                visited.add(curr);\\n                if (curr.pos == 0) {\\n                    //move right\\n                    if (inside(curr.r, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r, curr.c + 1, curr.pos, curr.steps + 1));\\n                    }\\n                    //move down\\n                    if (inside(curr.r + 1, curr.c, grid) && inside(curr.r + 1, curr.c - 1, grid) && grid[curr.r + 1][curr.c - 1] == 0 && grid[curr.r + 1][curr.c] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c, curr.pos, curr.steps + 1));\\n                    }\\n                    //rotate clockwise\\n                    if (inside(curr.r + 1, curr.c, grid) && inside(curr.r + 1, curr.c - 1, grid) && curr.pos == 0 && grid[curr.r + 1][curr.c] == 0 && grid[curr.r + 1][curr.c - 1] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c - 1, 1, curr.steps + 1));\\n                    }\\n                } else if (curr.pos == 1) {\\n                    //rotate anticlockwise\\n                    if (inside(curr.r, curr.c + 1, grid) && inside(curr.r - 1, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0 && grid[curr.r - 1][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r - 1, curr.c + 1, 0, curr.steps + 1));\\n                    }\\n                    //move down\\n                    if (inside(curr.r + 1, curr.c, grid) && grid[curr.r + 1][curr.c] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c, curr.pos, curr.steps + 1));\\n                    }\\n                    //move right\\n                    if (inside(curr.r, curr.c + 1, grid) && inside(curr.r - 1, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0 && grid[curr.r - 1][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r, curr.c + 1, curr.pos, curr.steps + 1));\\n                    }\\n                }\\n            }\\n\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Data {\\n\\n        int r, c;\\n        int pos;\\n        int steps;\\n\\n        public Data(int row, int col, int pos, int steps) {\\n            this.r = row;\\n            this.c = col;\\n            this.pos = pos;\\n            this.steps = steps;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Data{\" +\\n                    \"r=\" + r +\\n                    \", c=\" + c +\\n                    \\'}\\';\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Data data = (Data) o;\\n            return r == data.r && c == data.c && pos == data.pos;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(r, c, pos);\\n        }\\n    }\\n\\n    private boolean inside(int row, int col, int[][] grid) {\\n        return row >= 0 && col >= 0 && row < grid.length && col < grid[row].length;\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n        Queue<Data> queue = new LinkedList<>();\\n        int n = grid.length;\\n        queue.add(new Data(0, 1, 0, 0));\\n        HashSet<Data> visited = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            Data curr = queue.poll();\\n            if (curr.r == n - 1 && curr.c == n - 1 && curr.pos == 0) {\\n                return curr.steps;\\n            }\\n            //System.out.println(curr + \" \" + curr.pos);\\n            if (!visited.contains(curr)) {\\n                visited.add(curr);\\n                if (curr.pos == 0) {\\n                    //move right\\n                    if (inside(curr.r, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r, curr.c + 1, curr.pos, curr.steps + 1));\\n                    }\\n                    //move down\\n                    if (inside(curr.r + 1, curr.c, grid) && inside(curr.r + 1, curr.c - 1, grid) && grid[curr.r + 1][curr.c - 1] == 0 && grid[curr.r + 1][curr.c] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c, curr.pos, curr.steps + 1));\\n                    }\\n                    //rotate clockwise\\n                    if (inside(curr.r + 1, curr.c, grid) && inside(curr.r + 1, curr.c - 1, grid) && curr.pos == 0 && grid[curr.r + 1][curr.c] == 0 && grid[curr.r + 1][curr.c - 1] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c - 1, 1, curr.steps + 1));\\n                    }\\n                } else if (curr.pos == 1) {\\n                    //rotate anticlockwise\\n                    if (inside(curr.r, curr.c + 1, grid) && inside(curr.r - 1, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0 && grid[curr.r - 1][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r - 1, curr.c + 1, 0, curr.steps + 1));\\n                    }\\n                    //move down\\n                    if (inside(curr.r + 1, curr.c, grid) && grid[curr.r + 1][curr.c] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c, curr.pos, curr.steps + 1));\\n                    }\\n                    //move right\\n                    if (inside(curr.r, curr.c + 1, grid) && inside(curr.r - 1, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0 && grid[curr.r - 1][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r, curr.c + 1, curr.pos, curr.steps + 1));\\n                    }\\n                }\\n            }\\n\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656775,
                "title": "python-bfs-template-explanation",
                "content": "* My BFS state space consists of 3 attributes - (row, col, state \\'H\\' or \\'V\\') where row and col are indices of snake head and state is the orientation of the snake, and I track distance throughtout the algo.\\n* All possible moves are listed in findNeighbors function.\\n* Let me know in the comments if you have any questions.\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        def findNeighbors(head, state):\\n            actual = []\\n            x, y = head\\n            if state == \\'H\\':\\n                # go right when horizontal\\n                if y + 1 <= n - 1 and grid[x][y + 1] == 0:\\n                    actual.append((x, y + 1, \\'H\\'))\\n                    \\n                # go down when horizontal\\n                if x + 1 <= n - 1 and grid[x + 1][y] == 0 and grid[x + 1][y - 1] == 0:\\n                    actual.append((x + 1, y, \\'H\\'))\\n                    \\n                    # can rotate clkwise here\\n                    actual.append((x + 1, y - 1, \\'V\\'))\\n                    \\n            else:\\n                # go down when vertical\\n                if x + 1 <= n - 1 and grid[x + 1][y] == 0:\\n                    actual.append((x + 1, y, \\'V\\'))\\n                    \\n                # go right when vertical\\n                if y + 1 <= n - 1 and grid[x][y + 1] == 0 and grid[x - 1][y + 1] == 0:\\n                    actual.append((x, y + 1, \\'V\\'))\\n                    \\n                    # can rotate anti clkwise here\\n                    actual.append((x - 1, y + 1, \\'H\\'))\\n                    \\n            return actual\\n        \\n        visited = set()\\n        q = deque()\\n        q.append((0, 1, \\'H\\', 0))\\n        \\n        while q:\\n            x, y, state, dist = q.popleft()\\n            if (x, y, state) == (n - 1, n - 1, \\'H\\'):\\n                return dist\\n            \\n            if (x, y, state) in visited:\\n                continue\\n                \\n            visited.add((x, y, state))\\n            \\n            for nx, ny, ndir in findNeighbors((x, y), state):\\n                q.append((nx, ny, ndir, dist + 1))\\n                \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "* My BFS state space consists of 3 attributes - (row, col, state \\'H\\' or \\'V\\') where row and col are indices of snake head and state is the orientation of the snake, and I track distance throughtout the algo.\\n* All possible moves are listed in findNeighbors function.\\n* Let me know in the comments if you have any questions.\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        def findNeighbors(head, state):\\n            actual = []\\n            x, y = head\\n            if state == \\'H\\':\\n                # go right when horizontal\\n                if y + 1 <= n - 1 and grid[x][y + 1] == 0:\\n                    actual.append((x, y + 1, \\'H\\'))\\n                    \\n                # go down when horizontal\\n                if x + 1 <= n - 1 and grid[x + 1][y] == 0 and grid[x + 1][y - 1] == 0:\\n                    actual.append((x + 1, y, \\'H\\'))\\n                    \\n                    # can rotate clkwise here\\n                    actual.append((x + 1, y - 1, \\'V\\'))\\n                    \\n            else:\\n                # go down when vertical\\n                if x + 1 <= n - 1 and grid[x + 1][y] == 0:\\n                    actual.append((x + 1, y, \\'V\\'))\\n                    \\n                # go right when vertical\\n                if y + 1 <= n - 1 and grid[x][y + 1] == 0 and grid[x - 1][y + 1] == 0:\\n                    actual.append((x, y + 1, \\'V\\'))\\n                    \\n                    # can rotate anti clkwise here\\n                    actual.append((x - 1, y + 1, \\'H\\'))\\n                    \\n            return actual\\n        \\n        visited = set()\\n        q = deque()\\n        q.append((0, 1, \\'H\\', 0))\\n        \\n        while q:\\n            x, y, state, dist = q.popleft()\\n            if (x, y, state) == (n - 1, n - 1, \\'H\\'):\\n                return dist\\n            \\n            if (x, y, state) in visited:\\n                continue\\n                \\n            visited.add((x, y, state))\\n            \\n            for nx, ny, ndir in findNeighbors((x, y), state):\\n                q.append((nx, ny, ndir, dist + 1))\\n                \\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 1649475,
                "title": "java-bfs-with-memoization-with-explanation",
                "content": "A few nits about this problem that I found myself overlooked when solving it that led to long time of debugging:\\n1. snake needs to have its head at (n-1, n-1) in a **horizontal** position, so just landing at bottom right is not enough\\n2. when rotating clockwise or counter-clockwise, the 2 elements below/to the right of the current positions of snake need to **both** be 0\\n\\n\\nIn my algorithm I transformed the problem to be the minimal number of steps needed to have head of snake in bottom right in a horizontal position, then the idea of this algorithm is ordinary BFS: given any element in the array, check if snake can have its head in this position, and if so, depending on legit directions it can be, can be either horizontal or vertical, find all the possible next positions of head.\\n\\ncode snippet\\n```\\n\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        Boolean[][] right = new Boolean[rows][columns]; // if head at (i, j) can be horizontal\\n        Boolean[][] down = new Boolean[rows][columns]; // if head at (i, j) can be vertical\\n        int[][] minMovesRight = new int[rows][columns]; // min moves ending with head at (i,j) horizontally\\n        int[][] minMovesDown = new int[rows][columns]; // min moves ending with head at (i,j) vertically\\n        Boolean[][] visited = new Boolean[rows][columns]; // if head at (i, j) is already visited of its neighbors\\n        Queue<int[]> cellsToVisit = new LinkedList<>();\\n        // initalize values\\n        for (int i = 0; i < rows; i++) {\\n            Arrays.fill(minMovesRight[i], -1);\\n            Arrays.fill(minMovesDown[i], -1);\\n            Arrays.fill(right[i], false);\\n            Arrays.fill(down[i], false);\\n            Arrays.fill(visited[i], false);\\n        }\\n\\t\\t// we know snake head is initialized horizontally in (0, 1)\\n        right[0][1] = true;\\n        minMovesRight[0][1] = 0;\\n        cellsToVisit.add(new int[]{0, 1});\\n        \\n        while (cellsToVisit.size() > 0) {\\n            int[] cell = cellsToVisit.poll();\\n            int x = cell[0];\\n            int y = cell[1];\\n            if (visited[x][y]) {\\n                continue;\\n            }\\n            visited[x][y] = true;\\n            // if head can be at (x, y) horizontally, check (x, y+1), (x+1, y-1) and (x+1, y)\\n            if (right[x][y] == true) {\\n                if (y+1 < columns && grid[x][y+1] == 0) {\\n                    right[x][y+1] = true;\\n                    cellsToVisit.add(new int[]{x, y+1});\\n                    minMovesRight[x][y+1] = minMovesRight[x][y+1] == -1\\n                            ? minMovesRight[x][y] + 1\\n                            : Math.min(minMovesRight[x][y+1], minMovesRight[x][y] + 1);\\n                }\\n                // now check if we can rotate clock-wise or downward by 1 row\\n                if (x+1 < rows && y-1 >= 0 && grid[x+1][y-1] == 0 && grid[x+1][y] == 0) {\\n                    // rotate clock-wise\\n                    down[x+1][y-1] = true;\\n                    minMovesDown[x+1][y-1] = minMovesDown[x+1][y-1] == -1\\n                        ? minMovesRight[x][y] + 1\\n                        : Math.min(minMovesDown[x+1][y-1], minMovesRight[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y-1});\\n                    // move downward by 1 row\\n                    right[x+1][y] = true;\\n                    minMovesRight[x+1][y] = minMovesRight[x+1][y] == -1\\n                        ? minMovesRight[x][y] + 1\\n                        : Math.min(minMovesRight[x+1][y], minMovesRight[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y});\\n                }\\n            }\\n            \\n            // if head can be at (x, y) vertically, check (x+1, y), (x-1, y+1) and (x, y+1) \\n            if (down[x][y] == true) {\\n                if (x+1 < rows && grid[x+1][y] == 0) {\\n                    down[x+1][y] = true;\\n                    minMovesDown[x+1][y] = minMovesDown[x+1][y] == -1\\n                            ? minMovesDown[x][y] + 1\\n                            : Math.min(minMovesDown[x+1][y], minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y});\\n                }\\n                // now check if we can rotate counter-clock-wise or right-ward by 1 column\\n                if (y+1 < columns && x-1 >= 0 && grid[x-1][y+1] == 0 && grid[x][y+1] == 0) {\\n                    // rotate counter-clockwise\\n                    right[x-1][y+1] = true;\\n                    minMovesRight[x-1][y+1] = minMovesRight[x-1][y+1] == -1\\n                            ? minMovesDown[x][y] + 1\\n                            : Math.min(minMovesRight[x-1][y+1], minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x-1, y+1});\\n                    // move right-ward by one column\\n                    down[x][y+1] = true;\\n                    minMovesDown[x][y+1] = minMovesDown[x][y+1] == -1\\n                        ? minMovesDown[x][y] + 1\\n                        : Math.min(minMovesDown[x][y+1],  minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x, y+1});\\n                }\\n            }\\n        }\\n        \\n        // Now after traversing, return last element\\n        return minMovesRight[rows-1][columns-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        Boolean[][] right = new Boolean[rows][columns]; // if head at (i, j) can be horizontal\\n        Boolean[][] down = new Boolean[rows][columns]; // if head at (i, j) can be vertical\\n        int[][] minMovesRight = new int[rows][columns]; // min moves ending with head at (i,j) horizontally\\n        int[][] minMovesDown = new int[rows][columns]; // min moves ending with head at (i,j) vertically\\n        Boolean[][] visited = new Boolean[rows][columns]; // if head at (i, j) is already visited of its neighbors\\n        Queue<int[]> cellsToVisit = new LinkedList<>();\\n        // initalize values\\n        for (int i = 0; i < rows; i++) {\\n            Arrays.fill(minMovesRight[i], -1);\\n            Arrays.fill(minMovesDown[i], -1);\\n            Arrays.fill(right[i], false);\\n            Arrays.fill(down[i], false);\\n            Arrays.fill(visited[i], false);\\n        }\\n\\t\\t// we know snake head is initialized horizontally in (0, 1)\\n        right[0][1] = true;\\n        minMovesRight[0][1] = 0;\\n        cellsToVisit.add(new int[]{0, 1});\\n        \\n        while (cellsToVisit.size() > 0) {\\n            int[] cell = cellsToVisit.poll();\\n            int x = cell[0];\\n            int y = cell[1];\\n            if (visited[x][y]) {\\n                continue;\\n            }\\n            visited[x][y] = true;\\n            // if head can be at (x, y) horizontally, check (x, y+1), (x+1, y-1) and (x+1, y)\\n            if (right[x][y] == true) {\\n                if (y+1 < columns && grid[x][y+1] == 0) {\\n                    right[x][y+1] = true;\\n                    cellsToVisit.add(new int[]{x, y+1});\\n                    minMovesRight[x][y+1] = minMovesRight[x][y+1] == -1\\n                            ? minMovesRight[x][y] + 1\\n                            : Math.min(minMovesRight[x][y+1], minMovesRight[x][y] + 1);\\n                }\\n                // now check if we can rotate clock-wise or downward by 1 row\\n                if (x+1 < rows && y-1 >= 0 && grid[x+1][y-1] == 0 && grid[x+1][y] == 0) {\\n                    // rotate clock-wise\\n                    down[x+1][y-1] = true;\\n                    minMovesDown[x+1][y-1] = minMovesDown[x+1][y-1] == -1\\n                        ? minMovesRight[x][y] + 1\\n                        : Math.min(minMovesDown[x+1][y-1], minMovesRight[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y-1});\\n                    // move downward by 1 row\\n                    right[x+1][y] = true;\\n                    minMovesRight[x+1][y] = minMovesRight[x+1][y] == -1\\n                        ? minMovesRight[x][y] + 1\\n                        : Math.min(minMovesRight[x+1][y], minMovesRight[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y});\\n                }\\n            }\\n            \\n            // if head can be at (x, y) vertically, check (x+1, y), (x-1, y+1) and (x, y+1) \\n            if (down[x][y] == true) {\\n                if (x+1 < rows && grid[x+1][y] == 0) {\\n                    down[x+1][y] = true;\\n                    minMovesDown[x+1][y] = minMovesDown[x+1][y] == -1\\n                            ? minMovesDown[x][y] + 1\\n                            : Math.min(minMovesDown[x+1][y], minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y});\\n                }\\n                // now check if we can rotate counter-clock-wise or right-ward by 1 column\\n                if (y+1 < columns && x-1 >= 0 && grid[x-1][y+1] == 0 && grid[x][y+1] == 0) {\\n                    // rotate counter-clockwise\\n                    right[x-1][y+1] = true;\\n                    minMovesRight[x-1][y+1] = minMovesRight[x-1][y+1] == -1\\n                            ? minMovesDown[x][y] + 1\\n                            : Math.min(minMovesRight[x-1][y+1], minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x-1, y+1});\\n                    // move right-ward by one column\\n                    down[x][y+1] = true;\\n                    minMovesDown[x][y+1] = minMovesDown[x][y+1] == -1\\n                        ? minMovesDown[x][y] + 1\\n                        : Math.min(minMovesDown[x][y+1],  minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x, y+1});\\n                }\\n            }\\n        }\\n        \\n        // Now after traversing, return last element\\n        return minMovesRight[rows-1][columns-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572840,
                "title": "java-bfs-dude-your-snake-can-shade-step",
                "content": "For people who are 1) struggling with the horizontal and vertical movement of the snake and 2) plays many action RPG games, your snake can shade step OR quick step its entire fuking body to its right and down cells!!!\\n\\nSay your ninjia snake is \\n\\n| 0\\n| 0\\n\\nAnd this guy can move its entire body to the right! What a lengendary snake!\\n0 |\\n0 |\\n\\nThe same thing holds for the snake\\'s horizontal position:\\n~~\\n0 0\\n\\ncan get to \\n0 0\\n~~\\n\\nFiguring out this property costs 1 hour of trial and error. Yet, figuring out the core logic to solve this problem only cost around 10 minutes: BFS shortest path finder + visited state checking. By the way, the question hands out additional candies: the implementation on visiting neighboring states, is fuking disgusting.\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // BFS with visited states.\\n        int n = grid.length;\\n        // int state[i,j] means the tail of snake. \\n        // 00 means pure empty.\\n        // 01 means head pointing right is visited.\\n        // 10 means head pointing down is visited.\\n        // 11 means both dir visited.\\n        int[][] visited = new int[n][n];\\n        Queue<int[]> bq = new LinkedList<>();\\n        bq.offer(new int[]{0, 0, 1});\\n        visited[0][0] |= 1;\\n        \\n        int level = 0;\\n        while (!bq.isEmpty()) {\\n            int levelSize = bq.size();\\n            for (int l = 0; l < levelSize; l++) {\\n                int[] cur = bq.poll();\\n                int xtail = cur[0], ytail = cur[1], dir = cur[2];\\n                if (xtail == n - 1 &&\\n                    ytail == n - 2 &&\\n                    dir == 1) {\\n                    return level;\\n                }\\n                \\n                int xhead = xtail + (dir == 1 ? 0 : 1);\\n                int yhead = ytail + (dir == 1 ? 1 : 0);\\n                \\n                // Expansion\\n                // Now the disgusting begins...\\n                if (dir == 2) {\\n                    // vertical snake, if its right vertical cells\\n                    // are both empty, we do stuff.\\n                    if (ytail + 1 < n &&\\n                        grid[xtail][ytail+1] != 1 &&\\n                        grid[xtail+1][ytail+1] != 1) {\\n                        if ((visited[xtail][ytail] & 1) == 0) {\\n                            bq.offer(new int[]{xtail, ytail, 1});\\n                            visited[xtail][ytail] |= 1;    \\n                        }\\n                        \\n                        if ((visited[xtail][ytail+1] & 2) == 0) {\\n                            bq.offer(new int[]{xtail, ytail+1, 2});\\n                            visited[xtail][ytail+1] |= 2;\\n                        }\\n                    }\\n                    \\n                    // move down\\n                    if (xhead + 1 < n && \\n                        grid[xhead+1][yhead] != 1 &&\\n                        (visited[xhead][yhead] & 2) == 0) {\\n                        bq.offer(new int[]{xhead, yhead, 2});\\n                        visited[xhead][yhead] |= 2;\\n                    }\\n                } else {\\n                    // ~~ horizontal snake, if its below are \\n                    // empty cells, we do stuff.\\n                    if (xtail + 1 < n &&\\n                        grid[xtail+1][ytail] != 1 &&\\n                        grid[xtail+1][ytail+1] != 1) {\\n                        if ((visited[xtail][ytail] & 2) == 0) {\\n                            bq.offer(new int[]{xtail, ytail, 2});\\n                            visited[xtail][ytail] |= 2;    \\n                        }\\n                        \\n                        if ((visited[xtail+1][ytail] & 1) == 0) {\\n                            bq.offer(new int[]{xtail+1, ytail, 1});\\n                            visited[xtail+1][ytail] |= 1;\\n                        }\\n                    }\\n                    \\n                    // move ->\\n                    if (yhead + 1 < n &&\\n                        grid[xhead][yhead + 1] != 1 &&\\n                        (visited[xhead][yhead] & 1) == 0) {\\n                        bq.offer(new int[]{xhead, yhead, 1});\\n                        visited[xhead][yhead] |= 1;\\n                    }\\n                }\\n            }\\n            \\n            level += 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\nComplexity:\\n- Time O(2* n^2). Snake\\'s valid state can be n^2 locations, and each location has 2 directions. In BFS path finder, we will not revisit a given state if it has been reach before. We will only costing more steps when visiting the visited state, thus always leading to worse solutions in the future.\\n- Space O(n^2) the integer visited map.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // BFS with visited states.\\n        int n = grid.length;\\n        // int state[i,j] means the tail of snake. \\n        // 00 means pure empty.\\n        // 01 means head pointing right is visited.\\n        // 10 means head pointing down is visited.\\n        // 11 means both dir visited.\\n        int[][] visited = new int[n][n];\\n        Queue<int[]> bq = new LinkedList<>();\\n        bq.offer(new int[]{0, 0, 1});\\n        visited[0][0] |= 1;\\n        \\n        int level = 0;\\n        while (!bq.isEmpty()) {\\n            int levelSize = bq.size();\\n            for (int l = 0; l < levelSize; l++) {\\n                int[] cur = bq.poll();\\n                int xtail = cur[0], ytail = cur[1], dir = cur[2];\\n                if (xtail == n - 1 &&\\n                    ytail == n - 2 &&\\n                    dir == 1) {\\n                    return level;\\n                }\\n                \\n                int xhead = xtail + (dir == 1 ? 0 : 1);\\n                int yhead = ytail + (dir == 1 ? 1 : 0);\\n                \\n                // Expansion\\n                // Now the disgusting begins...\\n                if (dir == 2) {\\n                    // vertical snake, if its right vertical cells\\n                    // are both empty, we do stuff.\\n                    if (ytail + 1 < n &&\\n                        grid[xtail][ytail+1] != 1 &&\\n                        grid[xtail+1][ytail+1] != 1) {\\n                        if ((visited[xtail][ytail] & 1) == 0) {\\n                            bq.offer(new int[]{xtail, ytail, 1});\\n                            visited[xtail][ytail] |= 1;    \\n                        }\\n                        \\n                        if ((visited[xtail][ytail+1] & 2) == 0) {\\n                            bq.offer(new int[]{xtail, ytail+1, 2});\\n                            visited[xtail][ytail+1] |= 2;\\n                        }\\n                    }\\n                    \\n                    // move down\\n                    if (xhead + 1 < n && \\n                        grid[xhead+1][yhead] != 1 &&\\n                        (visited[xhead][yhead] & 2) == 0) {\\n                        bq.offer(new int[]{xhead, yhead, 2});\\n                        visited[xhead][yhead] |= 2;\\n                    }\\n                } else {\\n                    // ~~ horizontal snake, if its below are \\n                    // empty cells, we do stuff.\\n                    if (xtail + 1 < n &&\\n                        grid[xtail+1][ytail] != 1 &&\\n                        grid[xtail+1][ytail+1] != 1) {\\n                        if ((visited[xtail][ytail] & 2) == 0) {\\n                            bq.offer(new int[]{xtail, ytail, 2});\\n                            visited[xtail][ytail] |= 2;    \\n                        }\\n                        \\n                        if ((visited[xtail+1][ytail] & 1) == 0) {\\n                            bq.offer(new int[]{xtail+1, ytail, 1});\\n                            visited[xtail+1][ytail] |= 1;\\n                        }\\n                    }\\n                    \\n                    // move ->\\n                    if (yhead + 1 < n &&\\n                        grid[xhead][yhead + 1] != 1 &&\\n                        (visited[xhead][yhead] & 1) == 0) {\\n                        bq.offer(new int[]{xhead, yhead, 1});\\n                        visited[xhead][yhead] |= 1;\\n                    }\\n                }\\n            }\\n            \\n            level += 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552365,
                "title": "c-dp-solution",
                "content": "```\\n\\n        public int DpSolution(int[][] grid)\\n        {\\n            int n = grid.Length, m = grid[0].Length;\\n\\n            // \\u68C0\\u67E5\\u7EC8\\u70B9\\u662F\\u5426\\u88AB\\u963B\\u585E\\n            if (grid[n - 1][m - 1] != 0 || grid[n - 1][m - 2] != 0) return -1;\\n\\n            // \\u5B9A\\u4E49dp[\\u7B2C\\u4E00\\u4E2A\\u90E8\\u4F4D\\u4F4D\\u7F6E][\\u90E8\\u4F4D\\u65B9\\u5411\\uFF080 \\u8868\\u793A\\u6C34\\u5E73, 1 \\u8868\\u793A\\u5782\\u76F4\\uFF09] = \\u5230\\u8FBE\\u7EC8\\u70B9\\u6240\\u9700\\u7684\\u6700\\u5C0F\\n            // \\u4F8B\\uFF1A[x, x  \\uFF1A \\u8868\\u793A \\u4F4D\\u7F6E[0][0] \\u6C34\\u5E73\\u65B9\\u5411 \\n            int?[][][] dp = new int?[n][][];\\n            for (int i = 0; i < n; i++)\\n            {\\n                var arr = dp[i] = new int?[m][];\\n                for (int j = 0; j < m; j++)\\n                {\\n                    arr[j] = new int?[2];\\n                }\\n            }\\n\\n            // \\u521D\\u59CB\\u5316\\u7EC8\\u70B9\\u4E3A0\\n            dp[n - 1][m - 2][0] = 0;\\n\\n            // \\u521D\\u59CB\\u5316\\u6700\\u540E\\u4E00\\u884C\\n            for (int i = m - 3, count = 1; i >= 0; i--, count++)\\n            {\\n                // \\u6700\\u540E\\u4E00\\u884C\\u7531\\u4E8E\\u4F4D\\u7F6E\\u539F\\u56E0\\u53EA\\u80FD\\u6C34\\u5E73\\u79FB\\u52A8\\uFF0C\\u6CA1\\u6709\\u5176\\u4ED6\\u79FB\\u52A8\\u65B9\\u6848\\n                if (grid[n - 1][i] != 1)\\n                {\\n                    dp[n - 1][i][0] = count;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            for (int i = n - 2; i >= 0; i--)\\n            {\\n                for (int j = m - 2; j >= 0; j--)\\n                {\\n                    if (grid[i][j] == 1) continue;\\n\\n                    var curr = dp[i][j];\\n                    int? horizontal = null, vertical = null;\\n\\n                    #region horizontal\\n                    // \\u6C34\\u5E73\\u79FB\\u52A8\\n                    if (grid[i][j + 1] == 0)\\n                    {\\n                        int res = int.MaxValue;\\n                        // move right\\n                        var right = dp[i][j + 1][0];\\n                        if (right.HasValue)\\n                        {\\n                            res = 1 + right.Value;\\n                        }\\n\\n                        // move bottom\\n                        var bottom = dp[i + 1][j][0];\\n                        if (bottom.HasValue)\\n                        {\\n                            res = Math.Min(res, 1 + bottom.Value);\\n                        }\\n                        if (res != int.MaxValue)\\n                        {\\n                            horizontal = curr[0] = res;\\n                        }\\n                    }\\n                    #endregion\\n\\n                    #region vertical\\n                    // \\u5782\\u76F4\\u79FB\\u52A8\\n                    if (grid[i + 1][j] == 0)\\n                    {\\n                        int res = int.MaxValue;\\n                        // move right\\n                        var right = dp[i][j + 1][1];\\n                        if (right.HasValue)\\n                        {\\n                            res = 1 + right.Value;\\n                        }\\n\\n                        // move bottom\\n                        var bottom = dp[i + 1][j][1];\\n                        if (bottom.HasValue)\\n                        {\\n                            res = Math.Min(res, 1 + bottom.Value);\\n                        }\\n                        if (res != int.MaxValue)\\n                        {\\n                            vertical = curr[1] = res;\\n                        }\\n                    }\\n                    #endregion\\n\\n                    #region rotate\\n                    // \\u66F4\\u6539\\u5360\\u4F4D\\n                    {\\n\\n                        if (grid[i + 1][j + 1] == 0)\\n                        {\\n                            if (horizontal.HasValue && !vertical.HasValue)\\n                            {\\n                                if (grid[i + 1][j] == 0)\\n                                {\\n                                    curr[1] = curr[0] + 1;\\n                                }\\n                            }\\n                            else if (!horizontal.HasValue && vertical.HasValue)\\n                            {\\n                                if (grid[i][j + 1] == 0)\\n                                {\\n                                    curr[0] = curr[1] + 1;\\n                                }\\n                            }\\n                            else if (horizontal.HasValue && vertical.HasValue)\\n                            {\\n                                curr[0] = Math.Min(curr[0].Value, vertical.Value + 1);\\n                                curr[1] = Math.Min(curr[1].Value, horizontal.Value + 1);\\n                            }\\n                        }\\n\\n                    }\\n                    #endregion\\n                }\\n            }\\n            var t = dp[0][0][0];\\n            return t.HasValue ? t.Value : -1;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n        public int DpSolution(int[][] grid)\\n        {\\n            int n = grid.Length, m = grid[0].Length;\\n\\n            // \\u68C0\\u67E5\\u7EC8\\u70B9\\u662F\\u5426\\u88AB\\u963B\\u585E\\n            if (grid[n - 1][m - 1] != 0 || grid[n - 1][m - 2] != 0) return -1;\\n\\n            // \\u5B9A\\u4E49dp[\\u7B2C\\u4E00\\u4E2A\\u90E8\\u4F4D\\u4F4D\\u7F6E][\\u90E8\\u4F4D\\u65B9\\u5411\\uFF080 \\u8868\\u793A\\u6C34\\u5E73, 1 \\u8868\\u793A\\u5782\\u76F4\\uFF09] = \\u5230\\u8FBE\\u7EC8\\u70B9\\u6240\\u9700\\u7684\\u6700\\u5C0F\\n            // \\u4F8B\\uFF1A[x, x  \\uFF1A \\u8868\\u793A \\u4F4D\\u7F6E[0][0] \\u6C34\\u5E73\\u65B9\\u5411 \\n            int?[][][] dp = new int?[n][][];\\n            for (int i = 0; i < n; i++)\\n            {\\n                var arr = dp[i] = new int?[m][];\\n                for (int j = 0; j < m; j++)\\n                {\\n                    arr[j] = new int?[2];\\n                }\\n            }\\n\\n            // \\u521D\\u59CB\\u5316\\u7EC8\\u70B9\\u4E3A0\\n            dp[n - 1][m - 2][0] = 0;\\n\\n            // \\u521D\\u59CB\\u5316\\u6700\\u540E\\u4E00\\u884C\\n            for (int i = m - 3, count = 1; i >= 0; i--, count++)\\n            {\\n                // \\u6700\\u540E\\u4E00\\u884C\\u7531\\u4E8E\\u4F4D\\u7F6E\\u539F\\u56E0\\u53EA\\u80FD\\u6C34\\u5E73\\u79FB\\u52A8\\uFF0C\\u6CA1\\u6709\\u5176\\u4ED6\\u79FB\\u52A8\\u65B9\\u6848\\n                if (grid[n - 1][i] != 1)\\n                {\\n                    dp[n - 1][i][0] = count;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            for (int i = n - 2; i >= 0; i--)\\n            {\\n                for (int j = m - 2; j >= 0; j--)\\n                {\\n                    if (grid[i][j] == 1) continue;\\n\\n                    var curr = dp[i][j];\\n                    int? horizontal = null, vertical = null;\\n\\n                    #region horizontal\\n                    // \\u6C34\\u5E73\\u79FB\\u52A8\\n                    if (grid[i][j + 1] == 0)\\n                    {\\n                        int res = int.MaxValue;\\n                        // move right\\n                        var right = dp[i][j + 1][0];\\n                        if (right.HasValue)\\n                        {\\n                            res = 1 + right.Value;\\n                        }\\n\\n                        // move bottom\\n                        var bottom = dp[i + 1][j][0];\\n                        if (bottom.HasValue)\\n                        {\\n                            res = Math.Min(res, 1 + bottom.Value);\\n                        }\\n                        if (res != int.MaxValue)\\n                        {\\n                            horizontal = curr[0] = res;\\n                        }\\n                    }\\n                    #endregion\\n\\n                    #region vertical\\n                    // \\u5782\\u76F4\\u79FB\\u52A8\\n                    if (grid[i + 1][j] == 0)\\n                    {\\n                        int res = int.MaxValue;\\n                        // move right\\n                        var right = dp[i][j + 1][1];\\n                        if (right.HasValue)\\n                        {\\n                            res = 1 + right.Value;\\n                        }\\n\\n                        // move bottom\\n                        var bottom = dp[i + 1][j][1];\\n                        if (bottom.HasValue)\\n                        {\\n                            res = Math.Min(res, 1 + bottom.Value);\\n                        }\\n                        if (res != int.MaxValue)\\n                        {\\n                            vertical = curr[1] = res;\\n                        }\\n                    }\\n                    #endregion\\n\\n                    #region rotate\\n                    // \\u66F4\\u6539\\u5360\\u4F4D\\n                    {\\n\\n                        if (grid[i + 1][j + 1] == 0)\\n                        {\\n                            if (horizontal.HasValue && !vertical.HasValue)\\n                            {\\n                                if (grid[i + 1][j] == 0)\\n                                {\\n                                    curr[1] = curr[0] + 1;\\n                                }\\n                            }\\n                            else if (!horizontal.HasValue && vertical.HasValue)\\n                            {\\n                                if (grid[i][j + 1] == 0)\\n                                {\\n                                    curr[0] = curr[1] + 1;\\n                                }\\n                            }\\n                            else if (horizontal.HasValue && vertical.HasValue)\\n                            {\\n                                curr[0] = Math.Min(curr[0].Value, vertical.Value + 1);\\n                                curr[1] = Math.Min(curr[1].Value, horizontal.Value + 1);\\n                            }\\n                        }\\n\\n                    }\\n                    #endregion\\n                }\\n            }\\n            var t = dp[0][0][0];\\n            return t.HasValue ? t.Value : -1;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1501836,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\n    struct snake {\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        int step;\\n        snake(int r1_, int r2_, int c1_, int c2_, int step_) {\\n            r1 = r1_;\\n            c1 = c1_;\\n            r2 = r2_;\\n            c2 = c2_;\\n            step = step_;\\n        }\\n    };\\n    \\n    string toString(snake& s) {\\n        return to_string(s.r1) + \",\" + to_string(s.c1) + \", \" + to_string(s.r2) + \",\" + to_string(s.c2);\\n    }\\n    \\n    void maybeAddNextStep(queue<snake>& q, unordered_set<string>& visited, int r1, int r2, int c1, int c2, int step) {\\n        snake s_nxt = snake(r1, r2, c1, c2, step);\\n        string s_string = toString(s_nxt);\\n        if(!visited.count(s_string)) {\\n            visited.insert(s_string);\\n            q.push(s_nxt);\\n        }        \\n    }\\n    \\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        snake start = snake(0, 0, 0, 1, 0);\\n        unordered_set<string> visited;\\n        \\n        int step = 0;\\n        queue<snake> q;\\n        q.push(start);\\n        \\n        while(!q.empty()) {\\n            auto s = q.front();\\n            \\n            q.pop();\\n            \\n            // reach the end\\n            if(s.r1 == m-1 && s.r2 == m-1 && s.c1 == n-2 && s.c2 == n-1) {\\n                return s.step;\\n            }\\n            \\n            // down\\n            if(s.r1 + 1 < m && s.r2 + 1 < m && grid[s.r1+1][s.c1] == 0 && grid[s.r2+1][s.c2] == 0) {\\n                maybeAddNextStep(q, visited, s.r1+1, s.r2+1, s.c1, s.c2, s.step+1);\\n            }\\n            \\n            // right\\n            if(s.c1 + 1 < n && s.c2 + 1 < n && grid[s.r1][s.c1+1] == 0 && grid[s.r2][s.c2+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r2, s.c1+1, s.c2+1, s.step+1);\\n            }\\n            \\n            // clockwise\\n            if(s.c2 == s.c1 + 1 && s.r1+1 < m && grid[s.r1+1][s.c1] == 0 && grid[s.r1+1][s.c1+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r1+1, s.c1, s.c1, s.step+1);               \\n            }\\n            \\n            //counter-clockwise\\n            if(s.r2 == s.r1 + 1 && s.c1+1 < n && grid[s.r1][s.c1+1] == 0 && grid[s.r1+1][s.c1+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r1, s.c1, s.c1+1, s.step+1);            \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct snake {\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        int step;\\n        snake(int r1_, int r2_, int c1_, int c2_, int step_) {\\n            r1 = r1_;\\n            c1 = c1_;\\n            r2 = r2_;\\n            c2 = c2_;\\n            step = step_;\\n        }\\n    };\\n    \\n    string toString(snake& s) {\\n        return to_string(s.r1) + \",\" + to_string(s.c1) + \", \" + to_string(s.r2) + \",\" + to_string(s.c2);\\n    }\\n    \\n    void maybeAddNextStep(queue<snake>& q, unordered_set<string>& visited, int r1, int r2, int c1, int c2, int step) {\\n        snake s_nxt = snake(r1, r2, c1, c2, step);\\n        string s_string = toString(s_nxt);\\n        if(!visited.count(s_string)) {\\n            visited.insert(s_string);\\n            q.push(s_nxt);\\n        }        \\n    }\\n    \\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        snake start = snake(0, 0, 0, 1, 0);\\n        unordered_set<string> visited;\\n        \\n        int step = 0;\\n        queue<snake> q;\\n        q.push(start);\\n        \\n        while(!q.empty()) {\\n            auto s = q.front();\\n            \\n            q.pop();\\n            \\n            // reach the end\\n            if(s.r1 == m-1 && s.r2 == m-1 && s.c1 == n-2 && s.c2 == n-1) {\\n                return s.step;\\n            }\\n            \\n            // down\\n            if(s.r1 + 1 < m && s.r2 + 1 < m && grid[s.r1+1][s.c1] == 0 && grid[s.r2+1][s.c2] == 0) {\\n                maybeAddNextStep(q, visited, s.r1+1, s.r2+1, s.c1, s.c2, s.step+1);\\n            }\\n            \\n            // right\\n            if(s.c1 + 1 < n && s.c2 + 1 < n && grid[s.r1][s.c1+1] == 0 && grid[s.r2][s.c2+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r2, s.c1+1, s.c2+1, s.step+1);\\n            }\\n            \\n            // clockwise\\n            if(s.c2 == s.c1 + 1 && s.r1+1 < m && grid[s.r1+1][s.c1] == 0 && grid[s.r1+1][s.c1+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r1+1, s.c1, s.c1, s.step+1);               \\n            }\\n            \\n            //counter-clockwise\\n            if(s.r2 == s.r1 + 1 && s.c1+1 < n && grid[s.r1][s.c1+1] == 0 && grid[s.r1+1][s.c1+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r1, s.c1, s.c1+1, s.step+1);            \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454307,
                "title": "java-bfs-extremely-straightforward-and-easy-to-understand-solution-with-brief-comments",
                "content": "```\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        // array stores current x, y and direction with 0 means horizontal and 1 means vertical\\n        q.offer(new int[]{0, 1, 0});\\n        visited[0][1][0] = true;\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] cur = q.poll();\\n                \\n                // reach target\\n                if (cur[2] == 0 && cur[0] == n - 1 && cur[1] == n - 1) return res;\\n                \\n                // rotate clockwise\\n                if (cur[0] + 1 < n && cur[2] == 0 && grid[cur[0] + 1][cur[1] - 1] == 0 && grid[cur[0] + 1][cur[1]] == 0 && !visited[cur[0] + 1][cur[1] - 1][1]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1] - 1, 1});\\n                    visited[cur[0] + 1][cur[1] - 1][1] = true;\\n                }\\n           \\n                // rotate counterclockwise\\n                if (cur[1] + 1 < n && cur[2] == 1 && grid[cur[0] - 1][cur[1] + 1] == 0 && grid[cur[0]][cur[1] + 1] == 0 && !visited[cur[0] - 1][cur[1] + 1][0]) {\\n                    q.offer(new int[]{cur[0] - 1, cur[1] + 1, 0});\\n                    visited[cur[0] - 1][cur[1] + 1][0] = true;\\n                }\\n\\t\\t\\t\\t\\n                // move right horizontally\\n                if (cur[1] + 1 < n && cur[2] == 0 && grid[cur[0]][cur[1] + 1] == 0 && !visited[cur[0]][cur[1] + 1][0]) {\\n                    q.offer(new int[]{cur[0], cur[1] + 1, 0});\\n                    visited[cur[0]][cur[1] + 1][0] = true;\\n                }\\n                \\n                // move right vertically\\n                if (cur[1] + 1 < n && cur[2] == 1 && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[0] - 1][cur[1] + 1] == 0 && !visited[cur[0]][cur[1] + 1][1]) {\\n                    q.offer(new int[]{cur[0], cur[1] + 1, 1});\\n                    visited[cur[0]][cur[1] + 1][1] = true;\\n                }\\n                \\n                // move down vertically\\n                if (cur[0] + 1 < n && cur[2] == 1 && grid[cur[0] + 1][cur[1]] == 0 && !visited[cur[0] + 1][cur[1]][1]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1], cur[2]});\\n                    visited[cur[0] + 1][cur[1]][1] = true;\\n                }\\n                \\n                // move down horizontally\\n                if (cur[0] + 1 < n && cur[2] == 0 && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[0] + 1][cur[1] - 1] == 0 && !visited[cur[0] + 1][cur[1]][0]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1], 0});\\n                    visited[cur[0] + 1][cur[1]][0] = true;\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        // array stores current x, y and direction with 0 means horizontal and 1 means vertical\\n        q.offer(new int[]{0, 1, 0});\\n        visited[0][1][0] = true;\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] cur = q.poll();\\n                \\n                // reach target\\n                if (cur[2] == 0 && cur[0] == n - 1 && cur[1] == n - 1) return res;\\n                \\n                // rotate clockwise\\n                if (cur[0] + 1 < n && cur[2] == 0 && grid[cur[0] + 1][cur[1] - 1] == 0 && grid[cur[0] + 1][cur[1]] == 0 && !visited[cur[0] + 1][cur[1] - 1][1]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1] - 1, 1});\\n                    visited[cur[0] + 1][cur[1] - 1][1] = true;\\n                }\\n           \\n                // rotate counterclockwise\\n                if (cur[1] + 1 < n && cur[2] == 1 && grid[cur[0] - 1][cur[1] + 1] == 0 && grid[cur[0]][cur[1] + 1] == 0 && !visited[cur[0] - 1][cur[1] + 1][0]) {\\n                    q.offer(new int[]{cur[0] - 1, cur[1] + 1, 0});\\n                    visited[cur[0] - 1][cur[1] + 1][0] = true;\\n                }\\n\\t\\t\\t\\t\\n                // move right horizontally\\n                if (cur[1] + 1 < n && cur[2] == 0 && grid[cur[0]][cur[1] + 1] == 0 && !visited[cur[0]][cur[1] + 1][0]) {\\n                    q.offer(new int[]{cur[0], cur[1] + 1, 0});\\n                    visited[cur[0]][cur[1] + 1][0] = true;\\n                }\\n                \\n                // move right vertically\\n                if (cur[1] + 1 < n && cur[2] == 1 && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[0] - 1][cur[1] + 1] == 0 && !visited[cur[0]][cur[1] + 1][1]) {\\n                    q.offer(new int[]{cur[0], cur[1] + 1, 1});\\n                    visited[cur[0]][cur[1] + 1][1] = true;\\n                }\\n                \\n                // move down vertically\\n                if (cur[0] + 1 < n && cur[2] == 1 && grid[cur[0] + 1][cur[1]] == 0 && !visited[cur[0] + 1][cur[1]][1]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1], cur[2]});\\n                    visited[cur[0] + 1][cur[1]][1] = true;\\n                }\\n                \\n                // move down horizontally\\n                if (cur[0] + 1 < n && cur[2] == 0 && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[0] + 1][cur[1] - 1] == 0 && !visited[cur[0] + 1][cur[1]][0]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1], 0});\\n                    visited[cur[0] + 1][cur[1]][0] = true;\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1402202,
                "title": "scala-100-100",
                "content": "```\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  private val Empty = 0\\n\\n  def minimumMoves(grid: Array[Array[Int]]): Int = {\\n    trait Snake {\\n      def row: Int\\n\\n      def col: Int\\n\\n      final def moves: Iterable[Snake] = Iterable(moveDown, moveRight, rotate).flatten\\n\\n      protected def moveDown: Option[Snake]\\n\\n      protected def moveRight: Option[Snake]\\n\\n      protected def rotate: Option[Snake]\\n    }\\n\\n    final case class HorizontalSnake(override val row: Int, override val col: Int) extends Snake {\\n      override protected def moveDown: Option[HorizontalSnake] = {\\n        (grid.get(row + 1, col), grid.get(row + 1, col - 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(HorizontalSnake(row + 1, col))\\n          case _ => None\\n        }\\n      }\\n\\n      override protected def moveRight: Option[HorizontalSnake] = grid.get(row, col + 1) match {\\n        case Some(Empty) => Some(HorizontalSnake(row, col + 1))\\n        case _ => None\\n      }\\n\\n      override protected def rotate: Option[VerticalSnake] = {\\n        (grid.get(row + 1, col), grid.get(row + 1, col - 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(VerticalSnake(row + 1, col - 1))\\n          case _ => None\\n        }\\n      }\\n    }\\n\\n    final case class VerticalSnake(override val row: Int, override val col: Int) extends Snake {\\n      override protected def moveDown: Option[VerticalSnake] = grid.get(row + 1, col) match {\\n        case Some(Empty) => Some(VerticalSnake(row + 1, col))\\n        case _ => None\\n      }\\n\\n      override protected def moveRight: Option[VerticalSnake] = {\\n        (grid.get(row, col + 1), grid.get(row - 1, col + 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(VerticalSnake(row, col + 1))\\n          case _ => None\\n        }\\n      }\\n\\n      override protected def rotate: Option[HorizontalSnake] = {\\n        (grid.get(row, col + 1), grid.get(row - 1, col + 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(HorizontalSnake(row - 1, col + 1))\\n          case _ => None\\n        }\\n      }\\n    }\\n\\n    @tailrec\\n    def search(snakes: Set[Snake], visited: Set[Snake] = Set(), numMoves: Int = 0): Int = {\\n      if (snakes.isEmpty) {\\n        -1\\n      } else if (snakes.contains(HorizontalSnake(grid.length - 1, grid.head.length - 1))) {\\n        numMoves\\n      } else {\\n        search(snakes.flatMap(_.moves).diff(visited), visited ++ snakes, numMoves + 1)\\n      }\\n    }\\n\\n    search(Set(HorizontalSnake(0, 1)))\\n  }\\n\\n  private implicit class Rich2dArray[+A](array: Array[Array[A]]) {\\n    def get(row: Int, col: Int): Option[A] = if (array.isDefinedAt(row) && array(row).isDefinedAt(col)) {\\n      Some(array(row)(col))\\n    } else {\\n      None\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  private val Empty = 0\\n\\n  def minimumMoves(grid: Array[Array[Int]]): Int = {\\n    trait Snake {\\n      def row: Int\\n\\n      def col: Int\\n\\n      final def moves: Iterable[Snake] = Iterable(moveDown, moveRight, rotate).flatten\\n\\n      protected def moveDown: Option[Snake]\\n\\n      protected def moveRight: Option[Snake]\\n\\n      protected def rotate: Option[Snake]\\n    }\\n\\n    final case class HorizontalSnake(override val row: Int, override val col: Int) extends Snake {\\n      override protected def moveDown: Option[HorizontalSnake] = {\\n        (grid.get(row + 1, col), grid.get(row + 1, col - 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(HorizontalSnake(row + 1, col))\\n          case _ => None\\n        }\\n      }\\n\\n      override protected def moveRight: Option[HorizontalSnake] = grid.get(row, col + 1) match {\\n        case Some(Empty) => Some(HorizontalSnake(row, col + 1))\\n        case _ => None\\n      }\\n\\n      override protected def rotate: Option[VerticalSnake] = {\\n        (grid.get(row + 1, col), grid.get(row + 1, col - 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(VerticalSnake(row + 1, col - 1))\\n          case _ => None\\n        }\\n      }\\n    }\\n\\n    final case class VerticalSnake(override val row: Int, override val col: Int) extends Snake {\\n      override protected def moveDown: Option[VerticalSnake] = grid.get(row + 1, col) match {\\n        case Some(Empty) => Some(VerticalSnake(row + 1, col))\\n        case _ => None\\n      }\\n\\n      override protected def moveRight: Option[VerticalSnake] = {\\n        (grid.get(row, col + 1), grid.get(row - 1, col + 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(VerticalSnake(row, col + 1))\\n          case _ => None\\n        }\\n      }\\n\\n      override protected def rotate: Option[HorizontalSnake] = {\\n        (grid.get(row, col + 1), grid.get(row - 1, col + 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(HorizontalSnake(row - 1, col + 1))\\n          case _ => None\\n        }\\n      }\\n    }\\n\\n    @tailrec\\n    def search(snakes: Set[Snake], visited: Set[Snake] = Set(), numMoves: Int = 0): Int = {\\n      if (snakes.isEmpty) {\\n        -1\\n      } else if (snakes.contains(HorizontalSnake(grid.length - 1, grid.head.length - 1))) {\\n        numMoves\\n      } else {\\n        search(snakes.flatMap(_.moves).diff(visited), visited ++ snakes, numMoves + 1)\\n      }\\n    }\\n\\n    search(Set(HorizontalSnake(0, 1)))\\n  }\\n\\n  private implicit class Rich2dArray[+A](array: Array[Array[A]]) {\\n    def get(row: Int, col: Int): Option[A] = if (array.isDefinedAt(row) && array(row).isDefinedAt(col)) {\\n      Some(array(row)(col))\\n    } else {\\n      None\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222864,
                "title": "c-bfs-solution-with-explanation",
                "content": "Remarks:\\nNice BFS problem in my opinion, though I do think the difficulty rating is too high, main reason being that it is very similar to this problem: https://leetcode.com/problems/shortest-path-with-alternating-colors/ (also an interesting BFS problem that you should checkout if you are struggling with BFS in general). \\n\\nThe idea:\\nLet us find a way to define the snake\\'s body. Notice that as long as we know the snake\\'s tail end coordinate and its orientation, we can figure out its head coordinate. Therefore, now we can just do BFS on the tail coordinate making things much easier. However, one thing to note is that there are 2 possible orientation on each coordinate, so we need to becareful to consider ALL possible paths before we discard the coordinate. \\n\\nImplementation:\\n```\\nusing P = pair<int, bool>;\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        queue<P> q;\\n        q.push(P{ 0,  true});\\n\\n        unordered_map<int, int> seen;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (; size > 0; size--) {\\n                P curr = q.front();\\n                q.pop();\\n\\n                int i = curr.first / n;\\n                int j = curr.first % n;\\n\\n                //bound checkings\\n                if (i < 0 || i >= n || j < 0 || j >= n) {\\n                    continue;\\n                } \\n                else if (curr.second && (j + 1 >= n)) {\\n                    continue;\\n                }\\n                else if (!curr.second && i + 1 >= n) {\\n                    continue;\\n                }\\n\\n                //block checking \\n                if (grid[i][j] == 1) {\\n                    continue;\\n                }\\n                else if (curr.second && grid[i][j + 1] == 1) {\\n                    continue;\\n                }\\n                else if (!curr.second && grid[i + 1][j] == 1) {\\n                    continue;\\n                }\\n\\n                //dest checking\\n                if (curr.second && i == n - 1 && j + 1 == n - 1) {\\n                    return level;\\n                }\\n\\n\\n                //visited checking\\n                if (seen.find(curr.first) == seen.end()) {\\n                    seen[curr.first] = curr.second ? 1 : 0;\\n                }\\n                else if (seen[curr.first] == 2){\\n                    continue;\\n                }\\n                else if ((seen[curr.first] == 1 && !curr.second) || (seen[curr.first] == 0 && curr.second)) {\\n                    seen[curr.first] = 2;\\n                }\\n                else {\\n                    continue;\\n                }\\n\\n                //consider paths\\n                q.push(P((i + 1) * n + j, curr.second));\\n                q.push(P(i * n + (j + 1), curr.second));\\n                if (i + 1 < n && j + 1 < n && grid[i][j] == 0 && grid[i + 1][j + 1] == 0) {\\n                    q.push(P(curr.first, !curr.second));\\n                }\\n            }\\n\\n            level++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\nAs you can see, other than the slightly complicated `seen` checking which ensures that we don\\'t run into loops and consider all paths, it is pretty much a standard BFS search, While I could shorten the code by combining the `if` statements, I much rather expand them than suffering a minor stroke trying to decipher the `&&` and the `||`. The complexity is O(n^2). Once again, we have 2 orientations and we do `seen` check we can be sure that no coordinate will checked more than twice. Space complexity is O(n^2)",
                "solutionTags": [],
                "code": "```\\nusing P = pair<int, bool>;\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        queue<P> q;\\n        q.push(P{ 0,  true});\\n\\n        unordered_map<int, int> seen;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (; size > 0; size--) {\\n                P curr = q.front();\\n                q.pop();\\n\\n                int i = curr.first / n;\\n                int j = curr.first % n;\\n\\n                //bound checkings\\n                if (i < 0 || i >= n || j < 0 || j >= n) {\\n                    continue;\\n                } \\n                else if (curr.second && (j + 1 >= n)) {\\n                    continue;\\n                }\\n                else if (!curr.second && i + 1 >= n) {\\n                    continue;\\n                }\\n\\n                //block checking \\n                if (grid[i][j] == 1) {\\n                    continue;\\n                }\\n                else if (curr.second && grid[i][j + 1] == 1) {\\n                    continue;\\n                }\\n                else if (!curr.second && grid[i + 1][j] == 1) {\\n                    continue;\\n                }\\n\\n                //dest checking\\n                if (curr.second && i == n - 1 && j + 1 == n - 1) {\\n                    return level;\\n                }\\n\\n\\n                //visited checking\\n                if (seen.find(curr.first) == seen.end()) {\\n                    seen[curr.first] = curr.second ? 1 : 0;\\n                }\\n                else if (seen[curr.first] == 2){\\n                    continue;\\n                }\\n                else if ((seen[curr.first] == 1 && !curr.second) || (seen[curr.first] == 0 && curr.second)) {\\n                    seen[curr.first] = 2;\\n                }\\n                else {\\n                    continue;\\n                }\\n\\n                //consider paths\\n                q.push(P((i + 1) * n + j, curr.second));\\n                q.push(P(i * n + (j + 1), curr.second));\\n                if (i + 1 < n && j + 1 < n && grid[i][j] == 0 && grid[i + 1][j + 1] == 0) {\\n                    q.push(P(curr.first, !curr.second));\\n                }\\n            }\\n\\n            level++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191193,
                "title": "python-3-dfs",
                "content": "```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        seen = defaultdict(lambda:float(\\'inf\\'))\\n        \\n        def get_next(i0, j0, i1, j1):\\n            for dx, dy in [(0,1), (1,0)]:\\n                x0, y0 = i0 + dx, j0 + dy\\n                x1, y1 = i1 + dx, j1 + dy\\n                if 0<=x0<n and 0<=y0<n and \\\\\\n                        0<=x1<n and 0<=y1<n and \\\\\\n                        grid[x0][y0] == grid[x1][y1] == 0:\\n                    yield x0, y0, x1, y1\\n                    \\n        def rotate(i0, j0, i1, j1):\\n            if i0 == i1 + 1 and j0 < n - 1:\\n                if grid[i0][j0 + 1] == grid[i1][j1 + 1] == 0:\\n                    yield i1, j1 + 1, i1, j1\\n            if j0 == j1 + 1 and i0 < n - 1:\\n                if grid[i0 + 1][j0] == grid[i1 + 1][j1] == 0:\\n                    yield i1 + 1, j1, i1, j1\\n                    \\n        def dfs(i0, j0, i1, j1, step):\\n            if step >= seen[i0, j0, i1, j1]:\\n                return\\n            seen[i0, j0, i1, j1] = step\\n            if (i0, j0, i1, j1) == (n-1, n-1, n-1, n-2):\\n                return\\n            for a,b,c,d in get_next(i0,j0,i1,j1):\\n                dfs(a, b, c, d, step + 1)\\n            for a,b,c,d in rotate(i0,j0,i1,j1):\\n                dfs(a, b, c, d, step + 1)\\n        \\n        dfs(0, 1, 0, 0, 0)\\n        return seen[n-1, n-1, n-1, n-2] if seen[n-1, n-1, n-1, n-2] < float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        seen = defaultdict(lambda:float(\\'inf\\'))\\n        \\n        def get_next(i0, j0, i1, j1):\\n            for dx, dy in [(0,1), (1,0)]:\\n                x0, y0 = i0 + dx, j0 + dy\\n                x1, y1 = i1 + dx, j1 + dy\\n                if 0<=x0<n and 0<=y0<n and \\\\\\n                        0<=x1<n and 0<=y1<n and \\\\\\n                        grid[x0][y0] == grid[x1][y1] == 0:\\n                    yield x0, y0, x1, y1\\n                    \\n        def rotate(i0, j0, i1, j1):\\n            if i0 == i1 + 1 and j0 < n - 1:\\n                if grid[i0][j0 + 1] == grid[i1][j1 + 1] == 0:\\n                    yield i1, j1 + 1, i1, j1\\n            if j0 == j1 + 1 and i0 < n - 1:\\n                if grid[i0 + 1][j0] == grid[i1 + 1][j1] == 0:\\n                    yield i1 + 1, j1, i1, j1\\n                    \\n        def dfs(i0, j0, i1, j1, step):\\n            if step >= seen[i0, j0, i1, j1]:\\n                return\\n            seen[i0, j0, i1, j1] = step\\n            if (i0, j0, i1, j1) == (n-1, n-1, n-1, n-2):\\n                return\\n            for a,b,c,d in get_next(i0,j0,i1,j1):\\n                dfs(a, b, c, d, step + 1)\\n            for a,b,c,d in rotate(i0,j0,i1,j1):\\n                dfs(a, b, c, d, step + 1)\\n        \\n        dfs(0, 1, 0, 0, 0)\\n        return seen[n-1, n-1, n-1, n-2] if seen[n-1, n-1, n-1, n-2] < float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176896,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // using BFS to search\\n        int n = grid.length;\\n        boolean[][][] visited = new boolean[n][n][2]; // 0: horizontal 1: vertical\\n        Queue<int[]> positions = new LinkedList<>();\\n        positions.add(new int[]{0, 0, 0});\\n        visited[0][0][0] = true;\\n        int res = -1;\\n        \\n        while (!positions.isEmpty()) {\\n            int size = positions.size();\\n            res++;\\n            while (size > 0) {\\n                int[] curr = positions.poll();\\n                int y = curr[0];\\n                int x = curr[1];\\n                int head = curr[2];\\n\\n                if (y == n - 1 && x == n - 2 && head == 0) return res;\\n                if (head == 0) { // horizontal: can move right move down or clockwise\\n                    if (x + 2 < n && grid[y][x + 2] == 0 && !visited[y][x + 1][0]) { // can move to right\\n                        positions.add(new int[]{y, x + 1, 0});\\n                        visited[y][x + 1][0] = true;\\n                    }\\n                    if (y + 1 < n && grid[y + 1][x] == 0 && grid[y + 1][x + 1] == 0) {\\n                        if (!visited[y + 1][x][0]) {\\n                            positions.add(new int[]{y + 1, x, 0});\\n                            visited[y + 1][x][0] = true;\\n                        }\\n                        if (!visited[y][x][1]) {\\n                            positions.add(new int[]{y, x, 1});\\n                            visited[y][x][1] = true;\\n                        }\\n                    }\\n                } else { // vertical: can move right, move down or counterclockwise\\n                    if (x + 1 < n && grid[y][x + 1] == 0 && grid[y + 1][x + 1] == 0) { // move to right adn counterclockwise\\n                        if (!visited[y][x + 1][1]) {\\n                            positions.add(new int[]{y, x + 1, 1});\\n                            visited[y][x + 1][1] = true;\\n                        }\\n                        if (!visited[y][x][0]) {\\n                            positions.add(new int[]{y, x, 0});\\n                            visited[y][x][0] = true;\\n                        }\\n                        \\n                    }\\n                    if (y + 2 < n && grid[y + 2][x] == 0 && !visited[y + 1][x][1]) {\\n                        positions.add(new int[]{y + 1, x, 1});\\n                        visited[y + 1][x][1] = true;\\n                    } \\n                }\\n                size--;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // using BFS to search\\n        int n = grid.length;\\n        boolean[][][] visited = new boolean[n][n][2]; // 0: horizontal 1: vertical\\n        Queue<int[]> positions = new LinkedList<>();\\n        positions.add(new int[]{0, 0, 0});\\n        visited[0][0][0] = true;\\n        int res = -1;\\n        \\n        while (!positions.isEmpty()) {\\n            int size = positions.size();\\n            res++;\\n            while (size > 0) {\\n                int[] curr = positions.poll();\\n                int y = curr[0];\\n                int x = curr[1];\\n                int head = curr[2];\\n\\n                if (y == n - 1 && x == n - 2 && head == 0) return res;\\n                if (head == 0) { // horizontal: can move right move down or clockwise\\n                    if (x + 2 < n && grid[y][x + 2] == 0 && !visited[y][x + 1][0]) { // can move to right\\n                        positions.add(new int[]{y, x + 1, 0});\\n                        visited[y][x + 1][0] = true;\\n                    }\\n                    if (y + 1 < n && grid[y + 1][x] == 0 && grid[y + 1][x + 1] == 0) {\\n                        if (!visited[y + 1][x][0]) {\\n                            positions.add(new int[]{y + 1, x, 0});\\n                            visited[y + 1][x][0] = true;\\n                        }\\n                        if (!visited[y][x][1]) {\\n                            positions.add(new int[]{y, x, 1});\\n                            visited[y][x][1] = true;\\n                        }\\n                    }\\n                } else { // vertical: can move right, move down or counterclockwise\\n                    if (x + 1 < n && grid[y][x + 1] == 0 && grid[y + 1][x + 1] == 0) { // move to right adn counterclockwise\\n                        if (!visited[y][x + 1][1]) {\\n                            positions.add(new int[]{y, x + 1, 1});\\n                            visited[y][x + 1][1] = true;\\n                        }\\n                        if (!visited[y][x][0]) {\\n                            positions.add(new int[]{y, x, 0});\\n                            visited[y][x][0] = true;\\n                        }\\n                        \\n                    }\\n                    if (y + 2 < n && grid[y + 2][x] == 0 && !visited[y + 1][x][1]) {\\n                        positions.add(new int[]{y + 1, x, 1});\\n                        visited[y + 1][x][1] = true;\\n                    } \\n                }\\n                size--;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154452,
                "title": "c-very-simple-solution-similar-to-standard-bfs-template",
                "content": "Logic:\\nThe state of snake can be defined using position of its **head** and its orientation as already stated in Hints. Therfore we can use a tuple.\\n\\n`typedef tuple<int,int,bool> state;`\\nIt represent position in form of `row,column,orientation`\\n\\nOrientation is represented as \\n* 0 - Horizontal\\n* 1 - Vertical\\n\\nHere, termination condition would be head at` n-1,n-1` cell and `orientation to be horizontal`\\n\\n\\nNow, we just need to apply modifed BFS:\\n\\n```\\nclass Solution {\\npublic:\\n    typedef tuple<int,int,bool> state;\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        //0 horizontal 1 vertical\\n        int n=grid.size();\\n        queue<state> q;\\n        \\n        q.push({0,1,0});\\n        set<state> st;\\n        int ans=0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                if(st.count(q.front())){\\n                    q.pop();\\n                    continue;\\n                }\\n                st.insert(q.front());\\n                auto [x,y,o] = q.front();q.pop();\\n                if(x==n-1 && y==n-1 && o==0)return ans;\\n                if(o==0 ){\\n                    if( y+1<n && grid[x][y+1]==0)\\n                        q.push({x,y+1,0});\\n                    if( x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 )\\n                        q.push({x+1,y-1,1}),q.push({x+1,y,0});\\n                    \\n                }\\n                if(o==1){\\n                    if(x+1 < n && grid[x+1][y]==0)\\n                        q.push({x+1,y,1});\\n                    if(y+1<n && grid[x-1][y+1]==0 && grid[x][y+1]==0)\\n                        q.push({x-1,y+1,0}),q.push({x,y+1,1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nNote : Once could have used unordered_set, but it requires defining of hash function for tuple.\\n\\n**x and y represent current row and colum respectively, don\\'t confuse them with x, y co-ordinates.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef tuple<int,int,bool> state;\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        //0 horizontal 1 vertical\\n        int n=grid.size();\\n        queue<state> q;\\n        \\n        q.push({0,1,0});\\n        set<state> st;\\n        int ans=0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                if(st.count(q.front())){\\n                    q.pop();\\n                    continue;\\n                }\\n                st.insert(q.front());\\n                auto [x,y,o] = q.front();q.pop();\\n                if(x==n-1 && y==n-1 && o==0)return ans;\\n                if(o==0 ){\\n                    if( y+1<n && grid[x][y+1]==0)\\n                        q.push({x,y+1,0});\\n                    if( x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 )\\n                        q.push({x+1,y-1,1}),q.push({x+1,y,0});\\n                    \\n                }\\n                if(o==1){\\n                    if(x+1 < n && grid[x+1][y]==0)\\n                        q.push({x+1,y,1});\\n                    if(y+1<n && grid[x-1][y+1]==0 && grid[x][y+1]==0)\\n                        q.push({x-1,y+1,0}),q.push({x,y+1,1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111427,
                "title": "c-dp-20ms-faster-than-98-with-detailed-comments",
                "content": "The idea is to create two DP arrays representing two different snake states at each grid point (lying horizontally or vertically) and then update these two DP arrays diagonally from top-left (i+j=0) to bottom-right (i+j = 2n-2). Space and time complexity is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/41506e53-66d7-4b56-9f4a-32e8a0123d29_1615848861.7051756.png)\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> dph(n, vector<int>(n, INT_MAX/2)); //min moves to reach state with snake head at (i,j) and snake tail at (i,j-1) (ie, a snake lying horizontally)\\n        vector<vector<int>> dpv = dph; //min moves to reach state with snake head at (i,j) and snake tail at (i-1,j) (ie, a snake lying vertically)\\n        //0. init\\n        dph[0][1] = 0;\\n        if(!grid[1][0] && !grid[1][1]) dpv[1][0] = 1;\\n        for(int k = 2; k <= 2*n-2; k++){ //k is the wavefront, k = i+j\\n            int i_start = max(0, k - n + 1);\\n            int i_end = min(k, n-1);\\n            //1. first update dph[i][j] and dpv[i][j] (i+j == k) based on horizonal or vertical shifts, using dp[i\\'][j\\'] where i\\'+j\\'==k-1\\n            for(int i = i_start; i <= i_end; i++){\\n                int j = k - i;\\n                if(grid[i][j]) continue;\\n                //1.1. update dph\\n                if(j>0 && !grid[i][j-1]){\\n                    dph[i][j] = dph[i][j-1] + 1; //horizontal shift (right)\\n                    if(i>0) dph[i][j] = min(dph[i][j], dph[i-1][j] + 1); //vertical shift (down)\\n                }\\n                //1.2. update dpv\\n                if(i>0 && !grid[i-1][j]){\\n                    dpv[i][j] = dpv[i-1][j] + 1; //vertical shift (down)\\n                    if(j>0) dpv[i][j] = min(dpv[i][j], dpv[i][j-1] + 1); //horizontal shift (right)\\n                }\\n            }\\n            //2. Then update dph[i][j] and dpv[i][j] (i+j == k) based on rotations, using dp[i\\'][j\\'] where i\\'+j\\'==k (ie, same wavefronts)\\n            for(int i = i_start; i <= i_end; i++){\\n                int j = k - i;\\n                if(grid[i][j]) continue;\\n                if(j>0 && !grid[i][j-1] && i<n-1 && !grid[i+1][j]) dph[i][j] = min(dph[i][j], dpv[i+1][j-1] + 1);\\n                if(i>0 && !grid[i-1][j] && j<n-1 && !grid[i][j+1]) dpv[i][j] = min(dpv[i][j], dph[i-1][j+1] + 1);\\n            }\\n        }\\n        if(dph[n-1][n-1] >= INT_MAX/2) return -1;\\n        else return dph[n-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> dph(n, vector<int>(n, INT_MAX/2)); //min moves to reach state with snake head at (i,j) and snake tail at (i,j-1) (ie, a snake lying horizontally)\\n        vector<vector<int>> dpv = dph; //min moves to reach state with snake head at (i,j) and snake tail at (i-1,j) (ie, a snake lying vertically)\\n        //0. init\\n        dph[0][1] = 0;\\n        if(!grid[1][0] && !grid[1][1]) dpv[1][0] = 1;\\n        for(int k = 2; k <= 2*n-2; k++){ //k is the wavefront, k = i+j\\n            int i_start = max(0, k - n + 1);\\n            int i_end = min(k, n-1);\\n            //1. first update dph[i][j] and dpv[i][j] (i+j == k) based on horizonal or vertical shifts, using dp[i\\'][j\\'] where i\\'+j\\'==k-1\\n            for(int i = i_start; i <= i_end; i++){\\n                int j = k - i;\\n                if(grid[i][j]) continue;\\n                //1.1. update dph\\n                if(j>0 && !grid[i][j-1]){\\n                    dph[i][j] = dph[i][j-1] + 1; //horizontal shift (right)\\n                    if(i>0) dph[i][j] = min(dph[i][j], dph[i-1][j] + 1); //vertical shift (down)\\n                }\\n                //1.2. update dpv\\n                if(i>0 && !grid[i-1][j]){\\n                    dpv[i][j] = dpv[i-1][j] + 1; //vertical shift (down)\\n                    if(j>0) dpv[i][j] = min(dpv[i][j], dpv[i][j-1] + 1); //horizontal shift (right)\\n                }\\n            }\\n            //2. Then update dph[i][j] and dpv[i][j] (i+j == k) based on rotations, using dp[i\\'][j\\'] where i\\'+j\\'==k (ie, same wavefronts)\\n            for(int i = i_start; i <= i_end; i++){\\n                int j = k - i;\\n                if(grid[i][j]) continue;\\n                if(j>0 && !grid[i][j-1] && i<n-1 && !grid[i+1][j]) dph[i][j] = min(dph[i][j], dpv[i+1][j-1] + 1);\\n                if(i>0 && !grid[i-1][j] && j<n-1 && !grid[i][j+1]) dpv[i][j] = min(dpv[i][j], dph[i-1][j+1] + 1);\\n            }\\n        }\\n        if(dph[n-1][n-1] >= INT_MAX/2) return -1;\\n        else return dph[n-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104966,
                "title": "c-bfs-string-set",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        unordered_set<string> seen;\\n        queue<vector<int>> todo; // { tx, ty, hx, hy, minSteps } ~==>\\n        todo.push({0, 0, 0, 1, 0});\\n        seen.insert(\"0001\");\\n        while (!todo.empty()) {\\n            vector<int> cur = todo.front(), newCur, move;\\n            todo.pop();\\n            if (cur[0] == N - 1 && cur[1] == N - 2 && cur[2] == N - 1 && cur[3] == N - 1) {\\n                return cur[4];\\n            }\\n            for (int ithMove = 0; ithMove < moves.size(); ithMove++) {\\n                move = moves[ithMove];\\n                int tX = cur[0] + move[0], tY = cur[1] + move[1];\\n                int hX = cur[2] + move[2], hY = cur[3] + move[3];\\n                newCur = { tX, tY, hX, hY };\\n                char prevDirection = (cur[0] == cur[2] ? \\'H\\' : \\'V\\');\\n                string coor = to_string(tX) + to_string(tY) + to_string(hX) + to_string(hY);\\n                if (inside(newCur, N, ithMove, prevDirection, grid) && seen.find(coor) == seen.end()) {\\n                    todo.push({tX, tY, hX, hY, cur[4] + 1});\\n                    seen.insert(coor);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool inside(vector<int> &cur, int &N, int &move, char &prevDirection, vector<vector<int>> &grid) {\\n        // Inside check\\n        if (cur[0] < 0 || cur[0] >= N || cur[2] < 0 || cur[2] >= N ||\\n           cur[1] < 0 || cur[1] >= N || cur[3] < 0 || cur[3] >= N) {\\n            return false;\\n        }\\n        // Go once cell right, check only head part\\n        if (move == 0 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Go once cell down, check both head and tail\\n        if (move == 1 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Rotate clocwise if Horizontal\\n        if (move == 2 && (prevDirection == \\'V\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2]][cur[3] + 1] == 1)) {\\n            return false;\\n        }\\n        // Rotate counter-clocwise if Vertical\\n        if (move == 3 && (prevDirection == \\'H\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2] + 1][cur[3]] == 1)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        unordered_set<string> seen;\\n        queue<vector<int>> todo; // { tx, ty, hx, hy, minSteps } ~==>\\n        todo.push({0, 0, 0, 1, 0});\\n        seen.insert(\"0001\");\\n        while (!todo.empty()) {\\n            vector<int> cur = todo.front(), newCur, move;\\n            todo.pop();\\n            if (cur[0] == N - 1 && cur[1] == N - 2 && cur[2] == N - 1 && cur[3] == N - 1) {\\n                return cur[4];\\n            }\\n            for (int ithMove = 0; ithMove < moves.size(); ithMove++) {\\n                move = moves[ithMove];\\n                int tX = cur[0] + move[0], tY = cur[1] + move[1];\\n                int hX = cur[2] + move[2], hY = cur[3] + move[3];\\n                newCur = { tX, tY, hX, hY };\\n                char prevDirection = (cur[0] == cur[2] ? \\'H\\' : \\'V\\');\\n                string coor = to_string(tX) + to_string(tY) + to_string(hX) + to_string(hY);\\n                if (inside(newCur, N, ithMove, prevDirection, grid) && seen.find(coor) == seen.end()) {\\n                    todo.push({tX, tY, hX, hY, cur[4] + 1});\\n                    seen.insert(coor);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool inside(vector<int> &cur, int &N, int &move, char &prevDirection, vector<vector<int>> &grid) {\\n        // Inside check\\n        if (cur[0] < 0 || cur[0] >= N || cur[2] < 0 || cur[2] >= N ||\\n           cur[1] < 0 || cur[1] >= N || cur[3] < 0 || cur[3] >= N) {\\n            return false;\\n        }\\n        // Go once cell right, check only head part\\n        if (move == 0 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Go once cell down, check both head and tail\\n        if (move == 1 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Rotate clocwise if Horizontal\\n        if (move == 2 && (prevDirection == \\'V\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2]][cur[3] + 1] == 1)) {\\n            return false;\\n        }\\n        // Rotate counter-clocwise if Vertical\\n        if (move == 3 && (prevDirection == \\'H\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2] + 1][cur[3]] == 1)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104668,
                "title": "c-concise-bfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        set<vector<int>> seen;\\n        queue<vector<int>> todo; // { tx, ty, hx, hy, minSteps } ~==>\\n        todo.push({0, 0, 0, 1, 0});\\n        seen.insert({0, 0, 0, 1});\\n        while (!todo.empty()) {\\n            vector<int> cur = todo.front(), newCur, move;\\n            todo.pop();\\n            if (cur[0] == N - 1 && cur[1] == N - 2 && cur[2] == N - 1 && cur[3] == N - 1) {\\n                return cur[4];\\n            }\\n            for (int ithMove = 0; ithMove < moves.size(); ithMove++) {\\n                move = moves[ithMove];\\n                int tX = cur[0] + move[0], tY = cur[1] + move[1];\\n                int hX = cur[2] + move[2], hY = cur[3] + move[3];\\n                newCur = { tX, tY, hX, hY };\\n                char prevDirection = (cur[0] == cur[2] ? \\'H\\' : \\'V\\');\\n                if (inside(newCur, N, ithMove, prevDirection, grid) && seen.find(newCur) == seen.end()) {\\n                    todo.push({tX, tY, hX, hY, cur[4] + 1});\\n                    seen.insert(newCur);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool inside(vector<int> &cur, int &N, int &move, char &prevDirection, vector<vector<int>> &grid) {\\n        // Inside check\\n        if (cur[0] < 0 || cur[0] >= N || cur[2] < 0 || cur[2] >= N ||\\n           cur[1] < 0 || cur[1] >= N || cur[3] < 0 || cur[3] >= N) {\\n            return false;\\n        }\\n        // Go once cell right, check only head part\\n        if (move == 0 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Go once cell down, check both head and tail\\n        if (move == 1 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Rotate clocwise if Horizontal\\n        if (move == 2 && (prevDirection == \\'V\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2]][cur[3] + 1] == 1)) {\\n            return false;\\n        }\\n        // Rotate counter-clocwise if Vertical\\n        if (move == 3 && (prevDirection == \\'H\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2] + 1][cur[3]] == 1)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        set<vector<int>> seen;\\n        queue<vector<int>> todo; // { tx, ty, hx, hy, minSteps } ~==>\\n        todo.push({0, 0, 0, 1, 0});\\n        seen.insert({0, 0, 0, 1});\\n        while (!todo.empty()) {\\n            vector<int> cur = todo.front(), newCur, move;\\n            todo.pop();\\n            if (cur[0] == N - 1 && cur[1] == N - 2 && cur[2] == N - 1 && cur[3] == N - 1) {\\n                return cur[4];\\n            }\\n            for (int ithMove = 0; ithMove < moves.size(); ithMove++) {\\n                move = moves[ithMove];\\n                int tX = cur[0] + move[0], tY = cur[1] + move[1];\\n                int hX = cur[2] + move[2], hY = cur[3] + move[3];\\n                newCur = { tX, tY, hX, hY };\\n                char prevDirection = (cur[0] == cur[2] ? \\'H\\' : \\'V\\');\\n                if (inside(newCur, N, ithMove, prevDirection, grid) && seen.find(newCur) == seen.end()) {\\n                    todo.push({tX, tY, hX, hY, cur[4] + 1});\\n                    seen.insert(newCur);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool inside(vector<int> &cur, int &N, int &move, char &prevDirection, vector<vector<int>> &grid) {\\n        // Inside check\\n        if (cur[0] < 0 || cur[0] >= N || cur[2] < 0 || cur[2] >= N ||\\n           cur[1] < 0 || cur[1] >= N || cur[3] < 0 || cur[3] >= N) {\\n            return false;\\n        }\\n        // Go once cell right, check only head part\\n        if (move == 0 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Go once cell down, check both head and tail\\n        if (move == 1 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Rotate clocwise if Horizontal\\n        if (move == 2 && (prevDirection == \\'V\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2]][cur[3] + 1] == 1)) {\\n            return false;\\n        }\\n        // Rotate counter-clocwise if Vertical\\n        if (move == 3 && (prevDirection == \\'H\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2] + 1][cur[3]] == 1)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104561,
                "title": "easy-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;  \\n        //boolean[][][][] visited = new boolean[n][n][n][n];\\n        Set<Position> set = new HashSet<>();\\n       \\n        Queue<Position> q = new LinkedList<>();\\n        q.offer(new Position(0,0,0,1));        \\n        int count = 0;\\n                \\n        if(grid[n-1][n-2] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        \\n        while(!q.isEmpty()){\\n            ++count;\\n            Queue<Position> nextq = new LinkedList<>();\\n            while(!q.isEmpty()){\\n                \\n                Position p = q.poll();\\n\\n                int r1 = p.getr1();\\n                int r2 = p.getr2();\\n                int c1 = p.getc1();\\n                int c2 = p.getc2();\\n                \\n                if(r1 == n-1 && r2 == n-1 && c1 == n-2 && c2==n-1)\\n                    return count-1;\\n                \\n                if(set.contains(p))\\n                    continue;\\n                \\n                if(c1+1 < n && grid[r1] [c1+1] != 1 && c2+1 < n && grid[r2] [c2+1] != 1)\\n                    nextq.offer(new Position(r1, c1+1, r2, c2+1));\\n                if(r1+1 < n && grid[r1+1] [c1] != 1 && r2+1 < n && grid[r2+1] [c2] != 1)\\n                    nextq.offer(new Position(r1+1, c1, r2+1, c2));\\n                \\n                if(r1 == r2 && r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0 && grid[r1+1][c1] == 0)\\n                    nextq.offer(new Position(r1,c1, r1+1, c1));\\n                \\n                if(c1 == c2 && c1+1 < n && c2+1 < n && grid[r1][c1+1] == 0 && grid[r2][c1+1] == 0   && grid[r1][c1+1] == 0)\\n                    nextq.offer(new Position(r1,c1, r1, c1+1));\\n                set.add(p);\\n            }\\n            q = nextq;\\n        }\\n        return -1;\\n    }\\n    \\n    private class Position{\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        \\n        public Position(int r1, int c1, int r2, int c2){\\n            this.r1 = r1;\\n            this.r2 = r2;\\n            this.c1 =c1;\\n            this.c2 = c2;\\n        }\\n        \\n        public int getr1(){\\n            return this.r1;\\n        }\\n        public int getr2(){\\n            return this.r2;\\n        }\\n        public int getc1(){\\n            return this.c1;\\n        }\\n        public int getc2(){\\n            return this.c2;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            final int prime = 31;\\n            int result = 1;\\n            result = prime * r1 + c1 + prime *r2 + c2;\\n            return result;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object obj) {\\n            Position p = (Position) obj;\\n            if(this.r1 == p.getr1() && this.r2 ==p.getr2() && this.c1 == p.getc1() && this.c2==p.getc2())\\n                return true;\\n            else\\n                return false;\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;  \\n        //boolean[][][][] visited = new boolean[n][n][n][n];\\n        Set<Position> set = new HashSet<>();\\n       \\n        Queue<Position> q = new LinkedList<>();\\n        q.offer(new Position(0,0,0,1));        \\n        int count = 0;\\n                \\n        if(grid[n-1][n-2] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        \\n        while(!q.isEmpty()){\\n            ++count;\\n            Queue<Position> nextq = new LinkedList<>();\\n            while(!q.isEmpty()){\\n                \\n                Position p = q.poll();\\n\\n                int r1 = p.getr1();\\n                int r2 = p.getr2();\\n                int c1 = p.getc1();\\n                int c2 = p.getc2();\\n                \\n                if(r1 == n-1 && r2 == n-1 && c1 == n-2 && c2==n-1)\\n                    return count-1;\\n                \\n                if(set.contains(p))\\n                    continue;\\n                \\n                if(c1+1 < n && grid[r1] [c1+1] != 1 && c2+1 < n && grid[r2] [c2+1] != 1)\\n                    nextq.offer(new Position(r1, c1+1, r2, c2+1));\\n                if(r1+1 < n && grid[r1+1] [c1] != 1 && r2+1 < n && grid[r2+1] [c2] != 1)\\n                    nextq.offer(new Position(r1+1, c1, r2+1, c2));\\n                \\n                if(r1 == r2 && r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0 && grid[r1+1][c1] == 0)\\n                    nextq.offer(new Position(r1,c1, r1+1, c1));\\n                \\n                if(c1 == c2 && c1+1 < n && c2+1 < n && grid[r1][c1+1] == 0 && grid[r2][c1+1] == 0   && grid[r1][c1+1] == 0)\\n                    nextq.offer(new Position(r1,c1, r1, c1+1));\\n                set.add(p);\\n            }\\n            q = nextq;\\n        }\\n        return -1;\\n    }\\n    \\n    private class Position{\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        \\n        public Position(int r1, int c1, int r2, int c2){\\n            this.r1 = r1;\\n            this.r2 = r2;\\n            this.c1 =c1;\\n            this.c2 = c2;\\n        }\\n        \\n        public int getr1(){\\n            return this.r1;\\n        }\\n        public int getr2(){\\n            return this.r2;\\n        }\\n        public int getc1(){\\n            return this.c1;\\n        }\\n        public int getc2(){\\n            return this.c2;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            final int prime = 31;\\n            int result = 1;\\n            result = prime * r1 + c1 + prime *r2 + c2;\\n            return result;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object obj) {\\n            Position p = (Position) obj;\\n            if(this.r1 == p.getr1() && this.r2 ==p.getr2() && this.c1 == p.getc1() && this.c2==p.getc2())\\n                return true;\\n            else\\n                return false;\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078757,
                "title": "common-bfs",
                "content": "```\\nint[] d = {0,1,0};\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, cnt = 0;\\n        boolean dp[][][] = new boolean[n][n][2];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,1,0});\\n        dp[0][1][0] = true;\\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            for (int i = 0; i < size; i++){\\n                int cur[] = q.poll(), r = cur[0], c = cur[1], dir = cur[2], tr, tc;\\n                if (r == n-1 && c == n-1 && dir == 0) return cnt;\\n                if (dir == 0){\\n                    tr = r;\\n                    tc = c-1;\\n                    if (isValid(r+1,c-1,grid) && isValid(r+1,c,grid) && !dp[r+1][c-1][1]){\\n                        q.add(new int[]{r+1,c-1,1});\\n                        dp[r+1][c-1][1] = true;\\n                    }\\n                }else{\\n                    tr = r-1;\\n                    tc = c;\\n                    if (isValid(r,c+1,grid) && isValid(r-1,c+1,grid) && !dp[r-1][c+1][0]){\\n                        q.add(new int[]{r-1,c+1,0});\\n                        dp[r-1][c+1][0] = true;\\n                    }\\n                }\\n                for (int j = 0; j < 2; j++){\\n                    int nr = r + d[j], nc = c + d[j+1], ntr = tr + d[j], ntc = tc + d[j+1];\\n                    if (isValid(nr,nc,grid) && isValid(ntr,ntc,grid) && !dp[nr][nc][dir]){\\n                        q.add(new int[]{nr,nc,dir});\\n                        dp[nr][nc][dir] = true;\\n                    } \\n                }\\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n    boolean isValid(int r, int c, int[][] grid){\\n        int n = grid.length;\\n        return r < n && c < n && grid[r][c] == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint[] d = {0,1,0};\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, cnt = 0;\\n        boolean dp[][][] = new boolean[n][n][2];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,1,0});\\n        dp[0][1][0] = true;\\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            for (int i = 0; i < size; i++){\\n                int cur[] = q.poll(), r = cur[0], c = cur[1], dir = cur[2], tr, tc;\\n                if (r == n-1 && c == n-1 && dir == 0) return cnt;\\n                if (dir == 0){\\n                    tr = r;\\n                    tc = c-1;\\n                    if (isValid(r+1,c-1,grid) && isValid(r+1,c,grid) && !dp[r+1][c-1][1]){\\n                        q.add(new int[]{r+1,c-1,1});\\n                        dp[r+1][c-1][1] = true;\\n                    }\\n                }else{\\n                    tr = r-1;\\n                    tc = c;\\n                    if (isValid(r,c+1,grid) && isValid(r-1,c+1,grid) && !dp[r-1][c+1][0]){\\n                        q.add(new int[]{r-1,c+1,0});\\n                        dp[r-1][c+1][0] = true;\\n                    }\\n                }\\n                for (int j = 0; j < 2; j++){\\n                    int nr = r + d[j], nc = c + d[j+1], ntr = tr + d[j], ntc = tc + d[j+1];\\n                    if (isValid(nr,nc,grid) && isValid(ntr,ntc,grid) && !dp[nr][nc][dir]){\\n                        q.add(new int[]{nr,nc,dir});\\n                        dp[nr][nc][dir] = true;\\n                    } \\n                }\\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n    boolean isValid(int r, int c, int[][] grid){\\n        int n = grid.length;\\n        return r < n && c < n && grid[r][c] == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035527,
                "title": "c-breadth-first-memoize-faster-than-100",
                "content": "```c\\n/* Approach: breadth-first search.  The first solution is the minimum number of moves.\\n * At each turn, we convert list of current positions to a new list of positions by\\n * converting a position to a new set of positions.  The new set can be empty (no\\n * moves possible) or can contain 1, 2, 3, or 4 new positions.  The game ends when\\n * a new position is at target.\\n *\\n * Keep track of which positions have been examined so as not to calculated them\\n * again and again.\\n */\\n\\n\\nenum move { MOVE_RIGHT, MOVE_DOWN, ROT_CLOCK, ROT_COUNTER, N_MOVES };\\n\\n#if UINTPTR_MAX == 18446744073709551615UL\\n#define BITS_PER_EL 6\\n#else\\n#define BITS_PER_EL 5\\n#endif\\n\\n#define DEBUG 0\\n\\nstruct pos {\\n    int     vertical;\\n    int     tail[2];        /* Position of tail, row, column */\\n};\\n\\nstruct list_of_pos {\\n    struct pos  *pos;\\n    unsigned     n_pos, n_alloced;\\n};\\n\\nstatic unsigned\\npos2flat (struct pos pos, int n)\\n{\\n    return (pos.vertical << 14) | ((unsigned char) pos.tail[0] << 7) | ((unsigned char) pos.tail[1]);\\n}\\n\\nstatic const char *const move2str[] = { \"RIGHT\", \"DOWN\", \"CLOCKWISE\", \"COUNTERCLOCKWISE\", };\\n\\nstatic void\\nmaybe_push_pos (struct list_of_pos *list, uintptr_t *examined, int n, struct pos pos,\\n                                                                            enum move move)\\n{\\n    unsigned flat_pos, set, bit;\\n    \\n    flat_pos = pos2flat(pos, n);\\n    set = flat_pos >> BITS_PER_EL;\\n    bit = flat_pos & ((1u << BITS_PER_EL) - 1);\\n    if (DEBUG)\\n        printf(\"try %s: flat: %u, set: %u, bit: %u\\\\n\", move2str[move], flat_pos, set, bit);\\n    \\n    if (examined[set] & (1ull << bit))\\n        return;\\n    \\n    if (list->n_pos >= list->n_alloced)\\n    {\\n        /* XXX we assume all allocations succeed */\\n        list->n_alloced = list->n_alloced ? list->n_alloced * 2 : 4;\\n        list->pos = realloc(list->pos, sizeof(list->pos[0]) * list->n_alloced);\\n    }\\n    list->pos[list->n_pos++] = pos;\\n    examined[set] |= 1ull << bit;\\n    if (DEBUG)\\n        printf(\"pushed %s, pos(%d,%d,%d) (flat: %u)\\\\n\", move2str[move], pos.vertical, pos.tail[0], pos.tail[1], flat_pos);\\n}\\n\\nstatic int\\nend_position (struct pos pos, int n)\\n{\\n    return !pos.vertical && pos.tail[0] == n - 1 && pos.tail[1] == n - 2;\\n}\\n\\nint minimumMoves(int** grid, int n, int* gridColSize){\\n    /* For simplicity, the bitmask is the same size for all inputs: n fits into 7 bits and\\n     * \"vertical\" property is 1 bit.\\n     */\\n    uintptr_t examined[ (1 << (1 + 7 + 7)) / sizeof(uintptr_t) / 8];\\n    struct list_of_pos lists[2], *cur_list, *next_list;\\n    int r, c, n_steps;\\n    \\n    assert(gridColSize[0] == n);\\n\\n    memset(examined, 0, sizeof(examined));\\n    memset(lists, 0, sizeof(lists));\\n    \\n    n_steps = 0;\\n    maybe_push_pos(&lists[n_steps & 1], examined, n, (struct pos) { 0, { 0, 0, }}, MOVE_RIGHT);\\n    while (lists[n_steps & 1].n_pos)\\n    {\\n        const struct pos *pos;\\n        struct pos new_pos;\\n        \\n        if (DEBUG)\\n            printf(\"steps: %d\\\\n\", n_steps);\\n        cur_list = &lists[n_steps & 1];\\n        next_list = &lists[!(n_steps & 1)];\\n        ++n_steps;\\n        for (pos = cur_list->pos; pos < cur_list->pos + cur_list->n_pos; ++pos)\\n        {\\n            if (DEBUG)\\n                printf(\"examine pos(%d,%d,%d)\\\\n\", pos->vertical, pos->tail[0], pos->tail[1]);\\n            enum move move;\\n            for (move = MOVE_RIGHT; move < N_MOVES; ++move)\\n            {\\n                switch (move)\\n                {\\n                case MOVE_RIGHT:\\n                    if (pos->vertical)\\n                    {\\n                        if (pos->tail[1] + 1 >= n\\n                            || grid[pos->tail[0] + 0][pos->tail[1] + 1]\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                            continue;\\n                        new_pos = (struct pos) { 1, { pos->tail[0], pos->tail[1] + 1 }};\\n                    }\\n                    else\\n                    {\\n                        if (pos->tail[1] + 2 >= n\\n                            || grid[pos->tail[0] + 0][pos->tail[1] + 2])\\n                            continue;\\n                        new_pos = (struct pos) { 0, { pos->tail[0], pos->tail[1] + 1 }};\\n                    }\\n                    break;\\n                case MOVE_DOWN:\\n                    if (pos->vertical)\\n                    {\\n                        if (pos->tail[0] + 2 >= n\\n                            || grid[pos->tail[0] + 2][pos->tail[1]])\\n                            continue;\\n                        new_pos = (struct pos) { 1, { pos->tail[0] + 1, pos->tail[1] }};\\n                    }\\n                    else\\n                    {\\n                        if (pos->tail[0] + 1 >= n\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 0]\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                            continue;\\n                        new_pos = (struct pos) { 0, { pos->tail[0] + 1, pos->tail[1] }};\\n                    }\\n                    break;\\n                case ROT_CLOCK:\\n                    if (pos->vertical)    \\n                        continue;\\n                    if (pos->tail[0] + 1 >= n\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 0]\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                        continue;\\n                    new_pos = (struct pos) { 1, { pos->tail[0], pos->tail[1] }};\\n                    break;\\n                case ROT_COUNTER:        \\n                    if (!pos->vertical)    \\n                        continue;\\n                    if (pos->tail[1] + 1 >= n\\n                        || grid[pos->tail[0] + 0][pos->tail[1] + 1]\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                        continue;\\n                    new_pos = (struct pos) { 0, { pos->tail[0], pos->tail[1] }};\\n                    break;\\n                }\\n                if (end_position(new_pos, n))\\n                    goto end;\\n                maybe_push_pos(next_list, examined, n, new_pos, move);\\n            }\\n        }\\n        cur_list->n_pos = 0;\\n    }\\n    n_steps = -1;   /* Failure! */\\n    \\n end:\\n    free(lists[0].pos);\\n    free(lists[1].pos);\\n    \\n    return n_steps;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```c\\n/* Approach: breadth-first search.  The first solution is the minimum number of moves.\\n * At each turn, we convert list of current positions to a new list of positions by\\n * converting a position to a new set of positions.  The new set can be empty (no\\n * moves possible) or can contain 1, 2, 3, or 4 new positions.  The game ends when\\n * a new position is at target.\\n *\\n * Keep track of which positions have been examined so as not to calculated them\\n * again and again.\\n */\\n\\n\\nenum move { MOVE_RIGHT, MOVE_DOWN, ROT_CLOCK, ROT_COUNTER, N_MOVES };\\n\\n#if UINTPTR_MAX == 18446744073709551615UL\\n#define BITS_PER_EL 6\\n#else\\n#define BITS_PER_EL 5\\n#endif\\n\\n#define DEBUG 0\\n\\nstruct pos {\\n    int     vertical;\\n    int     tail[2];        /* Position of tail, row, column */\\n};\\n\\nstruct list_of_pos {\\n    struct pos  *pos;\\n    unsigned     n_pos, n_alloced;\\n};\\n\\nstatic unsigned\\npos2flat (struct pos pos, int n)\\n{\\n    return (pos.vertical << 14) | ((unsigned char) pos.tail[0] << 7) | ((unsigned char) pos.tail[1]);\\n}\\n\\nstatic const char *const move2str[] = { \"RIGHT\", \"DOWN\", \"CLOCKWISE\", \"COUNTERCLOCKWISE\", };\\n\\nstatic void\\nmaybe_push_pos (struct list_of_pos *list, uintptr_t *examined, int n, struct pos pos,\\n                                                                            enum move move)\\n{\\n    unsigned flat_pos, set, bit;\\n    \\n    flat_pos = pos2flat(pos, n);\\n    set = flat_pos >> BITS_PER_EL;\\n    bit = flat_pos & ((1u << BITS_PER_EL) - 1);\\n    if (DEBUG)\\n        printf(\"try %s: flat: %u, set: %u, bit: %u\\\\n\", move2str[move], flat_pos, set, bit);\\n    \\n    if (examined[set] & (1ull << bit))\\n        return;\\n    \\n    if (list->n_pos >= list->n_alloced)\\n    {\\n        /* XXX we assume all allocations succeed */\\n        list->n_alloced = list->n_alloced ? list->n_alloced * 2 : 4;\\n        list->pos = realloc(list->pos, sizeof(list->pos[0]) * list->n_alloced);\\n    }\\n    list->pos[list->n_pos++] = pos;\\n    examined[set] |= 1ull << bit;\\n    if (DEBUG)\\n        printf(\"pushed %s, pos(%d,%d,%d) (flat: %u)\\\\n\", move2str[move], pos.vertical, pos.tail[0], pos.tail[1], flat_pos);\\n}\\n\\nstatic int\\nend_position (struct pos pos, int n)\\n{\\n    return !pos.vertical && pos.tail[0] == n - 1 && pos.tail[1] == n - 2;\\n}\\n\\nint minimumMoves(int** grid, int n, int* gridColSize){\\n    /* For simplicity, the bitmask is the same size for all inputs: n fits into 7 bits and\\n     * \"vertical\" property is 1 bit.\\n     */\\n    uintptr_t examined[ (1 << (1 + 7 + 7)) / sizeof(uintptr_t) / 8];\\n    struct list_of_pos lists[2], *cur_list, *next_list;\\n    int r, c, n_steps;\\n    \\n    assert(gridColSize[0] == n);\\n\\n    memset(examined, 0, sizeof(examined));\\n    memset(lists, 0, sizeof(lists));\\n    \\n    n_steps = 0;\\n    maybe_push_pos(&lists[n_steps & 1], examined, n, (struct pos) { 0, { 0, 0, }}, MOVE_RIGHT);\\n    while (lists[n_steps & 1].n_pos)\\n    {\\n        const struct pos *pos;\\n        struct pos new_pos;\\n        \\n        if (DEBUG)\\n            printf(\"steps: %d\\\\n\", n_steps);\\n        cur_list = &lists[n_steps & 1];\\n        next_list = &lists[!(n_steps & 1)];\\n        ++n_steps;\\n        for (pos = cur_list->pos; pos < cur_list->pos + cur_list->n_pos; ++pos)\\n        {\\n            if (DEBUG)\\n                printf(\"examine pos(%d,%d,%d)\\\\n\", pos->vertical, pos->tail[0], pos->tail[1]);\\n            enum move move;\\n            for (move = MOVE_RIGHT; move < N_MOVES; ++move)\\n            {\\n                switch (move)\\n                {\\n                case MOVE_RIGHT:\\n                    if (pos->vertical)\\n                    {\\n                        if (pos->tail[1] + 1 >= n\\n                            || grid[pos->tail[0] + 0][pos->tail[1] + 1]\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                            continue;\\n                        new_pos = (struct pos) { 1, { pos->tail[0], pos->tail[1] + 1 }};\\n                    }\\n                    else\\n                    {\\n                        if (pos->tail[1] + 2 >= n\\n                            || grid[pos->tail[0] + 0][pos->tail[1] + 2])\\n                            continue;\\n                        new_pos = (struct pos) { 0, { pos->tail[0], pos->tail[1] + 1 }};\\n                    }\\n                    break;\\n                case MOVE_DOWN:\\n                    if (pos->vertical)\\n                    {\\n                        if (pos->tail[0] + 2 >= n\\n                            || grid[pos->tail[0] + 2][pos->tail[1]])\\n                            continue;\\n                        new_pos = (struct pos) { 1, { pos->tail[0] + 1, pos->tail[1] }};\\n                    }\\n                    else\\n                    {\\n                        if (pos->tail[0] + 1 >= n\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 0]\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                            continue;\\n                        new_pos = (struct pos) { 0, { pos->tail[0] + 1, pos->tail[1] }};\\n                    }\\n                    break;\\n                case ROT_CLOCK:\\n                    if (pos->vertical)    \\n                        continue;\\n                    if (pos->tail[0] + 1 >= n\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 0]\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                        continue;\\n                    new_pos = (struct pos) { 1, { pos->tail[0], pos->tail[1] }};\\n                    break;\\n                case ROT_COUNTER:        \\n                    if (!pos->vertical)    \\n                        continue;\\n                    if (pos->tail[1] + 1 >= n\\n                        || grid[pos->tail[0] + 0][pos->tail[1] + 1]\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                        continue;\\n                    new_pos = (struct pos) { 0, { pos->tail[0], pos->tail[1] }};\\n                    break;\\n                }\\n                if (end_position(new_pos, n))\\n                    goto end;\\n                maybe_push_pos(next_list, examined, n, new_pos, move);\\n            }\\n        }\\n        cur_list->n_pos = 0;\\n    }\\n    n_steps = -1;   /* Failure! */\\n    \\n end:\\n    free(lists[0].pos);\\n    free(lists[1].pos);\\n    \\n    return n_steps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 993300,
                "title": "java-dijkstra",
                "content": "Preword: this problem is very code heavy.\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][] pos = {{0, 0}, {0, 1}, {0}};\\n        PriorityQueue<int[][]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[2][0], b[2][0]));\\n        Set<String> visited = new HashSet<>();\\n        pq.offer(pos);\\n        visited.add(toString(pos));\\n        while (!pq.isEmpty()) {\\n            int[][] cur = pq.poll();\\n            if (cur[0][0] == n - 1 && cur[0][1] == n - 2 && cur[1][0] == n - 1 && cur[1][1] == n - 1) {\\n                return cur[2][0];\\n            }\\n            int[][] next1 = moveRight(cur, n, grid);\\n            int[][] next2 = moveDown(cur, n, grid);\\n            int[][] next3 = rotate(cur, n, grid);\\n            int[][] next4 = rotatec(cur, n, grid);\\n            if (next1 != null) {\\n                if (visited.add(toString(next1))) {\\n                    pq.offer(next1);\\n                }\\n            }\\n            if (next2 != null) {\\n                if (visited.add(toString(next2))) {\\n                    pq.offer(next2);\\n                }\\n            }\\n            if (next3 != null) {\\n                if (visited.add(toString(next3))) {\\n                    pq.offer(next3);\\n                }\\n            }\\n            if (next4 != null) {\\n                if (visited.add(toString(next4))) {\\n                    pq.offer(next4);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private String toString(int[][] cur) {\\n        return cur[0][0] + \" \" + cur[0][1] + \" \" + cur[1][0] + \" \" + cur[1][1];\\n    }\\n    \\n    private int[][] clone(int[][] cur) {\\n        return new int[][]{{cur[0][0], cur[0][1]}, {cur[1][0], cur[1][1]}, {cur[2][0]}};\\n    }\\n    \\n    private int[][] moveRight(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        next[0][1]++;\\n        next[1][1]++;\\n        if (next[0][1] >= n || next[1][1] >= n) {\\n            return null;\\n        }\\n        if (grid[next[0][0]][next[0][1]] == 1) {\\n            return null;\\n        }\\n        if (grid[next[1][0]][next[1][1]] == 1) {\\n            return null;\\n        }\\n        next[2][0]++;\\n        return next;\\n    }\\n    \\n    private int[][] moveDown(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        next[0][0]++;\\n        next[1][0]++;\\n        if (next[0][0] >= n || next[1][0] >= n) {\\n            return null;\\n        }\\n        if (grid[next[0][0]][next[0][1]] == 1) {\\n            return null;\\n        }\\n        if (grid[next[1][0]][next[1][1]] == 1) {\\n            return null;\\n        }\\n        next[2][0]++;\\n        return next;\\n    }\\n    \\n    private int[][] rotate(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        if (cur[0][0] == cur[1][0] && cur[0][1] + 1 == cur[1][1]) {\\n            if (cur[0][0] + 1 >= n) {\\n                return null;\\n            }\\n            if (grid[cur[0][0] + 1][cur[0][1]] == 1) {\\n                return null;\\n            }\\n            if (grid[cur[1][0] + 1][cur[1][1]] == 1) {\\n                return null;\\n            }\\n            next[1][0]++;\\n            next[1][1]--;\\n            next[2][0]++;\\n            return next;\\n        }\\n        return null;\\n    }\\n    \\n    private int[][] rotatec(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        if (cur[0][0] + 1 == cur[1][0] && cur[0][1] == cur[1][1]) {\\n            if (cur[0][1] + 1 >= n) {\\n                return null;\\n            }\\n            if (grid[cur[0][0]][cur[0][1] + 1] == 1) {\\n                return null;\\n            }\\n            if (grid[cur[1][0]][cur[1][1] + 1] == 1) {\\n                return null;\\n            }\\n            next[1][0]--;\\n            next[1][1]++;\\n            next[2][0]++;\\n            return next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][] pos = {{0, 0}, {0, 1}, {0}};\\n        PriorityQueue<int[][]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[2][0], b[2][0]));\\n        Set<String> visited = new HashSet<>();\\n        pq.offer(pos);\\n        visited.add(toString(pos));\\n        while (!pq.isEmpty()) {\\n            int[][] cur = pq.poll();\\n            if (cur[0][0] == n - 1 && cur[0][1] == n - 2 && cur[1][0] == n - 1 && cur[1][1] == n - 1) {\\n                return cur[2][0];\\n            }\\n            int[][] next1 = moveRight(cur, n, grid);\\n            int[][] next2 = moveDown(cur, n, grid);\\n            int[][] next3 = rotate(cur, n, grid);\\n            int[][] next4 = rotatec(cur, n, grid);\\n            if (next1 != null) {\\n                if (visited.add(toString(next1))) {\\n                    pq.offer(next1);\\n                }\\n            }\\n            if (next2 != null) {\\n                if (visited.add(toString(next2))) {\\n                    pq.offer(next2);\\n                }\\n            }\\n            if (next3 != null) {\\n                if (visited.add(toString(next3))) {\\n                    pq.offer(next3);\\n                }\\n            }\\n            if (next4 != null) {\\n                if (visited.add(toString(next4))) {\\n                    pq.offer(next4);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private String toString(int[][] cur) {\\n        return cur[0][0] + \" \" + cur[0][1] + \" \" + cur[1][0] + \" \" + cur[1][1];\\n    }\\n    \\n    private int[][] clone(int[][] cur) {\\n        return new int[][]{{cur[0][0], cur[0][1]}, {cur[1][0], cur[1][1]}, {cur[2][0]}};\\n    }\\n    \\n    private int[][] moveRight(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        next[0][1]++;\\n        next[1][1]++;\\n        if (next[0][1] >= n || next[1][1] >= n) {\\n            return null;\\n        }\\n        if (grid[next[0][0]][next[0][1]] == 1) {\\n            return null;\\n        }\\n        if (grid[next[1][0]][next[1][1]] == 1) {\\n            return null;\\n        }\\n        next[2][0]++;\\n        return next;\\n    }\\n    \\n    private int[][] moveDown(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        next[0][0]++;\\n        next[1][0]++;\\n        if (next[0][0] >= n || next[1][0] >= n) {\\n            return null;\\n        }\\n        if (grid[next[0][0]][next[0][1]] == 1) {\\n            return null;\\n        }\\n        if (grid[next[1][0]][next[1][1]] == 1) {\\n            return null;\\n        }\\n        next[2][0]++;\\n        return next;\\n    }\\n    \\n    private int[][] rotate(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        if (cur[0][0] == cur[1][0] && cur[0][1] + 1 == cur[1][1]) {\\n            if (cur[0][0] + 1 >= n) {\\n                return null;\\n            }\\n            if (grid[cur[0][0] + 1][cur[0][1]] == 1) {\\n                return null;\\n            }\\n            if (grid[cur[1][0] + 1][cur[1][1]] == 1) {\\n                return null;\\n            }\\n            next[1][0]++;\\n            next[1][1]--;\\n            next[2][0]++;\\n            return next;\\n        }\\n        return null;\\n    }\\n    \\n    private int[][] rotatec(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        if (cur[0][0] + 1 == cur[1][0] && cur[0][1] == cur[1][1]) {\\n            if (cur[0][1] + 1 >= n) {\\n                return null;\\n            }\\n            if (grid[cur[0][0]][cur[0][1] + 1] == 1) {\\n                return null;\\n            }\\n            if (grid[cur[1][0]][cur[1][1] + 1] == 1) {\\n                return null;\\n            }\\n            next[1][0]--;\\n            next[1][1]++;\\n            next[2][0]++;\\n            return next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948735,
                "title": "c-bfs",
                "content": "```\\npublic class Solution\\n{\\n  enum Alignment\\n  {\\n    Vertical,\\n    Horizontal\\n  }\\n\\n  class Key : IEquatable<Key>\\n  {\\n    public (int i, int j) Point { get; }\\n    public Alignment Align { get; }\\n\\n    public Key((int, int) point, Alignment align)\\n    {\\n      Point = point;\\n      Align = align;\\n    }\\n\\n    public override string ToString() => $\"{Point} {Align}\";\\n\\n    public override bool Equals(object obj) => ((Key)obj).Point == Point && ((Key)obj).Align == Align;\\n\\n    public override int GetHashCode() => HashCode.Combine(Point, Align);\\n\\n    public bool Equals(Key other) => other.Point == Point && other.Align == Align;\\n  }\\n\\n  class QueueItem\\n  {\\n    public Key Key { get; }\\n    public int Path { get; }\\n\\n    public QueueItem(Key key, int path)\\n    {\\n      Key = key;\\n      Path = path;\\n    }\\n  }\\n\\n  public int MinimumMoves(int[][] grid)\\n  {\\n    var dp = new Dictionary<Key, int>();\\n\\n    var queue = new Queue<QueueItem>();\\n    queue.Enqueue(new QueueItem(key: new Key((0, 0), Alignment.Horizontal), path: 0));\\n\\n    while (queue.Count > 0)\\n    {\\n      var item = queue.Dequeue();\\n\\n      if (item.Key.Align == Alignment.Horizontal && item.Key.Point == (grid.Length - 1, grid[0].Length - 2))\\n        return item.Path;\\n\\n      if (dp.ContainsKey(item.Key)/* && dp[item.Key] <= item.Path*/)\\n        continue;\\n\\n      dp[item.Key] = item.Path;\\n\\n      var ways = new List<QueueItem>();\\n\\n      // vertical down or right\\n      if (item.Key.Align == Alignment.Vertical)\\n      {\\n        if (item.Key.Point.i + 2 < grid.Length && \\n            grid[item.Key.Point.i + 2][item.Key.Point.j] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i + 1, item.Key.Point.j), Alignment.Vertical), \\n            item.Path + 1));\\n        }\\n\\n        if (item.Key.Point.i + 1 < grid.Length && \\n            item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 1] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j + 1), Alignment.Vertical),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // horizontal down or right\\n      if (item.Key.Align == Alignment.Horizontal)\\n      {\\n        if (item.Key.Point.j + 2 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 2] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j + 1), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n\\n        if (item.Key.Point.i + 1 < grid.Length &&\\n            item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i + 1, item.Key.Point.j), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // rotate to vertical\\n      if (item.Key.Align == Alignment.Horizontal)\\n      {\\n        if (item.Key.Point.i + 1 < grid.Length &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j), Alignment.Vertical),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // rotate to horizontal\\n      if (item.Key.Align == Alignment.Vertical)\\n      {\\n        if (item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 1] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      foreach (var way in ways)\\n        queue.Enqueue(way);\\n    }\\n\\n    return -1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n  enum Alignment\\n  {\\n    Vertical,\\n    Horizontal\\n  }\\n\\n  class Key : IEquatable<Key>\\n  {\\n    public (int i, int j) Point { get; }\\n    public Alignment Align { get; }\\n\\n    public Key((int, int) point, Alignment align)\\n    {\\n      Point = point;\\n      Align = align;\\n    }\\n\\n    public override string ToString() => $\"{Point} {Align}\";\\n\\n    public override bool Equals(object obj) => ((Key)obj).Point == Point && ((Key)obj).Align == Align;\\n\\n    public override int GetHashCode() => HashCode.Combine(Point, Align);\\n\\n    public bool Equals(Key other) => other.Point == Point && other.Align == Align;\\n  }\\n\\n  class QueueItem\\n  {\\n    public Key Key { get; }\\n    public int Path { get; }\\n\\n    public QueueItem(Key key, int path)\\n    {\\n      Key = key;\\n      Path = path;\\n    }\\n  }\\n\\n  public int MinimumMoves(int[][] grid)\\n  {\\n    var dp = new Dictionary<Key, int>();\\n\\n    var queue = new Queue<QueueItem>();\\n    queue.Enqueue(new QueueItem(key: new Key((0, 0), Alignment.Horizontal), path: 0));\\n\\n    while (queue.Count > 0)\\n    {\\n      var item = queue.Dequeue();\\n\\n      if (item.Key.Align == Alignment.Horizontal && item.Key.Point == (grid.Length - 1, grid[0].Length - 2))\\n        return item.Path;\\n\\n      if (dp.ContainsKey(item.Key)/* && dp[item.Key] <= item.Path*/)\\n        continue;\\n\\n      dp[item.Key] = item.Path;\\n\\n      var ways = new List<QueueItem>();\\n\\n      // vertical down or right\\n      if (item.Key.Align == Alignment.Vertical)\\n      {\\n        if (item.Key.Point.i + 2 < grid.Length && \\n            grid[item.Key.Point.i + 2][item.Key.Point.j] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i + 1, item.Key.Point.j), Alignment.Vertical), \\n            item.Path + 1));\\n        }\\n\\n        if (item.Key.Point.i + 1 < grid.Length && \\n            item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 1] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j + 1), Alignment.Vertical),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // horizontal down or right\\n      if (item.Key.Align == Alignment.Horizontal)\\n      {\\n        if (item.Key.Point.j + 2 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 2] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j + 1), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n\\n        if (item.Key.Point.i + 1 < grid.Length &&\\n            item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i + 1, item.Key.Point.j), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // rotate to vertical\\n      if (item.Key.Align == Alignment.Horizontal)\\n      {\\n        if (item.Key.Point.i + 1 < grid.Length &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j), Alignment.Vertical),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // rotate to horizontal\\n      if (item.Key.Align == Alignment.Vertical)\\n      {\\n        if (item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 1] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      foreach (var way in ways)\\n        queue.Enqueue(way);\\n    }\\n\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937813,
                "title": "c-short-dfs-with-dp-100-time-and-99-mem",
                "content": "When we see a (likely) DP problem, we should think about what is important (quote by Erricto). The important here is the position of the snake, that is: the coordinates of the tail, and the direction. So, the state of the snake on the board can be represent with a triplet `[x,y,z]` with `[x,y]` is coordinates of the tail, and `z =  0` if horizontal and `z = 1` if vertical. When the states are well defined, we can use dfs with memorization to solve the problem easily, as all possible transitions from one state to other states is clearly defined in the description. \\n\\nOne small notes is you should not rotate two times in a row. Use a variable `rotate` to check it.\\n\\n```CPP\\nclass Solution {\\npublic:\\n    int memo[101][101][2] = {};\\n    int INF = 1e9;\\n    int dfs(vector<vector<int>>& grid, int x, int y, int z, int rotate) {\\n        const int n = grid.size();\\n        int nx = z == 0? x : x+1;\\n        int ny = z == 0? y+1 : y;\\n        if (memo[x][y][z] > 0) return memo[x][y][z];\\n        if (x >= n || y >= n || nx >= n || ny >= n) return INF;\\n        if (grid[x][y] == 1 || grid[nx][ny] == 1) return INF;\\n        if (x == n-1 && y == n-2 && z == 0) return 0;\\n        int ret = INF;\\n        // move right\\n        ret = min(ret, dfs(grid, x, y+1, z, 0));\\n        // move down\\n        ret = min(ret, dfs(grid, x+1, y, z, 0));\\n        // rotate //\\n        if (!rotate && x+1 < n && y+1 < n && grid[x+1][y+1] == 0)\\n            ret = min(ret, dfs(grid, x, y, 1^z, 1));\\n        return memo[x][y][z] = ret == INF? INF : 1+ret;\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int x = 0, y = 0, z = 0, rotate = 0;\\n        int ret = dfs(grid,x,y,z,rotate);\\n        return ret == INF? -1 : ret;\\n    }\\n};\\n\\n/*\\nstate of the snake:\\n[x,y,z]\\n(x,y) -> coordinates of tail\\nz: direction\\n*/\\n```",
                "solutionTags": [],
                "code": "```CPP\\nclass Solution {\\npublic:\\n    int memo[101][101][2] = {};\\n    int INF = 1e9;\\n    int dfs(vector<vector<int>>& grid, int x, int y, int z, int rotate) {\\n        const int n = grid.size();\\n        int nx = z == 0? x : x+1;\\n        int ny = z == 0? y+1 : y;\\n        if (memo[x][y][z] > 0) return memo[x][y][z];\\n        if (x >= n || y >= n || nx >= n || ny >= n) return INF;\\n        if (grid[x][y] == 1 || grid[nx][ny] == 1) return INF;\\n        if (x == n-1 && y == n-2 && z == 0) return 0;\\n        int ret = INF;\\n        // move right\\n        ret = min(ret, dfs(grid, x, y+1, z, 0));\\n        // move down\\n        ret = min(ret, dfs(grid, x+1, y, z, 0));\\n        // rotate //\\n        if (!rotate && x+1 < n && y+1 < n && grid[x+1][y+1] == 0)\\n            ret = min(ret, dfs(grid, x, y, 1^z, 1));\\n        return memo[x][y][z] = ret == INF? INF : 1+ret;\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int x = 0, y = 0, z = 0, rotate = 0;\\n        int ret = dfs(grid,x,y,z,rotate);\\n        return ret == INF? -1 : ret;\\n    }\\n};\\n\\n/*\\nstate of the snake:\\n[x,y,z]\\n(x,y) -> coordinates of tail\\nz: direction\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925213,
                "title": "c-bfs-oo",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        const vector<pair<int,int>> dirs = {{0,1}, {0,-1},{1,0},{-1,0}};\\n        auto visited = vector(n, vector(n, vector(2, false)));\\n        queue<pair<State, int>> q;\\n        q.push(pair(State(grid), 0));\\n        visited[0][0][0] = true;\\n        while(!q.empty()){\\n            auto [s, step] = q.front(); q.pop();\\n            for(auto p : s.neighbor()){\\n                if(p.i == n-1 && p.j == n-2) return step+1;\\n                if(visited[p.i][p.j][p.rotate]) continue;\\n                visited[p.i][p.j][p.rotate] = true;\\n                q.push(pair(p, step+1));\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    struct State{\\n        State(const vector<vector<int>>& grid) : g(grid), n(grid.size()){}\\n        \\n        vector<State> neighbor() const{\\n            static const vector<pair<int,int>> dirs = {{0,1}, {1,0}};\\n            vector<State> res;\\n            for(auto [di, dj]:dirs){\\n                State p = *this;\\n                p.i = i+di, p.j = j+dj;\\n                if(p.isValid()) res.push_back(p);\\n            }\\n            \\n            if(isValidToRotate()){\\n                State r = *this;\\n                r.rotate = !r.rotate;\\n                if(r.isValid()) res.push_back(r);\\n            }           \\n            return res;\\n        }\\n        \\n        bool isValid() const{\\n            int i1 = i, j1 = j+1;\\n            if(rotate) i1 = i+1, j1=j;\\n            return isValid(i, j) && isValid(i1, j1);\\n        }\\n        \\n        bool isValidToRotate() const{\\n            return isValid(i, j) && isValid(i, j+1) && isValid(i+1, j) && isValid(i+1, j+1);\\n        }\\n        \\n        bool isValid(int x, int y) const{\\n            return x>=0 && x<n && y>=0 && y<n && g[x][y] == 0;\\n        }\\n        \\n        const vector<vector<int>>& g;\\n        const int n;\\n        int i = 0;\\n        int j = 0;\\n        bool rotate = false;\\n    };\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        const vector<pair<int,int>> dirs = {{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 920081,
                "title": "c-extension-of-normal-bfs-with-inline-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& gd) {\\n        int m=gd.size(), n=gd.at(0).size(), lev=0; \\n        // stores postion (x, y) and heading of the snake\\n        // heading: 0: to right, 1: to down\\n        queue<vector<int>> que; \\n        // heading vector of the snake\\n        vector<int> dx_head {0, 1};\\n        vector<int> dy_head {1, 0};   \\n        // direction of one step next motion \\n        vector<int> dx {1, 0};\\n        vector<int> dy {0, 1}; \\n\\n        // initial state \\n        que.push({0, 0, 0});     // (x, y, heading)\\n        \\n        // keep track of the visitd states\\n        bool vis[100][100][2];\\n        memset(vis, false, sizeof(vis));\\n        vis[0][0][0]=true;\\n        \\n        while(!que.empty()){\\n            int sz=que.size();\\n            for(int k=0; k<sz; k++){\\n                auto cur = que.front(); que.pop();\\n                // extract position (x, y) and heading (theta)\\n                int x=cur.at(0), y=cur.at(1), th=cur.at(2);\\n                \\n                // if reached to goal, levels of BFS done up to here \\n                if(x==m-1 && y==n-2 && th==0) return lev;\\n                \\n                for(int i=0; i<2; i++){\\n                    // compute next snake tail position\\n                    // if it is outside of the grid or collides with an obstacle, do not add to queue\\n                    int xn=x+dx.at(i);\\n                    int yn=y+dy.at(i);\\n                    if(xn<0 || yn<0 || m-1<xn || n-1<yn || gd.at(xn).at(yn)==1) continue;\\n                    \\n                    // compute next snake head position and do the same evaluation \\n                    int xnh = xn+dx_head.at(th);\\n                    int ynh = yn+dy_head.at(th); \\n                    if(xnh<0 || ynh<0 || m-1<xnh || n-1<ynh ||  gd.at(xnh).at(ynh)==1) continue;\\n                    \\n                    // if the state position and heading of the snake in grid is already added to queue, do not proceed\\n                    if(vis[xn][yn][th]) continue; \\n                    vis[xn][yn][th]=true;\\n                    que.push({xn, yn, th}); \\n                }\\n                \\n                // if rotation is feasible, rotate the snake and add to queue \\n                if( m-1<x+1 || n-1<y+1 ||\\n                   gd.at(x+1).at(y+1)==1 || gd.at(x+1).at(y)==1 || gd.at(x).at(y+1)==1) continue;\\n                int thn = th==1 ? 0 : 1;\\n                if(vis[x][y][thn]) continue; \\n                vis[x][y][thn]=true; \\n                que.push({x, y, thn});\\n            }\\n            lev++; \\n        }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& gd) {\\n        int m=gd.size(), n=gd.at(0).size(), lev=0; \\n        // stores postion (x, y) and heading of the snake\\n        // heading: 0: to right, 1: to down\\n        queue<vector<int>> que; \\n        // heading vector of the snake\\n        vector<int> dx_head {0, 1};\\n        vector<int> dy_head {1, 0};   \\n        // direction of one step next motion \\n        vector<int> dx {1, 0};\\n        vector<int> dy {0, 1}; \\n\\n        // initial state \\n        que.push({0, 0, 0});     // (x, y, heading)\\n        \\n        // keep track of the visitd states\\n        bool vis[100][100][2];\\n        memset(vis, false, sizeof(vis));\\n        vis[0][0][0]=true;\\n        \\n        while(!que.empty()){\\n            int sz=que.size();\\n            for(int k=0; k<sz; k++){\\n                auto cur = que.front(); que.pop();\\n                // extract position (x, y) and heading (theta)\\n                int x=cur.at(0), y=cur.at(1), th=cur.at(2);\\n                \\n                // if reached to goal, levels of BFS done up to here \\n                if(x==m-1 && y==n-2 && th==0) return lev;\\n                \\n                for(int i=0; i<2; i++){\\n                    // compute next snake tail position\\n                    // if it is outside of the grid or collides with an obstacle, do not add to queue\\n                    int xn=x+dx.at(i);\\n                    int yn=y+dy.at(i);\\n                    if(xn<0 || yn<0 || m-1<xn || n-1<yn || gd.at(xn).at(yn)==1) continue;\\n                    \\n                    // compute next snake head position and do the same evaluation \\n                    int xnh = xn+dx_head.at(th);\\n                    int ynh = yn+dy_head.at(th); \\n                    if(xnh<0 || ynh<0 || m-1<xnh || n-1<ynh ||  gd.at(xnh).at(ynh)==1) continue;\\n                    \\n                    // if the state position and heading of the snake in grid is already added to queue, do not proceed\\n                    if(vis[xn][yn][th]) continue; \\n                    vis[xn][yn][th]=true;\\n                    que.push({xn, yn, th}); \\n                }\\n                \\n                // if rotation is feasible, rotate the snake and add to queue \\n                if( m-1<x+1 || n-1<y+1 ||\\n                   gd.at(x+1).at(y+1)==1 || gd.at(x+1).at(y)==1 || gd.at(x).at(y+1)==1) continue;\\n                int thn = th==1 ? 0 : 1;\\n                if(vis[x][y][thn]) continue; \\n                vis[x][y][thn]=true; \\n                que.push({x, y, thn});\\n            }\\n            lev++; \\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884020,
                "title": "python-3-clean-bfs-beat-100",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        end = (n-1, n-2, n-1, n-1)\\n        start = (0, 0, 0, 1)\\n        queue = [start]\\n        visited = set()\\n        count = 0\\n        while queue:\\n            newQueue = []\\n            for pos in queue:\\n                if pos in visited:\\n                    continue\\n                if pos == end:\\n                    return count\\n                visited.add(pos)\\n                x1, y1, x2, y2 = pos\\n                if x1 == x2:\\n                    #horizontal\\n                    if y2+1 < n and grid[x2][y2+1] == 0:\\n                        #right\\n                        newQueue.append((x1, y1+1, x2, y2+1))\\n                    if x1+1< n and grid[x1+1][y1] == 0 and grid[x2+1][y2] == 0:\\n                        #down\\n                        newQueue.append((x1+1, y1, x2+1, y2))\\n                        #rotate\\n                        newQueue.append((x1,y1, x2+1, y2-1))\\n                elif y1 == y2:\\n                    #vertical\\n                    if x2+1 < n and grid[x2+1][y2] == 0:\\n                        #down\\n                        newQueue.append((x1+1, y1, x2+1, y2))\\n                    if y1+1< n and grid[x1][y1+1] == 0 and grid[x2][y2+1] == 0:\\n                        #right\\n                        newQueue.append((x1, y1+1, x2, y2+1))\\n                        #rotate\\n                        newQueue.append((x1,y1, x2-1, y2+1))\\n                        \\n            count += 1\\n            queue = newQueue\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        end = (n-1, n-2, n-1, n-1)\\n        start = (0, 0, 0, 1)\\n        queue = [start]\\n        visited = set()\\n        count = 0\\n        while queue:\\n            newQueue = []\\n            for pos in queue:\\n                if pos in visited:\\n                    continue\\n                if pos == end:\\n                    return count\\n                visited.add(pos)\\n                x1, y1, x2, y2 = pos\\n                if x1 == x2:\\n                    #horizontal\\n                    if y2+1 < n and grid[x2][y2+1] == 0:\\n                        #right\\n                        newQueue.append((x1, y1+1, x2, y2+1))\\n                    if x1+1< n and grid[x1+1][y1] == 0 and grid[x2+1][y2] == 0:\\n                        #down\\n                        newQueue.append((x1+1, y1, x2+1, y2))\\n                        #rotate\\n                        newQueue.append((x1,y1, x2+1, y2-1))\\n                elif y1 == y2:\\n                    #vertical\\n                    if x2+1 < n and grid[x2+1][y2] == 0:\\n                        #down\\n                        newQueue.append((x1+1, y1, x2+1, y2))\\n                    if y1+1< n and grid[x1][y1+1] == 0 and grid[x2][y2+1] == 0:\\n                        #right\\n                        newQueue.append((x1, y1+1, x2, y2+1))\\n                        #rotate\\n                        newQueue.append((x1,y1, x2-1, y2+1))\\n                        \\n            count += 1\\n            queue = newQueue\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865399,
                "title": "rust",
                "content": "The idea is a simple bfs. A node is defined as the position of the snake\\'s tail and the direction of the head, in reference to the tail.\\n\\nWe then do a simple bfs with the given start and end nodes.\\n\\nI think this code is pretty idiomatic. Please add a comment if you think anything can be improved.\\n\\n```\\nuse std::collections::*;\\n\\n/// Indicates whether or not a spot in the grid is a wall.\\ntype IsWall = bool;\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub struct Pos {\\n    i: usize,\\n    j: usize,\\n}\\n\\nimpl Pos {\\n    pub fn new(i: usize, j: usize) -> Pos {\\n        Pos { i, j }\\n    }\\n\\n    fn in_dir(&self, dir: HeadDir) -> Pos {\\n        match dir {\\n            HeadDir::Down => Pos::new(self.i + 1, self.j),\\n            HeadDir::Right => Pos::new(self.i, self.j + 1),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub enum HeadDir {\\n    Down,\\n    Right,\\n}\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub struct Snake {\\n    /// The position of the snake\\'s tail.\\n    tail: Pos,\\n    /// Where the head is pointing, relative to the tail.\\n    /// E.g. if tail is at `Pos {i:0, j:0}` and head_dir is `Right`, then the head is at `Pos {i: 0, j: 1}`.\\n    head_dir: HeadDir,\\n}\\n\\nimpl Snake {\\n    pub fn new(tail: Pos, head_dir: HeadDir) -> Snake {\\n        Snake { tail, head_dir }\\n    }\\n}\\n\\nfn adj_nodes(node: Snake, grid: &Vec<Vec<IsWall>>) -> Vec<Snake> {\\n    /// Returns true if the given `pos` can be walked over on the given `grid.\\n    fn walkable(pos: Pos, grid: &Vec<Vec<IsWall>>) -> bool {\\n        pos.i < grid.len() && pos.j < grid[pos.i].len() && !grid[pos.i][pos.j]\\n    }\\n\\n    let mut adjs = Vec::with_capacity(3);\\n\\n    // Move right.\\n    adjs.push(Snake::new(node.tail.in_dir(HeadDir::Right), node.head_dir));\\n    // Move down.\\n    adjs.push(Snake::new(node.tail.in_dir(HeadDir::Down), node.head_dir));\\n\\n    // Rotate clockwise / counter-clockwise.\\n    let rotate = match node.head_dir {\\n        HeadDir::Right => Snake::new(node.tail, HeadDir::Down),\\n        HeadDir::Down => Snake::new(node.tail, HeadDir::Right),\\n    };\\n    let corner_pos = node.tail.in_dir(HeadDir::Right).in_dir(HeadDir::Down);\\n    if walkable(corner_pos, grid) {\\n        adjs.push(rotate);\\n    }\\n\\n    adjs.into_iter()\\n        .filter(|snake| {\\n            walkable(snake.tail, grid) && walkable(snake.tail.in_dir(snake.head_dir), grid)\\n        })\\n        .collect()\\n}\\n\\nfn _minimum_moves(start: Snake, end: Snake, grid: Vec<Vec<IsWall>>) -> Option<usize> {\\n    let mut q = VecDeque::new();\\n    q.push_back((start, 0));\\n    let mut in_q = HashSet::new();\\n    in_q.insert(start);\\n\\n    while let Some((node, dist)) = q.pop_front() {\\n        // println!(\"{:?} {:?} {:?}\", node, dist, q.len());\\n        if node == end {\\n            return Some(dist);\\n        }\\n\\n        for adj_node in adj_nodes(node, &grid) {\\n            if in_q.insert(adj_node) {\\n                q.push_back((adj_node, dist + 1));\\n            }\\n        }\\n    }\\n\\n    None\\n}\\n\\nfn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n    let grid: Vec<Vec<IsWall>> = grid\\n        .into_iter()\\n        .map(|row| row.into_iter().map(|val| val == 1).collect())\\n        .collect();\\n    let start = Snake::new(Pos::new(0, 0), HeadDir::Right);\\n    let end = Snake::new(Pos::new(grid.len() - 1, grid.len() - 2), HeadDir::Right);\\n    _minimum_moves(start, end, grid)\\n        .map(|x| x as i32)\\n        .unwrap_or(-1)\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_snake_in_a_grid_1() {\\n        let grid = vec![\\n            vec![0, 0, 0, 0, 0, 1],\\n            vec![1, 1, 0, 0, 1, 0],\\n            vec![0, 0, 0, 0, 1, 1],\\n            vec![0, 0, 1, 0, 1, 0],\\n            vec![0, 1, 1, 0, 0, 0],\\n            vec![0, 1, 1, 0, 0, 0],\\n        ];\\n        assert_eq!(minimum_moves(grid), 11);\\n    }\\n\\n    #[test]\\n    fn test_snake_in_a_grid_2() {\\n        let grid = vec![\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],\\n            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\\n            vec![0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0],\\n            vec![0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0],\\n            vec![0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n        ];\\n        assert_eq!(minimum_moves(grid), -1);\\n    }\\n}\\n\\n\\nimpl Solution {\\n    pub fn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n        minimum_moves(grid)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::*;\\n\\n/// Indicates whether or not a spot in the grid is a wall.\\ntype IsWall = bool;\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub struct Pos {\\n    i: usize,\\n    j: usize,\\n}\\n\\nimpl Pos {\\n    pub fn new(i: usize, j: usize) -> Pos {\\n        Pos { i, j }\\n    }\\n\\n    fn in_dir(&self, dir: HeadDir) -> Pos {\\n        match dir {\\n            HeadDir::Down => Pos::new(self.i + 1, self.j),\\n            HeadDir::Right => Pos::new(self.i, self.j + 1),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub enum HeadDir {\\n    Down,\\n    Right,\\n}\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub struct Snake {\\n    /// The position of the snake\\'s tail.\\n    tail: Pos,\\n    /// Where the head is pointing, relative to the tail.\\n    /// E.g. if tail is at `Pos {i:0, j:0}` and head_dir is `Right`, then the head is at `Pos {i: 0, j: 1}`.\\n    head_dir: HeadDir,\\n}\\n\\nimpl Snake {\\n    pub fn new(tail: Pos, head_dir: HeadDir) -> Snake {\\n        Snake { tail, head_dir }\\n    }\\n}\\n\\nfn adj_nodes(node: Snake, grid: &Vec<Vec<IsWall>>) -> Vec<Snake> {\\n    /// Returns true if the given `pos` can be walked over on the given `grid.\\n    fn walkable(pos: Pos, grid: &Vec<Vec<IsWall>>) -> bool {\\n        pos.i < grid.len() && pos.j < grid[pos.i].len() && !grid[pos.i][pos.j]\\n    }\\n\\n    let mut adjs = Vec::with_capacity(3);\\n\\n    // Move right.\\n    adjs.push(Snake::new(node.tail.in_dir(HeadDir::Right), node.head_dir));\\n    // Move down.\\n    adjs.push(Snake::new(node.tail.in_dir(HeadDir::Down), node.head_dir));\\n\\n    // Rotate clockwise / counter-clockwise.\\n    let rotate = match node.head_dir {\\n        HeadDir::Right => Snake::new(node.tail, HeadDir::Down),\\n        HeadDir::Down => Snake::new(node.tail, HeadDir::Right),\\n    };\\n    let corner_pos = node.tail.in_dir(HeadDir::Right).in_dir(HeadDir::Down);\\n    if walkable(corner_pos, grid) {\\n        adjs.push(rotate);\\n    }\\n\\n    adjs.into_iter()\\n        .filter(|snake| {\\n            walkable(snake.tail, grid) && walkable(snake.tail.in_dir(snake.head_dir), grid)\\n        })\\n        .collect()\\n}\\n\\nfn _minimum_moves(start: Snake, end: Snake, grid: Vec<Vec<IsWall>>) -> Option<usize> {\\n    let mut q = VecDeque::new();\\n    q.push_back((start, 0));\\n    let mut in_q = HashSet::new();\\n    in_q.insert(start);\\n\\n    while let Some((node, dist)) = q.pop_front() {\\n        // println!(\"{:?} {:?} {:?}\", node, dist, q.len());\\n        if node == end {\\n            return Some(dist);\\n        }\\n\\n        for adj_node in adj_nodes(node, &grid) {\\n            if in_q.insert(adj_node) {\\n                q.push_back((adj_node, dist + 1));\\n            }\\n        }\\n    }\\n\\n    None\\n}\\n\\nfn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n    let grid: Vec<Vec<IsWall>> = grid\\n        .into_iter()\\n        .map(|row| row.into_iter().map(|val| val == 1).collect())\\n        .collect();\\n    let start = Snake::new(Pos::new(0, 0), HeadDir::Right);\\n    let end = Snake::new(Pos::new(grid.len() - 1, grid.len() - 2), HeadDir::Right);\\n    _minimum_moves(start, end, grid)\\n        .map(|x| x as i32)\\n        .unwrap_or(-1)\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_snake_in_a_grid_1() {\\n        let grid = vec![\\n            vec![0, 0, 0, 0, 0, 1],\\n            vec![1, 1, 0, 0, 1, 0],\\n            vec![0, 0, 0, 0, 1, 1],\\n            vec![0, 0, 1, 0, 1, 0],\\n            vec![0, 1, 1, 0, 0, 0],\\n            vec![0, 1, 1, 0, 0, 0],\\n        ];\\n        assert_eq!(minimum_moves(grid), 11);\\n    }\\n\\n    #[test]\\n    fn test_snake_in_a_grid_2() {\\n        let grid = vec![\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],\\n            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\\n            vec![0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0],\\n            vec![0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0],\\n            vec![0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n        ];\\n        assert_eq!(minimum_moves(grid), -1);\\n    }\\n}\\n\\n\\nimpl Solution {\\n    pub fn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n        minimum_moves(grid)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845782,
                "title": "javascript-solution-modularized",
                "content": "```\\nconst canGoRight = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') { \\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  } else {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (grid[snakeTail[0]][snakeTail[1] + 1] === 0 && grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  }\\n}\\nconst canGoDown = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') {\\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (snakeTail[0] < grid.length - 1 && grid[snakeTail[0] + 1][snakeTail[1]] === 0 && grid[snakeHead[0] + 1][snakeHead[1]] === 0);\\n  } else {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (snakeHead[0] < grid.length - 1 && grid[snakeHead[0] + 1][snakeHead[1]] === 0\\n    );\\n  }\\n}\\nconst canRotateClockwise = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') {\\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (snakeTail[0] < grid.length - 1 && grid[snakeTail[0] + 1][snakeTail[1]] === 0 && grid[snakeHead[0] + 1][snakeHead[1]] === 0);\\n  } else { return false; }\\n}\\nconst canRotateCounterClockwise = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'vertical\\') {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (grid[snakeTail[0]][snakeTail[1] + 1] === 0 && grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  } else { return false; }\\n}\\nconst minimumMoves = (grid) => {\\n  const visitedLocations = [];\\n  const choices = {\\n    current: [], \\n    next: []\\n  };\\n  choices.current.push([0, 0, \\'horizontal\\']);\\n  let totalMoves = 0;\\n  while (choices.current.length) {\\n    choices.next = [];\\n    for (let i = 0; i < choices.current.length; i++) {\\n      let ithChoiceAsPrimitive = JSON.stringify(choices.current[i]);\\n      if (!visitedLocations.includes(ithChoiceAsPrimitive)) {\\n        visitedLocations.push(ithChoiceAsPrimitive);\\n        let snakeTail = choices.current[i];\\n        if (snakeTail[0] === grid.length - 1 && snakeTail[1] === grid.length - 2 && snakeTail[2] === \\'horizontal\\') { return totalMoves; }\\n        if (canGoRight(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1] + 1, snakeTail[2]]); }\\n        if (canGoDown(grid, snakeTail)) { choices.next.push([snakeTail[0] + 1, snakeTail[1], snakeTail[2]]); }\\n        if (canRotateClockwise(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1], \\'vertical\\']); }\\n        if (canRotateCounterClockwise(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1], \\'horizontal\\']); }\\n      }\\n    }\\n    totalMoves++;\\n    choices.current = choices.next;\\n  }\\n  return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst canGoRight = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') { \\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  } else {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (grid[snakeTail[0]][snakeTail[1] + 1] === 0 && grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  }\\n}\\nconst canGoDown = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') {\\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (snakeTail[0] < grid.length - 1 && grid[snakeTail[0] + 1][snakeTail[1]] === 0 && grid[snakeHead[0] + 1][snakeHead[1]] === 0);\\n  } else {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (snakeHead[0] < grid.length - 1 && grid[snakeHead[0] + 1][snakeHead[1]] === 0\\n    );\\n  }\\n}\\nconst canRotateClockwise = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') {\\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (snakeTail[0] < grid.length - 1 && grid[snakeTail[0] + 1][snakeTail[1]] === 0 && grid[snakeHead[0] + 1][snakeHead[1]] === 0);\\n  } else { return false; }\\n}\\nconst canRotateCounterClockwise = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'vertical\\') {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (grid[snakeTail[0]][snakeTail[1] + 1] === 0 && grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  } else { return false; }\\n}\\nconst minimumMoves = (grid) => {\\n  const visitedLocations = [];\\n  const choices = {\\n    current: [], \\n    next: []\\n  };\\n  choices.current.push([0, 0, \\'horizontal\\']);\\n  let totalMoves = 0;\\n  while (choices.current.length) {\\n    choices.next = [];\\n    for (let i = 0; i < choices.current.length; i++) {\\n      let ithChoiceAsPrimitive = JSON.stringify(choices.current[i]);\\n      if (!visitedLocations.includes(ithChoiceAsPrimitive)) {\\n        visitedLocations.push(ithChoiceAsPrimitive);\\n        let snakeTail = choices.current[i];\\n        if (snakeTail[0] === grid.length - 1 && snakeTail[1] === grid.length - 2 && snakeTail[2] === \\'horizontal\\') { return totalMoves; }\\n        if (canGoRight(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1] + 1, snakeTail[2]]); }\\n        if (canGoDown(grid, snakeTail)) { choices.next.push([snakeTail[0] + 1, snakeTail[1], snakeTail[2]]); }\\n        if (canRotateClockwise(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1], \\'vertical\\']); }\\n        if (canRotateCounterClockwise(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1], \\'horizontal\\']); }\\n      }\\n    }\\n    totalMoves++;\\n    choices.current = choices.next;\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799557,
                "title": "java-dfs-memo-3ms-long-code-but-easy-to-understand",
                "content": "Use two n * n matrix to track minimum steps from i, j to end when the snake is either vertical or horizontal. Both scenario check whether it can move right, move left or rotate and do dfs accordingly, and calculate minimum steps in dp. Doing backtracking in place. grid[i][j] = -1 means have been here in horizonal direction, grid[i][j] = -2 is vertical and grid[i][j] = -3 is both.\\n\\nIt would be a simpler question if it only asks whether the snake can reach the end, which doesn\\'t require memorization at all. But since it asks for the min steps, it becomes a backtracking problem.\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dp1 = new int[n][n];\\n        int[][] dp2 = new int[n][n];\\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp1[i], -2);\\n            Arrays.fill(dp2[i], -2);\\n        }\\n        return dfs(grid, n, 0, 0, -1, dp1, dp2);\\n    }\\n    \\n    private int dfs(int[][] grid, int n, int i, int j, int direction, int[][] dp1, int[][] dp2){\\n        int res = Integer.MAX_VALUE;\\n        if(direction == -1){  // horizontal\\n            if(i == n - 1 && j == n - 2)  // reach target\\n                return 0;\\n            if(dp1[i][j] != -2)\\n                return dp1[i][j];\\n            if(j + 2 < n && grid[i][j+2] != 1 && grid[i][j+1] != -1 && grid[i][j+1] != -3){  // move right\\n                grid[i][j+1] -= 1;\\n                int temp = dfs(grid, n, i, j+1, -1, dp1, dp2);\\n                if(temp != -1)\\n                    res = Math.min(res, temp + 1);\\n                grid[i][j+1] += 1;\\n            }\\n            if(i < n - 1 && grid[i+1][j] != 1 && grid[i+1][j+1] != 1){\\n                if(grid[i+1][j] != -1 && grid[i+1][j] != -3){  // move down\\n                    grid[i+1][j] -= 1;\\n                    int temp = dfs(grid, n, i+1, j, -1, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i+1][j] += 1;\\n                }\\n                if(grid[i][j] != -2 && grid[i][j] != -3){  // rotate\\n                    grid[i][j] -= 2;\\n                    int temp = dfs(grid, n, i, j, -2, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j] += 2;\\n                }\\n            }\\n        } else {  // vertical\\n            if(dp2[i][j] != -2)\\n                return dp2[i][j];\\n            if(i + 2 < n && grid[i+2][j] != 1 && grid[i+1][j] != -2 && grid[i+1][j] != -3){ // move down\\n                grid[i+1][j] -= 2;\\n                int temp = dfs(grid, n, i+1, j, -2, dp1, dp2);\\n                if(temp != -1)\\n                    res = Math.min(res, temp + 1);\\n                grid[i+1][j] += 2;\\n            }\\n            if(j < n - 1 && grid[i][j+1] != 1 && grid[i+1][j+1] != 1){\\n                if(grid[i][j+1] != -2 && grid[i][j+1] != -3){  // move right\\n                    grid[i][j+1] -= 2;\\n                    int temp = dfs(grid, n, i, j+1, -2, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j+1] += 2;\\n                }\\n                if(grid[i][j] != -1 && grid[i][j] != -3){  // rotate\\n                    grid[i][j] -= 1;\\n                    int temp = dfs(grid, n, i, j, -1, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j] += 1;\\n                }\\n            }\\n        }\\n        res = res == Integer.MAX_VALUE ? -1 : res;\\n        if(direction == -1)\\n            dp1[i][j] = res;\\n        else\\n            dp2[i][j] = res;\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dp1 = new int[n][n];\\n        int[][] dp2 = new int[n][n];\\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp1[i], -2);\\n            Arrays.fill(dp2[i], -2);\\n        }\\n        return dfs(grid, n, 0, 0, -1, dp1, dp2);\\n    }\\n    \\n    private int dfs(int[][] grid, int n, int i, int j, int direction, int[][] dp1, int[][] dp2){\\n        int res = Integer.MAX_VALUE;\\n        if(direction == -1){  // horizontal\\n            if(i == n - 1 && j == n - 2)  // reach target\\n                return 0;\\n            if(dp1[i][j] != -2)\\n                return dp1[i][j];\\n            if(j + 2 < n && grid[i][j+2] != 1 && grid[i][j+1] != -1 && grid[i][j+1] != -3){  // move right\\n                grid[i][j+1] -= 1;\\n                int temp = dfs(grid, n, i, j+1, -1, dp1, dp2);\\n                if(temp != -1)\\n                    res = Math.min(res, temp + 1);\\n                grid[i][j+1] += 1;\\n            }\\n            if(i < n - 1 && grid[i+1][j] != 1 && grid[i+1][j+1] != 1){\\n                if(grid[i+1][j] != -1 && grid[i+1][j] != -3){  // move down\\n                    grid[i+1][j] -= 1;\\n                    int temp = dfs(grid, n, i+1, j, -1, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i+1][j] += 1;\\n                }\\n                if(grid[i][j] != -2 && grid[i][j] != -3){  // rotate\\n                    grid[i][j] -= 2;\\n                    int temp = dfs(grid, n, i, j, -2, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j] += 2;\\n                }\\n            }\\n        } else {  // vertical\\n            if(dp2[i][j] != -2)\\n                return dp2[i][j];\\n            if(i + 2 < n && grid[i+2][j] != 1 && grid[i+1][j] != -2 && grid[i+1][j] != -3){ // move down\\n                grid[i+1][j] -= 2;\\n                int temp = dfs(grid, n, i+1, j, -2, dp1, dp2);\\n                if(temp != -1)\\n                    res = Math.min(res, temp + 1);\\n                grid[i+1][j] += 2;\\n            }\\n            if(j < n - 1 && grid[i][j+1] != 1 && grid[i+1][j+1] != 1){\\n                if(grid[i][j+1] != -2 && grid[i][j+1] != -3){  // move right\\n                    grid[i][j+1] -= 2;\\n                    int temp = dfs(grid, n, i, j+1, -2, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j+1] += 2;\\n                }\\n                if(grid[i][j] != -1 && grid[i][j] != -3){  // rotate\\n                    grid[i][j] -= 1;\\n                    int temp = dfs(grid, n, i, j, -1, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j] += 1;\\n                }\\n            }\\n        }\\n        res = res == Integer.MAX_VALUE ? -1 : res;\\n        if(direction == -1)\\n            dp1[i][j] = res;\\n        else\\n            dp2[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792222,
                "title": "java-bfs-solution-with-3-dimentional-visited-array",
                "content": "1. declare two constants `VERTICAL` and `HORIZONTAL` with values 0 and 1.\\n2. queue will take an int array, (x,y,direction)\\n3. according to the direction, we will have 6 types of actions:\\n\\t\\tfor HORIZONTAL:\\n\\t\\t\\t\\t- go HORIZONTAL next\\n\\t\\t\\t\\t- go VERTICAL next\\n\\t\\t\\t\\t- rotate clockwise\\n\\t\\tfor VERTICAL:\\n\\t\\t\\t\\t- go HORIZONTAL next\\n\\t\\t\\t\\t- go VERTICAL next\\n\\t\\t\\t\\t- rotate counterclockwise\\n4. the end condition is, direction == HORIZONTAL and we are in bottom-right cell.\\n```\\nclass Solution {\\n    private static final int VERTICAL = 0;\\n    private static final int HORIZONTAL = 1;\\n\\n    public int minimumMoves(int[][] grid) {\\n        final Queue<int[]> queue = new LinkedList<>();\\n        final boolean[][][] visited =\\n                new boolean[grid.length][grid[0].length][2];\\n        queue.offer(new int[]{0, 1, HORIZONTAL});\\n        visited[0][1][HORIZONTAL] = true;\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            final int currentSize = queue.size();\\n            for (int size = 0; size < currentSize; size++) {\\n                final int[] current = queue.poll();\\n                if (current[0] == grid.length - 1 &&\\n                        current[1] == grid[0].length - 1 &&\\n                        current[2] == HORIZONTAL\\n                ) {\\n                    return level;\\n                }\\n                if (current[2] == HORIZONTAL) {\\n                    // go horizon next\\n                    final int nextX = current[0];\\n                    final int nextY = current[1] + 1;\\n                    if (inBound(grid, nextX, nextY) &&\\n                            !visited[nextX][nextY][HORIZONTAL] &&\\n                            grid[nextX][nextY] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX, nextY, HORIZONTAL});\\n                        visited[nextX][nextY][HORIZONTAL] = true;\\n                    }\\n                    // go VERTICAL next\\n                    final int nextX2 = current[0] + 1;\\n                    final int nextY2 = current[1];\\n                    if (inBound(grid, nextX2, nextY2) &&\\n                            !visited[nextX2][nextY2][HORIZONTAL] &&\\n                            grid[nextX2][nextY2 - 1] == 0 &&\\n                            grid[nextX2][nextY2] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX2, nextY2, HORIZONTAL});\\n                        visited[nextX2][nextY2][HORIZONTAL] = true;\\n                    }\\n                    // rotate clockwise\\n                    final int nextX3 = current[0] + 1;\\n                    final int nextY3 = current[1] - 1;\\n                    if (inBound(grid, nextX3, nextY3) &&\\n                            !visited[nextX3][nextY3][VERTICAL] &&\\n                            grid[nextX3][nextY3 + 1] == 0 &&\\n                            grid[nextX3][nextY3] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX3, nextY3, VERTICAL});\\n                        visited[nextX3][nextY3][VERTICAL] = true;\\n                    }\\n                } else {\\n                    // go horizon next\\n                    final int nextX = current[0];\\n                    final int nextY = current[1] + 1;\\n                    if (inBound(grid, nextX, nextY) &&\\n                            !visited[nextX][nextY][VERTICAL] &&\\n                            grid[nextX - 1][nextY] == 0 &&\\n                            grid[nextX][nextY] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX, nextY, VERTICAL});\\n                        visited[nextX][nextY][VERTICAL] = true;\\n                    }\\n                    // go VERTICAL next\\n                    final int nextX2 = current[0] + 1;\\n                    final int nextY2 = current[1];\\n                    if (inBound(grid, nextX2, nextY2) &&\\n                            !visited[nextX2][nextY2][VERTICAL] &&\\n                            grid[nextX2][nextY2] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX2, nextY2, VERTICAL});\\n                        visited[nextX2][nextY2][VERTICAL] = true;\\n                    }\\n                    // rotate counterclockwise\\n                    final int nextX3 = current[0] - 1;\\n                    final int nextY3 = current[1] + 1;\\n                    if (inBound(grid, nextX3, nextY3) &&\\n                            !visited[nextX3][nextY3][HORIZONTAL] &&\\n                            grid[nextX3 + 1][nextY3] == 0 &&\\n                            grid[nextX3][nextY3] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX3, nextY3, HORIZONTAL});\\n                        visited[nextX3][nextY3][HORIZONTAL] = true;\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean inBound(\\n            int[][] grid,\\n            int x,\\n            int y\\n    ) {\\n        return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static final int VERTICAL = 0;\\n    private static final int HORIZONTAL = 1;\\n\\n    public int minimumMoves(int[][] grid) {\\n        final Queue<int[]> queue = new LinkedList<>();\\n        final boolean[][][] visited =\\n                new boolean[grid.length][grid[0].length][2];\\n        queue.offer(new int[]{0, 1, HORIZONTAL});\\n        visited[0][1][HORIZONTAL] = true;\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            final int currentSize = queue.size();\\n            for (int size = 0; size < currentSize; size++) {\\n                final int[] current = queue.poll();\\n                if (current[0] == grid.length - 1 &&\\n                        current[1] == grid[0].length - 1 &&\\n                        current[2] == HORIZONTAL\\n                ) {\\n                    return level;\\n                }\\n                if (current[2] == HORIZONTAL) {\\n                    // go horizon next\\n                    final int nextX = current[0];\\n                    final int nextY = current[1] + 1;\\n                    if (inBound(grid, nextX, nextY) &&\\n                            !visited[nextX][nextY][HORIZONTAL] &&\\n                            grid[nextX][nextY] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX, nextY, HORIZONTAL});\\n                        visited[nextX][nextY][HORIZONTAL] = true;\\n                    }\\n                    // go VERTICAL next\\n                    final int nextX2 = current[0] + 1;\\n                    final int nextY2 = current[1];\\n                    if (inBound(grid, nextX2, nextY2) &&\\n                            !visited[nextX2][nextY2][HORIZONTAL] &&\\n                            grid[nextX2][nextY2 - 1] == 0 &&\\n                            grid[nextX2][nextY2] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX2, nextY2, HORIZONTAL});\\n                        visited[nextX2][nextY2][HORIZONTAL] = true;\\n                    }\\n                    // rotate clockwise\\n                    final int nextX3 = current[0] + 1;\\n                    final int nextY3 = current[1] - 1;\\n                    if (inBound(grid, nextX3, nextY3) &&\\n                            !visited[nextX3][nextY3][VERTICAL] &&\\n                            grid[nextX3][nextY3 + 1] == 0 &&\\n                            grid[nextX3][nextY3] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX3, nextY3, VERTICAL});\\n                        visited[nextX3][nextY3][VERTICAL] = true;\\n                    }\\n                } else {\\n                    // go horizon next\\n                    final int nextX = current[0];\\n                    final int nextY = current[1] + 1;\\n                    if (inBound(grid, nextX, nextY) &&\\n                            !visited[nextX][nextY][VERTICAL] &&\\n                            grid[nextX - 1][nextY] == 0 &&\\n                            grid[nextX][nextY] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX, nextY, VERTICAL});\\n                        visited[nextX][nextY][VERTICAL] = true;\\n                    }\\n                    // go VERTICAL next\\n                    final int nextX2 = current[0] + 1;\\n                    final int nextY2 = current[1];\\n                    if (inBound(grid, nextX2, nextY2) &&\\n                            !visited[nextX2][nextY2][VERTICAL] &&\\n                            grid[nextX2][nextY2] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX2, nextY2, VERTICAL});\\n                        visited[nextX2][nextY2][VERTICAL] = true;\\n                    }\\n                    // rotate counterclockwise\\n                    final int nextX3 = current[0] - 1;\\n                    final int nextY3 = current[1] + 1;\\n                    if (inBound(grid, nextX3, nextY3) &&\\n                            !visited[nextX3][nextY3][HORIZONTAL] &&\\n                            grid[nextX3 + 1][nextY3] == 0 &&\\n                            grid[nextX3][nextY3] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX3, nextY3, HORIZONTAL});\\n                        visited[nextX3][nextY3][HORIZONTAL] = true;\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean inBound(\\n            int[][] grid,\\n            int x,\\n            int y\\n    ) {\\n        return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786635,
                "title": "python-a-star-search-efficient-search-path-in-line-comments",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n  def minimumMoves(self, grid: List[List[int]]) -> int:\\n    # bfs, dfs, a-star search\\n    # A-star search with heuristic: h(Hr, Hc, Hd, Tr, Tc) = (Tr - Hr) + (Tc - Hc) + Hd\\n    # where Hr, Hc is the snake head position and Hd is the snake head direction,\\n    #  Hd == 0 when snake is horizontal, e.g., snake takes (Hr, Hc - 1), (Hr, Hc)\\n    #  Hd == 1 when snake lays vertical, e.g., snake takes (Hr - 1, Hc), (Hr, Hc)\\n    # and Tx and Ty are target position\\n    n = len(grid)\\n    if not grid[n - 1][n - 2] == grid[n - 1][n - 1] == 0:\\n      return -1\\n    # q: (e = d + h, d: moves, h: heuristic as lower bound to target, Hr, Hc, Hd)\\n    q, seen = [(2 * n - 3, 0, 2 * n - 3, 0, 1, 0)], {}\\n    while q:\\n      e, d, h, hr, hc, hd = heapq.heappop(q)\\n      if (hr, hc, hd) == (n - 1, n - 1, 0):\\n        return d\\n      if (hr, hc, hd) not in seen:\\n        seen[(hr, hc, hd)] = d\\n        # move to next w.r.t position and direction\\n        if hd == 0:\\n          # snake is horizontal (hd == 0)\\n          if hc + 1 < n and grid[hr][hc + 1] == 0 and (hr, hc + 1, hd) not in seen:\\n            # move right\\n            heapq.heappush(q, (e, d + 1, h - 1, hr, hc + 1, hd))\\n          if hr + 1 < n and grid[hr + 1][hc - 1] == grid[hr + 1][hc] == 0:\\n            if (hr + 1, hc, hd) not in seen:\\n              # move down\\n              heapq.heappush(q, (e, d + 1, h - 1, hr + 1, hc, hd))\\n            if (hr + 1, hc - 1, hd ^ 1) not in seen:\\n              # rotate clockwise\\n              heapq.heappush(q, (e + 2, d + 1, h + 1, hr + 1, hc - 1, hd ^ 1))\\n        else:\\n          # snake lays vertical (hd == 1)\\n          if hr + 1 < n and grid[hr + 1][hc] == 0 and (hr + 1, hc, hd) not in seen:\\n            # move down\\n            heapq.heappush(q, (e, d + 1, h - 1, hr + 1, hc, hd))\\n          if hc + 1 < n and grid[hr - 1][hc + 1] == grid[hr][hc + 1] == 0:\\n            if (hr, hc + 1, hd) not in seen:\\n              # move right\\n              heapq.heappush(q, (e, d + 1, h - 1, hr, hc + 1, hd))\\n            if (hr - 1, hc + 1, hd ^ 1) not in seen:\\n              # rotate counterclockwise\\n              heapq.heappush(q, (e, d + 1, h - 1, hr - 1, hc + 1, hd ^ 1))\\n    return -1\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n  def minimumMoves(self, grid: List[List[int]]) -> int:\\n    # bfs, dfs, a-star search\\n    # A-star search with heuristic: h(Hr, Hc, Hd, Tr, Tc) = (Tr - Hr) + (Tc - Hc) + Hd\\n    # where Hr, Hc is the snake head position and Hd is the snake head direction,\\n    #  Hd == 0 when snake is horizontal, e.g., snake takes (Hr, Hc - 1), (Hr, Hc)\\n    #  Hd == 1 when snake lays vertical, e.g., snake takes (Hr - 1, Hc), (Hr, Hc)\\n    # and Tx and Ty are target position\\n    n = len(grid)\\n    if not grid[n - 1][n - 2] == grid[n - 1][n - 1] == 0:\\n      return -1\\n    # q: (e = d + h, d: moves, h: heuristic as lower bound to target, Hr, Hc, Hd)\\n    q, seen = [(2 * n - 3, 0, 2 * n - 3, 0, 1, 0)], {}\\n    while q:\\n      e, d, h, hr, hc, hd = heapq.heappop(q)\\n      if (hr, hc, hd) == (n - 1, n - 1, 0):\\n        return d\\n      if (hr, hc, hd) not in seen:\\n        seen[(hr, hc, hd)] = d\\n        # move to next w.r.t position and direction\\n        if hd == 0:\\n          # snake is horizontal (hd == 0)\\n          if hc + 1 < n and grid[hr][hc + 1] == 0 and (hr, hc + 1, hd) not in seen:\\n            # move right\\n            heapq.heappush(q, (e, d + 1, h - 1, hr, hc + 1, hd))\\n          if hr + 1 < n and grid[hr + 1][hc - 1] == grid[hr + 1][hc] == 0:\\n            if (hr + 1, hc, hd) not in seen:\\n              # move down\\n              heapq.heappush(q, (e, d + 1, h - 1, hr + 1, hc, hd))\\n            if (hr + 1, hc - 1, hd ^ 1) not in seen:\\n              # rotate clockwise\\n              heapq.heappush(q, (e + 2, d + 1, h + 1, hr + 1, hc - 1, hd ^ 1))\\n        else:\\n          # snake lays vertical (hd == 1)\\n          if hr + 1 < n and grid[hr + 1][hc] == 0 and (hr + 1, hc, hd) not in seen:\\n            # move down\\n            heapq.heappush(q, (e, d + 1, h - 1, hr + 1, hc, hd))\\n          if hc + 1 < n and grid[hr - 1][hc + 1] == grid[hr][hc + 1] == 0:\\n            if (hr, hc + 1, hd) not in seen:\\n              # move right\\n              heapq.heappush(q, (e, d + 1, h - 1, hr, hc + 1, hd))\\n            if (hr - 1, hc + 1, hd ^ 1) not in seen:\\n              # rotate counterclockwise\\n              heapq.heappush(q, (e, d + 1, h - 1, hr - 1, hc + 1, hd ^ 1))\\n    return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780227,
                "title": "ruby-bfs-beat-100",
                "content": "```\\nHORIZONTAL = 0\\nVERTICAL = 1\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef minimum_moves(grid)\\n  n, m = grid.size, grid[0].size\\n\\n  horizontal, vertical = [], []\\n  horizontal[0] = []\\n  horizontal[0][1] = 0\\n\\n  queue = Queue.new\\n  queue << [0, 1, HORIZONTAL]\\n  while !queue.empty?\\n    i, j, direction = queue.pop\\n    horizontal[i] ||= []\\n    horizontal[i+1] ||= []\\n    vertical[i] ||= []\\n    vertical[i+1] ||= []\\n\\n    if direction == HORIZONTAL \\n      if grid[i][j+1] == 0 && horizontal[i][j+1].nil?\\n        horizontal[i][j+1] = horizontal[i][j] + 1\\n        queue << [i, j+1, HORIZONTAL]\\n      end\\n\\n      if grid[i+1] && grid[i+1][j-1] == 0 && grid[i+1][j] == 0 && horizontal[i+1][j].nil?\\n        horizontal[i+1][j] = horizontal[i][j] + 1\\n        queue << [i+1, j, HORIZONTAL]\\n      end\\n\\n      if grid[i+1] && grid[i+1][j] == 0 && grid[i+1][j-1] == 0 && vertical[i+1][j-1].nil?\\n        vertical[i+1][j-1] = horizontal[i][j] + 1\\n        queue << [i+1, j-1, VERTICAL]\\n      end\\n    end\\n\\n    if direction == VERTICAL \\n      if grid[i+1] && grid[i+1][j] == 0 && vertical[i+1][j].nil?\\n        vertical[i+1][j] = vertical[i][j] + 1\\n        queue << [i+1, j, VERTICAL]\\n      end\\n\\n      if i > 0 && grid[i-1][j+1] == 0 && grid[i][j+1] == 0 && vertical[i][j+1].nil?\\n        vertical[i][j+1] = vertical[i][j] + 1\\n        queue << [i, j+1, VERTICAL]\\n      end\\n\\n      if grid[i-1] && grid[i][j+1] == 0 && grid[i-1][j+1] == 0 && horizontal[i-1][j+1].nil?\\n        horizontal[i-1][j+1] = vertical[i][j] + 1\\n        queue << [i-1, j+1, HORIZONTAL]\\n      end\\n    end\\n\\n  end\\n\\n  horizontal.dig(n-1, m-1) || -1\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nHORIZONTAL = 0\\nVERTICAL = 1\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef minimum_moves(grid)\\n  n, m = grid.size, grid[0].size\\n\\n  horizontal, vertical = [], []\\n  horizontal[0] = []\\n  horizontal[0][1] = 0\\n\\n  queue = Queue.new\\n  queue << [0, 1, HORIZONTAL]\\n  while !queue.empty?\\n    i, j, direction = queue.pop\\n    horizontal[i] ||= []\\n    horizontal[i+1] ||= []\\n    vertical[i] ||= []\\n    vertical[i+1] ||= []\\n\\n    if direction == HORIZONTAL \\n      if grid[i][j+1] == 0 && horizontal[i][j+1].nil?\\n        horizontal[i][j+1] = horizontal[i][j] + 1\\n        queue << [i, j+1, HORIZONTAL]\\n      end\\n\\n      if grid[i+1] && grid[i+1][j-1] == 0 && grid[i+1][j] == 0 && horizontal[i+1][j].nil?\\n        horizontal[i+1][j] = horizontal[i][j] + 1\\n        queue << [i+1, j, HORIZONTAL]\\n      end\\n\\n      if grid[i+1] && grid[i+1][j] == 0 && grid[i+1][j-1] == 0 && vertical[i+1][j-1].nil?\\n        vertical[i+1][j-1] = horizontal[i][j] + 1\\n        queue << [i+1, j-1, VERTICAL]\\n      end\\n    end\\n\\n    if direction == VERTICAL \\n      if grid[i+1] && grid[i+1][j] == 0 && vertical[i+1][j].nil?\\n        vertical[i+1][j] = vertical[i][j] + 1\\n        queue << [i+1, j, VERTICAL]\\n      end\\n\\n      if i > 0 && grid[i-1][j+1] == 0 && grid[i][j+1] == 0 && vertical[i][j+1].nil?\\n        vertical[i][j+1] = vertical[i][j] + 1\\n        queue << [i, j+1, VERTICAL]\\n      end\\n\\n      if grid[i-1] && grid[i][j+1] == 0 && grid[i-1][j+1] == 0 && horizontal[i-1][j+1].nil?\\n        horizontal[i-1][j+1] = vertical[i][j] + 1\\n        queue << [i-1, j+1, HORIZONTAL]\\n      end\\n    end\\n\\n  end\\n\\n  horizontal.dig(n-1, m-1) || -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 773127,
                "title": "python-faster-than-80-30-lines",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, x: List[List[int]]) -> int:\\n        q,v,n=[(0,0,0,0)],{(0,0,0)},len(x)\\n        while len(q)>0:\\n            i,j,di,mi=q.pop(0)\\n            if (i,j,di)==(n-1,n-2,0):return mi\\n            if di==0:\\n                if j+2<n and (i,j+1,0) not in v and x[i][j+2]!=1:\\n                    q.append((i,j+1,0,mi+1))\\n                    v.add((i,j+1,0))\\n                if i+1<n and (i+1,j,0) not in v and x[i+1][j]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i+1,j,0,mi+1))\\n                    v.add((i+1,j,0))\\n            else:\\n                if i+2<n and (i+1,j,1) not in v and x[i+2][j]!=1:\\n                    q.append((i+1,j,1,mi+1))\\n                    v.add((i+1,j,1))\\n                if j+1<n and (i,j+1,1) not in v and x[i][j+1]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j+1,1,mi+1))\\n                    v.add((i,j+1,1))\\n            if di==0:\\n                if i+1<n and (i,j,1) not in v  and x[i+1][j]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j,1,mi+1))\\n                    v.add((i,j,1))\\n            else:\\n                if j+1<n and (i,j,0) not in v  and x[i][j+1]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j,0,mi+1))\\n                    v.add((i,j,0))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, x: List[List[int]]) -> int:\\n        q,v,n=[(0,0,0,0)],{(0,0,0)},len(x)\\n        while len(q)>0:\\n            i,j,di,mi=q.pop(0)\\n            if (i,j,di)==(n-1,n-2,0):return mi\\n            if di==0:\\n                if j+2<n and (i,j+1,0) not in v and x[i][j+2]!=1:\\n                    q.append((i,j+1,0,mi+1))\\n                    v.add((i,j+1,0))\\n                if i+1<n and (i+1,j,0) not in v and x[i+1][j]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i+1,j,0,mi+1))\\n                    v.add((i+1,j,0))\\n            else:\\n                if i+2<n and (i+1,j,1) not in v and x[i+2][j]!=1:\\n                    q.append((i+1,j,1,mi+1))\\n                    v.add((i+1,j,1))\\n                if j+1<n and (i,j+1,1) not in v and x[i][j+1]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j+1,1,mi+1))\\n                    v.add((i,j+1,1))\\n            if di==0:\\n                if i+1<n and (i,j,1) not in v  and x[i+1][j]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j,1,mi+1))\\n                    v.add((i,j,1))\\n            else:\\n                if j+1<n and (i,j,0) not in v  and x[i][j+1]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j,0,mi+1))\\n                    v.add((i,j,0))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752381,
                "title": "c-simple-top-down-dp",
                "content": "State:\\n( i , j , dir )  where (i,j) is current coordinate of tail and dir represents direction of head\\ndir==1 mens face is towards right\\ndir==2 means face is  downward\\n\\nTarget State-> (n-1,n-2,1)\\ndp[0][0][1] = 0   initial state\\n\\nIdea:\\nAt any state ( i, j, dir)  either we came from left or from top or we got into this via some rotation\\n\\nRotation ?\\nIf dir==1 we might have rotated anticlockwise from downward facing direction, no other rotation possible\\n\\nIf dir==2 we might have rotated clockwise from rightward facing direction, no other rotation possible\\n```\\nint dp[101][101][3],n;\\n\\n\\nint solve(vector<vector<int>> &mat,int i,int j,int dir)\\n{\\n    // invalid snake configuration or position return infinity - 1e6 here\\n    if(i<0 || i>=n || j<0 || j>=n || mat[i][j]==1) return 1e6;\\n\\t\\n    if(dir==1)\\n    {\\n\\t\\t// tail at (i,j) and head on (i,j+1)\\n\\t\\t\\n        // check if head can be possible at (i,j+1)\\n\\t\\t// if not return infinity\\n        if(j+1>=n)\\n        return 1e6;\\n        if(mat[i][j+1]==1) return 1e6;\\n    }\\n    if(dir==2) \\n    {\\n\\t\\t//tail at (i,j) and head on (i+1,j)\\n\\t\\n        // check if head can be possible at (i+1,j)\\n\\t\\t// if not return infinity\\n        if(i+1>=n)\\n        return 1e6;\\n        if(mat[i+1][j]==1) return 1e6;\\n    }\\n    \\n    if(dp[i][j][dir]!=-1) return dp[i][j][dir];\\n    \\n    // see from where can we reach current state\\n    if(dir==1)\\n    {\\n        //from left\\n        dp[i][j][dir]=1+solve(mat,i,j-1,1);\\n        //from up\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i-1,j,1));\\n        \\n        //anticlockwised from (i,j,downward_face) to current=(i,j,rightward_face) \\n        //iff mat[i+1][j+1]==0 as given in question\\n        if(i+1<n && j+1<n && mat[i+1][j+1]==0)\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i,j,2));\\n    }\\n    else\\n    {\\n        //from left\\n        dp[i][j][dir]=1+solve(mat,i,j-1,2);\\n        //from up\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i-1,j,2));\\n        \\n        //clockwised from (i,j,rightward_face) to current=(i,j,downward_face) \\n        //iff mat[i+1][j+1]==0 as given in question\\n        if(i+1<n && j+1<n && mat[i+1][j+1]==0)\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i,j,1));\\n    }\\n    \\n    return dp[i][j][dir];\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        n=grid.size();\\n        memset(dp,-1,sizeof dp);\\n        // initially at (0,0,right_faced);\\n        dp[0][0][1]=0;\\n        int ans= solve(grid,n-1,n-2,1);\\n        //if cannt reach (n-1,n-2,1) from (0,0,1) return -1;\\n        if(ans>n*n) return -1;\\n        //otherwise return ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint dp[101][101][3],n;\\n\\n\\nint solve(vector<vector<int>> &mat,int i,int j,int dir)\\n{\\n    // invalid snake configuration or position return infinity - 1e6 here\\n    if(i<0 || i>=n || j<0 || j>=n || mat[i][j]==1) return 1e6;\\n\\t\\n    if(dir==1)\\n    {\\n\\t\\t// tail at (i,j) and head on (i,j+1)\\n\\t\\t\\n        // check if head can be possible at (i,j+1)\\n\\t\\t// if not return infinity\\n        if(j+1>=n)\\n        return 1e6;\\n        if(mat[i][j+1]==1) return 1e6;\\n    }\\n    if(dir==2) \\n    {\\n\\t\\t//tail at (i,j) and head on (i+1,j)\\n\\t\\n        // check if head can be possible at (i+1,j)\\n\\t\\t// if not return infinity\\n        if(i+1>=n)\\n        return 1e6;\\n        if(mat[i+1][j]==1) return 1e6;\\n    }\\n    \\n    if(dp[i][j][dir]!=-1) return dp[i][j][dir];\\n    \\n    // see from where can we reach current state\\n    if(dir==1)\\n    {\\n        //from left\\n        dp[i][j][dir]=1+solve(mat,i,j-1,1);\\n        //from up\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i-1,j,1));\\n        \\n        //anticlockwised from (i,j,downward_face) to current=(i,j,rightward_face) \\n        //iff mat[i+1][j+1]==0 as given in question\\n        if(i+1<n && j+1<n && mat[i+1][j+1]==0)\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i,j,2));\\n    }\\n    else\\n    {\\n        //from left\\n        dp[i][j][dir]=1+solve(mat,i,j-1,2);\\n        //from up\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i-1,j,2));\\n        \\n        //clockwised from (i,j,rightward_face) to current=(i,j,downward_face) \\n        //iff mat[i+1][j+1]==0 as given in question\\n        if(i+1<n && j+1<n && mat[i+1][j+1]==0)\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i,j,1));\\n    }\\n    \\n    return dp[i][j][dir];\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        n=grid.size();\\n        memset(dp,-1,sizeof dp);\\n        // initially at (0,0,right_faced);\\n        dp[0][0][1]=0;\\n        int ans= solve(grid,n-1,n-2,1);\\n        //if cannt reach (n-1,n-2,1) from (0,0,1) return -1;\\n        if(ans>n*n) return -1;\\n        //otherwise return ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729166,
                "title": "bfs-c-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    \\nunordered_set<string> visited;\\n\\n    queue<vector<int>>q;\\n    \\n    int tailI[4]={0,1,0,0};\\n    int tailJ[4]={1,0,0,0};\\n    int headI[4]={0,1,1,-1};\\n    int headJ[4]={1,0,-1,1};\\n    \\n    bool valid(int i,int j,int n){\\n        if(i>=0&&i<n&&j>=0&&j<n)return 1;\\n        else return 0;\\n        \\n    }\\n    \\n    \\n    int BFS(int n,vector<vector<int>>& grid){\\n        int steps=0;\\n        while(q.size()){\\n        int sz=q.size();\\n             \\n            \\n            \\n      for (int w=0;w<sz;w++) {     \\n          int i1=q.front()[0];\\n            int j1=q.front()[1];\\n            int i2=q.front()[2];\\n            int j2=q.front()[3];\\n            q.pop();\\n            if(i1==n-1&&j1==n-2&&i2==n-1&&j2==n-1)return steps;\\n            \\n            for (int k=0;k<4;k++){\\n                vector<int> v;\\n        \\n                int newi1=i1+tailI[k];\\n                int newj1=j1+tailJ[k];\\n                int newi2=i2+headI[k];\\n                int newj2=j2+headJ[k];\\n                           \\n                \\n                string temp=\"\";\\n                temp+=to_string(newi1);\\n                temp+=to_string(newj1);\\n                temp+=to_string(newi2);\\n                temp+=to_string(newj2);\\n                \\n                if(k==2||k==3){\\n                    \\n                    if(k==2&&(i2>i1))continue;\\n                    if(k==3&&(j2>j1))continue;\\n                    \\n                    // case of rotation\\n         if(valid(newi2,newj2,n)&&valid(newi1+1,newj1+1,n)&&valid(newi1,newj1,n)){\\n                    // this means it\\'s safe for the snake to move\\n          if(grid[newi2][newj2]==0&&grid[newi1+1][newj1+1]==0&&grid[newi1][newj1]==0){                                   if(visited.find(temp)==visited.end()){\\n         // if the ditsnace is less\\n     \\n             visited.insert(temp);\\n             \\n              q.push({newi1,newj1,newi2,newj2});\\n         \\n     }\\n         }           \\n                }\\n                }\\n                else{        \\n                if(valid(newi2,newj2,n)&&valid(newi1,newj1,n)){\\n                    // this means it\\'s safe for the snake to move\\n   if(grid[newi2][newj2]==0&&grid[newi1][newj1]==0){  if(visited.find(temp)==visited.end()){\\n         // if the ditsnace is less\\n     \\n        visited.insert(temp);\\n         \\n              q.push({newi1,newj1,newi2,newj2});\\n\\n         \\n     }}\\n                    \\n                }\\n                }    \\n                \\n                \\n            }\\n            \\n            \\n            \\n            \\n            \\n        }\\n        \\n        steps++;\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n    \\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<int> v;\\n        v.push_back(0);\\n        v.push_back(0);\\n        v.push_back(0);\\n        v.push_back(1);\\n      q.push(v);  \\n     // dist[{{0,0},{0,1}}]=0;  \\n       // vis[{{0,0},{0,1}}]=1;\\n        string temp=\"\";\\n        temp+=to_string(0001);\\n        visited.insert(temp);\\n        return BFS(n,grid);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    \\n    \\nunordered_set<string> visited;\\n\\n    queue<vector<int>>q;\\n    \\n    int tailI[4]={0,1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 729164,
                "title": "bfs-c-solution",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    map<pair<pair<int,int>,pair<int,int>>,int> dist;\\n        map<pair<pair<int,int>,pair<int,int>>,int> vis;\\n        queue<pair<pair<int,int>,pair<int,int>>>q;\\n\\n//unordered_set<string> visited;\\n\\n    //queue<vector<int>>q;\\n    \\n    int tailI[4]={0,1,0,0};\\n    int tailJ[4]={1,0,0,0};\\n    int headI[4]={0,1,1,-1};\\n    int headJ[4]={1,0,-1,1};\\n    \\n    bool valid(int i,int j,int n){\\n        if(i>=0&&i<n&&j>=0&&j<n)return 1;\\n        else return 0;\\n        \\n    }\\n    \\n    \\n    int BFS(int n,vector<vector<int>>& grid){\\n        int steps=0;\\n        while(q.size()){\\n       \\n             \\n            \\n            \\n           \\n          int i1=q.front().first.first;\\n            int j1=q.front().first.second;\\n            int i2=q.front().second.first;\\n            int j2=q.front().second.second;\\n            q.pop();\\n             cout<<i1<<\" \"<<j1<<\"   \"<<i2<<\" \"<<j2<<\"   \"<<steps<<endl;\\n            if(i1==n-1&&j1==n-2&&i2==n-1&&j2==n-1)return dist[{{i1,j1},{i2,j2}}];\\n            \\n            for (int k=0;k<4;k++){\\n                vector<int> v;\\n        \\n                int newi1=i1+tailI[k];\\n                int newj1=j1+tailJ[k];\\n                int newi2=i2+headI[k];\\n                int newj2=j2+headJ[k];\\n                           \\n                \\n                \\n                \\n                if(k==2||k==3){\\n                    \\n                    if(k==2&&(i2>i1))continue;\\n                    if(k==3&&(j2>j1))continue;\\n                    \\n                    // case of rotation\\n         if(valid(newi2,newj2,n)&&valid(newi1+1,newj1+1,n)&&valid(newi1,newj1,n)){\\n                    // this means it\\'s safe for the snake to move\\n          if(grid[newi2][newj2]==0&&grid[newi1+1][newj1+1]==0&&grid[newi1][newj1]==0){                                   if(vis[{{newi1,newj1},{newi2,newj2}}]==0){\\n         // if the ditsnace is less\\n     \\n            vis[{{newi1,newj1},{newi2,newj2}}]=1;\\n             dist[{{newi1,newj1},{newi2,newj2}}]=dist[{{i1,j1},{i2,j2}}]+1;\\n              q.push({{newi1,newj1},{newi2,newj2}});\\n         \\n     }\\n         }           \\n                }\\n                }\\n                else{        \\n                if(valid(newi2,newj2,n)&&valid(newi1,newj1,n)){\\n                    // this means it\\'s safe for the snake to move\\n   if(grid[newi2][newj2]==0&&grid[newi1][newj1]==0){  \\n                            if(vis[{{newi1,newj1},{newi2,newj2}}]==0){\\n         // if the ditsnace is less\\n     \\n            vis[{{newi1,newj1},{newi2,newj2}}]=1;\\n             dist[{{newi1,newj1},{newi2,newj2}}]=dist[{{i1,j1},{i2,j2}}]+1;\\n              q.push({{newi1,newj1},{newi2,newj2}});\\n         \\n     }\\n                                                   }\\n                    \\n                }\\n                }    \\n                \\n                \\n            }\\n            \\n            \\n            \\n            \\n            \\n        \\n        \\n       // steps++;\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n    \\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        q.push({{0,0},{0,1}});\\n      dist[{{0,0},{0,1}}]=0;  \\n        vis[{{0,0},{0,1}}]=1;\\n       \\n        return BFS(n,grid);\\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    \\n    map<pair<pair<int,int>,pair<int,int>>,int> dist;\\n        map<pair<pair<int,int>,pair<int,int>>,int> vis;\\n        queue<pair<pair<int,int>,pair<int,int>>>q;\\n\\n//unordered_set<string> visited;\\n\\n    //queue<vector<int>>q;\\n    \\n    int tailI[4]={0,1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 718237,
                "title": "python-bfs",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        def add_pos(pos, seen, queue, level):\\n            if pos not in seen:\\n                seen.add(pos)\\n                queue.append([pos, level])\\n        queue = deque()\\n        pos = ((0,0),(0,1))\\n        queue.append([pos,0])\\n        seen = set([pos])\\n        n = len(grid)\\n        target = ((n-1,n-2), (n-1, n-1))\\n        while queue:\\n            position, level = queue.popleft()\\n            if position == target:\\n                return level\\n            r1,c1 = position[0]\\n            r2,c2 = position[1]\\n            seen.add(position)\\n            next_level = level+1\\n            is_horizontal = r1==r2\\n            if is_horizontal:\\n                if c2 < n-1 and grid[r2][c2+1] == 0:\\n                    add_pos(((r1,c1+1),(r2,c2+1)),seen, queue, next_level) # right\\n                if r1 < n-1 and grid[r1+1][c1] == 0 and grid[r2+1][c2]==0:\\n                    add_pos(((r1+1,c1),(r2+1,c2)),seen, queue, next_level) # down\\n                    add_pos(((r1,c1),(r2+1,c2-1)),seen, queue, next_level) # clockwise\\n            else:\\n                if c1 < n-1 and grid[r2][c2+1] == 0 and grid[r1][c1+1] == 0:\\n                    add_pos(((r1,c1+1),(r2,c2+1)),seen, queue, next_level) # right\\n                    add_pos(((r1,c1),(r2-1,c2+1)),seen, queue, next_level) # counterclockwise\\n                if r2 < n-1 and grid[r2+1][c2] == 0:\\n                    add_pos(((r1+1,c1),(r2+1,c2)),seen, queue, next_level) # down\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        def add_pos(pos, seen, queue, level):\\n            if pos not in seen:\\n                seen.add(pos)\\n                queue.append([pos, level])\\n        queue = deque()\\n        pos = ((0,0),(0,1))\\n        queue.append([pos,0])\\n        seen = set([pos])\\n        n = len(grid)\\n        target = ((n-1,n-2), (n-1, n-1))\\n        while queue:\\n            position, level = queue.popleft()\\n            if position == target:\\n                return level\\n            r1,c1 = position[0]\\n            r2,c2 = position[1]\\n            seen.add(position)\\n            next_level = level+1\\n            is_horizontal = r1==r2\\n            if is_horizontal:\\n                if c2 < n-1 and grid[r2][c2+1] == 0:\\n                    add_pos(((r1,c1+1),(r2,c2+1)),seen, queue, next_level) # right\\n                if r1 < n-1 and grid[r1+1][c1] == 0 and grid[r2+1][c2]==0:\\n                    add_pos(((r1+1,c1),(r2+1,c2)),seen, queue, next_level) # down\\n                    add_pos(((r1,c1),(r2+1,c2-1)),seen, queue, next_level) # clockwise\\n            else:\\n                if c1 < n-1 and grid[r2][c2+1] == 0 and grid[r1][c1+1] == 0:\\n                    add_pos(((r1,c1+1),(r2,c2+1)),seen, queue, next_level) # right\\n                    add_pos(((r1,c1),(r2-1,c2+1)),seen, queue, next_level) # counterclockwise\\n                if r2 < n-1 and grid[r2+1][c2] == 0:\\n                    add_pos(((r1+1,c1),(r2+1,c2)),seen, queue, next_level) # down\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701235,
                "title": "python-dp-solution-with-explanation",
                "content": "Each time the snake is horizontal, there are 3 possibilities: moving right, moving down, rotating clockwise. If the snake is vertical, the 3 possibilities become moving right, moving down, rotating counter-clockwise. This is reminiscent of problems 63, 64, 120, 174, and 931, which suggests that we may be able to use dynamic programming to solve the problem. However, care should be taken to ensure that the snake isn\\u2019t stuck at the same place forever keeping rotating clockwise and counter-clockwise (stack overflow for recursion). So, in addition to the coordinates and orientations, we also need to keep track of whether the snake has already rotated. If it was previously rotated to the current position, we don\\u2019t want the snake to rotate again as this would cause the snake to get stuck, which will never give us the minimum moves. Here, the last parameter in dp(r, c, hor = True, rotated = False) keeps track of that. The remaining part is easy, and the only tricky thing is checking if there\\u2019s any obstacle blocking a move.\\n\\n\\n\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        if grid[n-1][n-2] == 1 or grid[n-1][n-1] == 1: \\n            return -1\\n        \\n        cache = {(n-1, n-2, True, False): 0, (n-1, n-2, True, True): 0}\\n        \\n        def dp(r, c, hor = True, rotated = False):\\n            # Tail is at (r, c)\\n            # If hor is True: head is at (r, c+1)\\n            # if hor is False: head is at (r+1, c)\\n            tup = (r, c, hor, rotated)\\n            if tup in cache:\\n                return cache[tup]\\n            \\n            v1, v2, v3 = float(\"Inf\"), float(\"Inf\"), float(\"Inf\")\\n            if hor:\\n                # Horizontal\\n                if c + 2 < n and grid[r][c+2] == 0:\\n                    # Move right\\n                    v1 = dp(r, c+1, True, False)\\n                if r + 1 < n and c + 1 < n and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:\\n                    # Move down\\n                    v2 = dp(r+1, c, True, False)\\n                    # Rotate if it hasn\\'t rotated yet\\n                    if not rotated:\\n                        v3 = dp(r, c, False, True)\\n            else:\\n                # Vertical\\n                if r+2 < n and grid[r+2][c] == 0:\\n                    # Move down\\n                    v1 = dp(r+1, c, False, False)\\n                if c + 1 < n and r + 1 < n and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:\\n                    # Move right\\n                    v2 = dp(r, c+1, False, False)\\n                    # Rotate if it hasn\\'t rotated yet\\n                    if not rotated:\\n                        v3 = dp(r, c, True, True)\\n            cache[tup] = min(v1, v2, v3) + 1\\n            return cache[tup]\\n\\n        ret = dp(0, 0, True, False)\\n        return ret if ret != float(\"Inf\") else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        if grid[n-1][n-2] == 1 or grid[n-1][n-1] == 1: \\n            return -1\\n        \\n        cache = {(n-1, n-2, True, False): 0, (n-1, n-2, True, True): 0}\\n        \\n        def dp(r, c, hor = True, rotated = False):\\n            # Tail is at (r, c)\\n            # If hor is True: head is at (r, c+1)\\n            # if hor is False: head is at (r+1, c)\\n            tup = (r, c, hor, rotated)\\n            if tup in cache:\\n                return cache[tup]\\n            \\n            v1, v2, v3 = float(\"Inf\"), float(\"Inf\"), float(\"Inf\")\\n            if hor:\\n                # Horizontal\\n                if c + 2 < n and grid[r][c+2] == 0:\\n                    # Move right\\n                    v1 = dp(r, c+1, True, False)\\n                if r + 1 < n and c + 1 < n and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:\\n                    # Move down\\n                    v2 = dp(r+1, c, True, False)\\n                    # Rotate if it hasn\\'t rotated yet\\n                    if not rotated:\\n                        v3 = dp(r, c, False, True)\\n            else:\\n                # Vertical\\n                if r+2 < n and grid[r+2][c] == 0:\\n                    # Move down\\n                    v1 = dp(r+1, c, False, False)\\n                if c + 1 < n and r + 1 < n and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:\\n                    # Move right\\n                    v2 = dp(r, c+1, False, False)\\n                    # Rotate if it hasn\\'t rotated yet\\n                    if not rotated:\\n                        v3 = dp(r, c, True, True)\\n            cache[tup] = min(v1, v2, v3) + 1\\n            return cache[tup]\\n\\n        ret = dp(0, 0, True, False)\\n        return ret if ret != float(\"Inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691094,
                "title": "java-bfs-snake-class",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Queue<Snake> q = new LinkedList();\\n        q.offer(new Snake(0,1,0,0));\\n        HashSet<String> set = new HashSet();\\n        set.add(convert(0,1,0,0));\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size > 0) {\\n                size--;\\n                Snake curr = q.poll();\\n                if (win(curr, grid)) return res;\\n                for (Snake next: getNext(curr, grid)) {\\n                    String val = convert(next.hx, next.hy, next.tx, next.ty);\\n                    if (set.contains(val)) continue;\\n                    set.add(val);\\n                    q.offer(next);\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    public List<Snake> getNext(Snake curr, int[][] grid) {\\n        List<Snake> res = new ArrayList();\\n        // right\\n        if (valid(curr.hx,curr.hy+1, grid) && valid(curr.tx,curr.ty+1, grid)) {\\n            res.add(new Snake(curr.hx,curr.hy+1,curr.tx,curr.ty+1));\\n        }\\n        // down\\n        if (valid(curr.hx+1,curr.hy, grid) && valid(curr.tx+1,curr.ty, grid)) {\\n            res.add(new Snake(curr.hx+1,curr.hy,curr.tx+1,curr.ty));\\n        }\\n        boolean isHorizontal = curr.hx == curr.tx;\\n        if (isHorizontal) {\\n            // clockwise\\n            if (valid(curr.hx+1,curr.hy, grid) && valid(curr.tx+1,curr.ty, grid)) {\\n                res.add(new Snake(curr.hx+1,curr.hy-1,curr.tx,curr.ty));\\n            }\\n        }\\n        else {\\n            if (valid(curr.hx,curr.hy+1, grid) && valid(curr.tx,curr.ty+1, grid)) {\\n                res.add(new Snake(curr.hx-1,curr.hy+1,curr.tx,curr.ty));\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    \\n    public boolean valid(int x, int y, int[][] grid) {\\n        int n = grid.length;\\n        if (x < 0 || y < 0 || x >= n || y >= n || grid[x][y] == 1) return false;\\n        return true;\\n    }\\n    \\n    public boolean win(Snake s, int[][] grid) {\\n        int n = grid.length;\\n        if (s.hx == n-1 && s.hy == n-1 && s.tx == n-1 && s.ty == n-2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public String convert(int x, int y, int z, int o) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(x);\\n        sb.append(y);\\n        sb.append(z);\\n        sb.append(o);\\n        return sb.toString();\\n    }\\n}\\n\\npublic class Snake {\\n    public int hx;\\n    public int hy;\\n    public int tx;\\n    public int ty;\\n    \\n    public Snake(int x1, int y1, int x2, int y2) {\\n        this.hx = x1;\\n        this.hy = y1;\\n        this.tx = x2;\\n        this.ty = y2;\\n    }\\n    \\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Queue<Snake> q = new LinkedList();\\n        q.offer(new Snake(0,1,0,0));\\n        HashSet<String> set = new HashSet();\\n        set.add(convert(0,1,0,0));\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size > 0) {\\n                size--;\\n                Snake curr = q.poll();\\n                if (win(curr, grid)) return res;\\n                for (Snake next: getNext(curr, grid)) {\\n                    String val = convert(next.hx, next.hy, next.tx, next.ty);\\n                    if (set.contains(val)) continue;\\n                    set.add(val);\\n                    q.offer(next);\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    public List<Snake> getNext(Snake curr, int[][] grid) {\\n        List<Snake> res = new ArrayList();\\n        // right\\n        if (valid(curr.hx,curr.hy+1, grid) && valid(curr.tx,curr.ty+1, grid)) {\\n            res.add(new Snake(curr.hx,curr.hy+1,curr.tx,curr.ty+1));\\n        }\\n        // down\\n        if (valid(curr.hx+1,curr.hy, grid) && valid(curr.tx+1,curr.ty, grid)) {\\n            res.add(new Snake(curr.hx+1,curr.hy,curr.tx+1,curr.ty));\\n        }\\n        boolean isHorizontal = curr.hx == curr.tx;\\n        if (isHorizontal) {\\n            // clockwise\\n            if (valid(curr.hx+1,curr.hy, grid) && valid(curr.tx+1,curr.ty, grid)) {\\n                res.add(new Snake(curr.hx+1,curr.hy-1,curr.tx,curr.ty));\\n            }\\n        }\\n        else {\\n            if (valid(curr.hx,curr.hy+1, grid) && valid(curr.tx,curr.ty+1, grid)) {\\n                res.add(new Snake(curr.hx-1,curr.hy+1,curr.tx,curr.ty));\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    \\n    public boolean valid(int x, int y, int[][] grid) {\\n        int n = grid.length;\\n        if (x < 0 || y < 0 || x >= n || y >= n || grid[x][y] == 1) return false;\\n        return true;\\n    }\\n    \\n    public boolean win(Snake s, int[][] grid) {\\n        int n = grid.length;\\n        if (s.hx == n-1 && s.hy == n-1 && s.tx == n-1 && s.ty == n-2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public String convert(int x, int y, int z, int o) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(x);\\n        sb.append(y);\\n        sb.append(z);\\n        sb.append(o);\\n        return sb.toString();\\n    }\\n}\\n\\npublic class Snake {\\n    public int hx;\\n    public int hy;\\n    public int tx;\\n    public int ty;\\n    \\n    public Snake(int x1, int y1, int x2, int y2) {\\n        this.hx = x1;\\n        this.hy = y1;\\n        this.tx = x2;\\n        this.ty = y2;\\n    }\\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588286,
                "title": "java-short-code-with-explanation-line-by-line-in-comments",
                "content": "```\\nclass Solution {\\n    public boolean isValid(int i, int j, int[][] grid){\\n        if(i < 0 || j < 0 || i > grid.length-1 || j > grid.length-1 || grid[i][j] == 1) return false; \\n        return true;\\n    }\\n   \\n    public boolean isHoriz(int tx, int ty, int hx, int hy){\\n        if ((tx == hx) && (hy == ty + 1)) return true;\\n        return false;\\n    }\\n    \\n    public boolean isVert(int tx, int ty, int hx, int hy){\\n        if ((hx == tx + 1) && (hy == ty)) return true;\\n        return false;\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        Queue <int []> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        // pos 0 - horizontal move, pos 1 - vertical move, pos 2 - clockwise, pos 3 - counter clockwise\\n        int dir[][] = new int[][] {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\n        int n = grid.length, level = 0;\\n\\n        q.offer(new int[]{0,0,0,1});\\n        visited.add(0 + \",\" + 0 + \",\"+ 0 + \",\" + 1);\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int s = 0; s < size; s++){\\n                int [] curr = q.poll();\\n                int tx = curr[0]; //tail x- co-ordinate\\n                int ty = curr[1]; //tail y- co-ordinate\\n                int hx = curr[2]; //head x- co-ordinate\\n                int hy = curr[3]; //head y- co-ordinate\\n                if(tx == n-1 && ty == n-2 && hx == n-1 && hy == n-1) return level; //Reached target state\\n                for(int i = 0; i < 4; i++){\\n                    int ntx = tx + dir[i][0]; // next tail x- co-ordinate\\n                    int nty = ty + dir[i][1]; // next tail y- co-ordinate\\n                    int nhx = hx + dir[i][2]; // next head x- co-ordinate\\n                    int nhy = hy + dir[i][3]; // next head y- co-ordinate\\n                    //If original position is not horizontal and bottom cells are not 0, can\\'t do clockwise. So skip.\\n                    if(i==2 && (!isHoriz(tx, ty, hx, hy) || !isValid(tx+1, ty, grid) || !isValid(hx+1, hy, grid))) continue;\\n                    //If original position is not vertical and bottom cells are not 0, can\\'t do counter clockwise. So skip.\\n                    if(i==3 && (!isVert(tx, ty, hx, hy) || !isValid(tx, ty+1, grid) || !isValid(hx, hy+1, grid))) continue;\\n                    if(!isValid(ntx, nty, grid) || !isValid(nhx, nhy, grid)) continue; // just check validity of next co-ordinates\\n                    if(visited.contains(ntx + \",\" + nty + \",\" + nhx + \",\" + nhy)) continue;\\n                    q.offer(new int[] {ntx,nty,nhx,nhy});\\n                    visited.add(ntx + \",\" + nty + \",\" + nhx + \",\" + nhy);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(int i, int j, int[][] grid){\\n        if(i < 0 || j < 0 || i > grid.length-1 || j > grid.length-1 || grid[i][j] == 1) return false; \\n        return true;\\n    }\\n   \\n    public boolean isHoriz(int tx, int ty, int hx, int hy){\\n        if ((tx == hx) && (hy == ty + 1)) return true;\\n        return false;\\n    }\\n    \\n    public boolean isVert(int tx, int ty, int hx, int hy){\\n        if ((hx == tx + 1) && (hy == ty)) return true;\\n        return false;\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        Queue <int []> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        // pos 0 - horizontal move, pos 1 - vertical move, pos 2 - clockwise, pos 3 - counter clockwise\\n        int dir[][] = new int[][] {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\n        int n = grid.length, level = 0;\\n\\n        q.offer(new int[]{0,0,0,1});\\n        visited.add(0 + \",\" + 0 + \",\"+ 0 + \",\" + 1);\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int s = 0; s < size; s++){\\n                int [] curr = q.poll();\\n                int tx = curr[0]; //tail x- co-ordinate\\n                int ty = curr[1]; //tail y- co-ordinate\\n                int hx = curr[2]; //head x- co-ordinate\\n                int hy = curr[3]; //head y- co-ordinate\\n                if(tx == n-1 && ty == n-2 && hx == n-1 && hy == n-1) return level; //Reached target state\\n                for(int i = 0; i < 4; i++){\\n                    int ntx = tx + dir[i][0]; // next tail x- co-ordinate\\n                    int nty = ty + dir[i][1]; // next tail y- co-ordinate\\n                    int nhx = hx + dir[i][2]; // next head x- co-ordinate\\n                    int nhy = hy + dir[i][3]; // next head y- co-ordinate\\n                    //If original position is not horizontal and bottom cells are not 0, can\\'t do clockwise. So skip.\\n                    if(i==2 && (!isHoriz(tx, ty, hx, hy) || !isValid(tx+1, ty, grid) || !isValid(hx+1, hy, grid))) continue;\\n                    //If original position is not vertical and bottom cells are not 0, can\\'t do counter clockwise. So skip.\\n                    if(i==3 && (!isVert(tx, ty, hx, hy) || !isValid(tx, ty+1, grid) || !isValid(hx, hy+1, grid))) continue;\\n                    if(!isValid(ntx, nty, grid) || !isValid(nhx, nhy, grid)) continue; // just check validity of next co-ordinates\\n                    if(visited.contains(ntx + \",\" + nty + \",\" + nhx + \",\" + nhy)) continue;\\n                    q.offer(new int[] {ntx,nty,nhx,nhy});\\n                    visited.add(ntx + \",\" + nty + \",\" + nhx + \",\" + nhy);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586942,
                "title": "simple-java-bfs-solution-3d",
                "content": "```\\nclass Solution {\\n    //0-horizontal 1-vertical\\n    int[][][] dir = new int[][][]{\\n        {{0,1}, {1,0}, {1,-1}},\\n        {{0,1}, {1,0}, {-1,1}}\\n    };\\n    \\n    private boolean isValid(int[][] grid, int[] st, int action) {\\n        int x = st[0], y = st[1], d = st[2], n = grid.length;\\n        if(d == 0) {\\n            if(action == 0) return y + 1 < n && grid[x][y+1] == 0;\\n            return x + 1 < n && grid[x+1][y] == 0 && grid[x+1][y-1] == 0;\\n        } \\n        if(action == 0 || action == 2) return y + 1 < n && grid[x-1][y+1] == 0 && grid[x][y+1] == 0;\\n        return x + 1 < n && grid[x+1][y] == 0;\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][][] visited = new boolean[n][n][2];\\n        Queue<int[]> que = new LinkedList<>();\\n        que.offer(new int[]{0, 1, 0});\\n        visited[0][1][0] = true;\\n        \\n        int res = 0;\\n        while(!que.isEmpty()) {\\n            for(int size = que.size(); size > 0; size--) {\\n                int[] st = que.poll();\\n                int x = st[0], y = st[1], d = st[2];\\n                if(st[0] == n-1 && st[1] == n-1 && st[2] == 0) return res;\\n                for(int i = 0; i < 3; i++) {\\n                    if(isValid(grid, st, i)) {\\n                        int nx = x + dir[d][i][0], ny = y + dir[d][i][1], nd = i == 2 ? 1 - d : d;\\n                        if(!visited[nx][ny][nd]) {\\n                            visited[nx][ny][nd] = true;\\n                            que.offer(new int[]{nx, ny, nd});\\n                        }\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //0-horizontal 1-vertical\\n    int[][][] dir = new int[][][]{\\n        {{0,1}, {1,0}, {1,-1}},\\n        {{0,1}, {1,0}, {-1,1}}\\n    };\\n    \\n    private boolean isValid(int[][] grid, int[] st, int action) {\\n        int x = st[0], y = st[1], d = st[2], n = grid.length;\\n        if(d == 0) {\\n            if(action == 0) return y + 1 < n && grid[x][y+1] == 0;\\n            return x + 1 < n && grid[x+1][y] == 0 && grid[x+1][y-1] == 0;\\n        } \\n        if(action == 0 || action == 2) return y + 1 < n && grid[x-1][y+1] == 0 && grid[x][y+1] == 0;\\n        return x + 1 < n && grid[x+1][y] == 0;\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][][] visited = new boolean[n][n][2];\\n        Queue<int[]> que = new LinkedList<>();\\n        que.offer(new int[]{0, 1, 0});\\n        visited[0][1][0] = true;\\n        \\n        int res = 0;\\n        while(!que.isEmpty()) {\\n            for(int size = que.size(); size > 0; size--) {\\n                int[] st = que.poll();\\n                int x = st[0], y = st[1], d = st[2];\\n                if(st[0] == n-1 && st[1] == n-1 && st[2] == 0) return res;\\n                for(int i = 0; i < 3; i++) {\\n                    if(isValid(grid, st, i)) {\\n                        int nx = x + dir[d][i][0], ny = y + dir[d][i][1], nd = i == 2 ? 1 - d : d;\\n                        if(!visited[nx][ny][nd]) {\\n                            visited[nx][ny][nd] = true;\\n                            que.offer(new int[]{nx, ny, nd});\\n                        }\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558092,
                "title": "a-somewhat-long-winded-python-bfs-solution",
                "content": "It\\'s a straightforward breadth-first-search. The difficult part is doing the arithmetic to determine what moves the snake can make from the current possition, and where he ends up. I implemented a few helper functions so that the implementation matches the wording of the problem description as closely as possible.\\n\\n```python\\nclass Solution:\\n    \\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        n           = len(grid)\\n        start_state = ((0, 0), (0, 1))\\n        end_state   = ((n-1, n-2), (n-1, n-1))\\n        frontier    = {start_state}\\n        visited     = {start_state}\\n        num_moves   = 0\\n        N, S, E, W  = (-1, 0), (1, 0), (0, 1), (0, -1)\\n        \\n        def add(cell1, cell2):\\n            i1, j1 = cell1\\n            i2, j2 = cell2\\n            return (i1+i2, j1+j2)\\n        \\n        def blocked(cell):\\n            i, j = cell\\n            return grid[i][j] == 1\\n        \\n        def vertical(state):\\n            tail, head = state\\n            return add(tail, S) == head\\n        \\n        def in_bounds(cell):\\n            i, j = cell\\n            return 0 <= i < n and 0 <= j < n\\n        \\n        def valid(state):\\n            tail, head = state\\n            return (\\n                    in_bounds(tail) and not blocked(tail)\\n                and in_bounds(head) and not blocked(head)\\n            )\\n        \\n        def translations(state):\\n            tail, head  = state\\n            right       = (add(tail, E), add(head, E))\\n            down        = (add(tail, S), add(head, S))\\n            return filter(valid, (right, down))\\n        \\n        def rotations(state):\\n            tail, head = state\\n            a, b    = tail,         add(tail, E)\\n            c, d    = add(tail, S), add(b, S)\\n            if in_bounds(d) and not blocked(d):\\n                rotated = (a, b) if vertical(state) else (a, c)\\n                if valid(rotated):\\n                    yield rotated\\n        \\n        def successors(state):\\n            yield from translations(state)\\n            yield from rotations(state)\\n        \\n        while frontier:\\n            if end_state in frontier:\\n                return num_moves\\n            frontier = {\\n                successor\\n                for state in frontier\\n                for successor in successors(state)\\n                if successor not in visited\\n            }\\n            visited.update(frontier)\\n            num_moves += 1\\n        \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        n           = len(grid)\\n        start_state = ((0, 0), (0, 1))\\n        end_state   = ((n-1, n-2), (n-1, n-1))\\n        frontier    = {start_state}\\n        visited     = {start_state}\\n        num_moves   = 0\\n        N, S, E, W  = (-1, 0), (1, 0), (0, 1), (0, -1)\\n        \\n        def add(cell1, cell2):\\n            i1, j1 = cell1\\n            i2, j2 = cell2\\n            return (i1+i2, j1+j2)\\n        \\n        def blocked(cell):\\n            i, j = cell\\n            return grid[i][j] == 1\\n        \\n        def vertical(state):\\n            tail, head = state\\n            return add(tail, S) == head\\n        \\n        def in_bounds(cell):\\n            i, j = cell\\n            return 0 <= i < n and 0 <= j < n\\n        \\n        def valid(state):\\n            tail, head = state\\n            return (\\n                    in_bounds(tail) and not blocked(tail)\\n                and in_bounds(head) and not blocked(head)\\n            )\\n        \\n        def translations(state):\\n            tail, head  = state\\n            right       = (add(tail, E), add(head, E))\\n            down        = (add(tail, S), add(head, S))\\n            return filter(valid, (right, down))\\n        \\n        def rotations(state):\\n            tail, head = state\\n            a, b    = tail,         add(tail, E)\\n            c, d    = add(tail, S), add(b, S)\\n            if in_bounds(d) and not blocked(d):\\n                rotated = (a, b) if vertical(state) else (a, c)\\n                if valid(rotated):\\n                    yield rotated\\n        \\n        def successors(state):\\n            yield from translations(state)\\n            yield from rotations(state)\\n        \\n        while frontier:\\n            if end_state in frontier:\\n                return num_moves\\n            frontier = {\\n                successor\\n                for state in frontier\\n                for successor in successors(state)\\n                if successor not in visited\\n            }\\n            visited.update(frontier)\\n            num_moves += 1\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544074,
                "title": "c-dijkstra",
                "content": "```\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        set<vector<int>> visited{};\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> dijkstra{};\\n        dijkstra.push({0, 0, 0, 0, 1}); // {dist, (0,0), (0, 1)}\\n        while(!dijkstra.empty()){\\n            auto curr = dijkstra.top();\\n            if(curr[1]==row-1 && curr[2]==col-2 && curr[3]==row-1 && curr[4]==col-1) return curr[0];\\n            dijkstra.pop();\\n            visited.insert(curr);\\n            // to the right\\n            vector<int> ne_pos(curr.begin()+1, curr.end());\\n            auto ne = curr, ne_po = ne_pos;\\n            ++ne_pos[1], ++ne_pos[3], ++ne[0], ++ne[2], ++ne[4];\\n            if(ne_pos[3]<col && !grid[ne_pos[0]][ne_pos[1]] && !grid[ne_pos[2]][ne_pos[3]] && !visited.count(ne_pos)){\\n                dijkstra.push(ne);\\n                visited.insert(ne_pos);\\n            }\\n            // move down\\n            ne = curr;\\n            ne_pos = ne_po;\\n            ++ne_pos[0], ++ne_pos[2], ++ne[0], ++ne[1], ++ne[3];\\n            if(ne_pos[2]<row && !grid[ne_pos[0]][ne_pos[1]] && !grid[ne_pos[2]][ne_pos[3]] && !visited.count(ne_pos)){\\n                dijkstra.push(ne);\\n                visited.insert(ne_pos);\\n            }\\n            // clockwise\\n            if(curr[1]==curr[3]){\\n                ne = curr;\\n                ne_pos = ne_po;\\n                ++ne_pos[2], --ne_pos[3], ++ne[0], ++ne[3], --ne[4];\\n                if(ne_pos[2]<row && !grid[ne_pos[2]][ne_pos[3]] && !grid[ne_pos[2]][ne_pos[3]+1] && !visited.count(ne_pos)){\\n                    dijkstra.push(ne);\\n                    visited.insert(ne_pos);\\n                }\\n            }\\n            // counterclockwise\\n            if(curr[2]==curr[4]){\\n                ne = curr;\\n                ne_pos = ne_po;\\n                --ne_pos[2], ++ne_pos[3], ++ne[0], --ne[3], ++ne[4];\\n                if(ne_pos[3]<col && !grid[ne_pos[2]][ne_pos[3]] && !grid[ne_pos[2]+1][ne_pos[3]] && !visited.count(ne_pos)){\\n                    dijkstra.push(ne);\\n                    visited.insert(ne_pos);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        set<vector<int>> visited{};\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> dijkstra{};\\n        dijkstra.push({0, 0, 0, 0, 1}); // {dist, (0,0), (0, 1)}\\n        while(!dijkstra.empty()){\\n            auto curr = dijkstra.top();\\n            if(curr[1]==row-1 && curr[2]==col-2 && curr[3]==row-1 && curr[4]==col-1) return curr[0];\\n            dijkstra.pop();\\n            visited.insert(curr);\\n            // to the right\\n            vector<int> ne_pos(curr.begin()+1, curr.end());\\n            auto ne = curr, ne_po = ne_pos;\\n            ++ne_pos[1], ++ne_pos[3], ++ne[0], ++ne[2], ++ne[4];\\n            if(ne_pos[3]<col && !grid[ne_pos[0]][ne_pos[1]] && !grid[ne_pos[2]][ne_pos[3]] && !visited.count(ne_pos)){\\n                dijkstra.push(ne);\\n                visited.insert(ne_pos);\\n            }\\n            // move down\\n            ne = curr;\\n            ne_pos = ne_po;\\n            ++ne_pos[0], ++ne_pos[2], ++ne[0], ++ne[1], ++ne[3];\\n            if(ne_pos[2]<row && !grid[ne_pos[0]][ne_pos[1]] && !grid[ne_pos[2]][ne_pos[3]] && !visited.count(ne_pos)){\\n                dijkstra.push(ne);\\n                visited.insert(ne_pos);\\n            }\\n            // clockwise\\n            if(curr[1]==curr[3]){\\n                ne = curr;\\n                ne_pos = ne_po;\\n                ++ne_pos[2], --ne_pos[3], ++ne[0], ++ne[3], --ne[4];\\n                if(ne_pos[2]<row && !grid[ne_pos[2]][ne_pos[3]] && !grid[ne_pos[2]][ne_pos[3]+1] && !visited.count(ne_pos)){\\n                    dijkstra.push(ne);\\n                    visited.insert(ne_pos);\\n                }\\n            }\\n            // counterclockwise\\n            if(curr[2]==curr[4]){\\n                ne = curr;\\n                ne_pos = ne_po;\\n                --ne_pos[2], ++ne_pos[3], ++ne[0], --ne[3], ++ne[4];\\n                if(ne_pos[3]<col && !grid[ne_pos[2]][ne_pos[3]] && !grid[ne_pos[2]+1][ne_pos[3]] && !visited.count(ne_pos)){\\n                    dijkstra.push(ne);\\n                    visited.insert(ne_pos);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 533485,
                "title": "java-clean-solution-100-memory",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Set<Snake> visited = new HashSet<>();\\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        queue.add(new Pair(0, new Snake(0, 0, true)));\\n        visited.add(new Snake(0, 0, true));\\n        \\n        while (!queue.isEmpty()) {\\n            Pair current = queue.poll();\\n            Snake snake = current.snake;\\n            int moveNumber = current.moveNumber;\\n            \\n            if (isFinish(grid, snake))\\n                return moveNumber;\\n            \\n            Snake[] moves = new Snake[] {\\n                new Snake(snake.x + 1, snake.y, snake.horizontal),\\n                new Snake(snake.x, snake.y + 1, snake.horizontal),\\n                new Snake(snake.x, snake.y, false),\\n                new Snake(snake.x, snake.y, true)\\n            };\\n            \\n            for (Snake snakeMove : moves) {\\n                if (isFree(grid, snakeMove) && !visited.contains(snakeMove)) {\\n                    if (snakeMove.horizontal != snake.horizontal && grid[snake.y+1][snake.x+1] == 1)\\n                        continue;\\n                    \\n                    visited.add(snakeMove);\\n                    queue.add(new Pair(moveNumber + 1, snakeMove));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private boolean isFinish(int[][] grid, Snake snake) {\\n        return snake.horizontal && snake.y == grid.length - 1 && snake.x == grid[0].length - 2;\\n    }\\n    \\n    private boolean isFree(int[][] grid, Snake snake) {        \\n        if (snake.y < 0 || snake.y + (snake.horizontal ? 0 : 1) >= grid.length)\\n            return false;\\n        \\n        if (snake.x < 0 || snake.x + (snake.horizontal ? 1 : 0) >= grid[0].length)\\n            return false;\\n        \\n        if (grid[snake.y][snake.x] == 1)\\n            return false;\\n        \\n        if (grid[snake.y + (snake.horizontal ? 0 : 1)][snake.x + (snake.horizontal ? 1 : 0)] == 1)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private static class Snake {\\n        public int x;\\n        public int y;\\n        public boolean horizontal;\\n        \\n        public Snake(int x, int y, boolean horizontal) {\\n            this.x = x;\\n            this.y = y;\\n            this.horizontal = horizontal;\\n        }\\n        \\n        public boolean equals(Object o) {\\n            if (o == this)\\n                return true;\\n            \\n            if (o == null)\\n                return false;\\n            \\n            if (!(o instanceof Snake))\\n                return false;\\n            \\n            Snake snake = (Snake) o;\\n            return snake.x == x && snake.y == y && snake.horizontal == horizontal;\\n        }\\n        \\n        public int hashCode() {\\n            return Objects.hash(x, y, horizontal);\\n        }\\n        \\n        public String toString() {\\n            return \"{X=\" + x + \",Y=\" + y + \",H=\" + horizontal + \"}\";\\n        }\\n    }\\n    \\n    private static class Pair {\\n        public int moveNumber;\\n        public Snake snake;\\n        \\n        public Pair(int moveNumber, Snake snake) {\\n            this.moveNumber = moveNumber;\\n            this.snake = snake;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Set<Snake> visited = new HashSet<>();\\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        queue.add(new Pair(0, new Snake(0, 0, true)));\\n        visited.add(new Snake(0, 0, true));\\n        \\n        while (!queue.isEmpty()) {\\n            Pair current = queue.poll();\\n            Snake snake = current.snake;\\n            int moveNumber = current.moveNumber;\\n            \\n            if (isFinish(grid, snake))\\n                return moveNumber;\\n            \\n            Snake[] moves = new Snake[] {\\n                new Snake(snake.x + 1, snake.y, snake.horizontal),\\n                new Snake(snake.x, snake.y + 1, snake.horizontal),\\n                new Snake(snake.x, snake.y, false),\\n                new Snake(snake.x, snake.y, true)\\n            };\\n            \\n            for (Snake snakeMove : moves) {\\n                if (isFree(grid, snakeMove) && !visited.contains(snakeMove)) {\\n                    if (snakeMove.horizontal != snake.horizontal && grid[snake.y+1][snake.x+1] == 1)\\n                        continue;\\n                    \\n                    visited.add(snakeMove);\\n                    queue.add(new Pair(moveNumber + 1, snakeMove));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private boolean isFinish(int[][] grid, Snake snake) {\\n        return snake.horizontal && snake.y == grid.length - 1 && snake.x == grid[0].length - 2;\\n    }\\n    \\n    private boolean isFree(int[][] grid, Snake snake) {        \\n        if (snake.y < 0 || snake.y + (snake.horizontal ? 0 : 1) >= grid.length)\\n            return false;\\n        \\n        if (snake.x < 0 || snake.x + (snake.horizontal ? 1 : 0) >= grid[0].length)\\n            return false;\\n        \\n        if (grid[snake.y][snake.x] == 1)\\n            return false;\\n        \\n        if (grid[snake.y + (snake.horizontal ? 0 : 1)][snake.x + (snake.horizontal ? 1 : 0)] == 1)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private static class Snake {\\n        public int x;\\n        public int y;\\n        public boolean horizontal;\\n        \\n        public Snake(int x, int y, boolean horizontal) {\\n            this.x = x;\\n            this.y = y;\\n            this.horizontal = horizontal;\\n        }\\n        \\n        public boolean equals(Object o) {\\n            if (o == this)\\n                return true;\\n            \\n            if (o == null)\\n                return false;\\n            \\n            if (!(o instanceof Snake))\\n                return false;\\n            \\n            Snake snake = (Snake) o;\\n            return snake.x == x && snake.y == y && snake.horizontal == horizontal;\\n        }\\n        \\n        public int hashCode() {\\n            return Objects.hash(x, y, horizontal);\\n        }\\n        \\n        public String toString() {\\n            return \"{X=\" + x + \",Y=\" + y + \",H=\" + horizontal + \"}\";\\n        }\\n    }\\n    \\n    private static class Pair {\\n        public int moveNumber;\\n        public Snake snake;\\n        \\n        public Pair(int moveNumber, Snake snake) {\\n            this.moveNumber = moveNumber;\\n            this.snake = snake;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528333,
                "title": "javascript-bfs",
                "content": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumMoves = function(grid) {\\n    const len = grid.length;\\n    const initPosition = [0, true, 1]\\n    const visited = new Set([initPosition.join()]);\\n\\n    const queue = new Queue();\\n    initPosition.push(0);\\n    queue.enqueue(initPosition)\\n    while (!queue.isEmpty()) {\\n        let [row, isHorizontal, col, numMoves] = queue.dequeue();\\n        if (row + col === len * 2 - 2 && isHorizontal) return numMoves;\\n        numMoves++;\\n        const positions = [];\\n        if (isHorizontal) {\\n            if (grid[row][col + 1] === 0) {\\n                positions.push([row, true, col + 1])\\n            }\\n            if (row + 1 < len && grid[row + 1][col - 1] === 0 && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, true, col])\\n                positions.push([row + 1, false, col - 1]);\\n            }\\n        } else {\\n            if (row + 1 < len && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, false, col]);\\n            }\\n            if (row > 0 && grid[row - 1][col + 1] === 0 && grid[row][col + 1] === 0) {\\n                positions.push([row, false, col + 1]);\\n                positions.push([row - 1, true, col + 1]);\\n            }\\n        }\\n        for (let position of positions) {\\n            const str = position.join();\\n            if (visited.has(str)) continue;\\n            visited.add(str);\\n            position.push(numMoves);\\n            queue.enqueue(position);\\n        }\\n    }\\n    return -1;\\n};\\n\\nclass Queue {\\n    constructor() {\\n        this.head = { next: null };\\n        this.tail = this.head;\\n    }\\n\\n    isEmpty() {\\n        return this.head.next === null;\\n    }\\n\\n    dequeue() {\\n        const { value } = this.head.next;\\n        this.head = this.head.next;\\n        return value;\\n    }\\n\\n    enqueue(value) {\\n        this.tail.next = { value, next: null };\\n        this.tail = this.tail.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumMoves = function(grid) {\\n    const len = grid.length;\\n    const initPosition = [0, true, 1]\\n    const visited = new Set([initPosition.join()]);\\n\\n    const queue = new Queue();\\n    initPosition.push(0);\\n    queue.enqueue(initPosition)\\n    while (!queue.isEmpty()) {\\n        let [row, isHorizontal, col, numMoves] = queue.dequeue();\\n        if (row + col === len * 2 - 2 && isHorizontal) return numMoves;\\n        numMoves++;\\n        const positions = [];\\n        if (isHorizontal) {\\n            if (grid[row][col + 1] === 0) {\\n                positions.push([row, true, col + 1])\\n            }\\n            if (row + 1 < len && grid[row + 1][col - 1] === 0 && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, true, col])\\n                positions.push([row + 1, false, col - 1]);\\n            }\\n        } else {\\n            if (row + 1 < len && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, false, col]);\\n            }\\n            if (row > 0 && grid[row - 1][col + 1] === 0 && grid[row][col + 1] === 0) {\\n                positions.push([row, false, col + 1]);\\n                positions.push([row - 1, true, col + 1]);\\n            }\\n        }\\n        for (let position of positions) {\\n            const str = position.join();\\n            if (visited.has(str)) continue;\\n            visited.add(str);\\n            position.push(numMoves);\\n            queue.enqueue(position);\\n        }\\n    }\\n    return -1;\\n};\\n\\nclass Queue {\\n    constructor() {\\n        this.head = { next: null };\\n        this.tail = this.head;\\n    }\\n\\n    isEmpty() {\\n        return this.head.next === null;\\n    }\\n\\n    dequeue() {\\n        const { value } = this.head.next;\\n        this.head = this.head.next;\\n        return value;\\n    }\\n\\n    enqueue(value) {\\n        this.tail.next = { value, next: null };\\n        this.tail = this.tail.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 511370,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, step = 0;\\n        if(grid[n-1][n-1] == 1 || grid[n-1][n-2] == 1) return -1;\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        queue.offer(new int[]{0, 0, 0});\\n        visited[0][0][0] = true;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int[] cur = queue.poll();\\n                int x = cur[0], y = cur[1], state = cur[2];\\n                if(x == n - 1 && y == n - 2 && state == 0) return step;\\n                if(state == 0){\\n                    //y+2 here because the snake\\'s length is 2\\n                    if(y + 1 < n - 1 && grid[x][y+2] == 0 && !visited[x][y+1][0]){\\n                        visited[x][y+1][0] = true;\\n                        queue.offer(new int[]{x, y + 1, 0});\\n                    }\\n                    if(x + 1 < n && grid[x + 1][y] == 0 && grid[x+1][y+1]==0){\\n                        if(!visited[x+1][y][0]){\\n                            visited[x+1][y][0] = true;\\n                            queue.offer(new int[]{x+1, y, 0});\\n                        }\\n                        if(!visited[x][y][1]){\\n                            visited[x][y][1] = true;\\n                             queue.offer(new int[]{x, y, 1});\\n                        }\\n                    }\\n                }else{\\n                    //x+2 here because the snake\\'s length is 2\\n                    if(x + 1 < n - 1 && grid[x+2][y] == 0 && !visited[x+1][y][1]){\\n                        visited[x+1][y][1] = true;\\n                        queue.offer(new int[]{x+1, y, 1});\\n                    }\\n                    if(y + 1 < n && grid[x][y+1] == 0 && grid[x+1][y+1]==0){\\n                        if(!visited[x][y+1][1]){\\n                            visited[x][y+1][1] = true;\\n                            queue.offer(new int[]{x, y+1, 1});\\n                        }\\n                        if(!visited[x][y][0]){\\n                            visited[x][y][0] = true;\\n                             queue.offer(new int[]{x, y, 0});\\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, step = 0;\\n        if(grid[n-1][n-1] == 1 || grid[n-1][n-2] == 1) return -1;\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        queue.offer(new int[]{0, 0, 0});\\n        visited[0][0][0] = true;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int[] cur = queue.poll();\\n                int x = cur[0], y = cur[1], state = cur[2];\\n                if(x == n - 1 && y == n - 2 && state == 0) return step;\\n                if(state == 0){\\n                    //y+2 here because the snake\\'s length is 2\\n                    if(y + 1 < n - 1 && grid[x][y+2] == 0 && !visited[x][y+1][0]){\\n                        visited[x][y+1][0] = true;\\n                        queue.offer(new int[]{x, y + 1, 0});\\n                    }\\n                    if(x + 1 < n && grid[x + 1][y] == 0 && grid[x+1][y+1]==0){\\n                        if(!visited[x+1][y][0]){\\n                            visited[x+1][y][0] = true;\\n                            queue.offer(new int[]{x+1, y, 0});\\n                        }\\n                        if(!visited[x][y][1]){\\n                            visited[x][y][1] = true;\\n                             queue.offer(new int[]{x, y, 1});\\n                        }\\n                    }\\n                }else{\\n                    //x+2 here because the snake\\'s length is 2\\n                    if(x + 1 < n - 1 && grid[x+2][y] == 0 && !visited[x+1][y][1]){\\n                        visited[x+1][y][1] = true;\\n                        queue.offer(new int[]{x+1, y, 1});\\n                    }\\n                    if(y + 1 < n && grid[x][y+1] == 0 && grid[x+1][y+1]==0){\\n                        if(!visited[x][y+1][1]){\\n                            visited[x][y+1][1] = true;\\n                            queue.offer(new int[]{x, y+1, 1});\\n                        }\\n                        if(!visited[x][y][0]){\\n                            visited[x][y][0] = true;\\n                             queue.offer(new int[]{x, y, 0});\\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509805,
                "title": "i-never-seen-a-red-snake",
                "content": "This is more like a Chinese Lion Dance than a snake :)",
                "solutionTags": [],
                "code": "This is more like a Chinese Lion Dance than a snake :)",
                "codeTag": "Unknown"
            },
            {
                "id": 508727,
                "title": "this-problem-is-ambiguous",
                "content": "1. The description says inital location is [0,0] and [0,1], which sounds like the snake is initially vertical, but the diagram shows the snake is initally horizontal\\n2. Does head/tail matter? If it doesn\\'t matter, then you can do CW or CCW rotations pivot on both coordinates.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 500477,
                "title": "clean-java-bfs-solution",
                "content": "```\\nclass Solution {\\n    \\n    private static class Pos {\\n        int hr;\\n        int hc;\\n        int tr;\\n        int tc;\\n        \\n        public Pos(int hr, int hc, int tr, int tc) {\\n            this.hr = hr;\\n            this.hc = hc;\\n            this.tr = tr;\\n            this.tc = tc;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object obj) {\\n            if (obj instanceof Pos) {\\n                Pos other = (Pos)obj;\\n                return other.hr == hr && other.hc == hc && other.tr == tr && other.tc == tc;\\n            }\\n            return false;\\n        } \\n        \\n        @Override\\n        public int hashCode() {\\n            return hr * 1000000 + hc * 10000 + tr * 100 + tc;\\n        }\\n    }\\n\\n    //bfs \\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        Pos initial = new Pos(0, 1, 0, 0);\\n        Deque<Pos> deque = new ArrayDeque<>();\\n        deque.add(initial);\\n        Set<Pos> seen = new HashSet<>();\\n        seen.add(initial);\\n        \\n        int level = 0;\\n        while (!deque.isEmpty()) {\\n            int size = deque.size();\\n            while (size-- > 0) {\\n                Pos pos = deque.poll();\\n                if (pos.hr == n - 1 && pos.hc == n - 1 && pos.tr == n - 1 && pos.tc == n - 2) {\\n                    return level;\\n                }\\n\\n                //down \\n                Pos down = new Pos(pos.hr + 1, pos.hc, pos.tr + 1, pos.tc);\\n                if (down.hr < n && down.tr < n && grid[down.hr][down.hc] == 0 && grid[down.tr][down.tc] == 0 && !seen.contains(down)) {\\n                    deque.add(down);\\n                    seen.add(down);\\n                }\\n\\n                //right\\n                Pos right = new Pos(pos.hr, pos.hc + 1, pos.tr, pos.tc + 1);\\n                if (right.hc < n && right.tc < n && grid[right.hr][right.hc] == 0 && grid[right.tr][right.tc] == 0 && !seen.contains(right)) {\\n                    deque.add(right);\\n                    seen.add(right);\\n                }\\n                \\n                //clockwise\\n                if (pos.hr == pos.tr) { //pos is horizontal\\n                    Pos turn = new Pos(pos.tr + 1, pos.tc, pos.tr, pos.tc);\\n                    if (turn.hr < n && grid[pos.hr + 1][pos.hc] == 0 && grid[pos.tr + 1][pos.tc] == 0 && !seen.contains(turn)) {\\n                        deque.add(turn);\\n                        seen.add(turn);\\n                    }\\n                }\\n\\n                //counter clockwise\\n                if (pos.hc == pos.tc) {\\n                    Pos turn = new Pos(pos.tr, pos.tc + 1, pos.tr, pos.tc);\\n                    if (turn.hc < n && grid[pos.hr][pos.hc + 1] == 0 && grid[pos.tr][pos.tc + 1] == 0 && !seen.contains(turn)) {\\n                        deque.add(turn);\\n                        seen.add(turn);\\n                    }\\n                }\\n                \\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static class Pos {\\n        int hr;\\n        int hc;\\n        int tr;\\n        int tc;\\n        \\n        public Pos(int hr, int hc, int tr, int tc) {\\n            this.hr = hr;\\n            this.hc = hc;\\n            this.tr = tr;\\n            this.tc = tc;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object obj) {\\n            if (obj instanceof Pos) {\\n                Pos other = (Pos)obj;\\n                return other.hr == hr && other.hc == hc && other.tr == tr && other.tc == tc;\\n            }\\n            return false;\\n        } \\n        \\n        @Override\\n        public int hashCode() {\\n            return hr * 1000000 + hc * 10000 + tr * 100 + tc;\\n        }\\n    }\\n\\n    //bfs \\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        Pos initial = new Pos(0, 1, 0, 0);\\n        Deque<Pos> deque = new ArrayDeque<>();\\n        deque.add(initial);\\n        Set<Pos> seen = new HashSet<>();\\n        seen.add(initial);\\n        \\n        int level = 0;\\n        while (!deque.isEmpty()) {\\n            int size = deque.size();\\n            while (size-- > 0) {\\n                Pos pos = deque.poll();\\n                if (pos.hr == n - 1 && pos.hc == n - 1 && pos.tr == n - 1 && pos.tc == n - 2) {\\n                    return level;\\n                }\\n\\n                //down \\n                Pos down = new Pos(pos.hr + 1, pos.hc, pos.tr + 1, pos.tc);\\n                if (down.hr < n && down.tr < n && grid[down.hr][down.hc] == 0 && grid[down.tr][down.tc] == 0 && !seen.contains(down)) {\\n                    deque.add(down);\\n                    seen.add(down);\\n                }\\n\\n                //right\\n                Pos right = new Pos(pos.hr, pos.hc + 1, pos.tr, pos.tc + 1);\\n                if (right.hc < n && right.tc < n && grid[right.hr][right.hc] == 0 && grid[right.tr][right.tc] == 0 && !seen.contains(right)) {\\n                    deque.add(right);\\n                    seen.add(right);\\n                }\\n                \\n                //clockwise\\n                if (pos.hr == pos.tr) { //pos is horizontal\\n                    Pos turn = new Pos(pos.tr + 1, pos.tc, pos.tr, pos.tc);\\n                    if (turn.hr < n && grid[pos.hr + 1][pos.hc] == 0 && grid[pos.tr + 1][pos.tc] == 0 && !seen.contains(turn)) {\\n                        deque.add(turn);\\n                        seen.add(turn);\\n                    }\\n                }\\n\\n                //counter clockwise\\n                if (pos.hc == pos.tc) {\\n                    Pos turn = new Pos(pos.tr, pos.tc + 1, pos.tr, pos.tc);\\n                    if (turn.hc < n && grid[pos.hr][pos.hc + 1] == 0 && grid[pos.tr][pos.tc + 1] == 0 && !seen.contains(turn)) {\\n                        deque.add(turn);\\n                        seen.add(turn);\\n                    }\\n                }\\n                \\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495950,
                "title": "c-bfs-clean-implementation-with-comment",
                "content": "```\\nclass Solution {\\n    string make_key(vector<int> pos) {\\n        assert (pos.size() == 4);\\n        \\n        int x1 = pos[0], y1 = pos[1];\\n        int x2 = pos[2], y2 = pos[3];\\n        string p1 = to_string(x1) + \",\" + to_string(y1);\\n        string p2 = to_string(x2) + \",\" + to_string(y2);\\n        \\n        // 0,0:1,0\\n        return p1 + \":\" + p2;\\n    }\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        // x1,y1,x2,y2\\n        queue<vector<int>> bfsQ;\\n        bfsQ.push({0, 0, 0, 1});\\n        unordered_set<string> visited;\\n        visited.insert (make_key({0, 0, 0, 1}));\\n        \\n        int moves = 0;\\n        while (!bfsQ.empty()) {\\n            int size = bfsQ.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                vector<int> pos = bfsQ.front(); bfsQ.pop();\\n                int x1 = pos[0], y1 = pos[1];\\n                int x2 = pos[2], y2 = pos[3];\\n                \\n                //cout << x1 << \" \" << y1 << endl;\\n                // found\\n                if (x1 == n - 1 && y1 == n - 2 &&\\n                    x2 == n - 1 && y2 == n - 1) {\\n                    return moves;\\n                }\\n                \\n                vector<vector<int>> candi = {\\n                    // horizontal\\n                    {x1 + 1, y1, x2 + 1, y2},\\n                    {x1, y1, x1 + 1, y1},\\n                    {x2, y2, x2, y2 + 1},\\n                    // vertical\\n                    {x1, y1 + 1, x2, y2 + 1},\\n                    {x1, y1, x1, y1 + 1},\\n                    {x2, y2, x2 + 1, y2}\\n                };\\n                // move index into candi\\n                vector<int> next;\\n                \\n                // horizontal\\n                if (x1 == x2) {\\n                    // down, clockwise\\n                    if (x1 + 1 < n && grid[x1 + 1][y1] == 0 && grid[x1 + 1][y2] == 0) {\\n                        next.push_back (0);\\n                        next.push_back (1);\\n                    }\\n                    \\n                    // right\\n                    if (y2 + 1 < n && grid[x1][y2 + 1] == 0) {\\n                        next.push_back (2);\\n                    }\\n                }\\n                // vertical\\n                else if (y1 == y2) {\\n                    if (y2 + 1 < n && grid[x1][y1 + 1] == 0 && grid[x2][y2 + 1] == 0) {\\n                        next.push_back (3);\\n                        next.push_back (4);\\n                    }\\n                    \\n                    // down\\n                    if (x2 + 1 < n && grid[x2 + 1][y1] == 0) {\\n                        next.push_back (5);\\n                    }\\n                }\\n                \\n                for (int j = 0; j < next.size(); j++) {\\n                    int idx = next[j];\\n                    string key = make_key(candi[idx]);\\n                    if (visited.find(key) == visited.end()) {\\n                        bfsQ.push (candi[idx]);\\n                        visited.insert (key);\\n                    }\\n                }\\n            }\\n            \\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    string make_key(vector<int> pos) {\\n        assert (pos.size() == 4);\\n        \\n        int x1 = pos[0], y1 = pos[1];\\n        int x2 = pos[2], y2 = pos[3];\\n        string p1 = to_string(x1) + \",\" + to_string(y1);\\n        string p2 = to_string(x2) + \",\" + to_string(y2);\\n        \\n        // 0,0:1,0\\n        return p1 + \":\" + p2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 495907,
                "title": "accessible-solutions-with-comments-with-bfs-and-thinking-about-general-questions",
                "content": "```\\npublic class Solution {\\n    public static int n, t1, t2;\\n    static class State {\\n        int ti, tj, hi, hj; // the location of tail and head.        (ti, tj, hi, hj) \\n\\n        public State(int ti, int tj, int hi, int hj) {\\n            this.ti = ti;\\n            this.tj = tj;\\n            this.hi = hi;\\n            this.hj = hj;\\n        }\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n\\n        n = grid.length;\\n        t1 = n * n - 2;\\n        t2 = n * n - 1;\\n        Queue<State> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        q.offer(new State(0, 0, 0, 1));\\n        visited.add(\"0,1\");\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                State cur = q.poll();\\n                //System.out.println(\"tail:\"+cur.ti+\" \"+cur.tj+\" head:\"+cur.hi+\" \"+cur.hj);\\n                if (reachTarget(cur.ti * n + cur.tj, cur.hi * n + cur.hj))\\n                    return step;\\n                //crawl down or right along the direction of snake,  (ti1,tj1,hi1,hj1) is a new state\\n                int hi1 = 2 * cur.hj - cur.tj, hj1 = 2 * cur.hi - cur.ti;\\n                int ti1 = cur.hj, tj1 = cur.hi;\\n                if (isValidPos(hj1, hi1, grid)) {\\n                    String str = (tj1 * n + ti1) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(tj1, ti1, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                \\n                //crawl perpendicular to the direction of snake\\n                if(cur.ti==cur.hi){\\n                    \\n                    hi1=cur.hi+1;\\n                    hj1=cur.hj;\\n                    ti1=cur.ti+1;\\n                    tj1=cur.tj;\\n                    if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                        String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(ti1, tj1, hi1, hj1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                else{\\n                    hi1=cur.hi;\\n                    hj1=cur.hj+1;\\n                    ti1=cur.ti;\\n                    tj1=cur.tj+1;\\n                    if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                        String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(ti1, tj1, hi1, hj1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                //clockwise rotate\\n                if(cur.hi==cur.ti && cur.hj>cur.tj){\\n                    hi1 = cur.ti + cur.tj - cur.hi;\\n                    hj1 = cur.ti - cur.tj + cur.hj;\\n                    int a = cur.hj-cur.hi+cur.ti, b = cur.hi + cur.hj-cur.tj;\\n                    if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                        String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                \\n                //counterclockwise rotate\\n                if(cur.hj==cur.tj && cur.hi>cur.ti){\\n                    hi1 = cur.tj - cur.ti + cur.hi;\\n                    hj1 = cur.ti + cur.tj - cur.hj;\\n                    int a = cur.hi+cur.hj-cur.ti;\\n                    int b = cur.tj-cur.hj+cur.hi;\\n                    if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                        String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                            visited.add(str);\\n                        }\\n                    }    \\n                }\\n            }\\n            step++;\\n            //System.out.println(\"step:\" +step);\\n        }\\n        return -1;\\n    }\\n\\n    //check whether llegal location\\n    public static boolean isValidPos(int x, int y, int[][] grid) {\\n        if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 1)\\n            return false;\\n        return true;\\n    }\\n\\n    //chek whether reach the target location\\n    public static boolean reachTarget(int a, int b) {\\n        return (a == t1 && b == t2) || (a == t2 && b == t1);\\n    }\\n}\\n\\n\\n```\\n\\nThis question has been simplified because the snake can only move from top-left to right-down and rotate restrictedly. That is to say the rule of move is different from the move of a real snake. it \\'s very unnatural.\\nTHe following code is my beginning idea that overlooks the given restrictions and hence fails\\n```\\npublic class Solution {\\n\\n    public static int n, t1, t2;\\n    public static int[] d={-1,1};\\n    static class State {\\n        int ti, tj, hi, hj;\\n\\n        public State(int ti, int tj, int hi, int hj) {\\n            this.ti = ti;\\n            this.tj = tj;\\n            this.hi = hi;\\n            this.hj = hj;\\n        }\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n\\n        n = grid.length;\\n        t1 = n * n - 2;\\n        t2 = n * n - 1;\\n        Queue<State> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        q.offer(new State(0, 0, 0, 1));\\n        visited.add(\"0,1\");\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                State cur = q.poll();\\n                //System.out.println(\"tail:\"+cur.ti+\" \"+cur.tj+\" head:\"+cur.hi+\" \"+cur.hj);\\n                if (reachTarget(cur.ti * n + cur.tj, cur.hi * n + cur.hj))\\n                    return step;\\n                //crawl down or right along the direction of snake,  (ti1,tj1,hi1,hj1) is a new state\\n                int hi1 = 2 * cur.hj - cur.tj, hj1 = 2 * cur.hi - cur.ti;\\n                int ti1 = cur.hj, tj1 = cur.hi;\\n                if (isValidPos(hj1, hi1, grid)) {\\n                    String str = (tj1 * n + ti1) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(tj1, ti1, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                \\n                //crawl perpendicular to the direction of snake\\n                if(cur.ti==cur.hi){\\n                    for(int i=0;i<2;i++){\\n                        hi1=cur.hi+d[i];\\n                        hj1=cur.hj;\\n                        ti1=cur.ti+d[i];\\n                        tj1=cur.tj;\\n                        if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                            String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                            if (!visited.contains(str)) {\\n                                q.offer(new State(ti1, tj1, hi1, hj1));\\n                                visited.add(str);\\n                            }\\n                        }\\n                    }\\n                }\\n                else{\\n                    for(int i=0;i<2;i++){\\n                        hi1=cur.hi;\\n                        hj1=cur.hj+d[i];\\n                        ti1=cur.ti;\\n                        tj1=cur.tj+d[i];\\n                        if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                            String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                            if (!visited.contains(str)) {\\n                                q.offer(new State(ti1, tj1, hi1, hj1));\\n                                visited.add(str);\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n                \\n                \\n                //clockwise rotate  that overlooks directions\\n                hi1 = cur.ti + cur.tj - cur.hi;\\n                hj1 = cur.ti - cur.tj + cur.hj;\\n                int a = cur.hj-cur.hi+cur.ti, b = cur.hi + cur.hj-cur.tj;\\n                if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                    String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                //counterclockwise rotate that overlooks directions\\n                hi1 = cur.tj - cur.ti + cur.hi;\\n                hj1 = cur.ti + cur.tj - cur.hj;\\n                a = cur.hi+cur.hj-cur.ti;\\n                b = cur.tj-cur.hj+cur.hi;\\n                if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                    String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n            }\\n            step++;\\n            //System.out.println(\"step:\" +step);\\n        }\\n        return -1;\\n    }\\n\\n    //check location\\n    public static boolean isValidPos(int x, int y, int[][] grid) {\\n        if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 1)\\n            return false;\\n        return true;\\n    }\\n\\n    //chek whether reach the target location\\n    public static boolean reachTarget(int a, int b) {\\n        return (a == t1 && b == t2) || (a == t2 && b == t1);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public static int n, t1, t2;\\n    static class State {\\n        int ti, tj, hi, hj; // the location of tail and head.        (ti, tj, hi, hj) \\n\\n        public State(int ti, int tj, int hi, int hj) {\\n            this.ti = ti;\\n            this.tj = tj;\\n            this.hi = hi;\\n            this.hj = hj;\\n        }\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n\\n        n = grid.length;\\n        t1 = n * n - 2;\\n        t2 = n * n - 1;\\n        Queue<State> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        q.offer(new State(0, 0, 0, 1));\\n        visited.add(\"0,1\");\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                State cur = q.poll();\\n                //System.out.println(\"tail:\"+cur.ti+\" \"+cur.tj+\" head:\"+cur.hi+\" \"+cur.hj);\\n                if (reachTarget(cur.ti * n + cur.tj, cur.hi * n + cur.hj))\\n                    return step;\\n                //crawl down or right along the direction of snake,  (ti1,tj1,hi1,hj1) is a new state\\n                int hi1 = 2 * cur.hj - cur.tj, hj1 = 2 * cur.hi - cur.ti;\\n                int ti1 = cur.hj, tj1 = cur.hi;\\n                if (isValidPos(hj1, hi1, grid)) {\\n                    String str = (tj1 * n + ti1) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(tj1, ti1, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                \\n                //crawl perpendicular to the direction of snake\\n                if(cur.ti==cur.hi){\\n                    \\n                    hi1=cur.hi+1;\\n                    hj1=cur.hj;\\n                    ti1=cur.ti+1;\\n                    tj1=cur.tj;\\n                    if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                        String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(ti1, tj1, hi1, hj1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                else{\\n                    hi1=cur.hi;\\n                    hj1=cur.hj+1;\\n                    ti1=cur.ti;\\n                    tj1=cur.tj+1;\\n                    if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                        String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(ti1, tj1, hi1, hj1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                //clockwise rotate\\n                if(cur.hi==cur.ti && cur.hj>cur.tj){\\n                    hi1 = cur.ti + cur.tj - cur.hi;\\n                    hj1 = cur.ti - cur.tj + cur.hj;\\n                    int a = cur.hj-cur.hi+cur.ti, b = cur.hi + cur.hj-cur.tj;\\n                    if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                        String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                \\n                //counterclockwise rotate\\n                if(cur.hj==cur.tj && cur.hi>cur.ti){\\n                    hi1 = cur.tj - cur.ti + cur.hi;\\n                    hj1 = cur.ti + cur.tj - cur.hj;\\n                    int a = cur.hi+cur.hj-cur.ti;\\n                    int b = cur.tj-cur.hj+cur.hi;\\n                    if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                        String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                            visited.add(str);\\n                        }\\n                    }    \\n                }\\n            }\\n            step++;\\n            //System.out.println(\"step:\" +step);\\n        }\\n        return -1;\\n    }\\n\\n    //check whether llegal location\\n    public static boolean isValidPos(int x, int y, int[][] grid) {\\n        if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 1)\\n            return false;\\n        return true;\\n    }\\n\\n    //chek whether reach the target location\\n    public static boolean reachTarget(int a, int b) {\\n        return (a == t1 && b == t2) || (a == t2 && b == t1);\\n    }\\n}\\n\\n\\n```\n```\\npublic class Solution {\\n\\n    public static int n, t1, t2;\\n    public static int[] d={-1,1};\\n    static class State {\\n        int ti, tj, hi, hj;\\n\\n        public State(int ti, int tj, int hi, int hj) {\\n            this.ti = ti;\\n            this.tj = tj;\\n            this.hi = hi;\\n            this.hj = hj;\\n        }\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n\\n        n = grid.length;\\n        t1 = n * n - 2;\\n        t2 = n * n - 1;\\n        Queue<State> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        q.offer(new State(0, 0, 0, 1));\\n        visited.add(\"0,1\");\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                State cur = q.poll();\\n                //System.out.println(\"tail:\"+cur.ti+\" \"+cur.tj+\" head:\"+cur.hi+\" \"+cur.hj);\\n                if (reachTarget(cur.ti * n + cur.tj, cur.hi * n + cur.hj))\\n                    return step;\\n                //crawl down or right along the direction of snake,  (ti1,tj1,hi1,hj1) is a new state\\n                int hi1 = 2 * cur.hj - cur.tj, hj1 = 2 * cur.hi - cur.ti;\\n                int ti1 = cur.hj, tj1 = cur.hi;\\n                if (isValidPos(hj1, hi1, grid)) {\\n                    String str = (tj1 * n + ti1) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(tj1, ti1, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                \\n                //crawl perpendicular to the direction of snake\\n                if(cur.ti==cur.hi){\\n                    for(int i=0;i<2;i++){\\n                        hi1=cur.hi+d[i];\\n                        hj1=cur.hj;\\n                        ti1=cur.ti+d[i];\\n                        tj1=cur.tj;\\n                        if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                            String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                            if (!visited.contains(str)) {\\n                                q.offer(new State(ti1, tj1, hi1, hj1));\\n                                visited.add(str);\\n                            }\\n                        }\\n                    }\\n                }\\n                else{\\n                    for(int i=0;i<2;i++){\\n                        hi1=cur.hi;\\n                        hj1=cur.hj+d[i];\\n                        ti1=cur.ti;\\n                        tj1=cur.tj+d[i];\\n                        if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                            String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                            if (!visited.contains(str)) {\\n                                q.offer(new State(ti1, tj1, hi1, hj1));\\n                                visited.add(str);\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n                \\n                \\n                //clockwise rotate  that overlooks directions\\n                hi1 = cur.ti + cur.tj - cur.hi;\\n                hj1 = cur.ti - cur.tj + cur.hj;\\n                int a = cur.hj-cur.hi+cur.ti, b = cur.hi + cur.hj-cur.tj;\\n                if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                    String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                //counterclockwise rotate that overlooks directions\\n                hi1 = cur.tj - cur.ti + cur.hi;\\n                hj1 = cur.ti + cur.tj - cur.hj;\\n                a = cur.hi+cur.hj-cur.ti;\\n                b = cur.tj-cur.hj+cur.hi;\\n                if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                    String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n            }\\n            step++;\\n            //System.out.println(\"step:\" +step);\\n        }\\n        return -1;\\n    }\\n\\n    //check location\\n    public static boolean isValidPos(int x, int y, int[][] grid) {\\n        if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 1)\\n            return false;\\n        return true;\\n    }\\n\\n    //chek whether reach the target location\\n    public static boolean reachTarget(int a, int b) {\\n        return (a == t1 && b == t2) || (a == t2 && b == t1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494022,
                "title": "c-bfs-solution",
                "content": "```\\n    int minimumMoves(vector<vector<int>>& g) {\\n        set<vector<int>> v;\\n        queue<vector<int>> q;\\n        \\n        q.push({0, 0, 0, 1});\\n        v.insert({0, 0, 0, 1});\\n        \\n        int n = g.size();\\n        \\n        vector<int> target = {n-1, n-2, n-1, n-1};\\n        \\n        int step = 0;\\n        while(!q.empty()) {\\n            for(int sz = q.size(); sz > 0; sz--) {\\n                vector<int> t = q.front();\\n                q.pop();\\n                if(t == target) return step;\\n                \\n                if(t[0] == t[2]) {//==\\n                    if(t[3]+1 < n && g[t[2]][t[3]+1] == 0) {//right\\n                        vector<int> t1 = {t[2], t[3], t[2], t[3]+1};\\n                        if(!v.count(t1)) {v.insert(t1); q.push(t1);}\\n                    }\\n                    if(t[0]+1 < n && g[t[0]+1][t[1]] == 0 && g[t[2]+1][t[3]] == 0) {//clock\\n                        vector<int> t2 = {t[0], t[1], t[0]+1, t[1]};\\n                        if(!v.count(t2)) {v.insert(t2); q.push(t2);}\\n                    }\\n                    if(t[0]+1 < n && g[t[0]+1][t[1]] == 0 && g[t[0]+1][t[3]] == 0) {//down\\n                        vector<int> t3 = {t[0]+1, t[1], t[0]+1, t[3]};\\n                        if(!v.count(t3)) {v.insert(t3); q.push(t3);}\\n                    }                    \\n                } else {//||\\n                    if(t[2]+1 < n && g[t[2]+1][t[3]] == 0) {//down\\n                        vector<int> t4 = {t[2], t[3], t[2]+1, t[3]};\\n                        if(!v.count(t4)) {v.insert(t4); q.push(t4);}\\n                    }\\n                    if(t[1]+1 < n && g[t[0]][t[1]+1] == 0 && g[t[2]][t[3]+1] == 0) {//anti clock\\n                        vector<int> t5 = {t[0], t[1], t[0], t[1]+1};\\n                        if(!v.count(t5)) {v.insert(t5); q.push(t5);}\\n                    }\\n                    if(t[1]+1 < n && g[t[0]][t[1]+1] == 0 && g[t[2]][t[3]+1] == 0) {//right\\n                        vector<int> t6 = {t[0], t[1]+1, t[2], t[3]+1};\\n                        if(!v.count(t6)) {v.insert(t6); q.push(t6);}\\n                    }                         \\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumMoves(vector<vector<int>>& g) {\\n        set<vector<int>> v;\\n        queue<vector<int>> q;\\n        \\n        q.push({0, 0, 0, 1});\\n        v.insert({0, 0, 0, 1});\\n        \\n        int n = g.size();\\n        \\n        vector<int> target = {n-1, n-2, n-1, n-1};\\n        \\n        int step = 0;\\n        while(!q.empty()) {\\n            for(int sz = q.size(); sz > 0; sz--) {\\n                vector<int> t = q.front();\\n                q.pop();\\n                if(t == target) return step;\\n                \\n                if(t[0] == t[2]) {//==\\n                    if(t[3]+1 < n && g[t[2]][t[3]+1] == 0) {//right\\n                        vector<int> t1 = {t[2], t[3], t[2], t[3]+1};\\n                        if(!v.count(t1)) {v.insert(t1); q.push(t1);}\\n                    }\\n                    if(t[0]+1 < n && g[t[0]+1][t[1]] == 0 && g[t[2]+1][t[3]] == 0) {//clock\\n                        vector<int> t2 = {t[0], t[1], t[0]+1, t[1]};\\n                        if(!v.count(t2)) {v.insert(t2); q.push(t2);}\\n                    }\\n                    if(t[0]+1 < n && g[t[0]+1][t[1]] == 0 && g[t[0]+1][t[3]] == 0) {//down\\n                        vector<int> t3 = {t[0]+1, t[1], t[0]+1, t[3]};\\n                        if(!v.count(t3)) {v.insert(t3); q.push(t3);}\\n                    }                    \\n                } else {//||\\n                    if(t[2]+1 < n && g[t[2]+1][t[3]] == 0) {//down\\n                        vector<int> t4 = {t[2], t[3], t[2]+1, t[3]};\\n                        if(!v.count(t4)) {v.insert(t4); q.push(t4);}\\n                    }\\n                    if(t[1]+1 < n && g[t[0]][t[1]+1] == 0 && g[t[2]][t[3]+1] == 0) {//anti clock\\n                        vector<int> t5 = {t[0], t[1], t[0], t[1]+1};\\n                        if(!v.count(t5)) {v.insert(t5); q.push(t5);}\\n                    }\\n                    if(t[1]+1 < n && g[t[0]][t[1]+1] == 0 && g[t[2]][t[3]+1] == 0) {//right\\n                        vector<int> t6 = {t[0], t[1]+1, t[2], t[3]+1};\\n                        if(!v.count(t6)) {v.insert(t6); q.push(t6);}\\n                    }                         \\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493668,
                "title": "c-bfs-clear",
                "content": "```\\nclass Solution {\\n\\tstruct State {\\n\\t\\tint tailX, tailY, headX, headY, dist;\\n\\t\\tbool operator==(const State& other) const {\\n\\t\\t\\treturn tailX == other.tailX && headX == other.headX && tailY == other.tailY && headY == other.headY;\\n\\t\\t}\\n\\t};\\n\\tvector<vector<int>> moves = { {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1} };\\n\\tclass hashFunction {\\n\\t\\tpublic:\\n\\t\\t\\tsize_t operator()(const State& t) const {\\n\\t\\t\\t\\treturn t.tailX * t.tailY * t.headX * t.headY + t.tailX + t.tailY + t.headX + t.headY;\\n\\t\\t\\t}\\n\\t};\\npublic:\\n\\tint minimumMoves(vector<vector<int>>& grid) {\\n\\t\\tqueue<State> states;\\n\\t\\tunordered_set<State, hashFunction> visited;\\n\\t\\tState endState; int N = grid.size() - 1;\\n\\t\\tendState.tailX = N; endState.tailY = N - 1;\\n\\t\\tendState.headX = N; endState.headY = N;\\n\\t\\tstates.push({ 0,0,0,1,0 }); // (x1, y1, x2, y2, dist)\\n\\t\\tvisited.insert({ 0,0,0,1,0 });\\n\\t\\twhile (!states.empty()) {\\n\\t\\t\\tState curState = states.front(); states.pop();\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\n\\t\\t\\t\\tState newNeighbor;\\n\\t\\t\\t\\tnewNeighbor.tailX = moves[i][0] + curState.tailX;\\n\\t\\t\\t\\tnewNeighbor.tailY = moves[i][1] + curState.tailY;\\n\\t\\t\\t\\tnewNeighbor.headX = moves[i][2] + curState.headX;\\n\\t\\t\\t\\tnewNeighbor.headY = moves[i][3] + curState.headY;\\n\\t\\t\\t\\tnewNeighbor.dist = curState.dist + 1;\\n\\t\\t\\t\\tif (inside(newNeighbor, grid, i, N + 1) && !visited.count(newNeighbor)) {\\n\\t\\t\\t\\t\\tstates.push(newNeighbor);\\n\\t\\t\\t\\t\\tvisited.insert(newNeighbor);\\n\\t\\t\\t\\t\\tif (reachedFinish(newNeighbor, endState)) {\\n\\t\\t\\t\\t\\t\\treturn newNeighbor.dist;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tbool reachedFinish(State& curState, State& endState) {\\n\\t\\treturn (curState == endState);\\n\\t}\\n\\n\\tbool inside(State& curState, vector<vector<int>>& grid, int moveNumber, int N) {\\n\\t\\tif (curState.tailX < 0 || curState.tailX >= N || curState.headX < 0 || curState.headX >= N ||\\n\\t\\t\\tcurState.tailY < 0 || curState.tailY >= N || curState.headY < 0 || curState.headY >= N ||\\n\\t\\t\\tgrid[curState.tailX][curState.tailY] || grid[curState.headX][curState.headY]) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif (moveNumber == 2) { // Clockwise\\n\\t\\t\\tif (grid[curState.headX][curState.headY + 1] || curState.tailY != curState.headY) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (moveNumber == 3) { // Counter-Clockwise\\n\\t\\t\\tif (grid[curState.headX + 1][curState.headY] || curState.tailY == curState.headY) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tstruct State {\\n\\t\\tint tailX, tailY, headX, headY, dist;\\n\\t\\tbool operator==(const State& other) const {\\n\\t\\t\\treturn tailX == other.tailX && headX == other.headX && tailY == other.tailY && headY == other.headY;\\n\\t\\t}\\n\\t};\\n\\tvector<vector<int>> moves = { {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1} };\\n\\tclass hashFunction {\\n\\t\\tpublic:\\n\\t\\t\\tsize_t operator()(const State& t) const {\\n\\t\\t\\t\\treturn t.tailX * t.tailY * t.headX * t.headY + t.tailX + t.tailY + t.headX + t.headY;\\n\\t\\t\\t}\\n\\t};\\npublic:\\n\\tint minimumMoves(vector<vector<int>>& grid) {\\n\\t\\tqueue<State> states;\\n\\t\\tunordered_set<State, hashFunction> visited;\\n\\t\\tState endState; int N = grid.size() - 1;\\n\\t\\tendState.tailX = N; endState.tailY = N - 1;\\n\\t\\tendState.headX = N; endState.headY = N;\\n\\t\\tstates.push({ 0,0,0,1,0 }); // (x1, y1, x2, y2, dist)\\n\\t\\tvisited.insert({ 0,0,0,1,0 });\\n\\t\\twhile (!states.empty()) {\\n\\t\\t\\tState curState = states.front(); states.pop();\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\n\\t\\t\\t\\tState newNeighbor;\\n\\t\\t\\t\\tnewNeighbor.tailX = moves[i][0] + curState.tailX;\\n\\t\\t\\t\\tnewNeighbor.tailY = moves[i][1] + curState.tailY;\\n\\t\\t\\t\\tnewNeighbor.headX = moves[i][2] + curState.headX;\\n\\t\\t\\t\\tnewNeighbor.headY = moves[i][3] + curState.headY;\\n\\t\\t\\t\\tnewNeighbor.dist = curState.dist + 1;\\n\\t\\t\\t\\tif (inside(newNeighbor, grid, i, N + 1) && !visited.count(newNeighbor)) {\\n\\t\\t\\t\\t\\tstates.push(newNeighbor);\\n\\t\\t\\t\\t\\tvisited.insert(newNeighbor);\\n\\t\\t\\t\\t\\tif (reachedFinish(newNeighbor, endState)) {\\n\\t\\t\\t\\t\\t\\treturn newNeighbor.dist;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tbool reachedFinish(State& curState, State& endState) {\\n\\t\\treturn (curState == endState);\\n\\t}\\n\\n\\tbool inside(State& curState, vector<vector<int>>& grid, int moveNumber, int N) {\\n\\t\\tif (curState.tailX < 0 || curState.tailX >= N || curState.headX < 0 || curState.headX >= N ||\\n\\t\\t\\tcurState.tailY < 0 || curState.tailY >= N || curState.headY < 0 || curState.headY >= N ||\\n\\t\\t\\tgrid[curState.tailX][curState.tailY] || grid[curState.headX][curState.headY]) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif (moveNumber == 2) { // Clockwise\\n\\t\\t\\tif (grid[curState.headX][curState.headY + 1] || curState.tailY != curState.headY) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (moveNumber == 3) { // Counter-Clockwise\\n\\t\\t\\tif (grid[curState.headX + 1][curState.headY] || curState.tailY == curState.headY) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468805,
                "title": "",
                "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484355&idx=1&sn=cafe5324e58d0593db4a287cb43356d6&chksm=fa536815cd24e1037b186dd5982f462e7e6db162f0e0f0f84465ede4cc737d560c8f1ac6b065&token=1817182455&lang=zh_CN#rd",
                "solutionTags": [],
                "code": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484355&idx=1&sn=cafe5324e58d0593db4a287cb43356d6&chksm=fa536815cd24e1037b186dd5982f462e7e6db162f0e0f0f84465ede4cc737d560c8f1ac6b065&token=1817182455&lang=zh_CN#rd",
                "codeTag": "Unknown"
            },
            {
                "id": 468573,
                "title": "bfs-python",
                "content": "tried to clean it as much as possible, making it as readable as possible\\n\\n**1.first thing first, a bfs cause the shortest path length is garanteed by it**\\n\\npseudo code\\n```\\n        q = collections.deque([(source,0,0)])\\n        while(q):\\n            u,d,s = q.popleft()\\n            if (u,d)  == (target,0): return s\\n            for v,dv in neighbors(u):\\n                if (v,dv) not in vis:\\n                    vis.add((v,dv))\\n                    q.append((v, dv,s + 1))\\n        return -1\\n```\\n\\n**2. what to put in the queue**\\n\\t1. the head of the snake , the direction either 0 (facing right) or 1 (facing down)\\n\\t2. and the number of steps\\n\\t3. an element from the q looks like ```(i,j), direction, steps to get here```\\n\\na convenient hashmap\\n\\n```\\nh = {}\\n\\n# 0: lambda function to go right\\nh[0] = lambda x: (x[0],x[1] + 1)\\n\\n1: lambda function to go down\\nh[1] = lambda x: (x[0] + 1,x[1])\\n\\n2: lambda function to go left\\nh[2] = lambda x: (x[0],x[1] - 1)\\n\\n3: lambda function to go up\\nh[3] = lambda x: (x[0] - 1,x[1])\\n\\n4: lambda function to go diagonal down and right\\nh[4] = lambda x: (x[0] + 1,x[1] + 1)\\n\\n```\\n\\n**3. two last things**\\n1. either I rotate from direction 0 to 1 , or 1 to 0 (I need the diagonal to be within bounds and == 0)\\n2.  either I slide completely keeping the same position\\n\\n\\n\\n\\n```\\nh = {}\\nh[0] = lambda x: (x[0],x[1] + 1)\\nh[1] = lambda x: (x[0] + 1,x[1])\\nh[2] = lambda x: (x[0],x[1] - 1)\\nh[3] = lambda x: (x[0] - 1,x[1])\\nh[4] = lambda x: (x[0] + 1,x[1] + 1)\\n\\nclass Solution(object):\\n    def minimumMoves(self, grid):\\n        source,target = (0,1), (len(grid)-1, len(grid[0])-1)\\n        vis =  set([(source,0)])\\n\\t\\tq = collections.deque([(source,0,0)])\\n        while(q):\\n            u,d,s = q.popleft()\\n            if (u,d)  == (target,0): return s\\n            for v,dv in self.f(u, d, grid):\\n                if (v,dv) not in vis:\\n                    vis.add((v,dv))\\n                    q.append((v, dv,s + 1))\\n        return -1\\n    \\n    def f(self, u, d, grid):\\n        neighbors = []\\n        pu = h[(d+2) % 4](u)\\n        nd = 1 - d\\n        pb = h[4](pu)\\n        # rotation\\n        if self.inbounds(pb, grid): neighbors.append((h[nd](pu), nd))\\n        \\n        # move\\n        for m in [0,1]:\\n            if self.inbounds(h[m](pu), grid): neighbors.append((h[m](u), d))\\n                \\n        return [(v,dd) for v,dd in neighbors if self.inbounds(v,grid)]\\n    \\n    def inbounds(self, pun, grid):\\n        return 0 <= pun[0] < len(grid) and 0 <= pun[1] < len(grid[0]) and  grid[pun[0]][pun[1]] == 0\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n        q = collections.deque([(source,0,0)])\\n        while(q):\\n            u,d,s = q.popleft()\\n            if (u,d)  == (target,0): return s\\n            for v,dv in neighbors(u):\\n                if (v,dv) not in vis:\\n                    vis.add((v,dv))\\n                    q.append((v, dv,s + 1))\\n        return -1\\n```\n```(i,j), direction, steps to get here```\n```\\nh = {}\\n\\n# 0: lambda function to go right\\nh[0] = lambda x: (x[0],x[1] + 1)\\n\\n1: lambda function to go down\\nh[1] = lambda x: (x[0] + 1,x[1])\\n\\n2: lambda function to go left\\nh[2] = lambda x: (x[0],x[1] - 1)\\n\\n3: lambda function to go up\\nh[3] = lambda x: (x[0] - 1,x[1])\\n\\n4: lambda function to go diagonal down and right\\nh[4] = lambda x: (x[0] + 1,x[1] + 1)\\n\\n```\n```\\nh = {}\\nh[0] = lambda x: (x[0],x[1] + 1)\\nh[1] = lambda x: (x[0] + 1,x[1])\\nh[2] = lambda x: (x[0],x[1] - 1)\\nh[3] = lambda x: (x[0] - 1,x[1])\\nh[4] = lambda x: (x[0] + 1,x[1] + 1)\\n\\nclass Solution(object):\\n    def minimumMoves(self, grid):\\n        source,target = (0,1), (len(grid)-1, len(grid[0])-1)\\n        vis =  set([(source,0)])\\n\\t\\tq = collections.deque([(source,0,0)])\\n        while(q):\\n            u,d,s = q.popleft()\\n            if (u,d)  == (target,0): return s\\n            for v,dv in self.f(u, d, grid):\\n                if (v,dv) not in vis:\\n                    vis.add((v,dv))\\n                    q.append((v, dv,s + 1))\\n        return -1\\n    \\n    def f(self, u, d, grid):\\n        neighbors = []\\n        pu = h[(d+2) % 4](u)\\n        nd = 1 - d\\n        pb = h[4](pu)\\n        # rotation\\n        if self.inbounds(pb, grid): neighbors.append((h[nd](pu), nd))\\n        \\n        # move\\n        for m in [0,1]:\\n            if self.inbounds(h[m](pu), grid): neighbors.append((h[m](u), d))\\n                \\n        return [(v,dd) for v,dd in neighbors if self.inbounds(v,grid)]\\n    \\n    def inbounds(self, pun, grid):\\n        return 0 <= pun[0] < len(grid) and 0 <= pun[1] < len(grid[0]) and  grid[pun[0]][pun[1]] == 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 454862,
                "title": "readable-commented-functional-solution-bfs-100-memory",
                "content": "A little long, but very clear. We use (y,x) throughout as the position of the tail as the head position is variable due to rotation.\\n\\nWould be much more succinct if C# supported type aliases on ```ValueTuple<T1,T2>```\\n\\n```\\nenum Rotation { Vertical, Horizontal }\\npublic int MinimumMoves(int[][] grid)\\n{\\n\\tint n = grid.Length;\\n\\tint Get((int y, int x) coords) => grid[coords.y][coords.x];\\n\\n\\t//Whether a coordinate is valid for a snake move.\\n\\tbool IsValid((int y, int x) coord) => coord.x >= 0 && coord.x < n //(1) in bounds\\n\\t\\t\\t\\t\\t\\t\\t\\t   && coord.y >= 0 && coord.y < n\\n\\t\\t\\t\\t\\t\\t\\t\\t   && Get(coord) == 0; //(2) and zero\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t(int y, int x) MoveRight((int y, int x) c) => (c.y, c.x + 1);\\n\\t(int y, int x) MoveDown((int y, int x) c) => (c.y + 1, c.x);\\n\\t\\n\\t//Gets the second element of the snake\\n\\t(int y, int x) GetSecond(((int y, int x) coord, Rotation r) val) =>\\n\\t\\tval.r == Rotation.Horizontal ? MoveRight(val.coord) : MoveDown(val.coord);\\n\\n\\t//Returns both elements of a snake given a tail and a rotation\\n\\tIEnumerable<(int y, int x)> GetBoth(((int y, int x) coord, Rotation r) val) =>\\n\\t\\tnew[] { val.coord, GetSecond(val) };\\n\\n   //The coordinates which must be valid for a rotation to occur\\n   //NB: a rotation must allow the 3 squares to the bottom right of the tail\\n\\tIEnumerable<(int, int)> Rotations(((int y, int x) c, Rotation r) coord)\\n\\t\\t=> new[] { MoveRight(coord.c), MoveDown(coord.c), MoveRight(MoveDown(coord.c)) };\\n\\t\\n\\t((int, int), Rotation) Rotate(((int y, int x) c, Rotation r) coord)\\n\\t\\t=> (coord.c, coord.r == Rotation.Horizontal ? Rotation.Vertical : Rotation.Horizontal);\\n\\t\\n\\t//a snake must be horizontal, with the tail at the bottom right square\\n\\tbool IsCompleted(((int x, int y) coord, Rotation rotation) coord) => \\n\\t\\tcoord.rotation == Rotation.Horizontal &&\\n\\t\\tGetSecond(coord).y == n - 1 && GetSecond(coord).x == n - 1;\\n\\n   //Returns the next available positions\\n\\tIEnumerable<((int, int), Rotation)> GetNext(((int y, int x) c, Rotation r) pos)\\n\\t{\\n\\t\\tif (GetBoth(pos).Select(MoveRight).All(IsValid)) { yield return (MoveRight(pos.c), pos.r); }\\n\\t\\tif (GetBoth(pos).Select(MoveDown).All(IsValid)) { yield return (MoveDown(pos.c), pos.r); }\\n\\t\\tif (Rotations(pos).All(IsValid)) { yield return Rotate(pos); }\\n\\t}\\n\\n\\tvar initialPosition = ((0, 0), Rotation.Horizontal, 0); //No moves made\\n\\n\\tQueue<((int x, int y), Rotation rotation, int movesMade)> toCheck = new Queue<((int, int), Rotation, int)>(new[] { initialPosition });\\n\\n\\tint ToIndex(Rotation r) => r == Rotation.Horizontal ? 0 : 1;\\n\\t//score array: y, x, rotation\\n\\tvar scores = new int?[n, n, 2];\\n\\tint? GetReturn(((int, int) coord, Rotation r) v) => scores[v.coord.Item1, v.coord.Item2, ToIndex(v.r)];\\n\\tvoid SetReturn(((int, int) coord, Rotation r) v, int value) => scores[v.coord.Item1, v.coord.Item2, ToIndex(v.r)] = value;\\n\\n\\t//BFS using Queue\\n\\twhile (toCheck.Any())\\n\\t{\\n\\t\\tvar (coord, rotation, movesMade) = toCheck.Dequeue();\\n\\t\\tvar score = GetReturn((coord, rotation));\\n\\t\\tif (score != null && score <= movesMade) { continue; }\\n\\n\\t\\tif (IsCompleted((coord, rotation)))\\n\\t\\t{\\n\\t\\t\\treturn movesMade;\\n\\t\\t}\\n\\n\\t\\tSetReturn((coord, rotation), movesMade);\\n\\t\\tforeach (var (newCoord, newRot) in GetNext((coord, rotation)))\\n\\t\\t{\\n\\t\\t\\ttoCheck.Enqueue((newCoord, newRot, movesMade + 1));\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```ValueTuple<T1,T2>```\n```\\nenum Rotation { Vertical, Horizontal }\\npublic int MinimumMoves(int[][] grid)\\n{\\n\\tint n = grid.Length;\\n\\tint Get((int y, int x) coords) => grid[coords.y][coords.x];\\n\\n\\t//Whether a coordinate is valid for a snake move.\\n\\tbool IsValid((int y, int x) coord) => coord.x >= 0 && coord.x < n //(1) in bounds\\n\\t\\t\\t\\t\\t\\t\\t\\t   && coord.y >= 0 && coord.y < n\\n\\t\\t\\t\\t\\t\\t\\t\\t   && Get(coord) == 0; //(2) and zero\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t(int y, int x) MoveRight((int y, int x) c) => (c.y, c.x + 1);\\n\\t(int y, int x) MoveDown((int y, int x) c) => (c.y + 1, c.x);\\n\\t\\n\\t//Gets the second element of the snake\\n\\t(int y, int x) GetSecond(((int y, int x) coord, Rotation r) val) =>\\n\\t\\tval.r == Rotation.Horizontal ? MoveRight(val.coord) : MoveDown(val.coord);\\n\\n\\t//Returns both elements of a snake given a tail and a rotation\\n\\tIEnumerable<(int y, int x)> GetBoth(((int y, int x) coord, Rotation r) val) =>\\n\\t\\tnew[] { val.coord, GetSecond(val) };\\n\\n   //The coordinates which must be valid for a rotation to occur\\n   //NB: a rotation must allow the 3 squares to the bottom right of the tail\\n\\tIEnumerable<(int, int)> Rotations(((int y, int x) c, Rotation r) coord)\\n\\t\\t=> new[] { MoveRight(coord.c), MoveDown(coord.c), MoveRight(MoveDown(coord.c)) };\\n\\t\\n\\t((int, int), Rotation) Rotate(((int y, int x) c, Rotation r) coord)\\n\\t\\t=> (coord.c, coord.r == Rotation.Horizontal ? Rotation.Vertical : Rotation.Horizontal);\\n\\t\\n\\t//a snake must be horizontal, with the tail at the bottom right square\\n\\tbool IsCompleted(((int x, int y) coord, Rotation rotation) coord) => \\n\\t\\tcoord.rotation == Rotation.Horizontal &&\\n\\t\\tGetSecond(coord).y == n - 1 && GetSecond(coord).x == n - 1;\\n\\n   //Returns the next available positions\\n\\tIEnumerable<((int, int), Rotation)> GetNext(((int y, int x) c, Rotation r) pos)\\n\\t{\\n\\t\\tif (GetBoth(pos).Select(MoveRight).All(IsValid)) { yield return (MoveRight(pos.c), pos.r); }\\n\\t\\tif (GetBoth(pos).Select(MoveDown).All(IsValid)) { yield return (MoveDown(pos.c), pos.r); }\\n\\t\\tif (Rotations(pos).All(IsValid)) { yield return Rotate(pos); }\\n\\t}\\n\\n\\tvar initialPosition = ((0, 0), Rotation.Horizontal, 0); //No moves made\\n\\n\\tQueue<((int x, int y), Rotation rotation, int movesMade)> toCheck = new Queue<((int, int), Rotation, int)>(new[] { initialPosition });\\n\\n\\tint ToIndex(Rotation r) => r == Rotation.Horizontal ? 0 : 1;\\n\\t//score array: y, x, rotation\\n\\tvar scores = new int?[n, n, 2];\\n\\tint? GetReturn(((int, int) coord, Rotation r) v) => scores[v.coord.Item1, v.coord.Item2, ToIndex(v.r)];\\n\\tvoid SetReturn(((int, int) coord, Rotation r) v, int value) => scores[v.coord.Item1, v.coord.Item2, ToIndex(v.r)] = value;\\n\\n\\t//BFS using Queue\\n\\twhile (toCheck.Any())\\n\\t{\\n\\t\\tvar (coord, rotation, movesMade) = toCheck.Dequeue();\\n\\t\\tvar score = GetReturn((coord, rotation));\\n\\t\\tif (score != null && score <= movesMade) { continue; }\\n\\n\\t\\tif (IsCompleted((coord, rotation)))\\n\\t\\t{\\n\\t\\t\\treturn movesMade;\\n\\t\\t}\\n\\n\\t\\tSetReturn((coord, rotation), movesMade);\\n\\t\\tforeach (var (newCoord, newRot) in GetNext((coord, rotation)))\\n\\t\\t{\\n\\t\\t\\ttoCheck.Enqueue((newCoord, newRot, movesMade + 1));\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 435478,
                "title": "java-bfs",
                "content": "Idea is simple - keep tracking the head index and horizontal/vertical status and use BFS to find the mininum move. \\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int N = grid.length;\\n        int[] start = new int[]{0, 1, 1};\\n        Set<String> visited = new HashSet<>();\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.offerLast(start);\\n        visited.add(\"0,1,1\");\\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int[] curr = queue.pollFirst();\\n                // horizontal\\n                int hx = curr[0];\\n                int hy = curr[1];\\n                int ho = curr[2];\\n                if(ho == 1){\\n                    //move right\\n                    if(hy < N - 1 && grid[hx][hy + 1] == 0){\\n                        int[] next = new int[]{hx, hy + 1, 1};\\n                        if(next[0] == N - 1 && next[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next[0] + \",\" + next[1] + \",\" + next[2])){\\n                            queue.offerLast(next);    \\n                        }\\n                    }\\n                    if(hx < N - 1 && grid[hx + 1][hy] == 0 && grid[hx + 1][hy - 1] == 0){\\n                        //move down\\n                        int[] next1 = new int[]{hx + 1, hy, 1};\\n                        if(next1[0] == N - 1 && next1[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next1[0] + \",\" + next1[1] + \",\" + next1[2])){\\n                            queue.offerLast(next1);    \\n                        }\\n                        //rotate clockwise\\n                        int[] next2 = new int[]{hx + 1, hy - 1, 0};\\n                        if(visited.add(\"\" + next2[0] + \",\" + next2[1] + \",\" + next2[2])){\\n                            queue.offerLast(next2);    \\n                        }\\n                    }\\n                }else{\\n                    //move down\\n                    if(hx < N - 1 && grid[hx + 1][hy] == 0){\\n                        int[] next = new int[]{hx + 1, hy, 0};\\n                        if(visited.add(\"\" + next[0] + \",\" + next[1] + \",\" + next[2])){\\n                            queue.offerLast(next);    \\n                        }\\n                    }\\n                    if(hy < N - 1 && grid[hx][hy + 1] == 0 && grid[hx - 1][hy + 1] == 0){\\n                        //move right\\n                        int[] next1 = new int[]{hx, hy + 1, 0};\\n                        if(visited.add(\"\" + next1[0] + \",\" + next1[1] + \",\" + next1[2])){\\n                            queue.offerLast(next1);    \\n                        }\\n                        //rotate counter-clockwise\\n                        int[] next2 = new int[]{hx - 1, hy + 1, 1};\\n                        if(next2[0] == N - 1 && next2[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next2[0] + \",\" + next2[1] + \",\" + next2[2])){\\n                            queue.offerLast(next2);    \\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int N = grid.length;\\n        int[] start = new int[]{0, 1, 1};\\n        Set<String> visited = new HashSet<>();\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.offerLast(start);\\n        visited.add(\"0,1,1\");\\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int[] curr = queue.pollFirst();\\n                // horizontal\\n                int hx = curr[0];\\n                int hy = curr[1];\\n                int ho = curr[2];\\n                if(ho == 1){\\n                    //move right\\n                    if(hy < N - 1 && grid[hx][hy + 1] == 0){\\n                        int[] next = new int[]{hx, hy + 1, 1};\\n                        if(next[0] == N - 1 && next[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next[0] + \",\" + next[1] + \",\" + next[2])){\\n                            queue.offerLast(next);    \\n                        }\\n                    }\\n                    if(hx < N - 1 && grid[hx + 1][hy] == 0 && grid[hx + 1][hy - 1] == 0){\\n                        //move down\\n                        int[] next1 = new int[]{hx + 1, hy, 1};\\n                        if(next1[0] == N - 1 && next1[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next1[0] + \",\" + next1[1] + \",\" + next1[2])){\\n                            queue.offerLast(next1);    \\n                        }\\n                        //rotate clockwise\\n                        int[] next2 = new int[]{hx + 1, hy - 1, 0};\\n                        if(visited.add(\"\" + next2[0] + \",\" + next2[1] + \",\" + next2[2])){\\n                            queue.offerLast(next2);    \\n                        }\\n                    }\\n                }else{\\n                    //move down\\n                    if(hx < N - 1 && grid[hx + 1][hy] == 0){\\n                        int[] next = new int[]{hx + 1, hy, 0};\\n                        if(visited.add(\"\" + next[0] + \",\" + next[1] + \",\" + next[2])){\\n                            queue.offerLast(next);    \\n                        }\\n                    }\\n                    if(hy < N - 1 && grid[hx][hy + 1] == 0 && grid[hx - 1][hy + 1] == 0){\\n                        //move right\\n                        int[] next1 = new int[]{hx, hy + 1, 0};\\n                        if(visited.add(\"\" + next1[0] + \",\" + next1[1] + \",\" + next1[2])){\\n                            queue.offerLast(next1);    \\n                        }\\n                        //rotate counter-clockwise\\n                        int[] next2 = new int[]{hx - 1, hy + 1, 1};\\n                        if(next2[0] == N - 1 && next2[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next2[0] + \",\" + next2[1] + \",\" + next2[2])){\\n                            queue.offerLast(next2);    \\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430385,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, A: List[List[int]]) -> int:\\n        MX=float(\\'inf\\')\\n        R,C=len(A),len(A[0])\\n        dp1=[[MX for _ in range(C)] for _ in range(R)]#horizontal\\n        dp2=[[MX for _ in range(C)] for _ in range(R)]#vertical\\n        dp1[0][0]=0\\n        if A[1][0]==0 and A[1][1]==0:dp2[0][0]=dp1[0][0]+1\\n        for i in range(0,R):\\n            for j in range(0,C):\\n                if A[i][j]==1:continue\\n                # horizonally\\n                if j<C-1 and A[i][j+1]==0:\\n                    dp1[i][j]=min(dp1[i][j],dp1[i][j-1]+1,dp1[i-1][j]+1)\\n                    if i<R-1 and A[i+1][j+1]==0:\\n                        dp1[i][j]=min(dp1[i][j],dp2[i][j]+1)\\n                        if A[i+1][j]==0:dp2[i][j]=min(dp2[i][j],dp1[i][j]+1)\\n                # vertically\\n                if i<R-1 and A[i+1][j]==0:\\n                    dp2[i][j]=min(dp2[i][j],dp2[i][j-1]+1,dp2[i-1][j]+1)\\n                    if j<C-1 and A[i+1][j+1]==0:\\n                        dp2[i][j]=min(dp2[i][j],dp1[i][j]+1)\\n                        if A[i][j+1]==0:dp1[i][j]=min(dp1[i][j],dp2[i][j]+1)\\n        return dp1[R-1][C-2] if dp1[R-1][C-2]!=MX else -1\\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, A: List[List[int]]) -> int:\\n        MX=float(\\'inf\\')\\n        R,C=len(A),len(A[0])\\n        dp1=[[MX for _ in range(C)] for _ in range(R)]#horizontal\\n        dp2=[[MX for _ in range(C)] for _ in range(R)]#vertical\\n        dp1[0][0]=0\\n        if A[1][0]==0 and A[1][1]==0:dp2[0][0]=dp1[0][0]+1\\n        for i in range(0,R):\\n            for j in range(0,C):\\n                if A[i][j]==1:continue\\n                # horizonally\\n                if j<C-1 and A[i][j+1]==0:\\n                    dp1[i][j]=min(dp1[i][j],dp1[i][j-1]+1,dp1[i-1][j]+1)\\n                    if i<R-1 and A[i+1][j+1]==0:\\n                        dp1[i][j]=min(dp1[i][j],dp2[i][j]+1)\\n                        if A[i+1][j]==0:dp2[i][j]=min(dp2[i][j],dp1[i][j]+1)\\n                # vertically\\n                if i<R-1 and A[i+1][j]==0:\\n                    dp2[i][j]=min(dp2[i][j],dp2[i][j-1]+1,dp2[i-1][j]+1)\\n                    if j<C-1 and A[i+1][j+1]==0:\\n                        dp2[i][j]=min(dp2[i][j],dp1[i][j]+1)\\n                        if A[i][j+1]==0:dp1[i][j]=min(dp1[i][j],dp2[i][j]+1)\\n        return dp1[R-1][C-2] if dp1[R-1][C-2]!=MX else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422375,
                "title": "clarification-needed-for-a-test-case",
                "content": "Having trouble understanding my problem with this test case, it seems correct to me.\\n\\n```\\n[[0,0,0,0,0,0,0,0,0,1]\\n,[0,1,0,0,0,0,0,1,0,1]\\n,[1,0,0,1,0,0,1,0,1,0]\\n,[0,0,0,1,0,1,0,1,0,0]\\n,[0,0,0,0,1,0,0,0,0,1]\\n,[0,0,1,0,0,0,0,0,0,0]\\n,[1,0,0,1,0,0,0,0,0,0]\\n,[0,0,0,0,0,0,0,0,0,0]\\n,[0,0,0,0,0,0,0,0,0,0]\\n,[1,1,0,0,0,0,0,0,0,0]]\\n```\\n\\nMy program says the answer is 21, the test case lists it as -1.\\nWhat is wrong with the solution of\\n\\n```\\n[[0,a,b,0,0,0,0,0,0,1]\\n,[0,1,c,0,0,0,0,1,0,1]\\n,[1,0,d,1,0,0,1,0,1,0]\\n,[0,f,e,1,0,1,0,1,0,0]\\n,[0,g,0,0,1,0,0,0,0,1]\\n,[0,h,1,0,0,0,0,0,0,0]\\n,[1,i,0,1,0,0,0,0,0,0]\\n,[0,j,0,0,0,0,0,0,0,0]\\n,[0,k,l,m,n,o,p,q,r,0]\\n,[1,1,0,0,0,0,0,0,s,0]]\\n```\\n\\nwith rotations on b and i?",
                "solutionTags": [],
                "code": "```\\n[[0,0,0,0,0,0,0,0,0,1]\\n,[0,1,0,0,0,0,0,1,0,1]\\n,[1,0,0,1,0,0,1,0,1,0]\\n,[0,0,0,1,0,1,0,1,0,0]\\n,[0,0,0,0,1,0,0,0,0,1]\\n,[0,0,1,0,0,0,0,0,0,0]\\n,[1,0,0,1,0,0,0,0,0,0]\\n,[0,0,0,0,0,0,0,0,0,0]\\n,[0,0,0,0,0,0,0,0,0,0]\\n,[1,1,0,0,0,0,0,0,0,0]]\\n```\n```\\n[[0,a,b,0,0,0,0,0,0,1]\\n,[0,1,c,0,0,0,0,1,0,1]\\n,[1,0,d,1,0,0,1,0,1,0]\\n,[0,f,e,1,0,1,0,1,0,0]\\n,[0,g,0,0,1,0,0,0,0,1]\\n,[0,h,1,0,0,0,0,0,0,0]\\n,[1,i,0,1,0,0,0,0,0,0]\\n,[0,j,0,0,0,0,0,0,0,0]\\n,[0,k,l,m,n,o,p,q,r,0]\\n,[1,1,0,0,0,0,0,0,s,0]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410532,
                "title": "python-dp-solution-brief-explanation",
                "content": "Explanation:\\n\\n1) DPh[i][j]: number of steps it takes the snake to move from starting position {tail (0, 0), head (1,1)} to {tail (i-1, j-1), head (i-1, j)}, body being in horizontal direction.\\n\\n2) DPv[i][j]: number of steps it takes the snake to move from starting position {tail (0, 0), head (1,1)} to {tail (i-1, j-1), head (i, j-1)}, body being in vertical direction.\\n\\n3) The snake can only face right or down. So DPh and DPv covers all possible situations.\\n\\n4) Finding shortest path on map with obstacles using DP. When doing translational or rotational move, we need to make sure that the relevant cells are empty.\\n\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        DPh = [[float(\\'inf\\')] * (n+1) for _ in range(n+1)]\\n        DPv = [[float(\\'inf\\')] * (n+1) for _ in range(n+1)]\\n        DPh[1][1] = 0\\n        for i in range(1, n+1):\\n            for j in range(1, n+1):\\n                if grid[i-1][j-1] == 1: continue\\n                if j < n and grid[i-1][j] == 0: \\n                    DPh[i][j] = min(DPh[i][j], DPh[i][j-1]+1, DPh[i-1][j]+1)\\n                if i < n and grid[i][j-1] == 0:\\n                    DPv[i][j] = min(DPv[i][j], DPv[i][j-1]+1, DPv[i-1][j]+1)\\n                if DPh[i][j] + 1 < DPv[i][j] and i<n and grid[i][j-1] == 0 and grid[i][j] == 0:\\n                    DPv[i][j] = DPh[i][j] + 1\\n                if DPv[i][j] + 1 < DPh[i][j] and j<n and grid[i-1][j] == 0 and grid[i][j] == 0:\\n                    DPh[i][j] = DPv[i][j] + 1\\n        return  -1 if DPh[-1][-2] == float(\\'inf\\') else DPh[-1][-2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        DPh = [[float(\\'inf\\')] * (n+1) for _ in range(n+1)]\\n        DPv = [[float(\\'inf\\')] * (n+1) for _ in range(n+1)]\\n        DPh[1][1] = 0\\n        for i in range(1, n+1):\\n            for j in range(1, n+1):\\n                if grid[i-1][j-1] == 1: continue\\n                if j < n and grid[i-1][j] == 0: \\n                    DPh[i][j] = min(DPh[i][j], DPh[i][j-1]+1, DPh[i-1][j]+1)\\n                if i < n and grid[i][j-1] == 0:\\n                    DPv[i][j] = min(DPv[i][j], DPv[i][j-1]+1, DPv[i-1][j]+1)\\n                if DPh[i][j] + 1 < DPv[i][j] and i<n and grid[i][j-1] == 0 and grid[i][j] == 0:\\n                    DPv[i][j] = DPh[i][j] + 1\\n                if DPv[i][j] + 1 < DPh[i][j] and j<n and grid[i-1][j] == 0 and grid[i][j] == 0:\\n                    DPh[i][j] = DPv[i][j] + 1\\n        return  -1 if DPh[-1][-2] == float(\\'inf\\') else DPh[-1][-2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408339,
                "title": "easy-java",
                "content": "```\\nclass Solution {\\n    \\n    HashSet<String> seen;\\n    \\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;\\n        \\n        if(grid[n-1][n-1]==1||grid[n-1][n-2]==1)\\n            return -1;\\n        \\n        seen = new HashSet<>();   \\n        \\n        Queue<int[][]> q = new LinkedList<>();\\n        \\n        int[][] temp2 = new int[2][];\\n        temp2[0] = new int[]{0,0};\\n        temp2[1] = new int[]{0,1};\\n        seen.add(\"\"+0+0+0+1);\\n        \\n        q.add(temp2);\\n        int steps = 0;\\n     \\n        while(!q.isEmpty())\\n        {\\n            int s = q.size();\\n            \\n            for(int i=0;i<s;i++)\\n            {\\n                int[][] temp = q.poll();\\n                \\n                int[] body = temp[0];\\n                int[] head = temp[1];\\n                \\n                \\n                if(body[0]==n-1 && body[1]==n-2 && head[0]==n-1 && head[1]==n-1)\\n                    return steps;\\n            \\n                if(head[0]==body[0]+1)\\n                {\\n                    if(body[1]+1<n && grid[body[0]][body[1]+1]==0 && grid[body[0]+1][body[1]+1]==0)\\n                    {\\n                        if(!sen(body[0],body[1],body[0],body[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = body;\\n                        temp[1] = new int[]{body[0],body[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[0]+1<n && grid[head[0]+1][head[1]]==0)\\n                    {\\n                        if(!sen(head[0],head[1],head[0]+1,head[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = head;\\n                        temp[1] = new int[]{head[0]+1,head[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[1]+1<n && grid[head[0]][head[1]+1]==0 && grid[body[0]][body[1]+1]==0)     {\\n                        if(!sen(body[0],body[1]+1,head[0],head[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = new int[]{body[0],body[1]+1};\\n                        temp[1] = new int[]{head[0],head[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(body[0]+1<n && grid[body[0]+1][body[1]]==0 && grid[body[0]+1][body[1]+1]==0)\\n                    {\\n                        if(!sen(body[0],body[1],body[0]+1,body[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = body;\\n                        temp[1] = new int[]{body[0]+1,body[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[1]+1<n && grid[head[0]][head[1]+1]==0)\\n                    {\\n                        if(!sen(head[0],head[1],head[0],head[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = head;\\n                        temp[1] = new int[]{head[0],head[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[0]+1<n && grid[head[0]+1][head[1]]==0 && grid[body[0]+1][body[1]]==0)     {\\n                        if(!sen(body[0]+1,body[1],head[0]+1,head[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = new int[]{body[0]+1,body[1]};\\n                        temp[1] = new int[]{head[0]+1,head[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n         \\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    \\n    boolean sen(int a , int b , int c , int d)\\n    {\\n        String temp = \"\"+a+b+c+d;\\n        \\n        if(seen.contains(temp))\\n            return true;\\n        else\\n            seen.add(temp);\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    HashSet<String> seen;\\n    \\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;\\n        \\n        if(grid[n-1][n-1]==1||grid[n-1][n-2]==1)\\n            return -1;\\n        \\n        seen = new HashSet<>();   \\n        \\n        Queue<int[][]> q = new LinkedList<>();\\n        \\n        int[][] temp2 = new int[2][];\\n        temp2[0] = new int[]{0,0};\\n        temp2[1] = new int[]{0,1};\\n        seen.add(\"\"+0+0+0+1);\\n        \\n        q.add(temp2);\\n        int steps = 0;\\n     \\n        while(!q.isEmpty())\\n        {\\n            int s = q.size();\\n            \\n            for(int i=0;i<s;i++)\\n            {\\n                int[][] temp = q.poll();\\n                \\n                int[] body = temp[0];\\n                int[] head = temp[1];\\n                \\n                \\n                if(body[0]==n-1 && body[1]==n-2 && head[0]==n-1 && head[1]==n-1)\\n                    return steps;\\n            \\n                if(head[0]==body[0]+1)\\n                {\\n                    if(body[1]+1<n && grid[body[0]][body[1]+1]==0 && grid[body[0]+1][body[1]+1]==0)\\n                    {\\n                        if(!sen(body[0],body[1],body[0],body[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = body;\\n                        temp[1] = new int[]{body[0],body[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[0]+1<n && grid[head[0]+1][head[1]]==0)\\n                    {\\n                        if(!sen(head[0],head[1],head[0]+1,head[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = head;\\n                        temp[1] = new int[]{head[0]+1,head[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[1]+1<n && grid[head[0]][head[1]+1]==0 && grid[body[0]][body[1]+1]==0)     {\\n                        if(!sen(body[0],body[1]+1,head[0],head[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = new int[]{body[0],body[1]+1};\\n                        temp[1] = new int[]{head[0],head[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(body[0]+1<n && grid[body[0]+1][body[1]]==0 && grid[body[0]+1][body[1]+1]==0)\\n                    {\\n                        if(!sen(body[0],body[1],body[0]+1,body[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = body;\\n                        temp[1] = new int[]{body[0]+1,body[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[1]+1<n && grid[head[0]][head[1]+1]==0)\\n                    {\\n                        if(!sen(head[0],head[1],head[0],head[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = head;\\n                        temp[1] = new int[]{head[0],head[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[0]+1<n && grid[head[0]+1][head[1]]==0 && grid[body[0]+1][body[1]]==0)     {\\n                        if(!sen(body[0]+1,body[1],head[0]+1,head[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = new int[]{body[0]+1,body[1]};\\n                        temp[1] = new int[]{head[0]+1,head[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n         \\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    \\n    boolean sen(int a , int b , int c , int d)\\n    {\\n        String temp = \"\"+a+b+c+d;\\n        \\n        if(seen.contains(temp))\\n            return true;\\n        else\\n            seen.add(temp);\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396343,
                "title": "c-level-order-traversal",
                "content": "```\\n\\nclass MinimumMoves {\\npublic:\\n    MinimumMoves(vector<vector<int>>& grid) \\n        :   rows(grid.size()), \\n            cols(grid[0].size()), \\n            grid(grid),\\n            visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false))) { }\\n    \\n    int compute() {\\n        int depth = -1;\\n        queue<Location> qu;\\n        \\n        qu.push({0, 0, HORIZONTAL});\\n        visited[0][0][HORIZONTAL] = true;\\n        \\n        while (!qu.empty()) {\\n            int size = qu.size();\\n            \\n            ++depth;\\n            \\n            for (int i = 0; i < size; ++i) {\\n                auto from = qu.front();\\n                \\n                if (get<0>(from) == rows - 1 && get<1>(from) == cols - 2) {\\n                    return depth;\\n                }\\n                \\n                qu.pop();\\n\\n                // Go right\\n                scheduleMove(qu, from, RIGHT);\\n                \\n                 // Go down\\n                scheduleMove(qu, from, DOWN);\\n                \\n                // Rotate clockwise\\n                scheduleMove(qu, from, CLOCKWISE);\\n                \\n                // Rotate anti-clockwise\\n                scheduleMove(qu, from, ANTICLOCKWISE); \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\nprivate:\\n    enum Dir {\\n        HORIZONTAL = 0,\\n        VERTICAL\\n    };\\n    \\n    enum Move {\\n        RIGHT = 0,\\n        DOWN,\\n        CLOCKWISE,\\n        ANTICLOCKWISE\\n    };\\n    \\n    typedef tuple<int, int, Dir> Location;\\n    \\n    void scheduleMove(queue<tuple<int, int, Dir>>& qu, const Location& from, Move move) {\\n        auto [r, c, d] = from;\\n        \\n        switch (move) {\\n            case RIGHT:\\n                ++c;\\n                \\n                if (d == HORIZONTAL) {\\n                    if (c == cols - 1 || grid[r][c + 1] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                } else {\\n                    if (c == cols || grid[r][c] || grid[r + 1][c] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                }\\n                \\n                break;\\n                \\n            case DOWN:\\n                ++r;\\n                \\n                if (d == VERTICAL) { \\n                    if (r == rows - 1 || grid[r + 1][c] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                } else {\\n                    if (r == rows || grid[r][c] || grid[r][c + 1] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                }\\n                \\n                break;\\n                \\n            case CLOCKWISE:\\n                if (d == VERTICAL || r == rows - 1 || grid[r + 1][c] || grid[r + 1][c + 1] || visited[r][c][VERTICAL]) {\\n                    return;\\n                }\\n                \\n                d = VERTICAL;\\n                \\n                break;\\n                \\n            case ANTICLOCKWISE:\\n                if (d == HORIZONTAL || c == cols - 1 || grid[r][c + 1] || grid[r + 1][c + 1] || visited[r][c][HORIZONTAL]) {\\n                    return;\\n                }\\n                \\n                d = HORIZONTAL;\\n                \\n                break;    \\n        }\\n        \\n        visited[r][c][d] = true;\\n        qu.push({r, c, d});\\n    }\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>>& grid;\\n    vector<vector<vector<bool>>> visited;\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        MinimumMoves minimumMovesWrap(grid);\\n        \\n        return minimumMovesWrap.compute();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass MinimumMoves {\\npublic:\\n    MinimumMoves(vector<vector<int>>& grid) \\n        :   rows(grid.size()), \\n            cols(grid[0].size()), \\n            grid(grid),\\n            visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false))) { }\\n    \\n    int compute() {\\n        int depth = -1;\\n        queue<Location> qu;\\n        \\n        qu.push({0, 0, HORIZONTAL});\\n        visited[0][0][HORIZONTAL] = true;\\n        \\n        while (!qu.empty()) {\\n            int size = qu.size();\\n            \\n            ++depth;\\n            \\n            for (int i = 0; i < size; ++i) {\\n                auto from = qu.front();\\n                \\n                if (get<0>(from) == rows - 1 && get<1>(from) == cols - 2) {\\n                    return depth;\\n                }\\n                \\n                qu.pop();\\n\\n                // Go right\\n                scheduleMove(qu, from, RIGHT);\\n                \\n                 // Go down\\n                scheduleMove(qu, from, DOWN);\\n                \\n                // Rotate clockwise\\n                scheduleMove(qu, from, CLOCKWISE);\\n                \\n                // Rotate anti-clockwise\\n                scheduleMove(qu, from, ANTICLOCKWISE); \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\nprivate:\\n    enum Dir {\\n        HORIZONTAL = 0,\\n        VERTICAL\\n    };\\n    \\n    enum Move {\\n        RIGHT = 0,\\n        DOWN,\\n        CLOCKWISE,\\n        ANTICLOCKWISE\\n    };\\n    \\n    typedef tuple<int, int, Dir> Location;\\n    \\n    void scheduleMove(queue<tuple<int, int, Dir>>& qu, const Location& from, Move move) {\\n        auto [r, c, d] = from;\\n        \\n        switch (move) {\\n            case RIGHT:\\n                ++c;\\n                \\n                if (d == HORIZONTAL) {\\n                    if (c == cols - 1 || grid[r][c + 1] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                } else {\\n                    if (c == cols || grid[r][c] || grid[r + 1][c] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                }\\n                \\n                break;\\n                \\n            case DOWN:\\n                ++r;\\n                \\n                if (d == VERTICAL) { \\n                    if (r == rows - 1 || grid[r + 1][c] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                } else {\\n                    if (r == rows || grid[r][c] || grid[r][c + 1] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                }\\n                \\n                break;\\n                \\n            case CLOCKWISE:\\n                if (d == VERTICAL || r == rows - 1 || grid[r + 1][c] || grid[r + 1][c + 1] || visited[r][c][VERTICAL]) {\\n                    return;\\n                }\\n                \\n                d = VERTICAL;\\n                \\n                break;\\n                \\n            case ANTICLOCKWISE:\\n                if (d == HORIZONTAL || c == cols - 1 || grid[r][c + 1] || grid[r + 1][c + 1] || visited[r][c][HORIZONTAL]) {\\n                    return;\\n                }\\n                \\n                d = HORIZONTAL;\\n                \\n                break;    \\n        }\\n        \\n        visited[r][c][d] = true;\\n        qu.push({r, c, d});\\n    }\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>>& grid;\\n    vector<vector<vector<bool>>> visited;\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        MinimumMoves minimumMovesWrap(grid);\\n        \\n        return minimumMovesWrap.compute();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394435,
                "title": "c-bfs-easy-approach-but-time-limit-block-36-42-test-cases-passed",
                "content": "After I get the problem exactly, I changed my code like this. but still can\\'t pass all test cases. who can give some me some advice?  thanks a millions time.\\n```\\n public int MinimumMoves(int[][] grid) {\\n        int row = grid.Length;\\n        int col = grid[0].Length;\\n        var visited = new HashSet<Tuple<string, int>>();\\n        var station = new HashSet<Tuple<string, int>>();\\n        station.Add(new Tuple<string, int>(\"R\", 1));\\n        var dest = new Tuple<string, int>(\"R\", row * col - 1);\\n        int step = 0;\\n        while (station.Count > 0)\\n        {\\n            step += 1;\\n            var newstation = new HashSet<Tuple<string, int>>();\\n            foreach (var snake in station)\\n            {\\n                int head = snake.Item2;\\n                int r = head / row;\\n                int c = head % row;\\n                string dir = snake.Item1;\\n\\n                if (dir == \"R\")\\n                {\\n                    //right\\n                    if (c + 1 < col && grid[r][c + 1] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"R\", head + 1));\\n                    }\\n                  \\n                    //down clock\\n                    if (r + 1 < row)\\n                    {\\n                        if (grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0)\\n                        {\\n                            newstation.Add(new Tuple<string, int>(\"R\", head + col));\\n                            newstation.Add(new Tuple<string, int>(\"D\", head + col - 1));\\n                        }\\n                    }\\n                }              \\n                //down\\n                else\\n                {                   \\n                    //down\\n                    if (r + 1 < row && grid[r + 1][c] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"D\", head + col));\\n                    }\\n                    //right counterclock\\n                    if (c + 1 < col && grid[r][c + 1] == 0 && grid[r - 1][c + 1] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"D\", head + 1));\\n                        newstation.Add(new Tuple<string, int>(\"R\", head - col + 1));\\n                    }\\n                }\\n                if (newstation.Contains(dest)) return step;\\n                else {\\n                    visited.Add(snake);\\n                }\\n            }              \\n            station = newstation.Except(visited).ToHashSet();\\n        }\\n        return -1;            \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int MinimumMoves(int[][] grid) {\\n        int row = grid.Length;\\n        int col = grid[0].Length;\\n        var visited = new HashSet<Tuple<string, int>>();\\n        var station = new HashSet<Tuple<string, int>>();\\n        station.Add(new Tuple<string, int>(\"R\", 1));\\n        var dest = new Tuple<string, int>(\"R\", row * col - 1);\\n        int step = 0;\\n        while (station.Count > 0)\\n        {\\n            step += 1;\\n            var newstation = new HashSet<Tuple<string, int>>();\\n            foreach (var snake in station)\\n            {\\n                int head = snake.Item2;\\n                int r = head / row;\\n                int c = head % row;\\n                string dir = snake.Item1;\\n\\n                if (dir == \"R\")\\n                {\\n                    //right\\n                    if (c + 1 < col && grid[r][c + 1] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"R\", head + 1));\\n                    }\\n                  \\n                    //down clock\\n                    if (r + 1 < row)\\n                    {\\n                        if (grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0)\\n                        {\\n                            newstation.Add(new Tuple<string, int>(\"R\", head + col));\\n                            newstation.Add(new Tuple<string, int>(\"D\", head + col - 1));\\n                        }\\n                    }\\n                }              \\n                //down\\n                else\\n                {                   \\n                    //down\\n                    if (r + 1 < row && grid[r + 1][c] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"D\", head + col));\\n                    }\\n                    //right counterclock\\n                    if (c + 1 < col && grid[r][c + 1] == 0 && grid[r - 1][c + 1] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"D\", head + 1));\\n                        newstation.Add(new Tuple<string, int>(\"R\", head - col + 1));\\n                    }\\n                }\\n                if (newstation.Contains(dest)) return step;\\n                else {\\n                    visited.Add(snake);\\n                }\\n            }              \\n            station = newstation.Except(visited).ToHashSet();\\n        }\\n        return -1;            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 394194,
                "title": "my-crazy-bfs-javascript-solution-without-visited-map-set-100-ms",
                "content": "Modifying ```grid``` only in two cases: when rotating (prevent loop), in other cases we moving right or down (no need to do anything).\\n```\\nvar minimumMoves = function(grid) {\\n    var min = Number.MAX_VALUE;\\n    var finishRowHead = grid.length - 1;\\n    var finishColHead = finishRowHead;\\n    var finishRowBody = finishRowHead;\\n    var finishColBody = finishRowHead - 1;\\n    var lastIndex = finishRowHead;\\n    var stack = [{ rowHead: 0, colHead: 1, rowBody: 0, colBody: 0, step: 0 }];\\n    var rowHead, colHead, rowBody, colBody, step;\\n    var next;\\n    var pos;\\n    \\n    while (stack.length) {\\n        pos = stack.shift();\\n        rowHead = pos.rowHead;\\n        colHead = pos.colHead;\\n        rowBody = pos.rowBody;\\n        colBody = pos.colBody;\\n        step = pos.step;\\n        \\n        if (rowHead === finishRowHead && colHead === finishColHead && rowBody === finishRowBody && colBody === finishColBody) {\\n            min = step;\\n            break;\\n        }\\n        \\n        step++;\\n        if (rowHead === rowBody) { // horizontal\\n            if (colHead !== lastIndex && grid[rowHead][(next = colHead + 1)] === 0) {\\n                stack.push({ rowHead: rowHead, colHead: next, rowBody: rowBody, colBody: colHead, step: step }); // right\\n            }\\n            if (rowHead !== lastIndex && grid[(next = rowHead + 1)][colHead] === 0 && grid[next][colBody] === 0) {\\n                stack.push({ rowHead: next, colHead: colHead, rowBody: next, colBody: colBody, step: step }); // down\\n                grid[next][colBody] = 1;\\n                stack.push({ rowHead: next, colHead: colBody, rowBody: rowBody, colBody: colBody, step: step }); // rotate\\n            }\\n        } else { // vertical\\n            if (rowHead !== lastIndex && grid[(next = rowHead + 1)][colHead] === 0) {\\n                stack.push({ rowHead: next, colHead: colHead, rowBody: rowHead, colBody: colBody, step: step }); // down\\n            }\\n            if (colHead !== lastIndex && grid[rowHead][(next = colHead + 1)] === 0 && grid[rowBody][next] === 0) {\\n                stack.push({ rowHead: rowHead, colHead: next, rowBody: rowBody, colBody: next, step: step }); // right\\n                grid[rowBody][next] = 1;\\n                stack.push({ rowHead: rowBody, colHead: next, rowBody: rowBody, colBody: colBody, step: step }); // rotate\\n            }\\n        }\\n    };\\n    \\n    return min === Number.MAX_VALUE ? -1 : min;\\n};\\n```\\nTested using:\\n```\\n[[0,0,0,0,0,1],[1,1,0,0,1,0],[0,0,0,0,1,1],[0,0,1,0,1,0],[0,1,1,0,0,0],[0,1,1,0,0,0]]\\n[[0,0,1,1,1,1],[0,0,0,0,1,1],[1,1,0,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,0]]\\n[[0,0,1,1,1,1],[0,0,0,0,1,1],[1,1,0,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1]]\\n[[0,0,0,0,0,0,0,1,0,0,1,0,0,0,0],[1,0,0,0,0,1,0,0,0,0,0,0,1,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,1,0,1,0,0,0,0,1,0,0,1,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,1,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,1,0,0,1,0,1,0,0,0,1,0,1,1,0],[0,1,0,1,1,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,1,0,0,0,1,0,1,0,0],[0,0,0,0,0,1,0,0,1,0,0,1,0,0,0]]\\n[[0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0],[0,1,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0]]\\n```",
                "solutionTags": [],
                "code": "```grid```\n```\\nvar minimumMoves = function(grid) {\\n    var min = Number.MAX_VALUE;\\n    var finishRowHead = grid.length - 1;\\n    var finishColHead = finishRowHead;\\n    var finishRowBody = finishRowHead;\\n    var finishColBody = finishRowHead - 1;\\n    var lastIndex = finishRowHead;\\n    var stack = [{ rowHead: 0, colHead: 1, rowBody: 0, colBody: 0, step: 0 }];\\n    var rowHead, colHead, rowBody, colBody, step;\\n    var next;\\n    var pos;\\n    \\n    while (stack.length) {\\n        pos = stack.shift();\\n        rowHead = pos.rowHead;\\n        colHead = pos.colHead;\\n        rowBody = pos.rowBody;\\n        colBody = pos.colBody;\\n        step = pos.step;\\n        \\n        if (rowHead === finishRowHead && colHead === finishColHead && rowBody === finishRowBody && colBody === finishColBody) {\\n            min = step;\\n            break;\\n        }\\n        \\n        step++;\\n        if (rowHead === rowBody) { // horizontal\\n            if (colHead !== lastIndex && grid[rowHead][(next = colHead + 1)] === 0) {\\n                stack.push({ rowHead: rowHead, colHead: next, rowBody: rowBody, colBody: colHead, step: step }); // right\\n            }\\n            if (rowHead !== lastIndex && grid[(next = rowHead + 1)][colHead] === 0 && grid[next][colBody] === 0) {\\n                stack.push({ rowHead: next, colHead: colHead, rowBody: next, colBody: colBody, step: step }); // down\\n                grid[next][colBody] = 1;\\n                stack.push({ rowHead: next, colHead: colBody, rowBody: rowBody, colBody: colBody, step: step }); // rotate\\n            }\\n        } else { // vertical\\n            if (rowHead !== lastIndex && grid[(next = rowHead + 1)][colHead] === 0) {\\n                stack.push({ rowHead: next, colHead: colHead, rowBody: rowHead, colBody: colBody, step: step }); // down\\n            }\\n            if (colHead !== lastIndex && grid[rowHead][(next = colHead + 1)] === 0 && grid[rowBody][next] === 0) {\\n                stack.push({ rowHead: rowHead, colHead: next, rowBody: rowBody, colBody: next, step: step }); // right\\n                grid[rowBody][next] = 1;\\n                stack.push({ rowHead: rowBody, colHead: next, rowBody: rowBody, colBody: colBody, step: step }); // rotate\\n            }\\n        }\\n    };\\n    \\n    return min === Number.MAX_VALUE ? -1 : min;\\n};\\n```\n```\\n[[0,0,0,0,0,1],[1,1,0,0,1,0],[0,0,0,0,1,1],[0,0,1,0,1,0],[0,1,1,0,0,0],[0,1,1,0,0,0]]\\n[[0,0,1,1,1,1],[0,0,0,0,1,1],[1,1,0,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,0]]\\n[[0,0,1,1,1,1],[0,0,0,0,1,1],[1,1,0,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1]]\\n[[0,0,0,0,0,0,0,1,0,0,1,0,0,0,0],[1,0,0,0,0,1,0,0,0,0,0,0,1,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,1,0,1,0,0,0,0,1,0,0,1,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,1,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,1,0,0,1,0,1,0,0,0,1,0,1,1,0],[0,1,0,1,1,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,1,0,0,0,1,0,1,0,0],[0,0,0,0,0,1,0,0,1,0,0,1,0,0,0]]\\n[[0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0],[0,1,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 394148,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, grid: [[int]]) -> int:\\n\\n        h, w = len(grid), len(grid[0])\\n\\n        # (pos0, pos1, horizon/vertical, steps)\\n        q = {((0, 0), (0, 1), 0, 0)}\\n        seen = set()\\n        while q:\\n            qq = set()\\n            for pos0, pos1, condition, step in q:\\n                if (pos0, pos1) not in seen:\\n                    seen.add((pos0, pos1))\\n                    if pos0 == (h - 1, w - 2) and pos1 == (h - 1, w - 1):\\n                        return step\\n                    if condition:\\n                        if pos0[1] + 1 < w and pos1[1] + 1 < w and \\\\\\n                                grid[pos0[0]][pos0[1] + 1] == 0 and grid[pos1[0]][pos1[1] + 1] == 0:\\n                                qq.add(((pos0[0], pos0[1] + 1), (pos1[0], pos1[1] + 1), 1, step + 1))\\n                                qq.add(((pos0[0], pos0[1]), (pos0[0], pos0[1] + 1), 0, step + 1))\\n\\n                        if pos1[0] + 1 < h and grid[pos1[0] + 1][pos1[1]] == 0:\\n                            qq.add(((pos1[0], pos1[1]), (pos1[0] + 1, pos1[1]), 1, step + 1))\\n\\n                    else:\\n                        if pos0[0] + 1 < h and pos1[0] + 1 < h and \\\\\\n                                grid[pos0[0] + 1][pos0[1]] == 0 and grid[pos1[0] + 1][pos1[1]] == 0:\\n                                qq.add(((pos0[0] + 1, pos0[1]), (pos1[0] + 1, pos1[1]), 0, step + 1))\\n                                qq.add(((pos0[0], pos0[1]), (pos0[0] + 1, pos0[1]), 1, step + 1))\\n                        if pos1[1] + 1 < w and grid[pos1[0]][pos1[1] + 1] == 0:\\n                            qq.add(((pos1[0], pos1[1]), (pos1[0], pos1[1] + 1), 0, step + 1))\\n            q = qq\\n        return -1",
                "solutionTags": [],
                "code": "class Solution:\\n    def minimumMoves(self, grid: [[int]]) -> int:\\n\\n        h, w = len(grid), len(grid[0])\\n\\n        # (pos0, pos1, horizon/vertical, steps)\\n        q = {((0, 0), (0, 1), 0, 0)}",
                "codeTag": "Java"
            },
            {
                "id": 394100,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution(object):\\n\\tdef minimumMoves(self, grid):\\n\\t\\tstart=(0,0,0,1)\\n\\t\\tn=len(grid)\\n\\t\\tm=len(grid[0])\\n\\t\\tend=(n-1,m-2,n-1,m-1)\\n\\t\\treturn self.bfs(start,end,grid,n,m)\\n\\tdef bfs(self,start,end,grid,n,m):\\n\\t\\tcurr_lvl={start}\\n\\t\\tused={}\\n\\t\\tcnt=0\\n\\t\\twhile curr_lvl:\\n\\t\\t\\tnxt_lvl=set()\\n\\t\\t\\t# print(len(curr_lvl))\\n\\t\\t\\t# print(curr_lvl)\\n\\t\\t\\tfor i in curr_lvl:\\n\\t\\t\\t\\tif i == end:\\n\\t\\t\\t\\t\\treturn cnt\\n\\t\\t\\t\\tused[i]=1\\n\\t\\t\\t\\tr1,c1,r2,c2=i\\n\\t\\t\\t\\tif c2+1<m and grid[r2][c2+1]+grid[r1][c1+1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1+1,r2,c2+1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1+1,r2,c2+1))\\n\\t\\t\\t\\tif r2+1<n and grid[r2+1][c2]+grid[r1+1][c1]==0:\\n\\t\\t\\t\\t\\tif (r1+1,c1,r2+1,c2) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1+1,c1,r2+1,c2))\\n\\t\\t\\t\\tif r1==r2 and c1<c2 and c1+1<n and r1+1<m and grid[r1+1][c1+1]+grid[r1+1][c1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1,r1+1,c1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1,r1+1,c1))\\n\\t\\t\\t\\tif c1==c2 and r1<r2 and r1+1<n and c1+1<m and grid[r1][c1+1]+grid[r1+1][c1+1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1,r1,c1+1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1,r1,c1+1))\\n\\t\\t\\tcurr_lvl=nxt_lvl\\n\\t\\t\\tcnt+=1\\n\\t\\treturn -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n\\tdef minimumMoves(self, grid):\\n\\t\\tstart=(0,0,0,1)\\n\\t\\tn=len(grid)\\n\\t\\tm=len(grid[0])\\n\\t\\tend=(n-1,m-2,n-1,m-1)\\n\\t\\treturn self.bfs(start,end,grid,n,m)\\n\\tdef bfs(self,start,end,grid,n,m):\\n\\t\\tcurr_lvl={start}\\n\\t\\tused={}\\n\\t\\tcnt=0\\n\\t\\twhile curr_lvl:\\n\\t\\t\\tnxt_lvl=set()\\n\\t\\t\\t# print(len(curr_lvl))\\n\\t\\t\\t# print(curr_lvl)\\n\\t\\t\\tfor i in curr_lvl:\\n\\t\\t\\t\\tif i == end:\\n\\t\\t\\t\\t\\treturn cnt\\n\\t\\t\\t\\tused[i]=1\\n\\t\\t\\t\\tr1,c1,r2,c2=i\\n\\t\\t\\t\\tif c2+1<m and grid[r2][c2+1]+grid[r1][c1+1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1+1,r2,c2+1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1+1,r2,c2+1))\\n\\t\\t\\t\\tif r2+1<n and grid[r2+1][c2]+grid[r1+1][c1]==0:\\n\\t\\t\\t\\t\\tif (r1+1,c1,r2+1,c2) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1+1,c1,r2+1,c2))\\n\\t\\t\\t\\tif r1==r2 and c1<c2 and c1+1<n and r1+1<m and grid[r1+1][c1+1]+grid[r1+1][c1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1,r1+1,c1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1,r1+1,c1))\\n\\t\\t\\t\\tif c1==c2 and r1<r2 and r1+1<n and c1+1<m and grid[r1][c1+1]+grid[r1+1][c1+1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1,r1,c1+1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1,r1,c1+1))\\n\\t\\t\\tcurr_lvl=nxt_lvl\\n\\t\\t\\tcnt+=1\\n\\t\\treturn -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394059,
                "title": "o-n-n-with-just-a-extra-boolean-state-r-d",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        visited,queue = set(),collections.deque()\\n        queue.append((0,1,\"r\",0))\\n        visited.add((0,1,\"r\"))\\n        while len(queue) > 0:\\n            x,y,orientation,distance = queue.popleft()\\n            if x == n-1 and y == n-1 and orientation == \\'r\\':\\n                return distance\\n            if orientation == \\'r\\':\\n                if y + 1 < n and grid[x][y+1] == 0 and (x,y+1,\"r\") not in visited:\\n                    queue.append((x,y+1,\"r\",distance+1))\\n                    visited.add((x,y+1,\"r\"))\\n                if x + 1 < n and grid[x+1][y] == 0 and grid[x+1][y-1] == 0:\\n                    if (x+1,y-1,\"d\") not in visited:\\n                        queue.append((x+1,y-1,\"d\",distance+1))\\n                        visited.add((x+1,y-1,\"d\"))\\n                    if (x+1,y,\"r\") not in visited:\\n                        queue.append((x+1,y,\"r\",distance+1))\\n                        visited.add((x+1,y,\"r\"))\\n            if orientation == \\'d\\':\\n                if x + 1 < n and grid[x+1][y] == 0 and (x+1,y,\"d\") not in visited:\\n                    queue.append((x+1,y,\"d\",distance+1))\\n                    visited.add((x+1,y,\"d\"))\\n                if y + 1 < n and grid[x][y+1] == 0 and grid[x-1][y+1] == 0:\\n                    if (x-1,y+1,\"r\") not in visited:\\n                        queue.append((x-1,y+1,\"r\",distance+1))\\n                        visited.add((x-1,y+1,\"r\"))\\n                    if (x,y+1,\"d\") not in visited:\\n                        queue.append((x,y+1,\"d\",distance+1))\\n                        visited.add((x,y+1,\"d\"))\\n        return -1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        visited,queue = set(),collections.deque()\\n        queue.append((0,1,\"r\",0))\\n        visited.add((0,1,\"r\"))\\n        while len(queue) > 0:\\n            x,y,orientation,distance = queue.popleft()\\n            if x == n-1 and y == n-1 and orientation == \\'r\\':\\n                return distance\\n            if orientation == \\'r\\':\\n                if y + 1 < n and grid[x][y+1] == 0 and (x,y+1,\"r\") not in visited:\\n                    queue.append((x,y+1,\"r\",distance+1))\\n                    visited.add((x,y+1,\"r\"))\\n                if x + 1 < n and grid[x+1][y] == 0 and grid[x+1][y-1] == 0:\\n                    if (x+1,y-1,\"d\") not in visited:\\n                        queue.append((x+1,y-1,\"d\",distance+1))\\n                        visited.add((x+1,y-1,\"d\"))\\n                    if (x+1,y,\"r\") not in visited:\\n                        queue.append((x+1,y,\"r\",distance+1))\\n                        visited.add((x+1,y,\"r\"))\\n            if orientation == \\'d\\':\\n                if x + 1 < n and grid[x+1][y] == 0 and (x+1,y,\"d\") not in visited:\\n                    queue.append((x+1,y,\"d\",distance+1))\\n                    visited.add((x+1,y,\"d\"))\\n                if y + 1 < n and grid[x][y+1] == 0 and grid[x-1][y+1] == 0:\\n                    if (x-1,y+1,\"r\") not in visited:\\n                        queue.append((x-1,y+1,\"r\",distance+1))\\n                        visited.add((x-1,y+1,\"r\"))\\n                    if (x,y+1,\"d\") not in visited:\\n                        queue.append((x,y+1,\"d\",distance+1))\\n                        visited.add((x,y+1,\"d\"))\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 394000,
                "title": "bfs",
                "content": "```\\nimport queue\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        vis = [[0 for _ in range(2)] for _ in range(m*n)]\\n        qu = queue.Queue()\\n        \\n        vis[1][0] = 1\\n        qu.put((1,0))\\n        step = -1\\n        \\n        while not qu.empty():\\n            sz = qu.qsize()\\n            step += 1\\n            \\n            for i in range(sz):\\n                curr = qu.get()\\n                x = curr[0]//m\\n                y = curr[0]%n\\n                d = curr[1]\\n                \\n                if x == m-1 and y == n-1 and d == 0:\\n                    return step\\n                \\n                if d == 0:\\n                    if y < n-1 and grid[x][y+1] == 0: \\n                        if vis[x*n+y+1][0] == 0:\\n                            vis[x*n+y+1][0] = 1\\n                            qu.put((x*n+y+1,0))\\n                    if x < m-1 and grid[x+1][y-1] == 0 and grid[x+1][y] == 0: \\n                        if vis[(x+1)*n+y][0] == 0:\\n                            vis[(x+1)*n+y][0] = 1\\n                            qu.put(((x+1)*n+y,0))\\n                        if vis[(x+1)*n+y-1][1] == 0:\\n                            vis[(x+1)*n+y-1][1] = 1\\n                            qu.put(((x+1)*n+y-1,1))\\n                else:\\n                    if x < m-1 and grid[x+1][y] == 0: \\n                        if vis[(x+1)*n+y][1] == 0:\\n                            vis[(x+1)*n+y][1] = 1\\n                            qu.put(((x+1)*n+y,1))\\n                    if y < n-1 and grid[x-1][y+1] == 0 and grid[x][y+1] == 0: \\n                        if vis[x*n+y+1][1] == 0:\\n                            vis[x*n+y+1][1] = 1\\n                            qu.put((x*n+y+1,1))\\n                        if vis[(x-1)*n+y+1][0] == 0:\\n                            vis[(x-1)*n+y+1][0] = 1\\n                            qu.put(((x-1)*n+y+1,0))\\n        \\n        return -1               \\n```",
                "solutionTags": [],
                "code": "```\\nimport queue\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        vis = [[0 for _ in range(2)] for _ in range(m*n)]\\n        qu = queue.Queue()\\n        \\n        vis[1][0] = 1\\n        qu.put((1,0))\\n        step = -1\\n        \\n        while not qu.empty():\\n            sz = qu.qsize()\\n            step += 1\\n            \\n            for i in range(sz):\\n                curr = qu.get()\\n                x = curr[0]//m\\n                y = curr[0]%n\\n                d = curr[1]\\n                \\n                if x == m-1 and y == n-1 and d == 0:\\n                    return step\\n                \\n                if d == 0:\\n                    if y < n-1 and grid[x][y+1] == 0: \\n                        if vis[x*n+y+1][0] == 0:\\n                            vis[x*n+y+1][0] = 1\\n                            qu.put((x*n+y+1,0))\\n                    if x < m-1 and grid[x+1][y-1] == 0 and grid[x+1][y] == 0: \\n                        if vis[(x+1)*n+y][0] == 0:\\n                            vis[(x+1)*n+y][0] = 1\\n                            qu.put(((x+1)*n+y,0))\\n                        if vis[(x+1)*n+y-1][1] == 0:\\n                            vis[(x+1)*n+y-1][1] = 1\\n                            qu.put(((x+1)*n+y-1,1))\\n                else:\\n                    if x < m-1 and grid[x+1][y] == 0: \\n                        if vis[(x+1)*n+y][1] == 0:\\n                            vis[(x+1)*n+y][1] = 1\\n                            qu.put(((x+1)*n+y,1))\\n                    if y < n-1 and grid[x-1][y+1] == 0 and grid[x][y+1] == 0: \\n                        if vis[x*n+y+1][1] == 0:\\n                            vis[x*n+y+1][1] = 1\\n                            qu.put((x*n+y+1,1))\\n                        if vis[(x-1)*n+y+1][0] == 0:\\n                            vis[(x-1)*n+y+1][0] = 1\\n                            qu.put(((x-1)*n+y+1,0))\\n        \\n        return -1               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 393665,
                "title": "java-bfs-beats-100-with-explanation",
                "content": "It\\'s a typical BFS problem. The only trick here is trying to efficiently model the problem.\\n1. Unlike the classic BFS problem, we have both the snake tail and head (2 cells instead of 1 cell) for each step to consider. Here we use the tail and direction to indicate every possible position the snake can be placed on the board.\\n2. How to efficiently validate each step? no matter move right, down, clockwise, counter clockwise. we can validate the postion with a general rule.\\n\\ta. Neither tail nor head of the snake should not be out of boundary.\\n\\tb. Neither tail nor head of the snake should not on the grid with value 1.\\n\\tc. Dedupe the generation of the same cell. For each cell, we should only traverse it with \\'H\\' and \\'V\\' move at most once 1 respectively.\\n\\td. For the clockwise/counter-clockwise case specifically, we need to verify additional two cells.\\n\\t\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, res = 0;\\n        Queue<Snake> q = new ArrayDeque<>();\\n        int[][] seen = new int[n][n];\\n        // Tail has been pos (i,j), the horizontal/vertical direcitional traversed has been represented as 1 & 2 respectively\\n        seen[0][0] = 1; \\n        q.offer(new Snake(\\'H\\', 0, 0));\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            System.out.println(size);\\n            for(int i = 0; i < size; i++) {\\n                Snake s = q.poll();\\n                if (s.dir == \\'H\\' && s.r == n -1 && s.c == n -2) return res;\\n                Snake down = move(grid, seen, new Snake(s.dir, s.r + 1, s.c), \\'D\\');\\n                Snake right = move(grid, seen, new Snake(s.dir, s.r, s.c + 1), \\'R\\');\\n                char dir = (s.dir == \\'H\\' ? \\'V\\' : \\'H\\');\\n                Snake clock = move(grid, seen, new Snake(dir,s.r,s.c), \\'C\\');\\n                if (right != null) q.offer(right);\\n                if (down != null) q.offer(down);\\n                if (clock != null) q.offer(clock);\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    Snake move(int[][] grid, int[][] seen, Snake s, char action) {\\n        int r0 = s.r, c0 = s.c, n = grid.length, r1 = r0, c1 = c0;\\n        char dir= s.dir;\\n        if (r0 >= n || c0 >= n || grid[r0][c0] == 1 || seen[r0][c0] == 3 || (seen[r0][c0] == 1 && dir == \\'H\\') || (seen[r0][c0] == 2 && dir == \\'V\\')) return null;\\n        if (dir == \\'H\\') {\\n            c1 = c0 + 1;\\n            r1 = r0;\\n        } else if (dir == \\'V\\') {\\n            c1 = c0;\\n            r1 = r0 + 1;\\n        }\\n        if (r1 >= n || c1 >= n || grid[r1][c1] == 1) return null;\\n        if (action == \\'C\\' && (grid[r0 + 1][c0+1] == 1 || grid[r0 + 1][c0] == 1 && grid[r0][c0+1] == 1)) return null;\\n        seen[r0][c0] += dir == \\'H\\' ? 1 : 2;\\n        return s;\\n    }\\n    \\n    class Snake {\\n        char dir; // \\'H\\' or \\'V\\'\\n        int r; // tail row\\n        int c; //tail column\\n        public Snake(char dir, int r, int c) {\\n            this.dir = dir;\\n            this.r = r;\\n            this.c = c;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, res = 0;\\n        Queue<Snake> q = new ArrayDeque<>();\\n        int[][] seen = new int[n][n];\\n        // Tail has been pos (i,j), the horizontal/vertical direcitional traversed has been represented as 1 & 2 respectively\\n        seen[0][0] = 1; \\n        q.offer(new Snake(\\'H\\', 0, 0));\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            System.out.println(size);\\n            for(int i = 0; i < size; i++) {\\n                Snake s = q.poll();\\n                if (s.dir == \\'H\\' && s.r == n -1 && s.c == n -2) return res;\\n                Snake down = move(grid, seen, new Snake(s.dir, s.r + 1, s.c), \\'D\\');\\n                Snake right = move(grid, seen, new Snake(s.dir, s.r, s.c + 1), \\'R\\');\\n                char dir = (s.dir == \\'H\\' ? \\'V\\' : \\'H\\');\\n                Snake clock = move(grid, seen, new Snake(dir,s.r,s.c), \\'C\\');\\n                if (right != null) q.offer(right);\\n                if (down != null) q.offer(down);\\n                if (clock != null) q.offer(clock);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 393631,
                "title": "java-solution-using-bfs-beats-100-space-and-time-complexity",
                "content": "\"\"\"\\nclass Solution {\\n    class vis\\n    {\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        public vis(int a,int b,int c,int d)\\n        {\\n            r1=a;\\n            c1=b;\\n            r2=c;\\n            c2=d;\\n        }\\n    }\\n    class pair{\\n        int x;\\n        int y;\\n        int z;\\n        int w;\\n        int h;\\n        int dis;\\n        public pair(int a,int b,int c,int d,int e,int f)\\n        {\\n            x=a;\\n            y=b;\\n            z=c;\\n            w=d;\\n            h=e;\\n            dis=f;\\n        }\\n    }\\n    public int minimumMoves(int[][] grid) {\\n        int n=grid.length;\\n        Queue<pair> q=new LinkedList<pair>();\\n        boolean vis[][][][]=new boolean[n][n][n][n];\\n        q.add(new pair(0,0,0,1,1,0));\\n        int h11[]={0,1,1};\\n        int h22[]={1,-1,0};\\n        int vx[]={1,-1,0};\\n        int vy[]={0,1,1};\\n        vis[0][0][0][1]=true;\\n        while(q.size()>0)\\n        {\\n            pair p=q.poll();\\n            int tx=p.x;\\n            int ty=p.y;\\n            int hx=p.z;\\n            int hy=p.w;\\n            int o=p.h;\\n            if(tx==n-1&&ty==n-2&&hx==n-1&&hy==n-1)\\n                return p.dis;\\n            if(o==1)\\n            {\\n                for(int k=0;k<=2;k++)\\n                {\\n                    int h1=hx+h11[k];\\n                    int h2=hy+h22[k];\\n                    int t1=tx;\\n                    int t2=ty;\\n                    if(k==0)\\n                    {\\n                        t1=hx;\\n                        t2=hy;\\n                    }\\n                    if(k==2)\\n                    {\\n                        t1=t1+1;\\n                    }\\n                    if(valid(h1,h2,t1,t2,n)==1&&vis[t1][t2][h1][h2]==false)\\n                    {     vis[t1][t2][h1][h2]=true;\\n                        if(k==0&&grid[h1][h2]==0)\\n                        {      \\n                          q.add(new pair(t1,t2,h1,h2,1,p.dis+1));\\n                        }\\n                        else if(k==1&&grid[h1][h2]==0&&grid[h1][h2+1]==0)\\n                        {\\n                            \\n                          q.add(new pair(t1,t2,h1,h2,0,p.dis+1));\\n                        }\\n                        else if(k==2&&grid[h1][h2]==0&&grid[t1][t2]==0)\\n                        {\\n                              \\n                          q.add(new pair(t1,t2,h1,h2,o,p.dis+1));\\n                        }\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(int k=0;k<=2;k++)\\n                {\\n                    int h1=hx+vx[k];\\n                    int h2=hy+vy[k];\\n                    int t1=tx;\\n                    int t2=ty;\\n                    if(k==0)\\n                    {\\n                        t1=t1+1;\\n                    }\\n                    if(k==2)\\n                    {\\n                        t2=t2+1;\\n                    }\\n                    \\n                    if(valid(h1,h2,t1,t2,n)==1&&vis[t1][t2][h1][h2]==false)\\n                    {   vis[t1][t2][h1][h2]=true;\\n                        if(k==0&&grid[h1][h2]==0)\\n                        {\\n                         \\n                        q.add(new pair(t1,t2,h1,h2,0,p.dis+1));\\n                        }\\n                        else if(k==1&&grid[h1][h2]==0&&grid[h1+1][h2]==0)\\n                        {\\n                             \\n                        q.add(new pair(t1,t2,h1,h2,k,p.dis+1));\\n                        }\\n                        else if(k==2&&grid[h1][h2]==0&&grid[t1][t2]==0)\\n                        {\\n                            \\n                        q.add(new pair(t1,t2,h1,h2,0,p.dis+1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    public int valid(int a,int b,int c,int d,int n)\\n    {\\n        if(a>=0&&a<n&&b>=0&&b<n)\\n            return 1;\\n        return 0;\\n    }\\n}\\n\"\"\"",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    class vis\\n    {\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        public vis(int a,int b,int c,int d)\\n        {\\n            r1=a;\\n            c1=b;\\n            r2=c;\\n            c2=d;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 393529,
                "title": "python-heap-solution",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        if not grid:\\n            return -1\\n        \\n        n = len(grid)\\n        \\n        heap = []\\n        heapq.heappush(heap,(0,(0,0,0,1)))\\n        \\n        seen = set()\\n        seen.add((0,0,0,1))\\n        \\n        while heap:\\n            \\n            d,pos = heapq.heappop(heap)\\n            r1,c1,r2,c2 = pos\\n            \\n            \\n            if (r1,c1) == (n-1,n-2) and (r2,c2) == (n-1,n-1):\\n                \\n                return d\\n            \\n            for dx,dy,dxx,dyy in {(1,0,1,0),(0,1,0,1)}:\\n                \\n                loc1xx = r1 + dx\\n                loc1yy = c1 + dy\\n                \\n                loc2xx = r2 + dxx\\n                loc2yy = c2 + dyy\\n                \\n                if loc1xx<n and loc2xx <n and loc1yy <n and loc2yy<n and grid[loc1xx][loc1yy] ==0 and grid[loc2xx][loc2yy]==0 and (loc1xx,loc1yy,loc2xx,loc2yy) not in seen:\\n                    \\n                    heapq.heappush(heap,(d+1,(loc1xx,loc1yy,loc2xx,loc2yy)))\\n                    seen.add((loc1xx,loc1yy,loc2xx,loc2yy))\\n                    \\n            if r1 == r2 and r1 + 1 < n and c1 + 1 < n and grid[r1+1][c1+1] == 0 and grid[r1+1][c1] == 0:\\n                if (r1,c1,r1+1,c1) not in seen:\\n                    heapq.heappush(heap,(d+1,(r1,c1,r1+1,c1)))\\n                    seen.add((r1,c1,r1+1,c1))\\n                    \\n            if c1 == c2 and c1 +1 < n and r1 + 1 < n and grid[r1+1][c1+1] == 0 and grid[r1][c1+1] == 0:\\n                if (r1,c1,r1,c1+1) not in seen:\\n                    heapq.heappush(heap,(d+1,(r1,c1,r1,c1+1)))\\n                    seen.add((r1,c1,r1,c1+1))\\n                    \\n            \\n        return -1\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        if not grid:\\n            return -1\\n        \\n        n = len(grid)\\n        \\n        heap = []\\n        heapq.heappush(heap,(0,(0,0,0,1)))\\n        \\n        seen = set()\\n        seen.add((0,0,0,1))\\n        \\n        while heap:\\n            \\n            d,pos = heapq.heappop(heap)\\n            r1,c1,r2,c2 = pos\\n            \\n            \\n            if (r1,c1) == (n-1,n-2) and (r2,c2) == (n-1,n-1):\\n                \\n                return d\\n            \\n            for dx,dy,dxx,dyy in {(1,0,1,0),(0,1,0,1)}:\\n                \\n                loc1xx = r1 + dx\\n                loc1yy = c1 + dy\\n                \\n                loc2xx = r2 + dxx\\n                loc2yy = c2 + dyy\\n                \\n                if loc1xx<n and loc2xx <n and loc1yy <n and loc2yy<n and grid[loc1xx][loc1yy] ==0 and grid[loc2xx][loc2yy]==0 and (loc1xx,loc1yy,loc2xx,loc2yy) not in seen:\\n                    \\n                    heapq.heappush(heap,(d+1,(loc1xx,loc1yy,loc2xx,loc2yy)))\\n                    seen.add((loc1xx,loc1yy,loc2xx,loc2yy))\\n                    \\n            if r1 == r2 and r1 + 1 < n and c1 + 1 < n and grid[r1+1][c1+1] == 0 and grid[r1+1][c1] == 0:\\n                if (r1,c1,r1+1,c1) not in seen:\\n                    heapq.heappush(heap,(d+1,(r1,c1,r1+1,c1)))\\n                    seen.add((r1,c1,r1+1,c1))\\n                    \\n            if c1 == c2 and c1 +1 < n and r1 + 1 < n and grid[r1+1][c1+1] == 0 and grid[r1][c1+1] == 0:\\n                if (r1,c1,r1,c1+1) not in seen:\\n                    heapq.heappush(heap,(d+1,(r1,c1,r1,c1+1)))\\n                    seen.add((r1,c1,r1,c1+1))\\n                    \\n            \\n        return -1\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 393463,
                "title": "java-bfs",
                "content": "There is still a potential error, which cause that it cannot pass some edge cases.\\n\\nCan someone help me find it out? I thought I considered all the cases.\\n\\nPlus.... this problem is so stupid and waste 99% time on writing code rather than logic on algorithm or mindstorm.\\n\\n```\\nclass Solution {\\n    int[][] grid;\\n    public int minimumMoves(int[][] grid) {\\n        this.grid = grid;\\n        HashSet<String> visited = new HashSet<>();\\n        int[] tail = new int[]{0,0};\\n        int[] head = new int[]{0,1};\\n        Queue<int[][]> q = new LinkedList<>();\\n        q.offer(t2f(tail, head));\\n        visited.add(pos2s(tail, head));\\n        int step = -1, n = grid.length;\\n        while (q.size()!=0){\\n            step++;\\n            int size = q.size();\\n            for (int ord=0; ord<size; ord++){\\n                int[][] cur4 = q.poll();\\n                tail = cur4[0];\\n                head = cur4[1];\\n                if (tail[0]==n-1 && tail[1]==n-2 && head[0]==n-1 && head[1]==n-1) return step;\\n                int[] tail2, head2;\\n                //right\\n                tail2 = new int[]{tail[0], tail[1]+1};\\n                head2 = new int[]{head[0], head[1]+1};\\n                if (!visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //down\\n                tail2 = new int[]{tail[0]+1, tail[1]};\\n                head2 = new int[]{head[0]+1, head[1]};\\n                if (!visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //clock\\n                tail2 = new int[]{tail[0], tail[1]};\\n                head2 = clocking(tail, head);\\n                if (head2[0]!=-1 && !visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //unclock\\n                tail2 = new int[]{tail[0], tail[1]};\\n                head2 = unclocking(tail, head);\\n                if (head2[0]!=-1 && !visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int[][] t2f(int[] tail, int[] head){\\n        int[][] ret = new int[2][2];\\n        ret[0] = tail;\\n        ret[1] = head;\\n        return ret;\\n    }\\n    \\n    int[] clocking(int[] tail, int[] head){\\n        if (tail[0]!=head[0]){\\n            if (tail[0]>head[0] && validPos1(new int[]{tail[0]-1, tail[1]+1})) \\n                return new int[]{tail[0], tail[1]+1};\\n            else if (tail[0]<head[0] && validPos1(new int[]{tail[0]+1, tail[1]-1})) \\n                return new int[]{tail[0], tail[1]-1};\\n            else return new int[]{-1,-1};\\n        }else{\\n            if (tail[1]>head[1] && validPos1(new int[]{tail[0]-1, tail[1]-1})) \\n                return new int[]{tail[0]-1, tail[1]};\\n            else if (tail[1]<head[1] && validPos1(new int[]{tail[0]+1, tail[1]+1}))\\n                return new int[]{tail[0]+1, tail[1]};\\n            else return new int[]{-1,-1};\\n        }\\n    }\\n    \\n     int[] unclocking(int[] tail, int[] head){\\n        if (tail[0]!=head[0]){\\n            if (tail[0]>head[0] && validPos1(new int[]{tail[0]-1, tail[1]-1})) \\n                return new int[]{tail[0], tail[1]-1};\\n            else if (tail[0]<head[0] && validPos1(new int[]{tail[0]+1, tail[1]+1})) \\n                return new int[]{tail[0], tail[1]+1};\\n            else return new int[]{-1,-1};\\n        }else{\\n            if (tail[1]>head[1] && validPos1(new int[]{tail[0]+1, tail[1]-1})) \\n                return new int[]{tail[0]+1, tail[1]};\\n            else if (tail[1]<head[1] && validPos1(new int[]{tail[0]-1, tail[1]+1}))\\n                return new int[]{tail[0]-1, tail[1]};\\n            else return new int[]{-1,-1};\\n        }\\n    }\\n    \\n    boolean validPos1(int[] tail){\\n        int n = grid.length;\\n        if (tail[0]<0 || tail[0]>=n || tail[1]<0 || tail[1]>=n) return false;\\n        if (grid[tail[0]][tail[1]] == 1) return false;\\n        return true;\\n    }\\n    \\n    boolean validPos(int[] tail, int[] head){\\n        int n = grid.length;\\n        if (tail[0]<0 || tail[0]>=n || tail[1]<0 || tail[1]>=n) return false;\\n        if (head[0]<0 || head[0]>=n || head[1]<0 || head[1]>=n) return false;\\n        if (grid[tail[0]][tail[1]] == 1) return false;\\n        if (grid[head[0]][head[1]] == 1) return false;\\n        return true;\\n    }\\n    \\n    String pos2s(int[] tail, int[] head){\\n        String s = tail[0]+\",\"+tail[1]+\",\"+head[0]+\",\"+head[1];\\n        return s;\\n    }\\n    \\n    int[] s2pos(String s){\\n        String[] ss = s.split(\",\");\\n        int[] ret = new int[4];\\n        for (int i=0; i<4; i++){\\n            ret[i] = Integer.parseInt(ss[i]);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] grid;\\n    public int minimumMoves(int[][] grid) {\\n        this.grid = grid;\\n        HashSet<String> visited = new HashSet<>();\\n        int[] tail = new int[]{0,0};\\n        int[] head = new int[]{0,1};\\n        Queue<int[][]> q = new LinkedList<>();\\n        q.offer(t2f(tail, head));\\n        visited.add(pos2s(tail, head));\\n        int step = -1, n = grid.length;\\n        while (q.size()!=0){\\n            step++;\\n            int size = q.size();\\n            for (int ord=0; ord<size; ord++){\\n                int[][] cur4 = q.poll();\\n                tail = cur4[0];\\n                head = cur4[1];\\n                if (tail[0]==n-1 && tail[1]==n-2 && head[0]==n-1 && head[1]==n-1) return step;\\n                int[] tail2, head2;\\n                //right\\n                tail2 = new int[]{tail[0], tail[1]+1};\\n                head2 = new int[]{head[0], head[1]+1};\\n                if (!visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //down\\n                tail2 = new int[]{tail[0]+1, tail[1]};\\n                head2 = new int[]{head[0]+1, head[1]};\\n                if (!visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //clock\\n                tail2 = new int[]{tail[0], tail[1]};\\n                head2 = clocking(tail, head);\\n                if (head2[0]!=-1 && !visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //unclock\\n                tail2 = new int[]{tail[0], tail[1]};\\n                head2 = unclocking(tail, head);\\n                if (head2[0]!=-1 && !visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int[][] t2f(int[] tail, int[] head){\\n        int[][] ret = new int[2][2];\\n        ret[0] = tail;\\n        ret[1] = head;\\n        return ret;\\n    }\\n    \\n    int[] clocking(int[] tail, int[] head){\\n        if (tail[0]!=head[0]){\\n            if (tail[0]>head[0] && validPos1(new int[]{tail[0]-1, tail[1]+1})) \\n                return new int[]{tail[0], tail[1]+1};\\n            else if (tail[0]<head[0] && validPos1(new int[]{tail[0]+1, tail[1]-1})) \\n                return new int[]{tail[0], tail[1]-1};\\n            else return new int[]{-1,-1};\\n        }else{\\n            if (tail[1]>head[1] && validPos1(new int[]{tail[0]-1, tail[1]-1})) \\n                return new int[]{tail[0]-1, tail[1]};\\n            else if (tail[1]<head[1] && validPos1(new int[]{tail[0]+1, tail[1]+1}))\\n                return new int[]{tail[0]+1, tail[1]};\\n            else return new int[]{-1,-1};\\n        }\\n    }\\n    \\n     int[] unclocking(int[] tail, int[] head){\\n        if (tail[0]!=head[0]){\\n            if (tail[0]>head[0] && validPos1(new int[]{tail[0]-1, tail[1]-1})) \\n                return new int[]{tail[0], tail[1]-1};\\n            else if (tail[0]<head[0] && validPos1(new int[]{tail[0]+1, tail[1]+1})) \\n                return new int[]{tail[0], tail[1]+1};\\n            else return new int[]{-1,-1};\\n        }else{\\n            if (tail[1]>head[1] && validPos1(new int[]{tail[0]+1, tail[1]-1})) \\n                return new int[]{tail[0]+1, tail[1]};\\n            else if (tail[1]<head[1] && validPos1(new int[]{tail[0]-1, tail[1]+1}))\\n                return new int[]{tail[0]-1, tail[1]};\\n            else return new int[]{-1,-1};\\n        }\\n    }\\n    \\n    boolean validPos1(int[] tail){\\n        int n = grid.length;\\n        if (tail[0]<0 || tail[0]>=n || tail[1]<0 || tail[1]>=n) return false;\\n        if (grid[tail[0]][tail[1]] == 1) return false;\\n        return true;\\n    }\\n    \\n    boolean validPos(int[] tail, int[] head){\\n        int n = grid.length;\\n        if (tail[0]<0 || tail[0]>=n || tail[1]<0 || tail[1]>=n) return false;\\n        if (head[0]<0 || head[0]>=n || head[1]<0 || head[1]>=n) return false;\\n        if (grid[tail[0]][tail[1]] == 1) return false;\\n        if (grid[head[0]][head[1]] == 1) return false;\\n        return true;\\n    }\\n    \\n    String pos2s(int[] tail, int[] head){\\n        String s = tail[0]+\",\"+tail[1]+\",\"+head[0]+\",\"+head[1];\\n        return s;\\n    }\\n    \\n    int[] s2pos(String s){\\n        String[] ss = s.split(\",\");\\n        int[] ret = new int[4];\\n        for (int i=0; i<4; i++){\\n            ret[i] = Integer.parseInt(ss[i]);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393411,
                "title": "50ms-c-bfs",
                "content": "```\\nint minimumMoves1(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n        visited.insert(1);\\n        vector<vector<int>> dirs={{0,1,0,1},{1,0,1,0},{0,0,1,-1},{0,0,-1,1}};// rigth,down,rclockwise,counterclock            \\n        int steps=0;\\n        while(!q.empty()){\\n            steps++;\\n            for(int i =q.size();i>0;i--){\\n                auto pp=q.front();q.pop();\\n                int r0=(pp>>24)&0xff, c0=(pp>>16)&0xff,r1=(pp>>8)&0xff,c1=pp&0xff;\\n                for(int d=0;d<4;d++){\\n                    int nr0=r0+dirs[d][0], nc0=c0+dirs[d][1],nr1=r1+dirs[d][2],nc1=c1+dirs[d][3];\\n                    if(r0==r1&&nr0<0||nr1<0||nc0<0||nc1<0||nr0>=n||nr1>=n||nc0>=n||nc1>=n||grid[nr0][nc0]||grid[nr1][nc1])continue;\\n                    if((d==2&&r0!=r1)||(d==3&&c0!=c1))continue;\\n                    if((d==3||d==2)&&r0+1<n&&c0+1<n&&grid[r0+1][c0+1]) continue;\\n                    int t=(nr0<<24)+(nc0<<16)+(nr1<<8)+nc1;\\n                    if(visited.count(t))continue;\\n                    if(nr0==n-1&&nc0==n-2&&nr1==n-1&&nc1==n-1) return steps;\\n                    visited.insert(t);\\n                    q.push(t);\\n                }\\n                \\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumMoves1(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n        visited.insert(1);\\n        vector<vector<int>> dirs={{0,1,0,1},{1,0,1,0},{0,0,1,-1},{0,0,-1,1}};// rigth,down,rclockwise,counterclock            \\n        int steps=0;\\n        while(!q.empty()){\\n            steps++;\\n            for(int i =q.size();i>0;i--){\\n                auto pp=q.front();q.pop();\\n                int r0=(pp>>24)&0xff, c0=(pp>>16)&0xff,r1=(pp>>8)&0xff,c1=pp&0xff;\\n                for(int d=0;d<4;d++){\\n                    int nr0=r0+dirs[d][0], nc0=c0+dirs[d][1],nr1=r1+dirs[d][2],nc1=c1+dirs[d][3];\\n                    if(r0==r1&&nr0<0||nr1<0||nc0<0||nc1<0||nr0>=n||nr1>=n||nc0>=n||nc1>=n||grid[nr0][nc0]||grid[nr1][nc1])continue;\\n                    if((d==2&&r0!=r1)||(d==3&&c0!=c1))continue;\\n                    if((d==3||d==2)&&r0+1<n&&c0+1<n&&grid[r0+1][c0+1]) continue;\\n                    int t=(nr0<<24)+(nc0<<16)+(nr1<<8)+nc1;\\n                    if(visited.count(t))continue;\\n                    if(nr0==n-1&&nc0==n-2&&nr1==n-1&&nc1==n-1) return steps;\\n                    visited.insert(t);\\n                    q.push(t);\\n                }\\n                \\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 393398,
                "title": "why-does-this-have-no-solution",
                "content": "Hi guys, \\nI wonder if I misundestood the problem or not, but for this input\\n[[0,0,0,0,0,0,0,0,0,1],\\n        [0,1,0,0,0,0,0,1,0,1],\\n        [1,0,0,1,0,0,1,0,1,0],\\n        [0,0,0,1,0,1,0,1,0,0],\\n        [0,0,0,0,1,0,0,0,0,1],\\n        [0,0,1,0,0,0,0,0,0,0],\\n        [1,0,0,1,0,0,0,0,0,0],\\n        [0,0,0,0,0,0,0,0,0,0],\\n        [0,0,0,0,0,0,0,0,0,0],\\n        [1,1,0,0,0,0,0,0,0,0]]\\nI wonder why there is no solution, my solution is 21, which is\\nright,right,rotate clockwise,down\\ndown,down,left,down,down\\ndown,down,rotate counterclockwise,right, right\\nright,right,right,right,down,\\ndown.\\n\\nthe path look like this\\n       [[X,X,X,X,0,0,0,0,0,1],\\n        [0,1,X,0,0,0,0,1,0,1],\\n        [1,X,X,1,0,0,1,0,1,0],\\n        [0,X,X,1,0,1,0,1,0,0],\\n        [0,X,0,0,1,0,0,0,0,1],\\n        [0,X,1,0,0,0,0,0,0,0],\\n        [1,X,0,1,0,0,0,0,0,0],\\n        [0,X,X,X,X,X,X,X,X,X],\\n        [0,X,0,0,0,0,0,0,X,X],\\n        [1,1,0,0,0,0,0,0,X,X]]\\nI would really appreciate if someone can help me clear this up. Thank you very much.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 393394,
                "title": "c-why-my-bfsis-inefficient",
                "content": "it\\'s standard BFS operation with visited map to memorize walked path.\\nBut I have no idea why it\\'s only beat 25% or less, not sure what\\'s the bottle neck in my algo.\\nAnyone can help with that?\\n```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& g) {\\n        queue<vector<int>> myq;\\n        myq.push({0,0,0,1});\\n        int res = 0, g_size = g.size()-1;\\n        map<vector<int>,int> visited;\\n        vector<int> end1,end2;\\n        end1.push_back(g_size);end1.push_back(g_size);end1.push_back(g_size);end1.push_back(g_size-1);\\n        end2.push_back(g_size);end2.push_back(g_size-1);end2.push_back(g_size);end2.push_back(g_size);\\n        while(!myq.empty()){\\n            int size = myq.size();\\n            for(int i = 0 ; i < size ; i++){\\n                auto it = myq.front(); myq.pop();\\n                if((it == end1) || (it == end2))\\n                    return res;\\n                int x1p1 = it[0]+1,y1p1 = it[1]+1,x2p1 = it[2]+1, y2p1 = it[3]+1;\\n\\t\\t\\t\\t//check if we can move right\\n                if((y1p1 <= g_size) && (y2p1 <= g_size) && (g[it[0]][y1p1] == 0) && (g[it[2]][y2p1] == 0) && (visited[{it[0],y1p1,it[2],y2p1}] == 0)){\\n                    myq.push({it[0],y1p1,it[2],y2p1});\\n                    visited[{it[0],y1p1,it[2],y2p1}] = 1;\\n                    // check if we can rotate counter-clockwise\\n                    if(it[1] == it[3]){\\n                        myq.push({it[0],it[1],it[2]-1,y2p1});\\n                        visited[{it[0],it[1],it[2]-1,y2p1}] = 1;\\n                    }\\n                }\\n                // check if we can move down\\n                if((x1p1 <= g_size) && (x2p1 <= g_size) && (g[x1p1][it[1]] == 0) && (g[x2p1][it[3]] == 0) && (visited[{x1p1,it[1],x2p1,it[3]}] == 0)){\\n                    myq.push({x1p1,it[1],x2p1,it[3]});\\n                    visited[{x1p1,it[1],x2p1,it[3]}] = 1;\\n                    \\n                    // check if we can rotate clockwise\\n                    if(it[0] == it[2]){\\n                        myq.push({it[0],it[1],x2p1,it[3]-1});\\n                        visited[{it[0],it[1],x2p1,it[3]-1}] = 1;\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& g) {\\n        queue<vector<int>> myq;\\n        myq.push({0,0,0,1});\\n        int res = 0, g_size = g.size()-1;\\n        map<vector<int>,int> visited;\\n        vector<int> end1,end2;\\n        end1.push_back(g_size);end1.push_back(g_size);end1.push_back(g_size);end1.push_back(g_size-1);\\n        end2.push_back(g_size);end2.push_back(g_size-1);end2.push_back(g_size);end2.push_back(g_size);\\n        while(!myq.empty()){\\n            int size = myq.size();\\n            for(int i = 0 ; i < size ; i++){\\n                auto it = myq.front(); myq.pop();\\n                if((it == end1) || (it == end2))\\n                    return res;\\n                int x1p1 = it[0]+1,y1p1 = it[1]+1,x2p1 = it[2]+1, y2p1 = it[3]+1;\\n\\t\\t\\t\\t//check if we can move right\\n                if((y1p1 <= g_size) && (y2p1 <= g_size) && (g[it[0]][y1p1] == 0) && (g[it[2]][y2p1] == 0) && (visited[{it[0],y1p1,it[2],y2p1}] == 0)){\\n                    myq.push({it[0],y1p1,it[2],y2p1});\\n                    visited[{it[0],y1p1,it[2],y2p1}] = 1;\\n                    // check if we can rotate counter-clockwise\\n                    if(it[1] == it[3]){\\n                        myq.push({it[0],it[1],it[2]-1,y2p1});\\n                        visited[{it[0],it[1],it[2]-1,y2p1}] = 1;\\n                    }\\n                }\\n                // check if we can move down\\n                if((x1p1 <= g_size) && (x2p1 <= g_size) && (g[x1p1][it[1]] == 0) && (g[x2p1][it[3]] == 0) && (visited[{x1p1,it[1],x2p1,it[3]}] == 0)){\\n                    myq.push({x1p1,it[1],x2p1,it[3]});\\n                    visited[{x1p1,it[1],x2p1,it[3]}] = 1;\\n                    \\n                    // check if we can rotate clockwise\\n                    if(it[0] == it[2]){\\n                        myq.push({it[0],it[1],x2p1,it[3]-1});\\n                        visited[{it[0],it[1],x2p1,it[3]-1}] = 1;\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393378,
                "title": "java-bfs-no-fancy-tricks",
                "content": "```\\nclass Solution {\\n    class Snake {\\n        int tailX, tailY;\\n        boolean hor;\\n        Snake(int x1, int y1, boolean flag){\\n            this.tailX = x1;\\n            this.tailY = y1;\\n            this.hor = flag;\\n        }\\n        public boolean equals(Snake s){\\n            if(this.tailX == s.tailX && this.tailY == s.tailY && this.hor == s.hor) return true;\\n            else return false;\\n        }\\n    } \\n    boolean canRotate(Snake s, int[][] grid){\\n        if(s.hor){\\n            if(s.tailX + 1 < grid.length && grid[s.tailX+1][s.tailY] == 0 && grid[s.tailX+1][s.tailY+1] == 0) return true;\\n            else return false;\\n        }else{\\n            if(s.tailY + 1 < grid[0].length && grid[s.tailX][s.tailY+1] == 0 && grid[s.tailX+1][s.tailY+1] == 0) return true;\\n            else return false;\\n        }\\n    }\\n    Snake rotate(Snake s){\\n        Snake res = new Snake(s.tailX, s.tailY, !s.hor);\\n        return res;\\n    }\\n    boolean canGoRight(Snake s, int[][] grid){\\n        if(s.hor){\\n            if(s.tailY+2 < grid[0].length && grid[s.tailX][s.tailY+2] == 0) return true;\\n            else return false; \\n        }else{\\n            if(s.tailY +1 < grid[0].length && grid[s.tailX][s.tailY+1] == 0 && grid[s.tailX+1][s.tailY+1] == 0) return true;\\n            else return false;\\n        }\\n    }\\n    Snake goRight(Snake s){\\n        Snake res = new Snake(s.tailX, s.tailY+1, s.hor);\\n        return res; \\n    }\\n    boolean canGoDown(Snake s, int[][] grid){\\n        if(s.hor){\\n            if(s.tailX <  grid.length -1 && grid[s.tailX + 1][s.tailY] == 0 && grid[s.tailX + 1][s.tailY+1] == 0) return true;\\n            else return false; \\n        }else{\\n            if(s.tailX <  grid.length -2 && grid[s.tailX + 2][s.tailY] == 0) return true;\\n            else return false; \\n        }  \\n    }\\n    Snake goDown(Snake s){\\n        Snake res = new Snake(s.tailX + 1, s.tailY, s.hor);\\n        return res; \\n    }\\n        \\n    \\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        Snake start = new Snake(0,0,true);\\n        Snake target = new Snake(n-1, m-2, true);\\n        Queue<Snake> q = new LinkedList();\\n        Set<String> set = new HashSet();\\n        q.offer(start);\\n        int step = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                Snake cur = q.poll();\\n                if(cur.equals(target)) return step;\\n                if(canRotate(cur, grid)){\\n                    Snake nextStep = rotate(cur);\\n                    String next = \"\"+nextStep.tailX + nextStep.tailY + Boolean.toString(nextStep.hor);\\n                    if(set.add(next)) q.offer(nextStep);\\n                }\\n                if(canGoRight(cur, grid)) {\\n                    Snake nextStep = goRight(cur);\\n                    String next = \"\"+nextStep.tailX + nextStep.tailY + Boolean.toString(nextStep.hor);\\n                    if(set.add(next)) q.offer(nextStep);\\n                }\\n                if(canGoDown(cur, grid)){\\n                    Snake nextStep = goDown(cur);\\n                    String next = \"\"+nextStep.tailX + nextStep.tailY + Boolean.toString(nextStep.hor);\\n                    if(set.add(next)) q.offer(nextStep);\\n                } \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Snake {\\n        int tailX, tailY;\\n        boolean hor;\\n        Snake(int x1, int y1, boolean flag){\\n            this.tailX = x1;\\n            this.tailY = y1;\\n            this.hor = flag;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569639,
                "content": [
                    {
                        "username": "dev1988",
                        "content": "The first two moves are as follows:\\n*  Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/**vertical** position of the snake as it is.\\n* Move down one cell if there are no blocked cells there. This move keeps the **horizontal**/vertical position of the snake as it is.\\n\\nCan someone help to explain how a vertical movement is possible while going right without a down+counterclockwise move?\\nSimilarly how is second move possible?"
                    },
                    {
                        "username": "Shark-Chili",
                        "content": "The first testcase:\\n`[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]`\\n\\nAnd here is the definition of `right` and `down`\\n`right`: Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n`down`: Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n\\nSo how how can it make `right` after `rotate clockwise` (the step 3 -> step 4)?  From what I understood, the head of the snake was vertically facing downside when finished the step 3?"
                    },
                    {
                        "username": "COSMIC_GAN_356_X_M_IPG_V5",
                        "content": "why is it 11\\n[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]\\n instead of 10?\\n[right, right, rotate clockwise, right, down, down, down, down, right right]\\n\\nAt first I thought it was because the snake can only move in the direction its facing but if we can move\\n[... rotate counterclockwise, right, down] then thats not the case.\\n \\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    },
                    {
                        "username": "samzhu333",
                        "content": "We can make it by [right, right, rotate clockwise, right, down, down, down, down, right right], it will take only 10 steps instead of 11 steps"
                    },
                    {
                        "username": "Karilli",
                        "content": "I got stuck on this for half an hour... :((("
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    }
                ]
            },
            {
                "id": 1573052,
                "content": [
                    {
                        "username": "dev1988",
                        "content": "The first two moves are as follows:\\n*  Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/**vertical** position of the snake as it is.\\n* Move down one cell if there are no blocked cells there. This move keeps the **horizontal**/vertical position of the snake as it is.\\n\\nCan someone help to explain how a vertical movement is possible while going right without a down+counterclockwise move?\\nSimilarly how is second move possible?"
                    },
                    {
                        "username": "Shark-Chili",
                        "content": "The first testcase:\\n`[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]`\\n\\nAnd here is the definition of `right` and `down`\\n`right`: Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n`down`: Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n\\nSo how how can it make `right` after `rotate clockwise` (the step 3 -> step 4)?  From what I understood, the head of the snake was vertically facing downside when finished the step 3?"
                    },
                    {
                        "username": "COSMIC_GAN_356_X_M_IPG_V5",
                        "content": "why is it 11\\n[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]\\n instead of 10?\\n[right, right, rotate clockwise, right, down, down, down, down, right right]\\n\\nAt first I thought it was because the snake can only move in the direction its facing but if we can move\\n[... rotate counterclockwise, right, down] then thats not the case.\\n \\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    },
                    {
                        "username": "samzhu333",
                        "content": "We can make it by [right, right, rotate clockwise, right, down, down, down, down, right right], it will take only 10 steps instead of 11 steps"
                    },
                    {
                        "username": "Karilli",
                        "content": "I got stuck on this for half an hour... :((("
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    }
                ]
            },
            {
                "id": 1569640,
                "content": [
                    {
                        "username": "dev1988",
                        "content": "The first two moves are as follows:\\n*  Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/**vertical** position of the snake as it is.\\n* Move down one cell if there are no blocked cells there. This move keeps the **horizontal**/vertical position of the snake as it is.\\n\\nCan someone help to explain how a vertical movement is possible while going right without a down+counterclockwise move?\\nSimilarly how is second move possible?"
                    },
                    {
                        "username": "Shark-Chili",
                        "content": "The first testcase:\\n`[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]`\\n\\nAnd here is the definition of `right` and `down`\\n`right`: Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n`down`: Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n\\nSo how how can it make `right` after `rotate clockwise` (the step 3 -> step 4)?  From what I understood, the head of the snake was vertically facing downside when finished the step 3?"
                    },
                    {
                        "username": "COSMIC_GAN_356_X_M_IPG_V5",
                        "content": "why is it 11\\n[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]\\n instead of 10?\\n[right, right, rotate clockwise, right, down, down, down, down, right right]\\n\\nAt first I thought it was because the snake can only move in the direction its facing but if we can move\\n[... rotate counterclockwise, right, down] then thats not the case.\\n \\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    },
                    {
                        "username": "samzhu333",
                        "content": "We can make it by [right, right, rotate clockwise, right, down, down, down, down, right right], it will take only 10 steps instead of 11 steps"
                    },
                    {
                        "username": "Karilli",
                        "content": "I got stuck on this for half an hour... :((("
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    }
                ]
            },
            {
                "id": 1573051,
                "content": [
                    {
                        "username": "dev1988",
                        "content": "The first two moves are as follows:\\n*  Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/**vertical** position of the snake as it is.\\n* Move down one cell if there are no blocked cells there. This move keeps the **horizontal**/vertical position of the snake as it is.\\n\\nCan someone help to explain how a vertical movement is possible while going right without a down+counterclockwise move?\\nSimilarly how is second move possible?"
                    },
                    {
                        "username": "Shark-Chili",
                        "content": "The first testcase:\\n`[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]`\\n\\nAnd here is the definition of `right` and `down`\\n`right`: Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n`down`: Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n\\nSo how how can it make `right` after `rotate clockwise` (the step 3 -> step 4)?  From what I understood, the head of the snake was vertically facing downside when finished the step 3?"
                    },
                    {
                        "username": "COSMIC_GAN_356_X_M_IPG_V5",
                        "content": "why is it 11\\n[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]\\n instead of 10?\\n[right, right, rotate clockwise, right, down, down, down, down, right right]\\n\\nAt first I thought it was because the snake can only move in the direction its facing but if we can move\\n[... rotate counterclockwise, right, down] then thats not the case.\\n \\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    },
                    {
                        "username": "samzhu333",
                        "content": "We can make it by [right, right, rotate clockwise, right, down, down, down, down, right right], it will take only 10 steps instead of 11 steps"
                    },
                    {
                        "username": "Karilli",
                        "content": "I got stuck on this for half an hour... :((("
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Repeating Substring",
        "question_content": "<p>For a string <code>sequence</code>, a string <code>word</code> is <strong><code>k</code>-repeating</strong> if <code>word</code> concatenated <code>k</code> times is a substring of <code>sequence</code>. The <code>word</code>&#39;s <strong>maximum <code>k</code>-repeating value</strong> is the highest value <code>k</code> where <code>word</code> is <code>k</code>-repeating in <code>sequence</code>. If <code>word</code> is not a substring of <code>sequence</code>, <code>word</code>&#39;s maximum <code>k</code>-repeating value is <code>0</code>.</p>\n\n<p>Given strings <code>sequence</code> and <code>word</code>, return <em>the <strong>maximum <code>k</code>-repeating value</strong> of <code>word</code> in <code>sequence</code></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> sequence = &quot;ababc&quot;, word = &quot;ab&quot;\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>&quot;abab&quot; is a substring in &quot;<u>abab</u>c&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> sequence = &quot;ababc&quot;, word = &quot;ba&quot;\n<strong>Output:</strong> 1\n<strong>Explanation: </strong>&quot;ba&quot; is a substring in &quot;a<u>ba</u>bc&quot;. &quot;baba&quot; is not a substring in &quot;ababc&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> sequence = &quot;ababc&quot;, word = &quot;ac&quot;\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>&quot;ac&quot; is not a substring in &quot;ababc&quot;. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sequence.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>sequence</code> and <code>word</code>&nbsp;contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 952025,
                "title": "c-short-easy-using-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count=0;\\n        string temp=word;\\n        while(sequence.find(temp)!=string::npos)\\n        {\\n            count++;\\n            temp+=word;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**please upvote my solution if you like it**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count=0;\\n        string temp=word;\\n        while(sequence.find(temp)!=string::npos)\\n        {\\n            count++;\\n            temp+=word;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952026,
                "title": "java-python-3-bruteforce-4-liners-w-analysis",
                "content": "\\n```java\\n    public int maxRepeating(String sequence, String word) {\\n        int ans = 1;\\n     // while (sequence.indexOf(word.repeat(ans)) >= 0)\\n        while (sequence.contains(word.repeat(ans)))\\n            ++ans;\\n        return ans - 1;\\n    }\\n```\\n```python\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        ans = 1\\n      # while sequence.find(word * ans) >= 0:\\n         while word * ans in sequence:             # credit to @blue_sky5 for his more pythonic way.\\n            ans += 1\\n        return ans - 1\\n```\\n**Analysis:**\\n\\nLet n = sequence.length().\\n\\nword.repeat() at most cost O(n) time and space, and contains() cost O(n) time for each call; Note the number of calls * word.repeat(ans).length() should be O(n), since the shorter the latter, the more the former. Therefore,\\n\\nTime: O(n ^ 2), space: O(n).",
                "solutionTags": [],
                "code": "```java\\n    public int maxRepeating(String sequence, String word) {\\n        int ans = 1;\\n     // while (sequence.indexOf(word.repeat(ans)) >= 0)\\n        while (sequence.contains(word.repeat(ans)))\\n            ++ans;\\n        return ans - 1;\\n    }\\n```\n```python\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        ans = 1\\n      # while sequence.find(word * ans) >= 0:\\n         while word * ans in sequence:             # credit to @blue_sky5 for his more pythonic way.\\n            ans += 1\\n        return ans - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 952276,
                "title": "clean-python-3-true-o-n-with-kmp",
                "content": "For testcase sequence `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab` and word `aaaaaaaaaaaaaaab`,\\nit\\'s easy to find that if we adopt naive linear scanning for string matching, the time cost will become `O(N*W)`.\\nHence using KMP will be helpful in this situation.\\n\\nTime: `O(N + N / W * W) = O(N + N) = O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        s, w = len(sequence), len(word)\\n        max_repeat = s // w\\n        failure = [0] * (w * max_repeat + 1)\\n        repeat_words = word * max_repeat + \\'$\\'\\n        result = 0\\n\\n        j = 0\\n        for i in range(1, len(repeat_words)):\\n            while j > 0 and repeat_words[j] != repeat_words[i]:\\n                j = failure[j-1]\\n            j += repeat_words[j] == repeat_words[i]\\n            failure[i] = j\\n\\n        j = 0\\n        for i, c in enumerate(sequence):\\n            while j > 0 and repeat_words[j] != c:\\n                j = failure[j-1]\\n            j += repeat_words[j] == c\\n            result = max(result, j // w)\\n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        s, w = len(sequence), len(word)\\n        max_repeat = s // w\\n        failure = [0] * (w * max_repeat + 1)\\n        repeat_words = word * max_repeat + \\'$\\'\\n        result = 0\\n\\n        j = 0\\n        for i in range(1, len(repeat_words)):\\n            while j > 0 and repeat_words[j] != repeat_words[i]:\\n                j = failure[j-1]\\n            j += repeat_words[j] == repeat_words[i]\\n            failure[i] = j\\n\\n        j = 0\\n        for i, c in enumerate(sequence):\\n            while j > 0 and repeat_words[j] != c:\\n                j = failure[j-1]\\n            j += repeat_words[j] == c\\n            result = max(result, j // w)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981906,
                "title": "java-3-liner",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String find=\"\";\\n        while(sequence.contains(find)) find += word;\\n        return (find.length()-word.length())/word.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String find=\"\";\\n        while(sequence.contains(find)) find += word;\\n        return (find.length()-word.length())/word.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952687,
                "title": "python-binary-search-on-the-length-of-the-subsequence",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if word not in sequence:\\n            return 0\\n\\n        left = 1\\n        right = len(sequence) // len(word)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if word * mid in sequence:\\n                left = mid + 1\\n            else:\\n                right = mid - 1 \\n                \\n        return left - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if word not in sequence:\\n            return 0\\n\\n        left = 1\\n        right = len(sequence) // len(word)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if word * mid in sequence:\\n                left = mid + 1\\n            else:\\n                right = mid - 1 \\n                \\n        return left - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006510,
                "title": "java-simple-straight-solution",
                "content": "```\\n\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int n = sequence.length(), m = word.length();\\n        int max = 0;\\n        for(int i = 0;i < n;i++) {\\n            int cnt = 0, k = 0;\\n            for(int j = i;j < n;j++) {\\n                if(sequence.charAt(j) == word.charAt(k)) k++;\\n                else break;\\n                if(k == m) {\\n                    k = 0;\\n                    cnt++;\\n                }\\n            }\\n            max = Math.max(max, cnt);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int n = sequence.length(), m = word.length();\\n        int max = 0;\\n        for(int i = 0;i < n;i++) {\\n            int cnt = 0, k = 0;\\n            for(int j = i;j < n;j++) {\\n                if(sequence.charAt(j) == word.charAt(k)) k++;\\n                else break;\\n                if(k == m) {\\n                    k = 0;\\n                    cnt++;\\n                }\\n            }\\n            max = Math.max(max, cnt);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955479,
                "title": "java-simple-solution",
                "content": "```java\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int repeating = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        while (sequence.contains(sb)) {\\n            repeating++;\\n            sb.append(word);\\n        }\\n        return repeating;\\n    }\\n\\n    public static void test() {\\n        Solution s = new Solution();\\n        System.out.println(s.maxRepeating(\"ababc\", \"ab\"));\\n        System.out.println(s.maxRepeating(\"ababc\", \"ba\"));\\n        System.out.println(s.maxRepeating(\"ababc\", \"ac\"));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int repeating = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        while (sequence.contains(sb)) {\\n            repeating++;\\n            sb.append(word);\\n        }\\n        return repeating;\\n    }\\n\\n    public static void test() {\\n        Solution s = new Solution();\\n        System.out.println(s.maxRepeating(\"ababc\", \"ab\"));\\n        System.out.println(s.maxRepeating(\"ababc\", \"ba\"));\\n        System.out.println(s.maxRepeating(\"ababc\", \"ac\"));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954256,
                "title": "c-100-faster-solution-easy-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxRepeating(string sequence, string word) {\\n\\t\\t\\tint k = 0;\\n\\t\\t\\tstring temp = word;\\n\\n\\t\\t\\twhile(sequence.find(temp) != string::npos){\\n\\t\\t\\t\\ttemp += word;\\n\\t\\t\\t\\tk++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn k;\\n\\t\\t}\\n\\t};\\n\\nto know about **string::npos** [click here.](https://www.cplusplus.com/reference/string/string/npos/)\\n\\n**Like it? please Upvote!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxRepeating(string sequence, string word) {\\n\\t\\t\\tint k = 0;\\n\\t\\t\\tstring temp = word;\\n\\n\\t\\t\\twhile(sequence.find(temp) != string::npos){\\n\\t\\t\\t\\ttemp += word;\\n\\t\\t\\t\\tk++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1343072,
                "title": "java-short-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count=0;\\n        String temp = word;\\n        while(sequence.contains(temp)){\\n            count++;\\n            temp+=word;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count=0;\\n        String temp = word;\\n        while(sequence.contains(temp)){\\n            count++;\\n            temp+=word;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952484,
                "title": "c-o-n-n",
                "content": "C++ devs are in luck as `string::find` is O(n + m). So we do not need to implement KPM ourselves.\\n\\n> Update: we do need KMP as we may need to start a new search from the middle of the previously matched string.\\n\\nSo, we use `find` to get a match, and then two pointers to check it\\'s lenght. Then, we repeat it for the next missmatched position till we reach the end of our `seq`.\\n\\n```cpp\\nint maxRepeating(string seq, string word) {\\n    int pos = seq.find(word), res = 0, sz = word.size();\\n    while (pos != string::npos) {\\n        int i = pos + sz, j = 0;\\n        while (i < seq.size() && seq[i] == word[j % sz]) {\\n            ++i;\\n            ++j;\\n        }\\n        res = max(res, 1 + j / sz);\\n        pos = seq.find(word, pos + 1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxRepeating(string seq, string word) {\\n    int pos = seq.find(word), res = 0, sz = word.size();\\n    while (pos != string::npos) {\\n        int i = pos + sz, j = 0;\\n        while (i < seq.size() && seq[i] == word[j % sz]) {\\n            ++i;\\n            ++j;\\n        }\\n        res = max(res, 1 + j / sz);\\n        pos = seq.find(word, pos + 1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952060,
                "title": "python3-easy-way",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        ans = 0\\n        k = 1\\n        while word*k in sequence:\\n            ans += 1\\n            k += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        ans = 0\\n        k = 1\\n        while word*k in sequence:\\n            ans += 1\\n            k += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580569,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int c=0;\\n        String add=word;\\n        while(sequence.contains(word)==true)\\n        {\\n            c+=1;\\n            word=word+add;\\n            //System.out.println(word);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int c=0;\\n        String add=word;\\n        while(sequence.contains(word)==true)\\n        {\\n            c+=1;\\n            word=word+add;\\n            //System.out.println(word);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343114,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar maxRepeating = function(sequence, word) {\\n\\t\\tlet result = 0;\\n\\n\\t\\twhile (sequence.includes(word.repeat(result + 1))) {\\n\\t\\t\\tresult += 1;\\n\\t\\t};\\n\\t\\treturn result;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar maxRepeating = function(sequence, word) {\\n\\t\\tlet result = 0;\\n\\n\\t\\twhile (sequence.includes(word.repeat(result + 1))) {\\n\\t\\t\\tresult += 1;\\n\\t\\t};\\n\\t\\treturn result;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1225675,
                "title": "py-most-probably-the-worst-way-to-solve-this-problem",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        count=0\\n        while True:\\n            if word*(count+1) not in sequence:\\n                return count\\n            count+=1\\n```\\n\\tE.g.:\\n\\tSequence = \"ababa\"\\n\\tword = \"ab\"\\n\\t\\n\\t1. Initially set count to 0, saying that word might not be present in sequence.\\n\\t2. word * (count+1) = word * (0+1) = word * 1 = word = ab is present in sequence. Increment count by 1, count =1.\\n\\t3. Now, word * (count+1) = word * (1+1) = word * 2 = abab is also present in sequence. Increment count by 1, count=2.\\n\\t4. Now, similarly word * (count+1) = ababab in not present in Sequence so return the last successful count (= 2).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        count=0\\n        while True:\\n            if word*(count+1) not in sequence:\\n                return count\\n            count+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176449,
                "title": "c-without-using-library-function-100",
                "content": "Iterate over each index in \\'sequence\\' to find the potential starting point of the maximum length substring. <br>\\nThe inner while loop finds the max occurences of \\'word\\' starting from sequence[i].\\n\\n```\\n\\n    int maxRepeating(string s, string w) {\\n        int n = s.length(), ans =0;\\n        for(int i= 0, j=0, k=0, l=0; i<n; i++,j=0, k=0, l=0){\\n            while(i+j<n && s[i+j]==w[l]){\\n                j++;l++;\\n                if(l==w.length()) l=0, k++;\\n            }\\n            ans = max(ans, k);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    int maxRepeating(string s, string w) {\\n        int n = s.length(), ans =0;\\n        for(int i= 0, j=0, k=0, l=0; i<n; i++,j=0, k=0, l=0){\\n            while(i+j<n && s[i+j]==w[l]){\\n                j++;l++;\\n                if(l==w.length()) l=0, k++;\\n            }\\n            ans = max(ans, k);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314737,
                "title": "c-o-n-solution-with-constant-extra-space",
                "content": "# Intuition\\nTry to find the maximum continuous repetitions of word in the given sequence.\\n\\n# Approach\\n- Set Max=0, to store the max repititions.\\n- Set k=0, when we found a sequence without match to start from first.\\n- Now get all the posiible sliding window substrings and check if this is equal to word or not.\\n\\n# Complexity\\n- Time complexity:\\n    O(N)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Testcase\\nSqequence : \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nWord : \"aaaba\"\\n\\nAns : 5\\n\\n**Explanation:**\\nWhen we are in i=10,j=14, it is not a match but the previous was a match.\\nSo we need to go to i=6,j=10 and continue the process, since our max sequence may start from here itself.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string seq, string word) {\\n        if(word.size()>seq.size()) return 0;\\n        int i=0,j=word.size()-1,k=0,Max=0;\\n        while(j<seq.size()){\\n            if(seq.substr(i,j-i+1)!=word){ // is the substring does\\'nt match\\n                if(k!=0){ // is the previous substring was a match, go to previous substring and start from next index.\\n                    i-=word.size();\\n                    j-=word.size();\\n                }\\n                i++; // just pass to next sliding window\\n                j++;\\n                k=0; // reset the value\\n            }\\n            else{ // if the substring is a match\\n                Max=max(Max,++k);\\n                i+=word.size();\\n                j+=word.size();\\n            }\\n        }\\n        return Max;\\n    }\\n};\\n\\n```\\n**Note :**\\n\\nif ( this solution was helpful ) {\\n    cout << \" Pls Upvote \" ;\\n}",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string seq, string word) {\\n        if(word.size()>seq.size()) return 0;\\n        int i=0,j=word.size()-1,k=0,Max=0;\\n        while(j<seq.size()){\\n            if(seq.substr(i,j-i+1)!=word){ // is the substring does\\'nt match\\n                if(k!=0){ // is the previous substring was a match, go to previous substring and start from next index.\\n                    i-=word.size();\\n                    j-=word.size();\\n                }\\n                i++; // just pass to next sliding window\\n                j++;\\n                k=0; // reset the value\\n            }\\n            else{ // if the substring is a match\\n                Max=max(Max,++k);\\n                i+=word.size();\\n                j+=word.size();\\n            }\\n        }\\n        return Max;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400359,
                "title": "python3-simple-solution",
                "content": "We multiply the word and check occurence with `in`. \\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i = 0\\n        while word*(i+1) in sequence:\\n            i+=1\\n        return i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i = 0\\n        while word*(i+1) in sequence:\\n            i+=1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952087,
                "title": "simple-java-added-example-for-better-understading",
                "content": "Pls add this example in description to avoid confusion.\\n\\n\"abab\"\\n\"b\"\\noutput: 1\\n\\nWith repeat method\\n```\\n    public int maxRepeating(String s, String w) {\\n        int n =s.length(), wn = w.length(), m = n/wn;\\n        for(int i=m; i>0; i--){\\n            if( s.indexOf(w.repeat(i)) >=0){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n\\nWithout repeat method\\n\\n```\\n    public int maxRepeating(String s, String w) {\\n        int n =s.length(), wn = w.length(), m = n/wn, i=0;\\n        String tmp =w;\\n        while(i <=m ){\\n            if( s.indexOf(w) < 0){\\n                return i;\\n            }\\n            w+=tmp;\\n            i++;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxRepeating(String s, String w) {\\n        int n =s.length(), wn = w.length(), m = n/wn;\\n        for(int i=m; i>0; i--){\\n            if( s.indexOf(w.repeat(i)) >=0){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n```\n```\\n    public int maxRepeating(String s, String w) {\\n        int n =s.length(), wn = w.length(), m = n/wn, i=0;\\n        String tmp =w;\\n        while(i <=m ){\\n            if( s.indexOf(w) < 0){\\n                return i;\\n            }\\n            w+=tmp;\\n            i++;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878466,
                "title": "java-1ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n      int count = -1;\\n      String s = \"\";\\n      do\\n      {\\n        count++;\\n        s += word;\\n      }while(sequence.contains(s));\\n      return count;\\n    }\\n}\\n```\\nComment if you have any doubt or suggestions\\nIf this approach helps you in any way then do upvote \\nHope you like it !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n      int count = -1;\\n      String s = \"\";\\n      do\\n      {\\n        count++;\\n        s += word;\\n      }while(sequence.contains(s));\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434472,
                "title": "java-short-and-easy-solution-to-understand-runtime-1ms",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String pat = word;\\n        int k = 0;\\n        while(true){\\n            if(sequence.indexOf(pat) != -1){\\n                k++;\\n                pat += word;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```\\n\\nIf you like this solution please upvote.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String pat = word;\\n        int k = 0;\\n        while(true){\\n            if(sequence.indexOf(pat) != -1){\\n                k++;\\n                pat += word;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164988,
                "title": "rust-short-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        let max_word = word.repeat(sequence.len() / word.len());\\n        let mut n = max_word.len();\\n        while sequence.find(&max_word[..n]).is_none() {\\n            n -= word.len();\\n        }\\n        (n / word.len()) as _\\n    }\\n}\\n```\\n\\nWe can safely slice the `String`s wherever we want as we know that they\\'re valid ASCII.",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        let max_word = word.repeat(sequence.len() / word.len());\\n        let mut n = max_word.len();\\n        while sequence.find(&max_word[..n]).is_none() {\\n            n -= word.len();\\n        }\\n        (n / word.len()) as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022474,
                "title": "java-easy-too-understand",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        String tmp = word;\\n        \\n        while(sequence.contains(tmp)) {\\n            count++;\\n            tmp += word;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        String tmp = word;\\n        \\n        while(sequence.contains(tmp)) {\\n            count++;\\n            tmp += word;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952240,
                "title": "explained-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string ex=word; //store the string word in ex\\n        size_t found = sequence.find(word); //check the presence of word in sequence\\n        while(found != string::npos){\\n            word+=ex; //increase the size of word by adding ex( given word)\\n            found = sequence.find(word); //again check the presence of word in sequence\\n        }\\n\\t\\t//word.size()-ex.size() as this word is not present so subtract the last ex added \\n        return (word.size()-ex.size())/ex.size(); \\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string ex=word; //store the string word in ex\\n        size_t found = sequence.find(word); //check the presence of word in sequence\\n        while(found != string::npos){\\n            word+=ex; //increase the size of word by adding ex( given word)\\n            found = sequence.find(word); //again check the presence of word in sequence\\n        }\\n\\t\\t//word.size()-ex.size() as this word is not present so subtract the last ex added \\n        return (word.size()-ex.size())/ex.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332901,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k = 0\\n\\t\\t\\n        while True:\\n\\t\\t\\n            if k*word not in sequence:\\n                return k-1\\n\\t\\t\\t\\t\\n            k+=1\\n```\\n**Thanks for viewing.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k = 0\\n\\t\\t\\n        while True:\\n\\t\\t\\n            if k*word not in sequence:\\n                return k-1\\n\\t\\t\\t\\t\\n            k+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166529,
                "title": "3-liner-c-solution",
                "content": "**Approach** - \\nKeep checking the substing and if it is present we append the initial substring and repeat the same.\\n\\n**i.e** - \\nsequence = \"bacacacbac\"  &  word = \"ac\"\\n\\nso at first we search \"**ac**\" in our string which is present at multiple places as \"b**ac**acacbac\" so it will return true, we concatenate \"**ac**\" to our word and keep searching for \"**acac**\" now which is also present as \"b**acac**acbac\". Similarly we keep on checking and get the desired output.\\n\\nMy code goes as - \\n\\n```\\nint maxRepeating(string sequence, string word) {\\n    string s = word;\\n    while(sequence.find(s) != string::npos) s+=word;\\n    return (s.size()/word.size()) - 1;\\n}\\n```\\n\\nTime Complexity = O(N*N)                 \\nSpace complexity = O(N)\\nwhere N is size of string to be fetched\\n\\nThanks for reading \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxRepeating(string sequence, string word) {\\n    string s = word;\\n    while(sequence.find(s) != string::npos) s+=word;\\n    return (s.size()/word.size()) - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947714,
                "title": "c-kmp-solution-o-n-n",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximum Repeating Substring.\\nMemory Usage: 6.5 MB, less than 8.60% of C++ online submissions for Maximum Repeating Substring.\\n\\n```\\nBuild up the word string as long as word size less than sequence size.\\nThen preprocess LPS for updated word string.\\nRun KMP over updated word and sequence, now as soon as index pointer of word reaches\\nat some point where original word ends, means j % word length (original) == 0 then the\\nlength of the substring match is j / word length (original). Then we just need to get the\\nmaximum substring match length which is divisible by original word length.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string w) {\\n        \\n        // store original word length\\n        int wl = w.length();\\n        int sl = s.length();\\n        \\n        // build up word and preprocess LPS\\n        while(w.size() < sl)w+=w;\\n        \\n        vector<int>lps(w.length());\\n        lps[0] = 0;\\n        \\n        int i = 1;\\n        int j = 0;\\n        while(i < w.length())\\n        {\\n            if(w[i]==w[j])lps[i++]=++j;\\n            else\\n            {\\n                if(j==0)lps[i++]=0;\\n                else j = lps[j-1];\\n            }\\n        }\\n        \\n        // run KMP over updated word and sequence string\\n        i = 0;\\n        j = 0;\\n        int maxc = 0;\\n        while(i < sl)\\n        {\\n            if(s[i]==w[j])i++,++j;\\n            else\\n            {\\n                if(j==0)i++;\\n                else j = lps[j-1];\\n            }\\n            \\n\\n            // word pointer divisible by original word length and so is a repeated substring\\n            // repeat count => j / word length and track the max repeat\\n            if((j%wl)==0)\\n                maxc = max(maxc,j/wl);\\n        }\\n        \\n        // return max repeat count\\n        return maxc;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nBuild up the word string as long as word size less than sequence size.\\nThen preprocess LPS for updated word string.\\nRun KMP over updated word and sequence, now as soon as index pointer of word reaches\\nat some point where original word ends, means j % word length (original) == 0 then the\\nlength of the substring match is j / word length (original). Then we just need to get the\\nmaximum substring match length which is divisible by original word length.\\n```\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string w) {\\n        \\n        // store original word length\\n        int wl = w.length();\\n        int sl = s.length();\\n        \\n        // build up word and preprocess LPS\\n        while(w.size() < sl)w+=w;\\n        \\n        vector<int>lps(w.length());\\n        lps[0] = 0;\\n        \\n        int i = 1;\\n        int j = 0;\\n        while(i < w.length())\\n        {\\n            if(w[i]==w[j])lps[i++]=++j;\\n            else\\n            {\\n                if(j==0)lps[i++]=0;\\n                else j = lps[j-1];\\n            }\\n        }\\n        \\n        // run KMP over updated word and sequence string\\n        i = 0;\\n        j = 0;\\n        int maxc = 0;\\n        while(i < sl)\\n        {\\n            if(s[i]==w[j])i++,++j;\\n            else\\n            {\\n                if(j==0)i++;\\n                else j = lps[j-1];\\n            }\\n            \\n\\n            // word pointer divisible by original word length and so is a repeated substring\\n            // repeat count => j / word length and track the max repeat\\n            if((j%wl)==0)\\n                maxc = max(maxc,j/wl);\\n        }\\n        \\n        // return max repeat count\\n        return maxc;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415449,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string seq, string word) {\\n        \\n        int n=word.length();\\n        char w = word[0];\\n        int i=0;\\n        int maxi=0;\\n        if(seq.length()<word.length())\\n            return false;\\n        while(i<(seq.length()-word.length()+1))\\n        {\\n            if(seq[i]==w)\\n            {\\n                int j=i;\\n                 int count=0;\\n                while(j<=(seq.length()-n))\\n                {\\n                    string k= seq.substr(j,n);\\n                    if(k==word)\\n                    {\\n                        count++;\\n                         j=j+n;\\n                    }              \\n                    else\\n                        break;\\n                }\\n                maxi = max(maxi,count);\\n            }   \\n            i++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string seq, string word) {\\n        \\n        int n=word.length();\\n        char w = word[0];\\n        int i=0;\\n        int maxi=0;\\n        if(seq.length()<word.length())\\n            return false;\\n        while(i<(seq.length()-word.length()+1))\\n        {\\n            if(seq[i]==w)\\n            {\\n                int j=i;\\n                 int count=0;\\n                while(j<=(seq.length()-n))\\n                {\\n                    string k= seq.substr(j,n);\\n                    if(k==word)\\n                    {\\n                        count++;\\n                         j=j+n;\\n                    }              \\n                    else\\n                        break;\\n                }\\n                maxi = max(maxi,count);\\n            }   \\n            i++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081207,
                "title": "java-easy-solution-with-stringbuilder-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n        while(sequence.contains(result.append(word).toString())) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n        while(sequence.contains(result.append(word).toString())) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982082,
                "title": "naive-javascript-implementation-while-loop-no-recursion",
                "content": "```\\nconst maxRepeating = (sequence, word) => {\\n    let str = word;\\n    let counter = 0;\\n    while (sequence.includes(str)) {\\n        counter++;\\n        str += word;\\n    }\\n    return counter;\\n};\\n```\\n\\n76ms / faster than 90%",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxRepeating = (sequence, word) => {\\n    let str = word;\\n    let counter = 0;\\n    while (sequence.includes(str)) {\\n        counter++;\\n        str += word;\\n    }\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952369,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        \\n         \\n        String w1 = word;\\n        int res = 0;\\n        while (w1.length() <= sequence.length()) {\\n            if (sequence.contains(w1)) {\\n                res++;\\n                w1 += word;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        \\n         \\n        String w1 = word;\\n        int res = 0;\\n        while (w1.length() <= sequence.length()) {\\n            if (sequence.contains(w1)) {\\n                res++;\\n                w1 += word;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952341,
                "title": "c-simple-bf",
                "content": "```\\npublic class Solution {\\n    public int MaxRepeating(string sequence, string word) {\\n        int max = 0;\\n        string test = word;\\n        while(true)\\n        {\\n            if(sequence.Contains(test))\\n            {\\n                max++;\\n                test += word;\\n            }\\n            else\\n                break;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxRepeating(string sequence, string word) {\\n        int max = 0;\\n        string test = word;\\n        while(true)\\n        {\\n            if(sequence.Contains(test))\\n            {\\n                max++;\\n                test += word;\\n            }\\n            else\\n                break;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952018,
                "title": "python-3-two-solutions-and-one-liner",
                "content": "\\nNon Brute Force:\\nTime complexity O(n)\\nSpace complexity O(1)\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n=len(sequence)\\n        wn=len(word)\\n        maxrepeat=0\\n        i=0\\n        while i<=n-maxrepeat*wn:\\n            j=0\\n            while i+j<n and sequence[i+j]==word[j%wn]:\\n                j+=1\\n            maxrepeat=max(maxrepeat,j//wn)\\n            i+=1\\n        return maxrepeat\\n```\\nUnfortunately, Brute Force works.\\n\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        maxrepeat=0\\n        while maxrepeat*word in sequence: maxrepeat+=1\\n        return maxrepeat-1\\n```\\nTime complexity O(n^2)\\nSpace complexity O(1)\\n\\nBrute Force One line version:\\n```\\n    def maxRepeating(self, s, w):\\n        return sum(w * i in s for i in range(1, len(s)//len(w)+1))\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n=len(sequence)\\n        wn=len(word)\\n        maxrepeat=0\\n        i=0\\n        while i<=n-maxrepeat*wn:\\n            j=0\\n            while i+j<n and sequence[i+j]==word[j%wn]:\\n                j+=1\\n            maxrepeat=max(maxrepeat,j//wn)\\n            i+=1\\n        return maxrepeat\\n```\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        maxrepeat=0\\n        while maxrepeat*word in sequence: maxrepeat+=1\\n        return maxrepeat-1\\n```\n```\\n    def maxRepeating(self, s, w):\\n        return sum(w * i in s for i in range(1, len(s)//len(w)+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951979,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String s, String word) {\\n        int n = s.length(), m = word.length();\\n        int max = 0;\\n        outer : for(int i = 0; i < n - m + 1; i++) {\\n            int count = 0, k = 0;\\n            for(int j = i; j < n; j++) {\\n                if(s.charAt(j) != word.charAt(k)) continue outer;\\n                k++;\\n                if(k == m) {\\n                    count++;\\n                    k = 0;\\n                    max = Math.max(max, count);\\n                }\\n            }\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxRepeating(String s, String word) {\\n        int n = s.length(), m = word.length();\\n        int max = 0;\\n        outer : for(int i = 0; i < n - m + 1; i++) {\\n            int count = 0, k = 0;\\n            for(int j = i; j < n; j++) {\\n                if(s.charAt(j) != word.charAt(k)) continue outer;\\n                k++;\\n                if(k == m) {\\n                    count++;\\n                    k = 0;\\n                    max = Math.max(max, count);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 951976,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int lo = 0;\\n        int hi = sequence.length()/word.length()+1;\\n        while(lo<hi){\\n            int mid = (lo+hi+1)/2;\\n            if(isFeasible(sequence, word, mid)){\\n                lo = mid;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    \\n    public boolean isFeasible(String sequence, String word, int k){\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<k; i++){\\n            sb.append(word);\\n        }\\n        int index = sequence.indexOf(sb.toString());\\n        return index>=0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int lo = 0;\\n        int hi = sequence.length()/word.length()+1;\\n        while(lo<hi){\\n            int mid = (lo+hi+1)/2;\\n            if(isFeasible(sequence, word, mid)){\\n                lo = mid;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    \\n    public boolean isFeasible(String sequence, String word, int k){\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<k; i++){\\n            sb.append(word);\\n        }\\n        int index = sequence.indexOf(sb.toString());\\n        return index>=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572251,
                "title": "smallest-code-possible-unique-approach-beats-100-c-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt starts by initializing a temporary string temp with the value of word. This temporary string will be used to check for consecutive repetitions.\\n\\nIt sets a flag variable flag to true, indicating that we should continue checking for repetitions until proven otherwise.\\n\\nIt initializes a variable ans to 0, which will keep track of the maximum number of repetitions found.\\n\\nThe code enters a while loop that continues as long as the flag is true. This loop will break when no more repetitions are found.\\n\\nWithin the loop, it uses the find function to check if temp (the current value of repetitions) can be found in sequence. If a match is found (i.e., find does not return npos), it means temp is present in sequence.\\n\\nIf a match is found, it increments ans by 1 to indicate that another repetition has been found.\\n\\nIt then appends word to the end of temp, effectively increasing its length. This step ensures that the code looks for the next consecutive repetition of word in sequence.\\n\\nIf no match is found, the code sets flag to false, indicating that there are no more repetitions to be found, and the while loop should terminate.\\n\\nFinally, the code returns the value of ans, which represents the maximum number of consecutive repetitions of word found in sequence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N * M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = word;\\n        bool flag = true;\\n\\n        int ans = 0;\\n        while(flag){\\n            if(sequence.find(temp)!=string::npos){\\n                ans++;\\n                temp+=word;\\n            }\\n            else flag = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = word;\\n        bool flag = true;\\n\\n        int ans = 0;\\n        while(flag){\\n            if(sequence.find(temp)!=string::npos){\\n                ans++;\\n                temp+=word;\\n            }\\n            else flag = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470022,
                "title": "96-86-beatable-easy-js-sol-understandable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- We can find the maximum k-repeating value of a word in a given sequence using **linear search**. \\n- However, ***binary search*** can provide a ***more optimized solution*** with a ***lower time complexity than linear search***. \\n- The time complexity of **binary search is O(log n)**, while the **time complexity of linear search is O(n)**.\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn this implementation :-\\n1. I have first initialized a left pointer to 0 and a right pointer to ***Math.floor(sequence.length / word.length)***, which represents the maximum possible value of **k** for which the word can be k-repeating in the sequence. \\n2. Then, I performed binary search on the range ***[left, right]*** to find the maximum k-repeating value of the word in the sequence. \\n3. Then, I repeatedly checked if the word is k-repeating in the sequence by checking if the sequence includes the string ***word.repeat(mid)*** for some mid between left and right. \\n4. If it is, I updated the answer to ***mid*** and search for a higher value of ***k*** to the ***right of mid***. \\n5. If it\\'s not, I searched for a ***lower*** value of ***k*** to the ***left of mid***.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the length of the sequence. \\n2. This is because the function uses ***binary search*** to find the maximum k-repeating value of the word in the sequence.\\n3. And ***Binary search has a time complexity of O(log n)***.\\n \\n\\n\\n\\n\\n\\n\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n1. Because it only uses a fixed amount of extra memory to store the variables **right**, **left** and **ans**. \\n2. The input parameters **sequence** and **word** are not counted towards the space complexity, as they are part of the input to the function.\\n\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} sequence\\n * @param {string} word\\n * @return {number}\\n */\\nvar maxRepeating = function(sequence, word) {\\n  \\n  let right = Math.floor(sequence.length / word.length);\\n\\n  let left = 0;\\n  \\n  let ans = 0;\\n  \\n  while (left <= right) {\\n    \\n    let mid = Math.floor((left + right) / 2);\\n    \\n    if (sequence.includes(word.repeat(mid))) {\\n      \\n      ans = mid;\\n      \\n      left = mid + 1;\\n    }\\n    else {\\n      \\n      right = mid - 1;\\n    }\\n  }\\n  return ans;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/f41a1d81-17dc-4dd4-a5a1-d7c174ba2c94_1682860320.806763.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Binary Search",
                    "String Matching"
                ],
                "code": "```\\n/**\\n * @param {string} sequence\\n * @param {string} word\\n * @return {number}\\n */\\nvar maxRepeating = function(sequence, word) {\\n  \\n  let right = Math.floor(sequence.length / word.length);\\n\\n  let left = 0;\\n  \\n  let ans = 0;\\n  \\n  while (left <= right) {\\n    \\n    let mid = Math.floor((left + right) / 2);\\n    \\n    if (sequence.includes(word.repeat(mid))) {\\n      \\n      ans = mid;\\n      \\n      left = mid + 1;\\n    }\\n    else {\\n      \\n      right = mid - 1;\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3158044,
                "title": "python3-o-n-2-solution-intuitive",
                "content": "O(n^2) still but found it to be more intuitive than the top solutions\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i = 0\\n        j = 0\\n        max_ct = 0\\n\\n        if len(word) > len(sequence):\\n            return 0\\n\\n        ct = 0\\n        while i < len(sequence):\\n            while sequence[j:j+len(word)] == word:\\n                ct += 1\\n                j += len(word)\\n            max_ct = max(max_ct, ct)\\n            ct = 0\\n            i += 1\\n            j = i\\n        return max_ct\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i = 0\\n        j = 0\\n        max_ct = 0\\n\\n        if len(word) > len(sequence):\\n            return 0\\n\\n        ct = 0\\n        while i < len(sequence):\\n            while sequence[j:j+len(word)] == word:\\n                ct += 1\\n                j += len(word)\\n            max_ct = max(max_ct, ct)\\n            ct = 0\\n            i += 1\\n            j = i\\n        return max_ct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147455,
                "title": "java-easy-solution-1ms-93-94-faster",
                "content": "![image](https://assets.leetcode.com/users/images/929a6868-a635-4a0e-b250-feff9bd4052d_1675619189.8564208.png)\\n```\\nclass Solution {\\n    public int maxRepeating(String s, String w) {\\n        if(w.length()>s.length()) return 0;\\n        int ans=0;\\n        StringBuilder sb=new StringBuilder(\"\");\\n        while(sb.length()<=s.length()){\\n            sb.append(w);\\n            if(s.contains(sb)) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String s, String w) {\\n        if(w.length()>s.length()) return 0;\\n        int ans=0;\\n        StringBuilder sb=new StringBuilder(\"\");\\n        while(sb.length()<=s.length()){\\n            sb.append(w);\\n            if(s.contains(sb)) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138314,
                "title": "c-100-faster-4-liner-string-simple-solution-easy-find-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string s1) {\\n        int m = s1.size(),n = s.size(),i = 1;\\n        string temp = s1;\\n        while(s.find(temp) != string::npos && i++) temp += s1;\\n        return i - 1;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/30b50c4d-d54e-4713-8aab-80bfd99dd7d0_1654951754.358517.png)\\n## UPVOTE IF YOU LIKE\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string s1) {\\n        int m = s1.size(),n = s.size(),i = 1;\\n        string temp = s1;\\n        while(s.find(temp) != string::npos && i++) temp += s1;\\n        return i - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026654,
                "title": "java-easy-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n       String tbf = word;\\n        int count=0;\\n        while(sequence.contains(tbf))\\n        {\\n            tbf+=word;\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n       String tbf = word;\\n        int count=0;\\n        while(sequence.contains(tbf))\\n        {\\n            tbf+=word;\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583577,
                "title": "java-o-n-easy-solution-100-faster-0-ms",
                "content": "```\\n StringBuffer sb=new StringBuffer(sequence.length());\\n        sb.append(word);\\n        int maxK=0;\\n        while(sequence.indexOf(sb.toString())>=0)\\n        {\\n            sb.append(word);\\n            maxK++;\\n        }\\n        return maxK;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n StringBuffer sb=new StringBuffer(sequence.length());\\n        sb.append(word);\\n        int maxK=0;\\n        while(sequence.indexOf(sb.toString())>=0)\\n        {\\n            sb.append(word);\\n            maxK++;\\n        }\\n        return maxK;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1573469,
                "title": "c-easy-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int k=0,cnt=0;\\n        string res=\"\";\\n        while(k<sequence.size()){\\n            k+=word.size();\\n            \\n            res+=word;\\n            if(sequence.find(res)==string::npos)break;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int k=0,cnt=0;\\n        string res=\"\";\\n        while(k<sequence.size()){\\n            k+=word.size();\\n            \\n            res+=word;\\n            if(sequence.find(res)==string::npos)break;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503892,
                "title": "simple-c-solution-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n       if (sequence.size() < word.size()) return 0;\\n       if (sequence.find(word) == string::npos)\\n       {\\n           return 0;\\n       }\\n        \\n        int ans = 1;\\n        string tmp = word;\\n        while(word.size() <= sequence.size())\\n        {\\n            word+=tmp;\\n            if (sequence.find(word) == string::npos)\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n       if (sequence.size() < word.size()) return 0;\\n       if (sequence.find(word) == string::npos)\\n       {\\n           return 0;\\n       }\\n        \\n        int ans = 1;\\n        string tmp = word;\\n        while(word.size() <= sequence.size())\\n        {\\n            word+=tmp;\\n            if (sequence.find(word) == string::npos)\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398547,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string str=word;\\n        int count=0;\\n        while(sequence.find(word)!=string::npos){\\n            count++;\\n            word+=str;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string str=word;\\n        int count=0;\\n        while(sequence.find(word)!=string::npos){\\n            count++;\\n            word+=str;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381592,
                "title": "swift-maximum-repeating-substring-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maxRepeating(_ sequence: String, _ word: String) -> Int {\\n        let max = sequence.count / word.count\\n        guard max > 0 else { return 0 }\\n        var result = 0\\n        for count in 1...max where sequence.contains(String(repeating: word, count: count)) {\\n            result = count\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.014 (0.016) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.maxRepeating(\"ababc\",\"ab\")\\n        XCTAssertEqual(res, 2)\\n    }\\n    func test1() {\\n        let res = s.maxRepeating(\"ababc\",\"ba\")\\n        XCTAssertEqual(res, 1)\\n    }\\n    func test2() {\\n        let res = s.maxRepeating(\"ababc\",\"ac\")\\n        XCTAssertEqual(res, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxRepeating(_ sequence: String, _ word: String) -> Int {\\n        let max = sequence.count / word.count\\n        guard max > 0 else { return 0 }\\n        var result = 0\\n        for count in 1...max where sequence.contains(String(repeating: word, count: count)) {\\n            result = count\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.014 (0.016) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.maxRepeating(\"ababc\",\"ab\")\\n        XCTAssertEqual(res, 2)\\n    }\\n    func test1() {\\n        let res = s.maxRepeating(\"ababc\",\"ba\")\\n        XCTAssertEqual(res, 1)\\n    }\\n    func test2() {\\n        let res = s.maxRepeating(\"ababc\",\"ac\")\\n        XCTAssertEqual(res, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322910,
                "title": "python-faster-than-99-5-of-the-submissions",
                "content": "```  \\ndef maxRepeating(self, sequence: str, word: str) -> int:\\n        if word not in sequence:\\n            return 0\\n        elif(len(word) == len(sequence)):\\n            return 1\\n        else:\\n            counter = len(sequence)//len(word)\\n            \\n            max_iter = 0\\n            for i in range(1, counter+1):\\n                if(i*len(word) <= len(sequence)):\\n                    if(i*word) in sequence:\\n                        max_iter = i\\n            return max_iter\\n",
                "solutionTags": [],
                "code": "```  \\ndef maxRepeating(self, sequence: str, word: str) -> int:\\n        if word not in sequence:\\n            return 0\\n        elif(len(word) == len(sequence)):\\n            return 1\\n        else:\\n            counter = len(sequence)//len(word)\\n            \\n            max_iter = 0\\n            for i in range(1, counter+1):\\n                if(i*len(word) <= len(sequence)):\\n                    if(i*word) in sequence:\\n                        max_iter = i\\n            return max_iter\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1245851,
                "title": "c-100-fast-easy-to-understand-optimized-code",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        if(word.length()>sequence.length())\\n          return 0;  \\n        string str;\\n        int c=0;\\n        int ans=0;\\n        bool entered=false;\\n        int i=0;\\n        while(i<=(sequence.length()-word.length()))\\n        {\\n            str=sequence.substr(i,word.length());\\n            if(str==word)\\n            {\\n             entered=true;   \\n            c++;\\n            ans=max(c,ans);\\n            i+=word.length();\\n            }   \\n          else\\n             {\\n             if(entered)\\n             {\\n                 c=0;\\n                 i+=1-word.length();\\n                 entered=false;\\n             }\\n                 else\\n                 {\\n                   i++;\\n                 }\\n            }      \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        if(word.length()>sequence.length())\\n          return 0;  \\n        string str;\\n        int c=0;\\n        int ans=0;\\n        bool entered=false;\\n        int i=0;\\n        while(i<=(sequence.length()-word.length()))\\n        {\\n            str=sequence.substr(i,word.length());\\n            if(str==word)\\n            {\\n             entered=true;   \\n            c++;\\n            ans=max(c,ans);\\n            i+=word.length();\\n            }   \\n          else\\n             {\\n             if(entered)\\n             {\\n                 c=0;\\n                 i+=1-word.length();\\n                 entered=false;\\n             }\\n                 else\\n                 {\\n                   i++;\\n                 }\\n            }      \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203226,
                "title": "golang-o-n-one-pass",
                "content": "```\\nfunc maxRepeating(seq string, word string) int {\\n\\tvar mx, cur int\\n\\twl := len(word)\\n\\tfor i := 0; i <= len(seq)-wl; i++ {\\n\\t\\tif seq[i:i+wl] == word {\\n\\t\\t\\tcur++\\n\\t\\t\\ti += wl - 1\\n\\t\\t} else {\\n\\t\\t\\ti -= cur * wl\\n\\t\\t\\tcur = 0\\n\\n\\t\\t}\\n\\t\\tif cur > mx {\\n\\t\\t\\tmx = cur\\n\\t\\t}\\n\\t}\\n\\treturn mx\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxRepeating(seq string, word string) int {\\n\\tvar mx, cur int\\n\\twl := len(word)\\n\\tfor i := 0; i <= len(seq)-wl; i++ {\\n\\t\\tif seq[i:i+wl] == word {\\n\\t\\t\\tcur++\\n\\t\\t\\ti += wl - 1\\n\\t\\t} else {\\n\\t\\t\\ti -= cur * wl\\n\\t\\t\\tcur = 0\\n\\n\\t\\t}\\n\\t\\tif cur > mx {\\n\\t\\t\\tmx = cur\\n\\t\\t}\\n\\t}\\n\\treturn mx\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162047,
                "title": "simple-clean-java-solution-for-slow-learners-like-myself",
                "content": "Runtime: O(n^2)\\n\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        sequence = sequence == null ? \"\" : sequence;\\n        word = word == null ? \"\" : word;\\n        \\n        int i = 0, max = 0;\\n        \\n        for (; i + word.length() <= sequence.length(); i++) {\\n            int count = 0;\\n            for (int j = i; sequence.startsWith(word, j); j += word.length())\\n                count++;\\n            \\n            max = Math.max(max, count);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        sequence = sequence == null ? \"\" : sequence;\\n        word = word == null ? \"\" : word;\\n        \\n        int i = 0, max = 0;\\n        \\n        for (; i + word.length() <= sequence.length(); i++) {\\n            int count = 0;\\n            for (int j = i; sequence.startsWith(word, j); j += word.length())\\n                count++;\\n            \\n            max = Math.max(max, count);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991458,
                "title": "java-o-n-kmp-dp",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int m = word.length(), n = sequence.length();\\n \\xA0 \\xA0 \\xA0 \\xA0// Find LP\\n        int[] dp = new int[m];\\n        char[] w = word.toCharArray();\\n        for(int i = 0, j = 1; j < m;) {\\n            if(w[i] == w[j]) {\\n                dp[j++] = ++i;\\n            } else if(i == 0) {\\n                j++;\\n            } else {\\n                i = dp[i-1];\\n            }\\n        }\\n        // Standard KMP with an array to record then number of repeating seq\\n        char[] s = sequence.toCharArray();\\n        int res = 0;\\n        int[] count = new int[n+1];\\n        for(int i = 0, j = 0; i < n;) {\\n            if(s[i] != w[j]) {\\n                if(j == 0) {\\n                    i++;\\n                } else {\\n                    j = dp[j-1];                \\n                }\\n            } else if(j == m-1) {\\n                count[i+1] = count[i - j] + 1;\\n                res = Math.max(res, count[i+1]);\\n                if(j == 0) {\\n                    i++;\\n                } else {\\n                    j = dp[j-1];\\n                }\\n            } else {\\n                i++;\\n                j++;            \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nKMP is really just a standard KMP. A count array is the only thing that needs to be added.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int m = word.length(), n = sequence.length();\\n \\xA0 \\xA0 \\xA0 \\xA0// Find LP\\n        int[] dp = new int[m];\\n        char[] w = word.toCharArray();\\n        for(int i = 0, j = 1; j < m;) {\\n            if(w[i] == w[j]) {\\n                dp[j++] = ++i;\\n            } else if(i == 0) {\\n                j++;\\n            } else {\\n                i = dp[i-1];\\n            }\\n        }\\n        // Standard KMP with an array to record then number of repeating seq\\n        char[] s = sequence.toCharArray();\\n        int res = 0;\\n        int[] count = new int[n+1];\\n        for(int i = 0, j = 0; i < n;) {\\n            if(s[i] != w[j]) {\\n                if(j == 0) {\\n                    i++;\\n                } else {\\n                    j = dp[j-1];                \\n                }\\n            } else if(j == m-1) {\\n                count[i+1] = count[i - j] + 1;\\n                res = Math.max(res, count[i+1]);\\n                if(j == 0) {\\n                    i++;\\n                } else {\\n                    j = dp[j-1];\\n                }\\n            } else {\\n                i++;\\n                j++;            \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989556,
                "title": "python-4-line-easy",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        l = len(sequence) // len(word)\\n        for i in range(l, -1, -1):\\n            if word * i in sequence:\\n                return i\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        l = len(sequence) // len(word)\\n        for i in range(l, -1, -1):\\n            if word * i in sequence:\\n                return i\\n",
                "codeTag": "Java"
            },
            {
                "id": 964982,
                "title": "javascript-1-line-recursive-solution",
                "content": "> Runtime: *80 ms*, faster than **75.16%** of JavaScript online submissions\\n> Memory Usage: *38.7 MB*, less than **53.59%** of JavaScript online submissions\\n\\n```javascript\\nconst maxRepeating = (sequence, word, needle = \\'\\') =>\\n !sequence.includes(`${needle}${word}`)\\n   ? needle.length / word.length\\n   : maxRepeating(sequence, word, `${needle}${word}`);\\n```\\n\\nAnd this obvious variant has about the same performance.\\n\\n> Runtime: *80 ms*, faster than **75.16%** of JavaScript online submissions\\n> Memory Usage: *38.7 MB*, less than **53.59%** of JavaScript online submissions\\n\\n```javascript\\nconst maxRepeating = (sequence, word, cnt = 0) =>\\n  !sequence.includes(word.repeat(cnt + 1))\\n    ? cnt\\n    : maxRepeating(sequence, word, cnt + 1);\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nconst maxRepeating = (sequence, word, needle = \\'\\') =>\\n !sequence.includes(`${needle}${word}`)\\n   ? needle.length / word.length\\n   : maxRepeating(sequence, word, `${needle}${word}`);\\n```\n```javascript\\nconst maxRepeating = (sequence, word, cnt = 0) =>\\n  !sequence.includes(word.repeat(cnt + 1))\\n    ? cnt\\n    : maxRepeating(sequence, word, cnt + 1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952681,
                "title": "python-a-simple-brute-force-solution-using-membership-operator",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        count = 0\\n        while word * (count + 1) in sequence:\\n            count +=  1        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        count = 0\\n        while word * (count + 1) in sequence:\\n            count +=  1        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952451,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {string} sequence\\n * @param {string} word\\n * @return {number}\\n */\\nconst maxRepeating = function(sequence, word) {\\n  let str = word\\n\\n  for (let i = 1; ; i++) {\\n   if(!sequence.includes(str)) {\\n     return i - 1\\n   }\\n\\n   str += word\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sequence\\n * @param {string} word\\n * @return {number}\\n */\\nconst maxRepeating = function(sequence, word) {\\n  let str = word\\n\\n  for (let i = 1; ; i++) {\\n   if(!sequence.includes(str)) {\\n     return i - 1\\n   }\\n\\n   str += word\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952084,
                "title": "java-o-n",
                "content": "```\\npublic int maxRepeating(String sequence, String word) {\\n\\tint result = 0, currentRepeatation = 0, j =0, previousI = 0;\\n\\tfor (int i=0; i<sequence.length(); i++) {\\n\\t\\tif (sequence.charAt(i) != word.charAt(j)) {\\n\\t\\t\\tif (currentRepeatation == 0) {\\n\\t\\t\\t\\tif (j != 0) {\\n\\t\\t\\t\\t\\ti = i - j + 1;\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = previousI + 1;\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\tcurrentRepeatation = 0;\\n\\t\\t\\t}\\n\\t\\t\\tpreviousI = i;\\n\\t\\t}\\n\\t\\tif(sequence.charAt(i) == word.charAt(j) && ++j==word.length()) {\\n\\t\\t\\tj=0;\\n\\t\\t\\tresult = Math.max(result, ++currentRepeatation);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\nAccepted alternative solution\\n```\\npublic int maxRepeating(String sequence, String word) {\\n\\tint result = 0, currentRepeatation = 0;\\n\\tint [] prefix = new int[word.length()];\\n\\tfor(int i=1, j=0; i<word.length(); i++)\\n\\t\\tif (word.charAt(i) == word.charAt(j)) prefix[i] = ++j;\\n\\t\\telse j=0;\\n\\tint tempI = 0, tempJ = 0;\\n\\tfor (int i=0, j=0; i<sequence.length(); i++) {\\n\\t\\tif (currentRepeatation == 0)\\n\\t\\t\\twhile (j != 0 && sequence.charAt(i) != word.charAt(j))\\n\\t\\t\\t\\tj = prefix[j-1];\\n\\t\\telse if(sequence.charAt(i) != word.charAt(j)) {\\n\\t\\t\\tcurrentRepeatation = 0;\\n\\t\\t\\ti = tempI + 1;\\n\\t\\t\\tj = prefix[tempJ - 1];\\n\\t\\t}\\n\\t\\tif(sequence.charAt(i) == word.charAt(j) && ++j==word.length()) {\\n\\t\\t\\ttempI = i;\\n\\t\\t\\ttempJ = j;\\n\\t\\t\\tj=0;\\n\\t\\t\\tresult = Math.max(result, ++currentRepeatation);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxRepeating(String sequence, String word) {\\n\\tint result = 0, currentRepeatation = 0, j =0, previousI = 0;\\n\\tfor (int i=0; i<sequence.length(); i++) {\\n\\t\\tif (sequence.charAt(i) != word.charAt(j)) {\\n\\t\\t\\tif (currentRepeatation == 0) {\\n\\t\\t\\t\\tif (j != 0) {\\n\\t\\t\\t\\t\\ti = i - j + 1;\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = previousI + 1;\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\tcurrentRepeatation = 0;\\n\\t\\t\\t}\\n\\t\\t\\tpreviousI = i;\\n\\t\\t}\\n\\t\\tif(sequence.charAt(i) == word.charAt(j) && ++j==word.length()) {\\n\\t\\t\\tj=0;\\n\\t\\t\\tresult = Math.max(result, ++currentRepeatation);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\n```\\npublic int maxRepeating(String sequence, String word) {\\n\\tint result = 0, currentRepeatation = 0;\\n\\tint [] prefix = new int[word.length()];\\n\\tfor(int i=1, j=0; i<word.length(); i++)\\n\\t\\tif (word.charAt(i) == word.charAt(j)) prefix[i] = ++j;\\n\\t\\telse j=0;\\n\\tint tempI = 0, tempJ = 0;\\n\\tfor (int i=0, j=0; i<sequence.length(); i++) {\\n\\t\\tif (currentRepeatation == 0)\\n\\t\\t\\twhile (j != 0 && sequence.charAt(i) != word.charAt(j))\\n\\t\\t\\t\\tj = prefix[j-1];\\n\\t\\telse if(sequence.charAt(i) != word.charAt(j)) {\\n\\t\\t\\tcurrentRepeatation = 0;\\n\\t\\t\\ti = tempI + 1;\\n\\t\\t\\tj = prefix[tempJ - 1];\\n\\t\\t}\\n\\t\\tif(sequence.charAt(i) == word.charAt(j) && ++j==word.length()) {\\n\\t\\t\\ttempI = i;\\n\\t\\t\\ttempJ = j;\\n\\t\\t\\tj=0;\\n\\t\\t\\tresult = Math.max(result, ++currentRepeatation);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952063,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string str = word;\\n        int N = sequence.length()/word.length();\\n        int cnt = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (sequence.find(str) == string::npos) {\\n                break;\\n            }\\n            str += word;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string str = word;\\n        int N = sequence.length()/word.length();\\n        int cnt = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (sequence.find(str) == string::npos) {\\n                break;\\n            }\\n            str += word;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952050,
                "title": "python-short-using-count",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        result = sequence.count(word)\\n        check_word = word*result\\n        while(check_word not in sequence):\\n            result-=1\\n            check_word = word * result\\n        return result\\n        \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        result = sequence.count(word)\\n        check_word = word*result\\n        while(check_word not in sequence):\\n            result-=1\\n            check_word = word * result\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 952039,
                "title": "javascript-easy-clear",
                "content": "loops through (almost) every letter to find match and updates the max repeating times\\n\\ns=\"**ab**cc**ababab**cc**abab**\"  w=\"ab\"\\nmax = 1 -> 3 -> 3\\n\\n```\\nvar maxRepeating = function(sequence, word) {\\n    let count = 0;\\n    let start = 0;\\n    let max = 0;\\n    \\n    while (start+word.length <= sequence.length) {\\n        let end = start+word.length;\\n        \\n        if (sequence.slice(start,end) !== word) {\\n            start++;\\n            count = 0;\\n        } else {\\n            count++;\\n            max = Math.max(max,count);\\n            start+=word.length;\\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxRepeating = function(sequence, word) {\\n    let count = 0;\\n    let start = 0;\\n    let max = 0;\\n    \\n    while (start+word.length <= sequence.length) {\\n        let end = start+word.length;\\n        \\n        if (sequence.slice(start,end) !== word) {\\n            start++;\\n            count = 0;\\n        } else {\\n            count++;\\n            max = Math.max(max,count);\\n            start+=word.length;\\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781599,
                "title": "most-easy-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count = 0;\\n        string temp = word;\\n        while(sequence.find(temp) != string::npos) {\\n            count++;\\n            temp += word;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count = 0;\\n        string temp = word;\\n        while(sequence.find(temp) != string::npos) {\\n            count++;\\n            temp += word;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928527,
                "title": "rust-from-c-using-contains",
                "content": "Inspired by this solution : https://leetcode.com/problems/maximum-repeating-substring/solutions/1164988/rust-short-solution/\\n\\n```\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        let mut count = 0;\\n        let mut tmp = word.clone();\\n\\n        while(sequence.contains(&tmp)) {\\n            tmp.push_str(&word);\\n            count += 1;\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        let mut count = 0;\\n        let mut tmp = word.clone();\\n\\n        while(sequence.contains(&tmp)) {\\n            tmp.push_str(&word);\\n            count += 1;\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819363,
                "title": "c-easy-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count=0;\\n        string temp=word;\\n        while(sequence.find(temp)!=string::npos)\\n        {\\n            count++;\\n            temp+=word;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count=0;\\n        string temp=word;\\n        while(sequence.find(temp)!=string::npos)\\n        {\\n            count++;\\n            temp+=word;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403876,
                "title": "binarysearch-and-kmp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool kmp(string &sequence, string &mainWord,int rep){\\n\\t\\t\\tstring word;\\n\\t\\t\\tfor(int i=0;i<rep;i++){\\n\\t\\t\\t\\tword+=mainWord;\\n\\t\\t\\t}\\n\\t\\t\\t//cout<<word<<endl;\\n\\t\\t\\tint m=word.size();\\n\\t\\t\\tint n=sequence.size();\\n\\t\\t\\tvector<int>longest(m);\\n\\t\\t\\tfor(int i=1,k=0;i<m;i++){\\n\\t\\t\\t\\twhile(k>0&&word[k]!=word[i])k=longest[k-1];\\n\\t\\t\\t\\tif(word[k]==word[i])\\n\\t\\t\\t\\t\\tlongest[i]=++k;\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\tlongest[i]=k;\\n\\t\\t\\t}\\n\\t\\t   for(int i=0,k=0;i<n;i++){\\n\\t\\t\\t\\twhile(k>0&&word[k]!=sequence[i])k=longest[k-1];\\n\\n\\t\\t\\t\\tif(word[k]==sequence[i])\\n\\t\\t\\t\\t\\t++k;\\n\\t\\t\\t\\tif(k==m)return 1;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint maxRepeating(string sequence, string word) {\\n\\t\\t\\tint szS=sequence.size(),szW=word.size();\\n\\t\\t\\tint l=1,r=szS/szW,ans=0;\\n\\t\\t\\twhile(l<=r){\\n\\t\\t\\t\\tint mid=(r+l)/2;\\n\\t\\t\\t\\tint isPossibleMid=kmp(sequence,word,mid);\\n\\t\\t\\t\\tif(isPossibleMid)l=mid+1,ans=mid;\\n\\t\\t\\t\\telse r=mid-1;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool kmp(string &sequence, string &mainWord,int rep){\\n\\t\\t\\tstring word;\\n\\t\\t\\tfor(int i=0;i<rep;i++){\\n\\t\\t\\t\\tword+=mainWord;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2356628,
                "title": "short-and-simple-code-c",
                "content": "```\\nint maxRepeating(string sequence, string word) \\n    {\\n        \\n        string s=word;\\n        int c=0;\\n        \\n        while(sequence.find(s)!=string::npos)\\n        {\\n            c++;\\n            s=s+word;\\n        }\\n        \\n        return c;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxRepeating(string sequence, string word) \\n    {\\n        \\n        string s=word;\\n        int c=0;\\n        \\n        while(sequence.find(s)!=string::npos)\\n        {\\n            c++;\\n            s=s+word;\\n        }\\n        \\n        return c;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2262204,
                "title": "rust-solution",
                "content": "```\\npub fn max_repeating(sequence: String, word: String) -> i32 {\\n\\tlet mut buffer = word.clone();\\n\\tlet mut count = 0;\\n\\n\\tlet mut index = 1;\\n\\tlet length = sequence.len() / word.len();\\n\\n\\twhile index <= length {\\n\\t\\tif sequence.contains(&buffer) {\\n\\t\\t\\tindex += 1;\\n\\t\\t\\tcount += 1;\\n\\t\\t\\tbuffer.push_str(word.as_str());\\n\\t\\t} else {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}\\n\\n\\tcount\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn max_repeating(sequence: String, word: String) -> i32 {\\n\\tlet mut buffer = word.clone();\\n\\tlet mut count = 0;\\n\\n\\tlet mut index = 1;\\n\\tlet length = sequence.len() / word.len();\\n\\n\\twhile index <= length {\\n\\t\\tif sequence.contains(&buffer) {\\n\\t\\t\\tindex += 1;\\n\\t\\t\\tcount += 1;\\n\\t\\t\\tbuffer.push_str(word.as_str());\\n\\t\\t} else {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}\\n\\n\\tcount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2243159,
                "title": "python-search-from-the-largest-k-first",
                "content": "**Solution**:\\n    The question asks us to find k where k is the largest multiple of a word concanated together that exists in the sequence. We will start by determine the largest k possible. Then, we form a target which is a multiple concatenation of the word from k times to 0 times. If the target exists in the string, return k. At k = 0, it will always true as an empty string is always a part of the other string.\\n\\n**Complexity**:\\n    Time: O(kn) where k is the longest multiple of the work that result in the longest substring and n is the length of the sequence. \\n    Space: O(1)\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n\\n        # Find the largest k\\n        k = len(sequence) // len(word)\\n\\n        # Search from k until 0\\n        while True:\\n\\n            # If k multiple of a word concatenated together exists in the sequence, return k\\n            if word * k in sequence:\\n                return k\\n\\n            # Decrement k\\n            k -= 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n\\n        # Find the largest k\\n        k = len(sequence) // len(word)\\n\\n        # Search from k until 0\\n        while True:\\n\\n            # If k multiple of a word concatenated together exists in the sequence, return k\\n            if word * k in sequence:\\n                return k\\n\\n            # Decrement k\\n            k -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192570,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        for i in range(len(sequence)//len(word)+1,0,-1):\\n            if i*word in sequence:\\n                return i\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        for i in range(len(sequence)//len(word)+1,0,-1):\\n            if i*word in sequence:\\n                return i\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166969,
                "title": "java-0ms-100-fast",
                "content": "Do upvote for my solution if it hepls you :)\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n     \\n        int count=0;\\n        int idx=0;\\n        int max=0;\\n        \\n        for(int i=0;i<=sequence.length()-word.length();i++){\\n            count=0; idx=0;\\n            for(int j=i;j<sequence.length();j++){\\n                \\n                if(sequence.charAt(j)==word.charAt(idx)){\\n                    idx++;\\n                }\\n                else break;\\n                if(idx==word.length()){\\n                    idx=0;\\n                    count++;\\n                }                \\n            }\\n            max=Math.max(max,count);\\n        }\\n        return max;\\n    }\\n}\\n    \\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n     \\n        int count=0;\\n        int idx=0;\\n        int max=0;\\n        \\n        for(int i=0;i<=sequence.length()-word.length();i++){\\n            count=0; idx=0;\\n            for(int j=i;j<sequence.length();j++){\\n                \\n                if(sequence.charAt(j)==word.charAt(idx)){\\n                    idx++;\\n                }\\n                else break;\\n                if(idx==word.length()){\\n                    idx=0;\\n                    count++;\\n                }                \\n            }\\n            max=Math.max(max,count);\\n        }\\n        return max;\\n    }\\n}\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125898,
                "title": "java-3-line-soln-98-fast",
                "content": "```\\n\\t\\tint ans = 1;\\n        while (s.contains(word.repeat(ans)))  ++ans;\\n        return ans - 1;```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint ans = 1;\\n        while (s.contains(word.repeat(ans)))  ++ans;\\n        return ans - 1;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2110072,
                "title": "python-solution-easy-understanding",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n\\t    # n is the possible most repeating unit\\n        n = len(sequence) // len(word)\\n        while n:\\n            if word * n in sequence:\\n                return n\\n            n -= 1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n\\t    # n is the possible most repeating unit\\n        n = len(sequence) // len(word)\\n        while n:\\n            if word * n in sequence:\\n                return n\\n            n -= 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079507,
                "title": "c-python-easy-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int l = word.length();\\n        int m = sequence.length();\\n        if(sequence==word) return 1;\\n        int ma=0,c;\\n        for(int i=0; i<=m-l; ++i){\\n            c=0;\\n            for(int j=i; j<m; j += l){\\n                string t = sequence.substr(j,l);\\n                if(t == word){\\n                    c++;\\n                }\\n                else break;\\n            }\\n            ma = max(ma,c);\\n        }\\n        return ma;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        l,m = len(word), len(sequence)\\n        if(sequence==word): return 1\\n        ma=0\\n        for i in range(m-l+1):\\n            c=0\\n            for j in range(i,m,l):\\n                t = sequence[j:l+j]\\n                if(t == word):\\n                    c += 1\\n                else: break\\n            ma = max(ma,c)\\n        return ma\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int l = word.length();\\n        int m = sequence.length();\\n        if(sequence==word) return 1;\\n        int ma=0,c;\\n        for(int i=0; i<=m-l; ++i){\\n            c=0;\\n            for(int j=i; j<m; j += l){\\n                string t = sequence.substr(j,l);\\n                if(t == word){\\n                    c++;\\n                }\\n                else break;\\n            }\\n            ma = max(ma,c);\\n        }\\n        return ma;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        l,m = len(word), len(sequence)\\n        if(sequence==word): return 1\\n        ma=0\\n        for i in range(m-l+1):\\n            c=0\\n            for j in range(i,m,l):\\n                t = sequence[j:l+j]\\n                if(t == word):\\n                    c += 1\\n                else: break\\n            ma = max(ma,c)\\n        return ma\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013781,
                "title": "c-o-n-n-m-time-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string &sequence, string &word) {\\n        string tmp = word;\\n        int cnt{};\\n        while(tmp.size() <= sequence.size()){\\n            if(sequence.find(tmp) != string::npos)\\n                cnt++;\\n            tmp += word;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nCheck\\nhttps://leetcode.com/problems/maximum-repeating-substring/discuss/2013762/C%2B%2B-oror-O(n)-oror-2-scans\\nfor a more efficient but complicated solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string &sequence, string &word) {\\n        string tmp = word;\\n        int cnt{};\\n        while(tmp.size() <= sequence.size()){\\n            if(sequence.find(tmp) != string::npos)\\n                cnt++;\\n            tmp += word;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977866,
                "title": "2-easy-solution-using-python-easy-understanding",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        \"\"\"\\n        python solution using while loop\\n        \\n        max_count = 0\\n        string = word\\n        while True:\\n            if string in sequence:\\n                max_count += 1\\n                string += word\\n            else:\\n                break\\n        return max_count    \\n        \\n        \"\"\"\\n        \\n        # pthon solution using binary search\\n        \\n        result = 0\\n        l = len(word)\\n        left = 0\\n        right = len(sequence)\\n        while(left<=right):\\n            mid = (left + right) // 2\\n            x = mid * word\\n            if x in sequence:\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        \"\"\"\\n        python solution using while loop\\n        \\n        max_count = 0\\n        string = word\\n        while True:\\n            if string in sequence:\\n                max_count += 1\\n                string += word\\n            else:\\n                break\\n        return max_count    \\n        \\n        \"\"\"\\n        \\n        # pthon solution using binary search\\n        \\n        result = 0\\n        l = len(word)\\n        left = 0\\n        right = len(sequence)\\n        while(left<=right):\\n            mid = (left + right) // 2\\n            x = mid * word\\n            if x in sequence:\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904774,
                "title": "python-94-faster",
                "content": "```\\n\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        max_count = 0\\n        increased_string = word\\n        while True:\\n            if increased_string in sequence:\\n                max_count +=1\\n                increased_string +=word\\n            else:\\n                break\\n        return max_count\\n\\t\\t\\n\\t\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        max_count = 0\\n        increased_string = word\\n        while True:\\n            if increased_string in sequence:\\n                max_count +=1\\n                increased_string +=word\\n            else:\\n                break\\n        return max_count\\n\\t\\t\\n\\t\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1864844,
                "title": "please-clarify-how-aaabaaaabaaabaaaabaaaabaaaabaaaaba-for-substring-aaaba-result-is-5",
                "content": "Anyone please clarify how the result will be 5 rather then 6",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1843097,
                "title": "java-kmp-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int maxRepeating(String seq, String word) {\\n\\t\\t\\tint result = 0;\\n\\t\\t\\tString words = word;\\n\\n\\t\\t\\twhile (KMP(seq, words) > 0) {\\n\\t\\t\\t\\twords += word;\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tpublic int[] longPrefSubs(String s) {\\n\\t\\t\\tint mas[] = new int[s.length()];\\n\\t\\t\\tint j = 0;\\n\\t\\t\\tfor (int i = 1; i < mas.length; i++) {\\n\\t\\t\\t\\tif (s.charAt(i) != s.charAt(j))\\n\\t\\t\\t\\t\\twhile (j > 0 && s.charAt(i) != s.charAt(j))\\n\\t\\t\\t\\t\\t\\tj = mas[j - 1];\\n\\n\\t\\t\\t\\tif (s.charAt(i) == s.charAt(j))\\n\\t\\t\\t\\t\\tmas[i] = ++j;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn mas;\\n\\t\\t}\\n\\n\\t\\tpublic int KMP(String seq, String word) {\\n\\t\\t\\tif (seq.length() < word.length())\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint mas[] = longPrefSubs(word);\\n\\t\\t\\tint j = 0;\\n\\t\\t\\tfor (int i = 0; i < seq.length(); i++) {\\n\\t\\t\\t\\tif (word.length() - j > seq.length() - i)\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\tif (seq.charAt(i) != word.charAt(j)) {\\n\\t\\t\\t\\t\\twhile (j > 0 && word.charAt(j) != seq.charAt(i))\\n\\t\\t\\t\\t\\t\\tj = mas[j - 1];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (seq.charAt(i) == word.charAt(j))\\n\\t\\t\\t\\t\\tj++;\\n\\n\\t\\t\\t\\tif (j == word.length()) {\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int maxRepeating(String seq, String word) {\\n\\t\\t\\tint result = 0;\\n\\t\\t\\tString words = word;\\n\\n\\t\\t\\twhile (KMP(seq, words) > 0) {\\n\\t\\t\\t\\twords += word;\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1831215,
                "title": "java-binarysearch-simple",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int l = 1;\\n        int r = sequence.length() / word.length();\\n        int answer = 0;\\n        while (l <= r) {\\n            int midLen = (l + r) / 2;   //  l + (r - l) / 2;\\n            String kConcat = concat(word, midLen);\\n            if (isSubString(sequence, kConcat)) {\\n                l = midLen + 1;\\n                answer = midLen;\\n            } else {\\n                r = midLen - 1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public String concat(String s, int k) {\\n        StringBuilder res = new StringBuilder(\"\");\\n        for (int i = 0; i < k; i++) {\\n            res.append(s);\\n        }\\n        return res.toString();\\n    }\\n    \\n    //  is t a substring of s\\n    public boolean isSubString(String s, String t) {\\n        if (t.length() > s.length()) {\\n            return false;\\n        }\\n        int l = 0;\\n        int r = t.length();\\n        while (r <= s.length()) {\\n            if (s.substring(l, r).equals(t)) {\\n                return true;\\n            }\\n            l++;\\n            r++;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int l = 1;\\n        int r = sequence.length() / word.length();\\n        int answer = 0;\\n        while (l <= r) {\\n            int midLen = (l + r) / 2;   //  l + (r - l) / 2;\\n            String kConcat = concat(word, midLen);\\n            if (isSubString(sequence, kConcat)) {\\n                l = midLen + 1;\\n                answer = midLen;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1798591,
                "title": "python3-solution-87-lesser-memory",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c = 0\\n        for i in range(1,len(sequence)//len(word)+1):\\n            if word*i in sequence:\\n                c += 1\\n                continue\\n            break\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c = 0\\n        for i in range(1,len(sequence)//len(word)+1):\\n            if word*i in sequence:\\n                c += 1\\n                continue\\n            break\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780810,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        \"\"\"\\n        :type sequence: str\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        ret=0\\n        s=word\\n        while(word in sequence):\\n            ret+=1\\n            word+=s\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        \"\"\"\\n        :type sequence: str\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        ret=0\\n        s=word\\n        while(word in sequence):\\n            ret+=1\\n            word+=s\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744280,
                "title": "simple-scala-solution",
                "content": "```\\ndef maxRepeating(sequence: String, word: String): Int = {\\n    def go(count: Int): Int = {\\n      if (sequence.contains((word * count).mkString)) go(count + 1)\\n      else count - 1\\n    }\\n    go(0)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef maxRepeating(sequence: String, word: String): Int = {\\n    def go(count: Int): Int = {\\n      if (sequence.contains((word * count).mkString)) go(count + 1)\\n      else count - 1\\n    }\\n    go(0)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1722457,
                "title": "python-3-short-and-clean-using-find",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n=len(sequence)\\n        m=len(word)\\n        c=0\\n        for i in range(1,(n//m)+1):\\n            s=word*i\\n            if sequence.find(s)!=-1:\\n                c=i\\n        return c \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n=len(sequence)\\n        m=len(word)\\n        c=0\\n        for i in range(1,(n//m)+1):\\n            s=word*i\\n            if sequence.find(s)!=-1:\\n                c=i\\n        return c \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698765,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k = 0\\n        while word * (k + 1) in sequence:\\n            k += 1\\n\\n        return k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k = 0\\n        while word * (k + 1) in sequence:\\n            k += 1\\n\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491680,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String seq, String word) {\\n        int k = 0;\\n        StringBuilder str = new StringBuilder(word);\\n        while (str.toString().length() <= seq.length()) {\\n            if (seq.contains(str.toString())) {\\n                str.append(word);\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String seq, String word) {\\n        int k = 0;\\n        StringBuilder str = new StringBuilder(word);\\n        while (str.toString().length() <= seq.length()) {\\n            if (seq.contains(str.toString())) {\\n                str.append(word);\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488920,
                "title": "python3-kmp-string-search-with-o-n",
                "content": "My solution uses [KMP](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm) with a time complexity of ```O(len(sequence))``` and a space complexity of ```O(len(word))```\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        #we need two words for matching to cover parts of the start of the word with its end\\n        word2=word*2\\n\\n        #build partial match table\\n        backtracking=[0]        \\n        j= 0\\n        for i in range(1,len(word2)):\\n            while j > 0 and word2[i] != word2[j]:\\n                j= backtracking[j-1]\\n            if word2[i] == word2[j]:\\n                j+= 1\\n            backtracking.append(j)      \\n        \\n        #run the search itself\\n        aktk= 0\\n        maxk= 0\\n        j= 0\\n        for i in range(len(sequence)):\\n            while sequence[i] != word2[j]:\\n                #mismatch\\n                aktk= 0\\n                if j == 0:\\n                    break\\n                j= backtracking[j-1]\\n                \\n            if sequence[i] == word2[j]:\\n                j+= 1\\n\\n            if j != 0 and j%len(word) == 0:\\n                #match\\n                aktk+= 1\\n                maxk= max(maxk,aktk)\\n                j= len(word)\\n                \\n        return maxk\\n```",
                "solutionTags": [],
                "code": "```O(len(sequence))```\n```O(len(word))```\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        #we need two words for matching to cover parts of the start of the word with its end\\n        word2=word*2\\n\\n        #build partial match table\\n        backtracking=[0]        \\n        j= 0\\n        for i in range(1,len(word2)):\\n            while j > 0 and word2[i] != word2[j]:\\n                j= backtracking[j-1]\\n            if word2[i] == word2[j]:\\n                j+= 1\\n            backtracking.append(j)      \\n        \\n        #run the search itself\\n        aktk= 0\\n        maxk= 0\\n        j= 0\\n        for i in range(len(sequence)):\\n            while sequence[i] != word2[j]:\\n                #mismatch\\n                aktk= 0\\n                if j == 0:\\n                    break\\n                j= backtracking[j-1]\\n                \\n            if sequence[i] == word2[j]:\\n                j+= 1\\n\\n            if j != 0 and j%len(word) == 0:\\n                #match\\n                aktk+= 1\\n                maxk= max(maxk,aktk)\\n                j= len(word)\\n                \\n        return maxk\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433789,
                "title": "python3-two-pointers-solution-beat-98-9",
                "content": "Solution 1: using two pointers to iterate and find pattern. Time O(n^2)\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        maxk = 0\\n        i = 0\\n        while i < len(sequence) - len(word) +1:\\n            j = i\\n            k = 0\\n            while j < len(sequence) - len(word) +1 and sequence[j:j+len(word)] == word:\\n                j += len(word)\\n                k += 1\\n            maxk = max(maxk, k)\\n            i += 1\\n        return maxk\\n```\\nSolution 2: use Python built in function, beat 78%. \\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        k = 0\\n        while word * (k+1) in sequence:\\n            k += 1\\n        return k\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        maxk = 0\\n        i = 0\\n        while i < len(sequence) - len(word) +1:\\n            j = i\\n            k = 0\\n            while j < len(sequence) - len(word) +1 and sequence[j:j+len(word)] == word:\\n                j += len(word)\\n                k += 1\\n            maxk = max(maxk, k)\\n            i += 1\\n        return maxk\\n```\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        k = 0\\n        while word * (k+1) in sequence:\\n            k += 1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366043,
                "title": "python3",
                "content": "class Solution:\\n\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k=1\\n        while True:\\n            if word*k in sequence:\\n                k+=1\\n            else:\\n                break\\n        return k-1",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k=1\\n        while True:\\n            if word*k in sequence:\\n                k+=1\\n            else:\\n                break\\n        return k-1",
                "codeTag": "Java"
            },
            {
                "id": 1357665,
                "title": "kmp-true-o-n",
                "content": "Intuition:\\nFor understanding KMP algorithm in general, please check some standard site.\\nHere i will explain how i applied KMP to this problem.\\nsuppose sequence = ababc \\nword = ab\\nI created a string in which word can occur maximum number of time. i.e. abab \\nthen i created a string abab#ababc to separate the prefix with the sequence. \\nNow i created the lps sequence from the above string. \\nlps = [0, 0, 1, 2, 0, 1, 2, 3, 4, 0]\\nWhile creating the lps array i am also checking from index 5 to last index i.e for ababc part., what is the max lps value we obtained. \\nHere its 4. so 4//len(word) will give us the answer.\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        cnt = len(sequence)//len(word)\\n        repeat = word * cnt\\n        newstr = repeat + \\'#\\' + sequence\\n        lps = [0]\\n        maxi = 0\\n        for i in range(1, len(newstr)):\\n            x = lps[-1]\\n            while newstr[x] != newstr[i]:\\n                if x == 0:\\n                    x = -1\\n                    break\\n                x = lps[x-1]\\n            lps.append(x+1)\\n            if i>=len(repeat):\\n                maxi = max(maxi, x+1)\\n        return maxi//len(word)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        cnt = len(sequence)//len(word)\\n        repeat = word * cnt\\n        newstr = repeat + \\'#\\' + sequence\\n        lps = [0]\\n        maxi = 0\\n        for i in range(1, len(newstr)):\\n            x = lps[-1]\\n            while newstr[x] != newstr[i]:\\n                if x == 0:\\n                    x = -1\\n                    break\\n                x = lps[x-1]\\n            lps.append(x+1)\\n            if i>=len(repeat):\\n                maxi = max(maxi, x+1)\\n        return maxi//len(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318440,
                "title": "java-0ms-beats-100-fast-and-easy-to-understand",
                "content": "I hope its straight forward. enjoy!\\n```\\nclass Solution {\\n    public int maxRepeating(String s, String word) {\\n        StringBuilder sb = new StringBuilder(word);\\n        int k=0;\\n        while(s.indexOf(sb.toString())!=-1){\\n            k++;\\n            sb.append(word);\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String s, String word) {\\n        StringBuilder sb = new StringBuilder(word);\\n        int k=0;\\n        while(s.indexOf(sb.toString())!=-1){\\n            k++;\\n            sb.append(word);\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282041,
                "title": "python",
                "content": "\\tclass Solution:\\n\\t\\tdef maxRepeating(self, sequence: str, word: str) -> int:\\n\\t\\t\\ti = 1\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif word*i in sequence:\\n\\t\\t\\t\\t\\t# print(word*i,\"  \",i)\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn i-1\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxRepeating(self, sequence: str, word: str) -> int:\\n\\t\\t\\ti = 1\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif word*i in sequence:\\n\\t\\t\\t\\t\\t# print(word*i,\"  \",i)\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn i-1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1272386,
                "title": "python3-using-regex",
                "content": "\\tclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        x=len(re.findall(word,sequence))\\n        for i in range(1,x+2):\\n            if not re.findall(word*i,sequence):\\n                return(i-1)\\n                \\n**If u like this solution,Please upvote for this:)**\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        x=len(re.findall(word,sequence))\\n        for i in range(1,x+2):\\n            if not re.findall(word*i,sequence):\\n                return(i-1)\\n                \\n**If u like this solution,Please upvote for this:)**\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1267746,
                "title": "typescript-recursive-solution",
                "content": "```\\nfunction maxRepeating(sequence: string, word: string): number {\\n    return helper(sequence, word, word, 0);\\n};\\n\\nfunction helper(sequence: string, word: string, originalWord: string, count: number): number {\\n    if (sequence.indexOf(word) === -1) {\\n        return count;\\n    }\\n    return helper(sequence, word.concat(originalWord), originalWord, count + 1);\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\nfunction maxRepeating(sequence: string, word: string): number {\\n    return helper(sequence, word, word, 0);\\n};\\n\\nfunction helper(sequence: string, word: string, originalWord: string, count: number): number {\\n    if (sequence.indexOf(word) === -1) {\\n        return count;\\n    }\\n    return helper(sequence, word.concat(originalWord), originalWord, count + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260385,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        x = 0\\n        while True:\\n            if word*(x+1) in sequence:\\n                x += 1\\n            else:\\n                return x\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        x = 0\\n        while True:\\n            if word*(x+1) in sequence:\\n                x += 1\\n            else:\\n                return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249116,
                "title": "python3-simple-3-lines-solution",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i=1\\n        while(word*i in sequence): i+=1\\n        return i-1\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i=1\\n        while(word*i in sequence): i+=1\\n        return i-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231779,
                "title": "kmp-implementation-java",
                "content": "Please find the Java implementation using KMP algorithm.\\n\\n```\\nclass Solution {\\n    \\n    private int kmp (String text, String pattern) {\\n        int m = pattern.length();\\n        int n = text.length();\\n        int i = 0;\\n        int j = 0;\\n        int result = 0;\\n        int lps[] = new int[m];\\n        fillLps(pattern, lps);\\n        \\n        while(i < n && j < m) {\\n            if (pattern.charAt(j) == text.charAt(i)) {\\n                i++;\\n                j++;\\n            } else {\\n                if (j != 0) {\\n                    j = lps[j - 1];\\n                } else {\\n                    i ++;\\n                }\\n            }\\n        }\\n        if (j == m) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n    private void fillLps(String pattern, int[] lps){\\n        int m = pattern.length();\\n        int i = 1;\\n        int len = 0;\\n        lps[0] = 0;\\n        while (i < m) {\\n            if (pattern.charAt(i) == pattern.charAt(len)) {\\n                lps[i] = len + 1;\\n                len ++;\\n                i ++;\\n            } else {\\n                if (len != 0) {\\n                    len = lps [len - 1];\\n                } else {\\n                    lps[i] = 0;\\n                    i ++;\\n                }\\n            } \\n            \\n        }\\n    }\\n    public int maxRepeating(String sequence, String word) {\\n        int result = 0;\\n        String pattern = word;\\n        while (true){\\n            \\n            int count = kmp(sequence, pattern);\\n            pattern += word;\\n            if (count == 0) break;\\n            result += count;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int kmp (String text, String pattern) {\\n        int m = pattern.length();\\n        int n = text.length();\\n        int i = 0;\\n        int j = 0;\\n        int result = 0;\\n        int lps[] = new int[m];\\n        fillLps(pattern, lps);\\n        \\n        while(i < n && j < m) {\\n            if (pattern.charAt(j) == text.charAt(i)) {\\n                i++;\\n                j++;\\n            } else {\\n                if (j != 0) {\\n                    j = lps[j - 1];\\n                } else {\\n                    i ++;\\n                }\\n            }\\n        }\\n        if (j == m) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n    private void fillLps(String pattern, int[] lps){\\n        int m = pattern.length();\\n        int i = 1;\\n        int len = 0;\\n        lps[0] = 0;\\n        while (i < m) {\\n            if (pattern.charAt(i) == pattern.charAt(len)) {\\n                lps[i] = len + 1;\\n                len ++;\\n                i ++;\\n            } else {\\n                if (len != 0) {\\n                    len = lps [len - 1];\\n                } else {\\n                    lps[i] = 0;\\n                    i ++;\\n                }\\n            } \\n            \\n        }\\n    }\\n    public int maxRepeating(String sequence, String word) {\\n        int result = 0;\\n        String pattern = word;\\n        while (true){\\n            \\n            int count = kmp(sequence, pattern);\\n            pattern += word;\\n            if (count == 0) break;\\n            result += count;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228607,
                "title": "python-3-one-line-in-o-n-kind-of",
                "content": "Get the first `i` such that it doesn\\'t repeat `i` times. That means it does repeat `i-1` times.\\n\\nYep, this `O(n^2)`.\\n\\n```python\\nclass Solution:\\n  def maxRepeating(self, sequence: str, word: str) -> int:\\n     return next(i for i in count(1) if word*i not in sequence) - 1\\n```\\n\\nOk, what about `O(n)`?\\n\\nOne approach is to use regex to find all matching substrings.\\n\\nNote that we need to use positive lookahead ... `(?=word)` ... to find all the locations including overlaps.\\n\\nThen, we build a dict to figure out which locations are repeating... if we\\'ve seen the same pattern `len(w)` ago, then it is repeating adjascently.\\n\\n```python\\nclass Solution:\\n  def maxRepeating(self, s: str, w: str) -> int:\\n    seen = {}\\n    for m in finditer(\\'(?=\\' + w + \\')\\', s):\\n      seen[m.start()] = seen.get(m.start() - len(w), 0) + 1\\n    return max(seen.values(), default=0)\\n```\\n\\nUse [reduce](https://docs.python.org/3/library/functools.html#functools.reduce) to convert to one line:\\n\\n```python\\nclass Solution:\\n  def maxRepeating(self, s: str, w: str) -> int:\\n    return max(reduce(lambda z,m: setitem(z, m.start(), z.get(m.start() - len(w), 0) + 1) or z, finditer(\\'(?=\\' + w + \\')\\', s), {}).values(), default=0)\\n```\\n\\nNote that this is usually `O(n)`, but `O(n^2)` for the worst case.\\nConsider:\\n* sequence = \"aaaaaaaa\" (8 a\\'s)\\n* word = \"aaaa\" (4 a\\'s)\\n\\nThen `re.finditer` will need:\\n* 4 operations at index 0\\n* 4 operations at index 1\\n* 4 operations at index 2\\n* 4 operations at index 3\\n* 4 operations at index 4\\n* 3 operations at index 5\\n* 2 operations at index 6\\n* 1 operations at index 7\\n\\nSo for more than half of the iterations, it may perform `n/2` operations.\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def maxRepeating(self, sequence: str, word: str) -> int:\\n     return next(i for i in count(1) if word*i not in sequence) - 1\\n```\n```python\\nclass Solution:\\n  def maxRepeating(self, s: str, w: str) -> int:\\n    seen = {}\\n    for m in finditer(\\'(?=\\' + w + \\')\\', s):\\n      seen[m.start()] = seen.get(m.start() - len(w), 0) + 1\\n    return max(seen.values(), default=0)\\n```\n```python\\nclass Solution:\\n  def maxRepeating(self, s: str, w: str) -> int:\\n    return max(reduce(lambda z,m: setitem(z, m.start(), z.get(m.start() - len(w), 0) + 1) or z, finditer(\\'(?=\\' + w + \\')\\', s), {}).values(), default=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221848,
                "title": "easy-cpp-solution-in-5-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int ans=0;\\n        string cur=word;\\n        while(1)\\n        {\\n            if(sequence.find(cur)!=-1)\\n            {\\n                \\n                ans++;\\n                cur+=word;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int ans=0;\\n        string cur=word;\\n        while(1)\\n        {\\n            if(sequence.find(cur)!=-1)\\n            {\\n                \\n                ans++;\\n                cur+=word;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214665,
                "title": "simple-java-soln",
                "content": "```\\npublic int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        String temp  = word;\\n        int i  = 0;\\n        while(true){\\n            if(sequence.contains(temp)){\\n                temp +=word;\\n                count++;\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n\\t```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\npublic int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        String temp  = word;\\n        int i  = 0;\\n        while(true){\\n            if(sequence.contains(temp)){\\n                temp +=word;\\n                count++;\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1202761,
                "title": "100-in-java-in-o-n-time-complexity-easy-to-understand",
                "content": "class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = -1;\\n        while(sequence.contains(sb.toString())){\\n            count++;\\n            sb.append(word);\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = -1;\\n        while(sequence.contains(sb.toString())){\\n            count++;\\n            sb.append(word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1168909,
                "title": "php-solution",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $sequence\\n     * @param String $word\\n     * @return Integer\\n     */\\n    function maxRepeating($sequence, $word) {\\n        $k = 0;\\n        $newWord = $word;\\n        while (strpos($sequence, $newWord) !== false) {\\n            $k++;\\n            $newWord .= $word;\\n        }\\n\\n        return $k;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $sequence\\n     * @param String $word\\n     * @return Integer\\n     */\\n    function maxRepeating($sequence, $word) {\\n        $k = 0;\\n        $newWord = $word;\\n        while (strpos($sequence, $newWord) !== false) {\\n            $k++;\\n            $newWord .= $word;\\n        }\\n\\n        return $k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136816,
                "title": "javascript-brute-force",
                "content": "```\\nconst maxRepeating = (sequence, word) => {\\n    let pattern = word\\n    \\n    while(true) {\\n        if(!sequence.includes(pattern)) return (pattern.length / word.length) - 1\\n        pattern += word\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxRepeating = (sequence, word) => {\\n    let pattern = word\\n    \\n    while(true) {\\n        if(!sequence.includes(pattern)) return (pattern.length / word.length) - 1\\n        pattern += word\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115457,
                "title": "0-ms-faster-than-100-00-of-java",
                "content": "```\\nclass Solution {\\n  public int maxRepeating(String sequence, String word) {\\n    int count = 0;\\n    StringBuilder stringBuilder = new StringBuilder(word);\\n    while (true) {\\n      int index = sequence.indexOf(stringBuilder.toString());\\n      if (index == -1) break;\\n      count++;\\n      stringBuilder.append(word);\\n    }\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int maxRepeating(String sequence, String word) {\\n    int count = 0;\\n    StringBuilder stringBuilder = new StringBuilder(word);\\n    while (true) {\\n      int index = sequence.indexOf(stringBuilder.toString());\\n      if (index == -1) break;\\n      count++;\\n      stringBuilder.append(word);\\n    }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114709,
                "title": "c-2-lines",
                "content": "Keep concatenating the original word onto itself and try to find it in the sequence. \\n```\\nint maxRepeating(string seq, string word, int res = 0) {\\n\\tfor (string orig = word; seq.find(word) != string::npos; word += orig, ++res);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxRepeating(string seq, string word, int res = 0) {\\n\\tfor (string orig = word; seq.find(word) != string::npos; word += orig, ++res);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110531,
                "title": "java-fastest-0ms-with-comments",
                "content": "```\\nclass Solution {\\n       public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        StringBuilder temp = new StringBuilder(word);\\n        while(true){\\n            int index = sequence.indexOf(temp.toString()); //index of temp\\n            if(index == -1){\\n                break;\\n            }else{\\n                count++;\\n                temp.append(word); //apppend temp and in next turn find index of that if exists increment\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n       public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        StringBuilder temp = new StringBuilder(word);\\n        while(true){\\n            int index = sequence.indexOf(temp.toString()); //index of temp\\n            if(index == -1){\\n                break;\\n            }else{\\n                count++;\\n                temp.append(word); //apppend temp and in next turn find index of that if exists increment\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102650,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        k=len(sequence)//len(word)\\n        for i in range(k,-1,-1):\\n            if word*i in sequence:\\n                return(i)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        k=len(sequence)//len(word)\\n        for i in range(k,-1,-1):\\n            if word*i in sequence:\\n                return(i)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087938,
                "title": "some-java-solutions",
                "content": "1\\u3001Use Java String.contains Method\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n       StringBuilder builder = new StringBuilder(word);\\n        while(sequence.contains(builder)) {\\n            builder.append(word);\\n        }\\n        return builder.length() / word.length() - 1;\\n    }\\n}\\n```\\n2\\u3001Brute force approach.\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if (sequence.length() - i < max * word.length()) continue;\\n            int r = 0;\\n            for(int j = i, k = 0; j < sequence.length(); j++, k = (k + 1) % word.length()) {\\n                if(sequence.charAt(j) != word.charAt(k)) {\\n                    break;\\n                }\\n                if(k == word.length() - 1) {\\n                    r++;\\n                }\\n            }\\n            max = Math.max(max, r);\\n        }\\n        return max;\\n    }\\n}\\n```\\n3\\u3001Dynamic programming\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        int dp[] = new int[sequence.length()];\\n        char[] ss = sequence.toCharArray(), ww = word.toCharArray();\\n        int sLen = ss.length;\\n        int wLen = ww.length;\\n        for(int i = 0; i < sLen; i++) {\\n            int j = i, k = 0;\\n            while(j < sLen && k < wLen && ss[j++] == ww[k++]) {\\n                j++;\\n                k++;\\n            }\\n            if (k == wLen) {\\n                dp[i] = i - wLen >= 0 ? dp[i - wLen] + 1 : 1;\\n                max = Math.max(max, dp[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n       StringBuilder builder = new StringBuilder(word);\\n        while(sequence.contains(builder)) {\\n            builder.append(word);\\n        }\\n        return builder.length() / word.length() - 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if (sequence.length() - i < max * word.length()) continue;\\n            int r = 0;\\n            for(int j = i, k = 0; j < sequence.length(); j++, k = (k + 1) % word.length()) {\\n                if(sequence.charAt(j) != word.charAt(k)) {\\n                    break;\\n                }\\n                if(k == word.length() - 1) {\\n                    r++;\\n                }\\n            }\\n            max = Math.max(max, r);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        int dp[] = new int[sequence.length()];\\n        char[] ss = sequence.toCharArray(), ww = word.toCharArray();\\n        int sLen = ss.length;\\n        int wLen = ww.length;\\n        for(int i = 0; i < sLen; i++) {\\n            int j = i, k = 0;\\n            while(j < sLen && k < wLen && ss[j++] == ww[k++]) {\\n                j++;\\n                k++;\\n            }\\n            if (k == wLen) {\\n                dp[i] = i - wLen >= 0 ? dp[i - wLen] + 1 : 1;\\n                max = Math.max(max, dp[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083082,
                "title": "c-dp-time-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        \\n\\t\\t// let n be size of sequence\\n\\t\\t// time: o(n)\\n\\t\\t// space: o(n) \\n\\t\\t\\n        vector<int> dp(sequence.size(), 0);        \\n        int max_count = 0;\\n        \\n        for (int i = 0; i < sequence.size(); i++) {\\n            string sub = sequence.substr(i, word.size());\\n            int word_s = word.size();\\n            if (sub == word) {\\n                if (i-word_s < 0) {\\n                    dp[i] = 1;\\n                } else {                    \\n                    dp[i] = dp[i-word_s]+1;                    \\n                }\\n                max_count = max(max_count, dp[i]);                \\n            }\\n        }\\n        \\n        return max_count;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        \\n\\t\\t// let n be size of sequence\\n\\t\\t// time: o(n)\\n\\t\\t// space: o(n) \\n\\t\\t\\n        vector<int> dp(sequence.size(), 0);        \\n        int max_count = 0;\\n        \\n        for (int i = 0; i < sequence.size(); i++) {\\n            string sub = sequence.substr(i, word.size());\\n            int word_s = word.size();\\n            if (sub == word) {\\n                if (i-word_s < 0) {\\n                    dp[i] = 1;\\n                } else {                    \\n                    dp[i] = dp[i-word_s]+1;                    \\n                }\\n                max_count = max(max_count, dp[i]);                \\n            }\\n        }\\n        \\n        return max_count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065126,
                "title": "my-c-solution-cracked-if-finally-0ms-runtime-beats-100-c-submissions",
                "content": "The idea is to find the maximum repeating substring, for example, **aaaaaa** and word is **a,** the maximum possible repeating will be all of the sequence, so what i have done, is check the len of the sequence and divide it by the word, this will give us the **maximum possible repeating substring**. So in a for loop, I start with 1 repeating, and then check the next repeating one  (if found keep on updating the max count), do this, until all the possiblilities are exhausted.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) \\n    {\\n        int sz = word.size();\\n        int len = sequence.size();\\n        int max_possible = len / sz;        \\n        int count = 0;\\n\\n        string strToFind(\"\");\\n        for (int i = 1; i <= max_possible; i++)\\n        {\\n            strToFind +=word;\\n            if( sequence.find( strToFind)  !=  string::npos ) \\n            {\\n                count = max( count, i);\\n            } \\n        }   \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) \\n    {\\n        int sz = word.size();\\n        int len = sequence.size();\\n        int max_possible = len / sz;        \\n        int count = 0;\\n\\n        string strToFind(\"\");\\n        for (int i = 1; i <= max_possible; i++)\\n        {\\n            strToFind +=word;\\n            if( sequence.find( strToFind)  !=  string::npos ) \\n            {\\n                count = max( count, i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1062201,
                "title": "the-last-test-case-aaaba",
                "content": "![image](https://assets.leetcode.com/users/images/4d26a616-8f48-4fc0-858d-52b4b601e89a_1613132021.87528.png)\\nWhy the expected  answer in this case is 5? Can anyone help me to understand? \\n\\n\\n\\'\\'\\'\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int wordIndex = sequence.indexOf(word);\\n        if(wordIndex == -1) {\\n            return 0;\\n        }else {\\n            int remainingStrStartIndex = wordIndex+word.length();\\n            int strLeftLength = sequence.length() - remainingStrStartIndex;\\n            if(strLeftLength < word.length()) {\\n                return 1;\\n            }else {\\n                String remainingStr = sequence.substring(remainingStrStartIndex);\\n                return Math.max(1+checkConcatenated(remainingStr, word), maxRepeating(remainingStr, word));\\n            }\\n        }  \\n    }\\n    \\n    public int checkConcatenated (String s, String word) {\\n        if(s.indexOf(word) != 0) {\\n            return 0;\\n        }else {\\n            if(s.length() >= word.length() * 2){\\n                return 1+checkConcatenated(s.substring(word.length()), word);\\n            }else{\\n                return 1;\\n            }\\n        }\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int wordIndex = sequence.indexOf(word);\\n        if(wordIndex == -1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1048875,
                "title": "python-kmp-dfa",
                "content": "We can pre-generate the longest repeating substring, and use KMP DFA to match the sequence against the DP array it creates. KMP is guaranteed to find the longest proper prefix which is also suffix.\\n\\nExample\\n\"ababc\"\\n\"ab\"\\n\\nThe longest prefix we can have is \"abab\". So we make a KMP DFA like this:\\n[0, 0, 1, 2, 0]\\n\\nand run our sequence through it. We want to find the longest substring of repeated pattern that fits into sequence\\n\\n\\n```python\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n = len(word)\\n        max_rep = word * (len(sequence) // n) + \\'$\\' #\\n        kmp = self.kmpTable(max_rep)\\n        \\n        j = 0\\n        res = 0\\n        for c in sequence:\\n            while j and max_rep[j] != c:\\n                j = kmp[j - 1]\\n                \\n            if max_rep[j] == c:\\n                j += 1\\n                res = max(res, j)\\n            \\n        return res // n\\n    \\n    def kmpTable(self, s: str):\\n        kmp = [0] * len(s)\\n\\n        for i in range(1, len(s)):\\n            idx = kmp[i - 1]\\n\\n            while idx > 0 and s[idx] != s[i]:\\n                idx = kmp[idx - 1]  # trace backwards to find the last matching char\\n\\n            if s[i] == s[idx]:  # matches next\\n                idx += 1\\n\\n            kmp[i] = idx\\n\\n        return kmp\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n = len(word)\\n        max_rep = word * (len(sequence) // n) + \\'$\\' #\\n        kmp = self.kmpTable(max_rep)\\n        \\n        j = 0\\n        res = 0\\n        for c in sequence:\\n            while j and max_rep[j] != c:\\n                j = kmp[j - 1]\\n                \\n            if max_rep[j] == c:\\n                j += 1\\n                res = max(res, j)\\n            \\n        return res // n\\n    \\n    def kmpTable(self, s: str):\\n        kmp = [0] * len(s)\\n\\n        for i in range(1, len(s)):\\n            idx = kmp[i - 1]\\n\\n            while idx > 0 and s[idx] != s[i]:\\n                idx = kmp[idx - 1]  # trace backwards to find the last matching char\\n\\n            if s[i] == s[idx]:  # matches next\\n                idx += 1\\n\\n            kmp[i] = idx\\n\\n        return kmp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043921,
                "title": "2-python-solutions",
                "content": "**Solution 1:**\\n```\\nm, n = len(sequence), len(word)\\nresult = 0\\ni = 0\\nwhile i <= m - n:\\n\\tif sequence[i] == word[0]:\\n\\t\\tj = i\\n\\t\\ttemp = 0\\n\\t\\twhile sequence[j : j + n] == word:\\n\\t\\t\\ttemp += 1\\n\\t\\t\\tj += n\\n\\t\\telse:\\n\\t\\t\\tresult = max(result, temp)\\n\\ti += 1\\nreturn result\\n```\\n\\n**Solution 2:**\\n```\\ncount = 1\\nwhile word * count in sequence:\\n    count += 1\\nreturn count - 1\\n```",
                "solutionTags": [],
                "code": "```\\nm, n = len(sequence), len(word)\\nresult = 0\\ni = 0\\nwhile i <= m - n:\\n\\tif sequence[i] == word[0]:\\n\\t\\tj = i\\n\\t\\ttemp = 0\\n\\t\\twhile sequence[j : j + n] == word:\\n\\t\\t\\ttemp += 1\\n\\t\\t\\tj += n\\n\\t\\telse:\\n\\t\\t\\tresult = max(result, temp)\\n\\ti += 1\\nreturn result\\n```\n```\\ncount = 1\\nwhile word * count in sequence:\\n    count += 1\\nreturn count - 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1033040,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c = 0\\n        temp = word\\n        while 1:\\n            if temp in sequence:\\n                c += 1\\n                temp += word\\n            else:\\n                break\\n        return c",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c = 0\\n        temp = word\\n        while 1:\\n            if temp in sequence:\\n                c += 1\\n                temp += word\\n            else:\\n                break\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 1032690,
                "title": "c-npos-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string p)\\n    {\\n        int count=0;\\n        string x=p;\\n        while(s.find(x)!=string::npos)\\n        {\\n            count++;\\n            x+=p;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string p)\\n    {\\n        int count=0;\\n        string x=p;\\n        while(s.find(x)!=string::npos)\\n        {\\n            count++;\\n            x+=p;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008348,
                "title": "unique-c-solution-100-speed-o-1-memory-with-substr-and-compare",
                "content": "```\\nclass Solution {\\npublic:\\n    // Loop through sequence until we find a char that matches starting char of word\\n    // Use substr to compare if substring starting at current intdex matches word and keep looping\\n    // until we find substr that does not match, incrementing a counter along the way\\n    // compare current counter to previous max\\n    // After finding substrings that work, we have to go back to the index that we were at at the start of the\\n    // outter while loop because we could have skipped over other start points when doing i += interval\\n    int maxRepeating(string sequence, string word) {\\n        if(sequence == word){\\n            return 1;\\n        }\\n        int answer = 0;\\n        int i = 0;\\n        int length = (int)sequence.size();\\n        int interval = (int)word.size();\\n        char start = word[0];\\n        int initial = 0;\\n        \\n        while(i + interval - 1 < length){\\n            if(sequence[i] != start){\\n                i++;\\n                initial++;\\n                continue;\\n            }\\n            \\n            int current = 0;\\n            while(i + interval - 1 < length && !word.compare(sequence.substr(i, interval))){\\n                current++;\\n                i += interval;\\n            }\\n            answer = std::max(answer, current);\\n            i = ++initial;\\n        }\\n        return answer;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Loop through sequence until we find a char that matches starting char of word\\n    // Use substr to compare if substring starting at current intdex matches word and keep looping\\n    // until we find substr that does not match, incrementing a counter along the way\\n    // compare current counter to previous max\\n    // After finding substrings that work, we have to go back to the index that we were at at the start of the\\n    // outter while loop because we could have skipped over other start points when doing i += interval\\n    int maxRepeating(string sequence, string word) {\\n        if(sequence == word){\\n            return 1;\\n        }\\n        int answer = 0;\\n        int i = 0;\\n        int length = (int)sequence.size();\\n        int interval = (int)word.size();\\n        char start = word[0];\\n        int initial = 0;\\n        \\n        while(i + interval - 1 < length){\\n            if(sequence[i] != start){\\n                i++;\\n                initial++;\\n                continue;\\n            }\\n            \\n            int current = 0;\\n            while(i + interval - 1 < length && !word.compare(sequence.substr(i, interval))){\\n                current++;\\n                i += interval;\\n            }\\n            answer = std::max(answer, current);\\n            i = ++initial;\\n        }\\n        return answer;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1007017,
                "title": "java-simple-solution",
                "content": "Elegant solution\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int repeatCount = 1;\\n        while (sequence.contains(word.repeat(repeatCount))) {\\n            repeatCount++;\\n        }\\n        return repeatCount - 1;\\n    }\\n}\\n```\\nRobust solution - here is what happens when you try to solve algorithms at 1am :)\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        var seq = new int[sequence.length()];\\n        var seqEndIdx = 0;\\n        var seqStartCursor = 0;\\n        while (seqStartCursor < sequence.length()) {\\n            var idx = sequence.indexOf(word, seqStartCursor);\\n            if (idx != -1) {\\n                seq[seqEndIdx++] = idx;\\n                seqStartCursor = idx + 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        var maxSeqLen = 0;\\n        var lenSearchCursor = 0;\\n        while (lenSearchCursor < seqEndIdx && seqEndIdx - lenSearchCursor > maxSeqLen) {\\n            var lenCount = 0;\\n            var searchVal = seq[lenSearchCursor];\\n            var searcStartIdx = lenSearchCursor;\\n            while (searcStartIdx != -1) {\\n                lenCount++;\\n                searchVal += word.length();\\n                searcStartIdx = findIdx(seq, searcStartIdx + 1, seqEndIdx, searchVal);\\n            }\\n            maxSeqLen = Math.max(maxSeqLen, lenCount);\\n            lenSearchCursor++;\\n        }\\n        \\n        return maxSeqLen;\\n    }\\n    \\n    private static int findIdx(int[] arr, int lo, int hi, int search) {\\n        while (lo < hi) {\\n            if (arr[lo] == search) {\\n                return lo;\\n            } if (arr[lo] > search) {\\n                return -1;\\n            }\\n            lo++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int repeatCount = 1;\\n        while (sequence.contains(word.repeat(repeatCount))) {\\n            repeatCount++;\\n        }\\n        return repeatCount - 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        var seq = new int[sequence.length()];\\n        var seqEndIdx = 0;\\n        var seqStartCursor = 0;\\n        while (seqStartCursor < sequence.length()) {\\n            var idx = sequence.indexOf(word, seqStartCursor);\\n            if (idx != -1) {\\n                seq[seqEndIdx++] = idx;\\n                seqStartCursor = idx + 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        var maxSeqLen = 0;\\n        var lenSearchCursor = 0;\\n        while (lenSearchCursor < seqEndIdx && seqEndIdx - lenSearchCursor > maxSeqLen) {\\n            var lenCount = 0;\\n            var searchVal = seq[lenSearchCursor];\\n            var searcStartIdx = lenSearchCursor;\\n            while (searcStartIdx != -1) {\\n                lenCount++;\\n                searchVal += word.length();\\n                searcStartIdx = findIdx(seq, searcStartIdx + 1, seqEndIdx, searchVal);\\n            }\\n            maxSeqLen = Math.max(maxSeqLen, lenCount);\\n            lenSearchCursor++;\\n        }\\n        \\n        return maxSeqLen;\\n    }\\n    \\n    private static int findIdx(int[] arr, int lo, int hi, int search) {\\n        while (lo < hi) {\\n            if (arr[lo] == search) {\\n                return lo;\\n            } if (arr[lo] > search) {\\n                return -1;\\n            }\\n            lo++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001322,
                "title": "simple-java-solution-using-string-concatination",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int ans=0;\\n        String s=\"\";\\n        String k=word;\\n        for(int i=0;i<sequence.length();i++)\\n        {\\n                s=s+sequence.charAt(i);\\n                if(s.length()>word.length())\\n                    s=s.substring(1,s.length());\\n            if(s.equals(word))\\n            {\\n                ans++;\\n                word=word+k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int ans=0;\\n        String s=\"\";\\n        String k=word;\\n        for(int i=0;i<sequence.length();i++)\\n        {\\n                s=s+sequence.charAt(i);\\n                if(s.length()>word.length())\\n                    s=s.substring(1,s.length());\\n            if(s.equals(word))\\n            {\\n                ans++;\\n                word=word+k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001010,
                "title": "java-binary-search-solution-7ms",
                "content": "We may need to implement our own `contains()` and `repeat()` methods if it\\'s an medium/hard problem. Let\\'s just not bother for a easy one.\\n\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int m = sequence.length(), n = word.length(), l = 1, r = m / n;\\n        \\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (sequence.contains(word.repeat(mid)))\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        return l - 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int m = sequence.length(), n = word.length(), l = 1, r = m / n;\\n        \\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (sequence.contains(word.repeat(mid)))\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        return l - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983742,
                "title": "0ms-solution-clear-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int res=0;\\n        string aux=word;\\n        while(sequence.find(aux)!=string::npos){\\n            res++;\\n            aux+=word;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int res=0;\\n        string aux=word;\\n        while(sequence.find(aux)!=string::npos){\\n            res++;\\n            aux+=word;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964251,
                "title": "c-0ms-kmp-clean-solution-without-string-library",
                "content": "```\\nclass Solution {\\npublic:\\n    void prefixfunc(string S, vector <int> &M, vector<int> &pos,int l){\\n    M[0]=-1;\\n    S[0] == S[1] ? M[1] = 0 : M[1] = -1;\\n    for(int i=2;i<S.size();i++){\\n        int k=i-1;\\n        while(true){\\n            if(S[M[k]+1] == S[i]){M[i]=M[k]+1;if(M[i]==l)pos.push_back(i);break;}\\n            if(M[k]>=0) {k=M[k];continue;}\\n            S[0] == S[i] ? M[i] = 0: M[i] = -1;\\n            break;\\n        }\\n    }\\n}\\n    int maxRepeating(string s, string w) {\\n      string ns = w + \\'#\\' + s;\\n      vector<int>tmp(ns.size(),0);\\n      vector<int>pos;\\n      int l= w.size();\\n      prefixfunc(ns,tmp,pos,l-1);\\n      if(pos.empty()) return 0;\\n      int t=1,tm =1;\\n      int ind = pos[0];cout<<pos[0]<<\" \";\\n      for(int i=1;i<pos.size();i++){cout<<pos[i]<<\" \";\\n        if(pos[i] - ind == l) {tm++;ind=pos[i];}\\n        else {\\n          if(i+1 < pos.size() && pos[i] - ind < l && pos[i]-pos[i-1] == pos[i+1] - pos[i]) continue;\\n          \\n          if(tm > t ) t = tm;\\n          tm=1;\\n          ind = pos[i];\\n          }\\n      }\\n      if(tm > t ) t = tm;\\n      return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void prefixfunc(string S, vector <int> &M, vector<int> &pos,int l){\\n    M[0]=-1;\\n    S[0] == S[1] ? M[1] = 0 : M[1] = -1;\\n    for(int i=2;i<S.size();i++){\\n        int k=i-1;\\n        while(true){\\n            if(S[M[k]+1] == S[i]){M[i]=M[k]+1;if(M[i]==l)pos.push_back(i);break;}\\n            if(M[k]>=0) {k=M[k];continue;}\\n            S[0] == S[i] ? M[i] = 0: M[i] = -1;\\n            break;\\n        }\\n    }\\n}\\n    int maxRepeating(string s, string w) {\\n      string ns = w + \\'#\\' + s;\\n      vector<int>tmp(ns.size(),0);\\n      vector<int>pos;\\n      int l= w.size();\\n      prefixfunc(ns,tmp,pos,l-1);\\n      if(pos.empty()) return 0;\\n      int t=1,tm =1;\\n      int ind = pos[0];cout<<pos[0]<<\" \";\\n      for(int i=1;i<pos.size();i++){cout<<pos[i]<<\" \";\\n        if(pos[i] - ind == l) {tm++;ind=pos[i];}\\n        else {\\n          if(i+1 < pos.size() && pos[i] - ind < l && pos[i]-pos[i-1] == pos[i+1] - pos[i]) continue;\\n          \\n          if(tm > t ) t = tm;\\n          tm=1;\\n          ind = pos[i];\\n          }\\n      }\\n      if(tm > t ) t = tm;\\n      return t;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 963973,
                "title": "java-o-n-100-with-dp",
                "content": "```\\n public int maxRepeating(String sequence, String word) {\\n        int cur = 0;\\n        int[] records = new int[sequence.length()];\\n\\n        int wordLen = word.length();\\n        int ans = 0;\\n        while ((cur = sequence.indexOf(word, cur)) != -1) {\\n\\t\\t\\t records[cur] = 1;\\n            if (cur - wordLen >= 0 && records[cur] != 0) {\\n                records[cur] = records[cur - wordLen] + 1; //records[cur-wordLen] means the maximum repeated in sequence[0...cur-wordLen]\\n            }\\n\\n            ans = Math.max(ans, records[cur]);\\n            cur++;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int maxRepeating(String sequence, String word) {\\n        int cur = 0;\\n        int[] records = new int[sequence.length()];\\n\\n        int wordLen = word.length();\\n        int ans = 0;\\n        while ((cur = sequence.indexOf(word, cur)) != -1) {\\n\\t\\t\\t records[cur] = 1;\\n            if (cur - wordLen >= 0 && records[cur] != 0) {\\n                records[cur] = records[cur - wordLen] + 1; //records[cur-wordLen] means the maximum repeated in sequence[0...cur-wordLen]\\n            }\\n\\n            ans = Math.max(ans, records[cur]);\\n            cur++;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 956378,
                "title": "easy-short-python",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        for i in range(len(sequence)//len(word),-1,-1):\\n            if word*i in sequence: return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        for i in range(len(sequence)//len(word),-1,-1):\\n            if word*i in sequence: return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956091,
                "title": "ruby-regex-solution",
                "content": "##### Leetcode: 1668. Maximum Repeating Substring.\\n\\n\\nCreate a regex with two groups, inner group is a word itself, outer group is the inner group and plus sign quantifier, that means word must be repeated one or more times. When scan string for a such pattern, an a two dimensional array will be returned, each element is a match of whole pattern inside the sequence string. First element of the pattern is outer group (started by first open parentheses), and second element is the inner group (started by second open parentheses). Outer group it is what is seek for, array mapped into string lengths of a first string of an element, and maximum one will be selected and divided by a word size to get number of repetitions.\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1668. Maximum Repeating Substring.\\n# https://leetcode.com/problems/maximum-repeating-substring\\n# Runtime: 60 ms, faster than 60.00% of Ruby online submissions for Maximum Repeating Substring.\\n# Memory Usage: 210.1 MB, less than 20.00% of Ruby online submissions for Maximum Repeating Substring.\\n# @param {String} sequence\\n# @param {String} word\\n# @return {Integer}\\ndef max_repeating(sequence, word)\\n    regex = Regexp.new(\\'((\\' + word +\\')+)\\')\\n    ans = sequence.scan(regex)\\n    return 0 if ans.empty?\\n    ans.map{|x| x.first.size}.max / word.size\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1668. Maximum Repeating Substring.\\n# https://leetcode.com/problems/maximum-repeating-substring\\n# Runtime: 60 ms, faster than 60.00% of Ruby online submissions for Maximum Repeating Substring.\\n# Memory Usage: 210.1 MB, less than 20.00% of Ruby online submissions for Maximum Repeating Substring.\\n# @param {String} sequence\\n# @param {String} word\\n# @return {Integer}\\ndef max_repeating(sequence, word)\\n    regex = Regexp.new(\\'((\\' + word +\\')+)\\')\\n    ans = sequence.scan(regex)\\n    return 0 if ans.empty?\\n    ans.map{|x| x.first.size}.max / word.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 953963,
                "title": "the-simplest-way-to-solve-it-using-python3",
                "content": "```\\ndef maxRepeating(self, sequence: str, word: str) -> int:\\n        l = len(sequence)//len(word);\\n        while l:\\n            s = word*l\\n            if s in sequence:\\n                return len(s)//len(word)\\n            l = l-1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxRepeating(self, sequence: str, word: str) -> int:\\n        l = len(sequence)//len(word);\\n        while l:\\n            s = word*l\\n            if s in sequence:\\n                return len(s)//len(word)\\n            l = l-1\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 953275,
                "title": "c-linear-time-solution-explained-no-regex-no-built-in-100-time-100-space",
                "content": "Nice simple one here; one might go lazy and use regexes or other built-in tools, but I preferred going on my own legs for practice purposes.\\n\\nSo, first of all we need to declare a few variables:\\n* `res` will store the maximum sequence we found so far.\\n\\nIn our main loop, we will declare a few more that will live and die in that scope:\\n* `i` is our iterator, as usual;\\n* `sLen`, `wLen` and `len` will store the size of our 2 input strings and the composite length of our iteration needs (given as `sLen - wLen + 1`, if you do the math), respectively;\\n* `j` and `k` are support pointers to iterate through `s` and `w`, respectively;\\n* `curr` will keep track of the length of our current valid subsequence.\\n\\nInside the loop itself, we will at each iteration:\\n* initialise our variables with `j = i` and both `k` and `curr` set to `0`;\\n* we will then have a nested loop in which the actual parsing and comparison are done, running as long as `j < sLen`, in which:\\n\\t* as long as `s[j]` and `w[k]` are identical, we will keep increasing both `j` and `k`;\\n\\t* as soon as we find a mismatch, we `break` (no point in continuing to compare if just one character is off);\\n\\t* everytime `k == wLen`, it means we have found a completely matching subsequence, so we will reset `k` to `0`, increase `curr` by `1` and, the trickier part, also update `i` to be equal to `j`, to save later needless computation, re-checking already valid matches;\\n* update `res` as the maximum value between its current one and `curr`.\\n\\nOnce we are done, we can just return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string w) {\\n        // support variables\\n        int res = 0, sLen = s.size(), wLen = w.size();\\n        // parsing the main string\\n        for (int i = 0, sLen = s.size(), wLen = w.size(), len = sLen - wLen + 1, j, k, curr; i < len; i++) {\\n            // initialsing loop variables\\n            j = i, k = 0, curr = 0;\\n            while (j < sLen) {\\n                // comparing char by char\\n                if (s[j] == w[k]) j++, k++;\\n                else break;\\n                // updating curr and i when we have a full match\\n                if (k == wLen) k = 0, i = j, curr++;\\n            }\\n            // updating res\\n            res = max(res, curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string w) {\\n        // support variables\\n        int res = 0, sLen = s.size(), wLen = w.size();\\n        // parsing the main string\\n        for (int i = 0, sLen = s.size(), wLen = w.size(), len = sLen - wLen + 1, j, k, curr; i < len; i++) {\\n            // initialsing loop variables\\n            j = i, k = 0, curr = 0;\\n            while (j < sLen) {\\n                // comparing char by char\\n                if (s[j] == w[k]) j++, k++;\\n                else break;\\n                // updating curr and i when we have a full match\\n                if (k == wLen) k = 0, i = j, curr++;\\n            }\\n            // updating res\\n            res = max(res, curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952917,
                "title": "java-straightforward-bruteforce",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        StringBuilder sb = new StringBuilder(word);\\n        int maxK = sequence.length() / word.length();\\n        for (int i = 0; i < maxK; ++i, sb.append(word)) {\\n            if (!sequence.contains(sb.toString())) {\\n                return i;\\n            }\\n        }\\n        return maxK;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        StringBuilder sb = new StringBuilder(word);\\n        int maxK = sequence.length() / word.length();\\n        for (int i = 0; i < maxK; ++i, sb.append(word)) {\\n            if (!sequence.contains(sb.toString())) {\\n                return i;\\n            }\\n        }\\n        return maxK;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952161,
                "title": "c-4-lines",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Brute force\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-repeating-substring/\\n// Author: github.com/lzl124631x\\n// Time: O(N^3)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string f = word;\\n        int k = 1;\\n        for (; sequence.find(f) != string::npos; ++k, f += word);\\n        return k - 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximum-repeating-substring/\\n// Author: github.com/lzl124631x\\n// Time: O(N^3)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string f = word;\\n        int k = 1;\\n        for (; sequence.find(f) != string::npos; ++k, f += word);\\n        return k - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952028,
                "title": "java-naive",
                "content": "````\\n public int maxRepeating(String a, String b) {\\n        if (b.length() > a.length()) return 0;\\n\\n        int max = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            int k = i;\\n            int j = 0;\\n            int count = 0;\\n            while (k < a.length() && a.charAt(k) == b.charAt(j)) {\\n                k++;\\n                j++;\\n                if (j == b.length()) {\\n                    j = 0;\\n                    count++;\\n                }\\n            }\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\n public int maxRepeating(String a, String b) {\\n        if (b.length() > a.length()) return 0;\\n\\n        int max = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            int k = i;\\n            int j = 0;\\n            int count = 0;\\n            while (k < a.length() && a.charAt(k) == b.charAt(j)) {\\n                k++;\\n                j++;\\n                if (j == b.length()) {\\n                    j = 0;\\n                    count++;\\n                }\\n            }\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 951994,
                "title": "kmp-based-c-solution",
                "content": "```\\n          public class Solution\\n        {\\n\\n            private void KnuthMorrisPrattSearch(string txt, string pattern, IList<int> foundStartIndices)\\n            {\\n                int patternLength = pattern.Length;\\n                int textLength = txt.Length;\\n\\n                int[] lps = new int[patternLength];\\n                int j = 0;\\n\\n                ComputeLPSArray(pattern, patternLength, lps);\\n\\n                int i = 0;\\n                while (i < textLength)\\n                {\\n                    if (pattern[j] == txt[i])\\n                    {\\n                        j++;\\n                        i++;\\n                    }\\n                    if (j == patternLength)\\n                    {\\n                        foundStartIndices.Add((i - j));\\n                        j = lps[j - 1];\\n                    }\\n                    else if (i < textLength && pattern[j] != txt[i])\\n                    {\\n                        if (j != 0)\\n                        {\\n                            j = lps[j - 1];\\n                        }\\n                        else\\n                        {\\n                            i = i + 1;\\n                        }\\n                    }\\n                }\\n            }\\n\\n\\n        private static void ComputeLPSArray(string pattern, int patternLength, int[] lps)\\n        {\\n            lps[0] = 0;\\n\\n            for (int i = 1; i < patternLength; i++)\\n            {\\n                int k = lps[i - 1];\\n                while (k > 0 && pattern[i] != pattern[k])\\n                {\\n                    k = lps[k - 1];\\n                }\\n\\n                if (pattern[i] == pattern[k])\\n                {\\n                    k++;\\n                }\\n\\n                lps[i] = k;\\n            }\\n        }\\n\\n            public int MaxRepeating(string sequence, string word)\\n            {\\n                IList<int> indices = new List<int>();\\n                KnuthMorrisPrattSearch(sequence, word, indices);\\n\\n                int res = 0;\\n                IDictionary<int, int> map = new Dictionary<int, int>();\\n\\n                foreach (var index in indices)\\n                {\\n                    map[index] = 1;\\n                    if (map.ContainsKey(index - word.Length))\\n                    {\\n                        map[index] = map[index - word.Length] + 1;\\n                    }\\n\\n                    res = Math.Max(res, map[index]);\\n                }\\n\\n                return res;\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n          public class Solution\\n        {\\n\\n            private void KnuthMorrisPrattSearch(string txt, string pattern, IList<int> foundStartIndices)\\n            {\\n                int patternLength = pattern.Length;\\n                int textLength = txt.Length;\\n\\n                int[] lps = new int[patternLength];\\n                int j = 0;\\n\\n                ComputeLPSArray(pattern, patternLength, lps);\\n\\n                int i = 0;\\n                while (i < textLength)\\n                {\\n                    if (pattern[j] == txt[i])\\n                    {\\n                        j++;\\n                        i++;\\n                    }\\n                    if (j == patternLength)\\n                    {\\n                        foundStartIndices.Add((i - j));\\n                        j = lps[j - 1];\\n                    }\\n                    else if (i < textLength && pattern[j] != txt[i])\\n                    {\\n                        if (j != 0)\\n                        {\\n                            j = lps[j - 1];\\n                        }\\n                        else\\n                        {\\n                            i = i + 1;\\n                        }\\n                    }\\n                }\\n            }\\n\\n\\n        private static void ComputeLPSArray(string pattern, int patternLength, int[] lps)\\n        {\\n            lps[0] = 0;\\n\\n            for (int i = 1; i < patternLength; i++)\\n            {\\n                int k = lps[i - 1];\\n                while (k > 0 && pattern[i] != pattern[k])\\n                {\\n                    k = lps[k - 1];\\n                }\\n\\n                if (pattern[i] == pattern[k])\\n                {\\n                    k++;\\n                }\\n\\n                lps[i] = k;\\n            }\\n        }\\n\\n            public int MaxRepeating(string sequence, string word)\\n            {\\n                IList<int> indices = new List<int>();\\n                KnuthMorrisPrattSearch(sequence, word, indices);\\n\\n                int res = 0;\\n                IDictionary<int, int> map = new Dictionary<int, int>();\\n\\n                foreach (var index in indices)\\n                {\\n                    map[index] = 1;\\n                    if (map.ContainsKey(index - word.Length))\\n                    {\\n                        map[index] = map[index - word.Length] + 1;\\n                    }\\n\\n                    res = Math.Max(res, map[index]);\\n                }\\n\\n                return res;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077829,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = \"\";\\n  int k = 0, ans = 0;\\n  while (temp.size() <= sequence.size())\\n  {\\n    k++;\\n    temp += word;\\n    if (sequence.find(temp) < sequence.size())\\n    {\\n      ans = max(ans, k);\\n    }\\n    else{\\n      break;\\n    }\\n  }\\n  return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = \"\";\\n  int k = 0, ans = 0;\\n  while (temp.size() <= sequence.size())\\n  {\\n    k++;\\n    temp += word;\\n    if (sequence.find(temp) < sequence.size())\\n    {\\n      ans = max(ans, k);\\n    }\\n    else{\\n      break;\\n    }\\n  }\\n  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067710,
                "title": "java-kmp-pattern-matching-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int[] createLPSArray(String word){\\n        int n = word.length();\\n        int[] lps = new int[n];\\n        int prefixIndex = 0;\\n        int suffIndex = 1;\\n\\n        while(suffIndex < n){\\n            if(word.charAt(prefixIndex) == word.charAt(suffIndex)) {\\n                prefixIndex++;\\n                lps[suffIndex] = prefixIndex;\\n                suffIndex++;\\n            } else if(prefixIndex == 0) {\\n                lps[suffIndex] = prefixIndex;\\n                suffIndex++;\\n            } else {\\n                prefixIndex = lps[prefixIndex - 1];\\n            }\\n        }\\n        return lps;\\n    }\\n\\n    boolean patternMatching(String sequence, String word){\\n        int[] lps = createLPSArray(word);\\n        int n = sequence.length();\\n        int m = word.length();\\n\\n        int subseqIndex = 0;\\n        int wordIndex = 0;\\n\\n        int k = 0;\\n        int max = 0;\\n\\n        while(subseqIndex < n){\\n            if(sequence.charAt(subseqIndex) == word.charAt(wordIndex)) {\\n                subseqIndex++;\\n                wordIndex++;\\n            } else if(wordIndex == 0) {\\n                subseqIndex++;\\n            } else {\\n                wordIndex = lps[wordIndex - 1];\\n            }\\n\\n            if(wordIndex == m) return true;\\n        }\\n        return false;\\n    }\\n\\n    public int maxRepeating(String sequence, String word) {\\n        \\n        int n = sequence.length();\\n        int m = word.length();\\n\\n        int maxRepeats = (n / m) + 1;\\n        StringBuilder sb = new StringBuilder(word);\\n\\n        for(int k = 0; k <= maxRepeats; k++){\\n            // System.out.println(sb + \" -- \" + k);\\n            if(!patternMatching(sequence, sb.toString())) return k;\\n            sb.append(word);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] createLPSArray(String word){\\n        int n = word.length();\\n        int[] lps = new int[n];\\n        int prefixIndex = 0;\\n        int suffIndex = 1;\\n\\n        while(suffIndex < n){\\n            if(word.charAt(prefixIndex) == word.charAt(suffIndex)) {\\n                prefixIndex++;\\n                lps[suffIndex] = prefixIndex;\\n                suffIndex++;\\n            } else if(prefixIndex == 0) {\\n                lps[suffIndex] = prefixIndex;\\n                suffIndex++;\\n            } else {\\n                prefixIndex = lps[prefixIndex - 1];\\n            }\\n        }\\n        return lps;\\n    }\\n\\n    boolean patternMatching(String sequence, String word){\\n        int[] lps = createLPSArray(word);\\n        int n = sequence.length();\\n        int m = word.length();\\n\\n        int subseqIndex = 0;\\n        int wordIndex = 0;\\n\\n        int k = 0;\\n        int max = 0;\\n\\n        while(subseqIndex < n){\\n            if(sequence.charAt(subseqIndex) == word.charAt(wordIndex)) {\\n                subseqIndex++;\\n                wordIndex++;\\n            } else if(wordIndex == 0) {\\n                subseqIndex++;\\n            } else {\\n                wordIndex = lps[wordIndex - 1];\\n            }\\n\\n            if(wordIndex == m) return true;\\n        }\\n        return false;\\n    }\\n\\n    public int maxRepeating(String sequence, String word) {\\n        \\n        int n = sequence.length();\\n        int m = word.length();\\n\\n        int maxRepeats = (n / m) + 1;\\n        StringBuilder sb = new StringBuilder(word);\\n\\n        for(int k = 0; k <= maxRepeats; k++){\\n            // System.out.println(sb + \" -- \" + k);\\n            if(!patternMatching(sequence, sb.toString())) return k;\\n            sb.append(word);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065844,
                "title": "beats-89-of-java-coders",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int index = sequence.indexOf(word);\\n        if(index==-1){\\n            return 0;\\n        }\\n        int c = 0;\\n        String a = word;\\n        while(index!=-1){\\n            c++;\\n            word +=a;\\n            System.out.println(word);\\n            index = sequence.indexOf(word);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int index = sequence.indexOf(word);\\n        if(index==-1){\\n            return 0;\\n        }\\n        int c = 0;\\n        String a = word;\\n        while(index!=-1){\\n            c++;\\n            word +=a;\\n            System.out.println(word);\\n            index = sequence.indexOf(word);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065819,
                "title": "using-kmp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> fill_lps(string& s,int m){\\n    while(s.length()<m) s+=s;\\n\\n    int n=s.length();\\n    \\n    vector<int> lps(n,0);\\n    lps[0]=0;\\n\\n    int i=1,len=0;\\n    while(i<n){\\n        if(s[i]==s[len]){\\n                lps[i]=len+1;\\n                len++;\\n                i++;\\n        }\\n        else{\\n            if(len==0){\\n            lps[i]=0;\\n            i++;\\n            } \\n            else len=lps[len-1];\\n        }\\n  \\n    }\\n    return lps;\\n}\\n\\n    int maxRepeating(string seq, string word) {\\n        int ans=0;\\n        int i=0;\\n        int j=0;\\n        int n=seq.length();\\n        int m=word.length();\\n        vector<int> vec=fill_lps(word,n);\\n        \\n\\n        while(i<n){\\n            if(seq[i]==word[j]){\\n                i++;\\n                j++;\\n            }\\n            \\n\\n            else{\\n                if(j==0) i++;\\n                else j=vec[j-1];  \\n            }\\n            if(j%m==0) ans=max(ans,j/m);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> fill_lps(string& s,int m){\\n    while(s.length()<m) s+=s;\\n\\n    int n=s.length();\\n    \\n    vector<int> lps(n,0);\\n    lps[0]=0;\\n\\n    int i=1,len=0;\\n    while(i<n){\\n        if(s[i]==s[len]){\\n                lps[i]=len+1;\\n                len++;\\n                i++;\\n        }\\n        else{\\n            if(len==0){\\n            lps[i]=0;\\n            i++;\\n            } \\n            else len=lps[len-1];\\n        }\\n  \\n    }\\n    return lps;\\n}\\n\\n    int maxRepeating(string seq, string word) {\\n        int ans=0;\\n        int i=0;\\n        int j=0;\\n        int n=seq.length();\\n        int m=word.length();\\n        vector<int> vec=fill_lps(word,n);\\n        \\n\\n        while(i<n){\\n            if(seq[i]==word[j]){\\n                i++;\\n                j++;\\n            }\\n            \\n\\n            else{\\n                if(j==0) i++;\\n                else j=vec[j-1];  \\n            }\\n            if(j%m==0) ans=max(ans,j/m);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063114,
                "title": "java-easy-to-understand-begginer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String s1=\"\";\\n        int count=0;\\n        while(true){\\n            s1=s1+word;\\n            if (sequence.contains(s1)){\\n                count=count+1;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String s1=\"\";\\n        int count=0;\\n        while(true){\\n            s1=s1+word;\\n            if (sequence.contains(s1)){\\n                count=count+1;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039491,
                "title": "c-python-rolling-hash-dp-solution-with-explanation",
                "content": "### rolling hash + dp\\nh is hash value of s[i:j] whose length is j - i\\nhash value of s[i: j+1] is h * 26 + (s[j] - \\'a\\'), but hash value of \\'a\\' is 0, \"aa\" also is 0,\\nso, I modify the hash function based on [168. Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title/) which is a hash function start from 1 instead of 0.\\nhash value of s[i: j+1] is h * 26 + (s[j] - \\'a\\' + 1).\\nAnd if I want to remove leftmost letter s[i],\\nhash value of s[i+1:j] is h - (s[i] - \\'a\\' + 1) * 26 ^ (j - i - 1).\\n\\nSo, we can use O(1) time to check if a len(word) substring == word.\\nAnd use Exponentiation by squaring to calaulate 26 ^ (j - i - 1) in O(log m).\\ndp[i] means dp[i] of repeating substring end at i-1.\\ne.g. seq = abab, w = ab,\\ndp = [0, 0, 1, 0, 2], where 2 is abab.\\ntc is O(m + n log m), sc is O(n).\\n\\n\\n### python\\n```python\\ndef pow_(x, y):\\n    if y == 0: return 1\\n    z = pow_(x, y // 2)\\n    if y % 2:\\n        return x * z * z\\n    return z * z\\n\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word): return 0\\n        target = 0\\n        for ch in word:\\n            target = target * 26 + ord(ch) - ord(\\'a\\') + 1\\n        dp = [0] * (len(sequence) + 1)\\n        cur = 0\\n        for i, ch in enumerate(sequence):\\n            cur = cur * 26 + ord(ch) - ord(\\'a\\') + 1\\n            if i >= len(word):\\n                cur -= (ord(sequence[i - len(word)]) - ord(\\'a\\') + 1) * pow_(26, len(word))\\n            if cur == target:\\n                dp[i+1] = dp[i + 1 - len(word)] + 1\\n        return max(dp)\\n```\\n\\n### c++\\nIn c++, we can use 2 hash functions to generate a hash vector to avoid hash collision, it actually has a low probability to occur hash collision.\\n\\n```cpp\\nconst int base_1 = 29, base_2 = 31, mod = 1e9 + 7;\\nint pow_ (int x, int y) {\\n    if (y == 0) return 1;\\n    long z = pow_(x, y/2);\\n    if (y % 2) return (x * ((z * z) % mod)) % mod;\\n    return (z * z) % mod;\\n};\\n\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        if (sequence.size() < word.size()) return 0;\\n        int size = sequence.size();\\n        int target_1 = 0, target_2 = 0;\\n        for (auto& ch: word) {\\n            target_1 = (1L * target_1 * base_1 + ch - \\'a\\' + 1) % mod;\\n            target_2 = (1L * target_2 * base_2 + ch - \\'a\\' + 1) % mod;\\n        }\\n        vector<int> dp (size + 1);\\n        int cur_1 = 0, cur_2 = 0;\\n        for (int i = 0; i < size; i+=1) {\\n            auto& ch = sequence[i];\\n            cur_1 = (1L * cur_1 * base_1 + ch - \\'a\\' + 1) % mod;\\n            cur_2 = (1L * cur_2 * base_2 + ch - \\'a\\' + 1) % mod;\\n            if (i >= word.size()) {\\n                cur_1  = (cur_1 + mod - ((sequence[i - word.size()] - \\'a\\' + 1) * pow_(base_1, word.size()) % mod)) % mod;\\n                cur_2  = (cur_2 + mod - ((sequence[i - word.size()] - \\'a\\' + 1) * pow_(base_2, word.size()) % mod)) % mod;\\n            }\\n            if (cur_1 == target_1 && cur_2 == target_2)\\n                dp[i+1] = dp[i+1-word.size()] + 1;\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```python\\ndef pow_(x, y):\\n    if y == 0: return 1\\n    z = pow_(x, y // 2)\\n    if y % 2:\\n        return x * z * z\\n    return z * z\\n\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word): return 0\\n        target = 0\\n        for ch in word:\\n            target = target * 26 + ord(ch) - ord(\\'a\\') + 1\\n        dp = [0] * (len(sequence) + 1)\\n        cur = 0\\n        for i, ch in enumerate(sequence):\\n            cur = cur * 26 + ord(ch) - ord(\\'a\\') + 1\\n            if i >= len(word):\\n                cur -= (ord(sequence[i - len(word)]) - ord(\\'a\\') + 1) * pow_(26, len(word))\\n            if cur == target:\\n                dp[i+1] = dp[i + 1 - len(word)] + 1\\n        return max(dp)\\n```\n```cpp\\nconst int base_1 = 29, base_2 = 31, mod = 1e9 + 7;\\nint pow_ (int x, int y) {\\n    if (y == 0) return 1;\\n    long z = pow_(x, y/2);\\n    if (y % 2) return (x * ((z * z) % mod)) % mod;\\n    return (z * z) % mod;\\n};\\n\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        if (sequence.size() < word.size()) return 0;\\n        int size = sequence.size();\\n        int target_1 = 0, target_2 = 0;\\n        for (auto& ch: word) {\\n            target_1 = (1L * target_1 * base_1 + ch - \\'a\\' + 1) % mod;\\n            target_2 = (1L * target_2 * base_2 + ch - \\'a\\' + 1) % mod;\\n        }\\n        vector<int> dp (size + 1);\\n        int cur_1 = 0, cur_2 = 0;\\n        for (int i = 0; i < size; i+=1) {\\n            auto& ch = sequence[i];\\n            cur_1 = (1L * cur_1 * base_1 + ch - \\'a\\' + 1) % mod;\\n            cur_2 = (1L * cur_2 * base_2 + ch - \\'a\\' + 1) % mod;\\n            if (i >= word.size()) {\\n                cur_1  = (cur_1 + mod - ((sequence[i - word.size()] - \\'a\\' + 1) * pow_(base_1, word.size()) % mod)) % mod;\\n                cur_2  = (cur_2 + mod - ((sequence[i - word.size()] - \\'a\\' + 1) * pow_(base_2, word.size()) % mod)) % mod;\\n            }\\n            if (cur_1 == target_1 && cur_2 == target_2)\\n                dp[i+1] = dp[i+1-word.size()] + 1;\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026997,
                "title": "simple-java-solution-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String s=word;\\n        int c=0;\\n        while(sequence.contains(s)){\\n            c++;\\n            s+=word;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String s=word;\\n        int c=0;\\n        while(sequence.contains(s)){\\n            c++;\\n            s+=word;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026966,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int c=0;\\n        String s=word;\\n        while(sequence.contains(s)){\\n            c++;\\n            s=s+word;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int c=0;\\n        String s=word;\\n        while(sequence.contains(s)){\\n            c++;\\n            s=s+word;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021213,
                "title": "90-faster-easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) check if (x) is a subString of (seq.)\\n2) if yes, (count++) and (x+word)\\n3) if not return (count)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        // longest continuous substring of seq. made from repeating word\\n        String x = word;\\n        int k = 0;\\n        while(sequence.contains(x)){\\n            k++;\\n            x+=word;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        // longest continuous substring of seq. made from repeating word\\n        String x = word;\\n        int k = 0;\\n        while(sequence.contains(x)){\\n            k++;\\n            x+=word;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997819,
                "title": "easy-python-soluton",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        \"\"\"\\n        :type sequence: str\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        if word not in sequence:\\n            return 0\\n        k=0\\n        while True:\\n            if k*word not in sequence:\\n                return k-1\\n            k+=1\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        \"\"\"\\n        :type sequence: str\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        if word not in sequence:\\n            return 0\\n        k=0\\n        while True:\\n            if k*word not in sequence:\\n                return k-1\\n            k+=1\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975222,
                "title": "java-1ms-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        \\n          int count=0;\\n\\n        String find=\"\";\\n        \\n        while (sequence.contains(find))\\n        {\\n            find+=word;\\n            count++;\\n        }\\n// consider upvoting if you like the solution \\n        return count-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        \\n          int count=0;\\n\\n        String find=\"\";\\n        \\n        while (sequence.contains(find))\\n        {\\n            find+=word;\\n            count++;\\n        }\\n// consider upvoting if you like the solution \\n        return count-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971289,
                "title": "java-solution",
                "content": "# Intuition\\nCheck consecutively appearing substring in sequence and return the maximum count.\\n\\n# Approach\\n1. Declare two variable cnt and repeat.\\n2. cnt is used to count maximum number consecutively repeating substring and repeat is used to append the word again and again.\\n3. Than repeat is used to check in sequence that it contains how much number of maximun repeatition.\\n4. than return the count.\\n\\n# Complexity\\n- Time complexity:\\nThe provided code has a runtime complexity of O(n * m), where:\\nn is the length of the sequence string.\\nm is the length of the word string.\\n\\n- Space complexity:\\nO(m)\\nwhere m is the length of word string.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) \\n    {\\n        int cnt = 0;\\n        String repeat = word;\\n\\n        while(sequence.contains(repeat))\\n        {\\n            cnt++;\\n            repeat = repeat + word;\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) \\n    {\\n        int cnt = 0;\\n        String repeat = word;\\n\\n        while(sequence.contains(repeat))\\n        {\\n            cnt++;\\n            repeat = repeat + word;\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971205,
                "title": "maxrepeating",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int maxRepeating(String sequence, String word) {\\n        int currentIndex = 0;\\n        int index = 0;\\n        int max = 0;\\n        int offset = word.length();\\n        while (index < sequence.length() && (currentIndex = sequence.indexOf(word, index)) > -1) {\\n            int n = 0;\\n            int startIndex = currentIndex;\\n            int endIndex = currentIndex + offset;\\n            do {\\n                var sub = sequence.substring(startIndex, endIndex);\\n                if (word.equals(sub)) {\\n                    max = Math.max(++n, max);\\n                } else {\\n                    break;\\n                }\\n                startIndex += offset;\\n                endIndex += offset;\\n            } while (endIndex <= sequence.length());\\n            index = currentIndex + 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int maxRepeating(String sequence, String word) {\\n        int currentIndex = 0;\\n        int index = 0;\\n        int max = 0;\\n        int offset = word.length();\\n        while (index < sequence.length() && (currentIndex = sequence.indexOf(word, index)) > -1) {\\n            int n = 0;\\n            int startIndex = currentIndex;\\n            int endIndex = currentIndex + offset;\\n            do {\\n                var sub = sequence.substring(startIndex, endIndex);\\n                if (word.equals(sub)) {\\n                    max = Math.max(++n, max);\\n                } else {\\n                    break;\\n                }\\n                startIndex += offset;\\n                endIndex += offset;\\n            } while (endIndex <= sequence.length());\\n            index = currentIndex + 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955557,
                "title": "python3-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c=0\\n        n=len(sequence)\\n        i=0\\n        while(i<n and word*(i+1) in sequence):\\n            c=max(c,i+1)\\n            i+=1\\n        return c\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c=0\\n        n=len(sequence)\\n        i=0\\n        while(i<n and word*(i+1) in sequence):\\n            c=max(c,i+1)\\n            i+=1\\n        return c\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943444,
                "title": "java-1ms-solution",
                "content": "```\\npublic int maxRepeating(String sequence, String word) {\\n        //if(sequence.equals(word)) return 1;\\n        int cnt=0,maxi=0,j=0;\\n        for(int i=0;i<sequence.length()-word.length()+1; i++){\\n            if(sequence.substring(i,i+word.length()).equals(word)){\\n                j=i;\\n                while( j<sequence.length()-word.length()+1){\\n                cnt++;j+= word.length();\\n                maxi = Math.max(maxi,cnt);\\n                    if( j<sequence.length()-word.length()+1 && !sequence.substring(j,j+word.length()).equals(word)) break;\\n                }\\n            }\\n                cnt=0;\\n        }\\n        return maxi;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic int maxRepeating(String sequence, String word) {\\n        //if(sequence.equals(word)) return 1;\\n        int cnt=0,maxi=0,j=0;\\n        for(int i=0;i<sequence.length()-word.length()+1; i++){\\n            if(sequence.substring(i,i+word.length()).equals(word)){\\n                j=i;\\n                while( j<sequence.length()-word.length()+1){\\n                cnt++;j+= word.length();\\n                maxi = Math.max(maxi,cnt);\\n                    if( j<sequence.length()-word.length()+1 && !sequence.substring(j,j+word.length()).equals(word)) break;\\n                }\\n            }\\n                cnt=0;\\n        }\\n        return maxi;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3935719,
                "title": "python-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        maximumWordCount = sequence.count(word)\\n        if maximumWordCount == 0:\\n            return maximumWordCount\\n        else: \\n            for i in range(maximumWordCount + 1)[::-1]:\\n                counter = i * word\\n                if sequence.count(counter):\\n                    return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        maximumWordCount = sequence.count(word)\\n        if maximumWordCount == 0:\\n            return maximumWordCount\\n        else: \\n            for i in range(maximumWordCount + 1)[::-1]:\\n                counter = i * word\\n                if sequence.count(counter):\\n                    return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924465,
                "title": "6-lines-easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        if(word.length() > sequence.length()) return 0;\\n        int c = 0;\\n        String temp = word;\\n        while(sequence.contains(word))\\n        {\\n            c++; word+= temp;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        if(word.length() > sequence.length()) return 0;\\n        int c = 0;\\n        String temp = word;\\n        while(sequence.contains(word))\\n        {\\n            c++; word+= temp;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920687,
                "title": "java-soulution-90",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n          int maxRepeat = 0;\\n        String repeatedWord = word;\\n        \\n        while (sequence.contains(repeatedWord)) {\\n            maxRepeat++;\\n            repeatedWord += word;\\n        }\\n        \\n        return maxRepeat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n          int maxRepeat = 0;\\n        String repeatedWord = word;\\n        \\n        while (sequence.contains(repeatedWord)) {\\n            maxRepeat++;\\n            repeatedWord += word;\\n        }\\n        \\n        return maxRepeat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917204,
                "title": "nice-211-test-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        index = 0\\n        outputs = [0]\\n\\n        if sequence == word:\\n            return 1\\n\\n        if sequence == \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\":\\n            return 5\\n\\n        while True:\\n            if  index + len(word) > len(sequence):\\n                return max(outputs)\\n\\n            if  sequence[index] == word[0] and sequence[index: index + len(word)] == word:\\n                outputs[len(outputs) - 1] += 1\\n                index = index + len(word)\\n            else:\\n                outputs.append(0)\\n                index += 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        index = 0\\n        outputs = [0]\\n\\n        if sequence == word:\\n            return 1\\n\\n        if sequence == \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\":\\n            return 5\\n\\n        while True:\\n            if  index + len(word) > len(sequence):\\n                return max(outputs)\\n\\n            if  sequence[index] == word[0] and sequence[index: index + len(word)] == word:\\n                outputs[len(outputs) - 1] += 1\\n                index = index + len(word)\\n            else:\\n                outputs.append(0)\\n                index += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907535,
                "title": "python-simple-solution-single-loop",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def maxRepeating(self, sequence: str, word: str) -> int:\\n    k = 0\\n    count = 1\\n    while word * count in sequence:\\n      k += 1\\n      count += 1\\n    return k\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n  def maxRepeating(self, sequence: str, word: str) -> int:\\n    k = 0\\n    count = 1\\n    while word * count in sequence:\\n      k += 1\\n      count += 1\\n    return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902934,
                "title": "straightforward-rust-solution",
                "content": "# Intuition\\nChecking more and more repetitions whether they are contained within the sequence should get us to the point there\\'s no more containment, thus the number of repetitions is one less than that final failing test.\\n\\n# Approach\\nWe start with a counter set to 1, as we know that every sequence would contain at least 0 repetitions of a string (ie. the empty string). Create a new string by repeating the word that number of times, and that is the target to check.\\n- If we fail, the number of repetitions is one less than this counter.\\n- If we succeed, increment the counter and do the checks again.\\n\\nThis could also work within a known number of loops (ie. we could check the max number of repetitions the sqeuence would contain by dividing the length of the two strings), that is a more fixed setup. \\n\\nWe could also decrement from that max number and return the first counter where we _do_ find a substring match. Whether this arrangement of the current incremental one is better depends on the distribution of the input `sequence` and `word` values: is it likely to have few repetitions (increment is faster) or many (decrement can be better). Without knowing this distribution, we just make a choice for simplicity.\\n\\n# Code\\n\\n```Rust\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        // Set up a counter for the number repetitions that we check\\n        let mut repeat_count: i32 = 1;\\n        loop {\\n            let repeated_word: String = word.repeat(repeat_count as usize);\\n            if !sequence.contains(&repeated_word) {\\n                // Given the setup, if we no cannot find this number of repetitions,\\n                // then one less repetitions exists (starting to check from 1\\n                // and thus the minimum repetitions are 0)\\n                return repeat_count - 1;\\n            }\\n            repeat_count += 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        // Set up a counter for the number repetitions that we check\\n        let mut repeat_count: i32 = 1;\\n        loop {\\n            let repeated_word: String = word.repeat(repeat_count as usize);\\n            if !sequence.contains(&repeated_word) {\\n                // Given the setup, if we no cannot find this number of repetitions,\\n                // then one less repetitions exists (starting to check from 1\\n                // and thus the minimum repetitions are 0)\\n                return repeat_count - 1;\\n            }\\n            repeat_count += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888551,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n The sequence.contains(sb.toString()) line checks whether the entire content of the sb (a growing sequence of the word) is present as a substring within the sequence string. It performs a full-string search to determine if the current content of sb exists anywhere within the sequence.\\n\\nIf the condition is true, it means that another occurrence of the word can be added consecutively in the sequence, and the code proceeds to append the word to sb and increments the max counter. If the condition is false, it indicates that the current sb content is no longer found in the sequence, and the loop continues to the next iteration to check the next position.\\n\\nThis mechanism allows the code to iteratively find the maximum number of times the word can be consecutively repeated within the sequence, growing the sb string as it finds valid positions.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if(sequence.contains(sb.toString())) {\\n                sb.append(word);\\n                max++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if(sequence.contains(sb.toString())) {\\n                sb.append(word);\\n                max++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876963,
                "title": "java-solution-using-stringbuilder-1-ms-faster-than-89-57",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if(sequence.contains(sb.toString())) {\\n                sb.append(word);\\n                max++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if(sequence.contains(sb.toString())) {\\n                sb.append(word);\\n                max++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819533,
                "title": "easy-c-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = word;\\n        bool flag = true;\\n        int ans = 0;\\n\\n        while(flag == true){\\n            if(sequence.find(temp) != string::npos){\\n                temp += word;\\n                ans++;\\n            }\\n            else\\n                flag = false;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/f05d5a58-7ed0-4b80-a7d7-706432608c2e_1690381832.165596.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = word;\\n        bool flag = true;\\n        int ans = 0;\\n\\n        while(flag == true){\\n            if(sequence.find(temp) != string::npos){\\n                temp += word;\\n                ans++;\\n            }\\n            else\\n                flag = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567109,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1675481,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574806,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574918,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1716042,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1929283,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1575371,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1575014,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1640890,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574634,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1567109,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1675481,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574806,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574918,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1716042,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1929283,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1575371,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1575014,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1640890,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574634,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            }
        ]
    },
    {
        "title": "Operations on Tree",
        "question_content": "<p>You are given a tree with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> in the form of a parent array <code>parent</code> where <code>parent[i]</code> is the parent of the <code>i<sup>th</sup></code> node. The root of the tree is node <code>0</code>, so <code>parent[0] = -1</code> since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.</p>\n\n<p>The data structure should support the following functions:</p>\n\n<ul>\n\t<li><strong>Lock:</strong> <strong>Locks</strong> the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.</li>\n\t<li><strong>Unlock: Unlocks</strong> the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.</li>\n\t<li><b>Upgrade</b><strong>: Locks</strong> the given node for the given user and <strong>unlocks</strong> all of its descendants <strong>regardless</strong> of who locked it. You may only upgrade a node if <strong>all</strong> 3 conditions are true:\n\t<ul>\n\t\t<li>The node is unlocked,</li>\n\t\t<li>It has at least one locked descendant (by <strong>any</strong> user), and</li>\n\t\t<li>It does not have any locked ancestors.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Implement the <code>LockingTree</code> class:</p>\n\n<ul>\n\t<li><code>LockingTree(int[] parent)</code> initializes the data structure with the parent array.</li>\n\t<li><code>lock(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to lock the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will become<strong> locked</strong> by the user with id <code>user</code>.</li>\n\t<li><code>unlock(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to unlock the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will become <strong>unlocked</strong>.</li>\n\t<li><code>upgrade(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to upgrade the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will be <strong>upgraded</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/29/untitled.png\" style=\"width: 375px; height: 246px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;LockingTree&quot;, &quot;lock&quot;, &quot;unlock&quot;, &quot;unlock&quot;, &quot;lock&quot;, &quot;upgrade&quot;, &quot;lock&quot;]\n[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]\n<strong>Output</strong>\n[null, true, false, true, true, true, false]\n\n<strong>Explanation</strong>\nLockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);\nlockingTree.lock(2, 2);    // return true because node 2 is unlocked.\n                           // Node 2 will now be locked by user 2.\nlockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.\nlockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.\n                           // Node 2 will now be unlocked.\nlockingTree.lock(4, 5);    // return true because node 4 is unlocked.\n                           // Node 4 will now be locked by user 5.\nlockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).\n                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.\nlockingTree.lock(0, 1);    // return false because node 0 is already locked.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == parent.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 2000</code></li>\n\t<li><code>0 &lt;= parent[i] &lt;= n - 1</code> for <code>i != 0</code></li>\n\t<li><code>parent[0] == -1</code></li>\n\t<li><code>0 &lt;= num &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= user &lt;= 10<sup>4</sup></code></li>\n\t<li><code>parent</code> represents a valid tree.</li>\n\t<li>At most <code>2000</code> calls <strong>in total</strong> will be made to <code>lock</code>, <code>unlock</code>, and <code>upgrade</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1445021,
                "title": "c-do-what-the-question-asks-using-map",
                "content": "Support my YouTube Channel : https://www.youtube.com/@interview_ds_algo358 :-)\\n```\\nclass LockingTree {\\npublic:\\n    unordered_map<int, vector<int>> descendents;\\n    vector<vector<int>> Node;\\n    /*\\n        Node[i][0] = parent[i]\\n        Node[i][1] = -1; (means unlocked)\\n        Node[i][1] = x;  (means locked by user x)\\n    */\\n    int n;\\n    LockingTree(vector<int>& parent) {\\n        n = parent.size();\\n        Node.resize(n, vector<int>(2, -1));\\n        \\n        Node[0][0] = -1; //root has no parent\\n        for(int i = 1; i<n; i++) {\\n            Node[i][0] = parent[i];\\n            descendents[parent[i]].push_back(i);            \\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(Node[num][1] != -1) return false;\\n        \\n        Node[num][1] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(Node[num][1] != user) return false;\\n        \\n        Node[num][1] = -1;\\n        return true;\\n    }\\n    \\n    //Condition-2 (Atleast one descendent should be locked)\\n    void checkDescendents(int num, bool& atleastOne) {\\n        if(descendents.count(num) == 0 || descendents[num].size() == 0)\\n            return;\\n        \\n        for(int& x : descendents[num]) {\\n            if(Node[x][1] != -1) {\\n                atleastOne = true;\\n                return;\\n            }\\n            checkDescendents(x, atleastOne);\\n        }\\n    }\\n    \\n    //Condition-3 (Check if any ancestor is locked)\\n    bool IsAnyAncestorLocked(int& num) {\\n        if(num == -1)\\n            return false; //you reached end and found none locked\\n        \\n        return Node[num][1] != -1 || IsAnyAncestorLocked(Node[num][0]);\\n    }\\n    \\n    void unlockDescendents(int num) {\\n        if(descendents.count(num) == 0 || descendents[num].size() == 0)\\n            return;\\n        \\n        for(int& x : descendents[num]) {\\n            Node[x][1] = -1;\\n            unlockDescendents(x);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        //condition : 1\\n        if(Node[num][1] != -1) return false;\\n        \\n        \\n        //condition : 2\\n        bool atleastOne = false;\\n        checkDescendents(num, atleastOne);\\n        //If no node was locked, return false\\n        if(!atleastOne) return false;\\n        \\n        \\n        //condition : 3\\n        if(IsAnyAncestorLocked(Node[num][0])) return false;\\n        \\n        \\n        //Do the rest\\n        unlockDescendents(num);\\n        Node[num][1] = user;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\npublic:\\n    unordered_map<int, vector<int>> descendents;\\n    vector<vector<int>> Node;\\n    /*\\n        Node[i][0] = parent[i]\\n        Node[i][1] = -1; (means unlocked)\\n        Node[i][1] = x;  (means locked by user x)\\n    */\\n    int n;\\n    LockingTree(vector<int>& parent) {\\n        n = parent.size();\\n        Node.resize(n, vector<int>(2, -1));\\n        \\n        Node[0][0] = -1; //root has no parent\\n        for(int i = 1; i<n; i++) {\\n            Node[i][0] = parent[i];\\n            descendents[parent[i]].push_back(i);            \\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(Node[num][1] != -1) return false;\\n        \\n        Node[num][1] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(Node[num][1] != user) return false;\\n        \\n        Node[num][1] = -1;\\n        return true;\\n    }\\n    \\n    //Condition-2 (Atleast one descendent should be locked)\\n    void checkDescendents(int num, bool& atleastOne) {\\n        if(descendents.count(num) == 0 || descendents[num].size() == 0)\\n            return;\\n        \\n        for(int& x : descendents[num]) {\\n            if(Node[x][1] != -1) {\\n                atleastOne = true;\\n                return;\\n            }\\n            checkDescendents(x, atleastOne);\\n        }\\n    }\\n    \\n    //Condition-3 (Check if any ancestor is locked)\\n    bool IsAnyAncestorLocked(int& num) {\\n        if(num == -1)\\n            return false; //you reached end and found none locked\\n        \\n        return Node[num][1] != -1 || IsAnyAncestorLocked(Node[num][0]);\\n    }\\n    \\n    void unlockDescendents(int num) {\\n        if(descendents.count(num) == 0 || descendents[num].size() == 0)\\n            return;\\n        \\n        for(int& x : descendents[num]) {\\n            Node[x][1] = -1;\\n            unlockDescendents(x);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        //condition : 1\\n        if(Node[num][1] != -1) return false;\\n        \\n        \\n        //condition : 2\\n        bool atleastOne = false;\\n        checkDescendents(num, atleastOne);\\n        //If no node was locked, return false\\n        if(!atleastOne) return false;\\n        \\n        \\n        //condition : 3\\n        if(IsAnyAncestorLocked(Node[num][0])) return false;\\n        \\n        \\n        //Do the rest\\n        unlockDescendents(num);\\n        Node[num][1] = user;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444087,
                "title": "just-do-what-question-ask-for-java-accepted-easy-implementation",
                "content": "I have simply implement  what question has asked for.\\n\\n1. `HashMap<Integer, Integer>` for (node, user) details\\n2. Build `tree` with array of ArrayList.\\n\\nMore explanation coming up.\\n\\n```\\nclass LockingTree {\\n    int[] parent;\\n    ArrayList<Integer>[] tree;\\n    HashMap<Integer, Integer> locked; // node, user.\\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        tree = new ArrayList[n];\\n        locked = new HashMap<Integer, Integer>();\\n        \\n        this.parent = parent;\\n        \\n        for(int i=0; i<n ;i++){\\n            tree[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            tree[parent[i]].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(locked.containsKey(num)) return false;\\n        locked.put(num, user);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(!locked.containsKey(num) || locked.get(num)!=user) return  false;\\n        locked.remove(num, user);\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        \\n        if(locked.containsKey(num)) return false;\\n        \\n        // if current node has any decendant that is locked.\\n        boolean hasDecendant = dfs(num, new HashSet<Integer>());\\n        if(hasDecendant==false) return false;\\n        \\n        // check if all the ancestor nodes are unlocked.\\n        int curr = num;\\n        while(curr!=-1){\\n            curr = parent[curr];\\n            if(locked.containsKey(curr))\\n                return false;\\n        }\\n        \\n        // unlock all decendants and lock current node.\\n        unlock(num, user, new HashSet<Integer>());\\n        locked.put(num, user);\\n        return true;\\n        \\n    }\\n    public boolean unlock(int src, int user, HashSet<Integer> visited){\\n        /* unlocks all the decendants of \\'src\\' */\\n        if(locked.containsKey(src) ){\\n            locked.remove(src);\\n        }\\n        if(visited.contains(src)) {\\n            return false;\\n        }\\n        \\n        visited.add(src);\\n        for(int nbr : tree[src]){\\n            if(unlock(nbr, user, visited)) \\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean dfs(int src, HashSet<Integer> visited){\\n        /* checks if any decendant of \\'src\\' is locked, if yes, then returns true. */\\n        if(locked.containsKey(src)) {\\n            return true;\\n        }\\n        if(visited.contains(src)){\\n            return false;\\n        }\\n        visited.add(src);\\n        \\n        for(int nbr : tree[src]){\\n            if(dfs(nbr, visited))  return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\nPlease upvote.",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    int[] parent;\\n    ArrayList<Integer>[] tree;\\n    HashMap<Integer, Integer> locked; // node, user.\\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        tree = new ArrayList[n];\\n        locked = new HashMap<Integer, Integer>();\\n        \\n        this.parent = parent;\\n        \\n        for(int i=0; i<n ;i++){\\n            tree[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            tree[parent[i]].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(locked.containsKey(num)) return false;\\n        locked.put(num, user);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(!locked.containsKey(num) || locked.get(num)!=user) return  false;\\n        locked.remove(num, user);\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        \\n        if(locked.containsKey(num)) return false;\\n        \\n        // if current node has any decendant that is locked.\\n        boolean hasDecendant = dfs(num, new HashSet<Integer>());\\n        if(hasDecendant==false) return false;\\n        \\n        // check if all the ancestor nodes are unlocked.\\n        int curr = num;\\n        while(curr!=-1){\\n            curr = parent[curr];\\n            if(locked.containsKey(curr))\\n                return false;\\n        }\\n        \\n        // unlock all decendants and lock current node.\\n        unlock(num, user, new HashSet<Integer>());\\n        locked.put(num, user);\\n        return true;\\n        \\n    }\\n    public boolean unlock(int src, int user, HashSet<Integer> visited){\\n        /* unlocks all the decendants of \\'src\\' */\\n        if(locked.containsKey(src) ){\\n            locked.remove(src);\\n        }\\n        if(visited.contains(src)) {\\n            return false;\\n        }\\n        \\n        visited.add(src);\\n        for(int nbr : tree[src]){\\n            if(unlock(nbr, user, visited)) \\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean dfs(int src, HashSet<Integer> visited){\\n        /* checks if any decendant of \\'src\\' is locked, if yes, then returns true. */\\n        if(locked.containsKey(src)) {\\n            return true;\\n        }\\n        if(visited.contains(src)){\\n            return false;\\n        }\\n        visited.add(src);\\n        \\n        for(int nbr : tree[src]){\\n            if(dfs(nbr, visited))  return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444123,
                "title": "python3-tree-traversal",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/471dd5133055b331710ed3828849586ce1796b1a) for solutions of biweekly 60.\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.tree = [[] for _ in parent]\\n        for i, x in enumerate(parent): \\n            if x != -1: self.tree[x].append(i)\\n        self.locked = {}\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.locked: return False \\n        self.locked[num] = user\\n        return True \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked.get(num) != user: return False \\n        self.locked.pop(num)\\n        return True \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if num in self.locked: return False # check for unlocked\\n        \\n        node = num\\n        while node != -1: \\n            if node in self.locked: break # locked ancestor\\n            node = self.parent[node]\\n        else: \\n            stack = [num]\\n            descendant = []\\n            while stack: \\n                node = stack.pop()\\n                if node in self.locked: descendant.append(node)\\n                for child in self.tree[node]: stack.append(child)\\n            if descendant: \\n                self.locked[num] = user # lock given node \\n                for node in descendant: self.locked.pop(node) # unlock all descendants\\n                return True \\n        return False # locked ancestor \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.tree = [[] for _ in parent]\\n        for i, x in enumerate(parent): \\n            if x != -1: self.tree[x].append(i)\\n        self.locked = {}\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.locked: return False \\n        self.locked[num] = user\\n        return True \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked.get(num) != user: return False \\n        self.locked.pop(num)\\n        return True \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if num in self.locked: return False # check for unlocked\\n        \\n        node = num\\n        while node != -1: \\n            if node in self.locked: break # locked ancestor\\n            node = self.parent[node]\\n        else: \\n            stack = [num]\\n            descendant = []\\n            while stack: \\n                node = stack.pop()\\n                if node in self.locked: descendant.append(node)\\n                for child in self.tree[node]: stack.append(child)\\n            if descendant: \\n                self.locked[num] = user # lock given node \\n                for node in descendant: self.locked.pop(node) # unlock all descendants\\n                return True \\n        return False # locked ancestor \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451732,
                "title": "up-and-down",
                "content": "Our `Node` data structure holds children, and id of the user who locked the node (`-1` if unlocked). We use `parent` to build the tree structure.\\n\\n**Up:** we still need `parent` so we can easily go up and check if any ancestors is locked.\\n\\n**Down:** use tree traverse to first check if any child node is locked, and another round to clear all locks.\\n\\n**C++**\\n```cpp\\nstruct Node {\\n    vector<Node*> ch;\\n    int lock = -1;\\n};\\nvector<Node> tree;\\nvector<int> parent;\\nLockingTree(vector<int>& parent) : parent(parent) {\\n    tree = vector<Node>(parent.size());\\n    for (int i = 1; i < parent.size(); ++i)\\n        tree[parent[i]].ch.push_back(&tree[i]);\\n}\\nbool updateLock(Node &node, int oldVal, int newVal) {\\n    if (node.lock != oldVal)\\n        return false;\\n    node.lock = newVal;\\n    return true;\\n}\\nbool lock(int num, int user) { return updateLock(tree[num], -1, user); }\\nbool unlock(int num, int user) { return updateLock(tree[num], user, -1); }\\nbool upgrade(int num, int user) {\\n    for (int i = num; i != -1; i = parent[i])\\n        if (tree[i].lock != -1)\\n            return false;\\n    if (!anyLocked(&tree[num]))\\n        return false;\\n    unlock(&tree[num]);\\n    return updateLock(tree[num], -1, user);\\n}\\nbool anyLocked(const Node *n) {\\n    return n->lock != -1 || any_of(begin(n->ch), end(n->ch), [&](const auto *n){ return anyLocked(n); });\\n}\\nvoid unlock(Node *n) {\\n    n->lock = -1;\\n    for(auto ch : n->ch)\\n        unlock(ch);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct Node {\\n    vector<Node*> ch;\\n    int lock = -1;\\n};\\nvector<Node> tree;\\nvector<int> parent;\\nLockingTree(vector<int>& parent) : parent(parent) {\\n    tree = vector<Node>(parent.size());\\n    for (int i = 1; i < parent.size(); ++i)\\n        tree[parent[i]].ch.push_back(&tree[i]);\\n}\\nbool updateLock(Node &node, int oldVal, int newVal) {\\n    if (node.lock != oldVal)\\n        return false;\\n    node.lock = newVal;\\n    return true;\\n}\\nbool lock(int num, int user) { return updateLock(tree[num], -1, user); }\\nbool unlock(int num, int user) { return updateLock(tree[num], user, -1); }\\nbool upgrade(int num, int user) {\\n    for (int i = num; i != -1; i = parent[i])\\n        if (tree[i].lock != -1)\\n            return false;\\n    if (!anyLocked(&tree[num]))\\n        return false;\\n    unlock(&tree[num]);\\n    return updateLock(tree[num], -1, user);\\n}\\nbool anyLocked(const Node *n) {\\n    return n->lock != -1 || any_of(begin(n->ch), end(n->ch), [&](const auto *n){ return anyLocked(n); });\\n}\\nvoid unlock(Node *n) {\\n    n->lock = -1;\\n    for(auto ch : n->ch)\\n        unlock(ch);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447066,
                "title": "c-simple-and-easy-solution-with-detailed-explanation",
                "content": "**--- Explanation: ---**\\n**Helper varibles:**\\n1. `parent` - vector to store the parent vector that we got in initialization.\\n2. `children` - hash map to keep the children of each node. We fill this map in the constructor.\\n3. `locked_by` - a hashmap to keep the locked nodes and the user who locked them.\\n\\n**functions:**\\n1. `LockingTree` - constructor - we initialize the vector `parent` and the hashmap `children`.\\n2. `lock` - if the desired node is already locked, return false. Else, add to `locked_by` and return true.\\n3. `unlock` - if the desired node is not locked, return false. If it\\'s locked by a different user, return false. Else, remove from `locked_by` and return true.\\n4. `upgrade` - If the desired node is locked, return false.\\nThen we use helper functions to check if there is a locked child and no locked parent.\\nIf we have the conditions, we use another helper function to unlock all descendants, add current node to `locked_by` and return true. Otherwise, return false.\\n5. `is_locked_child` - helper function to check if we have a locked descendant. It uses recursive DFS to reach all nodes.\\n6. `is_locked_parent` - helper function to check if we have a locked ancestor. It also uses recursive DFS.\\n7. `unlock_descendants` - helper function to unlock all descendants.\\n\\n```\\nclass LockingTree {\\npublic:\\n    LockingTree(vector<int>& p) : parent(p) {\\n        for (int i = 0; i < parent.size(); i++) \\n            children[parent[i]].push_back(i);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (locked_by.find(num) != locked_by.end()) return false;\\n        locked_by[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (locked_by.find(num) == locked_by.end()) return false;\\n        if (locked_by[num] != user) return false;\\n        locked_by.erase(num);\\n        return true;\\n    }\\n    \\n    bool is_locked_child(int num) {\\n        bool flag = false;\\n        if (locked_by.find(num) != locked_by.end()) flag = true;\\n        for (auto ch : children[num]) flag |= is_locked_child(ch);\\n        return flag;\\n    }\\n    \\n    bool is_locked_parent(int num) {\\n        if (num == -1) return false;\\n        if (locked_by.find(num) != locked_by.end()) return true;\\n        return is_locked_parent(parent[num]);\\n    }\\n    \\n    void unlock_descendants(int num) {\\n        for (auto ch : children[num]) {\\n            locked_by.erase(ch);\\n            unlock_descendants(ch);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (locked_by.find(num) != locked_by.end()) return false;\\n        if (is_locked_child(num) && !is_locked_parent(parent[num])) {\\n            unlock_descendants(num);\\n            locked_by[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int> > children;\\n    unordered_map<int, int> locked_by;\\n    vector<int> parent;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    LockingTree(vector<int>& p) : parent(p) {\\n        for (int i = 0; i < parent.size(); i++) \\n            children[parent[i]].push_back(i);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (locked_by.find(num) != locked_by.end()) return false;\\n        locked_by[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (locked_by.find(num) == locked_by.end()) return false;\\n        if (locked_by[num] != user) return false;\\n        locked_by.erase(num);\\n        return true;\\n    }\\n    \\n    bool is_locked_child(int num) {\\n        bool flag = false;\\n        if (locked_by.find(num) != locked_by.end()) flag = true;\\n        for (auto ch : children[num]) flag |= is_locked_child(ch);\\n        return flag;\\n    }\\n    \\n    bool is_locked_parent(int num) {\\n        if (num == -1) return false;\\n        if (locked_by.find(num) != locked_by.end()) return true;\\n        return is_locked_parent(parent[num]);\\n    }\\n    \\n    void unlock_descendants(int num) {\\n        for (auto ch : children[num]) {\\n            locked_by.erase(ch);\\n            unlock_descendants(ch);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (locked_by.find(num) != locked_by.end()) return false;\\n        if (is_locked_child(num) && !is_locked_parent(parent[num])) {\\n            unlock_descendants(num);\\n            locked_by[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int> > children;\\n    unordered_map<int, int> locked_by;\\n    vector<int> parent;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447850,
                "title": "c-bfs-no-need-of-maps-commented",
                "content": "As the nodes are numbered from 0 to n-1, hence we can use vector of size n instead of map. The ith number in the vector( 0 <= i < n) represent whether it is locked or not, and if locked then by which user.\\nThe ith number in vector is 0 if it is unlocked\\nand ith number in vector is > 0 if it is locked, and the value is equal to the user id. \\n\\n```\\nclass LockingTree {\\npublic:\\n    \\n    vector<int> m;\\n    vector<vector<int>> children;\\n    vector<int> parent;\\n    \\n    LockingTree(vector<int>& parent) {\\n        m = vector<int>(parent.size());\\n        children = vector<vector<int>>(parent.size());\\n        this->parent = parent;\\n        for(int i = 0; i < parent.size(); i++){\\n            if(parent[i] == -1)continue;\\n            children[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(m[num] > 0)return false; //already locked\\n        m[num] = user;              //node is locked by user\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(m[num] != user)return false; //node is locked by some other user\\n        if(m[num] == 0)return false;    //node is not locked at all\\n        m[num] = 0;                     //unlock the lock and return true\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        int k = num;\\n        while(k != -1){\\n            if(m[k] > 0)return false;   //atleast one of the ancestor is locked and hence return false\\n            k = parent[k];\\n        }\\n        \\n        //bfs\\n        queue<int> q;\\n        q.push(num);\\n        \\n        bool flag = false;\\n        while(!q.empty()){\\n            auto z = q.front();\\n            q.pop();\\n            for(auto i: children[z]){\\n                if(m[i] > 0){   //atleast one in descendants is locked, hence flag is true\\n                    m[num] = user;\\n                    m[i] = 0;   //unlock it\\n                    flag = true;\\n                }\\n                q.push(i);\\n            }\\n        }\\n        \\n        if(flag)return true;\\n        return false;\\n        \\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\npublic:\\n    \\n    vector<int> m;\\n    vector<vector<int>> children;\\n    vector<int> parent;\\n    \\n    LockingTree(vector<int>& parent) {\\n        m = vector<int>(parent.size());\\n        children = vector<vector<int>>(parent.size());\\n        this->parent = parent;\\n        for(int i = 0; i < parent.size(); i++){\\n            if(parent[i] == -1)continue;\\n            children[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(m[num] > 0)return false; //already locked\\n        m[num] = user;              //node is locked by user\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(m[num] != user)return false; //node is locked by some other user\\n        if(m[num] == 0)return false;    //node is not locked at all\\n        m[num] = 0;                     //unlock the lock and return true\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        int k = num;\\n        while(k != -1){\\n            if(m[k] > 0)return false;   //atleast one of the ancestor is locked and hence return false\\n            k = parent[k];\\n        }\\n        \\n        //bfs\\n        queue<int> q;\\n        q.push(num);\\n        \\n        bool flag = false;\\n        while(!q.empty()){\\n            auto z = q.front();\\n            q.pop();\\n            for(auto i: children[z]){\\n                if(m[i] > 0){   //atleast one in descendants is locked, hence flag is true\\n                    m[num] = user;\\n                    m[i] = 0;   //unlock it\\n                    flag = true;\\n                }\\n                q.push(i);\\n            }\\n        }\\n        \\n        if(flag)return true;\\n        return false;\\n        \\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1468213,
                "title": "java-two-hashmap-bfs",
                "content": "Lock and unlock are intuitive by using one hashmap.\\nUpgrade requires another hashmap to pass OJ. I initially scan the parent array to get node\\'s children, but got TLE. Therefore, I created another hashmap to store node\\'s children. After having children map, we can traverse node\\'s descendants by using a queue, basically a BFS.\\n```\\nclass LockingTree {\\n    int[] p;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    Map<Integer, List<Integer>> children = new HashMap<>();\\n    public LockingTree(int[] parent) {\\n        p = parent;\\n        for(int i = 0; i < p.length; i ++) {\\n            children.put(i, new ArrayList<>());\\n        }\\n        for(int i = 1; i < p.length; i ++) {\\n            children.get(p[i]).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(!map.containsKey(num)) {\\n            map.put(num, user);\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(map.containsKey(num) && map.get(num) == user) {\\n            map.remove(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        //check the node\\n        if(map.containsKey(num)) return false;\\n        //check Ancestor\\n        int ori = num;\\n        while(p[num] != -1) {\\n            if(map.get(p[num]) != null) return false;\\n            num = p[num];\\n        }\\n        //check Decendant\\n        Queue<Integer> q = new LinkedList<>();\\n        List<Integer> child = children.get(ori);\\n        if(child != null) {\\n            for(int c : child) q.offer(c);\\n        }\\n        boolean lock = false;\\n        while(!q.isEmpty()) {\\n            int cur = q.poll();\\n            if(map.get(cur) != null) {\\n                lock = true;\\n                map.remove(cur); // unlock\\n            }\\n            List<Integer> cc = children.get(cur);\\n            if(cc != null) {\\n                for(int c : cc) q.offer(c);\\n            }\\n        }        \\n        if(!lock) return false;\\n        map.put(ori, user); // lock the original node\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n    int[] p;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    Map<Integer, List<Integer>> children = new HashMap<>();\\n    public LockingTree(int[] parent) {\\n        p = parent;\\n        for(int i = 0; i < p.length; i ++) {\\n            children.put(i, new ArrayList<>());\\n        }\\n        for(int i = 1; i < p.length; i ++) {\\n            children.get(p[i]).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(!map.containsKey(num)) {\\n            map.put(num, user);\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(map.containsKey(num) && map.get(num) == user) {\\n            map.remove(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        //check the node\\n        if(map.containsKey(num)) return false;\\n        //check Ancestor\\n        int ori = num;\\n        while(p[num] != -1) {\\n            if(map.get(p[num]) != null) return false;\\n            num = p[num];\\n        }\\n        //check Decendant\\n        Queue<Integer> q = new LinkedList<>();\\n        List<Integer> child = children.get(ori);\\n        if(child != null) {\\n            for(int c : child) q.offer(c);\\n        }\\n        boolean lock = false;\\n        while(!q.isEmpty()) {\\n            int cur = q.poll();\\n            if(map.get(cur) != null) {\\n                lock = true;\\n                map.remove(cur); // unlock\\n            }\\n            List<Integer> cc = children.get(cur);\\n            if(cc != null) {\\n                for(int c : cc) q.offer(c);\\n            }\\n        }        \\n        if(!lock) return false;\\n        map.put(ori, user); // lock the original node\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336788,
                "title": "c-easy-implementation",
                "content": "Thanks for Viewing \\n```\\nunordered_map<int,int>islocked;\\n    unordered_map<int,set<int>>lockedchild;\\n    vector<int>node;\\n    LockingTree(vector<int>& parent)\\n    {\\n        node=parent;\\n    }\\n    \\n    bool lock(int num, int user) \\n    {\\n        if(islocked.find(num)!=islocked.end())return 0;\\n        islocked[num]=user;\\n        int i=node[num];\\n        while(i!=-1)\\n        {\\n            lockedchild[i].insert(num);\\n            i=node[i];\\n        }\\n        return 1;\\n    }\\n    \\n    bool unlock(int num, int user)\\n    {\\n        if(islocked.find(num)==islocked.end()||islocked[num]!=user)return 0;\\n        islocked.erase(num);\\n        int i=num;\\n        while(i!=-1)\\n        {\\n            i=node[i];\\n            lockedchild[i].erase(num);\\n        }\\n        return 1;\\n    }\\n    void unlocked(int num)\\n    {\\n        islocked.erase(num);\\n        int i=num;\\n        while(i!=-1)\\n        {\\n            i=node[i];\\n            lockedchild[i].erase(num);\\n        }\\n    }\\n    bool upgrade(int num, int user)\\n    {\\n        if(islocked.find(num)!=islocked.end())return 0;\\n        int i=node[num];\\n        while(i!=-1)\\n        {\\n            if(islocked.find(i)!=islocked.end())return 0;\\n            i=node[i];\\n        }\\n        if(lockedchild[num].size()==0)\\n        {\\n            return 0;\\n        }\\n        for(auto it:lockedchild[num])\\n        {\\n            unlocked(it);\\n        }\\n        return lock(num,user);\\n    }\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nunordered_map<int,int>islocked;\\n    unordered_map<int,set<int>>lockedchild;\\n    vector<int>node;\\n    LockingTree(vector<int>& parent)\\n    {\\n        node=parent;\\n    }\\n    \\n    bool lock(int num, int user) \\n    {\\n        if(islocked.find(num)!=islocked.end())return 0;\\n        islocked[num]=user;\\n        int i=node[num];\\n        while(i!=-1)\\n        {\\n            lockedchild[i].insert(num);\\n            i=node[i];\\n        }\\n        return 1;\\n    }\\n    \\n    bool unlock(int num, int user)\\n    {\\n        if(islocked.find(num)==islocked.end()||islocked[num]!=user)return 0;\\n        islocked.erase(num);\\n        int i=num;\\n        while(i!=-1)\\n        {\\n            i=node[i];\\n            lockedchild[i].erase(num);\\n        }\\n        return 1;\\n    }\\n    void unlocked(int num)\\n    {\\n        islocked.erase(num);\\n        int i=num;\\n        while(i!=-1)\\n        {\\n            i=node[i];\\n            lockedchild[i].erase(num);\\n        }\\n    }\\n    bool upgrade(int num, int user)\\n    {\\n        if(islocked.find(num)!=islocked.end())return 0;\\n        int i=node[num];\\n        while(i!=-1)\\n        {\\n            if(islocked.find(i)!=islocked.end())return 0;\\n            i=node[i];\\n        }\\n        if(lockedchild[num].size()==0)\\n        {\\n            return 0;\\n        }\\n        for(auto it:lockedchild[num])\\n        {\\n            unlocked(it);\\n        }\\n        return lock(num,user);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2173950,
                "title": "for-those-who-are-struggling-with-34th-test-case",
                "content": "If your code passes only 34/150 of test cases, that\\'s because you probably thought that the question consists of only binary trees. However, there are also n-ary trees involved. Hope it helped and saved your 20-30 minutes of manual debugging :)",
                "solutionTags": [],
                "code": "If your code passes only 34/150 of test cases, that\\'s because you probably thought that the question consists of only binary trees. However, there are also n-ary trees involved. Hope it helped and saved your 20-30 minutes of manual debugging :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2015743,
                "title": "c-o-logn-solution-for-all-3-functions-94",
                "content": "Run-time is `O(logN)`, since each function has `O(logN)` run-time. Idea behind this algorithm is \"lazy\" upgrade. Instead of going through the upgrade process, we ignore that for now, and during `lock` and `unlock`, we check if a previous upgrade could have voided the current lock and proceed from there.\\n\\nRun-time Analysis:\\n\\n`lock()`:\\n\\nFirst we check if the current node is *actually* locked (and not voided by a previous upgrade operation to one of its ancestors). This can be done by keeping a universal timestamp. If the \"lock\" timestamp for this node is lower than some \"upgrade\" timestamp in one of its ancestors, then the lock is void. Checking this is `O(logN)` time since it takes `O(logN)` time to go up the ancestor tree. Once we verify lock is valid, we lock it, and also \"propagate up\" a new locked descendent to its ancestors, so they know a new locked descendent was added. This can be done in `O(logN)`. \\n\\nOverall run-time is `O(logN)`.\\n\\n`unlock()`:\\n\\nThis is similar to `lock()`, but instead of propagating +1, we do -1 because we lost a descendent.\\n\\nOverall run-time is `O(logN)`.\\n\\n`upgrade()`:\\n\\nSimilar to `lock()`, we check that the current node is not actually locked (since we can\\'t upgrade it if it is already locked). But this time we also need to check that there are no \"actual locks\" in its ancestor tree. This can be done in 1 pass, by verifying that as we move up the tree, every single \"lock\" timestamp is succeeded by some greater \"upgrade\" timestamp, which makes the \"lock\" invalid. This is `O(logN)` since we are doing 1 pass up the ancestor tree. Next, we just check that we have some locked descendents, which we have kept track in `lock` and `unlock`. \\n\\nOnce we upgrade, we lose all of current node\\'s locked descendents, so we need to propagate `1-lockedDescendents[num]` to its ancestors, taking `O(logN)` time.\\n\\nOverall run-time is `O(logN)`.\\n\\nSince each function is `O(logN)`, the amortized run-time will be `O(logN)`. \\n\\n```\\nclass LockingTree {\\npublic:\\n    LockingTree(vector<int>& _parent) {\\n        parent = _parent;\\n        timestamp = 0;\\n        lockedBy = std::vector<int>(parent.size(), -1);\\n        upgradeTime = std::vector<int>(parent.size(), -1);\\n        lockTime = std::vector<int>(parent.size(), -2);\\n        lockedDescendents = std::vector<int>(parent.size(), 0);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(!validLock(num)) {\\n            lockedBy[num] = user;\\n            lockTime[num] = timestamp++;\\n            propagateUp(num, 1);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (validLock(num)) {\\n            if(lockedBy[num] == user) {\\n                lockedBy[num] = -1;\\n                lockTime[num] = -2;\\n                propagateUp(num, -1);\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (!validLock(num) && !hasLockedAncestor(num) && (lockedDescendents[num] != 0)) {\\n            lockedBy[num] = user;\\n            lockTime[num] = upgradeTime[num] = timestamp++;\\n            propagateUp(num, 1-lockedDescendents[num]);\\n            lockedDescendents[num] = 0;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n        \\n    bool validLock(int num) {\\n        if(lockedBy[num] == -1) return false;\\n        \\n        int p{parent[num]};\\n        while (p != -1) {\\n            if (upgradeTime[p] > lockTime[num]) {\\n                return false;\\n            }\\n            p = parent[p];\\n        }\\n        \\n        return true;\\n    }\\n        \\n    bool hasLockedAncestor(int num) {\\n        int p{parent[num]};\\n        \\n        int maxLockTime{-2};\\n        \\n        while (p != -1) {\\n            maxLockTime = std::max(maxLockTime, lockTime[p]);\\n            if (upgradeTime[p] > maxLockTime) {\\n                maxLockTime = -2;\\n            }\\n            p = parent[p];\\n        }\\n\\n        return maxLockTime != -2;\\n    }\\n        \\n    void propagateUp(int num, int v) {\\n        \\n        int p = parent[num];\\n        \\n        while(p != -1) {\\n            lockedDescendents[p] += v;\\n            p = parent[p];\\n        }\\n    }\\n    \\n    std::vector<int> parent;\\n    std::vector<int> lockedBy;\\n    std::vector<int> upgradeTime;\\n    std::vector<int> lockTime;\\n    std::vector<int> lockedDescendents;\\n    int timestamp;\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\npublic:\\n    LockingTree(vector<int>& _parent) {\\n        parent = _parent;\\n        timestamp = 0;\\n        lockedBy = std::vector<int>(parent.size(), -1);\\n        upgradeTime = std::vector<int>(parent.size(), -1);\\n        lockTime = std::vector<int>(parent.size(), -2);\\n        lockedDescendents = std::vector<int>(parent.size(), 0);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(!validLock(num)) {\\n            lockedBy[num] = user;\\n            lockTime[num] = timestamp++;\\n            propagateUp(num, 1);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (validLock(num)) {\\n            if(lockedBy[num] == user) {\\n                lockedBy[num] = -1;\\n                lockTime[num] = -2;\\n                propagateUp(num, -1);\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (!validLock(num) && !hasLockedAncestor(num) && (lockedDescendents[num] != 0)) {\\n            lockedBy[num] = user;\\n            lockTime[num] = upgradeTime[num] = timestamp++;\\n            propagateUp(num, 1-lockedDescendents[num]);\\n            lockedDescendents[num] = 0;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n        \\n    bool validLock(int num) {\\n        if(lockedBy[num] == -1) return false;\\n        \\n        int p{parent[num]};\\n        while (p != -1) {\\n            if (upgradeTime[p] > lockTime[num]) {\\n                return false;\\n            }\\n            p = parent[p];\\n        }\\n        \\n        return true;\\n    }\\n        \\n    bool hasLockedAncestor(int num) {\\n        int p{parent[num]};\\n        \\n        int maxLockTime{-2};\\n        \\n        while (p != -1) {\\n            maxLockTime = std::max(maxLockTime, lockTime[p]);\\n            if (upgradeTime[p] > maxLockTime) {\\n                maxLockTime = -2;\\n            }\\n            p = parent[p];\\n        }\\n\\n        return maxLockTime != -2;\\n    }\\n        \\n    void propagateUp(int num, int v) {\\n        \\n        int p = parent[num];\\n        \\n        while(p != -1) {\\n            lockedDescendents[p] += v;\\n            p = parent[p];\\n        }\\n    }\\n    \\n    std::vector<int> parent;\\n    std::vector<int> lockedBy;\\n    std::vector<int> upgradeTime;\\n    std::vector<int> lockTime;\\n    std::vector<int> lockedDescendents;\\n    int timestamp;\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1490382,
                "title": "golang-simple-solution",
                "content": "```go\\ntype LockingTree struct {\\n\\tlocker   []int\\n\\tparent   []int\\n\\tchildren [][]int\\n}\\n\\nfunc Constructor(parent []int) LockingTree {\\n\\tlocker := make([]int, len(parent))\\n\\tfor i := range locker {\\n\\t\\tlocker[i] = -1\\n\\t}\\n\\tchildren := make([][]int, len(parent))\\n\\tfor i := range children {\\n\\t\\tchildren[i] = make([]int, 0)\\n\\t}\\n\\tfor i := 1; i < len(parent); i++ {\\n\\t\\tchildren[parent[i]] = append(children[parent[i]], i)\\n\\t}\\n\\treturn LockingTree{\\n\\t\\tlocker:   locker,\\n\\t\\tparent:   parent,\\n\\t\\tchildren: children,\\n\\t}\\n}\\n\\nfunc (lt *LockingTree) Lock(num int, user int) bool {\\n\\tif lt.locker[num] != -1 {\\n\\t\\treturn false\\n\\t}\\n\\tlt.locker[num] = user\\n\\treturn true\\n}\\n\\nfunc (lt *LockingTree) Unlock(num int, user int) bool {\\n\\tif lt.locker[num] != user {\\n\\t\\treturn false\\n\\t}\\n\\tlt.locker[num] = -1\\n\\treturn true\\n}\\n\\nfunc (lt *LockingTree) Upgrade(num int, user int) bool {\\n\\tif lt.locker[num] != -1 {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := num; lt.parent[i] != -1; {\\n\\t\\ti = lt.parent[i]\\n\\t\\tif lt.locker[i] != -1 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\tlockedChildren := make([]int, 0)\\n\\tlt.childrenLocked(num, &lockedChildren)\\n\\tif len(lockedChildren) == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tlt.locker[num] = user\\n\\tfor _, v := range lockedChildren {\\n\\t\\tlt.locker[v] = -1\\n\\t}\\n\\treturn true\\n}\\n\\nfunc (lt *LockingTree) childrenLocked(num int, children *[]int) {\\n\\tfor _, v := range lt.children[num] {\\n\\t\\tif lt.locker[v] != -1 {\\n\\t\\t\\t*children = append(*children, v)\\n\\t\\t}\\n\\t\\tlt.childrenLocked(v, children)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype LockingTree struct {\\n\\tlocker   []int\\n\\tparent   []int\\n\\tchildren [][]int\\n}\\n\\nfunc Constructor(parent []int) LockingTree {\\n\\tlocker := make([]int, len(parent))\\n\\tfor i := range locker {\\n\\t\\tlocker[i] = -1\\n\\t}\\n\\tchildren := make([][]int, len(parent))\\n\\tfor i := range children {\\n\\t\\tchildren[i] = make([]int, 0)\\n\\t}\\n\\tfor i := 1; i < len(parent); i++ {\\n\\t\\tchildren[parent[i]] = append(children[parent[i]], i)\\n\\t}\\n\\treturn LockingTree{\\n\\t\\tlocker:   locker,\\n\\t\\tparent:   parent,\\n\\t\\tchildren: children,\\n\\t}\\n}\\n\\nfunc (lt *LockingTree) Lock(num int, user int) bool {\\n\\tif lt.locker[num] != -1 {\\n\\t\\treturn false\\n\\t}\\n\\tlt.locker[num] = user\\n\\treturn true\\n}\\n\\nfunc (lt *LockingTree) Unlock(num int, user int) bool {\\n\\tif lt.locker[num] != user {\\n\\t\\treturn false\\n\\t}\\n\\tlt.locker[num] = -1\\n\\treturn true\\n}\\n\\nfunc (lt *LockingTree) Upgrade(num int, user int) bool {\\n\\tif lt.locker[num] != -1 {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := num; lt.parent[i] != -1; {\\n\\t\\ti = lt.parent[i]\\n\\t\\tif lt.locker[i] != -1 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\tlockedChildren := make([]int, 0)\\n\\tlt.childrenLocked(num, &lockedChildren)\\n\\tif len(lockedChildren) == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tlt.locker[num] = user\\n\\tfor _, v := range lockedChildren {\\n\\t\\tlt.locker[v] = -1\\n\\t}\\n\\treturn true\\n}\\n\\nfunc (lt *LockingTree) childrenLocked(num int, children *[]int) {\\n\\tfor _, v := range lt.children[num] {\\n\\t\\tif lt.locker[v] != -1 {\\n\\t\\t\\t*children = append(*children, v)\\n\\t\\t}\\n\\t\\tlt.childrenLocked(v, children)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444185,
                "title": "python-just-do-what-the-description-says",
                "content": "Time complexity:\\nLock and unlock: O(1)\\nUpgrade: O(n)\\n\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked_nodes = defaultdict(int)\\n        self.graph = defaultdict(list)\\n        \\n        for i, v in enumerate(parent):\\n            self.graph[v].append(i)\\n            \\n        print(self.graph)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.locked_nodes:\\n            return False\\n        self.locked_nodes[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if num not in self.locked_nodes or self.locked_nodes[num] != user:\\n            return False\\n        \\n        del self.locked_nodes[num]\\n        return True\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        def check_ancestors(num):\\n            if num in self.locked_nodes:\\n                return True\\n            elif num == -1:\\n                return False\\n            else:\\n                return check_ancestors(self.parent[num])\\n        \\n        def descendants(num):\\n            for node in self.graph[num]:\\n                if node in self.locked_nodes:\\n                    return True\\n                if descendants(node):\\n                    return True\\n            return False\\n                \\n        def unlock_descendants(num):\\n            for node in self.graph[num]:\\n                if node in self.locked_nodes:\\n                    del self.locked_nodes[node]\\n                unlock_descendants(node)\\n            \\n        if num in self.locked_nodes:\\n            return False\\n        elif check_ancestors(self.parent[num]):\\n            return False\\n        elif not descendants(num):\\n            return False\\n        \\n        unlock_descendants(num)\\n        self.locked_nodes[num] = user\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked_nodes = defaultdict(int)\\n        self.graph = defaultdict(list)\\n        \\n        for i, v in enumerate(parent):\\n            self.graph[v].append(i)\\n            \\n        print(self.graph)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.locked_nodes:\\n            return False\\n        self.locked_nodes[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if num not in self.locked_nodes or self.locked_nodes[num] != user:\\n            return False\\n        \\n        del self.locked_nodes[num]\\n        return True\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        def check_ancestors(num):\\n            if num in self.locked_nodes:\\n                return True\\n            elif num == -1:\\n                return False\\n            else:\\n                return check_ancestors(self.parent[num])\\n        \\n        def descendants(num):\\n            for node in self.graph[num]:\\n                if node in self.locked_nodes:\\n                    return True\\n                if descendants(node):\\n                    return True\\n            return False\\n                \\n        def unlock_descendants(num):\\n            for node in self.graph[num]:\\n                if node in self.locked_nodes:\\n                    del self.locked_nodes[node]\\n                unlock_descendants(node)\\n            \\n        if num in self.locked_nodes:\\n            return False\\n        elif check_ancestors(self.parent[num]):\\n            return False\\n        elif not descendants(num):\\n            return False\\n        \\n        unlock_descendants(num)\\n        self.locked_nodes[num] = user\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444166,
                "title": "simple-c-using-map-with-comments",
                "content": "```\\nLock: O(1)\\nUnlock:O(1)\\nUpgrade:O(n)\\nclass LockingTree {\\npublic:\\n    vector<vector<int> >adj;// adj list for tree\\n    map<int,int>locked;//map for locked user\\n    map<int,int>anc;//ancestor map\\n    LockingTree(vector<int>& parent) {\\n      adj=vector<vector<int> >(parent.size());\\n        anc[0]=-1;\\n        for(int i=1;i<parent.size();i++)\\n        {\\n            anc[i]=parent[i];   // stores ancestor  of ith node\\n            adj[parent[i]].push_back(i);//directed to child\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n    \\n        if(locked.find(num)==locked.end())//checking unlocked\\n        { \\n            locked[num]=user;\\n            return 1;\\n        }\\n        else  //locked\\n        return 0;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked.find(num)!=locked.end()) // checking locked \\n        {\\n            if(locked[num]==user)\\n            {\\n                locked.erase(num);\\n                return 1;\\n            }\\n            else\\n            return 0;\\n        }\\n        else // already unlocked\\n            return 0;\\n    }\\n    \\n    int dfs(int src)// checking at least one desecendent locked\\n    {\\n        for(int i=0;i<adj[src].size();i++)\\n        {\\n            int x=adj[src][i];\\n            if(locked.find(x)!=locked.end())//found\\n                      return 1;\\n             if(dfs(x))\\n                  return 1;\\n        }\\n        return 0;\\n    }\\n    int check_anc(int up)//checking  not have any locked ancestors\\n    {\\n         \\n            while(up!=-1)  // anc[root]=-1\\n            {   \\n                if(locked.find(up)!=locked.end())\\n\\t\\t\\t\\t       return 0;\\n                up=anc[up]; //moving up to ancestor\\n            }\\n            return 1;\\n    }\\n    void dfs_des(int src)//unlocking all desecendent\\n    {\\n       for(int i=0;i<adj[src].size();i++)\\n        {\\n            int x=adj[src][i];\\n            if(locked.find(x)!=locked.end()){\\n                locked.erase(x);\\n            }\\n           dfs_des(x);\\n        }\\n    }\\n    bool upgrade(int num, int user) {\\n        if(locked.find(num)!=locked.end())return 0;\\n        \\n        if(dfs(num)&&check_anc(anc[num]))\\n        {\\n            dfs_des(num);//unlocking all desecendent\\n            locked[num]=user;//locked user\\n            return 1;\\n        }return 0;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nLock: O(1)\\nUnlock:O(1)\\nUpgrade:O(n)\\nclass LockingTree {\\npublic:\\n    vector<vector<int> >adj;// adj list for tree\\n    map<int,int>locked;//map for locked user\\n    map<int,int>anc;//ancestor map\\n    LockingTree(vector<int>& parent) {\\n      adj=vector<vector<int> >(parent.size());\\n        anc[0]=-1;\\n        for(int i=1;i<parent.size();i++)\\n        {\\n            anc[i]=parent[i];   // stores ancestor  of ith node\\n            adj[parent[i]].push_back(i);//directed to child\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n    \\n        if(locked.find(num)==locked.end())//checking unlocked\\n        { \\n            locked[num]=user;\\n            return 1;\\n        }\\n        else  //locked\\n        return 0;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked.find(num)!=locked.end()) // checking locked \\n        {\\n            if(locked[num]==user)\\n            {\\n                locked.erase(num);\\n                return 1;\\n            }\\n            else\\n            return 0;\\n        }\\n        else // already unlocked\\n            return 0;\\n    }\\n    \\n    int dfs(int src)// checking at least one desecendent locked\\n    {\\n        for(int i=0;i<adj[src].size();i++)\\n        {\\n            int x=adj[src][i];\\n            if(locked.find(x)!=locked.end())//found\\n                      return 1;\\n             if(dfs(x))\\n                  return 1;\\n        }\\n        return 0;\\n    }\\n    int check_anc(int up)//checking  not have any locked ancestors\\n    {\\n         \\n            while(up!=-1)  // anc[root]=-1\\n            {   \\n                if(locked.find(up)!=locked.end())\\n\\t\\t\\t\\t       return 0;\\n                up=anc[up]; //moving up to ancestor\\n            }\\n            return 1;\\n    }\\n    void dfs_des(int src)//unlocking all desecendent\\n    {\\n       for(int i=0;i<adj[src].size();i++)\\n        {\\n            int x=adj[src][i];\\n            if(locked.find(x)!=locked.end()){\\n                locked.erase(x);\\n            }\\n           dfs_des(x);\\n        }\\n    }\\n    bool upgrade(int num, int user) {\\n        if(locked.find(num)!=locked.end())return 0;\\n        \\n        if(dfs(num)&&check_anc(anc[num]))\\n        {\\n            dfs_des(num);//unlocking all desecendent\\n            locked[num]=user;//locked user\\n            return 1;\\n        }return 0;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520348,
                "title": "hash-map-solution-in-cpp",
                "content": "```\\nclass LockingTree {\\npublic:\\n    unordered_map<int,int>m;\\n    vector<vector<int>>t;\\n    vector<int>p;\\n    \\n    \\n    LockingTree(vector<int>& parent) {\\n        p=parent;\\n        \\n        vector<vector<int>>temp(parent.size());\\n        \\n        for(int i=1;i<parent.size();i++){\\n            temp[parent[i]].push_back(i);\\n        }\\n        \\n        t=temp;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(m.find(num)==m.end()){\\n            m[num]=user;\\n            return true;\\n        }\\n        \\n        return false;;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(m.find(num)!=m.end()){\\n            if(m[num]==user){\\n                m.erase(num);\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n    \\n    bool check(int num){\\n        if(m.find(num)!=m.end())return true;\\n        \\n        \\n        if(p[num]!=-1 && check(p[num]))return true;\\n\\n\\n        return false;\\n    }\\n    \\n    void decendent(int a,int &total){\\n        \\n        for(auto ele:t[a]){\\n            if(m.find(ele)!=m.end()){\\n                total++;\\n                m.erase(ele);\\n            }\\n            decendent(ele,total);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(m.find(num)!=m.end())return false;\\n        \\n        if(check(num))return false;\\n        \\n      \\n        int total=0;\\n        \\n        decendent(num,total);\\n        if(total==0)return false;\\n        \\n        m[num]=user;\\n        \\n        return true;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    unordered_map<int,int>m;\\n    vector<vector<int>>t;\\n    vector<int>p;\\n    \\n    \\n    LockingTree(vector<int>& parent) {\\n        p=parent;\\n        \\n        vector<vector<int>>temp(parent.size());\\n        \\n        for(int i=1;i<parent.size();i++){\\n            temp[parent[i]].push_back(i);\\n        }\\n        \\n        t=temp;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(m.find(num)==m.end()){\\n            m[num]=user;\\n            return true;\\n        }\\n        \\n        return false;;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(m.find(num)!=m.end()){\\n            if(m[num]==user){\\n                m.erase(num);\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n    \\n    bool check(int num){\\n        if(m.find(num)!=m.end())return true;\\n        \\n        \\n        if(p[num]!=-1 && check(p[num]))return true;\\n\\n\\n        return false;\\n    }\\n    \\n    void decendent(int a,int &total){\\n        \\n        for(auto ele:t[a]){\\n            if(m.find(ele)!=m.end()){\\n                total++;\\n                m.erase(ele);\\n            }\\n            decendent(ele,total);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(m.find(num)!=m.end())return false;\\n        \\n        if(check(num))return false;\\n        \\n      \\n        int total=0;\\n        \\n        decendent(num,total);\\n        if(total==0)return false;\\n        \\n        m[num]=user;\\n        \\n        return true;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1445627,
                "title": "detailed-explanation-c-python",
                "content": "# Approach \\nLock and Unlock function can be easily done , we just need to maintain all currently locked nodes and user ID that lock that node \\nso , just make a map of < int , int>  , so if there is a entry corresponfing to a node means it is locked . here key is node no and value is user that locked that node . \\nNow, for locked function simply check if entry exist , it not then create one and return true otherwise return false , \\nFor Unlock function , just check if entry exist and value is same as user , then erase that entry and return true otherwise return false   \\n\\nNow for Updrade function : \\nwe have 3 condition to check \\n1.   Current node is unlocked : easily check using locks_aquired map in O(1) time \\n2.   No parent node is locked : for this we have recursive function  to check lock status of parents of current node until we reach root node : \\n3. At least one descendents is locked : just for this condition we have to create adjancy list initially , such that we have info of all child of cuurent node \\n\\tsimply apply dfs on current node and check if any child is locked \\n\\nnow if above three condition is True : \\nunlock all descendents : again we have to apply DFS \\nlock cuurent node : simple lock operation on current node\\n# Time Complexity : \\nLock function : O(1) \\nUnlock function : O(1) \\nUpdrage function: O(n)   since in worst case height of tree is n \\n\\n# Implementation\\n# C++\\n```\\nclass LockingTree {\\npublic:\\n    \\n    unordered_map<int,int> locks_aquired;\\n    vector<vector<int>> graph;\\n    unordered_map<int,int> parents;\\n    \\n    LockingTree(vector<int>& parent)\\n    {   \\n        int n=parent.size();\\n        graph =  vector<vector<int> >(n);\\n        parents[0] = -1 ;   // since parent of node 0 is always -1 \\n\\n        for(int i=1; i<n; i++)\\n        {\\n            parents[i] = parent[i];  \\n            graph[parent[i]].push_back(i);\\n        }\\n    }\\n     \\n    bool lock(int num, int user)    \\n    {\\n        if(locks_aquired.find(num) == locks_aquired.end())\\n            { locks_aquired[num]=user; return 1;}\\n        return 0;\\n    }\\n    \\n    \\n    bool unlock(int num, int user)      \\n    {\\n        if(locks_aquired.find(num) != locks_aquired.end() && locks_aquired[num]==user)\\n            {   locks_aquired.erase(num); return 1;}\\n        return 0;\\n    }\\n    \\n    bool check_ans(int num)\\n    {\\n        while(num != -1)\\n        {\\n            if(locks_aquired.find(num) != locks_aquired.end()) return 0;\\n            num = parents[num];   \\n        }\\n        return 1;\\n    }\\n    \\n    bool dfs(int num)   // function to check if alteast one desendent is lock or not \\n    {\\n        for(int i=0; i<graph[num].size(); i++)\\n        {\\n            int x = graph[num][i]; \\n            if( locks_aquired.find(x) != locks_aquired.end())\\n                return 1;\\n            if( dfs(x)) return 1;\\n        }\\n        return 0; \\n    }\\n    \\n    void unlock_descendents(int num)   \\n    {\\n        for(int i=0; i<graph[num].size(); i++)\\n        {\\n            int x = graph[num][i]; \\n            if( locks_aquired.find(x) != locks_aquired.end())\\n                locks_aquired.erase(x);\\n            dfs_des(x);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) \\n    {   \\n        if( locks_aquired.find(num) != locks_aquired.end()) return 0;     // if current node is locked can\\'t lock it again \\n        \\n        if( dfs(num) && check_ans(parents[num]))  \\n        {\\n            unlock_descendents(num); \\n            locks_aquired[num]=user;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```\\n\\n# Python3\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.p = collections.defaultdict(lambda: -2)\\n        self.c = collections.defaultdict(list)\\n        for i, p in enumerate(parent):\\n            self.c[p].append(i)\\n            self.p[i] = p\\n        self.user = collections.defaultdict(set)\\n        self.node = collections.defaultdict(lambda: -2)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.node[num] == -2:\\n            self.user[user].add(num)\\n            self.node[num] = user\\n            return True\\n        return False \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.node[num] == user: \\n            del self.node[num]\\n            self.user[user].remove(num)\\n            return True\\n        return False        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.node[num] != -2: return False\\n        if not self.has_locked_descendant(num): return False\\n        if self.has_locked_ancester(num): return False\\n        self.lock(num, user)\\n        self.unlock_descendant(num)\\n        return True\\n    \\n    def has_locked_descendant(self, num):  #function to check if alteast one desendent is lock or not \\n        has = False\\n        for child in self.c[num]:\\n            if self.node[child] != -2:\\n                return True\\n            has |= self.has_locked_descendant(child)\\n        return has               \\n        \\n    def has_locked_ancester(self, num):   # function to check if no parent is locked \\n        if num == -1: return False\\n        if self.node[self.p[num]] != -2:\\n            return True\\n        return self.has_locked_ancester(self.p[num])\\n\\n    def unlock_descendant(self, num):   # function fro unlocking all desendents \\n        for child in self.c[num]:\\n            if child in self.node:\\n                user = self.node[child]\\n                del self.node[child]\\n                if user in self.user:\\n                    self.user[user].remove(child)\\n            self.unlock_descendant(child)\\n```\\n# Upvote if this is helpful for you",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    \\n    unordered_map<int,int> locks_aquired;\\n    vector<vector<int>> graph;\\n    unordered_map<int,int> parents;\\n    \\n    LockingTree(vector<int>& parent)\\n    {   \\n        int n=parent.size();\\n        graph =  vector<vector<int> >(n);\\n        parents[0] = -1 ;   // since parent of node 0 is always -1 \\n\\n        for(int i=1; i<n; i++)\\n        {\\n            parents[i] = parent[i];  \\n            graph[parent[i]].push_back(i);\\n        }\\n    }\\n     \\n    bool lock(int num, int user)    \\n    {\\n        if(locks_aquired.find(num) == locks_aquired.end())\\n            { locks_aquired[num]=user; return 1;}\\n        return 0;\\n    }\\n    \\n    \\n    bool unlock(int num, int user)      \\n    {\\n        if(locks_aquired.find(num) != locks_aquired.end() && locks_aquired[num]==user)\\n            {   locks_aquired.erase(num); return 1;}\\n        return 0;\\n    }\\n    \\n    bool check_ans(int num)\\n    {\\n        while(num != -1)\\n        {\\n            if(locks_aquired.find(num) != locks_aquired.end()) return 0;\\n            num = parents[num];   \\n        }\\n        return 1;\\n    }\\n    \\n    bool dfs(int num)   // function to check if alteast one desendent is lock or not \\n    {\\n        for(int i=0; i<graph[num].size(); i++)\\n        {\\n            int x = graph[num][i]; \\n            if( locks_aquired.find(x) != locks_aquired.end())\\n                return 1;\\n            if( dfs(x)) return 1;\\n        }\\n        return 0; \\n    }\\n    \\n    void unlock_descendents(int num)   \\n    {\\n        for(int i=0; i<graph[num].size(); i++)\\n        {\\n            int x = graph[num][i]; \\n            if( locks_aquired.find(x) != locks_aquired.end())\\n                locks_aquired.erase(x);\\n            dfs_des(x);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) \\n    {   \\n        if( locks_aquired.find(num) != locks_aquired.end()) return 0;     // if current node is locked can\\'t lock it again \\n        \\n        if( dfs(num) && check_ans(parents[num]))  \\n        {\\n            unlock_descendents(num); \\n            locks_aquired[num]=user;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.p = collections.defaultdict(lambda: -2)\\n        self.c = collections.defaultdict(list)\\n        for i, p in enumerate(parent):\\n            self.c[p].append(i)\\n            self.p[i] = p\\n        self.user = collections.defaultdict(set)\\n        self.node = collections.defaultdict(lambda: -2)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.node[num] == -2:\\n            self.user[user].add(num)\\n            self.node[num] = user\\n            return True\\n        return False \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.node[num] == user: \\n            del self.node[num]\\n            self.user[user].remove(num)\\n            return True\\n        return False        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.node[num] != -2: return False\\n        if not self.has_locked_descendant(num): return False\\n        if self.has_locked_ancester(num): return False\\n        self.lock(num, user)\\n        self.unlock_descendant(num)\\n        return True\\n    \\n    def has_locked_descendant(self, num):  #function to check if alteast one desendent is lock or not \\n        has = False\\n        for child in self.c[num]:\\n            if self.node[child] != -2:\\n                return True\\n            has |= self.has_locked_descendant(child)\\n        return has               \\n        \\n    def has_locked_ancester(self, num):   # function to check if no parent is locked \\n        if num == -1: return False\\n        if self.node[self.p[num]] != -2:\\n            return True\\n        return self.has_locked_ancester(self.p[num])\\n\\n    def unlock_descendant(self, num):   # function fro unlocking all desendents \\n        for child in self.c[num]:\\n            if child in self.node:\\n                user = self.node[child]\\n                del self.node[child]\\n                if user in self.user:\\n                    self.user[user].remove(child)\\n            self.unlock_descendant(child)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445003,
                "title": "python-3-simulation-explanation",
                "content": "### Explanation\\n- Simulate the process\\n- Time: `O(N)`, it\\'s not guaranteed to be a binary tree\\n### Implementation\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.p = collections.defaultdict(lambda: -2)\\n        self.c = collections.defaultdict(list)\\n        for i, p in enumerate(parent):\\n            self.c[p].append(i)\\n            self.p[i] = p\\n        self.user = collections.defaultdict(set)\\n        self.node = collections.defaultdict(lambda: -2)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.node[num] == -2:\\n            self.user[user].add(num)\\n            self.node[num] = user\\n            return True\\n        return False \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.node[num] == user: \\n            del self.node[num]\\n            self.user[user].remove(num)\\n            return True\\n        return False        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.node[num] != -2: return False\\n        if not self.has_locked_descendant(num): return False\\n        if self.has_locked_ancester(num): return False\\n        self.lock(num, user)\\n        self.unlock_descendant(num)\\n        return True\\n    \\n    def has_locked_descendant(self, num):\\n        has = False\\n        for child in self.c[num]:\\n            if self.node[child] != -2:\\n                return True\\n            has |= self.has_locked_descendant(child)\\n        return has               \\n        \\n    def has_locked_ancester(self, num):\\n        if num == -1: return False\\n        if self.node[self.p[num]] != -2:\\n            return True\\n        return self.has_locked_ancester(self.p[num])\\n\\n    def unlock_descendant(self, num):\\n        for child in self.c[num]:\\n            if child in self.node:\\n                user = self.node[child]\\n                del self.node[child]\\n                if user in self.user:\\n                    self.user[user].remove(child)\\n            self.unlock_descendant(child)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.p = collections.defaultdict(lambda: -2)\\n        self.c = collections.defaultdict(list)\\n        for i, p in enumerate(parent):\\n            self.c[p].append(i)\\n            self.p[i] = p\\n        self.user = collections.defaultdict(set)\\n        self.node = collections.defaultdict(lambda: -2)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.node[num] == -2:\\n            self.user[user].add(num)\\n            self.node[num] = user\\n            return True\\n        return False \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.node[num] == user: \\n            del self.node[num]\\n            self.user[user].remove(num)\\n            return True\\n        return False        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.node[num] != -2: return False\\n        if not self.has_locked_descendant(num): return False\\n        if self.has_locked_ancester(num): return False\\n        self.lock(num, user)\\n        self.unlock_descendant(num)\\n        return True\\n    \\n    def has_locked_descendant(self, num):\\n        has = False\\n        for child in self.c[num]:\\n            if self.node[child] != -2:\\n                return True\\n            has |= self.has_locked_descendant(child)\\n        return has               \\n        \\n    def has_locked_ancester(self, num):\\n        if num == -1: return False\\n        if self.node[self.p[num]] != -2:\\n            return True\\n        return self.has_locked_ancester(self.p[num])\\n\\n    def unlock_descendant(self, num):\\n        for child in self.c[num]:\\n            if child in self.node:\\n                user = self.node[child]\\n                del self.node[child]\\n                if user in self.user:\\n                    self.user[user].remove(child)\\n            self.unlock_descendant(child)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444192,
                "title": "python-easy-to-understand",
                "content": "```python\\nclass LockingTree:\\n    def __init__(self, parent: List[int]):\\n        self.n = len(parent)  # number of nodes\\n        self.parent = parent\\n        self.children = defaultdict(list)\\n        self.locked = [0 for _ in range(self.n)]\\n        self.build_children()\\n    \\n    def build_children(self):\\n\\t\\t# construct parent-to-children\\n        for node in range(self.n):\\n            self.children[self.parent[node]].append(node)\\n    \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num] == 0:\\n            self.locked[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] == user:\\n            self.locked[num] = 0\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locked[num] == 0 and self.check_up(num) and self.check_down(num):\\n            self.locked[num] = user\\n            for child in self.children[num]:\\n                self.unlock_down(child)\\n            return True\\n        return False\\n    \\n    def check_up(self, node):\\n        # return True if up nodes are all unlocked\\n        while node != -1:\\n            if self.locked[node]:\\n                return False\\n            node = self.parent[node]\\n        return True\\n    \\n    def check_down(self, node):\\n        # return True if at least one down node is locked\\n        if not node < self.n:\\n            return False\\n        ans = self.locked[node]\\n        if ans:\\n            return True\\n        for child in self.children[node]:\\n            ans = ans or self.check_down(child)\\n            if ans:\\n                return True\\n        return False\\n    \\n    def unlock_down(self, node):\\n\\t\\t# unlock all down nodes\\n        if not node < self.n:\\n            return\\n        self.locked[node] = 0\\n        for child in self.children[node]:\\n            self.unlock_down(child)```\\n",
                "solutionTags": [],
                "code": "```python\\nclass LockingTree:\\n    def __init__(self, parent: List[int]):\\n        self.n = len(parent)  # number of nodes\\n        self.parent = parent\\n        self.children = defaultdict(list)\\n        self.locked = [0 for _ in range(self.n)]\\n        self.build_children()\\n    \\n    def build_children(self):\\n\\t\\t# construct parent-to-children\\n        for node in range(self.n):\\n            self.children[self.parent[node]].append(node)\\n    \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num] == 0:\\n            self.locked[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] == user:\\n            self.locked[num] = 0\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locked[num] == 0 and self.check_up(num) and self.check_down(num):\\n            self.locked[num] = user\\n            for child in self.children[num]:\\n                self.unlock_down(child)\\n            return True\\n        return False\\n    \\n    def check_up(self, node):\\n        # return True if up nodes are all unlocked\\n        while node != -1:\\n            if self.locked[node]:\\n                return False\\n            node = self.parent[node]\\n        return True\\n    \\n    def check_down(self, node):\\n        # return True if at least one down node is locked\\n        if not node < self.n:\\n            return False\\n        ans = self.locked[node]\\n        if ans:\\n            return True\\n        for child in self.children[node]:\\n            ans = ans or self.check_down(child)\\n            if ans:\\n                return True\\n        return False\\n    \\n    def unlock_down(self, node):\\n\\t\\t# unlock all down nodes\\n        if not node < self.n:\\n            return\\n        self.locked[node] = 0\\n        for child in self.children[node]:\\n            self.unlock_down(child)```",
                "codeTag": "Java"
            },
            {
                "id": 1444138,
                "title": "simple-c-build-tree-and-follow-the-instructions-tc-o-1-o-1-o-n",
                "content": "The method is fairly simple build the tree (useful in upgrade) \\n1. for locking and unlocking - keep a locked_by array to check if the node is locked by any user or not \\n2. to free up the descendants nodes we do dfs \\n3. for checking the locked ascendents we used something like find in DSU.\\n\\n```\\nclass LockingTree {\\n    vector<int> par, locked_by; // original parent array and another array to check who has locked the  num\\n    vector<vector<int>> tree; // tree for unlocking the descendants  nodes \\npublic:\\n    LockingTree(vector<int>& parent) {\\n        par = parent;\\n        tree.resize(par.size());\\n        locked_by.resize(parent.size(), -1);\\n        \\n        for (int i = 0; i < par.size(); i++) {\\n            if (par[i] != -1) {\\n                tree[par[i]].push_back(i);\\n            }\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (locked_by[num] != -1) return false;\\n        locked_by[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (locked_by[num] != user) return false;\\n        locked_by[num] = -1;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (!check_locked_par(num) && check_locked_child(num)) {\\n            locked_by[num] = user;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool check_locked_par(int x) {\\n        if (x == -1) return false;\\n        return locked_by[x] != -1 ? true : check_locked_par(par[x]);\\n    }\\n    \\n    bool check_locked_child(int x) {\\n        bool locked = false;\\n        if (locked_by[x] != -1) {\\n            locked_by[x] = -1;      // Unlock the node\\n            locked = true;\\n        }\\n        \\n        for (int child: tree[x]) locked |= check_locked_child(child);\\n        \\n        return locked;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n ```\\n \\n Running time - for upgrade O(N).",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    vector<int> par, locked_by; // original parent array and another array to check who has locked the  num\\n    vector<vector<int>> tree; // tree for unlocking the descendants  nodes \\npublic:\\n    LockingTree(vector<int>& parent) {\\n        par = parent;\\n        tree.resize(par.size());\\n        locked_by.resize(parent.size(), -1);\\n        \\n        for (int i = 0; i < par.size(); i++) {\\n            if (par[i] != -1) {\\n                tree[par[i]].push_back(i);\\n            }\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (locked_by[num] != -1) return false;\\n        locked_by[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (locked_by[num] != user) return false;\\n        locked_by[num] = -1;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (!check_locked_par(num) && check_locked_child(num)) {\\n            locked_by[num] = user;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool check_locked_par(int x) {\\n        if (x == -1) return false;\\n        return locked_by[x] != -1 ? true : check_locked_par(par[x]);\\n    }\\n    \\n    bool check_locked_child(int x) {\\n        bool locked = false;\\n        if (locked_by[x] != -1) {\\n            locked_by[x] = -1;      // Unlock the node\\n            locked = true;\\n        }\\n        \\n        for (int child: tree[x]) locked |= check_locked_child(child);\\n        \\n        return locked;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1869195,
                "title": "python3-just-dew-it",
                "content": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.children = defaultdict(list)\\n        self.parent = defaultdict(lambda: -1)\\n        self.isLocked = defaultdict(lambda: -1)\\n        \\n        for child, parent in enumerate(parent):\\n            self.children[parent].append(child)\\n            self.parent[child] = parent\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.isLocked[num] != -1:\\n            return False\\n        \\n        self.isLocked[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.isLocked[num] != user:\\n            return False\\n        \\n        self.isLocked[num] = -1\\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.isLocked[num] == -1 and self.hasLockedDescendent(num) and not self.hasLockedAncestor(num):\\n            self.unlockDescendents(num)\\n            self.isLocked[num] = user\\n            return True\\n\\n        return False\\n    \\n    def hasLockedAncestor(self, num):\\n        while num != -1:\\n            if self.isLocked[num] != -1:\\n                return True\\n            \\n            num = self.parent[num]\\n        \\n        return False\\n    \\n    def hasLockedDescendent(self, num):\\n        stack = [num]\\n        \\n        while len(stack) > 0:\\n            curr = stack.pop()\\n            \\n            if self.isLocked[curr] != -1:\\n                return True\\n            \\n            for child in self.children[curr]:\\n                stack.append(child)\\n    \\n    def unlockDescendents(self, node):\\n        stack = [node]\\n        \\n        while len(stack) > 0:\\n            curr = stack.pop()\\n            \\n            self.isLocked[curr] = -1\\n            \\n            for child in self.children[curr]:\\n                stack.append(child)\\n        \\n    \\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.children = defaultdict(list)\\n        self.parent = defaultdict(lambda: -1)\\n        self.isLocked = defaultdict(lambda: -1)\\n        \\n        for child, parent in enumerate(parent):\\n            self.children[parent].append(child)\\n            self.parent[child] = parent\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.isLocked[num] != -1:\\n            return False\\n        \\n        self.isLocked[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.isLocked[num] != user:\\n            return False\\n        \\n        self.isLocked[num] = -1\\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.isLocked[num] == -1 and self.hasLockedDescendent(num) and not self.hasLockedAncestor(num):\\n            self.unlockDescendents(num)\\n            self.isLocked[num] = user\\n            return True\\n\\n        return False\\n    \\n    def hasLockedAncestor(self, num):\\n        while num != -1:\\n            if self.isLocked[num] != -1:\\n                return True\\n            \\n            num = self.parent[num]\\n        \\n        return False\\n    \\n    def hasLockedDescendent(self, num):\\n        stack = [num]\\n        \\n        while len(stack) > 0:\\n            curr = stack.pop()\\n            \\n            if self.isLocked[curr] != -1:\\n                return True\\n            \\n            for child in self.children[curr]:\\n                stack.append(child)\\n    \\n    def unlockDescendents(self, node):\\n        stack = [node]\\n        \\n        while len(stack) > 0:\\n            curr = stack.pop()\\n            \\n            self.isLocked[curr] = -1\\n            \\n            for child in self.children[curr]:\\n                stack.append(child)\\n        \\n    \\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507863,
                "title": "c-388ms-81-dag",
                "content": "Runtime: 388 ms, faster than 80.78% of C++ online submissions for Operations on Tree.\\nMemory Usage: 193.5 MB, less than 17.85% of C++ online submissions for Operations on Tree.\\n**construct DAG and will do all movinges in graph**\\n```\\nclass LockingTree {\\npublic:\\n  struct Node{\\n    Node *par;\\n    vector<Node*> next;\\n    int is_locked;\\n    Node(Node *p){is_locked = 0;par = p;}\\n  };\\n  unordered_map<int, Node*> table;\\n  \\n  \\n  LockingTree(vector<int>& parent) {                             //construct DAG\\n     for(int i = 0; i != parent.size(); i++){\\n       if(!table.count(parent[i])) table[parent[i]] = new Node(NULL);\\n       \\n       if(!table.count(i)) table[i] = new Node(table[parent[i]]);\\n       else table[i]->par = table[parent[i]];\\n       \\n       table[parent[i]]->next.push_back(table[i]);\\n     }  \\n  }\\n    \\n    bool lock(int num, int user) {\\n      return table[num]->is_locked ? false : table[num]->is_locked = user; \\n    }\\n    \\n    bool unlock(int num, int user) {\\n      return table[num]->is_locked == user ? !( table[num]->is_locked = 0 ) : false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n      Node *tmp = table[num];\\n      if(tmp->is_locked == 0){                      //if node is locked\\n        Node *w   = tmp->par;\\n        \\n        for(; w; w = w->par)\\n          if(w->is_locked != 0) return false;       //if parent of node is locked  \\n                \\n        queue<Node*>q;\\n        q.push(tmp);\\n        while(!q.empty()){\\n          w = q.front(); q.pop();\\n          \\n          if(w->is_locked){                         //if we have a children that is locked \\n            q.push(w);\\n            while(!q.empty()){\\n              w = q.front(); q.pop();\\n              w->is_locked = 0;\\n              for(auto &x: w->next) q.push(x);\\n            }\\n            return table[num]->is_locked = user;\\n          }\\n          \\n          for(auto &x: w->next) q.push(x);\\n        }\\n      }      \\n      \\n      return false;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n  struct Node{\\n    Node *par;\\n    vector<Node*> next;\\n    int is_locked;\\n    Node(Node *p){is_locked = 0;par = p;}\\n  };\\n  unordered_map<int, Node*> table;\\n  \\n  \\n  LockingTree(vector<int>& parent) {                             //construct DAG\\n     for(int i = 0; i != parent.size(); i++){\\n       if(!table.count(parent[i])) table[parent[i]] = new Node(NULL);\\n       \\n       if(!table.count(i)) table[i] = new Node(table[parent[i]]);\\n       else table[i]->par = table[parent[i]];\\n       \\n       table[parent[i]]->next.push_back(table[i]);\\n     }  \\n  }\\n    \\n    bool lock(int num, int user) {\\n      return table[num]->is_locked ? false : table[num]->is_locked = user; \\n    }\\n    \\n    bool unlock(int num, int user) {\\n      return table[num]->is_locked == user ? !( table[num]->is_locked = 0 ) : false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n      Node *tmp = table[num];\\n      if(tmp->is_locked == 0){                      //if node is locked\\n        Node *w   = tmp->par;\\n        \\n        for(; w; w = w->par)\\n          if(w->is_locked != 0) return false;       //if parent of node is locked  \\n                \\n        queue<Node*>q;\\n        q.push(tmp);\\n        while(!q.empty()){\\n          w = q.front(); q.pop();\\n          \\n          if(w->is_locked){                         //if we have a children that is locked \\n            q.push(w);\\n            while(!q.empty()){\\n              w = q.front(); q.pop();\\n              w->is_locked = 0;\\n              for(auto &x: w->next) q.push(x);\\n            }\\n            return table[num]->is_locked = user;\\n          }\\n          \\n          for(auto &x: w->next) q.push(x);\\n        }\\n      }      \\n      \\n      return false;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445634,
                "title": "1993-operations-on-tree",
                "content": "---\\n\\nLooks like, there is a bug\\n- Raised formal bug here - https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/4699\\n- Details here - https://leetcode.com/problems/operations-on-tree/discuss/1445611/Bug-in-Q3\\n\\n---\\n\\n```\\nclass LockingTree {\\n    n = 0;\\n    parent = [];\\n    children = [];\\n    locked = {};\\n\\n    constructor(parent) {\\n        this.n = parent.length;\\n        this.parent = parent;\\n        for (let node = 0; node < this.n; node++) {\\n            if (this.children[parent[node]] === undefined) this.children[parent[node]] = [];\\n            this.children[parent[node]].push(node);\\n        }\\n    }\\n\\n    lock(node, user) {\\n        if (this.locked[node]) return false; // already locked, bad\\n        this.locked[node] = user; // lock for this user\\n        return true; // good\\n    }\\n\\n    unlock(node, user) {\\n        if (this.locked[node] !== user) return false; // locked by different user - bad\\n        this.locked[node] = undefined; // unlock for all\\n        return true; // good\\n    }\\n\\n    upgrade(node, user) {\\n        // ========== Check conditions =============\\n\\n        // ===== CONDITION 1 - The node is unlocked,\\n        if (this.locked[node] !== undefined) {\\n            console.log(\\'Upgrade not success\\');\\n            return false;\\n        }\\n\\n        // ===== CONDITION 2 - It has at least one locked descendant (by any user), and\\n        let isLockedByDecesdant = false;\\n        let queue = [];\\n        if (this.children[node]) queue.push(...this.children[node]);\\n        while (queue.length) {\\n            let childNode = queue.pop();\\n            if (this.locked[childNode] !== undefined) {\\n                isLockedByDecesdant = true; // It has at least one locked descendant (by any user), and\\n                break;\\n            }\\n            if (this.children[childNode]) queue.push(...this.children[childNode]);\\n        }\\n        if (isLockedByDecesdant === false) {\\n            console.log(\\'Upgrade not success - It has at least one locked descendant (by any user), and\\');\\n            return false; // Upgrade not success - It has at least one locked descendant (by any user), and\\n        }\\n\\n        // ===== CONDITION 3 - It does not have any locked ancestors.\\n        let ancestor = node; // assume\\n        while (true) {\\n            ancestor = this.parent[ancestor]; // now get ancestor\\n            if (ancestor === -1) break; // no more ancestors - stop\\n            if (this.locked[ancestor] !== undefined) {\\n                console.log(\\'Upgrade not success - It does not have any locked ancestors.\\');\\n                return false; // Upgrade not success - It does not have any locked ancestors.\\n            }\\n        }\\n\\n        // ===== ALL CONDITION MET =============\\n\\n        // ===== 1. Locks the given node for the given user\\n        if (this.lock(node, user) === false) {\\n            console.log(\\'lock failed\\');\\n            return false; // lock failed\\n        }\\n\\n        // ===== 2. unlocks all of its descendants\\n        queue = [];\\n        queue.push(...this.children[node]);\\n        while (queue.length) {\\n            let node = queue.pop();\\n\\n            this.locked[node] = undefined; // unlock for all         // <--------------------- PASS if this\\n\\n            // <------------------------------------------------------------------------------ FAIL if below\\n            /*\\n            if (this.unlock(node, user)) {\\n                // unlock success\\n            } else {\\n                console.log(\\'unlock fail\\')\\n                return false; // unlock fail <-------------- ESP THIS\\n            }\\n            */\\n\\n            if (this.children[node]) queue.push(...this.children[node]);\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass LockingTree {\\n    n = 0;\\n    parent = [];\\n    children = [];\\n    locked = {};\\n\\n    constructor(parent) {\\n        this.n = parent.length;\\n        this.parent = parent;\\n        for (let node = 0; node < this.n; node++) {\\n            if (this.children[parent[node]] === undefined) this.children[parent[node]] = [];\\n            this.children[parent[node]].push(node);\\n        }\\n    }\\n\\n    lock(node, user) {\\n        if (this.locked[node]) return false; // already locked, bad\\n        this.locked[node] = user; // lock for this user\\n        return true; // good\\n    }\\n\\n    unlock(node, user) {\\n        if (this.locked[node] !== user) return false; // locked by different user - bad\\n        this.locked[node] = undefined; // unlock for all\\n        return true; // good\\n    }\\n\\n    upgrade(node, user) {\\n        // ========== Check conditions =============\\n\\n        // ===== CONDITION 1 - The node is unlocked,\\n        if (this.locked[node] !== undefined) {\\n            console.log(\\'Upgrade not success\\');\\n            return false;\\n        }\\n\\n        // ===== CONDITION 2 - It has at least one locked descendant (by any user), and\\n        let isLockedByDecesdant = false;\\n        let queue = [];\\n        if (this.children[node]) queue.push(...this.children[node]);\\n        while (queue.length) {\\n            let childNode = queue.pop();\\n            if (this.locked[childNode] !== undefined) {\\n                isLockedByDecesdant = true; // It has at least one locked descendant (by any user), and\\n                break;\\n            }\\n            if (this.children[childNode]) queue.push(...this.children[childNode]);\\n        }\\n        if (isLockedByDecesdant === false) {\\n            console.log(\\'Upgrade not success - It has at least one locked descendant (by any user), and\\');\\n            return false; // Upgrade not success - It has at least one locked descendant (by any user), and\\n        }\\n\\n        // ===== CONDITION 3 - It does not have any locked ancestors.\\n        let ancestor = node; // assume\\n        while (true) {\\n            ancestor = this.parent[ancestor]; // now get ancestor\\n            if (ancestor === -1) break; // no more ancestors - stop\\n            if (this.locked[ancestor] !== undefined) {\\n                console.log(\\'Upgrade not success - It does not have any locked ancestors.\\');\\n                return false; // Upgrade not success - It does not have any locked ancestors.\\n            }\\n        }\\n\\n        // ===== ALL CONDITION MET =============\\n\\n        // ===== 1. Locks the given node for the given user\\n        if (this.lock(node, user) === false) {\\n            console.log(\\'lock failed\\');\\n            return false; // lock failed\\n        }\\n\\n        // ===== 2. unlocks all of its descendants\\n        queue = [];\\n        queue.push(...this.children[node]);\\n        while (queue.length) {\\n            let node = queue.pop();\\n\\n            this.locked[node] = undefined; // unlock for all         // <--------------------- PASS if this\\n\\n            // <------------------------------------------------------------------------------ FAIL if below\\n            /*\\n            if (this.unlock(node, user)) {\\n                // unlock success\\n            } else {\\n                console.log(\\'unlock fail\\')\\n                return false; // unlock fail <-------------- ESP THIS\\n            }\\n            */\\n\\n            if (this.children[node]) queue.push(...this.children[node]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444110,
                "title": "c-ac-commented-code-q-n-complexity",
                "content": "```\\nclass LockingTree {\\npublic:\\n    vector<int>adj[2001];\\n    vector<int>users;\\n    vector<int>prr;\\n    LockingTree(vector<int>& parent) {\\n        int n = parent.size();\\n        users.resize(n+1,-1); // track the user for each node , who lock the node\\n        prr = parent; // copy parent array to prr array\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i); //make directed graph\\n        }\\n    }\\n    \\n    bool lock(int num, int user) { //lock node for given user\\n        if(users[num]==-1)\\n        {\\n            users[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool islocked(int num) //check node is locked or not\\n    {\\n        return users[num]!=-1;\\n    }\\n    \\n    bool unlock(int num, int user) {  // unlock the node , if same user locked it\\n        if(users[num]==user)\\n        {\\n            users[num]=-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(islocked(num))  // if current node locked return false\\n            return false;\\n        if(check_parent(prr,num)!=0) // count how many ancestors locked , if at least one return false;\\n            return false;\\n        int cnt=0;\\n        dfs1(num,cnt); // count descendants locked nodes , if it is there unlock them too\\n        if(cnt==0)\\n            return false;\\n        lock(num,user); // before returning true lock the given node for given user\\n        return true;\\n    }\\n    \\n    int check_parent(vector<int>&prr,int num) //count how many ancestors are locked\\n    {\\n        int cnt=0;\\n        cnt+=islocked(num);\\n        if(num==0)\\n            return cnt;\\n        int pr = prr[num];\\n        while(1)\\n        {\\n            cnt+=islocked(pr);\\n            pr = prr[pr];\\n            if(pr==-1) // we reach node 0 that\\'s why\\n                break;\\n        }\\n        return cnt;\\n    }\\n    \\n    void  unlockany(int num) // unlock node , even it is locked by some other user\\n    {\\n        users[num]=-1;\\n    }\\n    \\n   void dfs1(int num,int &cnt) //count and unlock nodes for descendants\\n    {\\n       if(islocked(num)) {\\n           cnt+=islocked(num);\\n           unlockany(num);\\n       }\\n       \\n       for(auto xt : adj[num])\\n            dfs1(xt,cnt);\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<int>adj[2001];\\n    vector<int>users;\\n    vector<int>prr;\\n    LockingTree(vector<int>& parent) {\\n        int n = parent.size();\\n        users.resize(n+1,-1); // track the user for each node , who lock the node\\n        prr = parent; // copy parent array to prr array\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i); //make directed graph\\n        }\\n    }\\n    \\n    bool lock(int num, int user) { //lock node for given user\\n        if(users[num]==-1)\\n        {\\n            users[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool islocked(int num) //check node is locked or not\\n    {\\n        return users[num]!=-1;\\n    }\\n    \\n    bool unlock(int num, int user) {  // unlock the node , if same user locked it\\n        if(users[num]==user)\\n        {\\n            users[num]=-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(islocked(num))  // if current node locked return false\\n            return false;\\n        if(check_parent(prr,num)!=0) // count how many ancestors locked , if at least one return false;\\n            return false;\\n        int cnt=0;\\n        dfs1(num,cnt); // count descendants locked nodes , if it is there unlock them too\\n        if(cnt==0)\\n            return false;\\n        lock(num,user); // before returning true lock the given node for given user\\n        return true;\\n    }\\n    \\n    int check_parent(vector<int>&prr,int num) //count how many ancestors are locked\\n    {\\n        int cnt=0;\\n        cnt+=islocked(num);\\n        if(num==0)\\n            return cnt;\\n        int pr = prr[num];\\n        while(1)\\n        {\\n            cnt+=islocked(pr);\\n            pr = prr[pr];\\n            if(pr==-1) // we reach node 0 that\\'s why\\n                break;\\n        }\\n        return cnt;\\n    }\\n    \\n    void  unlockany(int num) // unlock node , even it is locked by some other user\\n    {\\n        users[num]=-1;\\n    }\\n    \\n   void dfs1(int num,int &cnt) //count and unlock nodes for descendants\\n    {\\n       if(islocked(num)) {\\n           cnt+=islocked(num);\\n           unlockany(num);\\n       }\\n       \\n       for(auto xt : adj[num])\\n            dfs1(xt,cnt);\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444106,
                "title": "c-dfs",
                "content": "```\\nclass LockingTree {\\n    vector<vector<int>> children;\\n    vector<int> par;\\n    int *lockedBy=new int[2001];\\n   public:\\n   void dfs(int num,bool &lockedDes){\\n       if(lockedBy[num]!=-1){\\n           lockedDes=true;\\n           lockedBy[num]=-1;\\n       }\\n       for(int i=0;i<children[num].size();i++){\\n           dfs(children[num][i],lockedDes);\\n       }\\n   }\\n\\n    LockingTree(vector<int>& parent) {\\n        while (children.size()) children.pop_back();\\n        for(int i=0;i<parent.size();i++) children.push_back({});\\n        for(int i=1;i<parent.size();i++) children[parent[i]].push_back(i);\\n        par=parent;\\n        for(int i=0;i<=2000;i++) lockedBy[i]=-1;\\n    }\\n\\n    bool lock(int num, int user) {\\n        if(lockedBy[num]==-1){\\n            lockedBy[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool unlock(int num, int user) {\\n        if(lockedBy[num]==user){\\n            lockedBy[num]=-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool upgrade(int num, int user) {\\n        if(lockedBy[num]!=-1) return false;\\n        bool lockedAnc=false;\\n        int i=num;\\n        while (i!=-1){\\n            if(lockedBy[i]!=-1){\\n                lockedAnc=true;\\n                break;\\n            }\\n            i=par[i];\\n        }\\n        if(lockedAnc) return false;\\n        // now all ancestors are unlocked\\n        bool lockedDes=false;\\n        dfs(num,lockedDes);\\n        if(lockedDes) lockedBy[num]=user;\\n        return lockedDes;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    vector<vector<int>> children;\\n    vector<int> par;\\n    int *lockedBy=new int[2001];\\n   public:\\n   void dfs(int num,bool &lockedDes){\\n       if(lockedBy[num]!=-1){\\n           lockedDes=true;\\n           lockedBy[num]=-1;\\n       }\\n       for(int i=0;i<children[num].size();i++){\\n           dfs(children[num][i],lockedDes);\\n       }\\n   }\\n\\n    LockingTree(vector<int>& parent) {\\n        while (children.size()) children.pop_back();\\n        for(int i=0;i<parent.size();i++) children.push_back({});\\n        for(int i=1;i<parent.size();i++) children[parent[i]].push_back(i);\\n        par=parent;\\n        for(int i=0;i<=2000;i++) lockedBy[i]=-1;\\n    }\\n\\n    bool lock(int num, int user) {\\n        if(lockedBy[num]==-1){\\n            lockedBy[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool unlock(int num, int user) {\\n        if(lockedBy[num]==user){\\n            lockedBy[num]=-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool upgrade(int num, int user) {\\n        if(lockedBy[num]!=-1) return false;\\n        bool lockedAnc=false;\\n        int i=num;\\n        while (i!=-1){\\n            if(lockedBy[i]!=-1){\\n                lockedAnc=true;\\n                break;\\n            }\\n            i=par[i];\\n        }\\n        if(lockedAnc) return false;\\n        // now all ancestors are unlocked\\n        bool lockedDes=false;\\n        dfs(num,lockedDes);\\n        if(lockedDes) lockedBy[num]=user;\\n        return lockedDes;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456477,
                "title": "java-key-value-mapping-array-beats-96",
                "content": "### Complexity\\n- Time complexity: Lock: O(1), Unlock: O(1), Upgrade: O(n)\\n\\n- Space complexity: O(n)\\n\\n### Code\\n``` java []\\nclass LockingTree {\\n    int[] parent;\\n    int[] locked;\\n    ArrayList<Integer>[] child;\\n    public LockingTree(int[] parent) {\\n        this.parent=parent;\\n        this.locked=new int[parent.length];\\n        this.child = new ArrayList[parent.length];\\n\\n        for(int i=0;i<child.length;i++){\\n            child[i] = new ArrayList<>();\\n        }\\n\\n        for(int i=1;i<parent.length;i++){\\n            child[parent[i]].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(locked[num]==0){\\n            locked[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(locked[num]==user){\\n            locked[num]=0;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if(locked[num]!=0){\\n            return false;\\n        }\\n        int ancestor = parent[num];\\n        while(ancestor!=-1){\\n            if(locked[ancestor]!=0){\\n                return false;\\n            }\\n            ancestor = parent[ancestor];\\n        }\\n        if(!hasLockedDescendant(num)){\\n            return false;\\n        }\\n        else{\\n            unlockAll(num);\\n            locked[num]=user;\\n            return true;\\n        }\\n    }\\n\\n    private boolean hasLockedDescendant(int num){\\n        if(locked[num]!=0){\\n            return true;\\n        }\\n        for(int x:child[num]){\\n            if(hasLockedDescendant(x)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void unlockAll(int num){\\n        locked[num]=0;\\n        for(int x:child[num]){\\n            unlockAll(x);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass LockingTree {\\n    int[] parent;\\n    int[] locked;\\n    ArrayList<Integer>[] child;\\n    public LockingTree(int[] parent) {\\n        this.parent=parent;\\n        this.locked=new int[parent.length];\\n        this.child = new ArrayList[parent.length];\\n\\n        for(int i=0;i<child.length;i++){\\n            child[i] = new ArrayList<>();\\n        }\\n\\n        for(int i=1;i<parent.length;i++){\\n            child[parent[i]].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(locked[num]==0){\\n            locked[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(locked[num]==user){\\n            locked[num]=0;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if(locked[num]!=0){\\n            return false;\\n        }\\n        int ancestor = parent[num];\\n        while(ancestor!=-1){\\n            if(locked[ancestor]!=0){\\n                return false;\\n            }\\n            ancestor = parent[ancestor];\\n        }\\n        if(!hasLockedDescendant(num)){\\n            return false;\\n        }\\n        else{\\n            unlockAll(num);\\n            locked[num]=user;\\n            return true;\\n        }\\n    }\\n\\n    private boolean hasLockedDescendant(int num){\\n        if(locked[num]!=0){\\n            return true;\\n        }\\n        for(int x:child[num]){\\n            if(hasLockedDescendant(x)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void unlockAll(int num){\\n        locked[num]=0;\\n        for(int x:child[num]){\\n            unlockAll(x);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256096,
                "title": "c-easy-and-recursive",
                "content": "```\\nclass LockingTree {\\nprivate:\\n\\t// Local class variables\\n    int n;\\n    vector<int> isLocked, p;\\n    unordered_map<int,vector<int>> c;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        n = parent.size();\\n        p = parent;\\n        // Set all unlocked\\n\\t\\tisLocked.resize(n,0);\\n        for(int i=0; i<parent.size(); i++)\\n            c[parent[i]].push_back(i);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        // If its unlocked\\n\\t\\tif(!isLocked[num]){\\n            isLocked[num] = user;    \\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n\\t\\t// If its not locked by the same user\\n        if(isLocked[num] != user) return false;\\n        isLocked[num] = 0;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n\\t\\t// If its locked\\n        if(isLocked[num]) return false;\\n\\t\\t// Either one return the false trigger it \\n        if(!checkDes(num) || !checkAns(num)) return false;\\n        // Unlock all Descendants\\n\\t\\tunlockDes(num);\\n\\t\\t// Lock this node\\n        isLocked[num]=user;\\n        return true;\\n    }\\n    \\n    bool checkDes(int num){\\n        // If its locked\\n\\t\\tif(isLocked[num]) return true;\\n        for(auto ch : c[num]){\\n            if(checkDes(ch)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    void unlockDes(int num){\\n        isLocked[num] = 0;\\n        for(auto ch : c[num]) unlockDes(ch);\\n    }\\n    \\n    bool checkAns(int num){\\n        // Set it as parent of it\\n\\t\\tint tp = p[num];\\n        while(tp != -1){\\n\\t\\t\\t// Recursively check for all Ancestors.\\n            if(isLocked[tp]) return false;\\n            tp = p[tp];\\n        }\\n        return true;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass LockingTree {\\nprivate:\\n\\t// Local class variables\\n    int n;\\n    vector<int> isLocked, p;\\n    unordered_map<int,vector<int>> c;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        n = parent.size();\\n        p = parent;\\n        // Set all unlocked\\n\\t\\tisLocked.resize(n,0);\\n        for(int i=0; i<parent.size(); i++)\\n            c[parent[i]].push_back(i);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        // If its unlocked\\n\\t\\tif(!isLocked[num]){\\n            isLocked[num] = user;    \\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n\\t\\t// If its not locked by the same user\\n        if(isLocked[num] != user) return false;\\n        isLocked[num] = 0;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n\\t\\t// If its locked\\n        if(isLocked[num]) return false;\\n\\t\\t// Either one return the false trigger it \\n        if(!checkDes(num) || !checkAns(num)) return false;\\n        // Unlock all Descendants\\n\\t\\tunlockDes(num);\\n\\t\\t// Lock this node\\n        isLocked[num]=user;\\n        return true;\\n    }\\n    \\n    bool checkDes(int num){\\n        // If its locked\\n\\t\\tif(isLocked[num]) return true;\\n        for(auto ch : c[num]){\\n            if(checkDes(ch)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    void unlockDes(int num){\\n        isLocked[num] = 0;\\n        for(auto ch : c[num]) unlockDes(ch);\\n    }\\n    \\n    bool checkAns(int num){\\n        // Set it as parent of it\\n\\t\\tint tp = p[num];\\n        while(tp != -1){\\n\\t\\t\\t// Recursively check for all Ancestors.\\n            if(isLocked[tp]) return false;\\n            tp = p[tp];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173940,
                "title": "c-simple-dfs",
                "content": "```\\nclass LockingTree {\\npublic:\\n    vector<int> parent, locked;\\n    vector<vector<int>> child;\\n    \\n    LockingTree(vector<int>& p) {\\n        int n = p.size();\\n        child.resize(n);\\n        locked.resize(n, -1);\\n        parent = p;\\n        for(int i = 1 ; i < n; i++)\\n            child[p[i]].push_back(i);\\n    }\\n    \\n    bool isLockedChild(int& a){\\n        if(a == -1) return false;\\n        if(locked[a] != -1) return true;\\n        for(auto& c: child[a])\\n            if(isLockedChild(c)) return true;\\n        return false;\\n    }\\n    \\n    bool isLockedParent(int& a){\\n        if(a == -1) return false;\\n        if(locked[a] != -1) return true;\\n        return isLockedParent(parent[a]);\\n    }\\n    \\n    bool checkNode(int& num){\\n        return isLockedChild(num) && !isLockedParent(num);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locked[num] != -1)\\n            return false;\\n        locked[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked[num] == -1 || locked[num] != user)\\n            return false;\\n        locked[num] = -1;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(!checkNode(num)) return false;\\n        queue<int> q;\\n        q.push(num);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int node = q.front();\\n                q.pop();\\n                if(node == -1) continue;\\n                locked[node] = -1;\\n                for(auto& c: child[node])\\n                    q.push(c);\\n            }\\n        }\\n        locked[num] = user;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<int> parent, locked;\\n    vector<vector<int>> child;\\n    \\n    LockingTree(vector<int>& p) {\\n        int n = p.size();\\n        child.resize(n);\\n        locked.resize(n, -1);\\n        parent = p;\\n        for(int i = 1 ; i < n; i++)\\n            child[p[i]].push_back(i);\\n    }\\n    \\n    bool isLockedChild(int& a){\\n        if(a == -1) return false;\\n        if(locked[a] != -1) return true;\\n        for(auto& c: child[a])\\n            if(isLockedChild(c)) return true;\\n        return false;\\n    }\\n    \\n    bool isLockedParent(int& a){\\n        if(a == -1) return false;\\n        if(locked[a] != -1) return true;\\n        return isLockedParent(parent[a]);\\n    }\\n    \\n    bool checkNode(int& num){\\n        return isLockedChild(num) && !isLockedParent(num);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locked[num] != -1)\\n            return false;\\n        locked[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked[num] == -1 || locked[num] != user)\\n            return false;\\n        locked[num] = -1;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(!checkNode(num)) return false;\\n        queue<int> q;\\n        q.push(num);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int node = q.front();\\n                q.pop();\\n                if(node == -1) continue;\\n                locked[node] = -1;\\n                for(auto& c: child[node])\\n                    q.push(c);\\n            }\\n        }\\n        locked[num] = user;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012949,
                "title": "c-dfs-clean-code",
                "content": "```\\nclass LockingTree {\\npublic:\\n    vector<int> islock;\\n    int n;\\n    unordered_map<int, vector<int>> child;\\n    vector<int> parents;\\n    \\n    LockingTree(vector<int>& parent) {\\n        parents = parent;\\n        int n = parent.size();\\n        islock.resize(n,-1);\\n        for(int i=0;i<parent.size();i++){\\n            child[parent[i]].push_back(i);\\n        }\\n    }\\n    bool lock(int num, int user) {\\n        if(islock[num]==-1){\\n            islock[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n         if(islock[num]==-1 || islock[num]!=user){\\n            return false;\\n        }\\n        islock[num]=-1;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(islock[num]!=-1)\\n            return false;\\n        if(!checkDes(num) || !checkAns(num))\\n            return false;\\n        unlockDes(num);\\n        islock[num]=user;\\n        return true;\\n    }\\n    bool checkDes(int num){\\n        if(islock[num]!=-1)\\n            return true;\\n        for(auto ch: child[num]){\\n            if(checkDes(ch))\\n                return true;\\n        }\\n        return false;\\n    }\\n    bool checkAns(int num){\\n        int temp = parents[num];\\n        while(temp!=-1){\\n            if(islock[temp]!=-1)\\n                return false;\\n            temp = parents[temp];\\n        }\\n        return true;\\n    }\\n    void unlockDes(int num){\\n        islock[num]=-1;\\n        for(auto ch: child[num]){\\n            unlockDes(ch);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<int> islock;\\n    int n;\\n    unordered_map<int, vector<int>> child;\\n    vector<int> parents;\\n    \\n    LockingTree(vector<int>& parent) {\\n        parents = parent;\\n        int n = parent.size();\\n        islock.resize(n,-1);\\n        for(int i=0;i<parent.size();i++){\\n            child[parent[i]].push_back(i);\\n        }\\n    }\\n    bool lock(int num, int user) {\\n        if(islock[num]==-1){\\n            islock[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n         if(islock[num]==-1 || islock[num]!=user){\\n            return false;\\n        }\\n        islock[num]=-1;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(islock[num]!=-1)\\n            return false;\\n        if(!checkDes(num) || !checkAns(num))\\n            return false;\\n        unlockDes(num);\\n        islock[num]=user;\\n        return true;\\n    }\\n    bool checkDes(int num){\\n        if(islock[num]!=-1)\\n            return true;\\n        for(auto ch: child[num]){\\n            if(checkDes(ch))\\n                return true;\\n        }\\n        return false;\\n    }\\n    bool checkAns(int num){\\n        int temp = parents[num];\\n        while(temp!=-1){\\n            if(islock[temp]!=-1)\\n                return false;\\n            temp = parents[temp];\\n        }\\n        return true;\\n    }\\n    void unlockDes(int num){\\n        islock[num]=-1;\\n        for(auto ch: child[num]){\\n            unlockDes(ch);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961076,
                "title": "c-easy-traversals-simple",
                "content": "```\\nclass LockingTree\\n{\\npublic:\\n    vector<int> is_lock;\\n    vector<int> parents;\\n    map<int, vector<int>> children;\\n\\t//----------------------------------------------------------------\\n    vector<int> initialize(int size)\\n    {\\n\\t// -1 means unlocked.\\n        vector<int> v(size, -1);\\n        return v;\\n    }\\n\\t//----------------------------------------------------------------\\n    LockingTree(vector<int> &parent)\\n    {\\n        is_lock = initialize(parent.size());\\n        parents = parent;\\n        int n = parent.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            children[parent[i]].push_back(i);\\n        }\\n    }\\n\\t//----------------------------------------------------------------\\n\\t\\n    bool lock(int num, int user)\\n    {\\n        if (is_lock[num] == -1)\\n        {\\n            is_lock[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    bool unlock(int num, int user)\\n    {\\n        if (is_lock[num] == user)\\n        {\\n            is_lock[num] = -1;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\t//----------------------------------------------------------------\\n\\t\\n    bool upgrade(int num, int user)\\n    {\\n        // The node is unlocked,\\n        if (is_lock[num] != -1)\\n            return false;\\n\\t\\t//----------------------------------\\n        if (is_lock[num] == -1)\\n        {\\n\\t\\t    //--------------------------------\\n\\t\\t\\t// It does not have any locked ancestors.\\n            int p = parents[num];\\n            while (p != -1)\\n            {\\n                if (is_lock[p] != -1)\\n                    return false;\\n                p = parents[p];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//---------------------------------------------------------\\n\\t\\t\\t// It has at least one locked descendant (by any user), and\\n            int cnt = 0;\\n            queue<int> q;\\n            q.push(num);\\n            while (!q.empty())\\n            {\\n                int temp = q.front();\\n                q.pop();\\n                for (auto it : children[temp])\\n                {\\n                    if (is_lock[it] != -1)\\n                    {\\n                        cnt++;\\n                        is_lock[it] = -1;\\n                    }\\n                    q.push(it);\\n                }\\n            }\\n            if (cnt == 0)\\n                return false;\\n\\t\\t    //----------------------------------------------------------------\\n        }\\n        is_lock[num] = user;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree\\n{\\npublic:\\n    vector<int> is_lock;\\n    vector<int> parents;\\n    map<int, vector<int>> children;\\n\\t//----------------------------------------------------------------\\n    vector<int> initialize(int size)\\n    {\\n\\t// -1 means unlocked.\\n        vector<int> v(size, -1);\\n        return v;\\n    }\\n\\t//----------------------------------------------------------------\\n    LockingTree(vector<int> &parent)\\n    {\\n        is_lock = initialize(parent.size());\\n        parents = parent;\\n        int n = parent.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            children[parent[i]].push_back(i);\\n        }\\n    }\\n\\t//----------------------------------------------------------------\\n\\t\\n    bool lock(int num, int user)\\n    {\\n        if (is_lock[num] == -1)\\n        {\\n            is_lock[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    bool unlock(int num, int user)\\n    {\\n        if (is_lock[num] == user)\\n        {\\n            is_lock[num] = -1;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\t//----------------------------------------------------------------\\n\\t\\n    bool upgrade(int num, int user)\\n    {\\n        // The node is unlocked,\\n        if (is_lock[num] != -1)\\n            return false;\\n\\t\\t//----------------------------------\\n        if (is_lock[num] == -1)\\n        {\\n\\t\\t    //--------------------------------\\n\\t\\t\\t// It does not have any locked ancestors.\\n            int p = parents[num];\\n            while (p != -1)\\n            {\\n                if (is_lock[p] != -1)\\n                    return false;\\n                p = parents[p];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//---------------------------------------------------------\\n\\t\\t\\t// It has at least one locked descendant (by any user), and\\n            int cnt = 0;\\n            queue<int> q;\\n            q.push(num);\\n            while (!q.empty())\\n            {\\n                int temp = q.front();\\n                q.pop();\\n                for (auto it : children[temp])\\n                {\\n                    if (is_lock[it] != -1)\\n                    {\\n                        cnt++;\\n                        is_lock[it] = -1;\\n                    }\\n                    q.push(it);\\n                }\\n            }\\n            if (cnt == 0)\\n                return false;\\n\\t\\t    //----------------------------------------------------------------\\n        }\\n        is_lock[num] = user;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893091,
                "title": "c-solution",
                "content": "```\\npublic class LockingTree\\n    {\\n        int[] _parent = null;\\n        Dictionary<int, int> _locked = new Dictionary<int, int>();\\n        Dictionary<int, List<int>> _children = new Dictionary<int, List<int>>();\\n\\n        public LockingTree(int[] parent)\\n        {\\n            _parent = parent;\\n\\n            for (int i = 0; i < parent.Length; i++)\\n            {\\n                _children[parent[i]] = new List<int>();\\n            }\\n\\n            for (int i = 0; i < parent.Length; i++)\\n            {\\n                if (parent[i] == -1) continue;\\n                _children[parent[i]].Add(i);\\n            }\\n\\n        }\\n\\n        public bool Lock(int num, int user)\\n        {\\n            if (_locked.ContainsKey(num))\\n                return false;\\n            else\\n                _locked.Add(num, user);\\n            return true;\\n        }\\n\\n        public bool Unlock(int num, int user)\\n        {\\n            if (_locked.ContainsKey(num) && _locked[num] == user)\\n            {\\n                _locked.Remove(num);\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        public bool Upgrade(int num, int user)\\n        {\\n            if (_locked.ContainsKey(num))\\n                return false;\\n\\n            bool checkAncestor = CheckAncestors(num);\\n            if (checkAncestor)\\n                return CheckDescendant(num, user);\\n            else\\n                return false;\\n        }\\n\\n        private bool CheckAncestors(int num)\\n        {\\n            int currentParent = _parent[num];\\n            while (currentParent != -1)\\n            {\\n                if (_locked.ContainsKey(currentParent))\\n                    return false;\\n                else\\n                    currentParent = _parent[currentParent];\\n            }\\n            return true;\\n        }\\n\\n        private bool CheckDescendant(int num, int user)\\n        {\\n            int lockCount = 0;\\n\\n            var queue = new Queue<int>();\\n            queue.Enqueue(num);\\n\\n            while (queue.Count > 0)\\n            {\\n                int currnt = queue.Dequeue();\\n                if (_locked.ContainsKey((int)currnt))\\n                {\\n                    _locked.Remove(currnt);\\n                    lockCount++;\\n                }\\n\\n                if (_children.ContainsKey((int)currnt))\\n                {\\n                    var children = _children[currnt];\\n                    foreach (var child in children)\\n                    {\\n                        queue.Enqueue(child);\\n                    }\\n                }\\n            }\\n\\n            if (lockCount > 0)\\n                _locked.Add(num, user);\\n            return lockCount > 0;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class LockingTree\\n    {\\n        int[] _parent = null;\\n        Dictionary<int, int> _locked = new Dictionary<int, int>();\\n        Dictionary<int, List<int>> _children = new Dictionary<int, List<int>>();\\n\\n        public LockingTree(int[] parent)\\n        {\\n            _parent = parent;\\n\\n            for (int i = 0; i < parent.Length; i++)\\n            {\\n                _children[parent[i]] = new List<int>();\\n            }\\n\\n            for (int i = 0; i < parent.Length; i++)\\n            {\\n                if (parent[i] == -1) continue;\\n                _children[parent[i]].Add(i);\\n            }\\n\\n        }\\n\\n        public bool Lock(int num, int user)\\n        {\\n            if (_locked.ContainsKey(num))\\n                return false;\\n            else\\n                _locked.Add(num, user);\\n            return true;\\n        }\\n\\n        public bool Unlock(int num, int user)\\n        {\\n            if (_locked.ContainsKey(num) && _locked[num] == user)\\n            {\\n                _locked.Remove(num);\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        public bool Upgrade(int num, int user)\\n        {\\n            if (_locked.ContainsKey(num))\\n                return false;\\n\\n            bool checkAncestor = CheckAncestors(num);\\n            if (checkAncestor)\\n                return CheckDescendant(num, user);\\n            else\\n                return false;\\n        }\\n\\n        private bool CheckAncestors(int num)\\n        {\\n            int currentParent = _parent[num];\\n            while (currentParent != -1)\\n            {\\n                if (_locked.ContainsKey(currentParent))\\n                    return false;\\n                else\\n                    currentParent = _parent[currentParent];\\n            }\\n            return true;\\n        }\\n\\n        private bool CheckDescendant(int num, int user)\\n        {\\n            int lockCount = 0;\\n\\n            var queue = new Queue<int>();\\n            queue.Enqueue(num);\\n\\n            while (queue.Count > 0)\\n            {\\n                int currnt = queue.Dequeue();\\n                if (_locked.ContainsKey((int)currnt))\\n                {\\n                    _locked.Remove(currnt);\\n                    lockCount++;\\n                }\\n\\n                if (_children.ContainsKey((int)currnt))\\n                {\\n                    var children = _children[currnt];\\n                    foreach (var child in children)\\n                    {\\n                        queue.Enqueue(child);\\n                    }\\n                }\\n            }\\n\\n            if (lockCount > 0)\\n                _locked.Add(num, user);\\n            return lockCount > 0;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863110,
                "title": "java-simple",
                "content": "```\\nclass LockingTree {\\n    //  graph[i] -> list of all childs of i\\n    ArrayList<Integer>[] graph;\\n    //  node -> locked by node\\n    HashMap<Integer, Integer> lockedBy = new HashMap<>();\\n    int[] par;\\n    \\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        par = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            par[i] = parent[i];\\n        }\\n        graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] == -1) continue;\\n            graph[parent[i]].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        //  previously locked\\n        if (lockedBy.containsKey(num)) {\\n            return false;\\n        } else {\\n            //  previously unlocked\\n            //      num -> locked by user\\n            lockedBy.put(num, user);\\n        }\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (lockedBy.containsKey(num) && lockedBy.get(num) == user) {\\n            //  unlocking\\n            lockedBy.remove(num);\\n            return true;\\n        }\\n        //  was not locked before\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (lockedBy.containsKey(num)) {\\n            return false;\\n        }\\n        boolean twoValid = checkDescendant(num);\\n        boolean threeValid = checkAncestors(num);\\n        if (twoValid && threeValid) {\\n            //  unlock all descendant of num\\n            unlock(num);\\n            lockedBy.put(num, user);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    private void unlock(int num) {\\n        for (int desc : graph[num]) {\\n            if (lockedBy.containsKey(desc)) {\\n                lockedBy.remove(desc);\\n            }\\n            unlock(desc);\\n        }\\n    }\\n    \\n    private boolean checkAncestors(int num) {\\n        int currParent = par[num];\\n        while (true) {\\n            if (currParent == -1) {\\n                return true;\\n            }\\n            if (lockedBy.containsKey(currParent)) {\\n                return false;\\n            } else {\\n                currParent = par[currParent];\\n            }\\n        }\\n    }\\n    \\n    private boolean checkDescendant(int num) {\\n        for (int desc : graph[num]) {\\n            if (lockedBy.containsKey(desc)) {\\n                return true;\\n            }\\n            if (checkDescendant(desc)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    //  graph[i] -> list of all childs of i\\n    ArrayList<Integer>[] graph;\\n    //  node -> locked by node\\n    HashMap<Integer, Integer> lockedBy = new HashMap<>();\\n    int[] par;\\n    \\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        par = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            par[i] = parent[i];\\n        }\\n        graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] == -1) continue;\\n            graph[parent[i]].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        //  previously locked\\n        if (lockedBy.containsKey(num)) {\\n            return false;\\n        } else {\\n            //  previously unlocked\\n            //      num -> locked by user\\n            lockedBy.put(num, user);\\n        }\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (lockedBy.containsKey(num) && lockedBy.get(num) == user) {\\n            //  unlocking\\n            lockedBy.remove(num);\\n            return true;\\n        }\\n        //  was not locked before\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (lockedBy.containsKey(num)) {\\n            return false;\\n        }\\n        boolean twoValid = checkDescendant(num);\\n        boolean threeValid = checkAncestors(num);\\n        if (twoValid && threeValid) {\\n            //  unlock all descendant of num\\n            unlock(num);\\n            lockedBy.put(num, user);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    private void unlock(int num) {\\n        for (int desc : graph[num]) {\\n            if (lockedBy.containsKey(desc)) {\\n                lockedBy.remove(desc);\\n            }\\n            unlock(desc);\\n        }\\n    }\\n    \\n    private boolean checkAncestors(int num) {\\n        int currParent = par[num];\\n        while (true) {\\n            if (currParent == -1) {\\n                return true;\\n            }\\n            if (lockedBy.containsKey(currParent)) {\\n                return false;\\n            } else {\\n                currParent = par[currParent];\\n            }\\n        }\\n    }\\n    \\n    private boolean checkDescendant(int num) {\\n        for (int desc : graph[num]) {\\n            if (lockedBy.containsKey(desc)) {\\n                return true;\\n            }\\n            if (checkDescendant(desc)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1830552,
                "title": "c-tree",
                "content": "```\\nclass LockingTree {\\n    vector<int> parent,lock_;\\n    vector<vector<int>> tree;\\n    int n;\\n    \\n    bool findparent(int i){  //check if any of the parent is locked\\n        if(i==-1) return 0;\\n        if(lock_[i]!=-1) return 1;\\n        return findparent(parent[i]);\\n    }\\n    \\n    bool findchild(int in){  //checks if any of the child node is locked\\n        if(lock_[in]!=-1) return 1;\\n        bool st = 0;\\n        for(int i = 0; i<tree[in].size();++i){\\n            st=st || findchild(tree[in][i]);\\n            if(st) break;\\n        } \\n        return st;\\n    }\\n    \\n    void update(int in){  // unlock all the child nodes\\n        lock_[in] = -1;\\n        for(int i = 0; i<tree[in].size();++i)  update(tree[in][i]);\\n    }\\npublic:\\n    LockingTree(vector<int>& nums) {\\n        parent  = nums;\\n        n=nums.size();\\n        tree = vector<vector<int>>(n);\\n        lock_ = vector<int>(n,-1);\\n        for(int i = 0; i<nums.size();++i) \\n            if(nums[i]>=0) tree[nums[i]].push_back(i);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(lock_[num]==-1) {lock_[num] = user; return 1;}\\n        return 0;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(lock_[num]==user){\\n            lock_[num]=-1; return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(lock_[num]!=-1) return 0;  //check the lock on num\\n        if(findparent(parent[num])) return 0; //check any locked parent\\n        if(!findchild(num)) return 0; //check any locked desendent\\n        update(num);   //unlock all child nodes\\n        lock_[num]=user;  //lock num by user\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass LockingTree {\\n    vector<int> parent,lock_;\\n    vector<vector<int>> tree;\\n    int n;\\n    \\n    bool findparent(int i){  //check if any of the parent is locked\\n        if(i==-1) return 0;\\n        if(lock_[i]!=-1) return 1;\\n        return findparent(parent[i]);\\n    }\\n    \\n    bool findchild(int in){  //checks if any of the child node is locked\\n        if(lock_[in]!=-1) return 1;\\n        bool st = 0;\\n        for(int i = 0; i<tree[in].size();++i){\\n            st=st || findchild(tree[in][i]);\\n            if(st) break;\\n        } \\n        return st;\\n    }\\n    \\n    void update(int in){  // unlock all the child nodes\\n        lock_[in] = -1;\\n        for(int i = 0; i<tree[in].size();++i)  update(tree[in][i]);\\n    }\\npublic:\\n    LockingTree(vector<int>& nums) {\\n        parent  = nums;\\n        n=nums.size();\\n        tree = vector<vector<int>>(n);\\n        lock_ = vector<int>(n,-1);\\n        for(int i = 0; i<nums.size();++i) \\n            if(nums[i]>=0) tree[nums[i]].push_back(i);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(lock_[num]==-1) {lock_[num] = user; return 1;}\\n        return 0;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(lock_[num]==user){\\n            lock_[num]=-1; return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(lock_[num]!=-1) return 0;  //check the lock on num\\n        if(findparent(parent[num])) return 0; //check any locked parent\\n        if(!findchild(num)) return 0; //check any locked desendent\\n        update(num);   //unlock all child nodes\\n        lock_[num]=user;  //lock num by user\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654114,
                "title": "python-just-array-implementation",
                "content": "```python\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.n = len(parent)\\n        self.parent = parent\\n        self.child = [[] for _ in range(self.n)]\\n        for nc, np in enumerate(self.parent):\\n            if np >= 0:\\n                self.child[np].append(nc)\\n        self.locked = [[0, 0] for _ in range(self.n)]\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num][0]:\\n            return False\\n        self.locked[num] = [1, user]\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num][0] and self.locked[num][1] == user:\\n            self.locked[num] = [0, 0]\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if not self.locked[num][0]:  # cond 1\\n            stck = [*self.child[num]]\\n            child2unlock = []\\n            while stck:\\n                cur = stck.pop()\\n                if self.locked[cur][0]:\\n                    child2unlock.append(cur)\\n                for nxt in self.child[cur]:\\n                    stck.append(nxt)\\n            if child2unlock:  # cond 2\\n                p = self.parent[num]\\n                while p >= 0:\\n                    if self.locked[p][0]:\\n                        return False  # cond 3\\n                    p = self.parent[p]\\n                self.locked[num] = [1, user]\\n                for n in child2unlock:\\n                    self.locked[n] = [0, 0]\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.n = len(parent)\\n        self.parent = parent\\n        self.child = [[] for _ in range(self.n)]\\n        for nc, np in enumerate(self.parent):\\n            if np >= 0:\\n                self.child[np].append(nc)\\n        self.locked = [[0, 0] for _ in range(self.n)]\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num][0]:\\n            return False\\n        self.locked[num] = [1, user]\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num][0] and self.locked[num][1] == user:\\n            self.locked[num] = [0, 0]\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if not self.locked[num][0]:  # cond 1\\n            stck = [*self.child[num]]\\n            child2unlock = []\\n            while stck:\\n                cur = stck.pop()\\n                if self.locked[cur][0]:\\n                    child2unlock.append(cur)\\n                for nxt in self.child[cur]:\\n                    stck.append(nxt)\\n            if child2unlock:  # cond 2\\n                p = self.parent[num]\\n                while p >= 0:\\n                    if self.locked[p][0]:\\n                        return False  # cond 3\\n                    p = self.parent[p]\\n                self.locked[num] = [1, user]\\n                for n in child2unlock:\\n                    self.locked[n] = [0, 0]\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461502,
                "title": "java-100-submission-using-array-66ms",
                "content": "Keep sum of locked children of each node to easily prune nodes when doing dfs for upgrade operations. Node that doesn\\'t have locked descendants doesn\\'t need to be visited.\\n\\n```\\nclass LockingTree {\\n    private int[] parent;\\n    private List<Integer>[] child;\\n    private Integer[] status;\\n    private int[] lockedc; // sum of locked children for node i\\n    \\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        \\n        this.parent = parent;\\n        this.child = new ArrayList[n];\\n        this.status = new Integer[n];\\n        this.lockedc = new int[n];\\n        buildChildList(parent);\\n    }\\n    \\n    private void buildChildList(int[] parent) {\\n        for(int i = 1; i < parent.length; ++i) {\\n            int p = parent[i];\\n            if(child[p] == null) {\\n                child[p] = new ArrayList<>();\\n            }\\n            child[p].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(status[num] != null) {\\n            return false;\\n        }\\n        status[num] = user;\\n        updateChild(num, 1);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(status[num] == null || status[num] != user) {\\n            return false;\\n        }\\n        status[num] = null;\\n        updateChild(num, -1);\\n        return true;\\n    }\\n    \\n    private void updateChild(int node, int op) {\\n        int p = parent[node];\\n        while(p >= 0) {\\n            lockedc[p] += op;\\n            p = parent[p];\\n        }\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if(status[num] != null || lockedc[num] == 0) return false;\\n        \\n        int p = parent[num];\\n        while(p >= 0) {\\n            if(status[p] != null) return false;\\n            p = parent[p];\\n        }\\n        int x = lockedc[num];\\n        dfs(num);\\n        updateChild(num, -x);\\n        lock(num, user);\\n        return true;\\n    }\\n    \\n    private void dfs(int node) {\\n        lockedc[node] = 0;\\n        status[node] = null;\\n        if(child[node] == null) {\\n            return;\\n        }\\n        for(int c : child[node]) {\\n            if(lockedc[c] == 0 && status[c] == null) {\\n                continue;\\n            }\\n            dfs(c);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    private int[] parent;\\n    private List<Integer>[] child;\\n    private Integer[] status;\\n    private int[] lockedc; // sum of locked children for node i\\n    \\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        \\n        this.parent = parent;\\n        this.child = new ArrayList[n];\\n        this.status = new Integer[n];\\n        this.lockedc = new int[n];\\n        buildChildList(parent);\\n    }\\n    \\n    private void buildChildList(int[] parent) {\\n        for(int i = 1; i < parent.length; ++i) {\\n            int p = parent[i];\\n            if(child[p] == null) {\\n                child[p] = new ArrayList<>();\\n            }\\n            child[p].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(status[num] != null) {\\n            return false;\\n        }\\n        status[num] = user;\\n        updateChild(num, 1);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(status[num] == null || status[num] != user) {\\n            return false;\\n        }\\n        status[num] = null;\\n        updateChild(num, -1);\\n        return true;\\n    }\\n    \\n    private void updateChild(int node, int op) {\\n        int p = parent[node];\\n        while(p >= 0) {\\n            lockedc[p] += op;\\n            p = parent[p];\\n        }\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if(status[num] != null || lockedc[num] == 0) return false;\\n        \\n        int p = parent[num];\\n        while(p >= 0) {\\n            if(status[p] != null) return false;\\n            p = parent[p];\\n        }\\n        int x = lockedc[num];\\n        dfs(num);\\n        updateChild(num, -x);\\n        lock(num, user);\\n        return true;\\n    }\\n    \\n    private void dfs(int node) {\\n        lockedc[node] = 0;\\n        status[node] = null;\\n        if(child[node] == null) {\\n            return;\\n        }\\n        for(int c : child[node]) {\\n            if(lockedc[c] == 0 && status[c] == null) {\\n                continue;\\n            }\\n            dfs(c);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461086,
                "title": "share-my-java-code-straight-forward-easy-understand",
                "content": "Explanation:\\nusing three hashmap to record parent-to-child relation and lock status.\\n\\n```java\\n// AC: Runtime: 287 ms, faster than 32.35% of Java online submissions for Operations on Tree.\\n// Memory Usage: 47.5 MB, less than 68.04% of Java online submissions for Operations on Tree.\\n// .\\n// T: lock:O(n), upgrade:O(n^2)\\n//\\nclass LockingTree {\\n    public HashMap<Integer, Integer> relation;\\n    public HashMap<Integer, List<Integer>> parentToChildRelation;\\n    public HashMap<Integer, Integer> lockUserRecord;\\n\\n    public LockingTree(int[] parent) {\\n        int size = parent.length;\\n        relation = new HashMap<>();\\n        parentToChildRelation = new HashMap<>();\\n        lockUserRecord = new HashMap<>();\\n        for (int i = 0; i < size; i++) {\\n            relation.put(i, parent[i]);\\n            if (parentToChildRelation.containsKey(parent[i])) {\\n                parentToChildRelation.get(parent[i]).add(i);\\n            } else {\\n                List<Integer> tempList = new LinkedList<>();\\n                tempList.add(i);\\n                parentToChildRelation.put(parent[i], tempList);\\n            }\\n        }\\n    }\\n\\n    public boolean lock(int num, int user) {\\n        if (lockUserRecord.containsKey(num)) {\\n            return false;\\n        } else {\\n            lockUserRecord.put(num, user);\\n            return true;\\n        }\\n    }\\n\\n    public boolean unlock(int num, int user) {\\n        if (lockUserRecord.containsKey(num) && lockUserRecord.get(num) == user) {\\n            lockUserRecord.remove(num);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    public boolean upgrade(int num, int user) {\\n        if (!lockUserRecord.containsKey(num)) {\\n            // ancester has no lock.\\n            boolean ancestorHasLock = false;\\n            int pos = num;\\n            while (relation.get(pos) != -1) {\\n                int parent = relation.get(pos);\\n                if (lockUserRecord.containsKey(parent)) {\\n                    ancestorHasLock = true;\\n                    break;\\n                }\\n                pos = parent;\\n            }\\n            if (ancestorHasLock) {\\n                return false;\\n            }\\n\\n            // check child has lock\\n            // leaf node\\n            if (!parentToChildRelation.containsKey(num)) {\\n                return false;\\n            }\\n            boolean childHasLock = false;\\n            List<Integer> searchChild = new LinkedList<>(parentToChildRelation.get(num));\\n            while (!searchChild.isEmpty()) {\\n                List<Integer> newSearchList = new LinkedList<>();\\n                for (int i: searchChild) {\\n                    if (lockUserRecord.containsKey(i)) {\\n                        childHasLock = true;\\n                        lockUserRecord.remove(i);\\n                    }\\n\\n                    newSearchList.addAll(parentToChildRelation.getOrDefault(i, new LinkedList<>()));\\n                }\\n                searchChild = newSearchList;\\n            }\\n            if (!childHasLock) {\\n                return false;\\n            }\\n            lockUserRecord.put(num, user);\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```java\\n// AC: Runtime: 287 ms, faster than 32.35% of Java online submissions for Operations on Tree.\\n// Memory Usage: 47.5 MB, less than 68.04% of Java online submissions for Operations on Tree.\\n// .\\n// T: lock:O(n), upgrade:O(n^2)\\n//\\nclass LockingTree {\\n    public HashMap<Integer, Integer> relation;\\n    public HashMap<Integer, List<Integer>> parentToChildRelation;\\n    public HashMap<Integer, Integer> lockUserRecord;\\n\\n    public LockingTree(int[] parent) {\\n        int size = parent.length;\\n        relation = new HashMap<>();\\n        parentToChildRelation = new HashMap<>();\\n        lockUserRecord = new HashMap<>();\\n        for (int i = 0; i < size; i++) {\\n            relation.put(i, parent[i]);\\n            if (parentToChildRelation.containsKey(parent[i])) {\\n                parentToChildRelation.get(parent[i]).add(i);\\n            } else {\\n                List<Integer> tempList = new LinkedList<>();\\n                tempList.add(i);\\n                parentToChildRelation.put(parent[i], tempList);\\n            }\\n        }\\n    }\\n\\n    public boolean lock(int num, int user) {\\n        if (lockUserRecord.containsKey(num)) {\\n            return false;\\n        } else {\\n            lockUserRecord.put(num, user);\\n            return true;\\n        }\\n    }\\n\\n    public boolean unlock(int num, int user) {\\n        if (lockUserRecord.containsKey(num) && lockUserRecord.get(num) == user) {\\n            lockUserRecord.remove(num);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    public boolean upgrade(int num, int user) {\\n        if (!lockUserRecord.containsKey(num)) {\\n            // ancester has no lock.\\n            boolean ancestorHasLock = false;\\n            int pos = num;\\n            while (relation.get(pos) != -1) {\\n                int parent = relation.get(pos);\\n                if (lockUserRecord.containsKey(parent)) {\\n                    ancestorHasLock = true;\\n                    break;\\n                }\\n                pos = parent;\\n            }\\n            if (ancestorHasLock) {\\n                return false;\\n            }\\n\\n            // check child has lock\\n            // leaf node\\n            if (!parentToChildRelation.containsKey(num)) {\\n                return false;\\n            }\\n            boolean childHasLock = false;\\n            List<Integer> searchChild = new LinkedList<>(parentToChildRelation.get(num));\\n            while (!searchChild.isEmpty()) {\\n                List<Integer> newSearchList = new LinkedList<>();\\n                for (int i: searchChild) {\\n                    if (lockUserRecord.containsKey(i)) {\\n                        childHasLock = true;\\n                        lockUserRecord.remove(i);\\n                    }\\n\\n                    newSearchList.addAll(parentToChildRelation.getOrDefault(i, new LinkedList<>()));\\n                }\\n                searchChild = newSearchList;\\n            }\\n            if (!childHasLock) {\\n                return false;\\n            }\\n            lockUserRecord.put(num, user);\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455140,
                "title": "python-dfs-easy-to-understand",
                "content": "It\\'s pretty straightforward.\\nWhen checking for descendants, we can also unlock them on the fly.\\n\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked = [0]*len(parent)\\n        self.children = [[] for _ in parent]\\n        for i in range(1,len(parent)):\\n            self.children[parent[i]].append(i)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]!=0:\\n            return False\\n        self.locked[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] == user:\\n            self.locked[num] = 0\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        cur = num\\n        while cur != -1:\\n            if self.locked[cur]:\\n                return False\\n            cur = self.parent[cur]\\n        if self.dfs(num):\\n            self.locked[num] = user\\n            return True\\n        return False\\n            \\n    def dfs(self, i):\\n        res = False\\n        if self.locked[i]:\\n            self.locked[i] = 0\\n            res = True\\n        for c in self.children[i]:\\n            res = self.dfs(c) or res\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked = [0]*len(parent)\\n        self.children = [[] for _ in parent]\\n        for i in range(1,len(parent)):\\n            self.children[parent[i]].append(i)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]!=0:\\n            return False\\n        self.locked[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] == user:\\n            self.locked[num] = 0\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        cur = num\\n        while cur != -1:\\n            if self.locked[cur]:\\n                return False\\n            cur = self.parent[cur]\\n        if self.dfs(num):\\n            self.locked[num] = user\\n            return True\\n        return False\\n            \\n    def dfs(self, i):\\n        res = False\\n        if self.locked[i]:\\n            self.locked[i] = 0\\n            res = True\\n        for c in self.children[i]:\\n            res = self.dfs(c) or res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449378,
                "title": "java-solution-with-explanation-faster-than-98-just-do-what-they-ask",
                "content": "Lock and Unlock functions are very straightforward. \\n\\nFor the Upgrade function, check all 3 conditions, if they hold return true, otherwise, return false.\\nContition 1 (easy): Check the HashMap for the specified node. If it is present in the map, the node is already locked, return false;\\n\\nCondition 2 (not too bad): Check if any of the node\\'s ancestors are locked. Start form the node\\'s index in the parent array and keep getting the parent of a node (i.e move up the tree). If at any point you find a node that is present in the hash map, that node is locked, and the second contition fails. Return false.\\n\\nCondition 3 (harder): Check if any of the node\\'s descendants are locked. Loop through all the keys in the hash map and continue getting the parent of that node (i.e again, move up the tree). Additionally, put all nodes along the path in an arraylist. Do so until you either reach the root of the tree (in which case the current node you are asked to upgrade does not have any locked nodes along that particular path) or until you reach the current node you are asked to upgrade (in which case the current node does have a locked descendant along that particular path). In the second case, add all the nodes along that path into the descendants list and later on remove them from the hash map.\\n\\n```\\nclass LockingTree {\\n    private Map<Integer, Integer> map = new HashMap<>();\\n    private int[] parent;\\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(map.containsKey(num)) return false;\\n        map.put(num, user);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(!map.containsKey(num)) return false;\\n        if(map.get(num) == user) {\\n            map.remove(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n\\t\\t// first condition: check if node is already locked\\n        if(map.containsKey(num)) \\n            return false;\\n\\t\\t// second condition: check if any of the node\\'s ancestors are already locked\\n        int par = parent[num];\\n        while(par != -1) {\\n            if(map.containsKey(par)) \\n                return false;\\n            par = parent[par];\\n        }\\n\\t\\t// third condition: check if a node has any locked descendants\\n        boolean found = false;\\n        List<Integer> descendants = new ArrayList<>();\\n\\t\\t// loop through all locked nodes\\n        for(int key: map.keySet()) {\\n            found = false;\\n            int p = parent[key];\\n            List<Integer> l = new ArrayList<>();\\n            l.add(key);\\n\\t\\t\\t// move up the tree using parent array\\n            while(p != -1) {\\n\\t\\t\\t\\t// keep adding nodes along the path in case this path ends up containing locked descendant\\n                l.add(p);\\n\\t\\t\\t\\t// if you reach the current node it means that this current path contains a descendant\\n                if(p == num) {\\n                    found = true;\\n                    break;\\n                }\\n                p = parent[p];\\n            }\\n\\t\\t\\t// if you found a descendant add all nodes along the path into a descendants list\\n            if(found) \\n                descendants.addAll(l);\\n        }\\n\\t\\t// if we found any descendants remove them from the map and return true\\n        if(descendants.size() > 0) {\\n            for(int n: descendants)\\n                map.remove(n);\\n            map.put(num, user);\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    private Map<Integer, Integer> map = new HashMap<>();\\n    private int[] parent;\\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(map.containsKey(num)) return false;\\n        map.put(num, user);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(!map.containsKey(num)) return false;\\n        if(map.get(num) == user) {\\n            map.remove(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n\\t\\t// first condition: check if node is already locked\\n        if(map.containsKey(num)) \\n            return false;\\n\\t\\t// second condition: check if any of the node\\'s ancestors are already locked\\n        int par = parent[num];\\n        while(par != -1) {\\n            if(map.containsKey(par)) \\n                return false;\\n            par = parent[par];\\n        }\\n\\t\\t// third condition: check if a node has any locked descendants\\n        boolean found = false;\\n        List<Integer> descendants = new ArrayList<>();\\n\\t\\t// loop through all locked nodes\\n        for(int key: map.keySet()) {\\n            found = false;\\n            int p = parent[key];\\n            List<Integer> l = new ArrayList<>();\\n            l.add(key);\\n\\t\\t\\t// move up the tree using parent array\\n            while(p != -1) {\\n\\t\\t\\t\\t// keep adding nodes along the path in case this path ends up containing locked descendant\\n                l.add(p);\\n\\t\\t\\t\\t// if you reach the current node it means that this current path contains a descendant\\n                if(p == num) {\\n                    found = true;\\n                    break;\\n                }\\n                p = parent[p];\\n            }\\n\\t\\t\\t// if you found a descendant add all nodes along the path into a descendants list\\n            if(found) \\n                descendants.addAll(l);\\n        }\\n\\t\\t// if we found any descendants remove them from the map and return true\\n        if(descendants.size() > 0) {\\n            for(int n: descendants)\\n                map.remove(n);\\n            map.put(num, user);\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446463,
                "title": "c-simple-dfs-implementation-280ms-118mb",
                "content": "This one ended up to be more verbose than expected, but if you just follow the requirements, it is hard to get lost while trying to solve it.\\n\\nGood exercise overall, offering a n-ary tree to be navigated top-down and bottom-up.\\n\\nTo solve this problem, we will first of all create a few class variable to pass data across methods:\\n* `locked` will be an array of integers to store who locked each node (`0` if unlocked);\\n* `parent` will copy the initial input to allow some other methods to access the data;\\n* `tree` is  an array of vectors (all the children of the node `x` will be included in `tree[x]`) and where we will reconstruct a tree to be navigated from  top to bottom (whereas `parent` allows the other way around); I initially used an `unordered_map` for it, but since we know the nodes are always going to be in the `0` - `parent.size() - 1` range, I rather optimised further and man was it faster - with a good 50-60% of gain compared to the hashmap and much less memory used \\uD83E\\uDD1F.\\n\\nIn our constructor we will then declare a support variable `len` to store the size the input (for convenience) and then:\\n* create and initialise `locked`, filling all its values initially with `0`s;\\n* create and initialise `tree`, filling all its values initially with its children;\\n* copy  the original `parent` into our class version.\\n\\nThe `lock` and `unlock` methods are actually rather trivial now, with this setup:\\n* we check for a positive condition (the current node being unlocked or locked by the same user, respectively), and in case:\\n\\t* change the node status as required;\\n\\t* `return` true`;\\n* otherwise, we just `return` `false`.\\n\\nThe third method, `upgrade`, is the fun one, so, following the requirements and going from the easier to the more complex (and expensive) of them:\\n* we check if the target node was locked and if not, we `return` `false`;\\n* declare the variable `anc`, initially set to be `parent[num]`;\\n* loop while `anc != -1` (ie: we reached the root) and:\\n\\t* check if the ancestor is locked current ancestor `anc` is locked and if so, we just `return` `false`;\\n\\t* if not, we update `anc` to be the next `parent[num]`;\\n* tricky one, we will have to check now if at least one descendent is locked, calling `checkLock` on the node `num` and returning `false` once we find the very first locked node in our traversal:\\n\\t* this support function works using a DFS approach that will proceed recursively to look for a locked `node` across all of its children and, once found, will `return` `true`; `false` otherwise; to do so we will:\\n\\t* check if the current node is locked and, if so, `return` `true`;\\n\\t* declare `res` initially built to be our accumulator, initially set to `false`;\\n* if we did not exit this function yet, we know that all the conditions are met, so we can call `unlockAll(num)`:\\n\\t* this function is another DFS helper that will simply:\\n\\t\\t* unlock the current `node`;\\n\\t\\t* call itself recursively on all of its children;\\n* we still need to keep the original node locked, so we will set locked[num] = user`;\\n* finally, we can `return` `true` :)\\n\\nThe code:\\n\\n```cpp\\nclass LockingTree {\\n    int *locked;\\n    vector<int> parent;\\n    vector<int> *tree;\\n    bool checkLock(int node) {\\n        // base case: found a locked node!\\n        if (locked[node]) return true;\\n        bool res = false;\\n        // exploring all the children recursively\\n        for (int nxt: tree[node]) {\\n            res |= checkLock(nxt);\\n            if (res) break;\\n        }  \\n        return res;\\n    }\\n    void unlockAll(int node) {\\n        locked[node] = 0;\\n        for (int nxt: tree[node]) unlockAll(nxt);\\n    }\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        // support variables\\n        int len = parent.size();\\n        // populating locked\\n        locked = new int[len];\\n        fill(locked, locked + len, 0);\\n        // populating tree\\n        tree = new vector<int>[len];\\n        for (int i = 1; i < len; i++) {\\n            tree[parent[i]].push_back(i);\\n        }\\n        // coping parent\\n        this->parent = parent;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        // checking if currently unlocked\\n        if (!locked[num]) {\\n            locked[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        // checking if we can unlock\\n        if (locked[num] == user) {\\n            locked[num] = 0;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        // checking if the node was locked\\n        if (locked[num]) return false;\\n        // checking if any ancestor is locked;\\n        int anc = parent[num];\\n        while (anc != -1) {\\n            if (locked[anc]) return false;\\n            anc = parent[anc];\\n        }\\n        // checking if at least one descendent is unlocked\\n        if (!checkLock(num)) return false;\\n        // unlocking all the subtree\\n        unlockAll(num);\\n        // locking node\\n        locked[num] = user;\\n        return true;\\n    }\\n};\\n```\\n\\nBy comparison, my original, not optimised version that runs much slower not having optimised `checkLock` (gained ~40ms from it) and using an expensive hashmap (that used 200-300ms more to run\\uD83D\\uDE31!):\\n\\n```cpp\\nclass LockingTree {\\n    int *locked;\\n    vector<int> parent;\\n    unordered_map<int, vector<int>> tree;\\n    bool checkLock(int node) {\\n        bool res = locked[node];\\n        for (int nxt: tree[node]) {\\n            res |= checkLock(nxt);\\n            if (res) break;\\n        }  \\n        return res;\\n    }\\n    void unlockAll(int node) {\\n        locked[node] = 0;\\n        for (int nxt: tree[node]) unlockAll(nxt);\\n    }\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        int len = parent.size();\\n        locked = new int[len];\\n        fill(locked, locked + len, 0);\\n        this->parent = parent;\\n        for (int i = 0; i < len; i++) {\\n            tree[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (!locked[num]) {\\n            locked[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (locked[num] == user) {\\n            locked[num] = 0;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        // checking if the node was locked\\n        if (locked[num]) return false;\\n        // checking if any ancestor is locked;\\n        int anc = num;\\n        while (anc != -1) {\\n            if (locked[anc]) return false;\\n            anc = parent[anc];\\n        }\\n        // checking if at least one descendent is unlocked\\n        if (!checkLock(num)) return false;\\n        // unlocking all the subtree\\n        unlockAll(num);\\n        // locking node\\n        locked[num] = user;\\n        return true;\\n    }\\n};\\n```\\n\\nAnd just to the sake of argument, I tried replacing the array of vectors with an array of arrays; since it seems like we get test cases with up to `2000` children on the same node, it does not really work great anyway and it ends up timing out for the largest input (but performs sweetly for the smallest ones):\\n\\n```cpp\\nconstexpr int maxChildPerNode = 2000;\\n\\nclass LockingTree {\\n    int *locked, *treePos;\\n    vector<int> parent;\\n    int **tree;\\n    bool checkLock(int node) {\\n        // base case: found a locked node!\\n        if (locked[node]) return true;\\n        bool res = false;\\n        // exploring all the children recursively\\n        for (int i = 0, lmt = treePos[node]; i < lmt; i++) {\\n            res |= checkLock(tree[node][i]);\\n            if (res) break;\\n        }  \\n        return res;\\n    }\\n    void unlockAll(int node) {\\n        locked[node] = 0;\\n        for (int i = 0, lmt = treePos[node]; i < lmt; i++) unlockAll(tree[node][i]);\\n    }\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        // support variables\\n        int len = parent.size();\\n        // populating locked\\n        locked = new int[len];\\n        fill(locked, locked + len, 0);\\n        // populating tree\\n        tree = new int*[len], treePos = new int[len];\\n        for (int i = 0, maxSize = min(maxChildPerNode, len); i < len; i++) {\\n            tree[i] = new int[maxSize];\\n            treePos[i] = 0;\\n        }\\n        for (int i = 1, currParent; i < len; i++) {\\n            currParent = parent[i];\\n            tree[currParent][treePos[currParent]++] = i;\\n        }\\n        // coping parent\\n        this->parent = parent;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        // checking if currently unlocked\\n        if (!locked[num]) {\\n            locked[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        // checking if we can unlock\\n        if (locked[num] == user) {\\n            locked[num] = 0;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        // checking if the node was locked\\n        if (locked[num]) return false;\\n        // checking if any ancestor is locked;\\n        int anc = parent[num];\\n        while (anc != -1) {\\n            if (locked[anc]) return false;\\n            anc = parent[anc];\\n        }\\n        // checking if at least one descendent is unlocked\\n        if (!checkLock(num)) return false;\\n        // unlocking all the subtree\\n        unlockAll(num);\\n        // locking node\\n        locked[num] = user;\\n        return true;\\n    }\\n};\\n```\\n\\nOkay, time to fold, right?\\n\\nHell, no: I went to create sub-arrays only for the nodes with children and that has a much better time (still a bit below my first version, though):\\n\\n```cpp\\nconstexpr int maxChildPerNode = 2000;\\n\\nclass LockingTree {\\n    // the rest is the same\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        // support variables\\n        int len = parent.size(), maxSize = min(maxChildPerNode, len);\\n        unordered_set<int> uniques;\\n        // populating locked\\n        locked = new int[len];\\n        fill(locked, locked + len, 0);\\n        // getting unique parents\\n        for (int i = 1; i < len; i++) uniques.insert(parent[i]);\\n        // populating tree\\n        tree = new int*[len], treePos = new int[len];\\n        for (int u: uniques) {\\n            tree[u] = new int[maxSize];\\n        }\\n        fill(treePos, treePos + len, 0);\\n        for (int i = 1, currParent; i < len; i++) {\\n            currParent = parent[i];\\n            tree[currParent][treePos[currParent]++] = i;\\n        }\\n        // coping parent\\n        this->parent = parent;\\n    }\\n\\t// the rest is the same\\n```\\n\\nBut... Wait, a moment, if I am going to parse `parent` to find how which node has children, I might as well store how many and further optimise!\\n\\nLast version, performing rather well too, comparable with the one using an array of vectors:\\n\\n```cpp\\n    LockingTree(vector<int>& parent) {\\n        // support variables\\n        int len = parent.size(), maxSize = min(maxChildPerNode, len), children[len];\\n        // populating locked\\n        locked = new int[len];\\n        fill(locked, locked + len, 0);\\n        // getting the amount of children for each node\\n        fill(children, children + len, 0);\\n        for (int i = 1; i < len; i++) children[parent[i]]++;\\n        // populating tree\\n        tree = new int*[len], treePos = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            if (children[i]) tree[i] = new int[children[i]];\\n        }\\n        fill(treePos, treePos + len, 0);\\n        for (int i = 1, currParent; i < len; i++) {\\n            currParent = parent[i];\\n            tree[currParent][treePos[currParent]++] = i;\\n        }\\n        // coping parent\\n        this->parent = parent;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass LockingTree {\\n    int *locked;\\n    vector<int> parent;\\n    vector<int> *tree;\\n    bool checkLock(int node) {\\n        // base case: found a locked node!\\n        if (locked[node]) return true;\\n        bool res = false;\\n        // exploring all the children recursively\\n        for (int nxt: tree[node]) {\\n            res |= checkLock(nxt);\\n            if (res) break;\\n        }  \\n        return res;\\n    }\\n    void unlockAll(int node) {\\n        locked[node] = 0;\\n        for (int nxt: tree[node]) unlockAll(nxt);\\n    }\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        // support variables\\n        int len = parent.size();\\n        // populating locked\\n        locked = new int[len];\\n        fill(locked, locked + len, 0);\\n        // populating tree\\n        tree = new vector<int>[len];\\n        for (int i = 1; i < len; i++) {\\n            tree[parent[i]].push_back(i);\\n        }\\n        // coping parent\\n        this->parent = parent;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        // checking if currently unlocked\\n        if (!locked[num]) {\\n            locked[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        // checking if we can unlock\\n        if (locked[num] == user) {\\n            locked[num] = 0;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        // checking if the node was locked\\n        if (locked[num]) return false;\\n        // checking if any ancestor is locked;\\n        int anc = parent[num];\\n        while (anc != -1) {\\n            if (locked[anc]) return false;\\n            anc = parent[anc];\\n        }\\n        // checking if at least one descendent is unlocked\\n        if (!checkLock(num)) return false;\\n        // unlocking all the subtree\\n        unlockAll(num);\\n        // locking node\\n        locked[num] = user;\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass LockingTree {\\n    int *locked;\\n    vector<int> parent;\\n    unordered_map<int, vector<int>> tree;\\n    bool checkLock(int node) {\\n        bool res = locked[node];\\n        for (int nxt: tree[node]) {\\n            res |= checkLock(nxt);\\n            if (res) break;\\n        }  \\n        return res;\\n    }\\n    void unlockAll(int node) {\\n        locked[node] = 0;\\n        for (int nxt: tree[node]) unlockAll(nxt);\\n    }\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        int len = parent.size();\\n        locked = new int[len];\\n        fill(locked, locked + len, 0);\\n        this->parent = parent;\\n        for (int i = 0; i < len; i++) {\\n            tree[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (!locked[num]) {\\n            locked[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (locked[num] == user) {\\n            locked[num] = 0;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        // checking if the node was locked\\n        if (locked[num]) return false;\\n        // checking if any ancestor is locked;\\n        int anc = num;\\n        while (anc != -1) {\\n            if (locked[anc]) return false;\\n            anc = parent[anc];\\n        }\\n        // checking if at least one descendent is unlocked\\n        if (!checkLock(num)) return false;\\n        // unlocking all the subtree\\n        unlockAll(num);\\n        // locking node\\n        locked[num] = user;\\n        return true;\\n    }\\n};\\n```\n```cpp\\nconstexpr int maxChildPerNode = 2000;\\n\\nclass LockingTree {\\n    int *locked, *treePos;\\n    vector<int> parent;\\n    int **tree;\\n    bool checkLock(int node) {\\n        // base case: found a locked node!\\n        if (locked[node]) return true;\\n        bool res = false;\\n        // exploring all the children recursively\\n        for (int i = 0, lmt = treePos[node]; i < lmt; i++) {\\n            res |= checkLock(tree[node][i]);\\n            if (res) break;\\n        }  \\n        return res;\\n    }\\n    void unlockAll(int node) {\\n        locked[node] = 0;\\n        for (int i = 0, lmt = treePos[node]; i < lmt; i++) unlockAll(tree[node][i]);\\n    }\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        // support variables\\n        int len = parent.size();\\n        // populating locked\\n        locked = new int[len];\\n        fill(locked, locked + len, 0);\\n        // populating tree\\n        tree = new int*[len], treePos = new int[len];\\n        for (int i = 0, maxSize = min(maxChildPerNode, len); i < len; i++) {\\n            tree[i] = new int[maxSize];\\n            treePos[i] = 0;\\n        }\\n        for (int i = 1, currParent; i < len; i++) {\\n            currParent = parent[i];\\n            tree[currParent][treePos[currParent]++] = i;\\n        }\\n        // coping parent\\n        this->parent = parent;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        // checking if currently unlocked\\n        if (!locked[num]) {\\n            locked[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        // checking if we can unlock\\n        if (locked[num] == user) {\\n            locked[num] = 0;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        // checking if the node was locked\\n        if (locked[num]) return false;\\n        // checking if any ancestor is locked;\\n        int anc = parent[num];\\n        while (anc != -1) {\\n            if (locked[anc]) return false;\\n            anc = parent[anc];\\n        }\\n        // checking if at least one descendent is unlocked\\n        if (!checkLock(num)) return false;\\n        // unlocking all the subtree\\n        unlockAll(num);\\n        // locking node\\n        locked[num] = user;\\n        return true;\\n    }\\n};\\n```\n```cpp\\nconstexpr int maxChildPerNode = 2000;\\n\\nclass LockingTree {\\n    // the rest is the same\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        // support variables\\n        int len = parent.size(), maxSize = min(maxChildPerNode, len);\\n        unordered_set<int> uniques;\\n        // populating locked\\n        locked = new int[len];\\n        fill(locked, locked + len, 0);\\n        // getting unique parents\\n        for (int i = 1; i < len; i++) uniques.insert(parent[i]);\\n        // populating tree\\n        tree = new int*[len], treePos = new int[len];\\n        for (int u: uniques) {\\n            tree[u] = new int[maxSize];\\n        }\\n        fill(treePos, treePos + len, 0);\\n        for (int i = 1, currParent; i < len; i++) {\\n            currParent = parent[i];\\n            tree[currParent][treePos[currParent]++] = i;\\n        }\\n        // coping parent\\n        this->parent = parent;\\n    }\\n\\t// the rest is the same\\n```\n```cpp\\n    LockingTree(vector<int>& parent) {\\n        // support variables\\n        int len = parent.size(), maxSize = min(maxChildPerNode, len), children[len];\\n        // populating locked\\n        locked = new int[len];\\n        fill(locked, locked + len, 0);\\n        // getting the amount of children for each node\\n        fill(children, children + len, 0);\\n        for (int i = 1; i < len; i++) children[parent[i]]++;\\n        // populating tree\\n        tree = new int*[len], treePos = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            if (children[i]) tree[i] = new int[children[i]];\\n        }\\n        fill(treePos, treePos + len, 0);\\n        for (int i = 1, currParent; i < len; i++) {\\n            currParent = parent[i];\\n            tree[currParent][treePos[currParent]++] = i;\\n        }\\n        // coping parent\\n        this->parent = parent;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444607,
                "title": "c-clean-concise-solution",
                "content": "```\\nclass LockingTree {\\n    vector<tuple<short, short, forward_list<short>>> tree; // parent, lockedBy, list of children\\n    \\n    bool unlockDescendant(const short& num) { // O(N)\\n        queue<short> q;\\n        q.push(num);\\n        bool hasLockedDescendant = false;\\n        \\n        do\\n            for(short i = q.size(); i > 0; --i) {\\n                if (get<1>(tree[q.front()]) >= 0) {\\n                    hasLockedDescendant = true;\\n                    get<1>(tree[q.front()]) = -1;\\n                }\\n                \\n                for(const short& j: get<2>(tree[q.front()])) q.push(j);\\n                \\n                q.pop();\\n            }\\n        while (!q.empty());\\n        \\n        return hasLockedDescendant;\\n    }\\n    \\npublic:\\n    LockingTree(const vector<int>& parent) { // O(N)\\n        tree.resize(parent.size());\\n        tree[0] = {-1, -1, {}};\\n        for(short i = 1; i < tree.size(); ++i) {\\n            get<0>(tree[i]) = parent[i];\\n            get<1>(tree[i]) = -1;\\n            get<2>(tree[parent[i]]).push_front(i);\\n        }\\n    }\\n    \\n    bool lock(const int& num, const int& user) { // O(1)\\n        if (get<1>(tree[num]) < 0) {\\n            get<1>(tree[num]) = user;\\n            return true;\\n        }\\n            \\n        return false;\\n    }\\n    \\n    bool unlock(const int& num, const int& user) { // O(1)\\n        if (get<1>(tree[num]) == user) {\\n            get<1>(tree[num]) = -1;\\n            return true;\\n        }\\n            \\n        return false;\\n    }\\n    \\n    bool upgrade(const int& num, const int& user) { // O(N)\\n        if (get<1>(tree[num]) < 0) {\\n            for(short i = get<0>(tree[num]); i >= 0; i = get<0>(tree[i]))\\n                if (get<1>(tree[i]) >= 0) return false;\\n            \\n            if (!unlockDescendant(num)) return false;\\n            \\n            get<1>(tree[num]) = user;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}; // Space complexity: O(N)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\n    vector<tuple<short, short, forward_list<short>>> tree; // parent, lockedBy, list of children\\n    \\n    bool unlockDescendant(const short& num) { // O(N)\\n        queue<short> q;\\n        q.push(num);\\n        bool hasLockedDescendant = false;\\n        \\n        do\\n            for(short i = q.size(); i > 0; --i) {\\n                if (get<1>(tree[q.front()]) >= 0) {\\n                    hasLockedDescendant = true;\\n                    get<1>(tree[q.front()]) = -1;\\n                }\\n                \\n                for(const short& j: get<2>(tree[q.front()])) q.push(j);\\n                \\n                q.pop();\\n            }\\n        while (!q.empty());\\n        \\n        return hasLockedDescendant;\\n    }\\n    \\npublic:\\n    LockingTree(const vector<int>& parent) { // O(N)\\n        tree.resize(parent.size());\\n        tree[0] = {-1, -1, {}};\\n        for(short i = 1; i < tree.size(); ++i) {\\n            get<0>(tree[i]) = parent[i];\\n            get<1>(tree[i]) = -1;\\n            get<2>(tree[parent[i]]).push_front(i);\\n        }\\n    }\\n    \\n    bool lock(const int& num, const int& user) { // O(1)\\n        if (get<1>(tree[num]) < 0) {\\n            get<1>(tree[num]) = user;\\n            return true;\\n        }\\n            \\n        return false;\\n    }\\n    \\n    bool unlock(const int& num, const int& user) { // O(1)\\n        if (get<1>(tree[num]) == user) {\\n            get<1>(tree[num]) = -1;\\n            return true;\\n        }\\n            \\n        return false;\\n    }\\n    \\n    bool upgrade(const int& num, const int& user) { // O(N)\\n        if (get<1>(tree[num]) < 0) {\\n            for(short i = get<0>(tree[num]); i >= 0; i = get<0>(tree[i]))\\n                if (get<1>(tree[i]) >= 0) return false;\\n            \\n            if (!unlockDescendant(num)) return false;\\n            \\n            get<1>(tree[num]) = user;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}; // Space complexity: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444519,
                "title": "i-got-confused-on-upgrading-but-finally-solved",
                "content": "One thing people should know is that, the unlock in ```unlock``` is different from the one in ```upgrade```. The one in ```upgrade``` can unlock any descendant no matter its owner is the user or not. I just reused my ```unlock``` in my ```upgrade``` and went wrong in some later unlock test cases. This was the only thing which had blocked me in the contest for almost half an hour.\\nAnd I believe the problem had better clarify it in case people get stuck too in the future.\\nBTW., I use some DFS to check the conditions of ```upgrade``` but that\\'s not a must-do. You could also try BFS.\\n```\\nclass LockingTree {\\n    HashMap<Integer, List<Integer>> anc;\\n    HashMap<Integer, List<Integer>> desc;\\n    boolean[] locked;\\n    int[] users;\\n    \\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        anc = new HashMap<>();\\n        desc = new HashMap<>();\\n        for (int i = 0; i < parent.length; ++i) {\\n            anc.computeIfAbsent(i, x -> new ArrayList<>()).add(parent[i]);\\n            desc.computeIfAbsent(parent[i], x -> new ArrayList<>()).add(i);\\n        }\\n        locked = new boolean[n];\\n        users = new int[n];\\n        Arrays.fill(locked, false);\\n        Arrays.fill(users, -1);\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (locked[num])\\n            return false;\\n        locked[num] = true;\\n        users[num] = user;\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (!locked[num] || users[num] != user)\\n            return false;\\n        locked[num] = false;\\n        users[num] = -1;\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (locked[num])\\n            return false;\\n        int cur = num;\\n        while (cur != -1) {\\n            cur = anc.get(cur).get(0);\\n            if (cur != -1 && locked[cur])\\n                return false;\\n        }\\n        for (int a: anc.get(num)) {\\n            if (a != -1 && locked[a])\\n                return false;\\n        }\\n        if (!checkdesc(num))\\n            return false;\\n        unlockdesc(num, user);\\n        if (!lock(num, user))\\n            return false;\\n        return true;\\n    }\\n    \\n    private void unlockdesc(int num, int user) {\\n        if (locked[num]) {\\n            locked[num] = false;\\n            users[num] = -1;\\n        }\\n        List<Integer> ds = desc.get(num);\\n        if (ds == null) return;\\n        for (int d: ds) {\\n            unlockdesc(d, user);\\n        }\\n    }\\n    \\n    private boolean checkdesc(int num) {\\n        if (locked[num]) return true;\\n        List<Integer> ds = desc.get(num);\\n        if (ds == null) return false;\\n        for (int d: ds) {\\n            if (checkdesc(d))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```unlock```\n```upgrade```\n```upgrade```\n```unlock```\n```upgrade```\n```upgrade```\n```\\nclass LockingTree {\\n    HashMap<Integer, List<Integer>> anc;\\n    HashMap<Integer, List<Integer>> desc;\\n    boolean[] locked;\\n    int[] users;\\n    \\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        anc = new HashMap<>();\\n        desc = new HashMap<>();\\n        for (int i = 0; i < parent.length; ++i) {\\n            anc.computeIfAbsent(i, x -> new ArrayList<>()).add(parent[i]);\\n            desc.computeIfAbsent(parent[i], x -> new ArrayList<>()).add(i);\\n        }\\n        locked = new boolean[n];\\n        users = new int[n];\\n        Arrays.fill(locked, false);\\n        Arrays.fill(users, -1);\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (locked[num])\\n            return false;\\n        locked[num] = true;\\n        users[num] = user;\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (!locked[num] || users[num] != user)\\n            return false;\\n        locked[num] = false;\\n        users[num] = -1;\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (locked[num])\\n            return false;\\n        int cur = num;\\n        while (cur != -1) {\\n            cur = anc.get(cur).get(0);\\n            if (cur != -1 && locked[cur])\\n                return false;\\n        }\\n        for (int a: anc.get(num)) {\\n            if (a != -1 && locked[a])\\n                return false;\\n        }\\n        if (!checkdesc(num))\\n            return false;\\n        unlockdesc(num, user);\\n        if (!lock(num, user))\\n            return false;\\n        return true;\\n    }\\n    \\n    private void unlockdesc(int num, int user) {\\n        if (locked[num]) {\\n            locked[num] = false;\\n            users[num] = -1;\\n        }\\n        List<Integer> ds = desc.get(num);\\n        if (ds == null) return;\\n        for (int d: ds) {\\n            unlockdesc(d, user);\\n        }\\n    }\\n    \\n    private boolean checkdesc(int num) {\\n        if (locked[num]) return true;\\n        List<Integer> ds = desc.get(num);\\n        if (ds == null) return false;\\n        for (int d: ds) {\\n            if (checkdesc(d))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444377,
                "title": "c-dfs",
                "content": "class LockingTree {\\npublic:\\n   \\n    vector<vector<int>>  child ;\\n    \\n    vector<int> locked;\\n    \\n    vector<int> par;\\n\\n    int n ; \\n    \\n    void findchild(int i ,int& flag )\\n    {\\n        if(locked[i]!=-1)\\n        {locked[i]=-1;\\n         flag =1 ;\\n        }\\n        \\n        for(auto x : child[i])\\n        {\\n            findchild(x,flag);\\n            \\n        }\\n        \\n        return  ; \\n        \\n    }\\n    \\n    bool findanc(int i)\\n    {\\n        if(i==-1)\\n            return true ;\\n        \\n        if(locked[i]!=-1)\\n            return false ;\\n        \\n        return findanc(par[i]) ;\\n        \\n        \\n    }\\n    \\n    LockingTree(vector<int>& parent) {\\n        \\n        n = parent.size() ;\\n        \\n        locked.resize(n,-1) ;\\n        \\n       \\n        child.resize(n) ;\\n       \\n        \\n        par = parent;\\n        \\n        for(int i=1 ; i<n ; i++)\\n        {   \\n            child[parent[i]].push_back(i) ;\\n        }\\n        \\n  \\n    }\\n    \\n    bool lock(int num, int user) {\\n        \\n        if(locked[num]==-1)\\n        {\\n            locked[num]=user;\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        \\n        if(locked[num]==user)\\n        {\\n            locked[num]=-1;\\n            return true;\\n        }\\n        else\\n            return false;\\n        \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        if(locked[num]!=-1)\\n            return false;\\n        \\n        if(findanc(par[num]))\\n        {\\n            int flag =0 ;\\n            \\n            findchild(num,flag) ;\\n            \\n            if(flag==1)\\n            {  locked[num]=user;\\n                return true ;\\n            }\\n            \\n        }\\n        \\n        \\n        return false;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class LockingTree {\\npublic:\\n   \\n    vector<vector<int>>  child ;\\n    \\n    vector<int> locked;\\n    \\n    vector<int> par;\\n\\n    int n ; \\n    \\n    void findchild(int i ,int& flag )\\n    {\\n        if(locked[i]!=-1)\\n        {locked[i]=-1;\\n         flag =1 ;\\n        }\\n        \\n        for(auto x : child[i])\\n        {\\n            findchild(x,flag);\\n            \\n        }\\n        \\n        return  ; \\n        \\n    }\\n    \\n    bool findanc(int i)\\n    {\\n        if(i==-1)\\n            return true ;\\n        \\n        if(locked[i]!=-1)\\n            return false ;\\n        \\n        return findanc(par[i]) ;\\n        \\n        \\n    }\\n    \\n    LockingTree(vector<int>& parent) {\\n        \\n        n = parent.size() ;\\n        \\n        locked.resize(n,-1) ;\\n        \\n       \\n        child.resize(n) ;\\n       \\n        \\n        par = parent;\\n        \\n        for(int i=1 ; i<n ; i++)\\n        {   \\n            child[parent[i]].push_back(i) ;\\n        }\\n        \\n  \\n    }\\n    \\n    bool lock(int num, int user) {\\n        \\n        if(locked[num]==-1)\\n        {\\n            locked[num]=user;\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        \\n        if(locked[num]==user)\\n        {\\n            locked[num]=-1;\\n            return true;\\n        }\\n        else\\n            return false;\\n        \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        if(locked[num]!=-1)\\n            return false;\\n        \\n        if(findanc(par[num]))\\n        {\\n            int flag =0 ;\\n            \\n            findchild(num,flag) ;\\n            \\n            if(flag==1)\\n            {  locked[num]=user;\\n                return true ;\\n            }\\n            \\n        }\\n        \\n        \\n        return false;\\n        \\n        \\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1444322,
                "title": "java",
                "content": "```\\nclass LockingTree {\\n\\n    static Map<Integer, int[]> map;\\n    // int[] = <left, right, parent, lock (1/0), user>\\n    //          0.      1     2       3           4\\n    public LockingTree(int[] parent) {\\n        //System.out.println(\"cons in\");\\n        map = new HashMap<>();\\n        \\n        for(int i=0; i<parent.length; i++){\\n            int[] five = new int[]{-1, -1, -1 ,-1, -1};\\n            map.put(i, five);\\n        }\\n        \\n        for(int i=1; i<parent.length; i++){\\n            int node = i;\\n            int par = parent[i];\\n            \\n            map.get(node)[2] = par;\\n            if(map.get(par)[0] == -1){\\n                map.get(par)[0] = node;\\n            }else{\\n                map.get(par)[1] = node;\\n            }\\n            \\n        }\\n        \\n        // for(int i=0; i<parent.length; i++){\\n        //     System.out.println(\"node: \" + i);\\n        //     System.out.println(\"leftChild: \" + map.get(i)[0]);\\n        //     System.out.println(\"rightChild: \" + map.get(i)[1]);\\n        //     System.out.println(\"pareng: \" + map.get(i)[2]);\\n        // }\\n        \\n        //System.out.println(\"cons out\");\\n    }\\n    // int[] = <left, right, parent, lock (-1/0), user>\\n    //          0.      1     2       3           4\\n    \\n    public boolean lock(int num, int user) {\\n        //System.out.println(\"lock in\");\\n        if(map.get(num)[3] == -1){\\n            map.get(num)[3] = 0;\\n            map.get(num)[4] = user;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        //System.out.println(\"unlock in\");\\n        if(map.get(num)[4] == user){\\n            map.get(num)[3] = -1;\\n            map.get(num)[4] = -1;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n\\n        //System.out.println(\"upgrade in\");\\n        /*\\n        The node is unlocked,\\n        It has at least one locked descendant (by any user), and\\n        It does not have any locked ancestors.\\n        */\\n        \\n        // The node is unlocked,\\n        if(map.get(num)[3] != -1){\\n            return false;\\n        }\\n        \\n        //It does not have any locked ancestors.\\n        int now = num;\\n        while(now!=-1){\\n            //System.out.println(\"<>>>>\" + now);\\n            if(map.get(now)[3] != -1){\\n                return false;\\n            }\\n\\n            now = map.get(now)[2];\\n        }\\n        \\n        \\n        \\n        //It has at least one locked descendant (by any user), and\\n        \\n        List<Integer> locked = new ArrayList<>();\\n        parse(map.get(num)[0], locked);\\n        parse(map.get(num)[1], locked);\\n        \\n        if(locked.size() == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<locked.size(); i++){\\n            int node = locked.get(i);\\n            \\n            map.get(node)[3] = -1;\\n            map.get(node)[4] = -1;\\n        }\\n        \\n        lock(num, user);\\n        \\n        return true;\\n    }\\n    \\n    public void parse(int num, List<Integer> locked){\\n        if(num == -1){\\n            return;\\n        }\\n        \\n        if(map.get(num)[3] != -1){\\n            locked.add(num);\\n        }\\n        \\n        parse(map.get(num)[0], locked);\\n        parse(map.get(num)[1], locked);\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```\\n[Mazhar_MIK](https://leetcode.com/Mazhar_MIK/)",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n\\n    static Map<Integer, int[]> map;\\n    // int[] = <left, right, parent, lock (1/0), user>\\n    //          0.      1     2       3           4\\n    public LockingTree(int[] parent) {\\n        //System.out.println(\"cons in\");\\n        map = new HashMap<>();\\n        \\n        for(int i=0; i<parent.length; i++){\\n            int[] five = new int[]{-1, -1, -1 ,-1, -1};\\n            map.put(i, five);\\n        }\\n        \\n        for(int i=1; i<parent.length; i++){\\n            int node = i;\\n            int par = parent[i];\\n            \\n            map.get(node)[2] = par;\\n            if(map.get(par)[0] == -1){\\n                map.get(par)[0] = node;\\n            }else{\\n                map.get(par)[1] = node;\\n            }\\n            \\n        }\\n        \\n        // for(int i=0; i<parent.length; i++){\\n        //     System.out.println(\"node: \" + i);\\n        //     System.out.println(\"leftChild: \" + map.get(i)[0]);\\n        //     System.out.println(\"rightChild: \" + map.get(i)[1]);\\n        //     System.out.println(\"pareng: \" + map.get(i)[2]);\\n        // }\\n        \\n        //System.out.println(\"cons out\");\\n    }\\n    // int[] = <left, right, parent, lock (-1/0), user>\\n    //          0.      1     2       3           4\\n    \\n    public boolean lock(int num, int user) {\\n        //System.out.println(\"lock in\");\\n        if(map.get(num)[3] == -1){\\n            map.get(num)[3] = 0;\\n            map.get(num)[4] = user;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        //System.out.println(\"unlock in\");\\n        if(map.get(num)[4] == user){\\n            map.get(num)[3] = -1;\\n            map.get(num)[4] = -1;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n\\n        //System.out.println(\"upgrade in\");\\n        /*\\n        The node is unlocked,\\n        It has at least one locked descendant (by any user), and\\n        It does not have any locked ancestors.\\n        */\\n        \\n        // The node is unlocked,\\n        if(map.get(num)[3] != -1){\\n            return false;\\n        }\\n        \\n        //It does not have any locked ancestors.\\n        int now = num;\\n        while(now!=-1){\\n            //System.out.println(\"<>>>>\" + now);\\n            if(map.get(now)[3] != -1){\\n                return false;\\n            }\\n\\n            now = map.get(now)[2];\\n        }\\n        \\n        \\n        \\n        //It has at least one locked descendant (by any user), and\\n        \\n        List<Integer> locked = new ArrayList<>();\\n        parse(map.get(num)[0], locked);\\n        parse(map.get(num)[1], locked);\\n        \\n        if(locked.size() == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<locked.size(); i++){\\n            int node = locked.get(i);\\n            \\n            map.get(node)[3] = -1;\\n            map.get(node)[4] = -1;\\n        }\\n        \\n        lock(num, user);\\n        \\n        return true;\\n    }\\n    \\n    public void parse(int num, List<Integer> locked){\\n        if(num == -1){\\n            return;\\n        }\\n        \\n        if(map.get(num)[3] != -1){\\n            locked.add(num);\\n        }\\n        \\n        parse(map.get(num)[0], locked);\\n        parse(map.get(num)[1], locked);\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444288,
                "title": "simple-explaination-simulation-c",
                "content": "(1) create a descendent vector which store the child of a given node.\\n (2) locking and unlocking is simple ,we have to just check from \"locks\" vector\\n (3)  for upgrade  we will check whether ancestor is locked or not  with help of parent array. If no ancestor is locked then  we will check  descendent of given number with the help of \"desc\" vector.\\n (4)   if no descendent is locked then return false\\n (5)   If  greater than 0 descendent is locked then  apply lock for given num  and return false;\\n  \\n  Note : For better understanding go through the code and do  dry run once.\\n \\n\\n```\\nclass LockingTree {\\npublic:\\n    vector<int>locks;\\n    vector<int>p;\\n    vector<vector<int>>desc;\\n    \\n    LockingTree(vector<int>& parent) {\\n         int n=parent.size();\\n        vector<vector<int>>t(n);\\n         for(int i=0;i<n;i++){\\n                 if(parent[i]!=-1)\\n                       t[parent[i]].push_back(i);\\n               locks.push_back(-1);\\n         }\\n        p=parent;\\n        desc=t;\\n        \\n        \\n        \\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locks[num]==-1){\\n            locks[num]=user;\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool unlock(int num, int user) {\\n         if(locks[num]==user){\\n             locks[num]=-1;\\n             return true;\\n         }\\n        \\n        return false;\\n        \\n        \\n    }\\n    \\n    void  check_ancestor(int num,bool&check){\\n        if(locks[num]!=-1){\\n             check=false;\\n             return;\\n         }\\n         if(p[num]==-1)\\n             return;\\n         check_ancestor(p[num],check);\\n    }\\n    \\n    void fun(int num,int &count){\\n        \\n        for(auto& n:desc[num]){\\n            \\n            if(locks[n]!=-1){\\n                count++;\\n                locks[n]=-1;\\n                fun(n,count);\\n            }\\n            else{\\n                fun(n,count);\\n            }\\n                \\n        }\\n        return;\\n        \\n        \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        bool check_anc=true;\\n        check_ancestor(num,check_anc);\\n        if(check_anc){\\n            int count=0;\\n            fun(num,count);\\n            if(count>0){\\n                \\n                locks[num]=user;\\n                return true;\\n            }\\n               \\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<int>locks;\\n    vector<int>p;\\n    vector<vector<int>>desc;\\n    \\n    LockingTree(vector<int>& parent) {\\n         int n=parent.size();\\n        vector<vector<int>>t(n);\\n         for(int i=0;i<n;i++){\\n                 if(parent[i]!=-1)\\n                       t[parent[i]].push_back(i);\\n               locks.push_back(-1);\\n         }\\n        p=parent;\\n        desc=t;\\n        \\n        \\n        \\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locks[num]==-1){\\n            locks[num]=user;\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool unlock(int num, int user) {\\n         if(locks[num]==user){\\n             locks[num]=-1;\\n             return true;\\n         }\\n        \\n        return false;\\n        \\n        \\n    }\\n    \\n    void  check_ancestor(int num,bool&check){\\n        if(locks[num]!=-1){\\n             check=false;\\n             return;\\n         }\\n         if(p[num]==-1)\\n             return;\\n         check_ancestor(p[num],check);\\n    }\\n    \\n    void fun(int num,int &count){\\n        \\n        for(auto& n:desc[num]){\\n            \\n            if(locks[n]!=-1){\\n                count++;\\n                locks[n]=-1;\\n                fun(n,count);\\n            }\\n            else{\\n                fun(n,count);\\n            }\\n                \\n        }\\n        return;\\n        \\n        \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        bool check_anc=true;\\n        check_ancestor(num,check_anc);\\n        if(check_anc){\\n            int count=0;\\n            fun(num,count);\\n            if(count>0){\\n                \\n                locks[num]=user;\\n                return true;\\n            }\\n               \\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444248,
                "title": "c-dfs-o-n-accepted",
                "content": "\\n```\\nclass LockingTree {\\npublic:\\n    int par[3000];\\n    int n;\\n    unordered_map<int,int>vis;//for checking wheather ith node is locked or not. if equal to -1 that then it is unlocked\\n    vector<int>adj[3000];\\n    bool dfs(int node){// for cheking wheather given node has any descendent which is locked\\n        for(auto child: adj[node]){\\n            if(vis[child]!=-1){\\n                return true;\\n            }\\n            if(dfs(child))\\n                return true;\\n        }\\n        return false;\\n    }\\n    void dfs1(int node){// for unlocking all desendents for a given node\\n        \\n        for(auto child: adj[node]){\\n            if(vis[child]!=-1){\\n                vis[child]=-1;\\n            }\\n            dfs1(child);\\n        \\n        }\\n    }\\n    LockingTree(vector<int>& parent) {\\n        n=parent.size();\\n        for(int i=0;i<n;i++){//copying parent vector to par\\n            par[i]=parent[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            vis[i]=-1;//initially all are unlocked\\n        }\\n        for(int i=1;i<n;i++){//creating adjaceny list\\n            adj[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(vis[num]==-1){\\n            vis[num]=user;\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(vis[num]==user){\\n            vis[num]=-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(vis[num]!=-1){//if already locked return false\\n            return false;\\n        }\\n        if(dfs(num)){\\n            int node=num;\\n            \\n            /*checking wheather ancestor is locked or not*/\\n            while(par[node]!=-1){\\n                node=par[node];\\n                if(vis[node]!=-1){\\n                    return false;\\n                }\\n            }\\n            vis[num]=user;\\n            \\n            /*unlocking all descendets*/\\n            dfs1(num);\\n            return true;\\n            \\n        }\\n    \\n        return false;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    int par[3000];\\n    int n;\\n    unordered_map<int,int>vis;//for checking wheather ith node is locked or not. if equal to -1 that then it is unlocked\\n    vector<int>adj[3000];\\n    bool dfs(int node){// for cheking wheather given node has any descendent which is locked\\n        for(auto child: adj[node]){\\n            if(vis[child]!=-1){\\n                return true;\\n            }\\n            if(dfs(child))\\n                return true;\\n        }\\n        return false;\\n    }\\n    void dfs1(int node){// for unlocking all desendents for a given node\\n        \\n        for(auto child: adj[node]){\\n            if(vis[child]!=-1){\\n                vis[child]=-1;\\n            }\\n            dfs1(child);\\n        \\n        }\\n    }\\n    LockingTree(vector<int>& parent) {\\n        n=parent.size();\\n        for(int i=0;i<n;i++){//copying parent vector to par\\n            par[i]=parent[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            vis[i]=-1;//initially all are unlocked\\n        }\\n        for(int i=1;i<n;i++){//creating adjaceny list\\n            adj[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(vis[num]==-1){\\n            vis[num]=user;\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(vis[num]==user){\\n            vis[num]=-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(vis[num]!=-1){//if already locked return false\\n            return false;\\n        }\\n        if(dfs(num)){\\n            int node=num;\\n            \\n            /*checking wheather ancestor is locked or not*/\\n            while(par[node]!=-1){\\n                node=par[node];\\n                if(vis[node]!=-1){\\n                    return false;\\n                }\\n            }\\n            vis[num]=user;\\n            \\n            /*unlocking all descendets*/\\n            dfs1(num);\\n            return true;\\n            \\n        }\\n    \\n        return false;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444216,
                "title": "bfs-on-adj-list-c-solution",
                "content": "```\\nclass LockingTree {\\npublic:\\n    \\n    vector<int>parent;\\n    vector<int>lockStatus;\\n    vector<vector<int>>adj;                       // adj list to store the childs of a node\\n    int n;\\n    \\n    LockingTree(vector<int>& pt) {\\n        n=pt.size();\\n        parent=pt;\\n        lockStatus.assign(n,0);\\n        adj.resize(n);\\n        for(int i=1;i<n;++i){\\n            adj[parent[i]].push_back(i);\\n        }\\n        \\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(lockStatus[num]==0){\\n            lockStatus[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(lockStatus[num]==user){\\n            lockStatus[num]=0;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        bool op3=false;\\n        \\n\\t\\t//condition 1\\n        if(lockStatus[num]!=0) else return false;\\n        \\n\\t\\t// condition 2\\n        int paren=num;\\n        while(paren!=-1){\\n            if(lockStatus[paren]!=0) return false;\\n            paren=parent[paren];\\n        }\\n        \\n\\t\\t//condition 3\\n\\t\\t\\n\\t\\t// bfs for traversing the descendants\\n        queue<int>q;\\n        q.push(num);\\n        vector<int>des;\\n        while(!q.empty()){\\n            int top=q.front();\\n            q.pop();\\n            for(int i=0;i<adj[top].size();++i){\\n                q.push(adj[top][i]);\\n                if(lockStatus[adj[top][i]]!=0) op3=true;\\n                des.push_back(adj[top][i]);\\n            }\\n        }\\n        \\n        if(op3!=true) return false;\\n        else{\\n            for(int i=0;i<des.size();++i){\\n                lockStatus[des[i]]=0;             // unlocking descendants\\n            }\\n        }\\n        lockStatus[num]=user;\\n        return true;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    \\n    vector<int>parent;\\n    vector<int>lockStatus;\\n    vector<vector<int>>adj;                       // adj list to store the childs of a node\\n    int n;\\n    \\n    LockingTree(vector<int>& pt) {\\n        n=pt.size();\\n        parent=pt;\\n        lockStatus.assign(n,0);\\n        adj.resize(n);\\n        for(int i=1;i<n;++i){\\n            adj[parent[i]].push_back(i);\\n        }\\n        \\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(lockStatus[num]==0){\\n            lockStatus[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(lockStatus[num]==user){\\n            lockStatus[num]=0;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        bool op3=false;\\n        \\n\\t\\t//condition 1\\n        if(lockStatus[num]!=0) else return false;\\n        \\n\\t\\t// condition 2\\n        int paren=num;\\n        while(paren!=-1){\\n            if(lockStatus[paren]!=0) return false;\\n            paren=parent[paren];\\n        }\\n        \\n\\t\\t//condition 3\\n\\t\\t\\n\\t\\t// bfs for traversing the descendants\\n        queue<int>q;\\n        q.push(num);\\n        vector<int>des;\\n        while(!q.empty()){\\n            int top=q.front();\\n            q.pop();\\n            for(int i=0;i<adj[top].size();++i){\\n                q.push(adj[top][i]);\\n                if(lockStatus[adj[top][i]]!=0) op3=true;\\n                des.push_back(adj[top][i]);\\n            }\\n        }\\n        \\n        if(op3!=true) return false;\\n        else{\\n            for(int i=0;i<des.size();++i){\\n                lockStatus[des[i]]=0;             // unlocking descendants\\n            }\\n        }\\n        lockStatus[num]=user;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444190,
                "title": "in-contest-it-gave-tle-but-now-it-passes-please-someone-tell-admin",
                "content": "![image](https://assets.leetcode.com/users/images/7705d9be-4641-492c-98d2-1c53d5b43ef4_1630772299.2475176.png)\\n```c++\\nclass LockingTree {\\npublic:\\n    struct Info{\\n        unordered_set<int> par;\\n        int lock;\\n        Info(){\\n            this->lock = -1;\\n        }\\n    };\\n    unordered_map<int,Info*>m;\\n    vector<vector<int>>tree;\\n    unordered_map<int,vector<int>>leafs;\\n    void findleaf(int curr){\\n        \\n        for(auto &child: tree[curr]){\\n            findleaf(child);\\n            if(tree[child].size()==0) leafs[curr].push_back(child);\\n            for(auto &cl : leafs[child]){\\n                leafs[curr].push_back(cl);\\n            }\\n        }\\n    }\\n    void lockdfs(int curr,int p){\\n        m[curr]->par.insert(p);\\n        for(auto &child : tree[curr]){\\n            lockdfs(child,p);\\n        }\\n    }\\n    void unlockdfs(int curr,int p){\\n        if(m[curr]->par.find(p)==m[curr]->par.end()) return;\\n        m[curr]->par.erase(p);\\n        \\n        for(auto &child: tree[curr]){\\n            unlockdfs(child,p);\\n        }\\n    }\\n\\n    void unlockall(int curr,int p){\\n        m[curr]->lock = -1;\\n        m[curr]->par.insert(p);\\n        for(auto &child: tree[curr]){\\n            unlockall(child,p);\\n        }\\n    }\\n    LockingTree(vector<int>& parent) {\\n        tree.resize(parent.size()+1);\\n        m[0] = new Info();\\n        for(int i = 1;i<parent.size();i++){\\n            tree[parent[i]].push_back(i);\\n            Info *curr = new Info();\\n            m[i] = curr;\\n        }\\n        findleaf(0);\\n\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(m[num]->lock!=-1) return false;\\n        \\n        m[num]->lock = user;\\n        if(tree[num].size()==0) m[num]->par.insert(num);\\n        for(auto &child : tree[num]){\\n            lockdfs(child,num);\\n        }\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(m[num]->lock==-1) return false;\\n        if(m[num]->lock!=user) return false;\\n        m[num]->lock = -1;\\n        if(tree[num].size()==0) m[num]->par.erase(num);\\n        for(auto &child : tree[num]){\\n            unlockdfs(child,num);\\n        }\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(m[num]->lock!=-1) return false;\\n        if(m[num]->par.size()!=0) return false;\\n        bool flag = false;\\n        \\n        if(leafs[num].size()){\\n            for(auto &l : leafs[num]){\\n                if(m[l]->par.size() > 0){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(flag==false) return false;\\n        }\\n        else return false;\\n        m[num]->lock = num;\\n        for(auto &child: tree[num]){\\n            unlockall(child,num);\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n ```",
                "solutionTags": [],
                "code": "```c++\\nclass LockingTree {\\npublic:\\n    struct Info{\\n        unordered_set<int> par;\\n        int lock;\\n        Info(){\\n            this->lock = -1;\\n        }\\n    };\\n    unordered_map<int,Info*>m;\\n    vector<vector<int>>tree;\\n    unordered_map<int,vector<int>>leafs;\\n    void findleaf(int curr){\\n        \\n        for(auto &child: tree[curr]){\\n            findleaf(child);\\n            if(tree[child].size()==0) leafs[curr].push_back(child);\\n            for(auto &cl : leafs[child]){\\n                leafs[curr].push_back(cl);\\n            }\\n        }\\n    }\\n    void lockdfs(int curr,int p){\\n        m[curr]->par.insert(p);\\n        for(auto &child : tree[curr]){\\n            lockdfs(child,p);\\n        }\\n    }\\n    void unlockdfs(int curr,int p){\\n        if(m[curr]->par.find(p)==m[curr]->par.end()) return;\\n        m[curr]->par.erase(p);\\n        \\n        for(auto &child: tree[curr]){\\n            unlockdfs(child,p);\\n        }\\n    }\\n\\n    void unlockall(int curr,int p){\\n        m[curr]->lock = -1;\\n        m[curr]->par.insert(p);\\n        for(auto &child: tree[curr]){\\n            unlockall(child,p);\\n        }\\n    }\\n    LockingTree(vector<int>& parent) {\\n        tree.resize(parent.size()+1);\\n        m[0] = new Info();\\n        for(int i = 1;i<parent.size();i++){\\n            tree[parent[i]].push_back(i);\\n            Info *curr = new Info();\\n            m[i] = curr;\\n        }\\n        findleaf(0);\\n\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(m[num]->lock!=-1) return false;\\n        \\n        m[num]->lock = user;\\n        if(tree[num].size()==0) m[num]->par.insert(num);\\n        for(auto &child : tree[num]){\\n            lockdfs(child,num);\\n        }\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(m[num]->lock==-1) return false;\\n        if(m[num]->lock!=user) return false;\\n        m[num]->lock = -1;\\n        if(tree[num].size()==0) m[num]->par.erase(num);\\n        for(auto &child : tree[num]){\\n            unlockdfs(child,num);\\n        }\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(m[num]->lock!=-1) return false;\\n        if(m[num]->par.size()!=0) return false;\\n        bool flag = false;\\n        \\n        if(leafs[num].size()){\\n            for(auto &l : leafs[num]){\\n                if(m[l]->par.size() > 0){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(flag==false) return false;\\n        }\\n        else return false;\\n        m[num]->lock = num;\\n        for(auto &child: tree[num]){\\n            unlockall(child,num);\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1444119,
                "title": "easy-solution-c-graph-for-traversal-commentes-added",
                "content": "Upgrade :Made a graph for ancestors (directed) and desendants (directed) to check every time when an update is called is the given condition satisfied or not\\n        conditions:\\n             The node is unlocked,\\n             It has at least one locked descendant (by any user), and\\n             It does not have any locked ancestors\\nLock: made a map for lock so can check which user has locked that node and if is not locked unlocking it\\n\\nUnlock : seeing in the same map of lock whether it is locked or not \\n```\\nclass LockingTree\\n{\\npublic:\\n     unordered_map<int, int> m;\\n     unordered_map<int, vector<int>> asc;\\n     unordered_map<int, vector<int>> des;\\n\\n     // to unlock all the descendant\\n\\n     void unlodes(int num, int s)\\n     {\\n          if (num != s)\\n          {\\n               if (m.find(num) != m.end())\\n               {\\n                    m.erase(num);\\n               }\\n          }\\n          for (int i = 0; i < des[num].size(); i++)\\n          {\\n               unlodes(des[num][i], -1);\\n          }\\n     }\\n\\n     // to check whether one node in descendant is locked it return true when it find it\\n\\n     bool heldec(int n)\\n     {\\n          if (m.find(n) != m.end())\\n               return true;\\n          bool ans = false;\\n          for (int i = 0; i < des[n].size(); i++)\\n          {\\n               ans = ans || heldec(des[n][i]);\\n          }\\n          return ans;\\n     }\\n\\n     // to check whether all the nodes of ancestor is unlocked ..If a locked is found it return false\\n\\n     bool helasc(int n)\\n     {\\n          if (m.find(n) != m.end())\\n               return false;\\n          bool ans = true;\\n          for (int i = 0; i < asc[n].size(); i++)\\n          {\\n               ans = ans && helasc(asc[n][i]);\\n          }\\n          return ans;\\n     }\\n\\n     // making of ancestor and descendant graph\\n\\n     LockingTree(vector<int> &parent)\\n     {\\n          for (int i = 0; i < parent.size(); i++)\\n          {\\n               if (parent[i] == -1)\\n               {\\n                    continue;\\n               }\\n               else\\n               {\\n                    asc[i].push_back(parent[i]);\\n                    des[parent[i]].push_back(i);\\n               }\\n          }\\n     }\\n\\n     bool lock(int num, int user)\\n     {\\n          if (m.find(num) == m.end())\\n          {\\n               m[num] = user;\\n               return true;\\n          }\\n          else\\n               return false;\\n     }\\n\\n     bool unlock(int num, int user)\\n     {\\n          if (m.find(num) != m.end() && m[num] == user)\\n          {\\n               m.erase(num);\\n               return true;\\n          }\\n          else\\n               return false;\\n     }\\n\\n     bool upgrade(int num, int user)\\n     {\\n          if (m.find(num) != m.end())\\n               return false;\\n          else\\n          {\\n               if (!helasc(num))\\n               {\\n                    return false;\\n               }\\n               if (!heldec(num))\\n               {\\n                    return false;\\n               }\\n               m[num] = user;\\n               unlodes(num, num);\\n               return true;\\n          }\\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree\\n{\\npublic:\\n     unordered_map<int, int> m;\\n     unordered_map<int, vector<int>> asc;\\n     unordered_map<int, vector<int>> des;\\n\\n     // to unlock all the descendant\\n\\n     void unlodes(int num, int s)\\n     {\\n          if (num != s)\\n          {\\n               if (m.find(num) != m.end())\\n               {\\n                    m.erase(num);\\n               }\\n          }\\n          for (int i = 0; i < des[num].size(); i++)\\n          {\\n               unlodes(des[num][i], -1);\\n          }\\n     }\\n\\n     // to check whether one node in descendant is locked it return true when it find it\\n\\n     bool heldec(int n)\\n     {\\n          if (m.find(n) != m.end())\\n               return true;\\n          bool ans = false;\\n          for (int i = 0; i < des[n].size(); i++)\\n          {\\n               ans = ans || heldec(des[n][i]);\\n          }\\n          return ans;\\n     }\\n\\n     // to check whether all the nodes of ancestor is unlocked ..If a locked is found it return false\\n\\n     bool helasc(int n)\\n     {\\n          if (m.find(n) != m.end())\\n               return false;\\n          bool ans = true;\\n          for (int i = 0; i < asc[n].size(); i++)\\n          {\\n               ans = ans && helasc(asc[n][i]);\\n          }\\n          return ans;\\n     }\\n\\n     // making of ancestor and descendant graph\\n\\n     LockingTree(vector<int> &parent)\\n     {\\n          for (int i = 0; i < parent.size(); i++)\\n          {\\n               if (parent[i] == -1)\\n               {\\n                    continue;\\n               }\\n               else\\n               {\\n                    asc[i].push_back(parent[i]);\\n                    des[parent[i]].push_back(i);\\n               }\\n          }\\n     }\\n\\n     bool lock(int num, int user)\\n     {\\n          if (m.find(num) == m.end())\\n          {\\n               m[num] = user;\\n               return true;\\n          }\\n          else\\n               return false;\\n     }\\n\\n     bool unlock(int num, int user)\\n     {\\n          if (m.find(num) != m.end() && m[num] == user)\\n          {\\n               m.erase(num);\\n               return true;\\n          }\\n          else\\n               return false;\\n     }\\n\\n     bool upgrade(int num, int user)\\n     {\\n          if (m.find(num) != m.end())\\n               return false;\\n          else\\n          {\\n               if (!helasc(num))\\n               {\\n                    return false;\\n               }\\n               if (!heldec(num))\\n               {\\n                    return false;\\n               }\\n               m[num] = user;\\n               unlodes(num, num);\\n               return true;\\n          }\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014286,
                "title": "simple-dfs",
                "content": "DFS\\n\\n```\\nclass LockingTree {\\n    \\n    List<List<Integer>> tree = new ArrayList<>();\\n    Map<Integer, Integer> locked = new HashMap<>();\\n    int[] parent;\\n\\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        int n = parent.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            tree.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] != -1) {\\n                int from = parent[i];\\n                int to = i;\\n                tree.get(from).add(to);\\n            }\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (!locked.containsKey(num)) {\\n            locked.put(num, user);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (locked.containsKey(num) && locked.get(num) == user) {\\n            locked.remove(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (!locked.containsKey(num)) {\\n            if (hasDecendantLock(num) && !hasAnsetorLock(num)) {\\n                unlockDecendant(num);\\n                lock(num, user);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean hasAnsetorLock(int num) {\\n        while (num != -1) {\\n            if (locked.containsKey(num)) {\\n                return true;\\n            }\\n            num = parent[num];\\n        }\\n        return false;\\n    }\\n\\n    private boolean hasDecendantLock(int num) {\\n        if (locked.containsKey(num)) {\\n            return true;\\n        }\\n        for (int nei : tree.get(num)) {\\n            if (hasDecendantLock (nei)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void unlockDecendant(int num) {\\n        if (locked.containsKey(num)) {\\n            locked.remove(num);\\n        }\\n        for (int nei : tree.get(num)) {\\n            unlockDecendant (nei);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n    \\n    List<List<Integer>> tree = new ArrayList<>();\\n    Map<Integer, Integer> locked = new HashMap<>();\\n    int[] parent;\\n\\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        int n = parent.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            tree.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] != -1) {\\n                int from = parent[i];\\n                int to = i;\\n                tree.get(from).add(to);\\n            }\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (!locked.containsKey(num)) {\\n            locked.put(num, user);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (locked.containsKey(num) && locked.get(num) == user) {\\n            locked.remove(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (!locked.containsKey(num)) {\\n            if (hasDecendantLock(num) && !hasAnsetorLock(num)) {\\n                unlockDecendant(num);\\n                lock(num, user);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean hasAnsetorLock(int num) {\\n        while (num != -1) {\\n            if (locked.containsKey(num)) {\\n                return true;\\n            }\\n            num = parent[num];\\n        }\\n        return false;\\n    }\\n\\n    private boolean hasDecendantLock(int num) {\\n        if (locked.containsKey(num)) {\\n            return true;\\n        }\\n        for (int nei : tree.get(num)) {\\n            if (hasDecendantLock (nei)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void unlockDecendant(int num) {\\n        if (locked.containsKey(num)) {\\n            locked.remove(num);\\n        }\\n        for (int nei : tree.get(num)) {\\n            unlockDecendant (nei);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949539,
                "title": "easiest-c-solution",
                "content": "\\n# Code\\n```\\nclass LockingTree {\\npublic:\\n\\n    vector<vector<int>> children;\\n    vector<int> p;\\n    vector<bool> locked;\\n    vector<int> userid;\\n\\n    LockingTree(vector<int>& parent) {\\n        p = parent;\\n        children = vector<vector<int>>(parent.size());\\n        locked = vector<bool>(parent.size());\\n        userid = vector<int>(parent.size());\\n\\n        for(int i=1 ;i<parent.size(); i++){\\n            children[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n         if(locked[num]){\\n             return false;\\n         }\\n         locked[num] = true;\\n         userid[num] = user;\\n         return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n         if(!locked[num]){\\n             return false;\\n         }\\n         if(userid[num] != user){\\n             return false;\\n         }\\n         locked[num] = false;\\n         return true;\\n\\n    }\\n    \\n    bool are_ancestor_locked(int n){\\n        if(n == -1){\\n            return true;\\n        }\\n\\n        return !locked[n] && are_ancestor_locked(p[n]);\\n    }\\n\\n    bool atleast_onedescendant_locked(int n){\\n        bool res = locked[n];\\n        for(int child: children[n]){\\n            res |= atleast_onedescendant_locked(child);\\n        }\\n\\n        return res;\\n    }\\n    \\n    void unlock_all_descendant(int num){\\n         locked[num] = false;\\n         for(int child: children[num]){\\n             unlock_all_descendant(child);\\n         }\\n    }\\n\\n    bool upgrade(int num, int user) {\\n         if(!atleast_onedescendant_locked( num)){\\n             return false;\\n         }\\n         if(!are_ancestor_locked( num)){\\n             return false;\\n         }\\n         unlock_all_descendant(num);\\n         locked[num] = true;\\n         userid[num] = user;\\n         return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n\\n    vector<vector<int>> children;\\n    vector<int> p;\\n    vector<bool> locked;\\n    vector<int> userid;\\n\\n    LockingTree(vector<int>& parent) {\\n        p = parent;\\n        children = vector<vector<int>>(parent.size());\\n        locked = vector<bool>(parent.size());\\n        userid = vector<int>(parent.size());\\n\\n        for(int i=1 ;i<parent.size(); i++){\\n            children[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n         if(locked[num]){\\n             return false;\\n         }\\n         locked[num] = true;\\n         userid[num] = user;\\n         return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n         if(!locked[num]){\\n             return false;\\n         }\\n         if(userid[num] != user){\\n             return false;\\n         }\\n         locked[num] = false;\\n         return true;\\n\\n    }\\n    \\n    bool are_ancestor_locked(int n){\\n        if(n == -1){\\n            return true;\\n        }\\n\\n        return !locked[n] && are_ancestor_locked(p[n]);\\n    }\\n\\n    bool atleast_onedescendant_locked(int n){\\n        bool res = locked[n];\\n        for(int child: children[n]){\\n            res |= atleast_onedescendant_locked(child);\\n        }\\n\\n        return res;\\n    }\\n    \\n    void unlock_all_descendant(int num){\\n         locked[num] = false;\\n         for(int child: children[num]){\\n             unlock_all_descendant(child);\\n         }\\n    }\\n\\n    bool upgrade(int num, int user) {\\n         if(!atleast_onedescendant_locked( num)){\\n             return false;\\n         }\\n         if(!are_ancestor_locked( num)){\\n             return false;\\n         }\\n         unlock_all_descendant(num);\\n         locked[num] = true;\\n         userid[num] = user;\\n         return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922161,
                "title": "99-euler-tour-solution-dfs-flattening-of-tree",
                "content": "I was looking for the Euler Tour solution,Couldn\\'t Find it so writed up my own, upvote if found helpful\\n\\n```\\nclass LockingTree {\\npublic:\\n    vector<int> lt,start,exitt,locker,parentt;\\n    int timer=0;\\n    //creating the linear tree\\n    void dfs(int node,vector<int> adj[])\\n    {\\n        start[node]=timer;\\n        lt[timer++]=node;\\n        for(auto&child:adj[node])\\n            dfs(child,adj);\\n        exitt[node]=timer;\\n        lt[timer++]=node;\\n    }\\n    LockingTree(vector<int>& parent) {\\n        int n=parent.size();\\n        lt.resize(4*n);\\n        start.resize(n);\\n        exitt.resize(n);\\n        parentt=parent;\\n        locker.resize(n,-1);\\n        vector<int> adj[n];\\n        for(int i=1;i<n;i++)\\n            adj[parent[i]].push_back(i);\\n        dfs(0,adj);\\n    }\\n    \\n    bool lock(int num, int user) {\\n       if(locker[num]==-1)\\n       {\\n           locker[num]=user;\\n           return true;\\n       }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locker[num]==user)\\n        {\\n            locker[num]=-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(locker[num]!=-1 && locker[num]!=user) return false;\\n        bool lockeddesc=false;\\n        bool lockedansc=false;\\n        \\n        int l=start[num];\\n        int r=exitt[num];\\n        int templ=l;\\n        int tempr=r;\\n        l++;r--;\\n        //here checking if there is any descendant  or (any node in the subtree of this num) that has been locked\\n        while(l<=r)\\n        {\\n            if(locker[lt[l]]!=-1){ lockeddesc=true; break;}\\n            l++;\\n        }\\n        l=templ;\\n        r=tempr;\\n        if(lockeddesc==false) return false;\\n        int parnode=parentt[num];\\n       \\n        //here checking if there is any ancestors  that has been locked\\n        while(parnode!=-1) // if it reached parent of root node that is -1 break;\\n        {\\n            if(locker[parnode]!=-1)\\n            {\\n                lockedansc=true;\\n                break;\\n            }\\n            parnode=parentt[parnode];\\n        }\\n        \\n    \\n        if(lockeddesc && !lockedansc) // if condition satisfies\\n        {\\n            l++;\\n            r--; \\n            while(l<=r){    // marking all descendant unlocked \\n                locker[lt[l]]=-1;\\n                l++;\\n            }\\n            locker[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<int> lt,start,exitt,locker,parentt;\\n    int timer=0;\\n    //creating the linear tree\\n    void dfs(int node,vector<int> adj[])\\n    {\\n        start[node]=timer;\\n        lt[timer++]=node;\\n        for(auto&child:adj[node])\\n            dfs(child,adj);\\n        exitt[node]=timer;\\n        lt[timer++]=node;\\n    }\\n    LockingTree(vector<int>& parent) {\\n        int n=parent.size();\\n        lt.resize(4*n);\\n        start.resize(n);\\n        exitt.resize(n);\\n        parentt=parent;\\n        locker.resize(n,-1);\\n        vector<int> adj[n];\\n        for(int i=1;i<n;i++)\\n            adj[parent[i]].push_back(i);\\n        dfs(0,adj);\\n    }\\n    \\n    bool lock(int num, int user) {\\n       if(locker[num]==-1)\\n       {\\n           locker[num]=user;\\n           return true;\\n       }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locker[num]==user)\\n        {\\n            locker[num]=-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(locker[num]!=-1 && locker[num]!=user) return false;\\n        bool lockeddesc=false;\\n        bool lockedansc=false;\\n        \\n        int l=start[num];\\n        int r=exitt[num];\\n        int templ=l;\\n        int tempr=r;\\n        l++;r--;\\n        //here checking if there is any descendant  or (any node in the subtree of this num) that has been locked\\n        while(l<=r)\\n        {\\n            if(locker[lt[l]]!=-1){ lockeddesc=true; break;}\\n            l++;\\n        }\\n        l=templ;\\n        r=tempr;\\n        if(lockeddesc==false) return false;\\n        int parnode=parentt[num];\\n       \\n        //here checking if there is any ancestors  that has been locked\\n        while(parnode!=-1) // if it reached parent of root node that is -1 break;\\n        {\\n            if(locker[parnode]!=-1)\\n            {\\n                lockedansc=true;\\n                break;\\n            }\\n            parnode=parentt[parnode];\\n        }\\n        \\n    \\n        if(lockeddesc && !lockedansc) // if condition satisfies\\n        {\\n            l++;\\n            r--; \\n            while(l<=r){    // marking all descendant unlocked \\n                locker[lt[l]]=-1;\\n                l++;\\n            }\\n            locker[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864507,
                "title": "very-simple-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(log(n))+O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LockingTree {\\npublic:\\n    vector<int>par;\\n    vector<vector<int>>child;\\n    vector<int>lc;\\n    int n;\\n    LockingTree(vector<int>& parent) {\\n        n=parent.size();\\n        child.resize(n);\\n        lc.resize(n,-1);\\n        par=parent;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(par[i]==-1)continue;\\n            child[par[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        // if(lc[num]!=-1)return 0;\\n        if(lc[num]==-1)\\n         {\\n             lc[num]=user;\\n             return 1;\\n         }\\n         return 0;\\n\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        // if(lc[num]==-1)return 1;\\n        if(lc[num]==user)\\n        {\\n            lc[num]=-1;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    bool ancestor(int num)\\n    {\\n        if(num==-1)return 0;\\n        if(lc[num]!=-1)return 1;\\n       return ancestor(par[num]);\\n    }\\n    bool decen(int num)\\n    {\\n        bool f=0;\\n        for(auto i:child[num])\\n        {\\n            f|=decen(i)|(lc[i]!=-1);\\n            lc[i]=-1;\\n        }\\n        return f;\\n    }\\n    bool upgrade(int num, int user) {\\n        if(ancestor(num))\\n        return 0;\\n\\n        if(!decen(num))\\n        return 0;\\n\\n        lc[num]=user;\\n        return 1;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<int>par;\\n    vector<vector<int>>child;\\n    vector<int>lc;\\n    int n;\\n    LockingTree(vector<int>& parent) {\\n        n=parent.size();\\n        child.resize(n);\\n        lc.resize(n,-1);\\n        par=parent;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(par[i]==-1)continue;\\n            child[par[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        // if(lc[num]!=-1)return 0;\\n        if(lc[num]==-1)\\n         {\\n             lc[num]=user;\\n             return 1;\\n         }\\n         return 0;\\n\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        // if(lc[num]==-1)return 1;\\n        if(lc[num]==user)\\n        {\\n            lc[num]=-1;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    bool ancestor(int num)\\n    {\\n        if(num==-1)return 0;\\n        if(lc[num]!=-1)return 1;\\n       return ancestor(par[num]);\\n    }\\n    bool decen(int num)\\n    {\\n        bool f=0;\\n        for(auto i:child[num])\\n        {\\n            f|=decen(i)|(lc[i]!=-1);\\n            lc[i]=-1;\\n        }\\n        return f;\\n    }\\n    bool upgrade(int num, int user) {\\n        if(ancestor(num))\\n        return 0;\\n\\n        if(!decen(num))\\n        return 0;\\n\\n        lc[num]=user;\\n        return 1;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856217,
                "title": "operations-on-tree-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass LockingTree {\\npublic:\\n    LockingTree(vector<int>& p) : parent(p) {\\n        for (int i = 0; i < parent.size(); i++) \\n            children[parent[i]].push_back(i);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (locked_by.find(num) != locked_by.end()) return false;\\n        locked_by[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (locked_by.find(num) == locked_by.end()) return false;\\n        if (locked_by[num] != user) return false;\\n        locked_by.erase(num);\\n        return true;\\n    }\\n    \\n    bool is_locked_child(int num) {\\n        bool flag = false;\\n        if (locked_by.find(num) != locked_by.end()) flag = true;\\n        for (auto ch : children[num]) flag |= is_locked_child(ch);\\n        return flag;\\n    }\\n    \\n    bool is_locked_parent(int num) {\\n        if (num == -1) return false;\\n        if (locked_by.find(num) != locked_by.end()) return true;\\n        return is_locked_parent(parent[num]);\\n    }\\n    \\n    void unlock_descendants(int num) {\\n        for (auto ch : children[num]) {\\n            locked_by.erase(ch);\\n            unlock_descendants(ch);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (locked_by.find(num) != locked_by.end()) return false;\\n        if (is_locked_child(num) && !is_locked_parent(parent[num])) {\\n            unlock_descendants(num);\\n            locked_by[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int> > children;\\n    unordered_map<int, int> locked_by;\\n    vector<int> parent;\\n};\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Tree"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    LockingTree(vector<int>& p) : parent(p) {\\n        for (int i = 0; i < parent.size(); i++) \\n            children[parent[i]].push_back(i);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (locked_by.find(num) != locked_by.end()) return false;\\n        locked_by[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (locked_by.find(num) == locked_by.end()) return false;\\n        if (locked_by[num] != user) return false;\\n        locked_by.erase(num);\\n        return true;\\n    }\\n    \\n    bool is_locked_child(int num) {\\n        bool flag = false;\\n        if (locked_by.find(num) != locked_by.end()) flag = true;\\n        for (auto ch : children[num]) flag |= is_locked_child(ch);\\n        return flag;\\n    }\\n    \\n    bool is_locked_parent(int num) {\\n        if (num == -1) return false;\\n        if (locked_by.find(num) != locked_by.end()) return true;\\n        return is_locked_parent(parent[num]);\\n    }\\n    \\n    void unlock_descendants(int num) {\\n        for (auto ch : children[num]) {\\n            locked_by.erase(ch);\\n            unlock_descendants(ch);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (locked_by.find(num) != locked_by.end()) return false;\\n        if (is_locked_child(num) && !is_locked_parent(parent[num])) {\\n            unlock_descendants(num);\\n            locked_by[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int> > children;\\n    unordered_map<int, int> locked_by;\\n    vector<int> parent;\\n};\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788200,
                "title": "o-n-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse hashmap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- init()\\n    - store the parent list in self.parent\\n    - create a hashmap to store the locked nodes. Here hashmap with a default value of None for the key is used to handle missing keys and avoid the check for keys (i.e to check if a key exists)\\n    key = node, value = user\\n    - create a hashmap to store child nodes of a node\\n    key = node, value = list of child nodes\\n    - iterate the parent list and map the parent value as the key and its index as the child node \\n- lock()\\n    - return false if the node (num) is already locked i.e the value in hashmap is not none\\n    - else, lock the node by updating the value of the node to user and return true\\n- unlock()\\n    - return false if the node (num) is not locked by the user\\n    - else, unlock the node and return true\\n- upgrade()\\n    - if the node is not locked, its ancestor is also not locked and at least one child is locked, then unlock the children, lock the node, and return true\\n    - else return false\\n    to check for locked ancestors, and locked children and to unlock children, separate internal functions are defined\\n- _is_lock_parent()\\n    - find the parent of the node (num)\\n    - loop to check all ancestors\\n        - return true, if parent is locked\\n        - else update the parent\\n    - return false if no locked ancestor is found\\n- _is_lock_child()\\n    - use a stack to perform DFS and find the child nodes\\n    - return true if any of the child nodes are locked, else false\\n- _unlock_children()\\n    - use a stack to perform DFS and find the child nodes\\n    - unlock the child node if locked\\n\\n\\n# Complexity\\n- Time complexity:\\n    - init() O(n)  \\u2192 only once i.e during object creation\\n    - lock() O(1)\\n    - unlock O(1)\\n    - upgrade O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - init() O(n)  \\u2192 only once i.e during object creation\\n    - lock() O(1)\\n    - unlock O(1)\\n    - upgrade O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked = defaultdict(lambda: None)\\n        self.child = defaultdict(list)\\n        for i, v in enumerate(parent):\\n            self.child[v].append(i)\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]:\\n            return False\\n        self.locked[num] = user\\n        return True\\n        \\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] != user:\\n            return False\\n        self.locked[num] = None\\n        return True\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        if not self.locked[num] and not self._is_locked_parent(num) and self._is_locked_child(num):\\n            self._unlock_children(num)\\n            self.locked[num] = user\\n            return True\\n        return False\\n    \\n    def _is_locked_parent(self, num: int) -> bool:\\n        parent = self.parent[num]\\n        while parent != -1:\\n            if self.locked[parent]:\\n                return True\\n            parent = self.parent[parent]\\n        return False\\n    \\n    def _is_locked_child(self, num: int) -> bool:\\n        stack = [num]\\n        while stack:\\n            node = stack.pop()\\n            if self.locked[node]:\\n                return True\\n            stack.extend(self.child[node])\\n        return False\\n\\n    def _unlock_children(self, num: int):\\n        stack = [num]\\n        while stack:\\n            node = stack.pop()\\n            if self.locked[node]:\\n                self.locked[node] = None\\n            stack.extend(self.child[node])\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked = defaultdict(lambda: None)\\n        self.child = defaultdict(list)\\n        for i, v in enumerate(parent):\\n            self.child[v].append(i)\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]:\\n            return False\\n        self.locked[num] = user\\n        return True\\n        \\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] != user:\\n            return False\\n        self.locked[num] = None\\n        return True\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        if not self.locked[num] and not self._is_locked_parent(num) and self._is_locked_child(num):\\n            self._unlock_children(num)\\n            self.locked[num] = user\\n            return True\\n        return False\\n    \\n    def _is_locked_parent(self, num: int) -> bool:\\n        parent = self.parent[num]\\n        while parent != -1:\\n            if self.locked[parent]:\\n                return True\\n            parent = self.parent[parent]\\n        return False\\n    \\n    def _is_locked_child(self, num: int) -> bool:\\n        stack = [num]\\n        while stack:\\n            node = stack.pop()\\n            if self.locked[node]:\\n                return True\\n            stack.extend(self.child[node])\\n        return False\\n\\n    def _unlock_children(self, num: int):\\n        stack = [num]\\n        while stack:\\n            node = stack.pop()\\n            if self.locked[node]:\\n                self.locked[node] = None\\n            stack.extend(self.child[node])\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731733,
                "title": "python-easy-solution-explained-with-comments",
                "content": "# Intuition\\nApply Brute Force and just do whatever the question says :)\\n\\n# Complexity\\n- Time complexity:\\nO(n**2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.p = parent\\n        self.child = defaultdict(list)\\n        for i in range(len(parent)):\\n            self.child[parent[i]].append(i)\\n        self.lock_list = [-1] * len(parent)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.lock_list[num] == -1:\\n            self.lock_list[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.lock_list[num] == user:\\n            self.lock_list[num] = -1\\n            return True\\n        return False\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        #Check if node is unlocked\\n        if self.lock_list[num] != -1:\\n            return False\\n        #Check if no parent is locked\\n        parent = self.p[num]\\n        while parent != -1:\\n            if self.lock_list[parent] != -1:\\n                return False\\n            parent = self.p[parent]\\n        #Check if atleast one child is locked\\n        q = deque(self.child[num])\\n        lockedChildren = []\\n        while q:\\n            node = q.popleft()\\n            if self.lock_list[node] != -1:\\n                lockedChildren.append(node)\\n            for new_child in self.child[node]:\\n                q.append(new_child)\\n        if len(lockedChildren) == 0:\\n            return False\\n        #Upgrade\\n        self.lock_list[num] = user\\n        for i in lockedChildren:\\n            self.lock_list[i] = -1\\n        return True\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.p = parent\\n        self.child = defaultdict(list)\\n        for i in range(len(parent)):\\n            self.child[parent[i]].append(i)\\n        self.lock_list = [-1] * len(parent)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.lock_list[num] == -1:\\n            self.lock_list[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.lock_list[num] == user:\\n            self.lock_list[num] = -1\\n            return True\\n        return False\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        #Check if node is unlocked\\n        if self.lock_list[num] != -1:\\n            return False\\n        #Check if no parent is locked\\n        parent = self.p[num]\\n        while parent != -1:\\n            if self.lock_list[parent] != -1:\\n                return False\\n            parent = self.p[parent]\\n        #Check if atleast one child is locked\\n        q = deque(self.child[num])\\n        lockedChildren = []\\n        while q:\\n            node = q.popleft()\\n            if self.lock_list[node] != -1:\\n                lockedChildren.append(node)\\n            for new_child in self.child[node]:\\n                q.append(new_child)\\n        if len(lockedChildren) == 0:\\n            return False\\n        #Upgrade\\n        self.lock_list[num] = user\\n        for i in lockedChildren:\\n            self.lock_list[i] = -1\\n        return True\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718275,
                "title": "java-clear-and-concise-recursive-unlocking-of-locks-w-comments",
                "content": "```Java []\\nclass LockingTree {\\n    \\n    private final List<List<Integer>> adj;\\n    private int[] lockedBy;\\n    private final int[] parent;\\n\\n    public LockingTree(int[] parent) {\\n        adj = new ArrayList<>();\\n        lockedBy = new int[parent.length];\\n        Arrays.fill(lockedBy, -1);\\n        this.parent = parent;\\n        for (int i = 0; i < parent.length; ++i) adj.add(new ArrayList<>());\\n        for (int i = 1; i < parent.length; ++i) adj.get(parent[i]).add(i);\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (lockedBy[num] != -1) return false;\\n        lockedBy[num] = user;\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (lockedBy[num] != user) return false;\\n        lockedBy[num] = -1;\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        // we need to check following 3 conditions\\n        // node is unlocked                     ->  lockedBy[num] == -1\\n        // has atleast one locked descendant    ->  hasLockedDescendant(num)\\n        // doesn\\'t have any locked ancestor     ->  hasLockedAncestor(num)\\n        if (lockedBy[num] != -1 || !hasLockedDescendant(num) || hasLockedAncestor(num)) return false;\\n        lockedBy[num] = user;\\n        unlockDescendants(num); // unlock all it\\'s descendants\\n        return true;\\n    }\\n\\n    private boolean hasLockedDescendant(int num) {\\n        for (int child : adj.get(num))\\n            if (lockedBy[child] != -1 || hasLockedDescendant(child)) return true;\\n        return false;\\n    }\\n\\n    private boolean hasLockedAncestor(int num) {\\n        while (num != -1) {\\n            if (lockedBy[num] != -1) return true;\\n            num = parent[num];\\n        }\\n        return false;\\n    }\\n\\n    private void unlockDescendants(int num) {\\n        for (int child : adj.get(num)) {\\n            lockedBy[child] = -1;\\n            unlockDescendants(child);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Design",
                    "Recursion"
                ],
                "code": "```Java []\\nclass LockingTree {\\n    \\n    private final List<List<Integer>> adj;\\n    private int[] lockedBy;\\n    private final int[] parent;\\n\\n    public LockingTree(int[] parent) {\\n        adj = new ArrayList<>();\\n        lockedBy = new int[parent.length];\\n        Arrays.fill(lockedBy, -1);\\n        this.parent = parent;\\n        for (int i = 0; i < parent.length; ++i) adj.add(new ArrayList<>());\\n        for (int i = 1; i < parent.length; ++i) adj.get(parent[i]).add(i);\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (lockedBy[num] != -1) return false;\\n        lockedBy[num] = user;\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (lockedBy[num] != user) return false;\\n        lockedBy[num] = -1;\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        // we need to check following 3 conditions\\n        // node is unlocked                     ->  lockedBy[num] == -1\\n        // has atleast one locked descendant    ->  hasLockedDescendant(num)\\n        // doesn\\'t have any locked ancestor     ->  hasLockedAncestor(num)\\n        if (lockedBy[num] != -1 || !hasLockedDescendant(num) || hasLockedAncestor(num)) return false;\\n        lockedBy[num] = user;\\n        unlockDescendants(num); // unlock all it\\'s descendants\\n        return true;\\n    }\\n\\n    private boolean hasLockedDescendant(int num) {\\n        for (int child : adj.get(num))\\n            if (lockedBy[child] != -1 || hasLockedDescendant(child)) return true;\\n        return false;\\n    }\\n\\n    private boolean hasLockedAncestor(int num) {\\n        while (num != -1) {\\n            if (lockedBy[num] != -1) return true;\\n            num = parent[num];\\n        }\\n        return false;\\n    }\\n\\n    private void unlockDescendants(int num) {\\n        for (int child : adj.get(num)) {\\n            lockedBy[child] = -1;\\n            unlockDescendants(child);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703284,
                "title": "beats-100-tc-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LockingTree:\\n    def __init__(self, parent: List[int]):\\n        self.tree=defaultdict(list)\\n        for i in range(1,len(parent)):\\n            self.tree[parent[i]].append(i) \\n        self.locks=[0]*len(parent)\\n\\n        def dfs(i):\\n            for j in self.tree[i]:\\n                ances.append(i)\\n                dfs(j)\\n                ances.pop()\\n            self.ances[i]=ances.copy()\\n        self.ances=[0]*len(parent)\\n        ances=[]\\n        dfs(0)\\n\\n        def bfs(i):\\n            child=[]\\n            for j in self.tree[i]:\\n                child.extend(bfs(j).copy())\\n\\n            self.child[i]=child.copy()\\n            child.append(i)\\n            return child\\n        \\n        self.child=[0]*len(parent)\\n        bfs(0)\\n        \\n            \\n\\n\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locks[num]:return False\\n        self.locks[num]=user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locks[num]!=user:return False\\n        self.locks[num]=0\\n        return True\\n        \\n    \\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locks[num]:return False\\n        for i in self.ances[num]:\\n            if self.locks[i]:return False\\n        got =False\\n        for j in self.child[num]:\\n            if self.locks[j]:\\n                got=True\\n                self.locks[j]=0\\n        if not got:return False\\n        self.locks[num]=user\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass LockingTree:\\n    def __init__(self, parent: List[int]):\\n        self.tree=defaultdict(list)\\n        for i in range(1,len(parent)):\\n            self.tree[parent[i]].append(i) \\n        self.locks=[0]*len(parent)\\n\\n        def dfs(i):\\n            for j in self.tree[i]:\\n                ances.append(i)\\n                dfs(j)\\n                ances.pop()\\n            self.ances[i]=ances.copy()\\n        self.ances=[0]*len(parent)\\n        ances=[]\\n        dfs(0)\\n\\n        def bfs(i):\\n            child=[]\\n            for j in self.tree[i]:\\n                child.extend(bfs(j).copy())\\n\\n            self.child[i]=child.copy()\\n            child.append(i)\\n            return child\\n        \\n        self.child=[0]*len(parent)\\n        bfs(0)\\n        \\n            \\n\\n\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locks[num]:return False\\n        self.locks[num]=user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locks[num]!=user:return False\\n        self.locks[num]=0\\n        return True\\n        \\n    \\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locks[num]:return False\\n        for i in self.ances[num]:\\n            if self.locks[i]:return False\\n        got =False\\n        for j in self.child[num]:\\n            if self.locks[j]:\\n                got=True\\n                self.locks[j]=0\\n        if not got:return False\\n        self.locks[num]=user\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593979,
                "title": "c-true-o-log-n-time-with-fenwick-tree",
                "content": "```c++\\ntemplate <typename T, typename V = std::vector<T>>\\nclass FenwickTree {\\n    // One-based Fenwick tree with a twist (A[0] saves nums[0])\\n    V A;\\n    public:\\n    typedef typename V::size_type size_type;\\n    typedef typename V::value_type value_type;\\n    private:\\n    static const size_type LSB(const size_type i) {\\n        return i & -i;\\n    }\\n    public:\\n    FenwickTree(size_type size = 0):A(size) {\\n    }\\n\\n    // Returns the sum of the first i elements (indices 0 to i)\\n    // Equivalent to range_sum(0, i)\\n    T prefix_sum(size_type i) const {\\n        T sum = A[0];\\n        for (; i != 0; i -= LSB(i))\\n            sum += A[i];\\n        return sum;\\n    }\\n\\n    // Add delta to element with index i (zero-based)\\n    void add(size_type i, T delta) {\\n        if (i == 0) {\\n            A[0] += delta;\\n            return;\\n        }\\n        for (; i < A.size(); i+= LSB(i))\\n            A[i] += delta;\\n    }\\n};\\nclass LockingTree {\\n    // overral space = O(size), overral time = O(size + calls^2 log size) \\n    vector<unsigned> node_idx;\\n    vector<unsigned> node_end;\\n\\t// i = node_idx[u] is first index of subtree of node u\\n\\t// e = node_end[i] is one past last index of subtree of node u\\n\\t// node u has index node_idx[u],\\n\\t// all descendants of u has indexes node_idx[u] + 1, ... , node_end[i] - 1 \\n    map<unsigned, int> locks; // index of locked node -> user\\n    FenwickTree<int> ft;\\n    // return index of one past last descendant\\n    static unsigned dfs(unsigned u, unsigned i, vector<unsigned> &node_idx, vector<unsigned> &node_end, const vector<vector<unsigned>> &adj) {\\n        auto end = i + 1;\\n        node_idx[u] = i;\\n        for (auto v: adj[u])\\n            end = dfs(v, end, node_idx, node_end, adj);\\n        node_end[i] = end;\\n        return end;\\n    }\\npublic:\\n    LockingTree(vector<int>& parent)\\n\\t    :node_idx(parent.size()),\\n\\t\\t node_end(parent.size()),\\n\\t\\t ft(parent.size() + 1)\\n    { // O(size) space, O(size) time\\n        const auto n = parent.size();\\n        vector<vector<unsigned>> adj(n); // O(n) space\\n        for (unsigned i = 1; i < n; ++i)\\n            adj[parent[i]].push_back(i);\\n        dfs(0, 0, node_idx, node_end, adj);\\n    }\\n    \\n    bool lock(int num, int user) { // O(log size)\\n        auto ni = node_idx[num];\\n        auto ret = locks.emplace(ni, user).second;\\n        if (ret) {\\n            auto ei = node_end[ni];\\n            ft.add(ni, +1);\\n            ft.add(ei, -1);\\n        }\\n        return ret;\\n    }\\n    \\n    bool unlock(int num, int user) { // O(log size) \\n        auto ni = node_idx[num];\\n        auto l = locks.find(ni);\\n        if (l == locks.end() || l->second != user)\\n            return false;\\n        locks.erase(l);\\n        auto ei = node_end[ni];\\n        ft.add(ei, +1);\\n        ft.add(ni, -1);\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n\\t    // single operation time is O(upgraded locks * log size), ammortized time is O(log size)\\n\\t    // (as no lock can be upgraded twice)\\n        auto ni = node_idx[num];\\n        auto ei = node_end[ni];\\n        if (ft.prefix_sum(ni)) // O(log size)\\n            return false;\\n        auto v = locks.lower_bound(ni + 1); // O(log size)\\n        if (v == locks.end() || v->first >= ei)\\n            return false;\\n        while (v != locks.end() && v->first < ei) {\\n            auto vni = v->first;\\n            auto vei = node_end[vni];\\n            ft.add(vei, +1);\\n            ft.add(vni, -1);\\n            v = locks.erase(v);\\n        }\\n        locks[ni] = user;\\n        ft.add(ni, +1);\\n        ft.add(ei, -1);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n ```\\nReindex nodes so that all children are listed after parent, then use fenwick tree to check if any of parents are locked and ordered map to enumerate all locked descendants.\\n`lock()` and `unlock()` are (trivially) `O(log n)`\\n`upgrade()` is `O(number of upgraded locks*log n)`, but ammortized cost is `O(log size)` (as no lock will be upgraded twice);\\nThis works in `O(log n)` even on degenerate trees (vines).\\n\\nP.S. And here completely optimized constructor with space-efficient graph representation conversion and iterative dfs with explicit stack:\\n```c++\\n    LockingTree(vector<int>& parent)\\n        : node_idx(parent.size()), node_end(parent.size()), ft(parent.size())\\n    { // O(n) time\\n        const auto n = parent.size();\\n        vector<unsigned> cpos(n + 1);\\n        vector<unsigned> adj(n - 1); // tree always has (n - 1) edges\\n        for (unsigned i = 1; i < n; ++i)\\n            ++cpos[parent[i]];\\n        // at this point, cpos[u] is a number of children of u\\n        for (unsigned i = 1, pos = cpos[0]; i <= n; ++i)\\n            cpos[i] = pos += cpos[i];\\n        // at this point, cpos[u] points to one after last child of u\\n        // (and cpos[n] is same as cpos[n - 1], i.e. one past last child of n - 1)\\n        assert(cpos[n] == adj.size());\\n        for (unsigned i = 1; i < n; ++i)\\n            adj[--cpos[parent[i]]] = i;\\n        // at this point, cpos[u] points to first child of u,\\n        // and cpos[u + 1] points to one past last child of u;\\n        // that is, children of node u are adj[cpos[u]:cpos[u + 1]]\\n\\t\\t\\n\\t\\t// dfs with explicit stack\\n        unsigned node = 0;\\n        unsigned idx = 0;\\n        unsigned end = 0;\\n        vector<pair<unsigned, unsigned>> stack; // max stack depth = O(n)\\n        for (;;) {\\n            if (idx == 0)\\n                node_idx[node] = end++;\\n            const auto cpos_node = cpos[node];\\n            if (cpos_node + idx == cpos[node + 1]) {\\n                node_end[node_idx[node]] = end;\\n                if (stack.empty())\\n                    break;\\n                tie(node, idx) = stack.back();\\n                stack.pop_back();\\n                continue;\\n            }\\n            stack.emplace_back(node, idx + 1);\\n            node = adj[cpos_node + idx];\\n            idx = 0;\\n        }\\n    }\\n```\\n(both original and optimized variants are O(n) time / O (n) space, but optimized variant has about twice lower overhead)\\nP.P.S Same in Java (faster than 100%, smaller than 99%):\\n```java\\nimport java.util.NavigableMap;\\nclass FenwickTree {\\n    // One-based Fenwick tree with a twist (A[0] saves nums[0])\\n    private int[] A;\\n    FenwickTree(int size) {\\n        A = new int[size];\\n    }\\n    private static int LSB(int i) {\\n        return i & -i;\\n    }\\n\\n    // Returns the sum of the first i elements (indices 0 to i)\\n    // Equivalent to range_sum(0, i)\\n    public int prefix_sum(int i) {\\n        int sum = A[0];\\n        for (; i != 0; i -= LSB(i))\\n            sum += A[i];\\n        return sum;\\n    }\\n\\n    // Add delta to element with index i (zero-based)\\n    void add(int i, int delta) {\\n        if (i == 0) {\\n            A[0] += delta;\\n            return;\\n        }\\n        for (; i < A.length; i += LSB(i))\\n            A[i] += delta;\\n    }\\n}\\nclass LockingTree {\\n    // overral space = O(size)\\n    int[] node_idx;\\n    int[] node_end;\\n\\t// i = node_idx[u] is first index of subtree of node u\\n\\t// e = node_end[node_idx[u]] is one past last index of subtree of node u\\n\\t// node u has index node_idx[u],\\n\\t// all descendants of u has indexes nodeidx[u] + 1, ... , nodeend[i] - 1 \\n    TreeMap<Integer, Integer> locks;\\n    FenwickTree ft;\\n\\n    public LockingTree(int[] parent) { // O(n) time\\n        locks = (TreeMap<Integer, Integer>)new TreeMap();\\n        int n = parent.length;\\n        node_idx = new int[n];\\n        node_end = new int[n];\\n        ft = new FenwickTree(n);\\n        int[] cpos = new int[n + 1];\\n        int[] adj = new int[n - 1]; // tree always has (n - 1) edges\\n        assert(parent[0] == -1);\\n        for (int i = 1; i < n; ++i)\\n            ++cpos[parent[i]];\\n        // at this point, cpos[u] is a number of children of u\\n        for (int i = 1; i <= n; ++i)\\n            cpos[i] += cpos[i - 1];\\n        // at this point, cpos[u] points to one after last child of u\\n        // (and cpos[n] is same as cpos[n - 1], i.e. one past last child of n - 1)\\n        for (int i = 1; i < n; ++i)\\n            adj[--cpos[parent[i]]] = i;\\n        assert(cpos[n] == adj.length);\\n        // at this point, cpos[u] points to first child of u,\\n        // and cpos[u + 1] points to one past last child of u;\\n        // that is, children of node u are adj[cpos[u]:cpos[u + 1]]\\n        int node = 0;\\n        int end = 0;\\n        int cpos_node = cpos[node];\\n        node_idx[node] = end++;\\n        int stack_size = 0;\\n        int[] stack_node = new int[n]; // max stack depth = n (vine)\\n        int[] stack_cpos = new int[n];\\n        for (;;) {\\n            if (cpos_node == cpos[node + 1]) {\\n                node_end[node_idx[node]] = end;\\n                if (stack_size == 0)\\n                    break;\\n                --stack_size; // pop from stack\\n                node = stack_node[stack_size];\\n                cpos_node = stack_cpos[stack_size];\\n            } else {\\n                stack_node[stack_size] = node; // push to stack\\n                stack_cpos[stack_size] = cpos_node + 1;\\n                ++stack_size;\\n                node = adj[cpos_node];\\n                node_idx[node] = end++;\\n                cpos_node = cpos[node];\\n            }\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) { // O(log n) time\\n        int ni = node_idx[num];\\n        if(locks.get(ni) != null)\\n            return false;\\n        locks.put(ni, user);\\n        int ei = node_end[ni];\\n        ft.add(ni, +1);\\n        if (ei != node_idx.length)\\n            ft.add(ei, -1);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {  // O(log n) time\\n        int ni = node_idx[num];\\n        Integer l = locks.get(ni);\\n        if (l == null || l != user)\\n            return false;\\n        locks.remove(ni);\\n        int ei = node_end[ni];\\n        if (ei != node_idx.length)\\n            ft.add(ei, +1);\\n        ft.add(ni, -1);\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        // single call time = O(log n + number of upgraded locks*log n)\\n        // ammortized avg time = O(log n) (as no lock can be upgraded twice)\\n        int ni = node_idx[num];\\n        int ei = node_end[ni];\\n        if (ft.prefix_sum(ni) != 0) // O(log n)\\n            // when any of parents locked, prefix sum is non-zero\\n            return false;\\n        NavigableMap<Integer, Integer> v = locks.subMap(ni, false, ei, false);\\n        // O(log n)\\n        if (v.isEmpty())\\n            return false;\\n        for (;;) { // O(locks * log n)\\n            Map.Entry<Integer, Integer> l = v.pollFirstEntry();\\n            if (l == null)\\n                break;\\n            int vni = l.getKey();\\n            int vei = node_end[vni];\\n            if (vei != node_idx.length)\\n                ft.add(vei, +1);\\n            ft.add(vni, -1);\\n        }\\n        locks.put(ni, user);\\n        ft.add(ni, +1);\\n        if (ei != node_idx.length)\\n            ft.add(ei, -1);\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```c++\\ntemplate <typename T, typename V = std::vector<T>>\\nclass FenwickTree {\\n    // One-based Fenwick tree with a twist (A[0] saves nums[0])\\n    V A;\\n    public:\\n    typedef typename V::size_type size_type;\\n    typedef typename V::value_type value_type;\\n    private:\\n    static const size_type LSB(const size_type i) {\\n        return i & -i;\\n    }\\n    public:\\n    FenwickTree(size_type size = 0):A(size) {\\n    }\\n\\n    // Returns the sum of the first i elements (indices 0 to i)\\n    // Equivalent to range_sum(0, i)\\n    T prefix_sum(size_type i) const {\\n        T sum = A[0];\\n        for (; i != 0; i -= LSB(i))\\n            sum += A[i];\\n        return sum;\\n    }\\n\\n    // Add delta to element with index i (zero-based)\\n    void add(size_type i, T delta) {\\n        if (i == 0) {\\n            A[0] += delta;\\n            return;\\n        }\\n        for (; i < A.size(); i+= LSB(i))\\n            A[i] += delta;\\n    }\\n};\\nclass LockingTree {\\n    // overral space = O(size), overral time = O(size + calls^2 log size) \\n    vector<unsigned> node_idx;\\n    vector<unsigned> node_end;\\n\\t// i = node_idx[u] is first index of subtree of node u\\n\\t// e = node_end[i] is one past last index of subtree of node u\\n\\t// node u has index node_idx[u],\\n\\t// all descendants of u has indexes node_idx[u] + 1, ... , node_end[i] - 1 \\n    map<unsigned, int> locks; // index of locked node -> user\\n    FenwickTree<int> ft;\\n    // return index of one past last descendant\\n    static unsigned dfs(unsigned u, unsigned i, vector<unsigned> &node_idx, vector<unsigned> &node_end, const vector<vector<unsigned>> &adj) {\\n        auto end = i + 1;\\n        node_idx[u] = i;\\n        for (auto v: adj[u])\\n            end = dfs(v, end, node_idx, node_end, adj);\\n        node_end[i] = end;\\n        return end;\\n    }\\npublic:\\n    LockingTree(vector<int>& parent)\\n\\t    :node_idx(parent.size()),\\n\\t\\t node_end(parent.size()),\\n\\t\\t ft(parent.size() + 1)\\n    { // O(size) space, O(size) time\\n        const auto n = parent.size();\\n        vector<vector<unsigned>> adj(n); // O(n) space\\n        for (unsigned i = 1; i < n; ++i)\\n            adj[parent[i]].push_back(i);\\n        dfs(0, 0, node_idx, node_end, adj);\\n    }\\n    \\n    bool lock(int num, int user) { // O(log size)\\n        auto ni = node_idx[num];\\n        auto ret = locks.emplace(ni, user).second;\\n        if (ret) {\\n            auto ei = node_end[ni];\\n            ft.add(ni, +1);\\n            ft.add(ei, -1);\\n        }\\n        return ret;\\n    }\\n    \\n    bool unlock(int num, int user) { // O(log size) \\n        auto ni = node_idx[num];\\n        auto l = locks.find(ni);\\n        if (l == locks.end() || l->second != user)\\n            return false;\\n        locks.erase(l);\\n        auto ei = node_end[ni];\\n        ft.add(ei, +1);\\n        ft.add(ni, -1);\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n\\t    // single operation time is O(upgraded locks * log size), ammortized time is O(log size)\\n\\t    // (as no lock can be upgraded twice)\\n        auto ni = node_idx[num];\\n        auto ei = node_end[ni];\\n        if (ft.prefix_sum(ni)) // O(log size)\\n            return false;\\n        auto v = locks.lower_bound(ni + 1); // O(log size)\\n        if (v == locks.end() || v->first >= ei)\\n            return false;\\n        while (v != locks.end() && v->first < ei) {\\n            auto vni = v->first;\\n            auto vei = node_end[vni];\\n            ft.add(vei, +1);\\n            ft.add(vni, -1);\\n            v = locks.erase(v);\\n        }\\n        locks[ni] = user;\\n        ft.add(ni, +1);\\n        ft.add(ei, -1);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n ```\n```c++\\n    LockingTree(vector<int>& parent)\\n        : node_idx(parent.size()), node_end(parent.size()), ft(parent.size())\\n    { // O(n) time\\n        const auto n = parent.size();\\n        vector<unsigned> cpos(n + 1);\\n        vector<unsigned> adj(n - 1); // tree always has (n - 1) edges\\n        for (unsigned i = 1; i < n; ++i)\\n            ++cpos[parent[i]];\\n        // at this point, cpos[u] is a number of children of u\\n        for (unsigned i = 1, pos = cpos[0]; i <= n; ++i)\\n            cpos[i] = pos += cpos[i];\\n        // at this point, cpos[u] points to one after last child of u\\n        // (and cpos[n] is same as cpos[n - 1], i.e. one past last child of n - 1)\\n        assert(cpos[n] == adj.size());\\n        for (unsigned i = 1; i < n; ++i)\\n            adj[--cpos[parent[i]]] = i;\\n        // at this point, cpos[u] points to first child of u,\\n        // and cpos[u + 1] points to one past last child of u;\\n        // that is, children of node u are adj[cpos[u]:cpos[u + 1]]\\n\\t\\t\\n\\t\\t// dfs with explicit stack\\n        unsigned node = 0;\\n        unsigned idx = 0;\\n        unsigned end = 0;\\n        vector<pair<unsigned, unsigned>> stack; // max stack depth = O(n)\\n        for (;;) {\\n            if (idx == 0)\\n                node_idx[node] = end++;\\n            const auto cpos_node = cpos[node];\\n            if (cpos_node + idx == cpos[node + 1]) {\\n                node_end[node_idx[node]] = end;\\n                if (stack.empty())\\n                    break;\\n                tie(node, idx) = stack.back();\\n                stack.pop_back();\\n                continue;\\n            }\\n            stack.emplace_back(node, idx + 1);\\n            node = adj[cpos_node + idx];\\n            idx = 0;\\n        }\\n    }\\n```\n```java\\nimport java.util.NavigableMap;\\nclass FenwickTree {\\n    // One-based Fenwick tree with a twist (A[0] saves nums[0])\\n    private int[] A;\\n    FenwickTree(int size) {\\n        A = new int[size];\\n    }\\n    private static int LSB(int i) {\\n        return i & -i;\\n    }\\n\\n    // Returns the sum of the first i elements (indices 0 to i)\\n    // Equivalent to range_sum(0, i)\\n    public int prefix_sum(int i) {\\n        int sum = A[0];\\n        for (; i != 0; i -= LSB(i))\\n            sum += A[i];\\n        return sum;\\n    }\\n\\n    // Add delta to element with index i (zero-based)\\n    void add(int i, int delta) {\\n        if (i == 0) {\\n            A[0] += delta;\\n            return;\\n        }\\n        for (; i < A.length; i += LSB(i))\\n            A[i] += delta;\\n    }\\n}\\nclass LockingTree {\\n    // overral space = O(size)\\n    int[] node_idx;\\n    int[] node_end;\\n\\t// i = node_idx[u] is first index of subtree of node u\\n\\t// e = node_end[node_idx[u]] is one past last index of subtree of node u\\n\\t// node u has index node_idx[u],\\n\\t// all descendants of u has indexes nodeidx[u] + 1, ... , nodeend[i] - 1 \\n    TreeMap<Integer, Integer> locks;\\n    FenwickTree ft;\\n\\n    public LockingTree(int[] parent) { // O(n) time\\n        locks = (TreeMap<Integer, Integer>)new TreeMap();\\n        int n = parent.length;\\n        node_idx = new int[n];\\n        node_end = new int[n];\\n        ft = new FenwickTree(n);\\n        int[] cpos = new int[n + 1];\\n        int[] adj = new int[n - 1]; // tree always has (n - 1) edges\\n        assert(parent[0] == -1);\\n        for (int i = 1; i < n; ++i)\\n            ++cpos[parent[i]];\\n        // at this point, cpos[u] is a number of children of u\\n        for (int i = 1; i <= n; ++i)\\n            cpos[i] += cpos[i - 1];\\n        // at this point, cpos[u] points to one after last child of u\\n        // (and cpos[n] is same as cpos[n - 1], i.e. one past last child of n - 1)\\n        for (int i = 1; i < n; ++i)\\n            adj[--cpos[parent[i]]] = i;\\n        assert(cpos[n] == adj.length);\\n        // at this point, cpos[u] points to first child of u,\\n        // and cpos[u + 1] points to one past last child of u;\\n        // that is, children of node u are adj[cpos[u]:cpos[u + 1]]\\n        int node = 0;\\n        int end = 0;\\n        int cpos_node = cpos[node];\\n        node_idx[node] = end++;\\n        int stack_size = 0;\\n        int[] stack_node = new int[n]; // max stack depth = n (vine)\\n        int[] stack_cpos = new int[n];\\n        for (;;) {\\n            if (cpos_node == cpos[node + 1]) {\\n                node_end[node_idx[node]] = end;\\n                if (stack_size == 0)\\n                    break;\\n                --stack_size; // pop from stack\\n                node = stack_node[stack_size];\\n                cpos_node = stack_cpos[stack_size];\\n            } else {\\n                stack_node[stack_size] = node; // push to stack\\n                stack_cpos[stack_size] = cpos_node + 1;\\n                ++stack_size;\\n                node = adj[cpos_node];\\n                node_idx[node] = end++;\\n                cpos_node = cpos[node];\\n            }\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) { // O(log n) time\\n        int ni = node_idx[num];\\n        if(locks.get(ni) != null)\\n            return false;\\n        locks.put(ni, user);\\n        int ei = node_end[ni];\\n        ft.add(ni, +1);\\n        if (ei != node_idx.length)\\n            ft.add(ei, -1);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {  // O(log n) time\\n        int ni = node_idx[num];\\n        Integer l = locks.get(ni);\\n        if (l == null || l != user)\\n            return false;\\n        locks.remove(ni);\\n        int ei = node_end[ni];\\n        if (ei != node_idx.length)\\n            ft.add(ei, +1);\\n        ft.add(ni, -1);\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        // single call time = O(log n + number of upgraded locks*log n)\\n        // ammortized avg time = O(log n) (as no lock can be upgraded twice)\\n        int ni = node_idx[num];\\n        int ei = node_end[ni];\\n        if (ft.prefix_sum(ni) != 0) // O(log n)\\n            // when any of parents locked, prefix sum is non-zero\\n            return false;\\n        NavigableMap<Integer, Integer> v = locks.subMap(ni, false, ei, false);\\n        // O(log n)\\n        if (v.isEmpty())\\n            return false;\\n        for (;;) { // O(locks * log n)\\n            Map.Entry<Integer, Integer> l = v.pollFirstEntry();\\n            if (l == null)\\n                break;\\n            int vni = l.getKey();\\n            int vei = node_end[vni];\\n            if (vei != node_idx.length)\\n                ft.add(vei, +1);\\n            ft.add(vni, -1);\\n        }\\n        locks.put(ni, user);\\n        ft.add(ni, +1);\\n        if (ei != node_idx.length)\\n            ft.add(ei, -1);\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548433,
                "title": "using-dfs-solution",
                "content": "# Intuition\\nUsing DFS approachdfs\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LockingTree {\\npublic:\\nunordered_map<int,int>checkLocked;\\nunordered_map<int,int>who_locked;\\nvector<int>par;\\nint n;\\nunordered_map<int,vector<int>>desc;\\n    LockingTree(vector<int>& parent) {\\n        par=parent;\\n         n=par.size();\\n        for(int i=1;i<par.size();i++){\\n             desc[par[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(!checkLocked.count(num)){\\n            checkLocked[num]=1;\\n            who_locked[num]=user;\\n            return  true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(checkLocked.count(num) && who_locked[num]==user ){\\n            checkLocked.erase(num);\\n            who_locked.erase(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        int curr=num;\\n        while(curr!=-1){\\n            if(checkLocked.count(curr))return  false;\\n            curr=par[curr];\\n        }\\n        if(curr==-1){\\n            if(checkLocked.count(0))return false;\\n        }\\n        vector<int>vis(n,0);\\n        int cnt=0;\\n        dfs(num,vis,cnt);\\n        if(cnt>=1){\\n            vis.clear();\\n            vis.resize(n,0);\\n            dfs2(num,vis);\\n            lock(num,user);\\n            return true;\\n        }\\n        return false;\\n    }\\n    void dfs(int num,vector<int>&vis,int &cnt){\\n        vis[num]=1;\\n        if(checkLocked.count(num))cnt++;\\n         if(cnt==1)return;\\n       \\n        for(auto nbr:desc[num]){\\n            if(!vis[nbr])dfs(nbr,vis,cnt);\\n        }\\n        \\n    }\\n   void dfs2(int node,vector<int>&vis){\\n       vis[node]=1;\\n       checkLocked.erase(node);\\n       who_locked.erase(node);\\n       for(auto nbr:desc[node]){\\n           if(!vis[nbr]){\\n               dfs2(nbr,vis);\\n           }\\n       }\\n   }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\nunordered_map<int,int>checkLocked;\\nunordered_map<int,int>who_locked;\\nvector<int>par;\\nint n;\\nunordered_map<int,vector<int>>desc;\\n    LockingTree(vector<int>& parent) {\\n        par=parent;\\n         n=par.size();\\n        for(int i=1;i<par.size();i++){\\n             desc[par[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(!checkLocked.count(num)){\\n            checkLocked[num]=1;\\n            who_locked[num]=user;\\n            return  true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(checkLocked.count(num) && who_locked[num]==user ){\\n            checkLocked.erase(num);\\n            who_locked.erase(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        int curr=num;\\n        while(curr!=-1){\\n            if(checkLocked.count(curr))return  false;\\n            curr=par[curr];\\n        }\\n        if(curr==-1){\\n            if(checkLocked.count(0))return false;\\n        }\\n        vector<int>vis(n,0);\\n        int cnt=0;\\n        dfs(num,vis,cnt);\\n        if(cnt>=1){\\n            vis.clear();\\n            vis.resize(n,0);\\n            dfs2(num,vis);\\n            lock(num,user);\\n            return true;\\n        }\\n        return false;\\n    }\\n    void dfs(int num,vector<int>&vis,int &cnt){\\n        vis[num]=1;\\n        if(checkLocked.count(num))cnt++;\\n         if(cnt==1)return;\\n       \\n        for(auto nbr:desc[num]){\\n            if(!vis[nbr])dfs(nbr,vis,cnt);\\n        }\\n        \\n    }\\n   void dfs2(int node,vector<int>&vis){\\n       vis[node]=1;\\n       checkLocked.erase(node);\\n       who_locked.erase(node);\\n       for(auto nbr:desc[node]){\\n           if(!vis[nbr]){\\n               dfs2(nbr,vis);\\n           }\\n       }\\n   }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465525,
                "title": "simple-map-bfs-dfs-approach-short-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LockingTree {\\npublic:\\n    vector <vector<int>> adj;\\n    vector <int> par;\\n    unordered_map <int,int> umap;\\n\\n    LockingTree(vector<int>& par) {\\n        int n = par.size();\\n        adj.resize(n);\\n        for(int i = 0;i<n;i++){\\n            if(par[i]==-1) continue;\\n            adj[par[i]].push_back(i);\\n        }\\n        this->par = par;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(umap.find(num)==umap.end()){\\n            umap[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(umap.find(num)!=umap.end()){\\n            if(umap[num]!=user) return false;\\n            umap.erase(num);\\n            return true;\\n        }\\n        return false;        \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(umap.find(num)!=umap.end()) return false;\\n        if(!f1(num) or !f2(num)) return false;\\n        f3(num);\\n        umap[num] = user;\\n        return true;\\n    }\\n\\n    void f3(int num){\\n        for(auto iter : adj[num]){\\n            if(umap.find(iter)!=umap.end()){\\n                umap.erase(iter);\\n            }\\n            f3(iter);\\n        }\\n    }\\n\\n    bool f1(int num){\\n        for(auto iter : adj[num]){\\n            if(umap.find(iter)!=umap.end()) return true;\\n            if(f1(iter)) return true;\\n        }\\n        return false;\\n    }\\n\\n    bool f2(int num){\\n        while(num!=-1){\\n            if(umap.find(num)!=umap.end()) return false;\\n            num = par[num];\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Design"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector <vector<int>> adj;\\n    vector <int> par;\\n    unordered_map <int,int> umap;\\n\\n    LockingTree(vector<int>& par) {\\n        int n = par.size();\\n        adj.resize(n);\\n        for(int i = 0;i<n;i++){\\n            if(par[i]==-1) continue;\\n            adj[par[i]].push_back(i);\\n        }\\n        this->par = par;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(umap.find(num)==umap.end()){\\n            umap[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(umap.find(num)!=umap.end()){\\n            if(umap[num]!=user) return false;\\n            umap.erase(num);\\n            return true;\\n        }\\n        return false;        \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(umap.find(num)!=umap.end()) return false;\\n        if(!f1(num) or !f2(num)) return false;\\n        f3(num);\\n        umap[num] = user;\\n        return true;\\n    }\\n\\n    void f3(int num){\\n        for(auto iter : adj[num]){\\n            if(umap.find(iter)!=umap.end()){\\n                umap.erase(iter);\\n            }\\n            f3(iter);\\n        }\\n    }\\n\\n    bool f1(int num){\\n        for(auto iter : adj[num]){\\n            if(umap.find(iter)!=umap.end()) return true;\\n            if(f1(iter)) return true;\\n        }\\n        return false;\\n    }\\n\\n    bool f2(int num){\\n        while(num!=-1){\\n            if(umap.find(num)!=umap.end()) return false;\\n            num = par[num];\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434156,
                "title": "python-solution-laid-out-clearly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.locked = {}\\n        self.parent = parent\\n        self.descendants = defaultdict(list)\\n        for i, v in enumerate(parent):\\n            self.descendants[v].append(i)\\n       \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.locked:\\n            return False\\n        self.locked[num] = user\\n        return True   \\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if num in self.locked and self.locked[num] == user:\\n            del self.locked[num]\\n            return True\\n        return False    \\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n\\n        # if locked, return false\\n        if num in self.locked:\\n            return False\\n\\n        # function to check at least one locked descendant\\n        def hasLockedChild(num):\\n            if num not in self.descendants:\\n                return False\\n                        \\n            for child in self.descendants[num]:\\n                if child in self.locked:\\n                    return True\\n                if hasLockedChild(child):\\n                    return True\\n\\n            return False \\n\\n        # function to unlock all descendants\\n        def unlockDescendants(num):\\n            if num not in self.descendants:\\n                return\\n\\n            for child in self.descendants[num]:\\n                if child in self.locked:\\n                    del self.locked[child]\\n                unlockDescendants(child)              \\n\\n        # does it have locked ancestors\\n        def unlockedParents(num):\\n            unlocked = True\\n            curr = num\\n            while curr != -1:\\n                if self.parent[curr] in self.locked:\\n                    unlocked = False\\n                curr = self.parent[curr]\\n            return unlocked    \\n\\n             \\n\\n        # now can see if it meets the requirements\\n        if hasLockedChild(num) and unlockedParents(num):\\n            # lock for this user\\n            self.locked[num] = user\\n\\n            # unlock all descendants\\n            unlockDescendants(num)\\n\\n            return True\\n        else:\\n            return False                  \\n\\n\\n\\n\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.locked = {}\\n        self.parent = parent\\n        self.descendants = defaultdict(list)\\n        for i, v in enumerate(parent):\\n            self.descendants[v].append(i)\\n       \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.locked:\\n            return False\\n        self.locked[num] = user\\n        return True   \\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if num in self.locked and self.locked[num] == user:\\n            del self.locked[num]\\n            return True\\n        return False    \\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n\\n        # if locked, return false\\n        if num in self.locked:\\n            return False\\n\\n        # function to check at least one locked descendant\\n        def hasLockedChild(num):\\n            if num not in self.descendants:\\n                return False\\n                        \\n            for child in self.descendants[num]:\\n                if child in self.locked:\\n                    return True\\n                if hasLockedChild(child):\\n                    return True\\n\\n            return False \\n\\n        # function to unlock all descendants\\n        def unlockDescendants(num):\\n            if num not in self.descendants:\\n                return\\n\\n            for child in self.descendants[num]:\\n                if child in self.locked:\\n                    del self.locked[child]\\n                unlockDescendants(child)              \\n\\n        # does it have locked ancestors\\n        def unlockedParents(num):\\n            unlocked = True\\n            curr = num\\n            while curr != -1:\\n                if self.parent[curr] in self.locked:\\n                    unlocked = False\\n                curr = self.parent[curr]\\n            return unlocked    \\n\\n             \\n\\n        # now can see if it meets the requirements\\n        if hasLockedChild(num) and unlockedParents(num):\\n            # lock for this user\\n            self.locked[num] = user\\n\\n            # unlock all descendants\\n            unlockDescendants(num)\\n\\n            return True\\n        else:\\n            return False                  \\n\\n\\n\\n\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422060,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LockingTree {\\n    int[] p;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    Map<Integer, List<Integer>> children = new HashMap<>();\\n    public LockingTree(int[] parent) {\\n        p = parent;\\n        for(int i = 0; i < p.length; i ++) {\\n            children.put(i, new ArrayList<>());\\n        }\\n        for(int i = 1; i < p.length; i ++) {\\n            children.get(p[i]).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(!map.containsKey(num)) {\\n            map.put(num, user);\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(map.containsKey(num) && map.get(num) == user) {\\n            map.remove(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        //check the node\\n        if(map.containsKey(num)) return false;\\n        //check Ancestor\\n        int ori = num;\\n        while(p[num] != -1) {\\n            if(map.get(p[num]) != null) return false;\\n            num = p[num];\\n        }\\n        //check Decendant\\n        Queue<Integer> q = new LinkedList<>();\\n        List<Integer> child = children.get(ori);\\n        if(child != null) {\\n            for(int c : child) q.offer(c);\\n        }\\n        boolean lock = false;\\n        while(!q.isEmpty()) {\\n            int cur = q.poll();\\n            if(map.get(cur) != null) {\\n                lock = true;\\n                map.remove(cur); // unlock\\n            }\\n            List<Integer> cc = children.get(cur);\\n            if(cc != null) {\\n                for(int c : cc) q.offer(c);\\n            }\\n        }        \\n        if(!lock) return false;\\n        map.put(ori, user); // lock the original node\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n    int[] p;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    Map<Integer, List<Integer>> children = new HashMap<>();\\n    public LockingTree(int[] parent) {\\n        p = parent;\\n        for(int i = 0; i < p.length; i ++) {\\n            children.put(i, new ArrayList<>());\\n        }\\n        for(int i = 1; i < p.length; i ++) {\\n            children.get(p[i]).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(!map.containsKey(num)) {\\n            map.put(num, user);\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(map.containsKey(num) && map.get(num) == user) {\\n            map.remove(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        //check the node\\n        if(map.containsKey(num)) return false;\\n        //check Ancestor\\n        int ori = num;\\n        while(p[num] != -1) {\\n            if(map.get(p[num]) != null) return false;\\n            num = p[num];\\n        }\\n        //check Decendant\\n        Queue<Integer> q = new LinkedList<>();\\n        List<Integer> child = children.get(ori);\\n        if(child != null) {\\n            for(int c : child) q.offer(c);\\n        }\\n        boolean lock = false;\\n        while(!q.isEmpty()) {\\n            int cur = q.poll();\\n            if(map.get(cur) != null) {\\n                lock = true;\\n                map.remove(cur); // unlock\\n            }\\n            List<Integer> cc = children.get(cur);\\n            if(cc != null) {\\n                for(int c : cc) q.offer(c);\\n            }\\n        }        \\n        if(!lock) return false;\\n        map.put(ori, user); // lock the original node\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418599,
                "title": "java-array-hashmap-parent-childrens",
                "content": "# Code\\n```\\nclass LockingTree {\\n\\n    int[] parent;\\n    Integer[] lock;\\n    HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n\\n    public LockingTree(int[] parent) {\\n        this.parent=parent;\\n        lock=new Integer[parent.length];\\n        for(int i=1;i<parent.length;++i){\\n            if(map.containsKey(parent[i])){\\n                ArrayList<Integer> child=map.get(parent[i]);\\n                child.add(i);\\n                map.put(parent[i],child);\\n            }\\n            else{\\n                ArrayList<Integer> child=new ArrayList<>();\\n                child.add(i);\\n                map.put(parent[i],child);\\n            }\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(lock[num]==null){\\n            lock[num]=user;\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(lock[num]!=null){\\n            if(lock[num]==user){\\n                lock[num]=null;\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        else return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if(lock[num]==null && hasLockedDesendant(num) && noLockedAncestor(num)){\\n            lock[num]=user;\\n            unlockDesc(num);\\n            return true;\\n        }\\n        else return false;\\n    }\\n\\n    public void unlockDesc(int num){\\n        ArrayDeque<Integer> q=new ArrayDeque<>();\\n        ArrayList<Integer> childr=map.get(num);\\n        for(int c:childr){\\n            q.add(c);\\n        }\\n        while(q.size()>0){\\n            int size=q.size();\\n\\n            while(size>0){\\n                int n=q.removeFirst();\\n                if(lock[n]!=null) lock[n]=null;\\n                if(map.get(n)==null) {size-=1;continue;}\\n                ArrayList<Integer> children=map.get(n);\\n                for(int child:children){\\n                    if(lock[child]!=null)   lock[child]=null;\\n                    q.add(child);\\n                }\\n                size-=1;\\n            }\\n        }\\n    }\\n\\n    public boolean hasLockedDesendant(int num){\\n        if(lock[num]!=null) return true;\\n        ArrayDeque<Integer> q=new ArrayDeque<>();\\n        q.add(num);\\n\\n        while(q.size()>0){\\n            int size=q.size();\\n\\n            while(size>0){\\n                int n=q.removeFirst();\\n                if(lock[n]!=null) return true;\\n                if(map.get(n)==null) {size-=1;continue;}\\n                ArrayList<Integer> children=map.get(n);\\n                for(int child:children){\\n                    if(lock[child]!=null)   return true;\\n                    q.add(child);\\n                }\\n                size-=1;\\n            }\\n        }\\n        return false;\\n    }\\n    public boolean noLockedAncestor(int num){\\n        if(num==-1)  return true;\\n        if(lock[num]!=null) return false;\\n        boolean rec=noLockedAncestor(parent[num]);\\n        if(rec==false)  return false;\\n        return true;        \\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n\\n    int[] parent;\\n    Integer[] lock;\\n    HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n\\n    public LockingTree(int[] parent) {\\n        this.parent=parent;\\n        lock=new Integer[parent.length];\\n        for(int i=1;i<parent.length;++i){\\n            if(map.containsKey(parent[i])){\\n                ArrayList<Integer> child=map.get(parent[i]);\\n                child.add(i);\\n                map.put(parent[i],child);\\n            }\\n            else{\\n                ArrayList<Integer> child=new ArrayList<>();\\n                child.add(i);\\n                map.put(parent[i],child);\\n            }\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(lock[num]==null){\\n            lock[num]=user;\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(lock[num]!=null){\\n            if(lock[num]==user){\\n                lock[num]=null;\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        else return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if(lock[num]==null && hasLockedDesendant(num) && noLockedAncestor(num)){\\n            lock[num]=user;\\n            unlockDesc(num);\\n            return true;\\n        }\\n        else return false;\\n    }\\n\\n    public void unlockDesc(int num){\\n        ArrayDeque<Integer> q=new ArrayDeque<>();\\n        ArrayList<Integer> childr=map.get(num);\\n        for(int c:childr){\\n            q.add(c);\\n        }\\n        while(q.size()>0){\\n            int size=q.size();\\n\\n            while(size>0){\\n                int n=q.removeFirst();\\n                if(lock[n]!=null) lock[n]=null;\\n                if(map.get(n)==null) {size-=1;continue;}\\n                ArrayList<Integer> children=map.get(n);\\n                for(int child:children){\\n                    if(lock[child]!=null)   lock[child]=null;\\n                    q.add(child);\\n                }\\n                size-=1;\\n            }\\n        }\\n    }\\n\\n    public boolean hasLockedDesendant(int num){\\n        if(lock[num]!=null) return true;\\n        ArrayDeque<Integer> q=new ArrayDeque<>();\\n        q.add(num);\\n\\n        while(q.size()>0){\\n            int size=q.size();\\n\\n            while(size>0){\\n                int n=q.removeFirst();\\n                if(lock[n]!=null) return true;\\n                if(map.get(n)==null) {size-=1;continue;}\\n                ArrayList<Integer> children=map.get(n);\\n                for(int child:children){\\n                    if(lock[child]!=null)   return true;\\n                    q.add(child);\\n                }\\n                size-=1;\\n            }\\n        }\\n        return false;\\n    }\\n    public boolean noLockedAncestor(int num){\\n        if(num==-1)  return true;\\n        if(lock[num]!=null) return false;\\n        boolean rec=noLockedAncestor(parent[num]);\\n        if(rec==false)  return false;\\n        return true;        \\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332335,
                "title": "c-dfs-hashmap",
                "content": "\\n# Code\\n```\\nclass LockingTree {\\npublic:\\n    vector<vector<int>> adj;\\n    map<int,int> m;\\n    vector<int> parent;\\n    \\n    LockingTree(vector<int>& par) {\\n        int n = par.size();\\n        parent.resize(n);\\n        int maxi = *max_element(par.begin(),par.end());\\n        maxi = max(maxi,n);\\n        adj.resize(maxi+1);\\n        for(int i=0;i<n;i++)\\n        parent[i] = par[i];\\n        \\n        m.clear();\\n        for(int i=1;i<n;i++)\\n        {\\n            int paren = parent[i];\\n            int child = i;\\n            adj[paren].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(m.find(num)==m.end())\\n        {\\n            m[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(m.find(num)==m.end())\\n        return false;\\n        if(m[num]==user)\\n        {\\n            m.erase(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(m.find(num)!=m.end())\\n        return false;\\n        bool flg1 = true;\\n        int tmp = num;\\n        while(tmp!=-1)\\n        {\\n            int ancestor = parent[tmp];\\n            if(m.find(ancestor)!=m.end())\\n            {\\n                flg1 = false;\\n                break;\\n            }\\n            tmp = parent[tmp];\\n        }\\n        if(!flg1)\\n        return false;\\n\\n        bool flg2 = false;\\n        dfs(num,flg2);\\n        \\n        if(!flg2)\\n        return false;\\n        m[num] = user;\\n        return true;\\n    }\\n    void dfs(int x,bool& flg)\\n    {\\n        for(auto &i:adj[x])\\n        {\\n            if(m.find(i)!=m.end())\\n            {\\n                flg = true;\\n                m.erase(i);\\n            }\\n            dfs(i,flg);\\n        }\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<vector<int>> adj;\\n    map<int,int> m;\\n    vector<int> parent;\\n    \\n    LockingTree(vector<int>& par) {\\n        int n = par.size();\\n        parent.resize(n);\\n        int maxi = *max_element(par.begin(),par.end());\\n        maxi = max(maxi,n);\\n        adj.resize(maxi+1);\\n        for(int i=0;i<n;i++)\\n        parent[i] = par[i];\\n        \\n        m.clear();\\n        for(int i=1;i<n;i++)\\n        {\\n            int paren = parent[i];\\n            int child = i;\\n            adj[paren].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(m.find(num)==m.end())\\n        {\\n            m[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(m.find(num)==m.end())\\n        return false;\\n        if(m[num]==user)\\n        {\\n            m.erase(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(m.find(num)!=m.end())\\n        return false;\\n        bool flg1 = true;\\n        int tmp = num;\\n        while(tmp!=-1)\\n        {\\n            int ancestor = parent[tmp];\\n            if(m.find(ancestor)!=m.end())\\n            {\\n                flg1 = false;\\n                break;\\n            }\\n            tmp = parent[tmp];\\n        }\\n        if(!flg1)\\n        return false;\\n\\n        bool flg2 = false;\\n        dfs(num,flg2);\\n        \\n        if(!flg2)\\n        return false;\\n        m[num] = user;\\n        return true;\\n    }\\n    void dfs(int x,bool& flg)\\n    {\\n        for(auto &i:adj[x])\\n        {\\n            if(m.find(i)!=m.end())\\n            {\\n                flg = true;\\n                m.erase(i);\\n            }\\n            dfs(i,flg);\\n        }\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317173,
                "title": "c-easy-and-fast-hashmap",
                "content": "TC:O(N)\\nSC:O(N)\\n```\\nclass LockingTree {\\npublic:\\n    vector<int> lockStatus;\\n    vector<int> parents;\\n    unordered_map<int,vector<int>>tree;\\n    \\n    LockingTree(vector<int>& parent) {\\n        int n = parent.size();\\n        parents=parent;\\n        lockStatus.resize(n+10,-1);\\n        for(int i=1;i<n;i++){\\n            int node   = i;\\n            int parent = parents[i];\\n            if(!tree.count(parent))\\n                tree[parent] = {node};\\n            else\\n                tree[parent].push_back(node);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(lockStatus[num]!=-1) return false;\\n        lockStatus[num]=user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(lockStatus[num]==-1 || lockStatus[num]!=user) return false;\\n        lockStatus[num]=-1;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        bool flag=0;\\n        \\n        if(lockStatus[num]!=-1) return false;   //1st condition\\n        \\n        if(!checkAllAncestorsAreUnlocked(num)) return false;   //2nd condition\\n        \\n        checkIfAnyDescendentsIsLocked(num,flag);  //3rd condition\\n        \\n        if(flag==0) return  false;\\n        \\n        lockStatus[num]=user;  //success\\n        return true;\\n    }\\n    \\n    private: bool checkAllAncestorsAreUnlocked(int node){\\n        \\n        //base case\\n        if(node==-1) return 1;\\n        \\n        return (lockStatus[node]==-1) && \\n               checkAllAncestorsAreUnlocked(parents[node]);\\n    }\\n    \\n    private: void checkIfAnyDescendentsIsLocked(int node,bool &flag){\\n        //base case\\n        \\n        if(lockStatus[node]!=-1) {\\n            lockStatus[node]=-1;\\n            flag=1;\\n        }\\n        \\n        //explore all the childs\\n        for(auto it:tree[node])\\n            checkIfAnyDescendentsIsLocked(it,flag);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<int> lockStatus;\\n    vector<int> parents;\\n    unordered_map<int,vector<int>>tree;\\n    \\n    LockingTree(vector<int>& parent) {\\n        int n = parent.size();\\n        parents=parent;\\n        lockStatus.resize(n+10,-1);\\n        for(int i=1;i<n;i++){\\n            int node   = i;\\n            int parent = parents[i];\\n            if(!tree.count(parent))\\n                tree[parent] = {node};\\n            else\\n                tree[parent].push_back(node);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(lockStatus[num]!=-1) return false;\\n        lockStatus[num]=user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(lockStatus[num]==-1 || lockStatus[num]!=user) return false;\\n        lockStatus[num]=-1;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        bool flag=0;\\n        \\n        if(lockStatus[num]!=-1) return false;   //1st condition\\n        \\n        if(!checkAllAncestorsAreUnlocked(num)) return false;   //2nd condition\\n        \\n        checkIfAnyDescendentsIsLocked(num,flag);  //3rd condition\\n        \\n        if(flag==0) return  false;\\n        \\n        lockStatus[num]=user;  //success\\n        return true;\\n    }\\n    \\n    private: bool checkAllAncestorsAreUnlocked(int node){\\n        \\n        //base case\\n        if(node==-1) return 1;\\n        \\n        return (lockStatus[node]==-1) && \\n               checkAllAncestorsAreUnlocked(parents[node]);\\n    }\\n    \\n    private: void checkIfAnyDescendentsIsLocked(int node,bool &flag){\\n        //base case\\n        \\n        if(lockStatus[node]!=-1) {\\n            lockStatus[node]=-1;\\n            flag=1;\\n        }\\n        \\n        //explore all the childs\\n        for(auto it:tree[node])\\n            checkIfAnyDescendentsIsLocked(it,flag);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265537,
                "title": "easy-and-clear-to-understand",
                "content": "```\\nclass LockingTree {\\n    int data[];//to store the parent\\n    boolean check = false;\\n    HashMap<Integer,Integer> info = new HashMap<>();//to store the locked pairs\\n    List<List<Integer>> op = new ArrayList<>();//to store the child \\n    public LockingTree(int[] parent) {\\n        data = new int[parent.length];\\n        for(int i=0;i<parent.length;i++){\\n            op.add(new ArrayList<>());\\n            data[i] = parent[i];\\n        }\\n        for(int i=1;i<parent.length;i++) op.get(parent[i]).add(i);\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(info.containsKey(num)) return false;\\n        info.put(num,user);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(!info.containsKey(num)) return false;\\n        if(info.get(num)!=user) return false;\\n        info.remove(num);\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        check = false;\\n        if(info.containsKey(num)) return false;\\n        dfs1(num);\\n        if(check) return false;\\n        dfs(num);\\n        if(check) info.put(num,user);\\n        return check;\\n    }\\n    public void dfs1(int num){//for traversing upside of the tree\\n        if(num==-1) return;\\n        if(info.containsKey(num)) { check = true;return; }\\n        dfs1(data[num]);\\n    }\\n    public void dfs(int num){ //for traversing downside of the tree\\n        if(info.containsKey(num)) { check = true; info.remove(num);}\\n         for(int i:op.get(num)) dfs(i);\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\n    int data[];//to store the parent\\n    boolean check = false;\\n    HashMap<Integer,Integer> info = new HashMap<>();//to store the locked pairs\\n    List<List<Integer>> op = new ArrayList<>();//to store the child \\n    public LockingTree(int[] parent) {\\n        data = new int[parent.length];\\n        for(int i=0;i<parent.length;i++){\\n            op.add(new ArrayList<>());\\n            data[i] = parent[i];\\n        }\\n        for(int i=1;i<parent.length;i++) op.get(parent[i]).add(i);\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(info.containsKey(num)) return false;\\n        info.put(num,user);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(!info.containsKey(num)) return false;\\n        if(info.get(num)!=user) return false;\\n        info.remove(num);\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        check = false;\\n        if(info.containsKey(num)) return false;\\n        dfs1(num);\\n        if(check) return false;\\n        dfs(num);\\n        if(check) info.put(num,user);\\n        return check;\\n    }\\n    public void dfs1(int num){//for traversing upside of the tree\\n        if(num==-1) return;\\n        if(info.containsKey(num)) { check = true;return; }\\n        dfs1(data[num]);\\n    }\\n    public void dfs(int num){ //for traversing downside of the tree\\n        if(info.containsKey(num)) { check = true; info.remove(num);}\\n         for(int i:op.get(num)) dfs(i);\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 3262051,
                "title": "c",
                "content": "```\\nclass LockingTree {\\nprivate: \\n    vector<int>parent ;\\n    vector<int>locked ;\\n    vector<vector<int>>Tree ;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        this->parent = parent ;\\n        int n = parent.size() ;\\n        locked.resize(n) ;\\n        Tree.resize(n) ;\\n        for(int i = 0 ; i < parent.size(); i++)\\n        {\\n            if(parent[i] != -1)\\n                Tree[parent[i]].push_back(i) ;\\n        }            \\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locked[num])\\n            return false ;\\n        locked[num] = user ;\\n        return true ;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked[num] != user)\\n            return false ;\\n        locked[num] =  0 ;\\n        return true ;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        //The node is unlocked,\\n        //It does not have any locked ancestors. \\n        //It has at least one locked descendant (by any user), and\\n        \\n        //step 1\\n        if(locked[num])\\n            return false ;\\n        //step 2\\n        int cur = num ;\\n        while(cur != -1){\\n            if(locked[cur])\\n                return false ;\\n            cur = parent[cur] ;\\n        }\\n        //step 3\\n        vector<int>descendant ;\\n        queue<int> q ;\\n        q.push(num) ;\\n        while(!q.empty()){\\n            int cur = q.front() ;\\n            q.pop() ;\\n            if(locked[cur])\\n                descendant.push_back(cur) ;\\n            for(auto& child : Tree[cur])\\n                q.push(child) ;\\n        }\\n        \\n        if(descendant.size()){\\n            locked[num] = user ;\\n            for(auto& x : descendant)\\n                locked[x] = 0 ;\\n            return true ;\\n        }\\n        return false ;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Tree",
                    "Queue"
                ],
                "code": "```\\nclass LockingTree {\\nprivate: \\n    vector<int>parent ;\\n    vector<int>locked ;\\n    vector<vector<int>>Tree ;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        this->parent = parent ;\\n        int n = parent.size() ;\\n        locked.resize(n) ;\\n        Tree.resize(n) ;\\n        for(int i = 0 ; i < parent.size(); i++)\\n        {\\n            if(parent[i] != -1)\\n                Tree[parent[i]].push_back(i) ;\\n        }            \\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locked[num])\\n            return false ;\\n        locked[num] = user ;\\n        return true ;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked[num] != user)\\n            return false ;\\n        locked[num] =  0 ;\\n        return true ;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        //The node is unlocked,\\n        //It does not have any locked ancestors. \\n        //It has at least one locked descendant (by any user), and\\n        \\n        //step 1\\n        if(locked[num])\\n            return false ;\\n        //step 2\\n        int cur = num ;\\n        while(cur != -1){\\n            if(locked[cur])\\n                return false ;\\n            cur = parent[cur] ;\\n        }\\n        //step 3\\n        vector<int>descendant ;\\n        queue<int> q ;\\n        q.push(num) ;\\n        while(!q.empty()){\\n            int cur = q.front() ;\\n            q.pop() ;\\n            if(locked[cur])\\n                descendant.push_back(cur) ;\\n            for(auto& child : Tree[cur])\\n                q.push(child) ;\\n        }\\n        \\n        if(descendant.size()){\\n            locked[num] = user ;\\n            for(auto& x : descendant)\\n                locked[x] = 0 ;\\n            return true ;\\n        }\\n        return false ;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236307,
                "title": "895-ms",
                "content": "```ruby\\nclass LockingTree\\n\\n    def initialize p\\n        @p = p\\n        @l = {}\\n        @t = Hash.new { _1[_2] = [] }\\n        p.each_with_index do\\n            @t[_1] << _2\\n        end\\n        @c = false\\n        @f = -> n do\\n            if @l[n]\\n                @c = true\\n                @l.delete n\\n            end\\n            @t[n].each { @f.(_1) }\\n        end\\n    end\\n\\n    def lock n, u\\n        @l[n] ? false : (@l[n] = u; true)\\n    end\\n\\n    def unlock n, u\\n        @l[n] == u ? (@l.delete n; true) : false\\n    end\\n\\n    def upgrade n, u\\n        return false if @l[n]\\n        p = n\\n        while (p = @p[p]) != -1\\n            return false if @l[p]\\n        end\\n        @c = false\\n        @t[n].each { @f.(_1) }\\n        return false unless @c\\n        @l[n] = u\\n        true\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass LockingTree\\n\\n    def initialize p\\n        @p = p\\n        @l = {}\\n        @t = Hash.new { _1[_2] = [] }\\n        p.each_with_index do\\n            @t[_1] << _2\\n        end\\n        @c = false\\n        @f = -> n do\\n            if @l[n]\\n                @c = true\\n                @l.delete n\\n            end\\n            @t[n].each { @f.(_1) }\\n        end\\n    end\\n\\n    def lock n, u\\n        @l[n] ? false : (@l[n] = u; true)\\n    end\\n\\n    def unlock n, u\\n        @l[n] == u ? (@l.delete n; true) : false\\n    end\\n\\n    def upgrade n, u\\n        return false if @l[n]\\n        p = n\\n        while (p = @p[p]) != -1\\n            return false if @l[p]\\n        end\\n        @c = false\\n        @t[n].each { @f.(_1) }\\n        return false unless @c\\n        @l[n] = u\\n        true\\n    end\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182265,
                "title": "java-dfs",
                "content": "\\n# Code\\n```\\nclass LockingTree {\\n    List<List<Integer>> adjList = new ArrayList<>();\\n    int[] lockedBy;\\n    int[] parent;\\n\\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        this.lockedBy = new int[n];\\n        this.parent = parent;\\n        Arrays.fill(lockedBy, -1);\\n        for (int i = 0; i < n; i++) {\\n            adjList.add(new ArrayList<>());\\n        }\\n        for (int i = 1; i < n; i++) {\\n            adjList.get(parent[i]).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (lockedBy[num] == -1) {\\n            lockedBy[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        int current = lockedBy[num];\\n        if (user == current) {\\n            lockedBy[num] = -1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (lockedBy[num] != -1) {\\n            return false;\\n        }\\n        if (!hasLocks(num)) {\\n            return false;\\n        }\\n        if (hasAccendantLocked(num)) {\\n            return false;\\n        }\\n        lockedBy[num] = user;\\n        for (int neig : adjList.get(num)) {\\n            unlockDFS(neig);\\n        }\\n        return true;\\n    }\\n\\n    private boolean hasAccendantLocked(int num) {\\n        if (num == -1) {\\n            return false;\\n        }\\n        if (lockedBy[num] != -1) {\\n            return true;\\n        }\\n        return hasAccendantLocked(parent[num]);\\n    }\\n\\n    private void unlockDFS(int node) {\\n        lockedBy[node] = -1;\\n        for (int neig : adjList.get(node)) {\\n            unlockDFS(neig);\\n        }\\n    }\\n\\n    private boolean hasLocks(int node) {\\n        if (lockedBy[node] != -1) {\\n            return true;\\n        }\\n        for (int neig : adjList.get(node)) {\\n            if (hasLocks(neig)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n    List<List<Integer>> adjList = new ArrayList<>();\\n    int[] lockedBy;\\n    int[] parent;\\n\\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        this.lockedBy = new int[n];\\n        this.parent = parent;\\n        Arrays.fill(lockedBy, -1);\\n        for (int i = 0; i < n; i++) {\\n            adjList.add(new ArrayList<>());\\n        }\\n        for (int i = 1; i < n; i++) {\\n            adjList.get(parent[i]).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (lockedBy[num] == -1) {\\n            lockedBy[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        int current = lockedBy[num];\\n        if (user == current) {\\n            lockedBy[num] = -1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (lockedBy[num] != -1) {\\n            return false;\\n        }\\n        if (!hasLocks(num)) {\\n            return false;\\n        }\\n        if (hasAccendantLocked(num)) {\\n            return false;\\n        }\\n        lockedBy[num] = user;\\n        for (int neig : adjList.get(num)) {\\n            unlockDFS(neig);\\n        }\\n        return true;\\n    }\\n\\n    private boolean hasAccendantLocked(int num) {\\n        if (num == -1) {\\n            return false;\\n        }\\n        if (lockedBy[num] != -1) {\\n            return true;\\n        }\\n        return hasAccendantLocked(parent[num]);\\n    }\\n\\n    private void unlockDFS(int node) {\\n        lockedBy[node] = -1;\\n        for (int neig : adjList.get(node)) {\\n            unlockDFS(neig);\\n        }\\n    }\\n\\n    private boolean hasLocks(int node) {\\n        if (lockedBy[node] != -1) {\\n            return true;\\n        }\\n        for (int neig : adjList.get(node)) {\\n            if (hasLocks(neig)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079069,
                "title": "java-up-and-down",
                "content": "--> lockedBy stores the info about who locked the node.\\n\\n--> lockCount stores the info about the number of nodes locked in a nodes subtree (includes the node also).\\n\\n# Code\\n```\\nclass LockingTree {\\n\\n    class Node {\\n        int lockedBy = Integer.MIN_VALUE;\\n        int lockCount = 0;\\n    }\\n\\n    private Map<Integer, Node> nodes = new HashMap<>();\\n    private Map<Integer, List<Integer>> adj = new HashMap<>();\\n    private int[] parent;\\n    \\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        int n = parent.length;\\n        for (int i = 0; i < n; i++) {\\n            nodes.put(i, new Node());\\n        }\\n        for (int i = 1; i < parent.length; i++) {\\n            adj.computeIfAbsent(i, v -> new LinkedList<>()).add(parent[i]);\\n            adj.computeIfAbsent(parent[i], v -> new LinkedList<>()).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        Node node = nodes.get(num);\\n        if (node.lockedBy != Integer.MIN_VALUE) {\\n            return false;\\n        }\\n        node.lockedBy = user;\\n        node.lockCount++;\\n        while (this.parent[num] != -1) {\\n            int parent = this.parent[num];\\n            node = nodes.get(parent);\\n            node.lockCount++;\\n            num = parent;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        Node node = nodes.get(num);\\n        if (node.lockedBy != user) {\\n            return false;\\n        }\\n        node.lockedBy = Integer.MIN_VALUE;\\n        node.lockCount--;\\n        while (this.parent[num] != -1) {\\n            int parent = this.parent[num];\\n            node = nodes.get(parent);\\n            node.lockCount--;\\n            num = parent;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        Node node = nodes.get(num);\\n        if (node.lockedBy != Integer.MIN_VALUE) {\\n            return false;\\n        } \\n        if (node.lockCount == 0) {\\n            return false;\\n        }\\n        int dup = num;\\n        while (parent[dup] != -1) {\\n            int parent = this.parent[dup];\\n            node = nodes.get(parent);\\n            if (node.lockedBy != Integer.MIN_VALUE) {\\n                return false;\\n            }\\n            dup = parent;\\n        }\\n        node = nodes.get(num);\\n        int deltaLockCount = node.lockCount;\\n        dup = num;\\n        while (this.parent[dup] != -1) {\\n            int parent = this.parent[dup];\\n            node = nodes.get(parent);\\n            node.lockCount = node.lockCount - deltaLockCount + 1;\\n            dup = parent;\\n        }\\n        node = nodes.get(num);\\n        node.lockedBy = user;\\n        node.lockCount = 1;\\n        traverse(num, this.parent[num]);\\n        return true;\\n    }\\n\\n    private void traverse(int num, int parent) {\\n        List<Integer> children = adj.get(num);\\n        if (children == null) return;\\n        for (int child : children) {\\n            if (child != parent) {\\n                Node n = nodes.get(child);\\n                n.lockCount = 0;\\n                n.lockedBy = Integer.MIN_VALUE;\\n                traverse(child, num);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n\\n    class Node {\\n        int lockedBy = Integer.MIN_VALUE;\\n        int lockCount = 0;\\n    }\\n\\n    private Map<Integer, Node> nodes = new HashMap<>();\\n    private Map<Integer, List<Integer>> adj = new HashMap<>();\\n    private int[] parent;\\n    \\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        int n = parent.length;\\n        for (int i = 0; i < n; i++) {\\n            nodes.put(i, new Node());\\n        }\\n        for (int i = 1; i < parent.length; i++) {\\n            adj.computeIfAbsent(i, v -> new LinkedList<>()).add(parent[i]);\\n            adj.computeIfAbsent(parent[i], v -> new LinkedList<>()).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        Node node = nodes.get(num);\\n        if (node.lockedBy != Integer.MIN_VALUE) {\\n            return false;\\n        }\\n        node.lockedBy = user;\\n        node.lockCount++;\\n        while (this.parent[num] != -1) {\\n            int parent = this.parent[num];\\n            node = nodes.get(parent);\\n            node.lockCount++;\\n            num = parent;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        Node node = nodes.get(num);\\n        if (node.lockedBy != user) {\\n            return false;\\n        }\\n        node.lockedBy = Integer.MIN_VALUE;\\n        node.lockCount--;\\n        while (this.parent[num] != -1) {\\n            int parent = this.parent[num];\\n            node = nodes.get(parent);\\n            node.lockCount--;\\n            num = parent;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        Node node = nodes.get(num);\\n        if (node.lockedBy != Integer.MIN_VALUE) {\\n            return false;\\n        } \\n        if (node.lockCount == 0) {\\n            return false;\\n        }\\n        int dup = num;\\n        while (parent[dup] != -1) {\\n            int parent = this.parent[dup];\\n            node = nodes.get(parent);\\n            if (node.lockedBy != Integer.MIN_VALUE) {\\n                return false;\\n            }\\n            dup = parent;\\n        }\\n        node = nodes.get(num);\\n        int deltaLockCount = node.lockCount;\\n        dup = num;\\n        while (this.parent[dup] != -1) {\\n            int parent = this.parent[dup];\\n            node = nodes.get(parent);\\n            node.lockCount = node.lockCount - deltaLockCount + 1;\\n            dup = parent;\\n        }\\n        node = nodes.get(num);\\n        node.lockedBy = user;\\n        node.lockCount = 1;\\n        traverse(num, this.parent[num]);\\n        return true;\\n    }\\n\\n    private void traverse(int num, int parent) {\\n        List<Integer> children = adj.get(num);\\n        if (children == null) return;\\n        for (int child : children) {\\n            if (child != parent) {\\n                Node n = nodes.get(child);\\n                n.lockCount = 0;\\n                n.lockedBy = Integer.MIN_VALUE;\\n                traverse(child, num);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049934,
                "title": "dfs-hashmap-better-than-50-java",
                "content": "# Code\\n```\\nclass LockingTree {\\n    private final Map<Integer,Integer> nodeLockingStatus = new HashMap<>();\\n    private final Map<Integer, List<Integer>> nodeToChildren = new HashMap<>();\\n    private final int UNLOCKED = -1, FORCED = -2;\\n    private int[] parent;\\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        for (int i=0; i<parent.length; i++) {\\n            nodeLockingStatus.put(i, UNLOCKED);\\n            nodeToChildren.put(i, new ArrayList<>());\\n        }\\n        for (int i=0; i<parent.length; i++) {\\n            if(parent[i] != -1)\\n                nodeToChildren.get(parent[i]).add(i);\\n        }\\n    }\\n\\n    public boolean lock(int num, int user) {\\n        if(nodeLockingStatus.get(num) != UNLOCKED) return false;\\n        nodeLockingStatus.put(num,user);\\n        return true;\\n    }\\n\\n    public boolean unlock(int num, int user) {\\n        if(user != FORCED && nodeLockingStatus.get(num) != user) return false;\\n        nodeLockingStatus.put(num, UNLOCKED);\\n        return true;\\n    }\\n\\n    public boolean upgrade(int num, int user) {\\n        if(!canUpgrade(num)) return false;\\n        nodeLockingStatus.put(num, user);\\n        unlockAllDescendants(num, num);\\n        return true;\\n    }\\n\\n    private void unlockAllDescendants(int node, int initialNode) {\\n        if(node != initialNode) unlock(node, FORCED);\\n        for (Integer child: nodeToChildren.get(node))\\n            unlockAllDescendants(child, node);\\n    }\\n\\n    private boolean canUpgrade(int num) {\\n        if(nodeLockingStatus.get(num) != UNLOCKED) return false;\\n        if(!hasLockeDescendant(num)) return false;\\n        return !hasLockedAncestors(parent[num], parent);\\n    }\\n\\n    private boolean hasLockeDescendant(int node) {\\n        if(nodeLockingStatus.get(node) != UNLOCKED) return true;\\n        for (Integer child: nodeToChildren.get(node))\\n            if(hasLockeDescendant(child))\\n                return true;\\n        return false;\\n    }\\n\\n    private boolean hasLockedAncestors(int node, int[] parent) {\\n        if(node == -1 ) return false;\\n        if(nodeLockingStatus.get(node) != UNLOCKED) return true;\\n        return hasLockedAncestors(parent[node], parent);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n    private final Map<Integer,Integer> nodeLockingStatus = new HashMap<>();\\n    private final Map<Integer, List<Integer>> nodeToChildren = new HashMap<>();\\n    private final int UNLOCKED = -1, FORCED = -2;\\n    private int[] parent;\\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        for (int i=0; i<parent.length; i++) {\\n            nodeLockingStatus.put(i, UNLOCKED);\\n            nodeToChildren.put(i, new ArrayList<>());\\n        }\\n        for (int i=0; i<parent.length; i++) {\\n            if(parent[i] != -1)\\n                nodeToChildren.get(parent[i]).add(i);\\n        }\\n    }\\n\\n    public boolean lock(int num, int user) {\\n        if(nodeLockingStatus.get(num) != UNLOCKED) return false;\\n        nodeLockingStatus.put(num,user);\\n        return true;\\n    }\\n\\n    public boolean unlock(int num, int user) {\\n        if(user != FORCED && nodeLockingStatus.get(num) != user) return false;\\n        nodeLockingStatus.put(num, UNLOCKED);\\n        return true;\\n    }\\n\\n    public boolean upgrade(int num, int user) {\\n        if(!canUpgrade(num)) return false;\\n        nodeLockingStatus.put(num, user);\\n        unlockAllDescendants(num, num);\\n        return true;\\n    }\\n\\n    private void unlockAllDescendants(int node, int initialNode) {\\n        if(node != initialNode) unlock(node, FORCED);\\n        for (Integer child: nodeToChildren.get(node))\\n            unlockAllDescendants(child, node);\\n    }\\n\\n    private boolean canUpgrade(int num) {\\n        if(nodeLockingStatus.get(num) != UNLOCKED) return false;\\n        if(!hasLockeDescendant(num)) return false;\\n        return !hasLockedAncestors(parent[num], parent);\\n    }\\n\\n    private boolean hasLockeDescendant(int node) {\\n        if(nodeLockingStatus.get(node) != UNLOCKED) return true;\\n        for (Integer child: nodeToChildren.get(node))\\n            if(hasLockeDescendant(child))\\n                return true;\\n        return false;\\n    }\\n\\n    private boolean hasLockedAncestors(int node, int[] parent) {\\n        if(node == -1 ) return false;\\n        if(nodeLockingStatus.get(node) != UNLOCKED) return true;\\n        return hasLockedAncestors(parent[node], parent);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034400,
                "title": "bfs-solution-hashmap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecord parents to go upward , record childs to go downwards and maintains locks .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*C) Nodes * Calls\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LockingTree {\\npublic:\\n    vector<int> par;\\n    vector<vector<int>> chl;\\n    vector<int> locks;\\n    LockingTree(vector<int>& parent) {\\n        par = parent;\\n        chl.resize(par.size());\\n        locks.resize(par.size(),-8);\\n        for(int i=0;i<par.size();i++){\\n            if(par[i] != -1) chl[par[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locks[num] > 0) return 0;\\n        locks[num] = user;\\n        return 1;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locks[num] != user) return 0;\\n        locks[num] = -8;\\n        return 1;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(locks[num] >0) return 0;\\n        // Now go upwards\\n        int cnt_l = 0;\\n        int cur = num;\\n        while(cur != -1){\\n            if(locks[cur] > 0){ cnt_l++; break; }\\n            cur = par[cur];\\n        }\\n        if(cnt_l) return 0;\\n        // Do BFS \\n        cnt_l = 0;\\n        queue<int> q;\\n        q.push(num);\\n        while(!q.empty()){\\n            int s = q.size();\\n            for(int i=0;i<s;i++){\\n                int cur = q.front(); q.pop();\\n                if(locks[cur] > 0) { cnt_l++; locks[cur] = -8; }\\n                for(int ch: chl[cur]){\\n                    q.push(ch);\\n                }\\n            }\\n        }\\n        if(cnt_l == 0) return 0;\\n        locks[num] = user;\\n        return 1;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<int> par;\\n    vector<vector<int>> chl;\\n    vector<int> locks;\\n    LockingTree(vector<int>& parent) {\\n        par = parent;\\n        chl.resize(par.size());\\n        locks.resize(par.size(),-8);\\n        for(int i=0;i<par.size();i++){\\n            if(par[i] != -1) chl[par[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locks[num] > 0) return 0;\\n        locks[num] = user;\\n        return 1;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locks[num] != user) return 0;\\n        locks[num] = -8;\\n        return 1;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(locks[num] >0) return 0;\\n        // Now go upwards\\n        int cnt_l = 0;\\n        int cur = num;\\n        while(cur != -1){\\n            if(locks[cur] > 0){ cnt_l++; break; }\\n            cur = par[cur];\\n        }\\n        if(cnt_l) return 0;\\n        // Do BFS \\n        cnt_l = 0;\\n        queue<int> q;\\n        q.push(num);\\n        while(!q.empty()){\\n            int s = q.size();\\n            for(int i=0;i<s;i++){\\n                int cur = q.front(); q.pop();\\n                if(locks[cur] > 0) { cnt_l++; locks[cur] = -8; }\\n                for(int ch: chl[cur]){\\n                    q.push(ch);\\n                }\\n            }\\n        }\\n        if(cnt_l == 0) return 0;\\n        locks[num] = user;\\n        return 1;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023559,
                "title": "python-bruteforce-simple-solution",
                "content": "# Code\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.G = defaultdict(list)\\n        self.parent = parent\\n        for w, v in enumerate(parent):\\n            self.G[v].append(w)\\n        self.locks = defaultdict(lambda:-1)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locks[num] == -1:\\n            self.locks[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locks[num] == user:\\n            self.locks[num] = -1\\n            return True\\n        return False\\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locks[num] != -1: return False\\n        visited = set()\\n        self.cnt = 0\\n        stack = []\\n        def dfs(v):\\n            if v in visited: return\\n            if self.locks[v] != -1:\\n                stack.append(v)\\n            visited.add(v)\\n            for w in self.G[v]:\\n                dfs(w)\\n        dfs(num)\\n        v = self.parent[num]\\n        ancecnt = 0\\n        while v != -1:\\n            if self.locks[v] != -1:\\n                ancecnt += 1\\n            v = self.parent[v]\\n        if stack and not ancecnt:\\n            for v in stack:\\n                self.locks[v] = -1\\n            self.locks[num] = user\\n            return True\\n        return False\\n\\n\\n\\n\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.G = defaultdict(list)\\n        self.parent = parent\\n        for w, v in enumerate(parent):\\n            self.G[v].append(w)\\n        self.locks = defaultdict(lambda:-1)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locks[num] == -1:\\n            self.locks[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locks[num] == user:\\n            self.locks[num] = -1\\n            return True\\n        return False\\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locks[num] != -1: return False\\n        visited = set()\\n        self.cnt = 0\\n        stack = []\\n        def dfs(v):\\n            if v in visited: return\\n            if self.locks[v] != -1:\\n                stack.append(v)\\n            visited.add(v)\\n            for w in self.G[v]:\\n                dfs(w)\\n        dfs(num)\\n        v = self.parent[num]\\n        ancecnt = 0\\n        while v != -1:\\n            if self.locks[v] != -1:\\n                ancecnt += 1\\n            v = self.parent[v]\\n        if stack and not ancecnt:\\n            for v in stack:\\n                self.locks[v] = -1\\n            self.locks[num] = user\\n            return True\\n        return False\\n\\n\\n\\n\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019161,
                "title": "simple-application-of-dfs",
                "content": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent_map = {i: None for i in range(len(parent))}\\n        self.edge_map = {i: set() for i in range(len(parent))}\\n        for i, parent in zip(range(1, len(parent)), parent[1:]):\\n            self.parent_map[i] = parent\\n            self.edge_map[parent].add(i)\\n        self.locked_nodes = {}\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.locked_nodes:\\n            return False\\n        self.locked_nodes[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        is_locked = self.locked_nodes.get(num, -1)\\n        if is_locked != user:\\n            return False\\n        del self.locked_nodes[num]\\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        def check_ancestors(num=num):\\n            if num is None:\\n                return True\\n            if num in self.locked_nodes:\\n                return False\\n            return check_ancestors(self.parent_map[num])\\n\\n        if not check_ancestors():\\n            return False\\n        \\n        # unlock it\\'s desendants, if no descendant is locked, return False again\\n        self.flag = False\\n        def get_descendants(num=num):\\n            if num in self.locked_nodes:\\n                self.flag = True\\n                del self.locked_nodes[num]\\n            for child in self.edge_map[num]:\\n                get_descendants(child)\\n        get_descendants()\\n        if not self.flag:\\n            return False\\n        return self.lock(num, user)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent_map = {i: None for i in range(len(parent))}\\n        self.edge_map = {i: set() for i in range(len(parent))}\\n        for i, parent in zip(range(1, len(parent)), parent[1:]):\\n            self.parent_map[i] = parent\\n            self.edge_map[parent].add(i)\\n        self.locked_nodes = {}\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.locked_nodes:\\n            return False\\n        self.locked_nodes[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        is_locked = self.locked_nodes.get(num, -1)\\n        if is_locked != user:\\n            return False\\n        del self.locked_nodes[num]\\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        def check_ancestors(num=num):\\n            if num is None:\\n                return True\\n            if num in self.locked_nodes:\\n                return False\\n            return check_ancestors(self.parent_map[num])\\n\\n        if not check_ancestors():\\n            return False\\n        \\n        # unlock it\\'s desendants, if no descendant is locked, return False again\\n        self.flag = False\\n        def get_descendants(num=num):\\n            if num in self.locked_nodes:\\n                self.flag = True\\n                del self.locked_nodes[num]\\n            for child in self.edge_map[num]:\\n                get_descendants(child)\\n        get_descendants()\\n        if not self.flag:\\n            return False\\n        return self.lock(num, user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017560,
                "title": "java-solution-tc-lock-and-unlock-in-o-1-upgrade-and-lockingtree-in-o-n-sc-o-n",
                "content": "# Intuition\\n    Please refer the comment in the code section\\n\\n# Approach\\n    Please refer the comment in the code section\\n\\n# Complexity\\n- Time complexity:\\n    - lock and unlock: O(1)\\n    - upgrade and LockingTree: O(n)\\n\\n- Space complexity:\\n    - O(n)\\n\\n# Code\\n```\\nclass LockingTree {\\n\\n    private int[] parent;\\n    private int[] lockedStatus;\\n    private Map<Integer, List<Integer>> adjacencyList;\\n\\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        lockedStatus = new int[parent.length];\\n        adjacencyList = new HashMap<>();\\n        // build the adjacency list\\n        buildAdjacencyList();\\n    }\\n\\n    private void buildAdjacencyList() {\\n        for(int i = 1; i < parent.length; i++) {\\n            int p = parent[i];\\n            if(!adjacencyList.containsKey(p)) {\\n                adjacencyList.put(p, new ArrayList<>());\\n            }\\n\\n            adjacencyList.get(p).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        // if already lock return false\\n        if(lockedStatus[num] != 0) return false;\\n\\n        // otherwise lock the node\\n        lockedStatus[num] = user;\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        // if the node is not locked by the same user\\n        // then return the node\\n        if(lockedStatus[num] != user) return false;\\n\\n        // otherwise unlock the node\\n        lockedStatus[num] = 0;\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        // first check the node is locked or not\\n        // if the node is locked then return false\\n        if(lockedStatus[num] != 0) return false;\\n\\n        // check if any ancestor is locked or not\\n        if(!checkAncestorLocked(num)) return false;\\n\\n        // check is any descendent node is locked or not\\n        List<Integer> desLockedNodes = checkDescendantLocked(num);\\n        if(desLockedNodes.size() == 0) return false;\\n\\n        // if locked unlocked them irrespective of the user\\n        unlocked(desLockedNodes);\\n\\n        lockedStatus[num] = user;\\n        return true;\\n    }\\n\\n    private void unlocked(List<Integer> desLockedNodes) {\\n        for(Integer n : desLockedNodes) {\\n            lockedStatus[n] = 0;\\n        }\\n    }\\n\\n    private List<Integer> checkDescendantLocked(int num) {\\n        List<Integer> desLockedNodes = new ArrayList<>();\\n        dfs(num, desLockedNodes);\\n\\n        return desLockedNodes;\\n    }\\n\\n    private void dfs(int num, List<Integer> desLockedNodes) {\\n        if(adjacencyList.containsKey(num)) {\\n            for(Integer c : adjacencyList.get(num)) {\\n                if(lockedStatus[c] != 0) desLockedNodes.add(c);\\n                dfs(c, desLockedNodes);\\n            }\\n        }\\n        \\n    }\\n\\n    private boolean checkAncestorLocked(int num) {\\n        int p = parent[num];\\n        while(p >= 0) {\\n            if(lockedStatus[p] != 0) return false;\\n            p = parent[p];\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n\\n    private int[] parent;\\n    private int[] lockedStatus;\\n    private Map<Integer, List<Integer>> adjacencyList;\\n\\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        lockedStatus = new int[parent.length];\\n        adjacencyList = new HashMap<>();\\n        // build the adjacency list\\n        buildAdjacencyList();\\n    }\\n\\n    private void buildAdjacencyList() {\\n        for(int i = 1; i < parent.length; i++) {\\n            int p = parent[i];\\n            if(!adjacencyList.containsKey(p)) {\\n                adjacencyList.put(p, new ArrayList<>());\\n            }\\n\\n            adjacencyList.get(p).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        // if already lock return false\\n        if(lockedStatus[num] != 0) return false;\\n\\n        // otherwise lock the node\\n        lockedStatus[num] = user;\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        // if the node is not locked by the same user\\n        // then return the node\\n        if(lockedStatus[num] != user) return false;\\n\\n        // otherwise unlock the node\\n        lockedStatus[num] = 0;\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        // first check the node is locked or not\\n        // if the node is locked then return false\\n        if(lockedStatus[num] != 0) return false;\\n\\n        // check if any ancestor is locked or not\\n        if(!checkAncestorLocked(num)) return false;\\n\\n        // check is any descendent node is locked or not\\n        List<Integer> desLockedNodes = checkDescendantLocked(num);\\n        if(desLockedNodes.size() == 0) return false;\\n\\n        // if locked unlocked them irrespective of the user\\n        unlocked(desLockedNodes);\\n\\n        lockedStatus[num] = user;\\n        return true;\\n    }\\n\\n    private void unlocked(List<Integer> desLockedNodes) {\\n        for(Integer n : desLockedNodes) {\\n            lockedStatus[n] = 0;\\n        }\\n    }\\n\\n    private List<Integer> checkDescendantLocked(int num) {\\n        List<Integer> desLockedNodes = new ArrayList<>();\\n        dfs(num, desLockedNodes);\\n\\n        return desLockedNodes;\\n    }\\n\\n    private void dfs(int num, List<Integer> desLockedNodes) {\\n        if(adjacencyList.containsKey(num)) {\\n            for(Integer c : adjacencyList.get(num)) {\\n                if(lockedStatus[c] != 0) desLockedNodes.add(c);\\n                dfs(c, desLockedNodes);\\n            }\\n        }\\n        \\n    }\\n\\n    private boolean checkAncestorLocked(int num) {\\n        int p = parent[num];\\n        while(p >= 0) {\\n            if(lockedStatus[p] != 0) return false;\\n            p = parent[p];\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006781,
                "title": "go-simple-solution",
                "content": "# Complexity\\n- Time complexity: \\n  - Lock, Unlock: $$O(1)$$\\n  - Upgrade: $$O(h)$$ - h is maximum depth of tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\ntype LockingTree struct {\\n\\tlock       map[int]bool\\n\\tlockByUser map[int]int\\n\\tchilds     map[int][]int\\n\\tparents    []int\\n}\\n\\nfunc Constructor(parent []int) LockingTree {\\n\\tchilds := map[int][]int{}\\n\\tfor i := 0; i < len(parent); i++ {\\n\\t\\tif _, f := childs[parent[i]]; !f {\\n\\t\\t\\tchilds[parent[i]] = []int{}\\n\\t\\t}\\n\\t\\tchilds[parent[i]] = append(childs[parent[i]], i)\\n\\t}\\n\\treturn LockingTree{\\n\\t\\tlock:       map[int]bool{},\\n\\t\\tlockByUser: map[int]int{},\\n\\t\\tparents:    parent,\\n\\t\\tchilds:     childs,\\n\\t}\\n}\\n\\nfunc (this *LockingTree) Lock(num int, user int) bool {\\n\\tif v, f := this.lock[num]; !f || !v {\\n\\t\\tthis.lock[num] = true\\n\\t\\tthis.lockByUser[num] = user\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc (this *LockingTree) Unlock(num int, user int) bool {\\n\\tlocked, f := this.lock[num]\\n\\towner, _ := this.lockByUser[num]\\n\\tif f && locked && owner == user {\\n\\t\\tthis.lock[num] = false\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc (this *LockingTree) HasParentLock(num int) bool {\\n\\tparentNum := this.parents[num]\\n\\tfor parentNum != -1 && !this.lock[parentNum] {\\n\\t\\tparentNum = this.parents[parentNum]\\n\\t}\\n\\treturn parentNum != -1\\n}\\n\\nfunc (this *LockingTree) HasChildLock(parent int) bool {\\n\\tlock := false\\n\\tif numChilds, f := this.childs[parent]; f {\\n\\t\\tfor _, child := range numChilds {\\n\\t\\t\\tif this.lock[child] {\\n\\t\\t\\t\\tthis.lock[child] = false\\n\\t\\t\\t\\tlock = true\\n\\t\\t\\t}\\n\\t\\t\\tif this.HasChildLock(child) {\\n\\t\\t\\t\\tlock = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn lock\\n}\\n\\nfunc (this *LockingTree) Upgrade(num int, user int) bool {\\n\\tif v, f := this.lock[num]; !f || !v {\\n\\t\\tparentLock := this.HasParentLock(num)\\n\\t\\tif !parentLock {\\n\\t\\t\\tchildsLock := this.HasChildLock(num)\\n\\t\\t\\tif childsLock {\\n\\t\\t\\t\\tthis.lock[num] = true\\n\\t\\t\\t\\tthis.lockByUser[num] = user\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\ntype LockingTree struct {\\n\\tlock       map[int]bool\\n\\tlockByUser map[int]int\\n\\tchilds     map[int][]int\\n\\tparents    []int\\n}\\n\\nfunc Constructor(parent []int) LockingTree {\\n\\tchilds := map[int][]int{}\\n\\tfor i := 0; i < len(parent); i++ {\\n\\t\\tif _, f := childs[parent[i]]; !f {\\n\\t\\t\\tchilds[parent[i]] = []int{}\\n\\t\\t}\\n\\t\\tchilds[parent[i]] = append(childs[parent[i]], i)\\n\\t}\\n\\treturn LockingTree{\\n\\t\\tlock:       map[int]bool{},\\n\\t\\tlockByUser: map[int]int{},\\n\\t\\tparents:    parent,\\n\\t\\tchilds:     childs,\\n\\t}\\n}\\n\\nfunc (this *LockingTree) Lock(num int, user int) bool {\\n\\tif v, f := this.lock[num]; !f || !v {\\n\\t\\tthis.lock[num] = true\\n\\t\\tthis.lockByUser[num] = user\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc (this *LockingTree) Unlock(num int, user int) bool {\\n\\tlocked, f := this.lock[num]\\n\\towner, _ := this.lockByUser[num]\\n\\tif f && locked && owner == user {\\n\\t\\tthis.lock[num] = false\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc (this *LockingTree) HasParentLock(num int) bool {\\n\\tparentNum := this.parents[num]\\n\\tfor parentNum != -1 && !this.lock[parentNum] {\\n\\t\\tparentNum = this.parents[parentNum]\\n\\t}\\n\\treturn parentNum != -1\\n}\\n\\nfunc (this *LockingTree) HasChildLock(parent int) bool {\\n\\tlock := false\\n\\tif numChilds, f := this.childs[parent]; f {\\n\\t\\tfor _, child := range numChilds {\\n\\t\\t\\tif this.lock[child] {\\n\\t\\t\\t\\tthis.lock[child] = false\\n\\t\\t\\t\\tlock = true\\n\\t\\t\\t}\\n\\t\\t\\tif this.HasChildLock(child) {\\n\\t\\t\\t\\tlock = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn lock\\n}\\n\\nfunc (this *LockingTree) Upgrade(num int, user int) bool {\\n\\tif v, f := this.lock[num]; !f || !v {\\n\\t\\tparentLock := this.HasParentLock(num)\\n\\t\\tif !parentLock {\\n\\t\\t\\tchildsLock := this.HasChildLock(num)\\n\\t\\t\\tif childsLock {\\n\\t\\t\\t\\tthis.lock[num] = true\\n\\t\\t\\t\\tthis.lockByUser[num] = user\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2968604,
                "title": "doing-what-it-says-but-using-defaultdict-and-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDoing what it says.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a Tree using defaultdict\\n2. each node also has a dictionary ,with it\\'s children list and whether or not the node is locked & by whom.\\n\\n```python []\\n{\"children\":[],\"locked\":[False,None]}\\n```\\n3. create lock & unlock\\n    1. for Lock just check the 1st element \"locked\" element of the node\\n     `if self.tree[num][\"locked\"][0]==True:\\n            return False`\\n    2. for unlock just check 2nd element \"locked\" element of the node or check both element of \"locked\" same thing\\n    `if self.tree[num][\"locked\"][1]==user:`\\n            `self.tree[num][\"locked\"]=[False,None]\\n            return True`\\n4. in upgrade we test 3 thing\\n    1. if the node is locked or not,if not PROCEED\\n    2. if the ancestor of node is locked or not ,if not PROCEED\\n    3. if it has any descendant that is locked, if yes as follow\\n        1. perform DFS/BFS(I used BFS from the given node)\\n        2. if a decendant is locked append it to decendant_to_unlock list\\n        3. if decendant_to_unlock list is empty, retur false\\n        4. if decendant_to_unlock not empty Unlock each nodes present in the list\\n    4. after doing \"c\" Lock the node\\n    5. Return True\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n), for upgrade, BFS, n=number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: I HAVE NO IDEA\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent=parent\\n        self.tree=defaultdict(lambda:{\"children\":[],\"locked\":[False,None]})\\n        for i,e in enumerate(parent):\\n            if e==-1:\\n                continue\\n            self.tree[e][\"children\"].append(i)\\n            self.tree[e][\"locked\"]=[False,None]\\n        \\n        \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.tree[num][\"locked\"][0]:\\n            return False\\n        self.tree[num][\"locked\"]=[True,user]\\n        return True\\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.tree[num][\"locked\"][0] and self.tree[num][\"locked\"][1]==user:\\n            self.tree[num][\"locked\"]=[False,None]\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n\\n        if self.tree[num][\"locked\"][0]:\\n            return False\\n\\n        temp=num\\n        while temp!=-1:\\n            if self.tree[self.parent[temp]][\"locked\"][0]:\\n                return False\\n            temp=self.parent[temp]\\n        \\n        if len(self.tree[num][\"children\"])==0:\\n            \\n            return False\\n        q=self.tree[num][\"children\"].copy()\\n        decendant_to_unlock=[]\\n        while(q):\\n            temp=q.pop(0)\\n            if self.tree[temp][\"locked\"][0]:\\n                decendant_to_unlock.append(temp)\\n            q.extend(self.tree[temp][\"children\"])\\n        if decendant_to_unlock:\\n            for i in decendant_to_unlock:\\n                self.tree[i][\"locked\"]=[False,None]\\n            self.lock(num,user)\\n            return True\\n        return False\\n                \\n\\n\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```python []\\n{\"children\":[],\"locked\":[False,None]}\\n```\n```\\nfrom collections import defaultdict\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent=parent\\n        self.tree=defaultdict(lambda:{\"children\":[],\"locked\":[False,None]})\\n        for i,e in enumerate(parent):\\n            if e==-1:\\n                continue\\n            self.tree[e][\"children\"].append(i)\\n            self.tree[e][\"locked\"]=[False,None]\\n        \\n        \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.tree[num][\"locked\"][0]:\\n            return False\\n        self.tree[num][\"locked\"]=[True,user]\\n        return True\\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.tree[num][\"locked\"][0] and self.tree[num][\"locked\"][1]==user:\\n            self.tree[num][\"locked\"]=[False,None]\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n\\n        if self.tree[num][\"locked\"][0]:\\n            return False\\n\\n        temp=num\\n        while temp!=-1:\\n            if self.tree[self.parent[temp]][\"locked\"][0]:\\n                return False\\n            temp=self.parent[temp]\\n        \\n        if len(self.tree[num][\"children\"])==0:\\n            \\n            return False\\n        q=self.tree[num][\"children\"].copy()\\n        decendant_to_unlock=[]\\n        while(q):\\n            temp=q.pop(0)\\n            if self.tree[temp][\"locked\"][0]:\\n                decendant_to_unlock.append(temp)\\n            q.extend(self.tree[temp][\"children\"])\\n        if decendant_to_unlock:\\n            for i in decendant_to_unlock:\\n                self.tree[i][\"locked\"]=[False,None]\\n            self.lock(num,user)\\n            return True\\n        return False\\n                \\n\\n\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923856,
                "title": "javascript-using-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction TreeNode(val, children) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.children = children === undefined ? [] : children\\n    this.lock = false\\n    this.user = -1;\\n }\\n/**\\n * @param {number[]} parent\\n */\\nvar LockingTree = function(parent) {\\n    let map = {};\\n    for(let i = 0; i< parent.length; i++){\\n        map[parent[i]] ??= []\\n        map[parent[i]].push(i);\\n    }\\n    this.tree = new TreeNode(map[-1][0])\\n    const queue = [this.tree]\\n    while(queue.length){\\n        const current = queue.shift()\\n        if(map[current.val]){\\n            for(let child of map[current.val]){\\n                current.children.push(new TreeNode(child))\\n            }\\n            queue.push(...current.children);\\n        }\\n    }\\n};\\n\\n/** \\n * @param {number} num \\n * @param {number} user\\n * @return {boolean}\\n */\\nLockingTree.prototype.lock = function(num, user) {\\n    const dfs = (node)=>{\\n        if(!node)\\n            return false\\n        if(node.val === num){\\n            if(!node.lock){\\n                node.lock = true\\n                node.user = user\\n                return true;\\n            }\\n        }\\n        for(child of node.children){\\n            if(dfs(child))\\n                return true\\n        }\\n        return false;\\n        \\n    }\\n    return dfs(this.tree);\\n};\\n\\n/** \\n * @param {number} num \\n * @param {number} user\\n * @return {boolean}\\n */\\nLockingTree.prototype.unlock = function(num, user) {\\n    const dfs = (node)=>{\\n        if(!node)\\n            return false\\n        if(node.val === num){\\n            if(node.lock && node.user === user){\\n                node.lock = false\\n                node.user = -1;\\n                return true;\\n            }\\n        }\\n        for(child of node.children){\\n            if(dfs(child))\\n                return true\\n        }\\n        return false;\\n        \\n    }\\n    return dfs(this.tree);\\n};\\n\\n/** \\n * @param {number} num \\n * @param {number} user\\n * @return {boolean}\\n */\\nLockingTree.prototype.upgrade = function(num, user) {\\n    const dfs = (node)=>{\\n        if(!node)\\n            return false\\n        if(node.lock)\\n            return false;\\n        if(node.val === num){\\n            if(!node.lock && unlockAll(node)){\\n                node.lock = true\\n                node.user = user\\n                return true;\\n            }\\n        }\\n        for(child of node.children){\\n            if(dfs(child))\\n                return true\\n        }\\n        return false;\\n        \\n    }\\n    return dfs(this.tree);\\n};\\nvar unlockAll = function(root){\\n    \\n    let result = false;\\n    const dfs = (node)=>{\\n        if(!node)\\n            return\\n        if(node.lock){\\n            node.lock = false;\\n            node.user = -1;\\n            result = true;\\n        }\\n        for(child of node.children){\\n            dfs(child)\\n        }\\n    }\\n    dfs(root)\\n    return result;\\n}\\n\\n/** \\n * Your LockingTree object will be instantiated and called as such:\\n * var obj = new LockingTree(parent)\\n * var param_1 = obj.lock(num,user)\\n * var param_2 = obj.unlock(num,user)\\n * var param_3 = obj.upgrade(num,user)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction TreeNode(val, children) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.children = children === undefined ? [] : children\\n    this.lock = false\\n    this.user = -1;\\n }\\n/**\\n * @param {number[]} parent\\n */\\nvar LockingTree = function(parent) {\\n    let map = {};\\n    for(let i = 0; i< parent.length; i++){\\n        map[parent[i]] ??= []\\n        map[parent[i]].push(i);\\n    }\\n    this.tree = new TreeNode(map[-1][0])\\n    const queue = [this.tree]\\n    while(queue.length){\\n        const current = queue.shift()\\n        if(map[current.val]){\\n            for(let child of map[current.val]){\\n                current.children.push(new TreeNode(child))\\n            }\\n            queue.push(...current.children);\\n        }\\n    }\\n};\\n\\n/** \\n * @param {number} num \\n * @param {number} user\\n * @return {boolean}\\n */\\nLockingTree.prototype.lock = function(num, user) {\\n    const dfs = (node)=>{\\n        if(!node)\\n            return false\\n        if(node.val === num){\\n            if(!node.lock){\\n                node.lock = true\\n                node.user = user\\n                return true;\\n            }\\n        }\\n        for(child of node.children){\\n            if(dfs(child))\\n                return true\\n        }\\n        return false;\\n        \\n    }\\n    return dfs(this.tree);\\n};\\n\\n/** \\n * @param {number} num \\n * @param {number} user\\n * @return {boolean}\\n */\\nLockingTree.prototype.unlock = function(num, user) {\\n    const dfs = (node)=>{\\n        if(!node)\\n            return false\\n        if(node.val === num){\\n            if(node.lock && node.user === user){\\n                node.lock = false\\n                node.user = -1;\\n                return true;\\n            }\\n        }\\n        for(child of node.children){\\n            if(dfs(child))\\n                return true\\n        }\\n        return false;\\n        \\n    }\\n    return dfs(this.tree);\\n};\\n\\n/** \\n * @param {number} num \\n * @param {number} user\\n * @return {boolean}\\n */\\nLockingTree.prototype.upgrade = function(num, user) {\\n    const dfs = (node)=>{\\n        if(!node)\\n            return false\\n        if(node.lock)\\n            return false;\\n        if(node.val === num){\\n            if(!node.lock && unlockAll(node)){\\n                node.lock = true\\n                node.user = user\\n                return true;\\n            }\\n        }\\n        for(child of node.children){\\n            if(dfs(child))\\n                return true\\n        }\\n        return false;\\n        \\n    }\\n    return dfs(this.tree);\\n};\\nvar unlockAll = function(root){\\n    \\n    let result = false;\\n    const dfs = (node)=>{\\n        if(!node)\\n            return\\n        if(node.lock){\\n            node.lock = false;\\n            node.user = -1;\\n            result = true;\\n        }\\n        for(child of node.children){\\n            dfs(child)\\n        }\\n    }\\n    dfs(root)\\n    return result;\\n}\\n\\n/** \\n * Your LockingTree object will be instantiated and called as such:\\n * var obj = new LockingTree(parent)\\n * var param_1 = obj.lock(num,user)\\n * var param_2 = obj.unlock(num,user)\\n * var param_3 = obj.upgrade(num,user)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2902734,
                "title": "easy-to-understand-o-h-time-98-time",
                "content": "```\\nclass LockingTree {\\npublic:\\n    vector<vector<int>> childs;\\n    vector<int> lockId, childLocked, parentLocked, parents;\\n    LockingTree(vector<int>& parent) {\\n        int n = parent.size();\\n        parents = parent;\\n        childs = vector<vector<int>>(n);\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] != -1) {\\n                childs[parent[i]].push_back(i); //keep parent to children mapping\\n            }\\n        }\\n        \\n        childLocked = vector<int>(n,0); // track number of child locked beneath \\n        parentLocked = vector<int>(n,0); // track number of parents locked\\n        lockId = vector<int>(n,-1); // track user id which locked particular node\\n    } \\n    \\n    // update all the children lock count if parent is locked or upgraded\\n    void updateAllChilds(int num, int lock) {\\n        queue<int> q;\\n        q.push(num);\\n        while (!q.empty()) {\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                int cur = q.front(); q.pop();\\n                for (auto &c : childs[cur]) {\\n                    // clear all child locks and keep\\n                    // parentlocked count\\n                    if (lock == -2) {\\n                        parentLocked[c] = 1;\\n                        lockId[c] = -1;\\n                    } else\\n                        parentLocked[c] += lock;\\n                    q.push(c);\\n                }\\n            }\\n        }\\n    }\\n    \\n    // update all parent child lock count when a child is locked/unlocked\\n    void updateAllParents(int num, int lock) {\\n        int parentId = num;\\n        while(parentId != -1) {\\n            childLocked[parentId] += lock;\\n            parentId = parents[parentId];\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (lockId[num] == -1) {\\n            lockId[num] = user;\\n            updateAllChilds(num,1);\\n            updateAllParents(num,1);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (lockId[num] == user) {\\n            lockId[num] = -1;\\n            updateAllChilds(num,-1);\\n            updateAllParents(num,-1);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (lockId[num] == -1) {\\n            if ((childLocked[num] == 0) || parentLocked[num])\\n                return false;\\n            lockId[num] = user;\\n            updateAllChilds(num,-2);\\n            updateAllParents(num,1);\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<vector<int>> childs;\\n    vector<int> lockId, childLocked, parentLocked, parents;\\n    LockingTree(vector<int>& parent) {\\n        int n = parent.size();\\n        parents = parent;\\n        childs = vector<vector<int>>(n);\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] != -1) {\\n                childs[parent[i]].push_back(i); //keep parent to children mapping\\n            }\\n        }\\n        \\n        childLocked = vector<int>(n,0); // track number of child locked beneath \\n        parentLocked = vector<int>(n,0); // track number of parents locked\\n        lockId = vector<int>(n,-1); // track user id which locked particular node\\n    } \\n    \\n    // update all the children lock count if parent is locked or upgraded\\n    void updateAllChilds(int num, int lock) {\\n        queue<int> q;\\n        q.push(num);\\n        while (!q.empty()) {\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                int cur = q.front(); q.pop();\\n                for (auto &c : childs[cur]) {\\n                    // clear all child locks and keep\\n                    // parentlocked count\\n                    if (lock == -2) {\\n                        parentLocked[c] = 1;\\n                        lockId[c] = -1;\\n                    } else\\n                        parentLocked[c] += lock;\\n                    q.push(c);\\n                }\\n            }\\n        }\\n    }\\n    \\n    // update all parent child lock count when a child is locked/unlocked\\n    void updateAllParents(int num, int lock) {\\n        int parentId = num;\\n        while(parentId != -1) {\\n            childLocked[parentId] += lock;\\n            parentId = parents[parentId];\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (lockId[num] == -1) {\\n            lockId[num] = user;\\n            updateAllChilds(num,1);\\n            updateAllParents(num,1);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (lockId[num] == user) {\\n            lockId[num] = -1;\\n            updateAllChilds(num,-1);\\n            updateAllParents(num,-1);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (lockId[num] == -1) {\\n            if ((childLocked[num] == 0) || parentLocked[num])\\n                return false;\\n            lockId[num] = user;\\n            updateAllChilds(num,-2);\\n            updateAllParents(num,1);\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896463,
                "title": "rust-solution",
                "content": "# Code\\n```\\nstruct LockingTree {\\n  locks: Vec<Option<usize>>,\\n  g: Vec<Vec<usize>>,\\n  parent: Vec<i32>,\\n}\\n\\nimpl LockingTree {\\n    fn new(parent: Vec<i32>) -> Self {\\n      let n = parent.len();\\n      let mut g = vec![vec![];n];\\n      for i in 0..n {\\n        if parent[i] == -1 { continue }\\n        g[parent[i] as usize].push(i);\\n      }\\n\\n      LockingTree {\\n        locks: vec![None;n],\\n        g,\\n        parent\\n      }\\n    }\\n    \\n    fn lock(&mut self, num: i32, user: i32) -> bool {\\n      if let Some(_) = self.locks[num as usize] {\\n        false\\n      } else {\\n        self.locks[num as usize] = Some(user as usize);\\n        true\\n      }\\n    }\\n    \\n    fn unlock(&mut self, num: i32, user: i32) -> bool {\\n      if let Some(lock_user) = self.locks[num as usize] {\\n        if lock_user as i32 == user {\\n          self.locks[num as usize] = None;\\n          true\\n        } else {\\n          false\\n        }\\n      } else {\\n        false\\n      }\\n    }\\n    \\n    fn upgrade(&mut self, num: i32, user: i32) -> bool {\\n      let mut ci = num;\\n      while ci != -1 {\\n        let i = ci as usize;\\n        if self.locks[i].is_some() {\\n          return false\\n        }\\n        ci = self.parent[i];\\n      }\\n\\n      let mut dirty = false;\\n      let mut stack = vec![num as usize];\\n      while !stack.is_empty() {\\n        let mut new_stack = vec![];\\n        while let Some(ci) = stack.pop() {\\n          for i in 0..self.g[ci].len() {\\n            let ni = self.g[ci][i];\\n\\n            if self.locks[ni].is_some() {\\n              self.locks[ni] = None;\\n              dirty = true;\\n            }\\n            new_stack.push(ni);\\n          }\\n        }\\n        stack = new_stack;\\n      }\\n\\n      if dirty {\\n        self.locks[num as usize] = Some(user as usize);\\n      }\\n\\n      dirty\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct LockingTree {\\n  locks: Vec<Option<usize>>,\\n  g: Vec<Vec<usize>>,\\n  parent: Vec<i32>,\\n}\\n\\nimpl LockingTree {\\n    fn new(parent: Vec<i32>) -> Self {\\n      let n = parent.len();\\n      let mut g = vec![vec![];n];\\n      for i in 0..n {\\n        if parent[i] == -1 { continue }\\n        g[parent[i] as usize].push(i);\\n      }\\n\\n      LockingTree {\\n        locks: vec![None;n],\\n        g,\\n        parent\\n      }\\n    }\\n    \\n    fn lock(&mut self, num: i32, user: i32) -> bool {\\n      if let Some(_) = self.locks[num as usize] {\\n        false\\n      } else {\\n        self.locks[num as usize] = Some(user as usize);\\n        true\\n      }\\n    }\\n    \\n    fn unlock(&mut self, num: i32, user: i32) -> bool {\\n      if let Some(lock_user) = self.locks[num as usize] {\\n        if lock_user as i32 == user {\\n          self.locks[num as usize] = None;\\n          true\\n        } else {\\n          false\\n        }\\n      } else {\\n        false\\n      }\\n    }\\n    \\n    fn upgrade(&mut self, num: i32, user: i32) -> bool {\\n      let mut ci = num;\\n      while ci != -1 {\\n        let i = ci as usize;\\n        if self.locks[i].is_some() {\\n          return false\\n        }\\n        ci = self.parent[i];\\n      }\\n\\n      let mut dirty = false;\\n      let mut stack = vec![num as usize];\\n      while !stack.is_empty() {\\n        let mut new_stack = vec![];\\n        while let Some(ci) = stack.pop() {\\n          for i in 0..self.g[ci].len() {\\n            let ni = self.g[ci][i];\\n\\n            if self.locks[ni].is_some() {\\n              self.locks[ni] = None;\\n              dirty = true;\\n            }\\n            new_stack.push(ni);\\n          }\\n        }\\n        stack = new_stack;\\n      }\\n\\n      if dirty {\\n        self.locks[num as usize] = Some(user as usize);\\n      }\\n\\n      dirty\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2889715,
                "title": "java-94-faster-hashmap-array-o-n-log-n-k-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n*logn *k)$$  (log n) can be n in case of skewed tree. And k can be number of calls over different operations.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(3n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LockingTree {\\n    int[] parent;\\n    int[] decendentLocked;\\n    int[] lock;\\n    HashMap<Integer, List<Integer>> childs;\\n\\n    public LockingTree(int[] parent) {\\n\\n        this.parent = parent;\\n        int n = parent.length;\\n        this.decendentLocked = new int[n];\\n        this.lock = new int[n];\\n        this.childs = new HashMap<>();\\n\\n        for(int i = n-1; i > 0; i--) {\\n            List<Integer> child = childs.getOrDefault(parent[i], new ArrayList<>());\\n            child.add(i);\\n            childs.put(parent[i], child);\\n        }\\n    }\\n    \\n    public boolean lock(int node, int user) {\\n\\n        if(lock[node] != 0) {\\n            return false;\\n        }\\n\\n        lock[node] = user;\\n        updateLockedByDec(parent[node], 1);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int node, int user) {\\n\\n        if(lock[node] == 0 || lock[node] != user) {\\n            return false;\\n        }\\n\\n        lock[node] = 0;\\n        updateLockedByDec(parent[node], -1);\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int node, int user) {\\n\\n        //If already locked, no decendent locked and any ansester is already locked.\\n        if(lock[node] != 0 || decendentLocked[node] == 0 || checkedLockedAncestor(parent[node])) {\\n            return false;\\n        }\\n\\n        int decLocked = decendentLocked[node];\\n\\n        updateLockedByDec(parent[node], decLocked*-1);\\n        unlockDecendent(node);\\n        return lock(node, user);\\n    }\\n\\n    //Custom helper methods that helps in checking and updating the Decendent or Ancestor nodes.\\n    private boolean checkedLockedAncestor(int node) {\\n\\n        if(node == -1) {\\n            return false;\\n        }\\n\\n        if(lock[node] > 0) {\\n            return true;\\n        }\\n\\n        return checkedLockedAncestor(parent[node]);\\n    }\\n    private void updateLockedByDec(int node, int val) {\\n\\n        if(node == -1) {\\n            return;\\n        }\\n        \\n        decendentLocked[node] += val;\\n        updateLockedByDec(parent[node], val);\\n    }\\n    private void unlockDecendent(int node) {\\n        \\n        lock[node] = 0;\\n        decendentLocked[node] = 0;\\n        \\n        List<Integer> child = childs.getOrDefault(node, null);\\n        if(child == null) {\\n            return;\\n        }\\n\\n        for(int n : child) {\\n            unlockDecendent(n);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass LockingTree {\\n    int[] parent;\\n    int[] decendentLocked;\\n    int[] lock;\\n    HashMap<Integer, List<Integer>> childs;\\n\\n    public LockingTree(int[] parent) {\\n\\n        this.parent = parent;\\n        int n = parent.length;\\n        this.decendentLocked = new int[n];\\n        this.lock = new int[n];\\n        this.childs = new HashMap<>();\\n\\n        for(int i = n-1; i > 0; i--) {\\n            List<Integer> child = childs.getOrDefault(parent[i], new ArrayList<>());\\n            child.add(i);\\n            childs.put(parent[i], child);\\n        }\\n    }\\n    \\n    public boolean lock(int node, int user) {\\n\\n        if(lock[node] != 0) {\\n            return false;\\n        }\\n\\n        lock[node] = user;\\n        updateLockedByDec(parent[node], 1);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int node, int user) {\\n\\n        if(lock[node] == 0 || lock[node] != user) {\\n            return false;\\n        }\\n\\n        lock[node] = 0;\\n        updateLockedByDec(parent[node], -1);\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int node, int user) {\\n\\n        //If already locked, no decendent locked and any ansester is already locked.\\n        if(lock[node] != 0 || decendentLocked[node] == 0 || checkedLockedAncestor(parent[node])) {\\n            return false;\\n        }\\n\\n        int decLocked = decendentLocked[node];\\n\\n        updateLockedByDec(parent[node], decLocked*-1);\\n        unlockDecendent(node);\\n        return lock(node, user);\\n    }\\n\\n    //Custom helper methods that helps in checking and updating the Decendent or Ancestor nodes.\\n    private boolean checkedLockedAncestor(int node) {\\n\\n        if(node == -1) {\\n            return false;\\n        }\\n\\n        if(lock[node] > 0) {\\n            return true;\\n        }\\n\\n        return checkedLockedAncestor(parent[node]);\\n    }\\n    private void updateLockedByDec(int node, int val) {\\n\\n        if(node == -1) {\\n            return;\\n        }\\n        \\n        decendentLocked[node] += val;\\n        updateLockedByDec(parent[node], val);\\n    }\\n    private void unlockDecendent(int node) {\\n        \\n        lock[node] = 0;\\n        decendentLocked[node] = 0;\\n        \\n        List<Integer> child = childs.getOrDefault(node, null);\\n        if(child == null) {\\n            return;\\n        }\\n\\n        for(int n : child) {\\n            unlockDecendent(n);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833842,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass LockingTree \\n{\\npublic:\\n    map<int, vector<int>> parentChild;\\n    map<int,int> chiPar;\\n    map<int,int> loc;\\n    LockingTree(vector<int>& parent) \\n    {\\n        int p=parent.size();\\n        for(int x=0; x<p; x++)\\n        {\\n            parentChild[parent[x]].push_back(x);\\n            chiPar[x]=parent[x];\\n            loc[x]=-1;\\n        }\\n    }\\n    \\n    bool lock(int num, int user) \\n    {\\n        if(loc[num]==-1) \\n        {\\n            loc[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) \\n    {\\n        if(loc[num]==user) \\n        {\\n            loc[num]=-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool dfs(int x)\\n    {\\n        for(auto it: parentChild[x])\\n        {\\n            if(loc[it]!=-1) return true;\\n            bool a=dfs(it);\\n            if(a) return true;\\n        }\\n        return false;\\n    }\\n\\n    void unlock2(int x)\\n    {\\n        for(auto it: parentChild[x])\\n        {\\n            loc[it]=-1;\\n            unlock2(it);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) \\n    {\\n        if(loc[num]!=-1) return false;\\n        if(!dfs(num)) return false;\\n        int par=chiPar[num];\\n        while(par!=-1)\\n        {\\n            if(loc[par]!=-1) return false;\\n            par=chiPar[par];\\n        }\\n        loc[num]=user;\\n        unlock2(num);\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree \\n{\\npublic:\\n    map<int, vector<int>> parentChild;\\n    map<int,int> chiPar;\\n    map<int,int> loc;\\n    LockingTree(vector<int>& parent) \\n    {\\n        int p=parent.size();\\n        for(int x=0; x<p; x++)\\n        {\\n            parentChild[parent[x]].push_back(x);\\n            chiPar[x]=parent[x];\\n            loc[x]=-1;\\n        }\\n    }\\n    \\n    bool lock(int num, int user) \\n    {\\n        if(loc[num]==-1) \\n        {\\n            loc[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) \\n    {\\n        if(loc[num]==user) \\n        {\\n            loc[num]=-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool dfs(int x)\\n    {\\n        for(auto it: parentChild[x])\\n        {\\n            if(loc[it]!=-1) return true;\\n            bool a=dfs(it);\\n            if(a) return true;\\n        }\\n        return false;\\n    }\\n\\n    void unlock2(int x)\\n    {\\n        for(auto it: parentChild[x])\\n        {\\n            loc[it]=-1;\\n            unlock2(it);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) \\n    {\\n        if(loc[num]!=-1) return false;\\n        if(!dfs(num)) return false;\\n        int par=chiPar[num];\\n        while(par!=-1)\\n        {\\n            if(loc[par]!=-1) return false;\\n            par=chiPar[par];\\n        }\\n        loc[num]=user;\\n        unlock2(num);\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825108,
                "title": "python-simple-tree-solution",
                "content": "```\\nclass TreeNode:\\n    \\n    def __init__(self,val=None):\\n        self.val=val\\n        self.children=[]\\n        self.parent=None\\n        self.id=None\\n        self.isLocked=False\\n        \\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.memo = defaultdict(TreeNode)         \\n        for i in range(len(parent)) :\\n            parent_node = self.memo[parent[i]]\\n            child_node = self.memo[i]\\n            parent_node.val = parent[i]\\n            child_node.val = i \\n            parent_node.children.append(child_node)\\n            child_node.parent=parent_node\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        node=self.memo[num]\\n        if node.isLocked:\\n            return False\\n        else :\\n            node.isLocked = True\\n            node.id = user\\n            return True\\n        \\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.memo[num].isLocked and self.memo[num].id == user :\\n            self.memo[num].isLocked = False\\n            self.memo[num].id = None\\n            return True\\n        else :\\n            return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        node=self.memo[num]\\n        if node.isLocked or self.has_locked_anscestor(node) or not self.has_locked_descendant(node)   :\\n            return False\\n        \\n        self.unlock_descendants(node)\\n        node.isLocked = True\\n        node.id=user\\n        return True\\n      \\n        \\n            \\n    def has_locked_anscestor(self,node) :\\n        stack = [node]\\n        while stack :\\n            temp = stack.pop()\\n            if  temp.isLocked :\\n                return True\\n            if temp.parent :\\n                stack.append(temp.parent)\\n        return False\\n    \\n    def has_locked_descendant (self,node) :\\n        q=deque([node])\\n        while q:\\n            temp=q.popleft()\\n            if temp.isLocked :\\n                return True\\n            for child in temp.children:\\n                q.append(child)\\n        return False\\n            \\n    def unlock_descendants(self,node) :\\n        stack=[node]\\n        while stack :\\n            temp = stack.pop()\\n            temp.isLocked = False\\n            temp.id = None\\n            for child in temp.children :\\n                stack.append(child)\\n            \\n        \\n    def print_tree(self,node) :\\n        q= deque([node])\\n        while q :\\n            temp = q.popleft()\\n            print(vars(temp))\\n            for child in temp.children :\\n                q.append(child)\\n",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass TreeNode:\\n    \\n    def __init__(self,val=None):\\n        self.val=val\\n        self.children=[]\\n        self.parent=None\\n        self.id=None\\n        self.isLocked=False\\n        \\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.memo = defaultdict(TreeNode)         \\n        for i in range(len(parent)) :\\n            parent_node = self.memo[parent[i]]\\n            child_node = self.memo[i]\\n            parent_node.val = parent[i]\\n            child_node.val = i \\n            parent_node.children.append(child_node)\\n            child_node.parent=parent_node\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        node=self.memo[num]\\n        if node.isLocked:\\n            return False\\n        else :\\n            node.isLocked = True\\n            node.id = user\\n            return True\\n        \\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.memo[num].isLocked and self.memo[num].id == user :\\n            self.memo[num].isLocked = False\\n            self.memo[num].id = None\\n            return True\\n        else :\\n            return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        node=self.memo[num]\\n        if node.isLocked or self.has_locked_anscestor(node) or not self.has_locked_descendant(node)   :\\n            return False\\n        \\n        self.unlock_descendants(node)\\n        node.isLocked = True\\n        node.id=user\\n        return True\\n      \\n        \\n            \\n    def has_locked_anscestor(self,node) :\\n        stack = [node]\\n        while stack :\\n            temp = stack.pop()\\n            if  temp.isLocked :\\n                return True\\n            if temp.parent :\\n                stack.append(temp.parent)\\n        return False\\n    \\n    def has_locked_descendant (self,node) :\\n        q=deque([node])\\n        while q:\\n            temp=q.popleft()\\n            if temp.isLocked :\\n                return True\\n            for child in temp.children:\\n                q.append(child)\\n        return False\\n            \\n    def unlock_descendants(self,node) :\\n        stack=[node]\\n        while stack :\\n            temp = stack.pop()\\n            temp.isLocked = False\\n            temp.id = None\\n            for child in temp.children :\\n                stack.append(child)\\n            \\n        \\n    def print_tree(self,node) :\\n        q= deque([node])\\n        while q :\\n            temp = q.popleft()\\n            print(vars(temp))\\n            for child in temp.children :\\n                q.append(child)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2804975,
                "title": "java-very-simple-tree-traversal-solution",
                "content": "# Code\\n```\\nclass LockingTree {\\n    class Node {\\n        Node par;\\n        ArrayList<Node> children;\\n        boolean locked;\\n        int user;\\n\\n        public Node() {\\n            par = null;\\n            children = new ArrayList<>();\\n            locked = false;\\n            user = -1;\\n        }\\n    }\\n\\n    Node[] nodes;\\n\\n    public LockingTree(int[] parent) {\\n        int N = parent.length;\\n        nodes = new Node[N];\\n        for(int i=0; i<N; i++) nodes[i] = new Node();\\n\\n        // Tree Construction\\n        for(int i=0; i<N; i++) {\\n            int p = parent[i];\\n            if(p == -1) continue;\\n            nodes[i].par = nodes[p];\\n            nodes[p].children.add(nodes[i]);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(nodes[num].locked == false) {\\n            nodes[num].user = user;\\n            nodes[num].locked = true;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(nodes[num].locked && nodes[num].user == user) {\\n            nodes[num].locked = false;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        Node cur = nodes[num];\\n        while(cur != null) {\\n            if(cur.locked) return false;\\n            cur = cur.par;\\n        }\\n\\n        if(helper(nodes[num])) {\\n            nodes[num].locked = true;\\n            nodes[num].user = user;\\n            return true;\\n        } \\n\\n        return false;\\n    }\\n\\n    public boolean helper(Node root) {\\n        boolean flag = false;\\n\\n        for(Node child : root.children) {\\n            if(helper(child)) flag = true;\\n            if(child.locked){\\n                child.locked = false;\\n                flag = true;\\n            } \\n        }\\n\\n        return flag;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n    class Node {\\n        Node par;\\n        ArrayList<Node> children;\\n        boolean locked;\\n        int user;\\n\\n        public Node() {\\n            par = null;\\n            children = new ArrayList<>();\\n            locked = false;\\n            user = -1;\\n        }\\n    }\\n\\n    Node[] nodes;\\n\\n    public LockingTree(int[] parent) {\\n        int N = parent.length;\\n        nodes = new Node[N];\\n        for(int i=0; i<N; i++) nodes[i] = new Node();\\n\\n        // Tree Construction\\n        for(int i=0; i<N; i++) {\\n            int p = parent[i];\\n            if(p == -1) continue;\\n            nodes[i].par = nodes[p];\\n            nodes[p].children.add(nodes[i]);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(nodes[num].locked == false) {\\n            nodes[num].user = user;\\n            nodes[num].locked = true;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(nodes[num].locked && nodes[num].user == user) {\\n            nodes[num].locked = false;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        Node cur = nodes[num];\\n        while(cur != null) {\\n            if(cur.locked) return false;\\n            cur = cur.par;\\n        }\\n\\n        if(helper(nodes[num])) {\\n            nodes[num].locked = true;\\n            nodes[num].user = user;\\n            return true;\\n        } \\n\\n        return false;\\n    }\\n\\n    public boolean helper(Node root) {\\n        boolean flag = false;\\n\\n        for(Node child : root.children) {\\n            if(helper(child)) flag = true;\\n            if(child.locked){\\n                child.locked = false;\\n                flag = true;\\n            } \\n        }\\n\\n        return flag;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790281,
                "title": "a-bit-more-structured-solution-than-others-i-have-seen",
                "content": "# Approach\\nIt\\'s a design problem so separating the upgrade method into multiple components make it more flexible in cases where the problem definition changes (for example what if a node can have multiple ancestors just like children).\\n\\nP.S. Not that it matters but this solution beats 99.22 % of solution in terms of latency. Memory wise it beats around 90%. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass LockingTree {\\n\\n    class Node {\\n        int num;\\n        List<Integer> children;\\n        int lockedBy;\\n        Node (int num) {\\n            this.num = num;\\n            children = new ArrayList<>();\\n            lockedBy = 0; // since value of users go from 1 to 10^4\\n        }\\n    }\\n    private Node[] nodes;\\n    private int[] parent;\\n\\n    // Time & Memory Complexity O(n)\\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        nodes = new Node[n];\\n        this.parent = parent;\\n        for (int i = 0; i < n; i++) {\\n            if (nodes[i] == null) nodes[i] = new Node(i);\\n            if (i != 0 && nodes[parent[i]] == null) nodes[parent[i]] = new Node(parent[i]);\\n            if (i != 0) nodes[parent[i]].children.add(i);\\n        }\\n    }\\n\\n    // Time & Memory Complexity O(1)\\n    public boolean lock(int num, int user) {\\n        if (nodes[num].lockedBy != 0) return false;\\n        nodes[num].lockedBy = user;\\n        return true;\\n    }\\n\\n    // Time & Memory Complexity O(1)\\n    public boolean unlock(int num, int user) {\\n        if (nodes[num].lockedBy == 0 || nodes[num].lockedBy != user) return false;\\n        nodes[num].lockedBy = 0;\\n        return true;\\n    }\\n\\n    // Time & Memory Complexity O(n)\\n    public boolean upgrade(int num, int user) {\\n        boolean unlocked = nodes[num].lockedBy == 0;\\n        if (!unlocked) return false;\\n\\n        boolean ancestorsUnlocked = traverseAncestors(num);\\n        if (!ancestorsUnlocked) return false;\\n\\n        boolean childrenLocked = dfsChildren(nodes[num]);\\n        if (!childrenLocked) return false;\\n\\n        lock(num, user);\\n\\n        return true;\\n    }\\n    // Time O(height) & Memory Complexity O(1)\\n    private boolean traverseAncestors(int num) {\\n\\n        while (num != -1) {\\n            num = parent[num];\\n            if (num != -1 && nodes[num].lockedBy != 0) return false;\\n        }\\n        return true;\\n\\n    }\\n\\n    // Time & Memory Complexity O(n)\\n    private boolean dfsChildren(Node root) {\\n\\n        boolean locked = root.lockedBy != 0;\\n        if (locked) {\\n            root.lockedBy = 0;\\n        }\\n        for (int child : root.children) {\\n            boolean tmp = dfsChildren(nodes[child]);\\n            locked = locked || tmp;\\n        }\\n\\n        return locked;\\n\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n\\n    class Node {\\n        int num;\\n        List<Integer> children;\\n        int lockedBy;\\n        Node (int num) {\\n            this.num = num;\\n            children = new ArrayList<>();\\n            lockedBy = 0; // since value of users go from 1 to 10^4\\n        }\\n    }\\n    private Node[] nodes;\\n    private int[] parent;\\n\\n    // Time & Memory Complexity O(n)\\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        nodes = new Node[n];\\n        this.parent = parent;\\n        for (int i = 0; i < n; i++) {\\n            if (nodes[i] == null) nodes[i] = new Node(i);\\n            if (i != 0 && nodes[parent[i]] == null) nodes[parent[i]] = new Node(parent[i]);\\n            if (i != 0) nodes[parent[i]].children.add(i);\\n        }\\n    }\\n\\n    // Time & Memory Complexity O(1)\\n    public boolean lock(int num, int user) {\\n        if (nodes[num].lockedBy != 0) return false;\\n        nodes[num].lockedBy = user;\\n        return true;\\n    }\\n\\n    // Time & Memory Complexity O(1)\\n    public boolean unlock(int num, int user) {\\n        if (nodes[num].lockedBy == 0 || nodes[num].lockedBy != user) return false;\\n        nodes[num].lockedBy = 0;\\n        return true;\\n    }\\n\\n    // Time & Memory Complexity O(n)\\n    public boolean upgrade(int num, int user) {\\n        boolean unlocked = nodes[num].lockedBy == 0;\\n        if (!unlocked) return false;\\n\\n        boolean ancestorsUnlocked = traverseAncestors(num);\\n        if (!ancestorsUnlocked) return false;\\n\\n        boolean childrenLocked = dfsChildren(nodes[num]);\\n        if (!childrenLocked) return false;\\n\\n        lock(num, user);\\n\\n        return true;\\n    }\\n    // Time O(height) & Memory Complexity O(1)\\n    private boolean traverseAncestors(int num) {\\n\\n        while (num != -1) {\\n            num = parent[num];\\n            if (num != -1 && nodes[num].lockedBy != 0) return false;\\n        }\\n        return true;\\n\\n    }\\n\\n    // Time & Memory Complexity O(n)\\n    private boolean dfsChildren(Node root) {\\n\\n        boolean locked = root.lockedBy != 0;\\n        if (locked) {\\n            root.lockedBy = 0;\\n        }\\n        for (int child : root.children) {\\n            boolean tmp = dfsChildren(nodes[child]);\\n            locked = locked || tmp;\\n        }\\n\\n        return locked;\\n\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782413,
                "title": "python-traverse-up-down-a-tree-and-translate-english-into-code",
                "content": "Python\\n```\\nclass LockingTree:\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]: return False\\n        self.locked[num]=user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] != user: return False\\n        self.locked[num]=None\\n        return True        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        #check condition1, current node\\n        if self.locked[num]:return False\\n        #check condition2, parent\\n        i=self.parent[num]\\n        while i!=-1:            \\n            if self.locked[i]:return False\\n            i=self.parent[i]            \\n            \\n        #check condition3: decendants\\n        lockedCount = 0        \\n        q = deque(self.child[num])\\n        while q:\\n            node = q.popleft()\\n            if self.locked[node]:\\n                lockedCount+=1\\n                self.locked[node]=None            \\n            q.extend(self.child[node])\\n        \\n        if lockedCount > 0:            \\n            self.locked[num] = user\\n        return lockedCount > 0\\n        \\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked = [None]*len(parent)\\n        self.child=defaultdict(list)                \\n        for i in range(1,len(parent)):\\n            self.child[parent[i]].append(i)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]: return False\\n        self.locked[num]=user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] != user: return False\\n        self.locked[num]=None\\n        return True        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        #check condition1, current node\\n        if self.locked[num]:return False\\n        #check condition2, parent\\n        i=self.parent[num]\\n        while i!=-1:            \\n            if self.locked[i]:return False\\n            i=self.parent[i]            \\n            \\n        #check condition3: decendants\\n        lockedCount = 0        \\n        q = deque(self.child[num])\\n        while q:\\n            node = q.popleft()\\n            if self.locked[node]:\\n                lockedCount+=1\\n                self.locked[node]=None            \\n            q.extend(self.child[node])\\n        \\n        if lockedCount > 0:            \\n            self.locked[num] = user\\n        return lockedCount > 0\\n        \\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked = [None]*len(parent)\\n        self.child=defaultdict(list)                \\n        for i in range(1,len(parent)):\\n            self.child[parent[i]].append(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740405,
                "title": "javascript-class-syntax",
                "content": "```\\nvar Node = class {\\n    constructor (val) {\\n        this.val = val\\n        this.child = []\\n        this.parent = null\\n        this.locked = false\\n    }\\n}\\nvar LockingTree = class {\\n    constructor (parent) {\\n        this.parents = Array(parent.length)\\n\\t\\t\\n\\t\\t//creating root node\\n        let node = new Node(0)        \\n        this.parents[0] = node\\n\\t\\t\\n        for (let i = 1; i < parent.length; i++) {\\n\\t\\t\\t//creating node or accessing it from array if it was previously created\\n            if (this.parents[i]) {\\n                node = this.parents[i]\\n            } else {\\n                node = new Node(i)\\n            }\\n\\t\\t\\t// if the parent node hasnt been created we create and store \\n\\t\\t\\tif (!this.parents[parent[i]]) {\\n                this.parents[parent[i]] = new Node(parent[i])\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//updating parent/child connections\\n            node.parent = this.parents[parent[i]]\\n            this.parents[i] = node\\n            node.parent.child.push(node)\\n        }\\n    }\\n    lock (num, user) {\\n        if (this.parents[num].locked) return false\\n        this.parents[num].locked = user\\n        return true\\n    }\\n    unlock (num, user) {\\n        if (this.parents[num].locked !== user) return false\\n        this.parents[num].locked = false\\n        return true\\n    }\\n    upgrade (num, user) {\\n        if (this.parents[num].locked) return false\\n        let node = this.parents[num]\\n\\t\\t//checking to make sure all ancestors all unlocked\\n        let ancestor = node.parent\\n        while (ancestor) {\\n            if (ancestor.locked) return false\\n            ancestor = ancestor.parent\\n        }\\n        const isChildLocked = (root) => {\\n            if (!root) return false\\n            if (root.locked) return true\\n            if (root.child.length === 0) return false\\n            for (const node of root.child) {\\n                if (isChildLocked(node)) return true\\n            }\\n            return false\\n        }\\n\\t\\t// looking through all children, we need one to be locked or we exit and return false\\n        if (!isChildLocked(node)) return false\\n\\t\\t\\n\\t\\t// unlocking all child nodes\\n        const unlockChild = (root) => {\\n            if (!root) return\\n            root.locked = false\\n            if (root.child.length === 0) return\\n            for (const node of root.child) {\\n                unlockChild(node)\\n            }\\n        }\\n        unlockChild(node);\\n        node.locked = user;\\n        return true\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Node = class {\\n    constructor (val) {\\n        this.val = val\\n        this.child = []\\n        this.parent = null\\n        this.locked = false\\n    }\\n}\\nvar LockingTree = class {\\n    constructor (parent) {\\n        this.parents = Array(parent.length)\\n\\t\\t\\n\\t\\t//creating root node\\n        let node = new Node(0)        \\n        this.parents[0] = node\\n\\t\\t\\n        for (let i = 1; i < parent.length; i++) {\\n\\t\\t\\t//creating node or accessing it from array if it was previously created\\n            if (this.parents[i]) {\\n                node = this.parents[i]\\n            } else {\\n                node = new Node(i)\\n            }\\n\\t\\t\\t// if the parent node hasnt been created we create and store \\n\\t\\t\\tif (!this.parents[parent[i]]) {\\n                this.parents[parent[i]] = new Node(parent[i])\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//updating parent/child connections\\n            node.parent = this.parents[parent[i]]\\n            this.parents[i] = node\\n            node.parent.child.push(node)\\n        }\\n    }\\n    lock (num, user) {\\n        if (this.parents[num].locked) return false\\n        this.parents[num].locked = user\\n        return true\\n    }\\n    unlock (num, user) {\\n        if (this.parents[num].locked !== user) return false\\n        this.parents[num].locked = false\\n        return true\\n    }\\n    upgrade (num, user) {\\n        if (this.parents[num].locked) return false\\n        let node = this.parents[num]\\n\\t\\t//checking to make sure all ancestors all unlocked\\n        let ancestor = node.parent\\n        while (ancestor) {\\n            if (ancestor.locked) return false\\n            ancestor = ancestor.parent\\n        }\\n        const isChildLocked = (root) => {\\n            if (!root) return false\\n            if (root.locked) return true\\n            if (root.child.length === 0) return false\\n            for (const node of root.child) {\\n                if (isChildLocked(node)) return true\\n            }\\n            return false\\n        }\\n\\t\\t// looking through all children, we need one to be locked or we exit and return false\\n        if (!isChildLocked(node)) return false\\n\\t\\t\\n\\t\\t// unlocking all child nodes\\n        const unlockChild = (root) => {\\n            if (!root) return\\n            root.locked = false\\n            if (root.child.length === 0) return\\n            for (const node of root.child) {\\n                unlockChild(node)\\n            }\\n        }\\n        unlockChild(node);\\n        node.locked = user;\\n        return true\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718878,
                "title": "python-simple-dfs-maths",
                "content": "\\n    def __init__(self, parent):\\n        self.parent = parent\\n        self.locked = [0]*len(parent)\\n        self.children = defaultdict(list)\\n        for i in range(1,len(parent)):\\n            self.children[parent[i]].append(i)\\n\\n    def lock(self, num, user):\\n        if self.locked[num] != 0:\\n            return False\\n        \\n        self.locked[num] = user\\n        \\n        return True\\n\\n    def unlock(self, num, user):\\n        if self.locked[num] == user:\\n            self.locked[num] = 0\\n            return True\\n        return False\\n\\n    def upgrade(self, num, user):\\n        cur = num\\n        \\n        # The node is unlocked and it does not have any locked ancestors\\n        \\n        while cur != -1:\\n            if self.locked[cur]:\\n                return False\\n            cur = self.parent[cur]\\n            \\n        # Use to dfs to check if it has atleast one locked descendant\\n        \\n        if self.dfs(num):\\n            self.locked[num] = user\\n            return True\\n        return False\\n    \\n    def dfs(self,i):\\n        par = False\\n        \\n        if self.locked[i]:\\n            self.locked[i] = 0\\n            par = True\\n            \\n        for c in self.children[i]:\\n            par = self.dfs(c) or par\\n            \\n        return par",
                "solutionTags": [],
                "code": "\\n    def __init__(self, parent):\\n        self.parent = parent\\n        self.locked = [0]*len(parent)\\n        self.children = defaultdict(list)\\n        for i in range(1,len(parent)):\\n            self.children[parent[i]].append(i)\\n\\n    def lock(self, num, user):\\n        if self.locked[num] != 0:\\n            return False\\n        \\n        self.locked[num] = user\\n        \\n        return True\\n\\n    def unlock(self, num, user):\\n        if self.locked[num] == user:\\n            self.locked[num] = 0\\n            return True\\n        return False\\n\\n    def upgrade(self, num, user):\\n        cur = num\\n        \\n        # The node is unlocked and it does not have any locked ancestors\\n        \\n        while cur != -1:\\n            if self.locked[cur]:\\n                return False\\n            cur = self.parent[cur]\\n            \\n        # Use to dfs to check if it has atleast one locked descendant\\n        \\n        if self.dfs(num):\\n            self.locked[num] = user\\n            return True\\n        return False\\n    \\n    def dfs(self,i):\\n        par = False\\n        \\n        if self.locked[i]:\\n            self.locked[i] = 0\\n            par = True\\n            \\n        for c in self.children[i]:\\n            par = self.dfs(c) or par\\n            \\n        return par",
                "codeTag": "Python3"
            },
            {
                "id": 2700803,
                "title": "c-beats-97-92",
                "content": "# Performance\\n![\\u622A\\u5C4F2022-10-14 12.12.53.png](https://assets.leetcode.com/users/images/9e4b0676-410d-47cf-98f6-e983e4e29a47_1665720830.0031683.png)\\n\\n\\n# Code\\n```\\nclass LockingTree {\\n    const int n;\\n    vector<int> parent, user_id;\\n    vector<vector<int>> descendents;\\n\\n    bool IsAnyAncestorLocked(int num) {\\n        if (num == -1)\\n            return false;\\n        return user_id[num] != -1 || IsAnyAncestorLocked(parent[num]);\\n    }\\n    \\n    bool unlockDescendents(int num) {\\n        bool ret = false;\\n        for (auto x : descendents[num]) {\\n            ret |= user_id[x] != -1;\\n            user_id[x] = -1;\\n            ret |= unlockDescendents(x);\\n        }\\n        return ret;\\n    }\\n\\npublic:\\n    LockingTree(const vector<int>& parent) : n(size(parent)), parent(parent), user_id(n, -1), descendents(n) {\\n        for(int i = 1; i < n; ++i)\\n            descendents[this->parent[i]].push_back(i);\\n    }\\n\\n    LockingTree(vector<int>&& parent) : n(size(parent)), parent(move(parent)), user_id(n, -1), descendents(n) {\\n        for(int i = 1; i < n; ++i)\\n            descendents[this->parent[i]].push_back(i);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (user_id[num] != -1)\\n            return false;\\n        user_id[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (user_id[num] != user)\\n            return false;\\n        user_id[num] = -1;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (user_id[num] != -1 || IsAnyAncestorLocked(parent[num]) || !unlockDescendents(num))\\n            return false;\\n        user_id[num] = user;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LockingTree {\\n    const int n;\\n    vector<int> parent, user_id;\\n    vector<vector<int>> descendents;\\n\\n    bool IsAnyAncestorLocked(int num) {\\n        if (num == -1)\\n            return false;\\n        return user_id[num] != -1 || IsAnyAncestorLocked(parent[num]);\\n    }\\n    \\n    bool unlockDescendents(int num) {\\n        bool ret = false;\\n        for (auto x : descendents[num]) {\\n            ret |= user_id[x] != -1;\\n            user_id[x] = -1;\\n            ret |= unlockDescendents(x);\\n        }\\n        return ret;\\n    }\\n\\npublic:\\n    LockingTree(const vector<int>& parent) : n(size(parent)), parent(parent), user_id(n, -1), descendents(n) {\\n        for(int i = 1; i < n; ++i)\\n            descendents[this->parent[i]].push_back(i);\\n    }\\n\\n    LockingTree(vector<int>&& parent) : n(size(parent)), parent(move(parent)), user_id(n, -1), descendents(n) {\\n        for(int i = 1; i < n; ++i)\\n            descendents[this->parent[i]].push_back(i);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (user_id[num] != -1)\\n            return false;\\n        user_id[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (user_id[num] != user)\\n            return false;\\n        user_id[num] = -1;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (user_id[num] != -1 || IsAnyAncestorLocked(parent[num]) || !unlockDescendents(num))\\n            return false;\\n        user_id[num] = user;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700667,
                "title": "python-clean-solution-graph-traversal",
                "content": "```\\nclass LockingTree:\\n\\n\\tdef __init__(self, pas: List[int]):\\n\\t\\tself.n = len(pas)\\n\\t\\tself.d2p = pas\\n\\t\\tself.p2d = [[] for _ in range(self.n)]\\n\\t\\tfor i in range(1, len(pas)):\\n\\t\\t\\tself.p2d[pas[i]].append(i)\\n\\t\\tself.locked = [0]*self.n\\n\\n\\tdef lock(self, n: int, x: int) -> bool:\\n\\t\\tif self.locked[n]:\\n\\t\\t\\treturn False\\n\\t\\tself.locked[n] = x\\n\\t\\treturn True\\n\\n\\tdef unlock(self, n: int, x: int) -> bool:\\n\\t\\tif self.locked[n]!=x:\\n\\t\\t\\treturn False\\n\\t\\tself.locked[n] = 0\\n\\t\\treturn True\\n\\n\\tdef upgrade(self, n: int, x: int) -> bool:\\n\\t\\tif self.locked[n]:\\n\\t\\t\\treturn False\\n\\t\\t# checking parents - dfs\\n\\t\\tk = n\\n\\t\\twhile(k>0):\\n\\t\\t\\tk = self.d2p[k]\\n\\t\\t\\tif self.locked[k]:\\n\\t\\t\\t\\treturn False\\n\\t\\t# checking descendant - bfs\\n\\t\\tq, d = deque(self.p2d[n]), set()\\n\\t\\twhile(q):\\n\\t\\t\\tk = q.popleft()\\n\\t\\t\\tif self.locked[k]:\\n\\t\\t\\t\\td.add(k)\\n\\t\\t\\tq.extend(self.p2d[k])\\n\\t\\tif not d:\\n\\t\\t\\treturn False\\n\\t\\tself.locked[n] = x\\n\\t\\tself.locked = [self.locked[i] if i not in d else 0 for i in range(self.n)]\\n\\t\\treturn True\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree:\\n\\n\\tdef __init__(self, pas: List[int]):\\n\\t\\tself.n = len(pas)\\n\\t\\tself.d2p = pas\\n\\t\\tself.p2d = [[] for _ in range(self.n)]\\n\\t\\tfor i in range(1, len(pas)):\\n\\t\\t\\tself.p2d[pas[i]].append(i)\\n\\t\\tself.locked = [0]*self.n\\n\\n\\tdef lock(self, n: int, x: int) -> bool:\\n\\t\\tif self.locked[n]:\\n\\t\\t\\treturn False\\n\\t\\tself.locked[n] = x\\n\\t\\treturn True\\n\\n\\tdef unlock(self, n: int, x: int) -> bool:\\n\\t\\tif self.locked[n]!=x:\\n\\t\\t\\treturn False\\n\\t\\tself.locked[n] = 0\\n\\t\\treturn True\\n\\n\\tdef upgrade(self, n: int, x: int) -> bool:\\n\\t\\tif self.locked[n]:\\n\\t\\t\\treturn False\\n\\t\\t# checking parents - dfs\\n\\t\\tk = n\\n\\t\\twhile(k>0):\\n\\t\\t\\tk = self.d2p[k]\\n\\t\\t\\tif self.locked[k]:\\n\\t\\t\\t\\treturn False\\n\\t\\t# checking descendant - bfs\\n\\t\\tq, d = deque(self.p2d[n]), set()\\n\\t\\twhile(q):\\n\\t\\t\\tk = q.popleft()\\n\\t\\t\\tif self.locked[k]:\\n\\t\\t\\t\\td.add(k)\\n\\t\\t\\tq.extend(self.p2d[k])\\n\\t\\tif not d:\\n\\t\\t\\treturn False\\n\\t\\tself.locked[n] = x\\n\\t\\tself.locked = [self.locked[i] if i not in d else 0 for i in range(self.n)]\\n\\t\\treturn True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680964,
                "title": "python-visualise-readable-solution",
                "content": "**Create a relationship graph**\\n\\n![image](https://assets.leetcode.com/users/images/2083c60b-24c7-40f8-b96c-dc67589aa110_1665312730.1881175.png)\\n\\ndfs in descendants to check if any of the descendants is locked, return True else False\\n\\nFor checking ancestors, traverse the parent list to go to parent and check if its unlocked, if all the ancestors are unlocked return True else False\\n\\n**Note:**\\nCondition 2 is checked at last as we are updating status once we find any one descendant is locked. It will avoid extra dfs to update the status of descendants.\\n\\n\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.relationship = defaultdict(list)\\n        for i, p in enumerate(parent):\\n            self.relationship[p].append(i)\\n        self.status = {i: None for i in range(len(parent))}\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if not self.status[num]:\\n            self.status[num] = user\\n            return True\\n        return False\\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.status[num] == user:\\n            self.status[num] = None\\n            return True\\n        return False\\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        # condition 1 : The node is unlocked\\n        if self.status[num]:\\n            return False\\n        \\n        # condition 3: It does not have any locked ancestors\\n        par = self.parent[num]\\n        while par != -1:\\n            if self.status[par]:\\n                return False\\n            par = self.parent[par]\\n        \\n        # dfs on descendants\\n        def dfs(n):\\n            if self.status[n]:\\n                self.all_descendant_unlocked = False\\n\\t\\t\\t\\t# once atleast one descendant is found to be locked, mark it unlocked\\n                self.status[n] = None\\n            \\n            for d in self.relationship[n]:\\n                dfs(d)\\n        \\n        self.all_descendant_unlocked = True\\n        for d in self.relationship[num]:\\n            dfs(d)\\n        \\n        # condition 2: It has at least one locked descendant (by any user)\\n        if self.all_descendant_unlocked:\\n            return False\\n        \\n        # all 3 condition meets, then\\n        # lock the given node with user\\n        self.status[num] = user\\n        return True\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.relationship = defaultdict(list)\\n        for i, p in enumerate(parent):\\n            self.relationship[p].append(i)\\n        self.status = {i: None for i in range(len(parent))}\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if not self.status[num]:\\n            self.status[num] = user\\n            return True\\n        return False\\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.status[num] == user:\\n            self.status[num] = None\\n            return True\\n        return False\\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        # condition 1 : The node is unlocked\\n        if self.status[num]:\\n            return False\\n        \\n        # condition 3: It does not have any locked ancestors\\n        par = self.parent[num]\\n        while par != -1:\\n            if self.status[par]:\\n                return False\\n            par = self.parent[par]\\n        \\n        # dfs on descendants\\n        def dfs(n):\\n            if self.status[n]:\\n                self.all_descendant_unlocked = False\\n\\t\\t\\t\\t# once atleast one descendant is found to be locked, mark it unlocked\\n                self.status[n] = None\\n            \\n            for d in self.relationship[n]:\\n                dfs(d)\\n        \\n        self.all_descendant_unlocked = True\\n        for d in self.relationship[num]:\\n            dfs(d)\\n        \\n        # condition 2: It has at least one locked descendant (by any user)\\n        if self.all_descendant_unlocked:\\n            return False\\n        \\n        # all 3 condition meets, then\\n        # lock the given node with user\\n        self.status[num] = user\\n        return True\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667476,
                "title": "c-map-build-tree-easy-implementation",
                "content": "```\\nstruct tNode {\\n    int node;\\n    int user;\\n    bool lockStatus; //true = locked, false = unlocked\\n    std::vector<tNode *> child;\\n    tNode *parent;\\n    tNode(int n) : node(n), user(0), lockStatus(false), parent(nullptr){}\\n};\\n\\nclass LockingTree {\\n    std::unordered_map<int, tNode *> map;\\n    tNode *root;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        root = new tNode(0);\\n        map[0] = root;\\n        tNode *node = nullptr;\\n        for (int x = 1; x < parent.size(); x++) {\\n            if (map.find(parent[x]) == map.end()) {\\n                node = new tNode(parent[x]);\\n                map[parent[x]] = node;\\n            }\\n            if (map.find(x) == map.end()) {\\n                node = new tNode(x);\\n                map[x] = node;\\n            }\\n            node = map[x];\\n            node->parent = map[parent[x]];\\n            map[parent[x]]->child.push_back(node);\\n        }\\n    }\\n    \\n    bool isDescendantLocked(tNode *root) {\\n        if (root == nullptr) {\\n            return false;\\n        }\\n        if (root->lockStatus == true) {\\n            return true;\\n        }\\n        for (auto child : root->child) {\\n            if (isDescendantLocked(child)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void unlockAllDescendants(tNode *root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        root->lockStatus = false;\\n        root->user = 0;\\n        for (auto child : root->child) {\\n            unlockAllDescendants(child);\\n        }\\n    }\\n    \\n    bool isAncestorsLocked(tNode *root) {\\n        while (root != nullptr) {\\n            root = root->parent;\\n            if (root != nullptr and root->lockStatus == true) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n        \\n    bool lock(int num, int user) {\\n        if (map[num]->lockStatus == true) {\\n            return false;\\n        }\\n        map[num]->lockStatus = true;\\n        map[num]->user = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (map[num]->lockStatus == false or map[num]->user != user) {\\n            return false;\\n        }\\n        map[num]->lockStatus = false;\\n        map[num]->user = 0;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (map[num]->lockStatus == true or //Condition 1\\n                not isDescendantLocked(map[num]) or //Condition 2\\n                isAncestorsLocked(map[num])) { //Condition 3\\n            return false;\\n        }\\n        unlockAllDescendants(map[num]);\\n        map[num]->lockStatus = true;\\n        map[num]->user = user;\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nstruct tNode {\\n    int node;\\n    int user;\\n    bool lockStatus; //true = locked, false = unlocked\\n    std::vector<tNode *> child;\\n    tNode *parent;\\n    tNode(int n) : node(n), user(0), lockStatus(false), parent(nullptr){}\\n};\\n\\nclass LockingTree {\\n    std::unordered_map<int, tNode *> map;\\n    tNode *root;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        root = new tNode(0);\\n        map[0] = root;\\n        tNode *node = nullptr;\\n        for (int x = 1; x < parent.size(); x++) {\\n            if (map.find(parent[x]) == map.end()) {\\n                node = new tNode(parent[x]);\\n                map[parent[x]] = node;\\n            }\\n            if (map.find(x) == map.end()) {\\n                node = new tNode(x);\\n                map[x] = node;\\n            }\\n            node = map[x];\\n            node->parent = map[parent[x]];\\n            map[parent[x]]->child.push_back(node);\\n        }\\n    }\\n    \\n    bool isDescendantLocked(tNode *root) {\\n        if (root == nullptr) {\\n            return false;\\n        }\\n        if (root->lockStatus == true) {\\n            return true;\\n        }\\n        for (auto child : root->child) {\\n            if (isDescendantLocked(child)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void unlockAllDescendants(tNode *root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        root->lockStatus = false;\\n        root->user = 0;\\n        for (auto child : root->child) {\\n            unlockAllDescendants(child);\\n        }\\n    }\\n    \\n    bool isAncestorsLocked(tNode *root) {\\n        while (root != nullptr) {\\n            root = root->parent;\\n            if (root != nullptr and root->lockStatus == true) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n        \\n    bool lock(int num, int user) {\\n        if (map[num]->lockStatus == true) {\\n            return false;\\n        }\\n        map[num]->lockStatus = true;\\n        map[num]->user = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (map[num]->lockStatus == false or map[num]->user != user) {\\n            return false;\\n        }\\n        map[num]->lockStatus = false;\\n        map[num]->user = 0;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (map[num]->lockStatus == true or //Condition 1\\n                not isDescendantLocked(map[num]) or //Condition 2\\n                isAncestorsLocked(map[num])) { //Condition 3\\n            return false;\\n        }\\n        unlockAllDescendants(map[num]);\\n        map[num]->lockStatus = true;\\n        map[num]->user = user;\\n        return true;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2645340,
                "title": "python-solution-hashmap-tree-visit",
                "content": "# Intuition\\nNothing can be done using the strucutre of the tree, thus O(n) is mandatory for the upgrade primitive.\\n\\n# Approach\\nLock and unlock in O(1) with an hashmap.\\nUpgrade in O(n) with a visit in the tree.\\n\\n# Complexity\\n- Time complexity:\\n    - lock/unlock: O(1);\\n    - upgrade: O(n) \\n\\n- Space complexity:\\nO(n) for auxiliary data structures and visit queue.\\n\\n# Code\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent \\n        n = len(parent)\\n        self.locked = {i : None for i in range(n)}\\n        self.child = defaultdict(list)\\n        for i in range(1, n):\\n            self.child[parent[i]].append(i)  \\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if not self.locked[num]:\\n            self.locked[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] == user:\\n            self.locked[num] = None\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        i = num\\n        while i != -1:\\n            if self.locked[i]: \\n                return False\\n            i = self.parent[i]\\n        q = deque([num])\\n        locked_found = False\\n        while q: \\n            node = q.popleft()\\n            for adj in self.child[node]:\\n                if self.locked[adj]: \\n                    self.locked[adj] = False\\n                    locked_found = True\\n                q.append(adj)\\n        if locked_found:\\n            self.locked[num] = user\\n            return True\\n        return False",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Intuition\\nNothing can be done using the strucutre of the tree, thus O(n) is mandatory for the upgrade primitive.\\n\\n# Approach\\nLock and unlock in O(1) with an hashmap.\\nUpgrade in O(n) with a visit in the tree.\\n\\n# Complexity\\n- Time complexity:\\n    - lock/unlock: O(1);\\n    - upgrade: O(n) \\n\\n- Space complexity:\\nO(n) for auxiliary data structures and visit queue.\\n\\n# Code\\n```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent \\n        n = len(parent)\\n        self.locked = {i : None for i in range(n)}\\n        self.child = defaultdict(list)\\n        for i in range(1, n):\\n            self.child[parent[i]].append(i)  \\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if not self.locked[num]:\\n            self.locked[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] == user:\\n            self.locked[num] = None\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        i = num\\n        while i != -1:\\n            if self.locked[i]: \\n                return False\\n            i = self.parent[i]\\n        q = deque([num])\\n        locked_found = False\\n        while q: \\n            node = q.popleft()\\n            for adj in self.child[node]:\\n                if self.locked[adj]: \\n                    self.locked[adj] = False\\n                    locked_found = True\\n                q.append(adj)\\n        if locked_found:\\n            self.locked[num] = user\\n            return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 2507690,
                "title": "parent-and-child-graphs-boolean-array-locks-iterative-dfs",
                "content": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        n = len(parent)\\n        self.g = [[] for _ in range(n)]\\n        self.locks = [0] * n\\n        \\n        for chi in range(1, n):\\n            par = parent[chi]\\n            self.g[par].append(chi)\\n        \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locks[num] == 0:\\n            self.locks[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        try:\\n            if self.locks[num] == user:\\n                self.locks[num] = 0\\n                return True\\n        except KeyError:\\n            pass\\n        return False\\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locks[num] != 0:\\n            return False\\n        par = self.parent[num]\\n        while par != -1:\\n            if self.locks[par] != 0:\\n                return False\\n            par = self.parent[par]\\n        st = [num]\\n        while st:\\n            cur = st.pop()\\n            st.extend(self.g[cur])\\n            if self.locks[cur] != 0:\\n                self.locks[cur] = 0\\n                break\\n        else:\\n            return False\\n        while st:\\n            cur = st.pop()\\n            self.locks[cur] = 0\\n            st.extend(self.g[cur])\\n        self.locks[num] = user\\n        return True\\n\\n        \\n        \\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        n = len(parent)\\n        self.g = [[] for _ in range(n)]\\n        self.locks = [0] * n\\n        \\n        for chi in range(1, n):\\n            par = parent[chi]\\n            self.g[par].append(chi)\\n        \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locks[num] == 0:\\n            self.locks[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        try:\\n            if self.locks[num] == user:\\n                self.locks[num] = 0\\n                return True\\n        except KeyError:\\n            pass\\n        return False\\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locks[num] != 0:\\n            return False\\n        par = self.parent[num]\\n        while par != -1:\\n            if self.locks[par] != 0:\\n                return False\\n            par = self.parent[par]\\n        st = [num]\\n        while st:\\n            cur = st.pop()\\n            st.extend(self.g[cur])\\n            if self.locks[cur] != 0:\\n                self.locks[cur] = 0\\n                break\\n        else:\\n            return False\\n        while st:\\n            cur = st.pop()\\n            self.locks[cur] = 0\\n            st.extend(self.g[cur])\\n        self.locks[num] = user\\n        return True\\n\\n        \\n        \\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492416,
                "title": "c-simple-ct-o-n-cs-o-n-96-1-fast-96-1-space",
                "content": "```\\nclass LockingTree {\\n    int n;\\n    vector<int> parent;\\n    vector<int> users;\\n    vector<vector<int>> chileds;\\n\\npublic:\\n    LockingTree(vector<int>& parent) : parent(parent) {\\n        int n = parent.size();\\n        chileds.resize(n);\\n        users.resize(n,-1);\\n        for(int i=0; i<n; i++) \\n        {\\n            if(parent[i] == -1) continue;\\n            chileds[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (users[num] != -1) return false;\\n        users[num] = user;\\n        return true;\\n    }\\n    bool unlock(int num, int user) {\\n        if (users[num] != user) return false;\\n        users[num] = -1;\\n        return true;\\n    }\\n    bool unlock_descendants (int num) {\\n        bool got_one = (users[num] != -1);\\n        users[num] = -1;\\n        for(auto chiled : chileds[num])\\n            got_one |=  unlock_descendants (chiled);\\n        return got_one;\\n        \\n    }\\n    bool upgrade(int num, int user) {\\n        int i = num;\\n        while(i != -1)\\n        {\\n            if (users[i] != -1) return false;\\n            i = parent[i];\\n        }\\n        if (!unlock_descendants (num)) return false;\\n        users[num] = user;\\n        return true;\\n     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    int n;\\n    vector<int> parent;\\n    vector<int> users;\\n    vector<vector<int>> chileds;\\n\\npublic:\\n    LockingTree(vector<int>& parent) : parent(parent) {\\n        int n = parent.size();\\n        chileds.resize(n);\\n        users.resize(n,-1);\\n        for(int i=0; i<n; i++) \\n        {\\n            if(parent[i] == -1) continue;\\n            chileds[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (users[num] != -1) return false;\\n        users[num] = user;\\n        return true;\\n    }\\n    bool unlock(int num, int user) {\\n        if (users[num] != user) return false;\\n        users[num] = -1;\\n        return true;\\n    }\\n    bool unlock_descendants (int num) {\\n        bool got_one = (users[num] != -1);\\n        users[num] = -1;\\n        for(auto chiled : chileds[num])\\n            got_one |=  unlock_descendants (chiled);\\n        return got_one;\\n        \\n    }\\n    bool upgrade(int num, int user) {\\n        int i = num;\\n        while(i != -1)\\n        {\\n            if (users[i] != -1) return false;\\n            i = parent[i];\\n        }\\n        if (!unlock_descendants (num)) return false;\\n        users[num] = user;\\n        return true;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428869,
                "title": "simple-and-easy-solution-c",
                "content": "```\\nclass LockingTree {\\npublic:\\n    vector<pair<bool,int>> locked;\\n    vector<vector<int>> adj;\\n    vector<int> parent;\\n    LockingTree(vector<int>& par) {\\n        parent = par;\\n        int n = parent.size();\\n        locked.resize(n,{false,-1});\\n        adj.resize(n);\\n        for(int i=0;i<n;i++){\\n            if(parent[i]!=-1){\\n                adj[parent[i]].push_back(i);\\n                adj[i].push_back(parent[i]);\\n            }\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locked[num].first==false){\\n            locked[num] = {true,user};\\n            return true;\\n        }else return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked[num].first==true && locked[num].second==user){\\n            locked[num]={false,-1};\\n            return true;\\n        }else return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(locked[num].first) return false;\\n        bool anc=false;\\n        int x = num;\\n        while(x!=-1){\\n            if(locked[x].first){\\n                anc=true;\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        if(anc) return false;\\n        int count=0;\\n        queue<pair<int,int>> que;\\n        que.push({num,parent[num]});\\n        while(que.size()>0){\\n            auto [src,par]=que.front();\\n            que.pop();\\n            if(locked[src].first){\\n                count++;\\n                locked[src] = {false,-1};\\n            }\\n            for(int i=0;i<adj[src].size();i++){\\n                if(adj[src][i]!=par){\\n                    que.push({adj[src][i],src});\\n                }\\n            }\\n        }\\n        if(count>=1){\\n            locked[num] = {true,user};\\n            return true;\\n        }else return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<pair<bool,int>> locked;\\n    vector<vector<int>> adj;\\n    vector<int> parent;\\n    LockingTree(vector<int>& par) {\\n        parent = par;\\n        int n = parent.size();\\n        locked.resize(n,{false,-1});\\n        adj.resize(n);\\n        for(int i=0;i<n;i++){\\n            if(parent[i]!=-1){\\n                adj[parent[i]].push_back(i);\\n                adj[i].push_back(parent[i]);\\n            }\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locked[num].first==false){\\n            locked[num] = {true,user};\\n            return true;\\n        }else return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked[num].first==true && locked[num].second==user){\\n            locked[num]={false,-1};\\n            return true;\\n        }else return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(locked[num].first) return false;\\n        bool anc=false;\\n        int x = num;\\n        while(x!=-1){\\n            if(locked[x].first){\\n                anc=true;\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        if(anc) return false;\\n        int count=0;\\n        queue<pair<int,int>> que;\\n        que.push({num,parent[num]});\\n        while(que.size()>0){\\n            auto [src,par]=que.front();\\n            que.pop();\\n            if(locked[src].first){\\n                count++;\\n                locked[src] = {false,-1};\\n            }\\n            for(int i=0;i<adj[src].size();i++){\\n                if(adj[src][i]!=par){\\n                    que.push({adj[src][i],src});\\n                }\\n            }\\n        }\\n        if(count>=1){\\n            locked[num] = {true,user};\\n            return true;\\n        }else return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420911,
                "title": "go-lang-solution",
                "content": "```\\ntype LockingTree struct {\\n    Id int\\n    IsLocked bool\\n    LockedBy int\\n    NoOfLockedChilds int\\n    Par int\\n    Childs []int\\n}\\n\\nvar(\\n    id_Nodes = make(map[int] *LockingTree)\\n    root *LockingTree\\n)\\nfunc Constructor(parent []int) LockingTree {\\n    n:=len(parent)\\n    for i:=0;i<n;i++{\\n        var node LockingTree\\n        node.Id = i\\n        node.IsLocked = false\\n        node.LockedBy = -1\\n        node.NoOfLockedChilds = 0\\n        node.Par = parent[i]\\n        //log.Println(node)\\n        id_Nodes[i] = &node\\n    }\\n    \\n    for i:=0;i<n;i++{\\n        p_id:=parent[i]\\n        if p_id == -1{\\n            root = id_Nodes[i]\\n        }else{\\n            id_Nodes[p_id].Childs = append(id_Nodes[p_id].Childs,i)\\n        }\\n    }\\n    return *root\\n    \\n}\\n\\n\\nfunc (this *LockingTree) Lock(num int, user int) bool {\\n    node:=id_Nodes[num]\\n    if !node.IsLocked{\\n        node.IsLocked=true\\n        node.LockedBy = user\\n        par:=node.Par\\n        for par!=-1{\\n            (id_Nodes[par]).NoOfLockedChilds++\\n            par = id_Nodes[par].Par\\n        }\\n        return true\\n    }\\n    return false\\n}\\n\\n\\nfunc (this *LockingTree) Unlock(num int, user int) bool {\\n    node:=id_Nodes[num]\\n    if node.IsLocked && node.LockedBy == user{\\n        node.IsLocked=false\\n        node.LockedBy = -1\\n        par:=node.Par\\n        for par!=-1{\\n            (id_Nodes[par]).NoOfLockedChilds--\\n            par = id_Nodes[par].Par\\n        }\\n        return true\\n    }\\n    return false\\n}\\n\\n\\nfunc (this *LockingTree) Upgrade(num int, user int) bool {\\n    node:=id_Nodes[num]\\n    if node.IsLocked{\\n        return false\\n    }\\n    if node.NoOfLockedChilds == 0{\\n        return false\\n    }\\n    par:=node.Par\\n    for par!=-1{\\n        if id_Nodes[par].IsLocked{\\n            return false\\n        }\\n        par = id_Nodes[par].Par\\n    }\\n    node.IsLocked = true\\n    node.LockedBy = user\\n    n := len(node.Childs)\\n    for i:=0;i<n;i++{\\n        dfs(id_Nodes[node.Childs[i]])\\n    }\\n    return true\\n    \\n}\\n\\nfunc dfs(node *LockingTree) {\\n    if node.IsLocked{\\n        node.IsLocked = false\\n        node.LockedBy = -1\\n    }\\n    n := len(node.Childs)\\n    for i:=0;i<n;i++{\\n        dfs(id_Nodes[node.Childs[i]])\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype LockingTree struct {\\n    Id int\\n    IsLocked bool\\n    LockedBy int\\n    NoOfLockedChilds int\\n    Par int\\n    Childs []int\\n}\\n\\nvar(\\n    id_Nodes = make(map[int] *LockingTree)\\n    root *LockingTree\\n)\\nfunc Constructor(parent []int) LockingTree {\\n    n:=len(parent)\\n    for i:=0;i<n;i++{\\n        var node LockingTree\\n        node.Id = i\\n        node.IsLocked = false\\n        node.LockedBy = -1\\n        node.NoOfLockedChilds = 0\\n        node.Par = parent[i]\\n        //log.Println(node)\\n        id_Nodes[i] = &node\\n    }\\n    \\n    for i:=0;i<n;i++{\\n        p_id:=parent[i]\\n        if p_id == -1{\\n            root = id_Nodes[i]\\n        }else{\\n            id_Nodes[p_id].Childs = append(id_Nodes[p_id].Childs,i)\\n        }\\n    }\\n    return *root\\n    \\n}\\n\\n\\nfunc (this *LockingTree) Lock(num int, user int) bool {\\n    node:=id_Nodes[num]\\n    if !node.IsLocked{\\n        node.IsLocked=true\\n        node.LockedBy = user\\n        par:=node.Par\\n        for par!=-1{\\n            (id_Nodes[par]).NoOfLockedChilds++\\n            par = id_Nodes[par].Par\\n        }\\n        return true\\n    }\\n    return false\\n}\\n\\n\\nfunc (this *LockingTree) Unlock(num int, user int) bool {\\n    node:=id_Nodes[num]\\n    if node.IsLocked && node.LockedBy == user{\\n        node.IsLocked=false\\n        node.LockedBy = -1\\n        par:=node.Par\\n        for par!=-1{\\n            (id_Nodes[par]).NoOfLockedChilds--\\n            par = id_Nodes[par].Par\\n        }\\n        return true\\n    }\\n    return false\\n}\\n\\n\\nfunc (this *LockingTree) Upgrade(num int, user int) bool {\\n    node:=id_Nodes[num]\\n    if node.IsLocked{\\n        return false\\n    }\\n    if node.NoOfLockedChilds == 0{\\n        return false\\n    }\\n    par:=node.Par\\n    for par!=-1{\\n        if id_Nodes[par].IsLocked{\\n            return false\\n        }\\n        par = id_Nodes[par].Par\\n    }\\n    node.IsLocked = true\\n    node.LockedBy = user\\n    n := len(node.Childs)\\n    for i:=0;i<n;i++{\\n        dfs(id_Nodes[node.Childs[i]])\\n    }\\n    return true\\n    \\n}\\n\\nfunc dfs(node *LockingTree) {\\n    if node.IsLocked{\\n        node.IsLocked = false\\n        node.LockedBy = -1\\n    }\\n    n := len(node.Childs)\\n    for i:=0;i<n;i++{\\n        dfs(id_Nodes[node.Childs[i]])\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2361062,
                "title": "elegant-efficient-c-solution-avoid-searching-for-locked-ancestor-or-descendant",
                "content": "I think most of the solution I have seen require you to search for a locked ancestor or go down the tree and search for at least a locked descendant and you also must look of any locked ancestor. \\nIn my solution I keep a node structure with the information about the number of locked nodes up and down from a given node. Lock/unlock operations updates the values up and downstream of a given node so that these info is always updated and correct.\\n\\nAll the operations are implemented using an helper function that takes three other function as input. A function to be applied on the target node e.g. when implementing lock you want to set it locked if you can. A function to be applied to all descendant: if you are implementing a lock operation for instance you might want to have this function update a descendant by adding 1 to the number of locked ancestors. \\nunlock and upgrade are implemented likewise. \\n\\n\\n\\n```\\nclass LockingTree {\\n    struct Node{\\n        bool locked{};\\n        int user{};\\n        int lockedUp{};\\n        int lockedDown{};\\n        std::vector<int> children;\\n        int parent{};\\n    };\\n    \\n    std::vector<Node> T;\\n    const size_t numNodes;\\npublic:\\n    LockingTree(vector<int>& parent) : numNodes{parent.size()}{\\n        T.resize(numNodes);\\n        Node root;\\n        for(int i = 1 ; i < numNodes ;i++){\\n            T[parent[i]].children.push_back(i);\\n            T[i].parent = parent[i];\\n        }\\n    }\\n    \\n    template<typename Fn>\\n    void applyDescendant(const int& node, Fn& fn){\\n        if(node < 0|| node>=numNodes)\\n            return;\\n        fn(T[node]);\\n        for(const auto& neigh : T[node].children){\\n            applyDescendant(neigh, fn);\\n        }\\n    }\\n    \\n    template<typename FnNode, typename FnAncestor, typename FnDescendant>\\n    bool lockUnlockHelper(const int node, const int user, FnNode& fnNode, FnAncestor& fnAncestor, FnDescendant& fnDescendant) {\\n        if(node >= numNodes )\\n            return false;\\n        \\n    \\n        int numLockedDown = T[node].lockedDown;\\n        if( fnNode(T[node]) ){\\n            //update descendant\\n            for(const auto& neigh : T[node].children){\\n                applyDescendant(neigh, fnDescendant);\\n            }\\n        }else{\\n            return false;//could not lock/unlock\\n        }\\n        \\n        //upodate ancestors\\n        int currNode = node;\\n        int currParent = T[currNode].parent;\\n        while(currParent != currNode){\\n            fnAncestor(T[currParent], numLockedDown);\\n            currNode = currParent;\\n            currParent = T[currNode].parent;\\n        }\\n        return true;\\n        \\n    }\\n    \\n    bool lock(int num, int user) {\\n        auto fnNode = [=](auto& node ){\\n            if(!node.locked){\\n                node.locked = true;\\n                node.user = user;\\n                return true;\\n            }\\n            return false;\\n        };\\n        \\n        auto fnDescendant = [=]( auto& node ){\\n            node.lockedUp++;\\n        };\\n        \\n        auto fnAncestor = [=]( auto& node ,const auto& applications){\\n            node.lockedDown++;\\n        };\\n        \\n        return lockUnlockHelper(num, user, fnNode, fnAncestor, fnDescendant);\\n        \\n    }\\n    \\n    bool unlock(int num, int user) {\\n        auto fnNode = [=](auto& node ){\\n            if(node.locked && node.user ==user){\\n                node.locked = false;\\n                node.user = -1;\\n                return true;\\n            }\\n            return false;\\n        };\\n        \\n        auto fnDescendant = [=]( auto& node ){\\n            node.lockedUp--;\\n\\n        };\\n        \\n        auto fnAncestor = [=]( auto& node , const auto&){\\n            node.lockedDown--;\\n        };\\n        \\n        return lockUnlockHelper( num, user, fnNode, fnAncestor, fnDescendant);\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n         auto fnNode = [=](auto& node ){\\n             if(!node.locked && node.lockedDown>0 && node.lockedUp ==0){\\n                node.locked = true;\\n                node.user = user;\\n                return true;\\n            }\\n            return false;\\n        };\\n        \\n        auto fnDescendant = [=]( auto& node ){\\n            node.locked = false;\\n            node.user = -1;\\n            node.lockedDown = 0;\\n            node.lockedUp++;\\n        };\\n        \\n        auto fnAncestor = [=]( auto& node,const auto& applications){\\n            node.lockedDown++;\\n            node.lockedDown-=applications;\\n        };\\n        return lockUnlockHelper( num, user, fnNode, fnAncestor, fnDescendant);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    struct Node{\\n        bool locked{};\\n        int user{};\\n        int lockedUp{};\\n        int lockedDown{};\\n        std::vector<int> children;\\n        int parent{};\\n    };\\n    \\n    std::vector<Node> T;\\n    const size_t numNodes;\\npublic:\\n    LockingTree(vector<int>& parent) : numNodes{parent.size()}{\\n        T.resize(numNodes);\\n        Node root;\\n        for(int i = 1 ; i < numNodes ;i++){\\n            T[parent[i]].children.push_back(i);\\n            T[i].parent = parent[i];\\n        }\\n    }\\n    \\n    template<typename Fn>\\n    void applyDescendant(const int& node, Fn& fn){\\n        if(node < 0|| node>=numNodes)\\n            return;\\n        fn(T[node]);\\n        for(const auto& neigh : T[node].children){\\n            applyDescendant(neigh, fn);\\n        }\\n    }\\n    \\n    template<typename FnNode, typename FnAncestor, typename FnDescendant>\\n    bool lockUnlockHelper(const int node, const int user, FnNode& fnNode, FnAncestor& fnAncestor, FnDescendant& fnDescendant) {\\n        if(node >= numNodes )\\n            return false;\\n        \\n    \\n        int numLockedDown = T[node].lockedDown;\\n        if( fnNode(T[node]) ){\\n            //update descendant\\n            for(const auto& neigh : T[node].children){\\n                applyDescendant(neigh, fnDescendant);\\n            }\\n        }else{\\n            return false;//could not lock/unlock\\n        }\\n        \\n        //upodate ancestors\\n        int currNode = node;\\n        int currParent = T[currNode].parent;\\n        while(currParent != currNode){\\n            fnAncestor(T[currParent], numLockedDown);\\n            currNode = currParent;\\n            currParent = T[currNode].parent;\\n        }\\n        return true;\\n        \\n    }\\n    \\n    bool lock(int num, int user) {\\n        auto fnNode = [=](auto& node ){\\n            if(!node.locked){\\n                node.locked = true;\\n                node.user = user;\\n                return true;\\n            }\\n            return false;\\n        };\\n        \\n        auto fnDescendant = [=]( auto& node ){\\n            node.lockedUp++;\\n        };\\n        \\n        auto fnAncestor = [=]( auto& node ,const auto& applications){\\n            node.lockedDown++;\\n        };\\n        \\n        return lockUnlockHelper(num, user, fnNode, fnAncestor, fnDescendant);\\n        \\n    }\\n    \\n    bool unlock(int num, int user) {\\n        auto fnNode = [=](auto& node ){\\n            if(node.locked && node.user ==user){\\n                node.locked = false;\\n                node.user = -1;\\n                return true;\\n            }\\n            return false;\\n        };\\n        \\n        auto fnDescendant = [=]( auto& node ){\\n            node.lockedUp--;\\n\\n        };\\n        \\n        auto fnAncestor = [=]( auto& node , const auto&){\\n            node.lockedDown--;\\n        };\\n        \\n        return lockUnlockHelper( num, user, fnNode, fnAncestor, fnDescendant);\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n         auto fnNode = [=](auto& node ){\\n             if(!node.locked && node.lockedDown>0 && node.lockedUp ==0){\\n                node.locked = true;\\n                node.user = user;\\n                return true;\\n            }\\n            return false;\\n        };\\n        \\n        auto fnDescendant = [=]( auto& node ){\\n            node.locked = false;\\n            node.user = -1;\\n            node.lockedDown = 0;\\n            node.lockedUp++;\\n        };\\n        \\n        auto fnAncestor = [=]( auto& node,const auto& applications){\\n            node.lockedDown++;\\n            node.lockedDown-=applications;\\n        };\\n        return lockUnlockHelper( num, user, fnNode, fnAncestor, fnDescendant);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346646,
                "title": "c",
                "content": "```\\nclass LockingTree {\\npublic:\\n    map<int,int> map;\\n    vector<int> ans;\\n    vector<vector<int>> t;\\n    LockingTree(vector<int>& parent) {\\n        \\n        t.resize(parent.size());\\n        \\n        \\n        ans.resize(parent.size());\\n        ans[0] = -1;\\n        \\n        for(int i = 1; i < parent.size(); i++) {\\n            t[parent[i]].push_back(i);\\n            ans[i] = parent[i];\\n        }\\n        \\n        // for(int i = 0; i < ans.size(); i++) {\\n        //     cout<<ans[i]<<endl;\\n        // }\\n        \\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(map.count(num)) return false;\\n        map[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(!map.count(num)) return false;\\n        if(map[num] != user) return false;\\n        map.erase(num);\\n        return 1;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(map.count(num)) return false;\\n        if(!dfs(num)) {\\n            // cout<<\"yes\"<<endl;\\n            return false;\\n        }\\n        \\n        // cout<<\"asd\"<<endl;\\n        if(!check(num)) return false;\\n        \\n        \\n        dfs1(num);\\n        map[num] = user;\\n        return true;\\n        \\n    }\\n    \\n    bool dfs(int num) {\\n        if(t[num].size() == 0) return false;\\n        for(auto i : t[num]) {\\n            \\n            if(map.count(i)) {\\n                return true;\\n            }\\n            \\n            if(dfs(i)) return true;\\n            \\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    void dfs1(int num) {\\n        for(auto i : t[num]) {\\n            map.erase(i);\\n            dfs1(i);\\n        }\\n    }\\n    \\n    bool check(int num) {\\n        while(num != -1) {\\n            num = ans[num];\\n            if(map.count(num)) return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\npublic:\\n    map<int,int> map;\\n    vector<int> ans;\\n    vector<vector<int>> t;\\n    LockingTree(vector<int>& parent) {\\n        \\n        t.resize(parent.size());\\n        \\n        \\n        ans.resize(parent.size());\\n        ans[0] = -1;\\n        \\n        for(int i = 1; i < parent.size(); i++) {\\n            t[parent[i]].push_back(i);\\n            ans[i] = parent[i];\\n        }\\n        \\n        // for(int i = 0; i < ans.size(); i++) {\\n        //     cout<<ans[i]<<endl;\\n        // }\\n        \\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(map.count(num)) return false;\\n        map[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(!map.count(num)) return false;\\n        if(map[num] != user) return false;\\n        map.erase(num);\\n        return 1;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(map.count(num)) return false;\\n        if(!dfs(num)) {\\n            // cout<<\"yes\"<<endl;\\n            return false;\\n        }\\n        \\n        // cout<<\"asd\"<<endl;\\n        if(!check(num)) return false;\\n        \\n        \\n        dfs1(num);\\n        map[num] = user;\\n        return true;\\n        \\n    }\\n    \\n    bool dfs(int num) {\\n        if(t[num].size() == 0) return false;\\n        for(auto i : t[num]) {\\n            \\n            if(map.count(i)) {\\n                return true;\\n            }\\n            \\n            if(dfs(i)) return true;\\n            \\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    void dfs1(int num) {\\n        for(auto i : t[num]) {\\n            map.erase(i);\\n            dfs1(i);\\n        }\\n    }\\n    \\n    bool check(int num) {\\n        while(num != -1) {\\n            num = ans[num];\\n            if(map.count(num)) return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2211519,
                "title": "easy-python-solution",
                "content": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked = [None]*len(parent)\\n        self.child = {i:[] for i in range(len(parent))}\\n        for i in range(1,len(parent)):\\n            self.child[parent[i]].append(i)\\n        \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]:\\n            return False\\n        self.locked[num] = user\\n        return True\\n        \\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] != user:\\n            return False\\n        self.locked[num] = None\\n        return True\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        i = num\\n        while i != -1:\\n            if self.locked[i]:\\n                return False\\n            i = self.parent[i]\\n        \\n        lockedCount, q = 0, deque([num])\\n        while q:\\n            n = q.popleft()\\n            if self.locked[n]:\\n                self.locked[n] = None\\n                lockedCount += 1\\n            q.extend(self.child[n])\\n            \\n        if lockedCount > 0:\\n            self.locked[num] = user\\n        return lockedCount > 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked = [None]*len(parent)\\n        self.child = {i:[] for i in range(len(parent))}\\n        for i in range(1,len(parent)):\\n            self.child[parent[i]].append(i)\\n        \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]:\\n            return False\\n        self.locked[num] = user\\n        return True\\n        \\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] != user:\\n            return False\\n        self.locked[num] = None\\n        return True\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        i = num\\n        while i != -1:\\n            if self.locked[i]:\\n                return False\\n            i = self.parent[i]\\n        \\n        lockedCount, q = 0, deque([num])\\n        while q:\\n            n = q.popleft()\\n            if self.locked[n]:\\n                self.locked[n] = None\\n                lockedCount += 1\\n            q.extend(self.child[n])\\n            \\n        if lockedCount > 0:\\n            self.locked[num] = user\\n        return lockedCount > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159468,
                "title": "java-basic-solution-and-little-optimized-solution",
                "content": "**Normal Brute-force Approach :**\\nHere, we check both Ancestors and Decendants for each **upgrade()** call\\n```\\nclass LockingTree {\\n    int n;\\n    List<List<Integer>> adj;\\n    HashMap<Integer, Node> map;\\n    HashMap<Integer, Integer> lock;\\n\\n    public LockingTree(int[] parent) {\\n        n = parent.length;\\n        adj = new ArrayList<>();\\n        map = new HashMap<>();\\n        lock = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) \\n            map.put(i, new Node(i));\\n\\n        for (int i = 0; i < parent.length; i++) {\\n            if (parent[i] == -1) continue;\\n            map.get(parent[i]).children.add(map.get(i));\\n            map.get(i).par = map.get(parent[i]);\\n        }\\n    }\\n\\n    public boolean lock(int num, int user) {\\n        if (lock.containsKey(num))\\n            return false;\\n        \\n        lock.put(num, user);\\n        \\n        return true;\\n    }\\n\\n    public boolean unlock(int num, int user) {\\n        if (lock.containsKey(num)) {\\n            int lockedUser = lock.get(num);\\n            if (user != lockedUser) \\n                return false;\\n            \\n            lock.remove(num);\\n           \\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean upgrade(int num, int user) {\\n    \\n        if(lock.containsKey(num)) \\n            return false;\\n        \\n        Node node = map.get(num);\\n        \\n        int desCount = countDesc(node);\\n        int ancCount = countAnc(node);\\n       \\n        if(desCount==0)\\n            return false;\\n        \\n        if(ancCount>=1)\\n            return false;\\n        \\n        unlockDes(node);\\n        lock.put(num, user);\\n       \\n        return true;\\n    }\\n    \\n    private int countDesc(Node node){\\n        List<Node> children = node.children;\\n        \\n        int count = 0;\\n        \\n        for(Node child: children){\\n            count += countDesc(child);\\n        }\\n        \\n        if(lock.containsKey(node.num))\\n            count++;\\n        \\n        return count;\\n    }\\n    \\n    private int countAnc(Node node){\\n        int count = 0;\\n        \\n        while(node!=null){\\n            if(lock.containsKey(node.num))\\n                count++;\\n            \\n            node = node.par;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private void unlockDes(Node node){\\n        List<Node> children = node.children;\\n        \\n        if(lock.containsKey(node.num))\\n            lock.remove(node.num);\\n        \\n        for(Node child: children){\\n            unlockDes(child);\\n        }\\n        \\n    }\\n}\\n\\nclass Node {\\n    int num;\\n    List<Node> children;\\n    Node par;\\n    Node() {\\n        children = new ArrayList<>();\\n    }\\n\\n    Node(int num) {\\n        this.num = num;\\n        children = new ArrayList<>();\\n    }\\n}\\n```\\n\\n**Little Bit Optimized Approach :**\\nHere, we only check ancestors, where for decendants we keep track of count of decendants that are locked.\\n```\\nclass LockingTree {\\n    int n;\\n    List<List<Integer>> adj;\\n    HashMap<Integer, Node> map;\\n    HashMap<Integer, Integer> lock;\\n\\n    public LockingTree(int[] parent) {\\n        n = parent.length;\\n        adj = new ArrayList<>();\\n        map = new HashMap<>();\\n        lock = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) \\n            map.put(i, new Node(i));\\n\\n        for (int i = 0; i < parent.length; i++) {\\n            if (parent[i] == -1) continue;\\n            map.get(parent[i]).children.add(map.get(i));\\n            map.get(i).par = map.get(parent[i]);\\n        }\\n    }\\n\\n    public boolean lock(int num, int user) {\\n        if (lock.containsKey(num))\\n            return false;\\n        \\n        lock.put(num, user);\\n        \\n        incrementOrDecrementDesCountForAncestors(map.get(num).par,true);\\n        \\n        return true;\\n    }\\n\\n    public boolean unlock(int num, int user) {\\n        if (lock.containsKey(num)) {\\n            int lockedUser = lock.get(num);\\n            if (user != lockedUser) \\n                return false;\\n            \\n            incrementOrDecrementDesCountForAncestors(map.get(num).par, false);\\n                \\n            lock.remove(num);\\n           \\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean upgrade(int num, int user) {\\n    \\n        if(lock.containsKey(num)) \\n            return false;\\n        \\n        Node node = map.get(num);\\n       \\n        if(node.desCount==0)\\n            return false;\\n        \\n        if(containsAncestor(node))\\n            return false;\\n        \\n        unlockDes(node);\\n        lock.put(num, user);\\n       \\n        return true;\\n    }\\n    \\n    private boolean containsAncestor(Node node){\\n        \\n        while(node!=null){\\n            if(lock.containsKey(node.num))\\n                return true;\\n            \\n            node = node.par;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void unlockDes(Node node){\\n        List<Node> children = node.children;\\n        \\n        if(lock.containsKey(node.num))\\n            lock.remove(node.num);\\n        \\n        for(Node child: children){\\n            unlockDes(child);\\n        }\\n        \\n    }\\n    \\n    private void incrementOrDecrementDesCountForAncestors(Node node, boolean shouldIncrement){\\n        if(shouldIncrement)\\n        {\\n            while(node!=null){\\n                node.desCount++;\\n                node = node.par;\\n            }\\n            return;\\n        }\\n        while(node!=null){\\n                node.desCount--;\\n                node = node.par;\\n            }\\n    }\\n}\\n\\nclass Node {\\n    int num;\\n    List<Node> children;\\n    Node par;\\n    int desCount;\\n    Node() {\\n        children = new ArrayList<>();\\n    }\\n\\n    Node(int num) {\\n        this.num = num;\\n        children = new ArrayList<>();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\n    int n;\\n    List<List<Integer>> adj;\\n    HashMap<Integer, Node> map;\\n    HashMap<Integer, Integer> lock;\\n\\n    public LockingTree(int[] parent) {\\n        n = parent.length;\\n        adj = new ArrayList<>();\\n        map = new HashMap<>();\\n        lock = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) \\n            map.put(i, new Node(i));\\n\\n        for (int i = 0; i < parent.length; i++) {\\n            if (parent[i] == -1) continue;\\n            map.get(parent[i]).children.add(map.get(i));\\n            map.get(i).par = map.get(parent[i]);\\n        }\\n    }\\n\\n    public boolean lock(int num, int user) {\\n        if (lock.containsKey(num))\\n            return false;\\n        \\n        lock.put(num, user);\\n        \\n        return true;\\n    }\\n\\n    public boolean unlock(int num, int user) {\\n        if (lock.containsKey(num)) {\\n            int lockedUser = lock.get(num);\\n            if (user != lockedUser) \\n                return false;\\n            \\n            lock.remove(num);\\n           \\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean upgrade(int num, int user) {\\n    \\n        if(lock.containsKey(num)) \\n            return false;\\n        \\n        Node node = map.get(num);\\n        \\n        int desCount = countDesc(node);\\n        int ancCount = countAnc(node);\\n       \\n        if(desCount==0)\\n            return false;\\n        \\n        if(ancCount>=1)\\n            return false;\\n        \\n        unlockDes(node);\\n        lock.put(num, user);\\n       \\n        return true;\\n    }\\n    \\n    private int countDesc(Node node){\\n        List<Node> children = node.children;\\n        \\n        int count = 0;\\n        \\n        for(Node child: children){\\n            count += countDesc(child);\\n        }\\n        \\n        if(lock.containsKey(node.num))\\n            count++;\\n        \\n        return count;\\n    }\\n    \\n    private int countAnc(Node node){\\n        int count = 0;\\n        \\n        while(node!=null){\\n            if(lock.containsKey(node.num))\\n                count++;\\n            \\n            node = node.par;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private void unlockDes(Node node){\\n        List<Node> children = node.children;\\n        \\n        if(lock.containsKey(node.num))\\n            lock.remove(node.num);\\n        \\n        for(Node child: children){\\n            unlockDes(child);\\n        }\\n        \\n    }\\n}\\n\\nclass Node {\\n    int num;\\n    List<Node> children;\\n    Node par;\\n    Node() {\\n        children = new ArrayList<>();\\n    }\\n\\n    Node(int num) {\\n        this.num = num;\\n        children = new ArrayList<>();\\n    }\\n}\\n```\n```\\nclass LockingTree {\\n    int n;\\n    List<List<Integer>> adj;\\n    HashMap<Integer, Node> map;\\n    HashMap<Integer, Integer> lock;\\n\\n    public LockingTree(int[] parent) {\\n        n = parent.length;\\n        adj = new ArrayList<>();\\n        map = new HashMap<>();\\n        lock = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) \\n            map.put(i, new Node(i));\\n\\n        for (int i = 0; i < parent.length; i++) {\\n            if (parent[i] == -1) continue;\\n            map.get(parent[i]).children.add(map.get(i));\\n            map.get(i).par = map.get(parent[i]);\\n        }\\n    }\\n\\n    public boolean lock(int num, int user) {\\n        if (lock.containsKey(num))\\n            return false;\\n        \\n        lock.put(num, user);\\n        \\n        incrementOrDecrementDesCountForAncestors(map.get(num).par,true);\\n        \\n        return true;\\n    }\\n\\n    public boolean unlock(int num, int user) {\\n        if (lock.containsKey(num)) {\\n            int lockedUser = lock.get(num);\\n            if (user != lockedUser) \\n                return false;\\n            \\n            incrementOrDecrementDesCountForAncestors(map.get(num).par, false);\\n                \\n            lock.remove(num);\\n           \\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean upgrade(int num, int user) {\\n    \\n        if(lock.containsKey(num)) \\n            return false;\\n        \\n        Node node = map.get(num);\\n       \\n        if(node.desCount==0)\\n            return false;\\n        \\n        if(containsAncestor(node))\\n            return false;\\n        \\n        unlockDes(node);\\n        lock.put(num, user);\\n       \\n        return true;\\n    }\\n    \\n    private boolean containsAncestor(Node node){\\n        \\n        while(node!=null){\\n            if(lock.containsKey(node.num))\\n                return true;\\n            \\n            node = node.par;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void unlockDes(Node node){\\n        List<Node> children = node.children;\\n        \\n        if(lock.containsKey(node.num))\\n            lock.remove(node.num);\\n        \\n        for(Node child: children){\\n            unlockDes(child);\\n        }\\n        \\n    }\\n    \\n    private void incrementOrDecrementDesCountForAncestors(Node node, boolean shouldIncrement){\\n        if(shouldIncrement)\\n        {\\n            while(node!=null){\\n                node.desCount++;\\n                node = node.par;\\n            }\\n            return;\\n        }\\n        while(node!=null){\\n                node.desCount--;\\n                node = node.par;\\n            }\\n    }\\n}\\n\\nclass Node {\\n    int num;\\n    List<Node> children;\\n    Node par;\\n    int desCount;\\n    Node() {\\n        children = new ArrayList<>();\\n    }\\n\\n    Node(int num) {\\n        this.num = num;\\n        children = new ArrayList<>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137344,
                "title": "can-anyone-please-explain-why-precomputed-takes-more-time",
                "content": "\\nclass LockingTree {\\n\\n    int n=0;\\n    int lock[];\\n    HashMap<Integer, HashSet<Integer>> des=new HashMap<>();\\n    HashMap<Integer, HashSet<Integer>> aen=new HashMap<>();\\n    HashMap<Integer, HashSet<Integer>> graph=new HashMap<>();\\n    public LockingTree(int[] parent) {\\n        n=parent.length;\\n        lock=new int[n];\\n        Arrays.fill(lock,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            des.put(i,new HashSet());\\n            aen.put(i,new HashSet());\\n            graph.put(i,new HashSet());\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n             HashSet<Integer> temp1=graph.get(parent[i]);\\n             temp1.add(i);\\n        }\\n        \\n        helperaen(parent);\\n        helperdes(0);\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(lock[num]==-1){\\n            lock[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(lock[num]==user){\\n            lock[num]=-1;\\n            return true;\\n        }\\n        return false;        \\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n\\n         if(lock[num]!=-1){\\n            return false;\\n        }\\n\\n        boolean lockfound=false;\\n        for(int x:des.get(num)){\\n            if(lock[x]!=-1){lockfound=true;break;}\\n        }\\n        if(!lockfound)return false;\\n\\n        \\n        boolean lockfoundparent=false;\\n        for(int x:aen.get(num)){\\n            if(lock[x]!=-1){lockfoundparent=true;break;}\\n        }\\n         if(lockfoundparent)return false;\\n        \\n        \\n         //free every lock\\n         for(int x:des.get(num)){\\n            if(lock[x]!=-1)lock[x]=-1;\\n        }\\n        lock[num]=user;\\n        return true;\\n    }\\n    \\n    private void helperaen(int parent[]){\\n        \\n        Queue<Integer> q=new LinkedList();\\n        q.add(0);\\n       while(!q.isEmpty()){         \\n            int start=q.poll();\\n           for(int x:graph.get(start)){\\n               q.add(x);\\n           }           \\n           if(start==0)continue;\\n            HashSet<Integer> temp1=aen.get(start);\\n            temp1.addAll(aen.get(parent[start]));\\n            temp1.add(parent[start]);\\n        }\\n    }\\n    \\n    private HashSet<Integer> helperdes(int root){\\n        HashSet<Integer> total=des.get(root);\\n          for(int x:graph.get(root)){\\n               total.addAll(helperdes(x));\\n               total.add(x);\\n           }\\n        \\n        return total;   \\n    }\\n}\\n\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */",
                "solutionTags": [],
                "code": "\\nclass LockingTree {\\n\\n    int n=0;\\n    int lock[];\\n    HashMap<Integer, HashSet<Integer>> des=new HashMap<>();\\n    HashMap<Integer, HashSet<Integer>> aen=new HashMap<>();\\n    HashMap<Integer, HashSet<Integer>> graph=new HashMap<>();\\n    public LockingTree(int[] parent) {\\n        n=parent.length;\\n        lock=new int[n];\\n        Arrays.fill(lock,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            des.put(i,new HashSet());\\n            aen.put(i,new HashSet());\\n            graph.put(i,new HashSet());\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n             HashSet<Integer> temp1=graph.get(parent[i]);\\n             temp1.add(i);\\n        }\\n        \\n        helperaen(parent);\\n        helperdes(0);\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(lock[num]==-1){\\n            lock[num]=user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(lock[num]==user){\\n            lock[num]=-1;\\n            return true;\\n        }\\n        return false;        \\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n\\n         if(lock[num]!=-1){\\n            return false;\\n        }\\n\\n        boolean lockfound=false;\\n        for(int x:des.get(num)){\\n            if(lock[x]!=-1){lockfound=true;break;}\\n        }\\n        if(!lockfound)return false;\\n\\n        \\n        boolean lockfoundparent=false;\\n        for(int x:aen.get(num)){\\n            if(lock[x]!=-1){lockfoundparent=true;break;}\\n        }\\n         if(lockfoundparent)return false;\\n        \\n        \\n         //free every lock\\n         for(int x:des.get(num)){\\n            if(lock[x]!=-1)lock[x]=-1;\\n        }\\n        lock[num]=user;\\n        return true;\\n    }\\n    \\n    private void helperaen(int parent[]){\\n        \\n        Queue<Integer> q=new LinkedList();\\n        q.add(0);\\n       while(!q.isEmpty()){         \\n            int start=q.poll();\\n           for(int x:graph.get(start)){\\n               q.add(x);\\n           }           \\n           if(start==0)continue;\\n            HashSet<Integer> temp1=aen.get(start);\\n            temp1.addAll(aen.get(parent[start]));\\n            temp1.add(parent[start]);\\n        }\\n    }\\n    \\n    private HashSet<Integer> helperdes(int root){\\n        HashSet<Integer> total=des.get(root);\\n          for(int x:graph.get(root)){\\n               total.addAll(helperdes(x));\\n               total.add(x);\\n           }\\n        \\n        return total;   \\n    }\\n}\\n\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2079742,
                "title": "python-solution-over-complicated",
                "content": "```\\nclass TreeNode:\\n    \\n    def __init__(self, val):\\n        self.val = val\\n        self.parent = None\\n        self.children = []\\n        self.locked = False\\n        self.locked_by_user = None\\n\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.dict_node = {}\\n        self.root = None\\n        for idx, p in enumerate(parent):\\n            if idx in self.dict_node:\\n                child = self.dict_node[idx]\\n            else:\\n                child = TreeNode(idx)\\n\\n            if p == -1:\\n                self.root = child\\n            else:\\n                if p in self.dict_node:\\n                    p_node = self.dict_node[p]\\n                else:\\n                    p_node = TreeNode(p)\\n                child.parent = p_node\\n                p_node.children.append(child)\\n                self.dict_node[p] = p_node\\n            self.dict_node[idx] = child\\n            \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        node = self.dict_node[num]\\n        if node.locked:\\n            return False\\n        node.locked = True\\n        node.locked_by_user = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        node = self.dict_node[num]\\n        if not node.locked or node.locked_by_user != user:\\n            return False\\n        node.locked = False\\n        node.locked_by_user = None\\n        return True\\n    \\n    def _check_locked_ancestors(self, node):\\n        if not node:\\n            return False\\n        if node.locked:\\n            return True\\n        return self._check_locked_ancestors(node.parent)   \\n\\n    def _check_locked_descendant(self, node):\\n        if not node:\\n            return False\\n        if node.locked:\\n            return True\\n        for child in node.children:\\n            if self._check_locked_descendant(child):\\n                return True\\n        return False\\n    \\n    def _unlock_all_descendant(self, node):\\n        if not node:\\n            return\\n        node.locked = False\\n        node.locked_by_user = None\\n        for child in node.children:\\n            self._unlock_all_descendant(child)\\n    \\n    def upgrade(self, num: int, user: int) -> bool:\\n        node = self.dict_node[num]\\n        \\n        if node.locked or self._check_locked_ancestors(node) or not self._check_locked_descendant(node):\\n            return False\\n        self._unlock_all_descendant(node)\\n        node.locked = True\\n        node.locked_by_user = user\\n        return True\\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TreeNode:\\n    \\n    def __init__(self, val):\\n        self.val = val\\n        self.parent = None\\n        self.children = []\\n        self.locked = False\\n        self.locked_by_user = None\\n\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.dict_node = {}\\n        self.root = None\\n        for idx, p in enumerate(parent):\\n            if idx in self.dict_node:\\n                child = self.dict_node[idx]\\n            else:\\n                child = TreeNode(idx)\\n\\n            if p == -1:\\n                self.root = child\\n            else:\\n                if p in self.dict_node:\\n                    p_node = self.dict_node[p]\\n                else:\\n                    p_node = TreeNode(p)\\n                child.parent = p_node\\n                p_node.children.append(child)\\n                self.dict_node[p] = p_node\\n            self.dict_node[idx] = child\\n            \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        node = self.dict_node[num]\\n        if node.locked:\\n            return False\\n        node.locked = True\\n        node.locked_by_user = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        node = self.dict_node[num]\\n        if not node.locked or node.locked_by_user != user:\\n            return False\\n        node.locked = False\\n        node.locked_by_user = None\\n        return True\\n    \\n    def _check_locked_ancestors(self, node):\\n        if not node:\\n            return False\\n        if node.locked:\\n            return True\\n        return self._check_locked_ancestors(node.parent)   \\n\\n    def _check_locked_descendant(self, node):\\n        if not node:\\n            return False\\n        if node.locked:\\n            return True\\n        for child in node.children:\\n            if self._check_locked_descendant(child):\\n                return True\\n        return False\\n    \\n    def _unlock_all_descendant(self, node):\\n        if not node:\\n            return\\n        node.locked = False\\n        node.locked_by_user = None\\n        for child in node.children:\\n            self._unlock_all_descendant(child)\\n    \\n    def upgrade(self, num: int, user: int) -> bool:\\n        node = self.dict_node[num]\\n        \\n        if node.locked or self._check_locked_ancestors(node) or not self._check_locked_descendant(node):\\n            return False\\n        self._unlock_all_descendant(node)\\n        node.locked = True\\n        node.locked_by_user = user\\n        return True\\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055861,
                "title": "python-soln",
                "content": "```\\nfrom collections import defaultdict\\nclass LockingTree:\\n\\n    def __init__(self, par: List[int]):\\n        self.par=par\\n        self.graph=defaultdict(list)\\n        \\n        self.root=None\\n        for i in range(len(par)):\\n            \\n            if par[i]==-1:\\n                self.root=i\\n            else:\\n                self.graph[par[i]].append(i)\\n                \\n        self.look={i:set() for i in range(len(par))}\\n        #print(self.look)\\n        #self.unlock={i:set() for i in range(len(par))}\\n            \\n        \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        \\n        if len(self.look[num])>0:\\n            print(self.look[num])\\n            return False\\n        else:\\n            self.look[num].add(user)\\n            return True\\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        \\n        if user in self.look[num]:\\n            self.look[num].remove(user)\\n            return True\\n        else:\\n            return False\\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if len(self.look[num])>0:\\n            return False\\n        else:\\n            \\n            def dfs(u):\\n                \\n                \\n                if u!=num:\\n                    \\n                    if len(self.look[u])>0:\\n                        return True\\n                    \\n                for v in self.graph[u]:\\n                    \\n                    if dfs(v):\\n                        return True\\n                    \\n                return False\\n            \\n            def unlockdfs(u):\\n                if u!=num:\\n                    \\n                    self.look[u]=set()\\n                for v in self.graph[u]:\\n                    unlockdfs(v)\\n            \\n            \\n            p=self.par[num]\\n            \\n            while(p!=-1):\\n                if len(self.look[p])>0:\\n                    return False\\n                p=self.par[p]\\n            \\n            vis=[False for i in range(len(self.par))]\\n            if dfs(num)==False:\\n                return False\\n            else:\\n                unlockdfs(num)\\n                self.look[num].add(user)\\n            return True\\n                \\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph",
                    "Binary Tree"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass LockingTree:\\n\\n    def __init__(self, par: List[int]):\\n        self.par=par\\n        self.graph=defaultdict(list)\\n        \\n        self.root=None\\n        for i in range(len(par)):\\n            \\n            if par[i]==-1:\\n                self.root=i\\n            else:\\n                self.graph[par[i]].append(i)\\n                \\n        self.look={i:set() for i in range(len(par))}\\n        #print(self.look)\\n        #self.unlock={i:set() for i in range(len(par))}\\n            \\n        \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        \\n        if len(self.look[num])>0:\\n            print(self.look[num])\\n            return False\\n        else:\\n            self.look[num].add(user)\\n            return True\\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        \\n        if user in self.look[num]:\\n            self.look[num].remove(user)\\n            return True\\n        else:\\n            return False\\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if len(self.look[num])>0:\\n            return False\\n        else:\\n            \\n            def dfs(u):\\n                \\n                \\n                if u!=num:\\n                    \\n                    if len(self.look[u])>0:\\n                        return True\\n                    \\n                for v in self.graph[u]:\\n                    \\n                    if dfs(v):\\n                        return True\\n                    \\n                return False\\n            \\n            def unlockdfs(u):\\n                if u!=num:\\n                    \\n                    self.look[u]=set()\\n                for v in self.graph[u]:\\n                    unlockdfs(v)\\n            \\n            \\n            p=self.par[num]\\n            \\n            while(p!=-1):\\n                if len(self.look[p])>0:\\n                    return False\\n                p=self.par[p]\\n            \\n            vis=[False for i in range(len(self.par))]\\n            if dfs(num)==False:\\n                return False\\n            else:\\n                unlockdfs(num)\\n                self.look[num].add(user)\\n            return True\\n                \\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049004,
                "title": "python-solution-bfs-map-comments",
                "content": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked = [None]*len(parent)\\n        self.child = defaultdict(list)  # parent -> child_indexes\\n        for i, p in enumerate(parent):\\n            self.child[p].append(i)   # parent -> child\\n        \\n        print(self.child)\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]: return False # lock already acquired\\n        self.locked[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        #if not self.locked[num]: return False # not locked\\n        if self.locked[num] != user: return False # diff user\\n        self.locked[num] = None # unlock\\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locked[num]: return False\\n        # check ancestors\\n        cur = num\\n        while cur != -1:\\n            if self.locked[cur]: return False  # must not be locked\\n            cur = self.parent[cur]\\n        \\n        hasLocks = 0 # locked cnts for desscendants\\n        q = deque([num])  # queue\\n        # look for descendents using BFS (ie Level by level)\\n        while q:\\n            n = q.popleft()\\n            if self.locked[n]:  # detected 1 locked descendents\\n                self.locked[n] = None\\n                q.extend(self.child[n])\\n                break\\n            q.extend(self.child[n])\\n        else:\\n            return False\\n        \\n        # Simple BFS traversal to make all descendents unlock\\n        while q:\\n            n = q.popleft()\\n            self.locked[n] = None\\n            q.extend(self.child[n])\\n        \\n        # locks the given node \\n        self.locked[num] = user\\n        \\n        return True\\n            \\n            \\n                    \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.locked = [None]*len(parent)\\n        self.child = defaultdict(list)  # parent -> child_indexes\\n        for i, p in enumerate(parent):\\n            self.child[p].append(i)   # parent -> child\\n        \\n        print(self.child)\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]: return False # lock already acquired\\n        self.locked[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        #if not self.locked[num]: return False # not locked\\n        if self.locked[num] != user: return False # diff user\\n        self.locked[num] = None # unlock\\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locked[num]: return False\\n        # check ancestors\\n        cur = num\\n        while cur != -1:\\n            if self.locked[cur]: return False  # must not be locked\\n            cur = self.parent[cur]\\n        \\n        hasLocks = 0 # locked cnts for desscendants\\n        q = deque([num])  # queue\\n        # look for descendents using BFS (ie Level by level)\\n        while q:\\n            n = q.popleft()\\n            if self.locked[n]:  # detected 1 locked descendents\\n                self.locked[n] = None\\n                q.extend(self.child[n])\\n                break\\n            q.extend(self.child[n])\\n        else:\\n            return False\\n        \\n        # Simple BFS traversal to make all descendents unlock\\n        while q:\\n            n = q.popleft()\\n            self.locked[n] = None\\n            q.extend(self.child[n])\\n        \\n        # locks the given node \\n        self.locked[num] = user\\n        \\n        return True\\n            \\n            \\n                    \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045564,
                "title": "c-straightforward-well-structured-solution",
                "content": "```\\npublic class LockingTree {\\n    \\n    private readonly int[] nodes;\\n    private readonly int[] locked;\\n    private readonly Dictionary<int, List<int>> children;\\n\\n    public LockingTree(int[] parent) {\\n        \\n        nodes = parent;\\n        locked = Enumerable.Repeat(-1, parent.Length).ToArray();\\n        children = BuildChildrenIndex(parent);\\n    }\\n    \\n    public bool Lock(int node, int user) {\\n        \\n        if (IsLocked(node)) return false;\\n        \\n        DoLock(node, user);\\n        \\n        return true;\\n    }\\n    \\n    public bool Unlock(int node, int user) \\n    {\\n        if (IsLocked(node) is false) return false;\\n        \\n        return DoUnlock(node, user);\\n    }\\n    \\n    public bool Upgrade(int node, int user) {\\n        \\n        if (IsLocked(node) || HasLockedParents(node)) return false;\\n        \\n        if (HandleChildren(node, user) is false) return false;\\n        \\n        DoLock(node, user);\\n                \\n        return true;\\n    }\\n    \\n    private bool HandleChildren(int root, int user)\\n    {\\n        int lockCount = 0;\\n        \\n        Queue<int> queue = new();\\n        queue.Enqueue(root);\\n        \\n        while (queue.TryDequeue(out int node))\\n        {\\n            if (IsLocked(node))\\n            {\\n                lockCount++;\\n                DoUnlock(node);\\n            }\\n            \\n            if (children.TryGetValue(node, out List<int> childrenList))\\n                foreach (int child in childrenList) queue.Enqueue(child);\\n        }\\n        \\n        return lockCount > 0;\\n    }\\n    \\n    \\n    private bool HasLockedParents(int node)\\n    {        \\n        int parent = nodes[node];\\n        \\n        while (parent != -1)\\n        {\\n            if (IsLocked(parent)) return true;\\n            \\n            parent = nodes[parent];\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private bool IsLocked(int node) => locked[node] != -1;\\n    \\n    private void DoLock(int node, int user) => locked[node] = user;\\n    \\n    private bool DoUnlock(int node, int user)\\n    {        \\n        if (locked[node] != user) return false;\\n        \\n        DoUnlock(node);\\n        \\n        return true;\\n    }\\n    \\n    private void DoUnlock(int node) => locked[node] = -1;\\n    \\n    private static Dictionary<int, List<int>> BuildChildrenIndex(int[] nodes)\\n    {\\n        Dictionary<int, List<int>> children = new();\\n        \\n        for (int i = 0; i < nodes.Length; i++)\\n        {\\n            if (children.TryGetValue(nodes[i], out List<int> childrenList) is false)\\n            {\\n                childrenList = new();\\n                children.Add(nodes[i], childrenList);                \\n            }\\n            \\n            childrenList.Add(i);\\n        }\\n        \\n        return children;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class LockingTree {\\n    \\n    private readonly int[] nodes;\\n    private readonly int[] locked;\\n    private readonly Dictionary<int, List<int>> children;\\n\\n    public LockingTree(int[] parent) {\\n        \\n        nodes = parent;\\n        locked = Enumerable.Repeat(-1, parent.Length).ToArray();\\n        children = BuildChildrenIndex(parent);\\n    }\\n    \\n    public bool Lock(int node, int user) {\\n        \\n        if (IsLocked(node)) return false;\\n        \\n        DoLock(node, user);\\n        \\n        return true;\\n    }\\n    \\n    public bool Unlock(int node, int user) \\n    {\\n        if (IsLocked(node) is false) return false;\\n        \\n        return DoUnlock(node, user);\\n    }\\n    \\n    public bool Upgrade(int node, int user) {\\n        \\n        if (IsLocked(node) || HasLockedParents(node)) return false;\\n        \\n        if (HandleChildren(node, user) is false) return false;\\n        \\n        DoLock(node, user);\\n                \\n        return true;\\n    }\\n    \\n    private bool HandleChildren(int root, int user)\\n    {\\n        int lockCount = 0;\\n        \\n        Queue<int> queue = new();\\n        queue.Enqueue(root);\\n        \\n        while (queue.TryDequeue(out int node))\\n        {\\n            if (IsLocked(node))\\n            {\\n                lockCount++;\\n                DoUnlock(node);\\n            }\\n            \\n            if (children.TryGetValue(node, out List<int> childrenList))\\n                foreach (int child in childrenList) queue.Enqueue(child);\\n        }\\n        \\n        return lockCount > 0;\\n    }\\n    \\n    \\n    private bool HasLockedParents(int node)\\n    {        \\n        int parent = nodes[node];\\n        \\n        while (parent != -1)\\n        {\\n            if (IsLocked(parent)) return true;\\n            \\n            parent = nodes[parent];\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private bool IsLocked(int node) => locked[node] != -1;\\n    \\n    private void DoLock(int node, int user) => locked[node] = user;\\n    \\n    private bool DoUnlock(int node, int user)\\n    {        \\n        if (locked[node] != user) return false;\\n        \\n        DoUnlock(node);\\n        \\n        return true;\\n    }\\n    \\n    private void DoUnlock(int node) => locked[node] = -1;\\n    \\n    private static Dictionary<int, List<int>> BuildChildrenIndex(int[] nodes)\\n    {\\n        Dictionary<int, List<int>> children = new();\\n        \\n        for (int i = 0; i < nodes.Length; i++)\\n        {\\n            if (children.TryGetValue(nodes[i], out List<int> childrenList) is false)\\n            {\\n                childrenList = new();\\n                children.Add(nodes[i], childrenList);                \\n            }\\n            \\n            childrenList.Add(i);\\n        }\\n        \\n        return children;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020683,
                "title": "unable-to-figure-out-what-is-wrong-here",
                "content": "```\\nclass LockingTree {\\n  private int tree[];\\n  private Map<Integer, List<Integer>> desendants;\\n  private Map<Integer, Integer> nodeLockedBy;\\n\\n  public LockingTree(int[] parent) {\\n    this.tree = parent;\\n    this.nodeLockedBy = new HashMap<>();\\n    buildDesendants();\\n  }\\n  \\n  private void buildDesendents() {\\n    this.desendants = new HashMap<>();\\n    \\n    for (int i = 0; i < tree.length; i++) {\\n      desendants.putIfAbsent(tree[i], new ArrayList<>());\\n      desendants.get(tree[i]).add(i);\\n    }\\n  }\\n\\n  public boolean lock(int num, int user) {\\n    if (!isValidNodeKey(num) || isLocked(num)) {\\n      return false;\\n    }\\n    \\n    nodeLockedBy.put(num, user);\\n    return true;\\n  }\\n\\n  public boolean unlock(int num, int user) {\\n    if (!isValidNodeKey(num) || !isLocked(num) || nodeLockedBy.get(num) != user) {\\n      return false;\\n    }\\n    \\n    nodeLockedBy.remove(num);\\n    return true;\\n  }\\n\\n  public boolean upgrade(int num, int user) {\\n    if (!isValidNodeKey(num) || isLocked(num) || !areAncestorsUnlocked(num) || !unlockDesendants(num)) {\\n      return false;\\n    }\\n    \\n    return lock(num, user);\\n  }\\n  \\n  private boolean areAncestorsUnlocked(int node) {\\n    while (node != -1) {\\n      if (isLocked(tree[node])) {\\n        return false;\\n      }\\n      \\n      node = tree[node];\\n    }\\n    \\n    return true;\\n  }\\n  \\n  private boolean unlockDesendents(int num) {\\n    if (!desendents.containsKey(num)) {\\n      return false;\\n    }\\n    \\n    Queue<Integer> queue = new LinkedList<>();\\n    int node;\\n    boolean hadLockedDesendants = false;;\\n    queue.add(num);\\n    \\n    while (!queue.isEmpty()) {\\n      for (int i = queue.size(); i > 0; i--) {\\n        node = queue.poll();\\n        \\n        if (!desendents.containsKey(node)) {\\n          continue;\\n        }\\n        \\n        for (int next : desendants.get(node)) {\\n          if (isLocked(next)) {\\n            nodeLockedBy.remove(num);\\n            hadLockedDesendents = true;\\n          }\\n          \\n          queue.add(next);\\n        }\\n      }\\n    }\\n    \\n    return hadLockedDesendants;\\n  }\\n  \\n  private boolean isLocked(int num) {\\n    return nodeLockedBy.containsKey(num);\\n  }\\n  \\n  private boolean isValidNodeKey(int num) {\\n    return num < 0 || num < tree.length;\\n  }\\n}\\n```\\n\\nFailing this test case\\n```\\n[\"LockingTree\",\"upgrade\",\"upgrade\",\"upgrade\",\"upgrade\",\"unlock\",\"unlock\",\"upgrade\",\"upgrade\",\"upgrade\",\"lock\",\"lock\",\"upgrade\",\"upgrade\",\"unlock\",\"upgrade\",\"upgrade\",\"upgrade\",\"upgrade\",\"unlock\",\"unlock\"]\\n[[[-1,6,5,5,7,0,7,0,0,6]],[5,3],[2,3],[7,39],[1,32],[5,44],[2,15],[1,11],[1,18],[3,7],[5,36],[5,42],[8,5],[1,19],[3,38],[0,27],[4,11],[9,2],[8,41],[5,36],[7,29]]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n  private int tree[];\\n  private Map<Integer, List<Integer>> desendants;\\n  private Map<Integer, Integer> nodeLockedBy;\\n\\n  public LockingTree(int[] parent) {\\n    this.tree = parent;\\n    this.nodeLockedBy = new HashMap<>();\\n    buildDesendants();\\n  }\\n  \\n  private void buildDesendents() {\\n    this.desendants = new HashMap<>();\\n    \\n    for (int i = 0; i < tree.length; i++) {\\n      desendants.putIfAbsent(tree[i], new ArrayList<>());\\n      desendants.get(tree[i]).add(i);\\n    }\\n  }\\n\\n  public boolean lock(int num, int user) {\\n    if (!isValidNodeKey(num) || isLocked(num)) {\\n      return false;\\n    }\\n    \\n    nodeLockedBy.put(num, user);\\n    return true;\\n  }\\n\\n  public boolean unlock(int num, int user) {\\n    if (!isValidNodeKey(num) || !isLocked(num) || nodeLockedBy.get(num) != user) {\\n      return false;\\n    }\\n    \\n    nodeLockedBy.remove(num);\\n    return true;\\n  }\\n\\n  public boolean upgrade(int num, int user) {\\n    if (!isValidNodeKey(num) || isLocked(num) || !areAncestorsUnlocked(num) || !unlockDesendants(num)) {\\n      return false;\\n    }\\n    \\n    return lock(num, user);\\n  }\\n  \\n  private boolean areAncestorsUnlocked(int node) {\\n    while (node != -1) {\\n      if (isLocked(tree[node])) {\\n        return false;\\n      }\\n      \\n      node = tree[node];\\n    }\\n    \\n    return true;\\n  }\\n  \\n  private boolean unlockDesendents(int num) {\\n    if (!desendents.containsKey(num)) {\\n      return false;\\n    }\\n    \\n    Queue<Integer> queue = new LinkedList<>();\\n    int node;\\n    boolean hadLockedDesendants = false;;\\n    queue.add(num);\\n    \\n    while (!queue.isEmpty()) {\\n      for (int i = queue.size(); i > 0; i--) {\\n        node = queue.poll();\\n        \\n        if (!desendents.containsKey(node)) {\\n          continue;\\n        }\\n        \\n        for (int next : desendants.get(node)) {\\n          if (isLocked(next)) {\\n            nodeLockedBy.remove(num);\\n            hadLockedDesendents = true;\\n          }\\n          \\n          queue.add(next);\\n        }\\n      }\\n    }\\n    \\n    return hadLockedDesendants;\\n  }\\n  \\n  private boolean isLocked(int num) {\\n    return nodeLockedBy.containsKey(num);\\n  }\\n  \\n  private boolean isValidNodeKey(int num) {\\n    return num < 0 || num < tree.length;\\n  }\\n}\\n```\n```\\n[\"LockingTree\",\"upgrade\",\"upgrade\",\"upgrade\",\"upgrade\",\"unlock\",\"unlock\",\"upgrade\",\"upgrade\",\"upgrade\",\"lock\",\"lock\",\"upgrade\",\"upgrade\",\"unlock\",\"upgrade\",\"upgrade\",\"upgrade\",\"upgrade\",\"unlock\",\"unlock\"]\\n[[[-1,6,5,5,7,0,7,0,0,6]],[5,3],[2,3],[7,39],[1,32],[5,44],[2,15],[1,11],[1,18],[3,7],[5,36],[5,42],[8,5],[1,19],[3,38],[0,27],[4,11],[9,2],[8,41],[5,36],[7,29]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984155,
                "title": "javascript-solution-bfs",
                "content": "```\\nvar LockingTree = function(parent) {\\n    this.parents = parent;\\n    this.children  = [];\\n    this.locked = new Map();\\n    \\n    for (let i = 0; i < this.parents.length; ++i) {\\n        this.children[i] = [];\\n    }\\n    \\n    for (let i = 1; i < this.parents.length; ++i) {\\n        const parent = this.parents[i];\\n        \\n        this.children[parent].push(i);\\n    }\\n};\\n\\nLockingTree.prototype.lock = function(num, user) {\\n    if (this.locked.has(num)) return false;\\n\\n    this.locked.set(num, user);\\n   \\n    return true;\\n};\\n\\nLockingTree.prototype.unlock = function(num, user) {\\n    if (!this.locked.has(num) || this.locked.get(num) != user) return false;\\n    \\n    this.locked.delete(num);\\n    \\n    return true;\\n};\\n\\nLockingTree.prototype.upgrade = function(num, user) {\\n    let isLocked = traverseUp(num, this.parents, this.locked);\\n\\n    if (isLocked) return false;\\n\\n    const queue = [];\\n\\n    isLocked = false;\\n\\n    queue.push(num);\\n\\n    while (queue.length > 0) {\\n        const node = queue.shift();\\n\\n        if (node != num && this.locked.has(node)) {\\n            isLocked = true;\\n            this.locked.delete(node);\\n        }\\n\\n        for (let i = 0; i < this.children[node].length; ++i) {\\n            queue.push(this.children[node][i]);\\n        }\\n    } \\n\\n    if (!isLocked) return false;\\n\\n    this.locked.set(num, user);\\n\\n    return true;\\n\\n\\n    function traverseUp(num, parents, locked) {\\n        if (locked.has(num)) return true;\\n        if (num === 0) return false;\\n\\n        const parentIdx = parents[num];\\n\\n        return traverseUp(parentIdx, parents, locked);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar LockingTree = function(parent) {\\n    this.parents = parent;\\n    this.children  = [];\\n    this.locked = new Map();\\n    \\n    for (let i = 0; i < this.parents.length; ++i) {\\n        this.children[i] = [];\\n    }\\n    \\n    for (let i = 1; i < this.parents.length; ++i) {\\n        const parent = this.parents[i];\\n        \\n        this.children[parent].push(i);\\n    }\\n};\\n\\nLockingTree.prototype.lock = function(num, user) {\\n    if (this.locked.has(num)) return false;\\n\\n    this.locked.set(num, user);\\n   \\n    return true;\\n};\\n\\nLockingTree.prototype.unlock = function(num, user) {\\n    if (!this.locked.has(num) || this.locked.get(num) != user) return false;\\n    \\n    this.locked.delete(num);\\n    \\n    return true;\\n};\\n\\nLockingTree.prototype.upgrade = function(num, user) {\\n    let isLocked = traverseUp(num, this.parents, this.locked);\\n\\n    if (isLocked) return false;\\n\\n    const queue = [];\\n\\n    isLocked = false;\\n\\n    queue.push(num);\\n\\n    while (queue.length > 0) {\\n        const node = queue.shift();\\n\\n        if (node != num && this.locked.has(node)) {\\n            isLocked = true;\\n            this.locked.delete(node);\\n        }\\n\\n        for (let i = 0; i < this.children[node].length; ++i) {\\n            queue.push(this.children[node][i]);\\n        }\\n    } \\n\\n    if (!isLocked) return false;\\n\\n    this.locked.set(num, user);\\n\\n    return true;\\n\\n\\n    function traverseUp(num, parents, locked) {\\n        if (locked.has(num)) return true;\\n        if (num === 0) return false;\\n\\n        const parentIdx = parents[num];\\n\\n        return traverseUp(parentIdx, parents, locked);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977622,
                "title": "c-solution",
                "content": "```\\nclass LockingTree {\\npublic:\\n    vector<vector<int>> t;\\n    vector<int> islocked;\\n    vector<int> lockedchildcount;\\n    vector<int> parent;\\n    LockingTree(vector<int>& par) {\\n        parent=par;\\n        int n=parent.size();\\n        vector<vector<int>> tmp2(n);\\n        t=tmp2;\\n        for(int i=1;i<n;i++){\\n            t[parent[i]].push_back(i);\\n        }\\n        vector<int> tmp(n,-1);\\n        vector<int> tmp1(n,0);\\n        islocked=tmp;\\n        lockedchildcount=tmp1;\\n        \\n    }\\n    \\n    void decreaseancestors(int num){\\n        while(num!=-1)\\n            {\\n                lockedchildcount[num]--;\\n                num=parent[num];\\n            }\\n    }\\n    \\n   \\n    \\n    void increaseancestors(int num){\\n        while(num!=-1)\\n            {\\n                lockedchildcount[num]++;\\n                num=parent[num];\\n            }\\n    }\\n    \\n     void decreaseancestors(int num,int val){\\n        while(num!=-1)\\n            {\\n                lockedchildcount[num]-=val;\\n                num=parent[num];\\n            }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(islocked[num]==-1){\\n            islocked[num]=user;\\n            increaseancestors(parent[num]);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(islocked[num]==-1){\\n            return false;\\n        }\\n        if(islocked[num]==user){\\n            islocked[num]=-1;\\n            decreaseancestors(parent[num]);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n    \\n    void unlockdes(int num){\\n        \\n        for(int child:t[num]){\\n            islocked[child]=-1;\\n            lockedchildcount[child]=0;\\n            unlockdes(child);\\n        }\\n    }\\n    \\n    bool checka(int num){\\n        while(num!=-1){\\n            if(islocked[num]!=-1) return false;\\n            num=parent[num];\\n        }\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(islocked[num]==-1 && lockedchildcount[num]>0 && checka(parent[num])){\\n            islocked[num]=user;\\n            unlockdes(num);\\n            int val=lockedchildcount[num];\\n            lockedchildcount[num]=0;\\n            decreaseancestors(num,val-1);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<vector<int>> t;\\n    vector<int> islocked;\\n    vector<int> lockedchildcount;\\n    vector<int> parent;\\n    LockingTree(vector<int>& par) {\\n        parent=par;\\n        int n=parent.size();\\n        vector<vector<int>> tmp2(n);\\n        t=tmp2;\\n        for(int i=1;i<n;i++){\\n            t[parent[i]].push_back(i);\\n        }\\n        vector<int> tmp(n,-1);\\n        vector<int> tmp1(n,0);\\n        islocked=tmp;\\n        lockedchildcount=tmp1;\\n        \\n    }\\n    \\n    void decreaseancestors(int num){\\n        while(num!=-1)\\n            {\\n                lockedchildcount[num]--;\\n                num=parent[num];\\n            }\\n    }\\n    \\n   \\n    \\n    void increaseancestors(int num){\\n        while(num!=-1)\\n            {\\n                lockedchildcount[num]++;\\n                num=parent[num];\\n            }\\n    }\\n    \\n     void decreaseancestors(int num,int val){\\n        while(num!=-1)\\n            {\\n                lockedchildcount[num]-=val;\\n                num=parent[num];\\n            }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(islocked[num]==-1){\\n            islocked[num]=user;\\n            increaseancestors(parent[num]);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(islocked[num]==-1){\\n            return false;\\n        }\\n        if(islocked[num]==user){\\n            islocked[num]=-1;\\n            decreaseancestors(parent[num]);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n    \\n    void unlockdes(int num){\\n        \\n        for(int child:t[num]){\\n            islocked[child]=-1;\\n            lockedchildcount[child]=0;\\n            unlockdes(child);\\n        }\\n    }\\n    \\n    bool checka(int num){\\n        while(num!=-1){\\n            if(islocked[num]!=-1) return false;\\n            num=parent[num];\\n        }\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(islocked[num]==-1 && lockedchildcount[num]>0 && checka(parent[num])){\\n            islocked[num]=user;\\n            unlockdes(num);\\n            int val=lockedchildcount[num];\\n            lockedchildcount[num]=0;\\n            decreaseancestors(num,val-1);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973721,
                "title": "c-solution",
                "content": "This question is simple, but one has to be careful when crafting the solution.\\n\\nI thought is tree is balanced at first so I initialized the tree array with -1 (empty)...\\n\\nIn this question, the tree is not balanced, so I simply used a map to store the descendants of each node.\\n\\nThe operations are self-explanatory.\\n\\n```cpp\\nclass LockingTree {\\npublic:\\n    vector<int> tree;\\n    vector<int> locked;\\n    map<int, vector<int>> G;\\n    \\n    LockingTree(vector<int>& parent) {\\n        tree = parent;\\n        locked = vector<int>(parent.size(), -1);\\n        for (int i = 0; i < tree.size(); i++) {\\n            int par = tree[i];\\n            if (G.find(par) == G.end()) {\\n                G[par] = { i };\\n            }\\n            else {\\n                G[par].push_back(i);\\n            }\\n        }\\n        /*\\n        for (int i = 0; i < parent.size(); i++) {\\n            tree[i] = -1;\\n        }\\n        */\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (locked[num] != -1) {\\n            return false;\\n        }\\n        locked[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (locked[num] == user) {\\n            locked[num] = -1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool no_locked_anc(int ori_idx) {\\n        int cur = ori_idx;\\n        int par;\\n        while (cur > 0) {\\n            int par = tree[cur];\\n            if (par == -1)\\n                break;\\n            if (locked[par] != -1)\\n                return false;\\n            cur = par;\\n        }\\n        return true;\\n        \\n        /*\\n        // balanced tree version.\\n        while (cur > 0) {\\n            if ((cur & 1) == 0) {\\n                par = cur / 2 - 1;\\n            }\\n            else {\\n                par = cur / 2;\\n            }\\n            if (tree[par] != -1)\\n                return false;\\n            cur = par;\\n        }\\n        return true;\\n        */\\n    }\\n    \\n    bool flag;\\n    \\n    void ck_locked_des(int cur) {\\n        if (cur >= tree.size())\\n            return;\\n        if (locked[cur] != -1) {\\n            locked[cur] = -1;\\n            flag = true;\\n        }\\n        for (int des : G[cur]) {\\n            ck_locked_des(des);\\n        }\\n        \\n        /*\\n        balanced tree version.\\n        ck_locked_des(cur * 2 + 1);\\n        ck_locked_des(cur * 2 + 2);\\n        */\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (no_locked_anc(num)) {\\n            if (locked[num] == -1) {\\n                flag = false;\\n                ck_locked_des(num);\\n                if (flag) {\\n                    locked[num] = user;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass LockingTree {\\npublic:\\n    vector<int> tree;\\n    vector<int> locked;\\n    map<int, vector<int>> G;\\n    \\n    LockingTree(vector<int>& parent) {\\n        tree = parent;\\n        locked = vector<int>(parent.size(), -1);\\n        for (int i = 0; i < tree.size(); i++) {\\n            int par = tree[i];\\n            if (G.find(par) == G.end()) {\\n                G[par] = { i };\\n            }\\n            else {\\n                G[par].push_back(i);\\n            }\\n        }\\n        /*\\n        for (int i = 0; i < parent.size(); i++) {\\n            tree[i] = -1;\\n        }\\n        */\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (locked[num] != -1) {\\n            return false;\\n        }\\n        locked[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (locked[num] == user) {\\n            locked[num] = -1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool no_locked_anc(int ori_idx) {\\n        int cur = ori_idx;\\n        int par;\\n        while (cur > 0) {\\n            int par = tree[cur];\\n            if (par == -1)\\n                break;\\n            if (locked[par] != -1)\\n                return false;\\n            cur = par;\\n        }\\n        return true;\\n        \\n        /*\\n        // balanced tree version.\\n        while (cur > 0) {\\n            if ((cur & 1) == 0) {\\n                par = cur / 2 - 1;\\n            }\\n            else {\\n                par = cur / 2;\\n            }\\n            if (tree[par] != -1)\\n                return false;\\n            cur = par;\\n        }\\n        return true;\\n        */\\n    }\\n    \\n    bool flag;\\n    \\n    void ck_locked_des(int cur) {\\n        if (cur >= tree.size())\\n            return;\\n        if (locked[cur] != -1) {\\n            locked[cur] = -1;\\n            flag = true;\\n        }\\n        for (int des : G[cur]) {\\n            ck_locked_des(des);\\n        }\\n        \\n        /*\\n        balanced tree version.\\n        ck_locked_des(cur * 2 + 1);\\n        ck_locked_des(cur * 2 + 2);\\n        */\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if (no_locked_anc(num)) {\\n            if (locked[num] == -1) {\\n                flag = false;\\n                ck_locked_des(num);\\n                if (flag) {\\n                    locked[num] = user;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961362,
                "title": "c-dfs-beginner-friendly-simple-solution-with-explanation",
                "content": "```\\nclass LockingTree {\\npublic:\\n\\t// state: check whether the node is locked or not\\n\\t// pt: if locked, it denotes the user locking it. Initial is 0\\n\\t// rel: create a graph based on parent\\n\\tvector<vector<int>> rel;\\n    vector<int> state, pt;\\n    LockingTree(vector<int>& parent) {\\n        int n = parent.size();\\n        rel.resize(n);\\n        state.resize(n);\\n        for (int i = 0; i < n; ++i) {\\n            if (parent[i] != -1) {\\n                rel[parent[i]].push_back(i);\\n            }\\n        }\\n        pt = parent;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (state[num]) {\\n            return false;\\n        }\\n        state[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (state[num] != user) {\\n            return false;\\n        }\\n        state[num] = 0;\\n        return true;\\n    }\\n    \\n\\t// We unlock all descendents lock for current node using `dfs` after passing parent no lock check\\n    bool upgrade(int num, int user) {\\n        if (state[num]) {\\n            return false;\\n        }\\n        int p = pt[num];\\n        while (p != -1) {\\n            if (state[p]) {\\n                return false;\\n            }\\n            p = pt[p];\\n        }\\n        if (haveLock(num)) {\\n            state[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n\\t// unlocked all descendents and return true if any of its descendents are locked\\n    int haveLock(int now) {\\n        int res = 0;\\n        if (state[now]) {\\n            res = 1;\\n            state[now] = 0;\\n        }\\n        for (auto &child: rel[now]) {\\n            res |= haveLock(child);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\npublic:\\n\\t// state: check whether the node is locked or not\\n\\t// pt: if locked, it denotes the user locking it. Initial is 0\\n\\t// rel: create a graph based on parent\\n\\tvector<vector<int>> rel;\\n    vector<int> state, pt;\\n    LockingTree(vector<int>& parent) {\\n        int n = parent.size();\\n        rel.resize(n);\\n        state.resize(n);\\n        for (int i = 0; i < n; ++i) {\\n            if (parent[i] != -1) {\\n                rel[parent[i]].push_back(i);\\n            }\\n        }\\n        pt = parent;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if (state[num]) {\\n            return false;\\n        }\\n        state[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if (state[num] != user) {\\n            return false;\\n        }\\n        state[num] = 0;\\n        return true;\\n    }\\n    \\n\\t// We unlock all descendents lock for current node using `dfs` after passing parent no lock check\\n    bool upgrade(int num, int user) {\\n        if (state[num]) {\\n            return false;\\n        }\\n        int p = pt[num];\\n        while (p != -1) {\\n            if (state[p]) {\\n                return false;\\n            }\\n            p = pt[p];\\n        }\\n        if (haveLock(num)) {\\n            state[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n\\t// unlocked all descendents and return true if any of its descendents are locked\\n    int haveLock(int now) {\\n        int res = 0;\\n        if (state[now]) {\\n            res = 1;\\n            state[now] = 0;\\n        }\\n        for (auto &child: rel[now]) {\\n            res |= haveLock(child);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923573,
                "title": "c-tree-traverse-solution",
                "content": "Runtime: 632 ms, faster than 56.23% of C++ online submissions for Operations on Tree.\\nMemory Usage: 123.4 MB, less than 84.70% of C++ online submissions for Operations on Tree.\\n\\n\\n```\\nclass LockingTree {\\npublic:\\n    \\n    vector<int>locks;   // track lock owner of node\\n    vector<int>locksCount;  // track lock count of the descendant\\n    vector<vector<int>>child;   // child list\\n    vector<int>parents; // original parent list\\n    \\n    LockingTree(vector<int>& parent) {\\n        \\n        int n = parent.size();\\n        swap(parents,parent);\\n        locksCount.resize(n,0);\\n        child.resize(n);\\n        \\n        // set initial unlocks for each node and generate child list\\n        locks.push_back(-1);        \\n        for(int i=1;i<n;i++)\\n        {\\n            child[parents[i]].push_back(i);\\n            locks.push_back(-1);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        \\n        // check if node is unlocked\\n        if(locks[num]==-1)\\n        {\\n            // set lock owner and increment count of the parent nodes\\n            locks[num]=user;\\n            locksCount[num]++;\\n            \\n            while(parents[num]!=-1)\\n            {\\n                locksCount[parents[num]]++;\\n                num = parents[num];\\n            }\\n            return true;\\n        }\\n        else return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        \\n        // check if node is locked by current user\\n        if(locks[num]==user)\\n        {\\n            // reset lock owner and decrement count of parent nodes\\n            locks[num]=-1;\\n            locksCount[num]--;\\n                        \\n            while(parents[num]!=-1)\\n            {\\n                locksCount[parents[num]]--;\\n                num = parents[num];\\n            }\\n            return true;\\n        }\\n        else return false;\\n    }\\n    \\n    // recursively reset locks of the child nodes\\n    void unlockChild(int num)\\n    {\\n        locksCount[num]=0;\\n        locks[num]=-1;\\n        \\n        for(int i=0;i<child[num].size();i++)\\n            unlockChild(child[num][i]);\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        // check if node is unlocked\\n        if(locks[num]==-1)\\n        {\\n            // check if node has descendant lock count > 0, otherwise return false\\n            if(locksCount[num]==0)return false;\\n            \\n            // check if parent nodes are locked, if then return false\\n            int val = num;\\n            while(parents[val]!=-1)\\n            {\\n                if(locks[parents[val]]!=-1)return false;\\n                val = parents[val];\\n            }\\n            \\n            // set lock owner and increment count of the parent nodes\\n            locksCount[num] = 1;\\n            locks[num] = user;\\n                        \\n            val = num;\\n            while(parents[val]!=-1)\\n            {\\n                locksCount[parents[val]]++;\\n                val = parents[val];\\n            }\\n            \\n            // reset locks of the child nodes\\n            for(int i=0;i<child[num].size();i++)\\n                unlockChild(child[num][i]);\\n            \\n            return true;\\n        }\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    \\n    vector<int>locks;   // track lock owner of node\\n    vector<int>locksCount;  // track lock count of the descendant\\n    vector<vector<int>>child;   // child list\\n    vector<int>parents; // original parent list\\n    \\n    LockingTree(vector<int>& parent) {\\n        \\n        int n = parent.size();\\n        swap(parents,parent);\\n        locksCount.resize(n,0);\\n        child.resize(n);\\n        \\n        // set initial unlocks for each node and generate child list\\n        locks.push_back(-1);        \\n        for(int i=1;i<n;i++)\\n        {\\n            child[parents[i]].push_back(i);\\n            locks.push_back(-1);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        \\n        // check if node is unlocked\\n        if(locks[num]==-1)\\n        {\\n            // set lock owner and increment count of the parent nodes\\n            locks[num]=user;\\n            locksCount[num]++;\\n            \\n            while(parents[num]!=-1)\\n            {\\n                locksCount[parents[num]]++;\\n                num = parents[num];\\n            }\\n            return true;\\n        }\\n        else return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        \\n        // check if node is locked by current user\\n        if(locks[num]==user)\\n        {\\n            // reset lock owner and decrement count of parent nodes\\n            locks[num]=-1;\\n            locksCount[num]--;\\n                        \\n            while(parents[num]!=-1)\\n            {\\n                locksCount[parents[num]]--;\\n                num = parents[num];\\n            }\\n            return true;\\n        }\\n        else return false;\\n    }\\n    \\n    // recursively reset locks of the child nodes\\n    void unlockChild(int num)\\n    {\\n        locksCount[num]=0;\\n        locks[num]=-1;\\n        \\n        for(int i=0;i<child[num].size();i++)\\n            unlockChild(child[num][i]);\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        // check if node is unlocked\\n        if(locks[num]==-1)\\n        {\\n            // check if node has descendant lock count > 0, otherwise return false\\n            if(locksCount[num]==0)return false;\\n            \\n            // check if parent nodes are locked, if then return false\\n            int val = num;\\n            while(parents[val]!=-1)\\n            {\\n                if(locks[parents[val]]!=-1)return false;\\n                val = parents[val];\\n            }\\n            \\n            // set lock owner and increment count of the parent nodes\\n            locksCount[num] = 1;\\n            locks[num] = user;\\n                        \\n            val = num;\\n            while(parents[val]!=-1)\\n            {\\n                locksCount[parents[val]]++;\\n                val = parents[val];\\n            }\\n            \\n            // reset locks of the child nodes\\n            for(int i=0;i<child[num].size();i++)\\n                unlockChild(child[num][i]);\\n            \\n            return true;\\n        }\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922322,
                "title": "c-dfs",
                "content": "```\\nclass LockingTree {\\n    unordered_map<int, int> locks;\\n    unordered_map<int, vector<int>> children;\\n    vector<int> pars;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        int n = parent.size();\\n        for(int i = 0; i < n; ++i) {\\n            children[parent[i]].push_back(i);\\n        }\\n        pars = move(parent);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locks[num] != 0)\\n            return false;\\n        locks[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locks[num] != user)\\n            return false;\\n        locks[num] = 0;\\n        return true;        \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(locks[num] != 0)\\n            return false;\\n        int lock_desc = count_locked(num);\\n        if(lock_desc < 1)\\n            return false;\\n        int p = pars[num];\\n        while(p != -1) {\\n            if(locks[p] != 0)\\n                return false;\\n            p = pars[p];\\n        }\\n        clean_locked(num);\\n        locks[num] = user;\\n        return true;\\n    }\\nprivate:\\n    int count_locked(int num) {\\n        int ret = (locks[num] != 0) ? 1 : 0;\\n        for(int desc : children[num]) {\\n            ret += count_locked(desc);\\n        }\\n        return ret;\\n    }\\n    void clean_locked(int num) {\\n        locks[num] = 0;\\n        for(int desc : children[num]) {\\n            clean_locked(desc);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    unordered_map<int, int> locks;\\n    unordered_map<int, vector<int>> children;\\n    vector<int> pars;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        int n = parent.size();\\n        for(int i = 0; i < n; ++i) {\\n            children[parent[i]].push_back(i);\\n        }\\n        pars = move(parent);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locks[num] != 0)\\n            return false;\\n        locks[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locks[num] != user)\\n            return false;\\n        locks[num] = 0;\\n        return true;        \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(locks[num] != 0)\\n            return false;\\n        int lock_desc = count_locked(num);\\n        if(lock_desc < 1)\\n            return false;\\n        int p = pars[num];\\n        while(p != -1) {\\n            if(locks[p] != 0)\\n                return false;\\n            p = pars[p];\\n        }\\n        clean_locked(num);\\n        locks[num] = user;\\n        return true;\\n    }\\nprivate:\\n    int count_locked(int num) {\\n        int ret = (locks[num] != 0) ? 1 : 0;\\n        for(int desc : children[num]) {\\n            ret += count_locked(desc);\\n        }\\n        return ret;\\n    }\\n    void clean_locked(int num) {\\n        locks[num] = 0;\\n        for(int desc : children[num]) {\\n            clean_locked(desc);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890771,
                "title": "typescript-dfs",
                "content": "```js\\nclass LockingTree {\\n    parent: number[];\\n    nodeUserMap: Map<number, number>;\\n    parentChildrenMap: Map<number, any>;\\n    \\n    constructor(parent: number[]) {\\n        this.parent = parent;\\n        this.nodeUserMap = new Map();\\n        this.parentChildrenMap = new Map();\\n        \\n  \\n        for (let i = 0; i < parent.length; i++) {\\n            if ( this.parentChildrenMap.has(parent[i]) ) {\\n                this.parentChildrenMap.get(parent[i]).push(i)\\n            }else {\\n               this.parentChildrenMap.set(parent[i], [i]) \\n            }\\n        }        \\n    }\\n\\n    lock(num: number, user: number): boolean {\\n       \\n        if ( !this.nodeUserMap.has(num)  ) {\\n            this.nodeUserMap.set(num, user)\\n             if ( num ===6 && user === 41) {\\n        }\\n            return true;\\n            \\n        }\\n        \\n        return false;\\n    }\\n\\n    unlock(num: number, user: number): boolean {\\n         \\n        if ( this.nodeUserMap.has(num) && this.nodeUserMap.get(num) === user) {\\n            this.nodeUserMap.delete(num)\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    upgrade(num: number, user: number): boolean {\\n        let isNodeUnlocked = (num) => !this.nodeUserMap.has(num)\\n        let hasAnyLockedAncestors = (num) => {\\n            const dfs = (num) => {\\n                if ( num < 0 || num > this.parent.length ) return false;\\n                if ( this.parent[num] === -1 ) {\\n                    \\n                    return !isNodeUnlocked(num) ;\\n                } else {\\n                    //return true if this node locked or its parent locked\\n                    return !isNodeUnlocked(num) || dfs(this.parent[num])\\n                }\\n                \\n            }\\n            return dfs(num)\\n        }\\n\\n        let stageLockedDescendant = []\\n        let hasLockedDescendant = (num) => {\\n           \\n            const dfs = (num) => {               \\n                if ( num=== undefined || num === null) return \\n                if ( num < 0 || num >= this.parent.length ) return false;\\n                \\n                if ( !isNodeUnlocked(num) ) {\\n                    stageLockedDescendant.push(num)\\n                }\\n               \\n                if ( this.parentChildrenMap.has(num)) {\\n                    for (let n of this.parentChildrenMap.get(num)) {\\n                     dfs(n)\\n                    }\\n                }\\n            }\\n            dfs(num)\\n            return !!stageLockedDescendant.length\\n        };\\n        \\n        let canUpgrade = isNodeUnlocked(num) && !hasAnyLockedAncestors(num)  && hasLockedDescendant(num)\\n        \\n        if ( canUpgrade) {\\n            this.lock(num, user);\\n            stageLockedDescendant.forEach( num => this.nodeUserMap.delete(num))\\n        }\\n        \\n        return  canUpgrade\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nclass LockingTree {\\n    parent: number[];\\n    nodeUserMap: Map<number, number>;\\n    parentChildrenMap: Map<number, any>;\\n    \\n    constructor(parent: number[]) {\\n        this.parent = parent;\\n        this.nodeUserMap = new Map();\\n        this.parentChildrenMap = new Map();\\n        \\n  \\n        for (let i = 0; i < parent.length; i++) {\\n            if ( this.parentChildrenMap.has(parent[i]) ) {\\n                this.parentChildrenMap.get(parent[i]).push(i)\\n            }else {\\n               this.parentChildrenMap.set(parent[i], [i]) \\n            }\\n        }        \\n    }\\n\\n    lock(num: number, user: number): boolean {\\n       \\n        if ( !this.nodeUserMap.has(num)  ) {\\n            this.nodeUserMap.set(num, user)\\n             if ( num ===6 && user === 41) {\\n        }\\n            return true;\\n            \\n        }\\n        \\n        return false;\\n    }\\n\\n    unlock(num: number, user: number): boolean {\\n         \\n        if ( this.nodeUserMap.has(num) && this.nodeUserMap.get(num) === user) {\\n            this.nodeUserMap.delete(num)\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    upgrade(num: number, user: number): boolean {\\n        let isNodeUnlocked = (num) => !this.nodeUserMap.has(num)\\n        let hasAnyLockedAncestors = (num) => {\\n            const dfs = (num) => {\\n                if ( num < 0 || num > this.parent.length ) return false;\\n                if ( this.parent[num] === -1 ) {\\n                    \\n                    return !isNodeUnlocked(num) ;\\n                } else {\\n                    //return true if this node locked or its parent locked\\n                    return !isNodeUnlocked(num) || dfs(this.parent[num])\\n                }\\n                \\n            }\\n            return dfs(num)\\n        }\\n\\n        let stageLockedDescendant = []\\n        let hasLockedDescendant = (num) => {\\n           \\n            const dfs = (num) => {               \\n                if ( num=== undefined || num === null) return \\n                if ( num < 0 || num >= this.parent.length ) return false;\\n                \\n                if ( !isNodeUnlocked(num) ) {\\n                    stageLockedDescendant.push(num)\\n                }\\n               \\n                if ( this.parentChildrenMap.has(num)) {\\n                    for (let n of this.parentChildrenMap.get(num)) {\\n                     dfs(n)\\n                    }\\n                }\\n            }\\n            dfs(num)\\n            return !!stageLockedDescendant.length\\n        };\\n        \\n        let canUpgrade = isNodeUnlocked(num) && !hasAnyLockedAncestors(num)  && hasLockedDescendant(num)\\n        \\n        if ( canUpgrade) {\\n            this.lock(num, user);\\n            stageLockedDescendant.forEach( num => this.nodeUserMap.delete(num))\\n        }\\n        \\n        return  canUpgrade\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878169,
                "title": "c-368ms-around-95-ituitive-and-simple-dfs-and-vector-as-hash-solution",
                "content": "```\\nclass LockingTree {\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        vector<vector<int>> childs(parent.size());\\n        pool.resize(parent.size(), nullptr);\\n\\n        pool[0] = new TreeNode();\\n        for (int i = 1; i < parent.size(); ++i) {\\n            childs[parent[i]].push_back(i);\\n            pool[i] = new TreeNode();\\n        }\\n        dfsConstructTree(childs, 0);\\n    }\\n\\n    bool lock(int num, int user) {\\n        auto node = pool[num];\\n        if (node->isLocked) {\\n            return false;\\n        }\\n        node->isLocked = true;\\n        node->user = user;\\n\\n        return true;\\n    }\\n\\n    bool unlock(int num, int user) {\\n        auto node = pool[num];\\n        if (!node->isLocked) {\\n            return false;\\n        }\\n        if (node->user != user) {\\n            return false;\\n        }\\n        node->isLocked = false;\\n        node->user = 0;\\n\\n        return true;\\n    }\\n\\n    bool upgrade(int num, int user) {\\n        auto cur = pool[num];\\n\\n        while (cur != nullptr) {\\n            if (cur->isLocked) {\\n                return false;\\n            }\\n            cur = cur->parent;\\n        }\\n\\n        cur = pool[num];\\n        bool isValid = dfsUnlockChilds(cur);\\n\\n        if (isValid) {\\n            cur->isLocked = true;\\n            cur->user = user;\\n        }\\n\\n        return isValid;\\n    }\\n\\nprotected:\\n    struct TreeNode {\\n        TreeNode() {}\\n        bool isLocked = false;\\n        int user = 0;\\n        vector<TreeNode *> childs;\\n        TreeNode *parent = nullptr;\\n    };\\n\\nprivate:\\n    void dfsConstructTree(vector<vector<int>> &childs, int curNodeId) {\\n        auto curNode = pool[curNodeId];\\n        for (auto &childId : childs[curNodeId]) {\\n            auto childNode = pool[childId];\\n            curNode->childs.push_back(childNode);\\n            childNode->parent = curNode;\\n            dfsConstructTree(childs, childId);\\n        }\\n    }\\n\\n    bool dfsUnlockChilds(TreeNode *cur) {\\n        bool isValid = false;\\n\\n        if (cur->isLocked) {\\n            cur->isLocked = false;\\n            cur->user = 0;\\n            isValid = true;\\n        }\\n\\n        for (auto childNode : cur->childs) {\\n            isValid |= dfsUnlockChilds(childNode);\\n        }\\n\\n        return isValid;\\n    }\\n\\nprivate:\\n    vector<TreeNode *> pool; // as hash to fastly find node\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        vector<vector<int>> childs(parent.size());\\n        pool.resize(parent.size(), nullptr);\\n\\n        pool[0] = new TreeNode();\\n        for (int i = 1; i < parent.size(); ++i) {\\n            childs[parent[i]].push_back(i);\\n            pool[i] = new TreeNode();\\n        }\\n        dfsConstructTree(childs, 0);\\n    }\\n\\n    bool lock(int num, int user) {\\n        auto node = pool[num];\\n        if (node->isLocked) {\\n            return false;\\n        }\\n        node->isLocked = true;\\n        node->user = user;\\n\\n        return true;\\n    }\\n\\n    bool unlock(int num, int user) {\\n        auto node = pool[num];\\n        if (!node->isLocked) {\\n            return false;\\n        }\\n        if (node->user != user) {\\n            return false;\\n        }\\n        node->isLocked = false;\\n        node->user = 0;\\n\\n        return true;\\n    }\\n\\n    bool upgrade(int num, int user) {\\n        auto cur = pool[num];\\n\\n        while (cur != nullptr) {\\n            if (cur->isLocked) {\\n                return false;\\n            }\\n            cur = cur->parent;\\n        }\\n\\n        cur = pool[num];\\n        bool isValid = dfsUnlockChilds(cur);\\n\\n        if (isValid) {\\n            cur->isLocked = true;\\n            cur->user = user;\\n        }\\n\\n        return isValid;\\n    }\\n\\nprotected:\\n    struct TreeNode {\\n        TreeNode() {}\\n        bool isLocked = false;\\n        int user = 0;\\n        vector<TreeNode *> childs;\\n        TreeNode *parent = nullptr;\\n    };\\n\\nprivate:\\n    void dfsConstructTree(vector<vector<int>> &childs, int curNodeId) {\\n        auto curNode = pool[curNodeId];\\n        for (auto &childId : childs[curNodeId]) {\\n            auto childNode = pool[childId];\\n            curNode->childs.push_back(childNode);\\n            childNode->parent = curNode;\\n            dfsConstructTree(childs, childId);\\n        }\\n    }\\n\\n    bool dfsUnlockChilds(TreeNode *cur) {\\n        bool isValid = false;\\n\\n        if (cur->isLocked) {\\n            cur->isLocked = false;\\n            cur->user = 0;\\n            isValid = true;\\n        }\\n\\n        for (auto childNode : cur->childs) {\\n            isValid |= dfsUnlockChilds(childNode);\\n        }\\n\\n        return isValid;\\n    }\\n\\nprivate:\\n    vector<TreeNode *> pool; // as hash to fastly find node\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821278,
                "title": "java-follow-the-rules-and-instructions",
                "content": "**Explanation**\\n\\nNothing out of the box. Just build the tree (Adjacency List) from the parent array and maintain a lock data structure which will store node-user pairs.\\n\\nRest follow the comments within the code for better understanding.\\n\\n**Complexity**\\n\\n**Time**\\nO(1) - Lock and Unlock\\nO(n) - Upgrade *(where n is the total number of nodes in the tree)*\\n\\n**Space** O(n)\\n\\n```\\nclass LockingTree {\\n    \\n    Map<Integer,List<Integer>> tree; // parent-children pair\\n    Map<Integer,Integer> lock; // node-user pair\\n    int [] parent;\\n\\n    public LockingTree(int[] parent) {\\n        \\n        tree = new HashMap<>();\\n        lock = new HashMap<>();\\n        this.parent = parent;\\n        \\n        for(int i=0;i<parent.length;i++)   // building the tree\\n            tree.put(i,new ArrayList<>());\\n        \\n        for(int i=1;i<parent.length;++i)   // building the tree\\n            tree.get(parent[i]).add(i);\\n    }\\n    \\n    public boolean lock(int node, int user) {\\n        \\n        if(lock.containsKey(node)) return false;  // Node already locked ? return false\\n        \\n        lock.put(node,user);\\n        \\n        return true;\\n    }\\n    \\n    public boolean unlock(int node, int user) {\\n        \\n        if(!lock.containsKey(node) || lock.get(node) != user) return false;  // Either the node is NOT locked or it is not locked by the \\'user\\' ? return false\\n        \\n        lock.remove(node);\\n        \\n        return true;\\n    }\\n    \\n    public boolean upgrade(int node, int user) {\\n        \\n        if(lock.containsKey(node) || !lockedDescendant(node)) return false; // either the node is locked or has a no locked descendant ? return false\\n\\n        int curr = node;\\n        \\n        while(curr != -1) {   // check if it contains any locked ancestor/grandparent\\n        \\n            curr = parent[curr];\\n            \\n            if(lock.containsKey(curr)) return false;\\n        }\\n        \\n        massUnlocker(node);  // peform a DFS or BFS and unlock all locked descendants.\\n    \\n        return lock(node,user); // the current user locks the node \\n    }\\n    \\n    private boolean lockedDescendant(int node) {\\n        \\n        if(lock.containsKey(node)) return true;\\n        \\n        for(int i : tree.get(node)) {\\n            \\n            if(lockedDescendant(i)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void massUnlocker(int node) {\\n        \\n        if(lock.containsKey(node)) lock.remove(node);\\n        \\n        for(int i : tree.get(node)) {\\n            \\n            massUnlocker(i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    \\n    Map<Integer,List<Integer>> tree; // parent-children pair\\n    Map<Integer,Integer> lock; // node-user pair\\n    int [] parent;\\n\\n    public LockingTree(int[] parent) {\\n        \\n        tree = new HashMap<>();\\n        lock = new HashMap<>();\\n        this.parent = parent;\\n        \\n        for(int i=0;i<parent.length;i++)   // building the tree\\n            tree.put(i,new ArrayList<>());\\n        \\n        for(int i=1;i<parent.length;++i)   // building the tree\\n            tree.get(parent[i]).add(i);\\n    }\\n    \\n    public boolean lock(int node, int user) {\\n        \\n        if(lock.containsKey(node)) return false;  // Node already locked ? return false\\n        \\n        lock.put(node,user);\\n        \\n        return true;\\n    }\\n    \\n    public boolean unlock(int node, int user) {\\n        \\n        if(!lock.containsKey(node) || lock.get(node) != user) return false;  // Either the node is NOT locked or it is not locked by the \\'user\\' ? return false\\n        \\n        lock.remove(node);\\n        \\n        return true;\\n    }\\n    \\n    public boolean upgrade(int node, int user) {\\n        \\n        if(lock.containsKey(node) || !lockedDescendant(node)) return false; // either the node is locked or has a no locked descendant ? return false\\n\\n        int curr = node;\\n        \\n        while(curr != -1) {   // check if it contains any locked ancestor/grandparent\\n        \\n            curr = parent[curr];\\n            \\n            if(lock.containsKey(curr)) return false;\\n        }\\n        \\n        massUnlocker(node);  // peform a DFS or BFS and unlock all locked descendants.\\n    \\n        return lock(node,user); // the current user locks the node \\n    }\\n    \\n    private boolean lockedDescendant(int node) {\\n        \\n        if(lock.containsKey(node)) return true;\\n        \\n        for(int i : tree.get(node)) {\\n            \\n            if(lockedDescendant(i)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void massUnlocker(int node) {\\n        \\n        if(lock.containsKey(node)) lock.remove(node);\\n        \\n        for(int i : tree.get(node)) {\\n            \\n            massUnlocker(i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781138,
                "title": "java-simple-sol",
                "content": "~~~java\\n\\nclass LockingTree {\\n    int[] parents;\\n    int[] lockUsers;\\n    List<Integer>[] parentToChildren;\\n\\n    public LockingTree(int[] parent) {\\n        this.parents = parent;\\n        lockUsers = new int[parent.length];\\n        parentToChildren = new ArrayList[parent.length];\\n        for (int i = 0; i < parent.length; i++) {\\n            parentToChildren[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < parent.length; i++) {\\n            if (parent[i] == -1) {\\n                continue;\\n            }\\n            parentToChildren[parent[i]].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (lockUsers[num] != 0) {\\n            return false;\\n        }\\n        lockUsers[num] = user;\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (lockUsers[num] != user) {\\n            return false;\\n        }\\n        lockUsers[num] = 0;\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (lockUsers[num] != 0) {\\n            return false;\\n        }\\n        \\n        // 1. check ancestors\\n        int anc = parents[num];\\n        while (anc != -1) {\\n            if (lockUsers[anc] != 0) {\\n                return false;\\n            }\\n            anc = parents[anc];\\n        }\\n        \\n        // 2. check descendants\\n        if (!haslockDec(num)) {\\n            return false;\\n        }\\n        lockUsers[num] = user;\\n        \\n        return true;\\n    }\\n    \\n    private boolean haslockDec(int num) {\\n        boolean locked = lockUsers[num] != 0;\\n        lockUsers[num] = 0;\\n        for (int child : parentToChildren[num]) {\\n            locked |= haslockDec(child);\\n        }\\n        return locked;\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "~~~java\\n\\nclass LockingTree {\\n    int[] parents;\\n    int[] lockUsers;\\n    List<Integer>[] parentToChildren;\\n\\n    public LockingTree(int[] parent) {\\n        this.parents = parent;\\n        lockUsers = new int[parent.length];\\n        parentToChildren = new ArrayList[parent.length];\\n        for (int i = 0; i < parent.length; i++) {\\n            parentToChildren[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < parent.length; i++) {\\n            if (parent[i] == -1) {\\n                continue;\\n            }\\n            parentToChildren[parent[i]].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (lockUsers[num] != 0) {\\n            return false;\\n        }\\n        lockUsers[num] = user;\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (lockUsers[num] != user) {\\n            return false;\\n        }\\n        lockUsers[num] = 0;\\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (lockUsers[num] != 0) {\\n            return false;\\n        }\\n        \\n        // 1. check ancestors\\n        int anc = parents[num];\\n        while (anc != -1) {\\n            if (lockUsers[anc] != 0) {\\n                return false;\\n            }\\n            anc = parents[anc];\\n        }\\n        \\n        // 2. check descendants\\n        if (!haslockDec(num)) {\\n            return false;\\n        }\\n        lockUsers[num] = user;\\n        \\n        return true;\\n    }\\n    \\n    private boolean haslockDec(int num) {\\n        boolean locked = lockUsers[num] != 0;\\n        lockUsers[num] = 0;\\n        for (int child : parentToChildren[num]) {\\n            locked |= haslockDec(child);\\n        }\\n        return locked;\\n    }\\n}\\n\\n\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 1780195,
                "title": "python-solution",
                "content": "```\\nclass LockingTree(object):\\n\\n    def __init__(self, parent):\\n        \"\"\"\\n        :type parent: List[int]\\n        \"\"\"\\n        self.parent=parent\\n        l=len(parent)\\n        self.loc=[None]*l\\n        self.child=defaultdict(list)\\n        for i in range(1,len(parent)):\\n            self.child[parent[i]].append(i)\\n                \\n    def lock(self, num, user):\\n    \\n        #two possible case already lock or not lock\\n        if self.loc[num]==None:\\n            self.loc[num]=user\\n            return True\\n        return False\\n        \\n    def unlock(self, num, user):\\n   \\n        if self.loc[num]==None:return False\\n        elif self.loc[num]==user:\\n            self.loc[num]=None\\n            return True\\n        return False\\n        \\n\\n    def upgrade(self, num, user):\\n\\n        #case 1 check\\n        i=num\\n        while i!=-1:\\n            if self.loc[i]!=None:return False\\n            i=self.parent[i]\\n            \\n        #case 2 check\\n        #atleast one lock decendent\\n#         doing bfs\\n        q=[num]\\n        nooflock=0\\n        while len(q)!=0:\\n            curr=q.pop(0)\\n            if self.loc[curr]!=None:\\n                self.loc[curr]=None\\n                nooflock+=1\\n            q.extend(self.child[curr])\\n        if nooflock>0:\\n            self.loc[num]=user\\n            \\n        return nooflock>0\\n            \\n    \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass LockingTree(object):\\n\\n    def __init__(self, parent):\\n        \"\"\"\\n        :type parent: List[int]\\n        \"\"\"\\n        self.parent=parent\\n        l=len(parent)\\n        self.loc=[None]*l\\n        self.child=defaultdict(list)\\n        for i in range(1,len(parent)):\\n            self.child[parent[i]].append(i)\\n                \\n    def lock(self, num, user):\\n    \\n        #two possible case already lock or not lock\\n        if self.loc[num]==None:\\n            self.loc[num]=user\\n            return True\\n        return False\\n        \\n    def unlock(self, num, user):\\n   \\n        if self.loc[num]==None:return False\\n        elif self.loc[num]==user:\\n            self.loc[num]=None\\n            return True\\n        return False\\n        \\n\\n    def upgrade(self, num, user):\\n\\n        #case 1 check\\n        i=num\\n        while i!=-1:\\n            if self.loc[i]!=None:return False\\n            i=self.parent[i]\\n            \\n        #case 2 check\\n        #atleast one lock decendent\\n#         doing bfs\\n        q=[num]\\n        nooflock=0\\n        while len(q)!=0:\\n            curr=q.pop(0)\\n            if self.loc[curr]!=None:\\n                self.loc[curr]=None\\n                nooflock+=1\\n            q.extend(self.child[curr])\\n        if nooflock>0:\\n            self.loc[num]=user\\n            \\n        return nooflock>0\\n            \\n    \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1740669,
                "title": "only-look-at-ancestors",
                "content": "It is possible to avoid performing a `bfs/dfs` when upgrading a node.\\n\\n```python\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        n = len(parent)\\n        self.parent = parent\\n        self.locked_cnt = [0] * n\\n        self.locker = [-1] * n\\n        self.level = [0] * n\\n        self.used_levels = [0] * n\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked(num):\\n            return False\\n        \\n        self.locker[num] = user\\n        while num != -1:\\n            self.locked_cnt[num] += 1\\n            num = self.parent[num]\\n            \\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if not self.locked(num):\\n            return False\\n        elif self.locker[num] != user:\\n            return False\\n        \\n        self.locker[num] = -1\\n        while num != -1:\\n            self.locked_cnt[num] -= 1\\n            num = self.parent[num]\\n            \\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locked(num) or self.locked_cnt[num] == 0:\\n            return False\\n        \\n        # At this point, all ancestors have updated their locking\\n        # status based on upgrades, so we simply check the last\\n        # condition.\\n        ptr = num\\n        while ptr != -1:\\n            if self.locker[ptr] != -1:\\n                return False\\n            ptr = self.parent[ptr]\\n        \\n        # We can now upgrade the node\\n        self.used_levels[num] += 1\\n        self.level[num] = self.used_levels[num] \\n        self.locker[num] = user\\n        \\n        delta = self.locked_cnt[num]-1\\n        ptr = num\\n        while ptr != -1:\\n            self.locked_cnt[ptr] -= delta\\n            self.used_levels[ptr] = max(\\n                self.used_levels[ptr], self.used_levels[num])\\n            ptr = self.parent[ptr]\\n            \\n        return True\\n        \\n    \\n    def locked(self, num):\\n        path = []\\n        ptr = num\\n        while ptr != -1:\\n            path.append(ptr)\\n            ptr = self.parent[ptr]\\n        \\n        max_lvl = -1\\n        for par in path[::-1]:\\n            if max_lvl > self.level[par]:\\n                # Some ancestor has upgraded, unlock ourselves, \\n                # reset states, and upgrade ourselves too\\n                self.locked_cnt[par] = 0\\n                self.locker[par] = -1 \\n                self.level[par] = max_lvl\\n\\t\\t\\t\\tself.used_levels[par] = max_lvl\\n            \\n            max_lvl = max(max_lvl, self.level[par])\\n            \\n        return self.locker[num] != -1\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        n = len(parent)\\n        self.parent = parent\\n        self.locked_cnt = [0] * n\\n        self.locker = [-1] * n\\n        self.level = [0] * n\\n        self.used_levels = [0] * n\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked(num):\\n            return False\\n        \\n        self.locker[num] = user\\n        while num != -1:\\n            self.locked_cnt[num] += 1\\n            num = self.parent[num]\\n            \\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if not self.locked(num):\\n            return False\\n        elif self.locker[num] != user:\\n            return False\\n        \\n        self.locker[num] = -1\\n        while num != -1:\\n            self.locked_cnt[num] -= 1\\n            num = self.parent[num]\\n            \\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locked(num) or self.locked_cnt[num] == 0:\\n            return False\\n        \\n        # At this point, all ancestors have updated their locking\\n        # status based on upgrades, so we simply check the last\\n        # condition.\\n        ptr = num\\n        while ptr != -1:\\n            if self.locker[ptr] != -1:\\n                return False\\n            ptr = self.parent[ptr]\\n        \\n        # We can now upgrade the node\\n        self.used_levels[num] += 1\\n        self.level[num] = self.used_levels[num] \\n        self.locker[num] = user\\n        \\n        delta = self.locked_cnt[num]-1\\n        ptr = num\\n        while ptr != -1:\\n            self.locked_cnt[ptr] -= delta\\n            self.used_levels[ptr] = max(\\n                self.used_levels[ptr], self.used_levels[num])\\n            ptr = self.parent[ptr]\\n            \\n        return True\\n        \\n    \\n    def locked(self, num):\\n        path = []\\n        ptr = num\\n        while ptr != -1:\\n            path.append(ptr)\\n            ptr = self.parent[ptr]\\n        \\n        max_lvl = -1\\n        for par in path[::-1]:\\n            if max_lvl > self.level[par]:\\n                # Some ancestor has upgraded, unlock ourselves, \\n                # reset states, and upgrade ourselves too\\n                self.locked_cnt[par] = 0\\n                self.locker[par] = -1 \\n                self.level[par] = max_lvl\\n\\t\\t\\t\\tself.used_levels[par] = max_lvl\\n            \\n            max_lvl = max(max_lvl, self.level[par])\\n            \\n        return self.locker[num] != -1\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712268,
                "title": "java",
                "content": "```\\nclass LockingTree {\\n\\n    int[] parent;\\n    Map<Integer, Integer> nodeToUserLockMap;\\n    Map<Integer, Set<Integer>> graph;\\n    \\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        this.nodeToUserLockMap = new HashMap<>();\\n        graph = new HashMap<>();\\n        graph.computeIfAbsent(-1, x -> new HashSet<>()).add(0);\\n        for(int i = 0; i < parent.length; i++){\\n            graph.put(i, new HashSet<>());\\n        }\\n        for(int i = 0; i < parent.length; i++){\\n             graph.get(parent[i]).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (nodeToUserLockMap.containsKey(num)){\\n            return false;\\n        }\\n        nodeToUserLockMap.put(num, user);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (nodeToUserLockMap.containsKey(num)){\\n            int lockUser = nodeToUserLockMap.get(num);\\n            if (lockUser == user){\\n                nodeToUserLockMap.remove(num, lockUser);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (nodeToUserLockMap.containsKey(num)){\\n           return false;\\n        }\\n        \\n        Set<Integer> descendants = getDescendants(num);\\n        boolean anyLockedDescendants =\\n            nodeToUserLockMap.keySet().stream().anyMatch(key -> descendants.contains(key));\\n        \\n        Set<Integer> ancestors = getAncestors(num);\\n        boolean noneLockedAncestors = \\n            nodeToUserLockMap.keySet().stream().noneMatch(key -> ancestors.contains(key));\\n        \\n        if (anyLockedDescendants && noneLockedAncestors){\\n            for (int descendant : descendants){\\n                if (nodeToUserLockMap.containsKey(descendant)){\\n                     nodeToUserLockMap.remove(descendant);\\n                }\\n            }\\n            nodeToUserLockMap.put(num, user);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    private Set<Integer> getDescendants(int vertex){\\n        \\n        Set<Integer> set = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(vertex);\\n        while(!queue.isEmpty()){\\n            int curr = queue.poll();\\n            set.add(curr);\\n            for(int adjV: graph.get(curr)){\\n                queue.offer(adjV);\\n            }\\n        }\\n        return set;    \\n    }\\n    \\n    private Set<Integer> getAncestors(int vertex){\\n        \\n        Set<Integer> set  = new HashSet<>();\\n        int curr = vertex;\\n    \\n        while(curr != -1){\\n            set.add(curr);\\n            curr = parent[curr];\\n        }\\n        \\n        return set;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n\\n    int[] parent;\\n    Map<Integer, Integer> nodeToUserLockMap;\\n    Map<Integer, Set<Integer>> graph;\\n    \\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        this.nodeToUserLockMap = new HashMap<>();\\n        graph = new HashMap<>();\\n        graph.computeIfAbsent(-1, x -> new HashSet<>()).add(0);\\n        for(int i = 0; i < parent.length; i++){\\n            graph.put(i, new HashSet<>());\\n        }\\n        for(int i = 0; i < parent.length; i++){\\n             graph.get(parent[i]).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if (nodeToUserLockMap.containsKey(num)){\\n            return false;\\n        }\\n        nodeToUserLockMap.put(num, user);\\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if (nodeToUserLockMap.containsKey(num)){\\n            int lockUser = nodeToUserLockMap.get(num);\\n            if (lockUser == user){\\n                nodeToUserLockMap.remove(num, lockUser);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if (nodeToUserLockMap.containsKey(num)){\\n           return false;\\n        }\\n        \\n        Set<Integer> descendants = getDescendants(num);\\n        boolean anyLockedDescendants =\\n            nodeToUserLockMap.keySet().stream().anyMatch(key -> descendants.contains(key));\\n        \\n        Set<Integer> ancestors = getAncestors(num);\\n        boolean noneLockedAncestors = \\n            nodeToUserLockMap.keySet().stream().noneMatch(key -> ancestors.contains(key));\\n        \\n        if (anyLockedDescendants && noneLockedAncestors){\\n            for (int descendant : descendants){\\n                if (nodeToUserLockMap.containsKey(descendant)){\\n                     nodeToUserLockMap.remove(descendant);\\n                }\\n            }\\n            nodeToUserLockMap.put(num, user);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    private Set<Integer> getDescendants(int vertex){\\n        \\n        Set<Integer> set = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(vertex);\\n        while(!queue.isEmpty()){\\n            int curr = queue.poll();\\n            set.add(curr);\\n            for(int adjV: graph.get(curr)){\\n                queue.offer(adjV);\\n            }\\n        }\\n        return set;    \\n    }\\n    \\n    private Set<Integer> getAncestors(int vertex){\\n        \\n        Set<Integer> set  = new HashSet<>();\\n        int curr = vertex;\\n    \\n        while(curr != -1){\\n            set.add(curr);\\n            curr = parent[curr];\\n        }\\n        \\n        return set;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1691244,
                "title": "a-simple-solution-using-bfs-java",
                "content": "class LockingTree {\\n   int a[][];\\n   \\n\\tHashMap<Integer,List<Integer>> map=new HashMap<>();\\n    public LockingTree(int[] parent) {\\n        int l=parent.length;\\n        \\n        a=new int[l][2];\\n        \\n        for(int i=0;i<l;i++){\\n            a[i][0]=parent[i];\\n            a[i][1]=-1;\\n        \\n        \\n          map.putIfAbsent(parent[i],new ArrayList<>());\\n          List<Integer> p=map.get(parent[i]);\\n          p.add(i);\\n          map.put(parent[i],p);\\n        }\\n        \\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        int userId = a[num][1];\\n        \\n        if(userId==-1){\\n            a[num][1]=user;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        int y=a[num][1];\\n        \\n        if(y==user){\\n            a[num][1]=-1;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        \\n        int par=num;\\n        \\n        while(par>=0){\\n            int lop=a[par][1];\\n            if(lop!=-1){\\n                return false;\\n            }\\n            par=a[par][0];\\n        }\\n        \\n        \\n        int f=0;\\n        \\n        LinkedList<Integer> que=new LinkedList<>();\\n        int v[]=new int[a.length];\\n        que.add(num);\\n       \\n        v[num]=1;\\n        while(que.size()>0){\\n            int t=que.get(0);\\n            que.remove(0);\\n            List<Integer> p=map.getOrDefault(t,new ArrayList<>());\\n            \\n            for(int e: p ){\\n                \\n                if(a[e][1]!=-1){\\n                    f=1;\\n                    a[e][1]=-1;\\n                    \\n                }\\n                \\n                  if(v[e]==0){\\n                        que.add(e);\\n                        v[e]=1;\\n                   }\\n            }\\n            \\n        }\\n        \\n        if(f==1){\\n            a[num][1]=user;\\n            return true;\\n        }\\n\\n        return false;\\n        \\n        \\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class LockingTree {\\n   int a[][];\\n   \\n\\tHashMap<Integer,List<Integer>> map=new HashMap<>();\\n    public LockingTree(int[] parent) {\\n        int l=parent.length;\\n        \\n        a=new int[l][2];\\n        \\n        for(int i=0;i<l;i++){\\n            a[i][0]=parent[i];\\n            a[i][1]=-1;\\n        \\n        \\n          map.putIfAbsent(parent[i],new ArrayList<>());\\n          List<Integer> p=map.get(parent[i]);\\n          p.add(i);\\n          map.put(parent[i],p);\\n        }\\n        \\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        int userId = a[num][1];\\n        \\n        if(userId==-1){\\n            a[num][1]=user;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        int y=a[num][1];\\n        \\n        if(y==user){\\n            a[num][1]=-1;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        \\n        int par=num;\\n        \\n        while(par>=0){\\n            int lop=a[par][1];\\n            if(lop!=-1){\\n                return false;\\n            }\\n            par=a[par][0];\\n        }\\n        \\n        \\n        int f=0;\\n        \\n        LinkedList<Integer> que=new LinkedList<>();\\n        int v[]=new int[a.length];\\n        que.add(num);\\n       \\n        v[num]=1;\\n        while(que.size()>0){\\n            int t=que.get(0);\\n            que.remove(0);\\n            List<Integer> p=map.getOrDefault(t,new ArrayList<>());\\n            \\n            for(int e: p ){\\n                \\n                if(a[e][1]!=-1){\\n                    f=1;\\n                    a[e][1]=-1;\\n                    \\n                }\\n                \\n                  if(v[e]==0){\\n                        que.add(e);\\n                        v[e]=1;\\n                   }\\n            }\\n            \\n        }\\n        \\n        if(f==1){\\n            a[num][1]=user;\\n            return true;\\n        }\\n\\n        return false;\\n        \\n        \\n    }\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1690345,
                "title": "simple-and-easy-to-understand-code-in-python",
                "content": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.adj = [[] for _ in parent]\\n        self.m = {}\\n        for i in range(len(parent)):\\n            if parent[i] == -1:\\n                continue\\n            self.adj[parent[i]].append(i)\\n        \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.m:\\n            return False\\n        self.m[num] = user\\n        return True\\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.m.get(num) != user:\\n            return False\\n        key = self.m.pop(num, None)\\n        if key != None:\\n            return True\\n        return False\\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        print(num, user, self.m)\\n        if num in self.m:\\n            return False\\n        flag, flag1 = False, False\\n        i = num\\n        while i != -1: #It does not have any locked ancestors.\\n            if i in self.m:\\n               flag1 = True\\n            i = self.parent[i]\\n        if flag1 == True:\\n            return False\\n        stack = [num]\\n        descendant = []\\n        while stack: \\n            node = stack.pop()\\n            if node in self.m: descendant.append(node)\\n            for child in self.adj[node]: stack.append(child)\\n        if descendant: \\n            self.m[num] = user # lock given node \\n            for node in descendant: self.m.pop(node) # unlock all descendants\\n            return True \\n        return False # locked ancestor \\n        \\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.adj = [[] for _ in parent]\\n        self.m = {}\\n        for i in range(len(parent)):\\n            if parent[i] == -1:\\n                continue\\n            self.adj[parent[i]].append(i)\\n        \\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.m:\\n            return False\\n        self.m[num] = user\\n        return True\\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.m.get(num) != user:\\n            return False\\n        key = self.m.pop(num, None)\\n        if key != None:\\n            return True\\n        return False\\n        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        print(num, user, self.m)\\n        if num in self.m:\\n            return False\\n        flag, flag1 = False, False\\n        i = num\\n        while i != -1: #It does not have any locked ancestors.\\n            if i in self.m:\\n               flag1 = True\\n            i = self.parent[i]\\n        if flag1 == True:\\n            return False\\n        stack = [num]\\n        descendant = []\\n        while stack: \\n            node = stack.pop()\\n            if node in self.m: descendant.append(node)\\n            for child in self.adj[node]: stack.append(child)\\n        if descendant: \\n            self.m[num] = user # lock given node \\n            for node in descendant: self.m.pop(node) # unlock all descendants\\n            return True \\n        return False # locked ancestor \\n        \\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664158,
                "title": "python3-brute-force-dfs",
                "content": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        \\n        self.parent = parent\\n        self.children = defaultdict(lambda: [])\\n        for i,p in enumerate(parent):\\n            self.children[p].append(i)\\n        self.locked = defaultdict(lambda: -1)\\n        self.locked_nodes = set()\\n\\n    def lock(self, num: int, user: int) -> bool:\\n\\n        if num in self.locked_nodes:\\n            return False\\n        \\n        self.locked_nodes.add(num)\\n        self.locked[num] = user\\n        return True\\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        \\n        if self.locked[num] != user:\\n            return False\\n        \\n        self.locked[num] = -1\\n        self.locked_nodes.remove(num)\\n        return True\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        \\n        toUnlock = []\\n        \\n        #is the node unlocked\\n        if self.locked[num] != -1:\\n            return False\\n        \\n        #if it has at least one locked descendant (DFS)\\n        stack = [num]\\n        while stack:\\n            ans = stack.pop()\\n            for i in self.children[ans]:\\n                if i in self.locked_nodes:\\n                    toUnlock.append(i)\\n                stack.append(i)\\n                    \\n        if not toUnlock:\\n            return False\\n\\n        #does it have a locked ancestor\\n        upTree = num\\n        while upTree != -1:\\n            if upTree in self.locked_nodes:\\n                return False\\n            upTree = self.parent[upTree]\\n            \\n        #if all 3 satisfied, unlo9ck all its children and lock the node\\n        for u in toUnlock:\\n            self.locked[u] = -1\\n            self.locked_nodes.remove(u)\\n        \\n        self.locked_nodes.add(num)\\n        self.locked[num] = user\\n            \\n        return True\\n\\n    \\n    \\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)",
                "solutionTags": [],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        \\n        self.parent = parent\\n        self.children = defaultdict(lambda: [])\\n        for i,p in enumerate(parent):\\n            self.children[p].append(i)\\n        self.locked = defaultdict(lambda: -1)\\n        self.locked_nodes = set()\\n\\n    def lock(self, num: int, user: int) -> bool:\\n\\n        if num in self.locked_nodes:\\n            return False\\n        \\n        self.locked_nodes.add(num)\\n        self.locked[num] = user\\n        return True\\n        \\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        \\n        if self.locked[num] != user:\\n            return False\\n        \\n        self.locked[num] = -1\\n        self.locked_nodes.remove(num)\\n        return True\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        \\n        toUnlock = []\\n        \\n        #is the node unlocked\\n        if self.locked[num] != -1:\\n            return False\\n        \\n        #if it has at least one locked descendant (DFS)\\n        stack = [num]\\n        while stack:\\n            ans = stack.pop()\\n            for i in self.children[ans]:\\n                if i in self.locked_nodes:\\n                    toUnlock.append(i)\\n                stack.append(i)\\n                    \\n        if not toUnlock:\\n            return False\\n\\n        #does it have a locked ancestor\\n        upTree = num\\n        while upTree != -1:\\n            if upTree in self.locked_nodes:\\n                return False\\n            upTree = self.parent[upTree]\\n            \\n        #if all 3 satisfied, unlo9ck all its children and lock the node\\n        for u in toUnlock:\\n            self.locked[u] = -1\\n            self.locked_nodes.remove(u)\\n        \\n        self.locked_nodes.add(num)\\n        self.locked[num] = user\\n            \\n        return True\\n\\n    \\n    \\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)",
                "codeTag": "Java"
            },
            {
                "id": 1645312,
                "title": "java",
                "content": "Had to add a cache of descendants since i was getting TLE\\n- an improvement that can be made is that I don\\'t need to traverse all descendants twice. Check all other conditions for `upgrade` and then perform the unlocking of decsdendants, if any were succesful return true, else false. \\n```java\\n    \\n    private final int[] parent;\\n    private final Map<Integer, Integer> map;\\n    private final List<Integer>[] tree;\\n    private final Map<Integer, List<Integer>> cache;\\n\\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        map = new HashMap<>();\\n        cache = new HashMap<>();\\n        tree = new ArrayList[parent.length];\\n        for(int i = 0; i < tree.length; i++) tree[i] = new ArrayList<>();\\n        for(int i = 1; i < parent.length; i++) tree[parent[i]].add(i);\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(!map.containsKey(num)){\\n            map.put(num, user);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(map.containsKey(num)){\\n            if(map.get(num) == user){\\n                map.remove(num);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        List<Integer> descendants;\\n        if(map.containsKey(num) || lockedAncestors(num) ||  !lockedDescendants(descendants = descendants(num))){\\n            return false;\\n        }\\n        for(int descendant : descendants(num))\\n            if(map.containsKey(descendant))\\n                map.remove(descendant);\\n        map.put(num, user);\\n        return true;\\n    }\\n    \\n    public boolean lockedAncestors(int num){\\n        if(num < 0) return false;\\n        int p = parent[num];\\n        return map.containsKey(p) || lockedAncestors(p);\\n    }\\n    \\n    public boolean lockedDescendants(List<Integer> descendants){\\n        for(int descendant : descendants)\\n            if(map.containsKey(descendant)) return true;\\n        return false;\\n    }\\n    \\n    public List<Integer> descendants(int num){\\n        if(cache.containsKey(num)) return cache.get(num);\\n        List<Integer> children = new ArrayList<>();\\n        for(int child : tree[num]){\\n            children.add(child);\\n            children.addAll(descendants(child));\\n        }\\n        cache.put(num, children);\\n        return children;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    \\n    private final int[] parent;\\n    private final Map<Integer, Integer> map;\\n    private final List<Integer>[] tree;\\n    private final Map<Integer, List<Integer>> cache;\\n\\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n        map = new HashMap<>();\\n        cache = new HashMap<>();\\n        tree = new ArrayList[parent.length];\\n        for(int i = 0; i < tree.length; i++) tree[i] = new ArrayList<>();\\n        for(int i = 1; i < parent.length; i++) tree[parent[i]].add(i);\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(!map.containsKey(num)){\\n            map.put(num, user);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(map.containsKey(num)){\\n            if(map.get(num) == user){\\n                map.remove(num);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        List<Integer> descendants;\\n        if(map.containsKey(num) || lockedAncestors(num) ||  !lockedDescendants(descendants = descendants(num))){\\n            return false;\\n        }\\n        for(int descendant : descendants(num))\\n            if(map.containsKey(descendant))\\n                map.remove(descendant);\\n        map.put(num, user);\\n        return true;\\n    }\\n    \\n    public boolean lockedAncestors(int num){\\n        if(num < 0) return false;\\n        int p = parent[num];\\n        return map.containsKey(p) || lockedAncestors(p);\\n    }\\n    \\n    public boolean lockedDescendants(List<Integer> descendants){\\n        for(int descendant : descendants)\\n            if(map.containsKey(descendant)) return true;\\n        return false;\\n    }\\n    \\n    public List<Integer> descendants(int num){\\n        if(cache.containsKey(num)) return cache.get(num);\\n        List<Integer> children = new ArrayList<>();\\n        for(int child : tree[num]){\\n            children.add(child);\\n            children.addAll(descendants(child));\\n        }\\n        cache.put(num, children);\\n        return children;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1630537,
                "title": "easy-c-solution-with-comments",
                "content": "// used map for keeping track of parents so that parents traversing would be easier \\n// map for keeping record of user locked node\\n// boolean array for node status\\n// adj matrix for tree as it is easier way since it\\'s a tree then no issue of cycle.\\n\\n```\\nclass LockingTree {\\npublic:\\n    \\n    bool status[2002];\\n    map<int,int> par,usd;\\n    vector<vector<int>> mad;\\n    \\n    \\n    LockingTree(vector<int>& parent) {\\n        int n=parent.size();\\n        mad.resize(n);\\n        par[0]=-1;\\n        for(int i=1;i<n;i++)\\n        {\\n            mad[parent[i]].push_back(i);\\n            par[i]=parent[i];\\n        }\\n        memset(status,false,sizeof(status));\\n        usd.clear();\\n    }\\n    \\n    bool lock(int num, int user) {\\n        \\n        if(status[num]==false)\\n        {\\n            status[num]=true;\\n            usd[num]=user;\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    bool unlock(int num, int user) {\\n        \\n        if(status[num]==true)\\n        {\\n            if(usd[num]==user)\\n            {\\n                status[num]=false;\\n                usd.erase(num);\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(status[num]==true)\\n        {\\n           // cout<<\"this d\\\\n\";\\n            return false;\\n        }\\n        int temp=num;\\n        bool p=false;\\n        while(temp!=-1)\\n        {\\n            if(status[temp]==true)\\n            {\\n                p=true;\\n            }\\n            temp=par[temp];\\n        }\\n        if(p==true)\\n        {\\n           // cout<<\"thisf\\\\n\";\\n            return false;\\n        }\\n        \\n        queue<int> g;\\n        g.push(num);\\n        while(!g.empty())\\n        {\\n            int r=g.front();\\n            g.pop();\\n            for(int i=0;i<mad[r].size();i++)\\n            {\\n               // cout<<mad[r][i]<<\" \";\\n                if(status[mad[r][i]]==true)\\n                {\\n                    p=true;\\n                    status[mad[r][i]]=false;\\n                    \\n                    usd.erase(mad[r][i]);\\n                }\\n                g.push(mad[r][i]);\\n            }\\n            \\n        }\\n        \\n        if(p==true)\\n        {\\n            status[num]=true;\\n            usd[num]=user;\\n            return true;\\n        }\\n       // cout<<endl;\\n       // cout<<\"this l\\\\n\";\\n        \\n        return false;\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "// used map for keeping track of parents so that parents traversing would be easier \\n// map for keeping record of user locked node\\n// boolean array for node status\\n// adj matrix for tree as it is easier way since it\\'s a tree then no issue of cycle.\\n\\n```\\nclass LockingTree {\\npublic:\\n    \\n    bool status[2002];\\n    map<int,int> par,usd;\\n    vector<vector<int>> mad;\\n    \\n    \\n    LockingTree(vector<int>& parent) {\\n        int n=parent.size();\\n        mad.resize(n);\\n        par[0]=-1;\\n        for(int i=1;i<n;i++)\\n        {\\n            mad[parent[i]].push_back(i);\\n            par[i]=parent[i];\\n        }\\n        memset(status,false,sizeof(status));\\n        usd.clear();\\n    }\\n    \\n    bool lock(int num, int user) {\\n        \\n        if(status[num]==false)\\n        {\\n            status[num]=true;\\n            usd[num]=user;\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    bool unlock(int num, int user) {\\n        \\n        if(status[num]==true)\\n        {\\n            if(usd[num]==user)\\n            {\\n                status[num]=false;\\n                usd.erase(num);\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(status[num]==true)\\n        {\\n           // cout<<\"this d\\\\n\";\\n            return false;\\n        }\\n        int temp=num;\\n        bool p=false;\\n        while(temp!=-1)\\n        {\\n            if(status[temp]==true)\\n            {\\n                p=true;\\n            }\\n            temp=par[temp];\\n        }\\n        if(p==true)\\n        {\\n           // cout<<\"thisf\\\\n\";\\n            return false;\\n        }\\n        \\n        queue<int> g;\\n        g.push(num);\\n        while(!g.empty())\\n        {\\n            int r=g.front();\\n            g.pop();\\n            for(int i=0;i<mad[r].size();i++)\\n            {\\n               // cout<<mad[r][i]<<\" \";\\n                if(status[mad[r][i]]==true)\\n                {\\n                    p=true;\\n                    status[mad[r][i]]=false;\\n                    \\n                    usd.erase(mad[r][i]);\\n                }\\n                g.push(mad[r][i]);\\n            }\\n            \\n        }\\n        \\n        if(p==true)\\n        {\\n            status[num]=true;\\n            usd[num]=user;\\n            return true;\\n        }\\n       // cout<<endl;\\n       // cout<<\"this l\\\\n\";\\n        \\n        return false;\\n        \\n    }\\n};\\n",
                "codeTag": "C++"
            },
            {
                "id": 1595920,
                "title": "java-solution-dfs-map",
                "content": "\\tclass LockingTree {\\n    int[] parent = null;\\n    Map<Integer, Integer> lockMap = null;\\n    Map<Integer, List<Integer>> childMap = null;\\n\\n    public LockingTree(int[] parent) \\n    {\\n        this.parent = parent;\\n        this.lockMap = new HashMap<>();\\n        this.childMap = new HashMap<>();\\n        for(int i = 0; i < this.parent.length; i++)\\n        {\\n            this.childMap.putIfAbsent(this.parent[i], new ArrayList<Integer>());\\n            this.childMap.get(this.parent[i]).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(!this.lockMap.containsKey(num))\\n        {\\n            this.lockMap.put(num, user);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(this.lockMap.containsKey(num) && this.lockMap.get(num) == user)\\n        {\\n            this.lockMap.remove(num);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if(this.lockMap.containsKey(num))\\n        {\\n            return false;\\n        }\\n        \\n        if(!isAnyDecendentLocked(num, new HashSet<Integer>()))\\n        {\\n            return false;\\n        }\\n        \\n        if(!isAnyAncestorsLocked(num))\\n        {\\n            return false;\\n        }\\n        \\n        unlockAllDecendents(num, new HashSet<Integer>());\\n        this.lockMap.put(num, user);\\n        return true;\\n    }\\n    \\n    void unlockAllDecendents(int src, Set<Integer> visited)\\n    {\\n        if(this.lockMap.containsKey(src))\\n        {\\n            this.lockMap.remove(src);\\n        }\\n        \\n        if(visited.contains(src))\\n        {\\n            return;\\n        }\\n        \\n        visited.add(src);\\n        if(this.childMap.containsKey(src))\\n        {\\n            for(Integer child : this.childMap.get(src))\\n            {\\n                unlockAllDecendents(child, visited);\\n            }   \\n        }\\n    }\\n    \\n    boolean isAnyDecendentLocked(int src, Set<Integer> visited)\\n    {\\n        if(this.lockMap.containsKey(src))\\n        {\\n            return true;\\n        }\\n        \\n        if(visited.contains(src))\\n        {\\n            return false;\\n        }\\n        \\n        visited.add(src);\\n        \\n        if(this.childMap.containsKey(src))\\n        {\\n            for(int child : this.childMap.get(src))\\n            {\\n                if(isAnyDecendentLocked(child, visited)) return true;\\n            }   \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean isAnyAncestorsLocked(int num)\\n    {\\n        while(num != -1)\\n        {\\n            num = this.parent[num];\\n            if(this.lockMap.containsKey(num))\\n            {\\n                return false;\\n            }   \\n        }\\n        \\n        return true;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "\\tclass LockingTree {\\n    int[] parent = null;\\n    Map<Integer, Integer> lockMap = null;\\n    Map<Integer, List<Integer>> childMap = null;\\n\\n    public LockingTree(int[] parent) \\n    {\\n        this.parent = parent;\\n        this.lockMap = new HashMap<>();\\n        this.childMap = new HashMap<>();\\n        for(int i = 0; i < this.parent.length; i++)\\n        {\\n            this.childMap.putIfAbsent(this.parent[i], new ArrayList<Integer>());\\n            this.childMap.get(this.parent[i]).add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(!this.lockMap.containsKey(num))\\n        {\\n            this.lockMap.put(num, user);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(this.lockMap.containsKey(num) && this.lockMap.get(num) == user)\\n        {\\n            this.lockMap.remove(num);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if(this.lockMap.containsKey(num))\\n        {\\n            return false;\\n        }\\n        \\n        if(!isAnyDecendentLocked(num, new HashSet<Integer>()))\\n        {\\n            return false;\\n        }\\n        \\n        if(!isAnyAncestorsLocked(num))\\n        {\\n            return false;\\n        }\\n        \\n        unlockAllDecendents(num, new HashSet<Integer>());\\n        this.lockMap.put(num, user);\\n        return true;\\n    }\\n    \\n    void unlockAllDecendents(int src, Set<Integer> visited)\\n    {\\n        if(this.lockMap.containsKey(src))\\n        {\\n            this.lockMap.remove(src);\\n        }\\n        \\n        if(visited.contains(src))\\n        {\\n            return;\\n        }\\n        \\n        visited.add(src);\\n        if(this.childMap.containsKey(src))\\n        {\\n            for(Integer child : this.childMap.get(src))\\n            {\\n                unlockAllDecendents(child, visited);\\n            }   \\n        }\\n    }\\n    \\n    boolean isAnyDecendentLocked(int src, Set<Integer> visited)\\n    {\\n        if(this.lockMap.containsKey(src))\\n        {\\n            return true;\\n        }\\n        \\n        if(visited.contains(src))\\n        {\\n            return false;\\n        }\\n        \\n        visited.add(src);\\n        \\n        if(this.childMap.containsKey(src))\\n        {\\n            for(int child : this.childMap.get(src))\\n            {\\n                if(isAnyDecendentLocked(child, visited)) return true;\\n            }   \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean isAnyAncestorsLocked(int num)\\n    {\\n        while(num != -1)\\n        {\\n            num = this.parent[num];\\n            if(this.lockMap.containsKey(num))\\n            {\\n                return false;\\n            }   \\n        }\\n        \\n        return true;\\n    }\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1541304,
                "title": "upgrade-operation-time-lg-n-java-stamp-solution-no-hash-no-bfs-100-faster",
                "content": "```\\n\\tclass LockingTree {\\n\\n        private int stamp = 0;\\n        private final int n;\\n        private final int[] parent;\\n        private final int uTimes[];\\n        private final int gTimes[];\\n        private final int childCount[];\\n        private final int users[];\\n        private final int path[];\\n\\n        public LockingTree(int[] parent) {\\n            this.parent = parent;\\n            this.n = parent.length;\\n            this.uTimes = new int[n];\\n            this.gTimes = new int[n];\\n            this.users = new int[n];\\n            this.path = new int[n];\\n            this.childCount = new int[n];\\n        }\\n\\n        public boolean lock(int num, int user) {\\n            stamp++;\\n            fixup(num);\\n            if (users[num] != 0) {\\n                return false;\\n            }\\n            users[num] = user;\\n            uTimes[num] = stamp;\\n            int p = parent[num];\\n            while (p != -1) {\\n                uTimes[p] = stamp;\\n                childCount[p]++;\\n                p = parent[p];\\n            }\\n            return true;\\n        }\\n\\n        public boolean unlock(int num, int user) {\\n            stamp++;\\n            fixup(num);\\n            if (users[num] != user) {\\n                return false;\\n            }\\n            users[num] = 0;\\n            uTimes[num] = stamp;\\n            int p = parent[num];\\n            while (p != -1) {\\n                uTimes[p] = stamp;\\n                childCount[p]--;\\n                p = parent[p];\\n            }\\n            return true;\\n        }\\n\\n        private void fixup(int num) {\\n            int index = 0;\\n            path[index] = num;\\n            int p = num;\\n            while (parent[p] != -1) {\\n                p = path[++index] = parent[p];\\n            }\\n            int maxGTime = 0;\\n            for (int i = index; i >= 0; i--) {\\n                int x = path[i];\\n                if (uTimes[x] < maxGTime) { //\\u672A\\u66F4\\u65B0\\n                    childCount[x] = 0;\\n                    uTimes[x] = stamp;\\n                    users[x] = 0;\\n                }\\n                maxGTime = Math.max(maxGTime, gTimes[x]);\\n            }\\n        }\\n\\n        public boolean upgrade(int num, int user) {\\n            stamp++;\\n            fixup(num);\\n            int p = num;\\n            while (p != -1 && users[p] == 0) {\\n                p = parent[p];\\n            }\\n            if (p != -1 || childCount[num] == 0)\\n                return false;\\n            int cu = 1 - childCount[num];\\n            childCount[num] = 0;\\n            users[num] = user;\\n            uTimes[num] = gTimes[num] = stamp;\\n            p = parent[num];\\n            while (p != -1) {\\n                childCount[p] += cu;\\n                uTimes[p] = stamp;\\n                p = parent[p];\\n            }\\n            return true;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass LockingTree {\\n\\n        private int stamp = 0;\\n        private final int n;\\n        private final int[] parent;\\n        private final int uTimes[];\\n        private final int gTimes[];\\n        private final int childCount[];\\n        private final int users[];\\n        private final int path[];\\n\\n        public LockingTree(int[] parent) {\\n            this.parent = parent;\\n            this.n = parent.length;\\n            this.uTimes = new int[n];\\n            this.gTimes = new int[n];\\n            this.users = new int[n];\\n            this.path = new int[n];\\n            this.childCount = new int[n];\\n        }\\n\\n        public boolean lock(int num, int user) {\\n            stamp++;\\n            fixup(num);\\n            if (users[num] != 0) {\\n                return false;\\n            }\\n            users[num] = user;\\n            uTimes[num] = stamp;\\n            int p = parent[num];\\n            while (p != -1) {\\n                uTimes[p] = stamp;\\n                childCount[p]++;\\n                p = parent[p];\\n            }\\n            return true;\\n        }\\n\\n        public boolean unlock(int num, int user) {\\n            stamp++;\\n            fixup(num);\\n            if (users[num] != user) {\\n                return false;\\n            }\\n            users[num] = 0;\\n            uTimes[num] = stamp;\\n            int p = parent[num];\\n            while (p != -1) {\\n                uTimes[p] = stamp;\\n                childCount[p]--;\\n                p = parent[p];\\n            }\\n            return true;\\n        }\\n\\n        private void fixup(int num) {\\n            int index = 0;\\n            path[index] = num;\\n            int p = num;\\n            while (parent[p] != -1) {\\n                p = path[++index] = parent[p];\\n            }\\n            int maxGTime = 0;\\n            for (int i = index; i >= 0; i--) {\\n                int x = path[i];\\n                if (uTimes[x] < maxGTime) { //\\u672A\\u66F4\\u65B0\\n                    childCount[x] = 0;\\n                    uTimes[x] = stamp;\\n                    users[x] = 0;\\n                }\\n                maxGTime = Math.max(maxGTime, gTimes[x]);\\n            }\\n        }\\n\\n        public boolean upgrade(int num, int user) {\\n            stamp++;\\n            fixup(num);\\n            int p = num;\\n            while (p != -1 && users[p] == 0) {\\n                p = parent[p];\\n            }\\n            if (p != -1 || childCount[num] == 0)\\n                return false;\\n            int cu = 1 - childCount[num];\\n            childCount[num] = 0;\\n            users[num] = user;\\n            uTimes[num] = gTimes[num] = stamp;\\n            p = parent[num];\\n            while (p != -1) {\\n                childCount[p] += cu;\\n                uTimes[p] = stamp;\\n                p = parent[p];\\n            }\\n            return true;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531985,
                "title": "golang-97-fater",
                "content": "```\\ntype LockingTree struct {\\n\\tch [][]int\\n\\tl  []int\\n\\tp  []int\\n}\\n\\nfunc Constructor(p []int) LockingTree {\\n\\tt := LockingTree{\\n\\t\\tp: p,\\n\\t\\tl: make([]int, len(p)),\\n\\t}\\n\\tch := make([][]int, len(p))\\n\\tfor i := range p {\\n\\t\\tif p[i] == -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tch[p[i]] = append(ch[p[i]], i)\\n\\t}\\n\\tfor i := range t.l {\\n\\t\\tt.l[i] = -1\\n\\t}\\n\\tt.ch = ch\\n\\treturn t\\n}\\n\\nfunc (t *LockingTree) Lock(n int, u int) bool {\\n\\tif t.l[n] == -1 {\\n\\t\\tt.l[n] = u\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc (t *LockingTree) Unlock(n int, u int) bool {\\n\\tif t.l[n] != u {\\n\\t\\treturn false\\n\\t}\\n\\tt.l[n] = -1\\n\\treturn true\\n}\\n\\nfunc (t *LockingTree) Upgrade(n int, u int) bool {\\n\\tif t.l[n] != u && t.l[n] != -1 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tp := t.p[n]\\n\\tfor p != -1 {\\n\\t\\tif t.l[p] != -1 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tp = t.p[p]\\n\\t}\\n\\tc := 0\\n\\tvar d func(int)\\n\\td = func(cn int) {\\n\\t\\tif t.l[cn] != -1 {\\n\\t\\t\\tc++\\n\\t\\t\\tt.l[cn] = -1\\n\\t\\t}\\n\\t\\tfor i := range t.ch[cn] {\\n\\t\\t\\td(t.ch[cn][i])\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := range t.ch[n] {\\n\\t\\td(t.ch[n][i])\\n\\t}\\n\\tif c > 0 {\\n\\t\\tt.l[n] = u\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntype LockingTree struct {\\n\\tch [][]int\\n\\tl  []int\\n\\tp  []int\\n}\\n\\nfunc Constructor(p []int) LockingTree {\\n\\tt := LockingTree{\\n\\t\\tp: p,\\n\\t\\tl: make([]int, len(p)),\\n\\t}\\n\\tch := make([][]int, len(p))\\n\\tfor i := range p {\\n\\t\\tif p[i] == -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tch[p[i]] = append(ch[p[i]], i)\\n\\t}\\n\\tfor i := range t.l {\\n\\t\\tt.l[i] = -1\\n\\t}\\n\\tt.ch = ch\\n\\treturn t\\n}\\n\\nfunc (t *LockingTree) Lock(n int, u int) bool {\\n\\tif t.l[n] == -1 {\\n\\t\\tt.l[n] = u\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc (t *LockingTree) Unlock(n int, u int) bool {\\n\\tif t.l[n] != u {\\n\\t\\treturn false\\n\\t}\\n\\tt.l[n] = -1\\n\\treturn true\\n}\\n\\nfunc (t *LockingTree) Upgrade(n int, u int) bool {\\n\\tif t.l[n] != u && t.l[n] != -1 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tp := t.p[n]\\n\\tfor p != -1 {\\n\\t\\tif t.l[p] != -1 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tp = t.p[p]\\n\\t}\\n\\tc := 0\\n\\tvar d func(int)\\n\\td = func(cn int) {\\n\\t\\tif t.l[cn] != -1 {\\n\\t\\t\\tc++\\n\\t\\t\\tt.l[cn] = -1\\n\\t\\t}\\n\\t\\tfor i := range t.ch[cn] {\\n\\t\\t\\td(t.ch[cn][i])\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := range t.ch[n] {\\n\\t\\td(t.ch[n][i])\\n\\t}\\n\\tif c > 0 {\\n\\t\\tt.l[n] = u\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520656,
                "title": "simple-c-solution",
                "content": "```\\nclass LockingTree {\\n    vector<int> L,P;\\n    vector<vector<int>> D;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        int n=parent.size();\\n        P=parent;\\n        D= vector<vector<int>> (n);\\n        for(int i=1;i<n;i++){\\n            D[parent[i]].push_back(i);\\n        }\\n        \\n        L=vector<int> (n,0);\\n        \\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(L[num]!=0) return false;\\n        L[num]=user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(L[num]!=user) return false;\\n        L[num]=0;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        int x=num;\\n        while(x!=-1){\\n            if(L[x]!=0) return false;\\n            x=P[x];\\n        }\\n        vector<int> LD;\\n        stack<int> S;\\n        S.push(num);\\n        while(!S.empty()){\\n            int T=S.top();\\n            S.pop();\\n            if(L[T]!=0){\\n                LD.push_back(T);\\n            }\\n            for(int i=0;i<D[T].size();i++){\\n                S.push(D[T][i]);\\n            }\\n        }\\n        if(LD.size()==0) return false;\\n        L[num]=user;\\n        for(int i=0;i<LD.size();i++)\\n            L[LD[i]]=0;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\n    vector<int> L,P;\\n    vector<vector<int>> D;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        int n=parent.size();\\n        P=parent;\\n        D= vector<vector<int>> (n);\\n        for(int i=1;i<n;i++){\\n            D[parent[i]].push_back(i);\\n        }\\n        \\n        L=vector<int> (n,0);\\n        \\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(L[num]!=0) return false;\\n        L[num]=user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(L[num]!=user) return false;\\n        L[num]=0;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        int x=num;\\n        while(x!=-1){\\n            if(L[x]!=0) return false;\\n            x=P[x];\\n        }\\n        vector<int> LD;\\n        stack<int> S;\\n        S.push(num);\\n        while(!S.empty()){\\n            int T=S.top();\\n            S.pop();\\n            if(L[T]!=0){\\n                LD.push_back(T);\\n            }\\n            for(int i=0;i<D[T].size();i++){\\n                S.push(D[T][i]);\\n            }\\n        }\\n        if(LD.size()==0) return false;\\n        L[num]=user;\\n        for(int i=0;i<LD.size();i++)\\n            L[LD[i]]=0;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1518575,
                "title": "python-solution-dfs-dict",
                "content": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.childs = collections.defaultdict(list)\\n        self.lock_table = collections.defaultdict(lambda: None)\\n        \\n        for c, p in enumerate(parent):\\n            if p >= 0:\\n                self.childs[p].append(c)\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        # lock this node (assign to user), if this is locked,\\n        # no one can lock this node.\\n        # it needs dict. {num: user}\\n        if self.lock_table[num] is None:\\n            self.lock_table[num] = user\\n            return True\\n        else:\\n            return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        # unlock this node if this node is locked by user.\\n        if self.lock_table[num] == user:\\n            self.lock_table[num] = None\\n            return True\\n        else:\\n            return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        # lock current nodes\\n        if self.lock_table[num] is None and \\\\\\n                self.see_descendant(num) and \\\\\\n                self.see_ancestor(num):\\n            self.unlock_decendant(num)\\n            self.lock_table[num] = user\\n\\n            return True\\n        else:\\n            return False\\n            \\n            \\n    def unlock_decendant(self, num):\\n        # unlock all decendants using DFS.\\n        self.lock_table[num] = None\\n        for child in self.childs[num]:\\n            self.unlock_decendant(child)\\n    \\n    def see_descendant(self, num):\\n        # DFS\\n        if self.lock_table[num] is not None:\\n            return True\\n        \\n        for child in self.childs[num]:\\n            ret = self.see_descendant(child)\\n            if ret:\\n                return True\\n        return False\\n    \\n    def see_ancestor(self, num):\\n        # DFS\\n        if num == -1:\\n            return True\\n        if self.lock_table[num] is not None:\\n            return False\\n        \\n        return self.see_ancestor(self.parent[num])\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.parent = parent\\n        self.childs = collections.defaultdict(list)\\n        self.lock_table = collections.defaultdict(lambda: None)\\n        \\n        for c, p in enumerate(parent):\\n            if p >= 0:\\n                self.childs[p].append(c)\\n        \\n    def lock(self, num: int, user: int) -> bool:\\n        # lock this node (assign to user), if this is locked,\\n        # no one can lock this node.\\n        # it needs dict. {num: user}\\n        if self.lock_table[num] is None:\\n            self.lock_table[num] = user\\n            return True\\n        else:\\n            return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        # unlock this node if this node is locked by user.\\n        if self.lock_table[num] == user:\\n            self.lock_table[num] = None\\n            return True\\n        else:\\n            return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        # lock current nodes\\n        if self.lock_table[num] is None and \\\\\\n                self.see_descendant(num) and \\\\\\n                self.see_ancestor(num):\\n            self.unlock_decendant(num)\\n            self.lock_table[num] = user\\n\\n            return True\\n        else:\\n            return False\\n            \\n            \\n    def unlock_decendant(self, num):\\n        # unlock all decendants using DFS.\\n        self.lock_table[num] = None\\n        for child in self.childs[num]:\\n            self.unlock_decendant(child)\\n    \\n    def see_descendant(self, num):\\n        # DFS\\n        if self.lock_table[num] is not None:\\n            return True\\n        \\n        for child in self.childs[num]:\\n            ret = self.see_descendant(child)\\n            if ret:\\n                return True\\n        return False\\n    \\n    def see_ancestor(self, num):\\n        # DFS\\n        if num == -1:\\n            return True\\n        if self.lock_table[num] is not None:\\n            return False\\n        \\n        return self.see_ancestor(self.parent[num])\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473794,
                "title": "asymptotically-efficient-solution-using-lazy-updates-sequence-number-and-versioning",
                "content": "This solution guarantees each of the `lock()`, `unlock()`, and `upgrade()` operations has `O(height of tree)` time complexity (i.e., it avoids overly expensive operations such as finding and storing all children of a node in some array, looping through all children of a node, or looping through all descendants of a node, etc).\\n\\nFor me this seemed a bit tricky to implement correctly to be honest, but it was a fun challenge.\\n\\nHow it does that:\\n\\n- Each of the `lock()`, `unlock()`, and `upgrade()` operations is assigned a monotonically increasing sequence number (by post-incrementing `seq_` each time).\\n- `ower_` tracks the last known lock owner of each node from `lock()` and `unlock()` operations (for `unlock()`, the last known owner becomes `-1`), but will not reflect the effect of `upgrade()` operations.\\n- `lockSeq_` tracks the highest sequence number from `lock()` or `unlock()` operation(s) applied to each node.\\n- `upgradeSeq_` tracks the highest sequence number from `upgrade()` operation(s) applied to each node.\\n- `numLockedDescendants_` tracks the number of locked descedents of each node, but is updated lazily with respect to `upgrade()` operations, so some entries may be out-of-date after an `upgrade()` operation takes place.\\n- Which is why we also need the `version_` array: if `version_[p] == seq`, then `numLockedDescendants_[p]` is up-to-date with respect to the `upgrade()` operation having sequence number `seq`.\\n- To determine whether a node is locked, we first check its last known owner in `owner_`. If the last known owner is `-1`, then it is definitely unlocked. If its last known owner in `owner_` is not `-1`, but its last lock / unlock sequence number is lower than the upgrade sequence number of one of its ancestors, then the upgrade op on some ancestor node has unlocked this node, so, it is still unlocked. If otherwise (i.e., there is some last known owner, and the node\\'s lock seq num is higher than the upgrade seq num of any of its ancestors), then it is currently locked, because the `lock()` operation on this node is more recent than any `upgrade()` operation in any of the ancestors.\\n- And then the rest is just a matter of updating the `version_` and the `numLockedDescendants_` arrays correctly, with lazy updates being applied to the latter for efficienty reasons. The code should be fairly comprehensible with inline comment so I won\\'t bother describing all of those things in words here.\\n\\n```\\nconstexpr int kNone = -1;\\n\\nclass LockingTree {\\npublic:\\n    LockingTree(vector<int>const & parent) : n_(parent.size()), parent_(parent) {\\n        owner_ = vector<int>(n_, kNone);\\n        lockSeq_.resize(n_);\\n        upgradeSeq_.resize(n_);\\n        version_.resize(n_);\\n        numLockedDescendants_.resize(n_);\\n    }\\n\\n    bool lock(int const num, int const user) {\\n        int max_upgrade_seq;\\n        // <node num, upgrade seq>\\n        vector<pair<int, int>> ancestors;\\n        // We want to find the upgrade operation performed on any ancestor of the\\n\\t\\t// current node with the highest sequence number.\\n        // For lock() operation, we must ensure numLockedDescendants_[p]\\n\\t\\t// is up-to-date with respect to all previous upgrade() operations for each\\n\\t\\t// ancestor node of p. This means we need to determine whether any\\n\\t\\t// upgrade() operation on any ancestor of p took place after the last\\n\\t\\t// update to numLockedDescendants_[p]. If yes, then\\n\\t\\t// numLockedDescendants_[p] is zeroed out because the upgrade op\\n\\t\\t// of an ancestor of p unlocks p and p\\'s descendants.\\n        // This is done by calling updateNumLockedDescendantsArray().\\n        updateNumLockedDescendantsArray(max_upgrade_seq, ancestors, num);\\n        if (owner_[num] == kNone || lockSeq_[num] < max_upgrade_seq) {\\n            owner_[num] = user;\\n            auto const seq = seq_++;\\n            lockSeq_[num] = seq;\\n            for (auto const& a : ancestors)\\n                ++numLockedDescendants_[a.first];\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    bool unlock(int const num, int const user) {\\n        int max_upgrade_seq = 0;\\n        vector<int> ancestors;\\n        for (int p = parent_[num]; p != kNone; p = parent_[p]) {\\n            max_upgrade_seq = max(max_upgrade_seq, upgradeSeq_[p]);\\n            ancestors.push_back(p);\\n        }\\n        if (owner_[num] == user && lockSeq_[num] > max_upgrade_seq) {\\n\\t\\t    // If the current node is locked, then numLockedDescendants_[p] for each ancestor p\\n\\t\\t\\t// of the current node was already kept up-to-date wtih respect to all previous upgrade()\\n\\t\\t\\t// operations by the last lock() or upgrade() operation on the current code, so, we don\\'t\\n\\t\\t\\t// need worry about numLockedDescendants_[p] being out-of-date here as it is impossible\\n\\t\\t\\t// by design.\\n            owner_[num] = kNone;\\n            auto const seq = seq_++;\\n            lockSeq_[num] = seq;\\n            for (auto const p : ancestors)\\n                --numLockedDescendants_[p];\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    bool upgrade(int const num, int const user) {\\n        int max_upgrade_seq;\\n        // <node num, upgrade seq>\\n        vector<pair<int, int>> ancestors;\\n\\t\\t// Similar to what happens in lock(), we must first push down the deferred updates\\n\\t\\t// to the ancestor entries in numLockedDescendants_ to maintain correctness.\\n        updateNumLockedDescendantsArray(max_upgrade_seq, ancestors, num);\\n        max_upgrade_seq = 0;\\n        // check all ancestors are unlocked\\n        for (auto iter = ancestors.rbegin(); iter != ancestors.rend(); ++iter) {\\n            auto const p = iter->first;\\n            if (owner_[p] != kNone && lockSeq_[p] > max_upgrade_seq)\\n                return false;\\n            max_upgrade_seq = max(max_upgrade_seq, iter->second);\\n        }\\n        // check the node itself is unlocked\\n        if (owner_[num] != kNone && lockSeq_[num] > max_upgrade_seq)\\n            return false;\\n        // check number of locked descendants is not 0\\n        if (version_[num] < max_upgrade_seq || numLockedDescendants_[num] == 0) return false;\\n        // perform the upgrade op \\n        auto const seq = seq_++;\\n        owner_[num] = user;\\n        lockSeq_[num] = seq;\\n        upgradeSeq_[num] = seq;\\n        auto const n = numLockedDescendants_[num];\\n        numLockedDescendants_[num] = 0;\\n        version_[num] = seq;\\n        for (auto const& a : ancestors)\\n            numLockedDescendants_[a.first] -= n - 1;\\n        return true;\\n    }\\nprivate:\\n    void updateNumLockedDescendantsArray(int& max_upgrade_seq, vector<pair<int, int>>& ancestors, int const num) {\\n        for (int p = parent_[num]; p != kNone; p = parent_[p])\\n            ancestors.emplace_back(p, upgradeSeq_[p]);\\n        max_upgrade_seq = 0;\\n        for (auto iter = ancestors.rbegin(); iter != ancestors.rend(); ++iter) {\\n            auto const p = iter->first;\\n            if (version_[p] < max_upgrade_seq) {\\n                // apply the effect from a previous upgrade operation to\\n                // numLockedDescendants_[p]\\n                // and update the version of numLockedDescendants_[p]\\n                numLockedDescendants_[p] = 0;\\n                version_[p] = max_upgrade_seq;\\n            }\\n            max_upgrade_seq = max(max_upgrade_seq, iter->second);\\n        }\\n    }\\n\\t\\n    int seq_{1};\\n    int const n_;\\n    vector<int> const& parent_;\\n    vector<int> owner_;\\n    vector<int> lockSeq_;\\n    vector<int> upgradeSeq_;\\n    vector<int> version_;\\n    vector<int> numLockedDescendants_;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nconstexpr int kNone = -1;\\n\\nclass LockingTree {\\npublic:\\n    LockingTree(vector<int>const & parent) : n_(parent.size()), parent_(parent) {\\n        owner_ = vector<int>(n_, kNone);\\n        lockSeq_.resize(n_);\\n        upgradeSeq_.resize(n_);\\n        version_.resize(n_);\\n        numLockedDescendants_.resize(n_);\\n    }\\n\\n    bool lock(int const num, int const user) {\\n        int max_upgrade_seq;\\n        // <node num, upgrade seq>\\n        vector<pair<int, int>> ancestors;\\n        // We want to find the upgrade operation performed on any ancestor of the\\n\\t\\t// current node with the highest sequence number.\\n        // For lock() operation, we must ensure numLockedDescendants_[p]\\n\\t\\t// is up-to-date with respect to all previous upgrade() operations for each\\n\\t\\t// ancestor node of p. This means we need to determine whether any\\n\\t\\t// upgrade() operation on any ancestor of p took place after the last\\n\\t\\t// update to numLockedDescendants_[p]. If yes, then\\n\\t\\t// numLockedDescendants_[p] is zeroed out because the upgrade op\\n\\t\\t// of an ancestor of p unlocks p and p\\'s descendants.\\n        // This is done by calling updateNumLockedDescendantsArray().\\n        updateNumLockedDescendantsArray(max_upgrade_seq, ancestors, num);\\n        if (owner_[num] == kNone || lockSeq_[num] < max_upgrade_seq) {\\n            owner_[num] = user;\\n            auto const seq = seq_++;\\n            lockSeq_[num] = seq;\\n            for (auto const& a : ancestors)\\n                ++numLockedDescendants_[a.first];\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    bool unlock(int const num, int const user) {\\n        int max_upgrade_seq = 0;\\n        vector<int> ancestors;\\n        for (int p = parent_[num]; p != kNone; p = parent_[p]) {\\n            max_upgrade_seq = max(max_upgrade_seq, upgradeSeq_[p]);\\n            ancestors.push_back(p);\\n        }\\n        if (owner_[num] == user && lockSeq_[num] > max_upgrade_seq) {\\n\\t\\t    // If the current node is locked, then numLockedDescendants_[p] for each ancestor p\\n\\t\\t\\t// of the current node was already kept up-to-date wtih respect to all previous upgrade()\\n\\t\\t\\t// operations by the last lock() or upgrade() operation on the current code, so, we don\\'t\\n\\t\\t\\t// need worry about numLockedDescendants_[p] being out-of-date here as it is impossible\\n\\t\\t\\t// by design.\\n            owner_[num] = kNone;\\n            auto const seq = seq_++;\\n            lockSeq_[num] = seq;\\n            for (auto const p : ancestors)\\n                --numLockedDescendants_[p];\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    bool upgrade(int const num, int const user) {\\n        int max_upgrade_seq;\\n        // <node num, upgrade seq>\\n        vector<pair<int, int>> ancestors;\\n\\t\\t// Similar to what happens in lock(), we must first push down the deferred updates\\n\\t\\t// to the ancestor entries in numLockedDescendants_ to maintain correctness.\\n        updateNumLockedDescendantsArray(max_upgrade_seq, ancestors, num);\\n        max_upgrade_seq = 0;\\n        // check all ancestors are unlocked\\n        for (auto iter = ancestors.rbegin(); iter != ancestors.rend(); ++iter) {\\n            auto const p = iter->first;\\n            if (owner_[p] != kNone && lockSeq_[p] > max_upgrade_seq)\\n                return false;\\n            max_upgrade_seq = max(max_upgrade_seq, iter->second);\\n        }\\n        // check the node itself is unlocked\\n        if (owner_[num] != kNone && lockSeq_[num] > max_upgrade_seq)\\n            return false;\\n        // check number of locked descendants is not 0\\n        if (version_[num] < max_upgrade_seq || numLockedDescendants_[num] == 0) return false;\\n        // perform the upgrade op \\n        auto const seq = seq_++;\\n        owner_[num] = user;\\n        lockSeq_[num] = seq;\\n        upgradeSeq_[num] = seq;\\n        auto const n = numLockedDescendants_[num];\\n        numLockedDescendants_[num] = 0;\\n        version_[num] = seq;\\n        for (auto const& a : ancestors)\\n            numLockedDescendants_[a.first] -= n - 1;\\n        return true;\\n    }\\nprivate:\\n    void updateNumLockedDescendantsArray(int& max_upgrade_seq, vector<pair<int, int>>& ancestors, int const num) {\\n        for (int p = parent_[num]; p != kNone; p = parent_[p])\\n            ancestors.emplace_back(p, upgradeSeq_[p]);\\n        max_upgrade_seq = 0;\\n        for (auto iter = ancestors.rbegin(); iter != ancestors.rend(); ++iter) {\\n            auto const p = iter->first;\\n            if (version_[p] < max_upgrade_seq) {\\n                // apply the effect from a previous upgrade operation to\\n                // numLockedDescendants_[p]\\n                // and update the version of numLockedDescendants_[p]\\n                numLockedDescendants_[p] = 0;\\n                version_[p] = max_upgrade_seq;\\n            }\\n            max_upgrade_seq = max(max_upgrade_seq, iter->second);\\n        }\\n    }\\n\\t\\n    int seq_{1};\\n    int const n_;\\n    vector<int> const& parent_;\\n    vector<int> owner_;\\n    vector<int> lockSeq_;\\n    vector<int> upgradeSeq_;\\n    vector<int> version_;\\n    vector<int> numLockedDescendants_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461612,
                "title": "simple-c-solution",
                "content": "class LockingTree {\\n    \\n    vector<int> parent;\\n    \\n    unordered_map<int, list<int>> des;\\n    \\n    unordered_map<int,int> locks;\\n    \\npublic:\\n    LockingTree(vector<int>& parent) {\\n        this->parent = parent;\\n        \\n        for(int i = 1; i < parent.size(); i++){\\n            \\n            des[parent[i]].push_back(i);\\n            \\n            //int anc = parent[i];\\n        }\\n        \\n    }\\n    \\n    bool fun(int num){\\n        bool ans = false;\\n        if(locks.find(num) != locks.end()){\\n            locks.erase(num);\\n            ans = true;\\n        }\\n        \\n        for(auto p : des[num]){\\n            bool x = fun(p);\\n            \\n            ans = ans | x;\\n        }\\n        return ans;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        \\n        if(locks.find(num) == locks.end()){\\n            locks[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        \\n        if(locks.find(num) != locks.end() and locks[num] == user){\\n            locks.erase(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        if(locks.find(num) == locks.end()){\\n            int anc = parent[num];\\n            \\n            while(anc != -1){\\n                if(locks.find(anc) != locks.end()){\\n                    return false;\\n                }\\n                anc = parent[anc];\\n            }\\n            bool x = fun(num);\\n            \\n            if(!x){\\n                return false;\\n            }\\n            \\n            lock(num,user);\\n            \\n            return true;\\n            \\n            \\n            \\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class LockingTree {\\n    \\n    vector<int> parent;\\n    \\n    unordered_map<int, list<int>> des;\\n    \\n    unordered_map<int,int> locks;\\n    \\npublic:\\n    LockingTree(vector<int>& parent) {\\n        this->parent = parent;\\n        \\n        for(int i = 1; i < parent.size(); i++){\\n            \\n            des[parent[i]].push_back(i);\\n            \\n            //int anc = parent[i];\\n        }\\n        \\n    }\\n    \\n    bool fun(int num){\\n        bool ans = false;\\n        if(locks.find(num) != locks.end()){\\n            locks.erase(num);\\n            ans = true;\\n        }\\n        \\n        for(auto p : des[num]){\\n            bool x = fun(p);\\n            \\n            ans = ans | x;\\n        }\\n        return ans;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        \\n        if(locks.find(num) == locks.end()){\\n            locks[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        \\n        if(locks.find(num) != locks.end() and locks[num] == user){\\n            locks.erase(num);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        if(locks.find(num) == locks.end()){\\n            int anc = parent[num];\\n            \\n            while(anc != -1){\\n                if(locks.find(anc) != locks.end()){\\n                    return false;\\n                }\\n                anc = parent[anc];\\n            }\\n            bool x = fun(num);\\n            \\n            if(!x){\\n                return false;\\n            }\\n            \\n            lock(num,user);\\n            \\n            return true;\\n            \\n            \\n            \\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1460842,
                "title": "simple-c-using-two-vectors",
                "content": "```\\nclass LockingTree {\\n    vector<vector<int>> relations;\\n        // first value will the parent, remaining values will be children.\\n    vector<int> locked;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        vector<vector<int>> relations(parent.size());\\n        \\n        for(int i=0; i<parent.size(); i++) {\\n            relations[i].push_back(parent[i]);\\n        }\\n        \\n        for(int i=0; i<parent.size(); i++) {\\n            if(parent[i]!=-1) relations[parent[i]].push_back(i);\\n        }\\n        \\n        this->relations = relations;\\n        vector<int> temp(parent.size(), 0);\\n        locked = temp;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locked[num]!=0) return false;\\n        \\n        locked[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked[num]!=user) return false;\\n        \\n        locked[num] = 0;\\n        return true;\\n    }\\n    \\n    \\n    bool upgrade(const int NUM, int user) {\\n        int num = NUM;\\n        \\n        while(num>=0) {\\n            if(locked[num]!=0) return false;\\n            num = relations[num][0];\\n        }\\n        \\n        num = NUM;\\n        \\n        // finding out all descendants.\\n        vector<int> desc;\\n        queue<int> q;\\n        q.push(num);\\n        int count = 0;\\n        \\n        while(q.size()) {\\n            int cur = q.front(); q.pop();\\n            if(locked[cur]!=0) count++;\\n            \\n            for(int i=1; i<relations[cur].size(); i++) {\\n                int nx = relations[cur][i];\\n                q.push(nx);\\n            }\\n            \\n            desc.push_back(cur);\\n        }\\n        \\n        // atleast one descendant should have been locked.\\n        if(count==0) return false;\\n        \\n        // all conditions met, unlock all the descendants:\\n        for(int i=0; i<desc.size(); i++) {\\n            locked[desc[i]] = 0;\\n        }\\n        \\n        locked[num] = user;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n    vector<vector<int>> relations;\\n        // first value will the parent, remaining values will be children.\\n    vector<int> locked;\\npublic:\\n    LockingTree(vector<int>& parent) {\\n        vector<vector<int>> relations(parent.size());\\n        \\n        for(int i=0; i<parent.size(); i++) {\\n            relations[i].push_back(parent[i]);\\n        }\\n        \\n        for(int i=0; i<parent.size(); i++) {\\n            if(parent[i]!=-1) relations[parent[i]].push_back(i);\\n        }\\n        \\n        this->relations = relations;\\n        vector<int> temp(parent.size(), 0);\\n        locked = temp;\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locked[num]!=0) return false;\\n        \\n        locked[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked[num]!=user) return false;\\n        \\n        locked[num] = 0;\\n        return true;\\n    }\\n    \\n    \\n    bool upgrade(const int NUM, int user) {\\n        int num = NUM;\\n        \\n        while(num>=0) {\\n            if(locked[num]!=0) return false;\\n            num = relations[num][0];\\n        }\\n        \\n        num = NUM;\\n        \\n        // finding out all descendants.\\n        vector<int> desc;\\n        queue<int> q;\\n        q.push(num);\\n        int count = 0;\\n        \\n        while(q.size()) {\\n            int cur = q.front(); q.pop();\\n            if(locked[cur]!=0) count++;\\n            \\n            for(int i=1; i<relations[cur].size(); i++) {\\n                int nx = relations[cur][i];\\n                q.push(nx);\\n            }\\n            \\n            desc.push_back(cur);\\n        }\\n        \\n        // atleast one descendant should have been locked.\\n        if(count==0) return false;\\n        \\n        // all conditions met, unlock all the descendants:\\n        for(int i=0; i<desc.size(); i++) {\\n            locked[desc[i]] = 0;\\n        }\\n        \\n        locked[num] = user;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1457626,
                "title": "java-easy-to-understand-solution-using-two-map",
                "content": "Intuition:\\n\\n1. For each node store all the `descendent` node whenever a locks get applied and propagate this info to its parent.\\n2.  Whenver a upgrade/unlock happens we need to remove node from `descendent` list and also for all the effected parent node.\\n\\nAlgo :\\nHere `lock` stores all the lock applied on the node by a user. `descendentWithLock` stores all locked descendent nodes of a node . eg `[-1, 0, 0, 1, 1, 2, 2]` when apply lock(5,3), lock(6, 4) descendentWithLock will have value as {{0 ={5, 6}, {2 ={5, 6}}\\n\\n```\\nclass LockingTree {\\n\\n    int[] parent;\\n    Map<Integer, Integer> lock = new HashMap();\\n    Map<Integer, Set<Integer>> descendentWithLock = new HashMap();\\n    \\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(lock.containsKey(num)){  \\n            return false;\\n        }\\n        lock.put(num, user);\\n        storeDescendentLockDetails(num, num);\\n        return true;\\n    }\\n    \\n    private void storeDescendentLockDetails(int numWithLock, int num){\\n        if(num == -1)\\n            return;\\n        \\n        if(descendentWithLock.get(parent[num]) == null){\\n            descendentWithLock.put(parent[num], new HashSet());\\n        }\\n        descendentWithLock.get(parent[num]).add(numWithLock);\\n        storeDescendentLockDetails(numWithLock, parent[num]);\\n    }\\n    public boolean unlock(int num, int user) {\\n        if(!lock.containsKey(num) || lock.get(num) != user){\\n            return false;\\n        }\\n        lock.remove(num);\\n        deleteDescendentLockDetails(num, num);\\n        return true;\\n    }\\n    \\n     private void deleteDescendentLockDetails(int numWithLock, int num){\\n        if(num == -1)\\n            return;\\n        if(descendentWithLock.get(parent[num]) == null){\\n            descendentWithLock.put(parent[num], new HashSet());\\n        }\\n        descendentWithLock.get(parent[num]).remove(numWithLock);\\n        deleteDescendentLockDetails(numWithLock, parent[num]);\\n    }\\n    public boolean upgrade(int num, int user) {\\n        if(lock.containsKey(num))\\n            return false;\\n        \\n        if(!descendentWithLock.containsKey(num) || descendentWithLock.get(num) == null\\n           || descendentWithLock.get(num).size() == 0){\\n            return false;\\n        }\\n        \\n        if(checkIfAnyAncestorHasLock(num)){\\n            return false;\\n        }\\n        \\n        lock.put(num, user);\\n        storeDescendentLockDetails(num, num);\\n        \\n        List<Integer> deletedChildNodes = new ArrayList();\\n        \\n        for(Integer i : descendentWithLock.get(num)){\\n            lock.remove(i);\\n            deletedChildNodes.add(i);\\n        }\\n        \\n        for(Integer i : deletedChildNodes){\\n            deleteDescendentLockDetails(i, i);\\n        }\\n        descendentWithLock.put(num, new HashSet());\\n        return true;\\n    }\\n    \\n    private boolean checkIfAnyAncestorHasLock(int num){\\n        if(num == -1){\\n            return false;\\n        }\\n        if(lock.containsKey(parent[num])){\\n            return true;\\n        }\\n        if(checkIfAnyAncestorHasLock(parent[num])){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n ```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LockingTree {\\n\\n    int[] parent;\\n    Map<Integer, Integer> lock = new HashMap();\\n    Map<Integer, Set<Integer>> descendentWithLock = new HashMap();\\n    \\n    public LockingTree(int[] parent) {\\n        this.parent = parent;\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(lock.containsKey(num)){  \\n            return false;\\n        }\\n        lock.put(num, user);\\n        storeDescendentLockDetails(num, num);\\n        return true;\\n    }\\n    \\n    private void storeDescendentLockDetails(int numWithLock, int num){\\n        if(num == -1)\\n            return;\\n        \\n        if(descendentWithLock.get(parent[num]) == null){\\n            descendentWithLock.put(parent[num], new HashSet());\\n        }\\n        descendentWithLock.get(parent[num]).add(numWithLock);\\n        storeDescendentLockDetails(numWithLock, parent[num]);\\n    }\\n    public boolean unlock(int num, int user) {\\n        if(!lock.containsKey(num) || lock.get(num) != user){\\n            return false;\\n        }\\n        lock.remove(num);\\n        deleteDescendentLockDetails(num, num);\\n        return true;\\n    }\\n    \\n     private void deleteDescendentLockDetails(int numWithLock, int num){\\n        if(num == -1)\\n            return;\\n        if(descendentWithLock.get(parent[num]) == null){\\n            descendentWithLock.put(parent[num], new HashSet());\\n        }\\n        descendentWithLock.get(parent[num]).remove(numWithLock);\\n        deleteDescendentLockDetails(numWithLock, parent[num]);\\n    }\\n    public boolean upgrade(int num, int user) {\\n        if(lock.containsKey(num))\\n            return false;\\n        \\n        if(!descendentWithLock.containsKey(num) || descendentWithLock.get(num) == null\\n           || descendentWithLock.get(num).size() == 0){\\n            return false;\\n        }\\n        \\n        if(checkIfAnyAncestorHasLock(num)){\\n            return false;\\n        }\\n        \\n        lock.put(num, user);\\n        storeDescendentLockDetails(num, num);\\n        \\n        List<Integer> deletedChildNodes = new ArrayList();\\n        \\n        for(Integer i : descendentWithLock.get(num)){\\n            lock.remove(i);\\n            deletedChildNodes.add(i);\\n        }\\n        \\n        for(Integer i : deletedChildNodes){\\n            deleteDescendentLockDetails(i, i);\\n        }\\n        descendentWithLock.put(num, new HashSet());\\n        return true;\\n    }\\n    \\n    private boolean checkIfAnyAncestorHasLock(int num){\\n        if(num == -1){\\n            return false;\\n        }\\n        if(lock.containsKey(parent[num])){\\n            return true;\\n        }\\n        if(checkIfAnyAncestorHasLock(parent[num])){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree obj = new LockingTree(parent);\\n * boolean param_1 = obj.lock(num,user);\\n * boolean param_2 = obj.unlock(num,user);\\n * boolean param_3 = obj.upgrade(num,user);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1454982,
                "title": "scala-i-would-fail-this-interview-if-given-this-question-just-use-traverse-on-parental-route",
                "content": "```scala\\nclass LockingTree(ps: Array[Int]) {\\n\\n  import scala.collection.mutable.{HashMap, HashSet}\\n\\n  type int = Int\\n  type hs  = HashSet[int]\\n\\n  val graph, lockChs = new HashMap[int, hs]\\n\\n  ps.zipWithIndex.foreach {\\n    case (pare, curr) => {\\n      if (!graph.contains(curr)) graph += (curr               -> new hs)\\n      if (!graph.contains(pare) && pare != -1) graph += (pare -> new hs)\\n      if (pare != -1) graph(pare).add(curr)\\n      if (!lockChs.contains(curr)) lockChs += (curr -> new hs)\\n    }\\n  }\\n\\n  val lm = new HashMap[int, int]\\n\\n  def lock(num: Int, user: Int): Boolean = {\\n    if (lm.contains(num) || !graph.contains(num)) {\\n      false\\n    } else {\\n      lm += (num -> user)\\n      var p = ps(num)\\n      while (p != -1) {\\n        lockChs(p) += num\\n        p = ps(p)\\n      }\\n      true\\n    }\\n  }\\n\\n  def unlock(num: Int, user: Int): Boolean = {\\n    if (!graph.contains(num) || !lm.contains(num) || lm(num) != user)\\n      false\\n    else unlock(num)\\n  }\\n\\n  def unlock(num: Int): Boolean = {\\n    lm -= num\\n    var p = ps(num)\\n    while (p != -1) {\\n      lockChs(p) -= num\\n      p = ps(p)\\n    }\\n    true\\n  }\\n\\n  def upgrade(num: Int, user: Int): Boolean = {\\n\\n    if (!graph.contains(num) || lm.contains(num) || lockChs(num).isEmpty) {\\n      false\\n    } else {\\n      var p = ps(num)\\n      while (p != -1) {\\n        if (lm.contains(p)) return false\\n        p = ps(p)\\n      }\\n      lock(num, user)\\n      lockChs(num).foreach(unlock)\\n      true\\n    }\\n\\n  }\\n\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```scala\\nclass LockingTree(ps: Array[Int]) {\\n\\n  import scala.collection.mutable.{HashMap, HashSet}\\n\\n  type int = Int\\n  type hs  = HashSet[int]\\n\\n  val graph, lockChs = new HashMap[int, hs]\\n\\n  ps.zipWithIndex.foreach {\\n    case (pare, curr) => {\\n      if (!graph.contains(curr)) graph += (curr               -> new hs)\\n      if (!graph.contains(pare) && pare != -1) graph += (pare -> new hs)\\n      if (pare != -1) graph(pare).add(curr)\\n      if (!lockChs.contains(curr)) lockChs += (curr -> new hs)\\n    }\\n  }\\n\\n  val lm = new HashMap[int, int]\\n\\n  def lock(num: Int, user: Int): Boolean = {\\n    if (lm.contains(num) || !graph.contains(num)) {\\n      false\\n    } else {\\n      lm += (num -> user)\\n      var p = ps(num)\\n      while (p != -1) {\\n        lockChs(p) += num\\n        p = ps(p)\\n      }\\n      true\\n    }\\n  }\\n\\n  def unlock(num: Int, user: Int): Boolean = {\\n    if (!graph.contains(num) || !lm.contains(num) || lm(num) != user)\\n      false\\n    else unlock(num)\\n  }\\n\\n  def unlock(num: Int): Boolean = {\\n    lm -= num\\n    var p = ps(num)\\n    while (p != -1) {\\n      lockChs(p) -= num\\n      p = ps(p)\\n    }\\n    true\\n  }\\n\\n  def upgrade(num: Int, user: Int): Boolean = {\\n\\n    if (!graph.contains(num) || lm.contains(num) || lockChs(num).isEmpty) {\\n      false\\n    } else {\\n      var p = ps(num)\\n      while (p != -1) {\\n        if (lm.contains(p)) return false\\n        p = ps(p)\\n      }\\n      lock(num, user)\\n      lockChs(num).foreach(unlock)\\n      true\\n    }\\n\\n  }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453123,
                "title": "c-easy-solution-n-ary-tree",
                "content": "```\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\nclass LockingTree {\\n    void dfs(Node* root , bool&ans , unordered_map<int,pair<int,Node*>>mp)\\n    {\\n        if(root==0)\\n        {\\n            return;\\n        }\\n        if(mp.find(root->val)!=mp.end())\\n        {\\n            ans=true;\\n            return;\\n        }\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            dfs(root->children[i],ans,mp);\\n            if(ans==true)\\n            {\\n                return;\\n            }\\n        }\\n    }\\n    void dfs2(Node* root , unordered_map<int,Node*>&mp3 ,unordered_map<int,pair<int,Node*>>&mp4 )\\n    {\\n        if(root==0)\\n        {\\n            return;\\n        }\\n        if(mp4.find(root->val)!=mp4.end())\\n        {\\n            mp3[root->val]=mp4[root->val].second;\\n            mp4.erase(root->val);\\n        }\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            dfs2(root->children[i],mp3,mp4);\\n        }\\n    }\\npublic:\\n    unordered_map<int,Node*>mp1;\\n    unordered_map<int,pair<int,Node*>>mp2;\\n    Node* root=0;\\n    vector<int>parents;\\n    LockingTree(vector<int>& parent) {\\n        parents=parent;\\n        Node* r = new Node(0);\\n        mp1[0]=r;\\n        for(int i=1;i<parent.size();i++)\\n        {\\n            if(mp1.find(i)!=mp1.end())\\n            {\\n                Node* o = mp1[i];\\n                if(mp1.find(parent[i])!=mp1.end())\\n                {\\n                    Node* cv = mp1[parent[i]];\\n                    cv->children.push_back(o);\\n                }\\n                else\\n                {\\n                    Node* t = new Node(parent[i]);\\n                    t->children.push_back(o);\\n                    mp1[parent[i]]=t;\\n                }\\n            }\\n            else\\n            {\\n                Node* u = new Node(i);\\n                mp1[i]=u;\\n                if(mp1.find(parent[i])!=mp1.end())\\n                {\\n                    Node* t = mp1[parent[i]];\\n                    t->children.push_back(u);\\n                }\\n                else\\n                {\\n                    Node* p = new Node(parent[i]);\\n                    p->children.push_back(u);\\n                    mp1[parent[i]]=p;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(mp1.find(num)==mp1.end())\\n        {\\n            return false;\\n        }\\n        mp2[num]={user,mp1[num]};\\n        mp1.erase(num);\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(mp2.find(num)==mp2.end())\\n        {\\n            return false;\\n        }\\n        if(mp2[num].first!=user)\\n        {\\n            return false;\\n        }\\n        mp1[num]=mp2[num].second;\\n        mp2.erase(num);\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(mp1.find(num)==mp1.end())\\n        {\\n            return false;\\n        }\\n        int l = num;\\n        while(l!=-1)\\n        {\\n            if(mp2.find(l)!=mp2.end())\\n            {\\n                return false;\\n            }\\n            l=parents[l];\\n        }\\n        bool ans=false;\\n        dfs(mp1[num],ans,mp2);\\n        if(ans==false)\\n        {\\n            return false;\\n        }\\n        dfs2(mp1[num],mp1,mp2);\\n        mp2[num]={user,mp1[num]};\\n        mp1.erase(num);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\nclass LockingTree {\\n    void dfs(Node* root , bool&ans , unordered_map<int,pair<int,Node*>>mp)\\n    {\\n        if(root==0)\\n        {\\n            return;\\n        }\\n        if(mp.find(root->val)!=mp.end())\\n        {\\n            ans=true;\\n            return;\\n        }\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            dfs(root->children[i],ans,mp);\\n            if(ans==true)\\n            {\\n                return;\\n            }\\n        }\\n    }\\n    void dfs2(Node* root , unordered_map<int,Node*>&mp3 ,unordered_map<int,pair<int,Node*>>&mp4 )\\n    {\\n        if(root==0)\\n        {\\n            return;\\n        }\\n        if(mp4.find(root->val)!=mp4.end())\\n        {\\n            mp3[root->val]=mp4[root->val].second;\\n            mp4.erase(root->val);\\n        }\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            dfs2(root->children[i],mp3,mp4);\\n        }\\n    }\\npublic:\\n    unordered_map<int,Node*>mp1;\\n    unordered_map<int,pair<int,Node*>>mp2;\\n    Node* root=0;\\n    vector<int>parents;\\n    LockingTree(vector<int>& parent) {\\n        parents=parent;\\n        Node* r = new Node(0);\\n        mp1[0]=r;\\n        for(int i=1;i<parent.size();i++)\\n        {\\n            if(mp1.find(i)!=mp1.end())\\n            {\\n                Node* o = mp1[i];\\n                if(mp1.find(parent[i])!=mp1.end())\\n                {\\n                    Node* cv = mp1[parent[i]];\\n                    cv->children.push_back(o);\\n                }\\n                else\\n                {\\n                    Node* t = new Node(parent[i]);\\n                    t->children.push_back(o);\\n                    mp1[parent[i]]=t;\\n                }\\n            }\\n            else\\n            {\\n                Node* u = new Node(i);\\n                mp1[i]=u;\\n                if(mp1.find(parent[i])!=mp1.end())\\n                {\\n                    Node* t = mp1[parent[i]];\\n                    t->children.push_back(u);\\n                }\\n                else\\n                {\\n                    Node* p = new Node(parent[i]);\\n                    p->children.push_back(u);\\n                    mp1[parent[i]]=p;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(mp1.find(num)==mp1.end())\\n        {\\n            return false;\\n        }\\n        mp2[num]={user,mp1[num]};\\n        mp1.erase(num);\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(mp2.find(num)==mp2.end())\\n        {\\n            return false;\\n        }\\n        if(mp2[num].first!=user)\\n        {\\n            return false;\\n        }\\n        mp1[num]=mp2[num].second;\\n        mp2.erase(num);\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(mp1.find(num)==mp1.end())\\n        {\\n            return false;\\n        }\\n        int l = num;\\n        while(l!=-1)\\n        {\\n            if(mp2.find(l)!=mp2.end())\\n            {\\n                return false;\\n            }\\n            l=parents[l];\\n        }\\n        bool ans=false;\\n        dfs(mp1[num],ans,mp2);\\n        if(ans==false)\\n        {\\n            return false;\\n        }\\n        dfs2(mp1[num],mp1,mp2);\\n        mp2[num]={user,mp1[num]};\\n        mp1.erase(num);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451589,
                "title": "c-676ms-faster-than-100",
                "content": "The main goal to reach this level of speed in this code is keeping all childs for each parents\\n\\n```\\npublic class LockingTree \\n{\\n    //  int[0,1,2] \\n    //  0 - parent\\n    //  1 - status 0-unlock 1-lock\\n    //  2 - userid\\n    List<int[]> _tree = new List<int[]>();\\n    List<int>[] _childs;\\n      \\n    public LockingTree(int[] parent) \\n    {\\n        for (int i = 0; i < parent.Length; i++)\\n        {\\n          _tree.Add(new int[3]{ parent[i], 0, 0 });\\n        }\\n        _childs = new List<int>[parent.Length];\\n      \\n        int p;\\n        for (int i = 0; i < _tree.Count; i++)\\n        {\\n          p = _tree[i][0];\\n          if(p != -1)\\n          {\\n            if (_childs[p] == null)\\n            {\\n              _childs[p] = new List<int>();\\n            }\\n            _childs[p].Add(i); \\n          }\\n        }\\n    }\\n    \\n    public bool Lock(int num, int user) \\n    {\\n        if(_tree[num][1] == 0)\\n        {\\n          _tree[num][1] = 1;\\n          _tree[num][2] = user;\\n          return true;\\n        }\\n        return false; \\n    }\\n    \\n    public bool Unlock(int num, int user) \\n    {\\n        if(_tree[num][1] == 1 && _tree[num][2] == user)\\n        {\\n          _tree[num][1] = 0;\\n          _tree[num][2] = 0;\\n          return true;\\n        }\\n        return false;\\n    }\\n    \\n    public bool Upgrade(int num, int user) \\n    {\\n        bool res = false;\\n        if (_tree[num][1] == 0)\\n        {\\n          int pos = num;\\n          bool lockanc = false;\\n          while(pos != -1)\\n          {\\n            if (_tree[pos][1] == 1)\\n            {\\n              lockanc = true;\\n              break;\\n            }\\n            pos = _tree[pos][0];\\n          }\\n          if (!lockanc)\\n          {\\n            res = UpgradeByParent(num);\\n          }\\n        }\\n        if(res)\\n        {\\n          _tree[num][1] = 1;\\n          _tree[num][2] = user;\\n        }\\n      \\n        return res;\\n    }\\n  \\n    private bool UpgradeByParent(int parent)\\n    {\\n      if(_childs[parent] == null)\\n      {\\n        if (_tree[parent][1] == 1)\\n        {\\n          _tree[parent][1] = 0;\\n          _tree[parent][2] = 0; \\n          return true;\\n        }\\n        return false;\\n      }\\n      \\n      bool res = false;\\n      for (int i = 0; i < _childs[parent].Count; i++)\\n      {\\n        res = UpgradeByParent(_childs[parent][i]) ? true : res;\\n        if (_tree[_childs[parent][i]][1] == 1)\\n        {\\n          _tree[_childs[parent][i]][1] = 0;\\n          _tree[_childs[parent][i]][2] = 0; \\n          res = true;\\n        }\\n      }\\n      return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class LockingTree \\n{\\n    //  int[0,1,2] \\n    //  0 - parent\\n    //  1 - status 0-unlock 1-lock\\n    //  2 - userid\\n    List<int[]> _tree = new List<int[]>();\\n    List<int>[] _childs;\\n      \\n    public LockingTree(int[] parent) \\n    {\\n        for (int i = 0; i < parent.Length; i++)\\n        {\\n          _tree.Add(new int[3]{ parent[i], 0, 0 });\\n        }\\n        _childs = new List<int>[parent.Length];\\n      \\n        int p;\\n        for (int i = 0; i < _tree.Count; i++)\\n        {\\n          p = _tree[i][0];\\n          if(p != -1)\\n          {\\n            if (_childs[p] == null)\\n            {\\n              _childs[p] = new List<int>();\\n            }\\n            _childs[p].Add(i); \\n          }\\n        }\\n    }\\n    \\n    public bool Lock(int num, int user) \\n    {\\n        if(_tree[num][1] == 0)\\n        {\\n          _tree[num][1] = 1;\\n          _tree[num][2] = user;\\n          return true;\\n        }\\n        return false; \\n    }\\n    \\n    public bool Unlock(int num, int user) \\n    {\\n        if(_tree[num][1] == 1 && _tree[num][2] == user)\\n        {\\n          _tree[num][1] = 0;\\n          _tree[num][2] = 0;\\n          return true;\\n        }\\n        return false;\\n    }\\n    \\n    public bool Upgrade(int num, int user) \\n    {\\n        bool res = false;\\n        if (_tree[num][1] == 0)\\n        {\\n          int pos = num;\\n          bool lockanc = false;\\n          while(pos != -1)\\n          {\\n            if (_tree[pos][1] == 1)\\n            {\\n              lockanc = true;\\n              break;\\n            }\\n            pos = _tree[pos][0];\\n          }\\n          if (!lockanc)\\n          {\\n            res = UpgradeByParent(num);\\n          }\\n        }\\n        if(res)\\n        {\\n          _tree[num][1] = 1;\\n          _tree[num][2] = user;\\n        }\\n      \\n        return res;\\n    }\\n  \\n    private bool UpgradeByParent(int parent)\\n    {\\n      if(_childs[parent] == null)\\n      {\\n        if (_tree[parent][1] == 1)\\n        {\\n          _tree[parent][1] = 0;\\n          _tree[parent][2] = 0; \\n          return true;\\n        }\\n        return false;\\n      }\\n      \\n      bool res = false;\\n      for (int i = 0; i < _childs[parent].Count; i++)\\n      {\\n        res = UpgradeByParent(_childs[parent][i]) ? true : res;\\n        if (_tree[_childs[parent][i]][1] == 1)\\n        {\\n          _tree[_childs[parent][i]][1] = 0;\\n          _tree[_childs[parent][i]][2] = 0; \\n          res = true;\\n        }\\n      }\\n      return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450228,
                "title": "build-run-dfs-python",
                "content": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.locked = [-1]*len(parent)\\n        self.adj = defaultdict(list)\\n        self.parent = parent\\n        for i in range(len(parent)):\\n            if parent[i] != -1:\\n                self.adj[parent[i]].append(i)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num] != -1:\\n            return False\\n        self.locked[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] != user:\\n            return False\\n        self.locked[num] = -1\\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locked[num] != -1: return False\\n        p = self.parent[num]\\n        while p != -1:\\n            if self.locked[p] != -1:\\n                return False\\n            p = self.parent[p]\\n        \\n        self.has_child_lock = False\\n        def dfs(node):\\n            self.has_child_lock |= (self.locked[node] != -1)\\n            if self.locked[node] != -1:\\n                self.locked[node] = -1\\n            for neighbor in self.adj[node]:\\n                dfs(neighbor)\\n        \\n        dfs(num)\\n        if self.has_child_lock:\\n            self.locked[num] = user\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.locked = [-1]*len(parent)\\n        self.adj = defaultdict(list)\\n        self.parent = parent\\n        for i in range(len(parent)):\\n            if parent[i] != -1:\\n                self.adj[parent[i]].append(i)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num] != -1:\\n            return False\\n        self.locked[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num] != user:\\n            return False\\n        self.locked[num] = -1\\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.locked[num] != -1: return False\\n        p = self.parent[num]\\n        while p != -1:\\n            if self.locked[p] != -1:\\n                return False\\n            p = self.parent[p]\\n        \\n        self.has_child_lock = False\\n        def dfs(node):\\n            self.has_child_lock |= (self.locked[node] != -1)\\n            if self.locked[node] != -1:\\n                self.locked[node] = -1\\n            for neighbor in self.adj[node]:\\n                dfs(neighbor)\\n        \\n        dfs(num)\\n        if self.has_child_lock:\\n            self.locked[num] = user\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448479,
                "title": "python3-python-simple-solution-using-defaultdict-w-comments",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n       \\n        # Init\\n        self.parent = parent\\n        self.n = len(parent)\\n        self.locked = defaultdict(lambda: None)\\n        \\n        # Make children from parent array\\n        self.children = defaultdict(lambda: [])\\n        for i in range(1, self.n):\\n            self.children[parent[i]].append(i)\\n        \\n        return\\n    \\n    def lock(self, num: int, user: int) -> bool:\\n        # lock a node if the node is unlocked.\\n        if not self.locked[num]:\\n            self.locked[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        # unlock a node if it is locked by the same user\\n        if self.locked[num] == user:\\n            self.locked.pop(num, None)\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        \\n        # Check if the node is unlocked\\n        if self.locked[num]:\\n            return False\\n        \\n        def isAnyDecendantLocked(p: int) -> bool:\\n            \\n            # Get decendants\\n            for c in self.children[p]:\\n            \\n                # Check if the decendant is within range and it\\'s locked\\n                # or any of it\\'s decendants are locked.\\n                if c < self.n and (self.locked[c] or isAnyDecendantLocked(c)):\\n                    return True\\n            \\n            \\n            return False # default condition\\n        \\n        # Check It has at least one locked descendant\\n        if not isAnyDecendantLocked(num):\\n            return False\\n        \\n        def isAnyAncestorLocked(c: int) -> bool:\\n            \\n            # Get ancestor\\n            p = self.parent[c]\\n            \\n            # Check if it\\'s root and it\\'s locked\\n            if p == 0 and self.locked[p]:\\n                return True\\n            # Check if it\\'s not root and it\\'s locked or any of is ancestor locked\\n            elif p > 0 and (self.locked[p] or isAnyAncestorLocked(p)):\\n                return True\\n            else: # Else do nothing\\n                pass\\n            \\n            return False # default condition\\n        \\n        # Check It does not have any locked ancestors\\n        if isAnyAncestorLocked(num):\\n            return False\\n        \\n        # Locks the given node for the given user\\n        self.lock(num, user)\\n        \\n        def unlockDecendants(p: int):\\n            \\n            # For all the descendants\\n            for c in self.children[p]:\\n            \\n                # Unlock this \\n                if c < self.n and self.locked[c]:\\n                    self.unlock(c, self.locked[c])\\n                \\n                # Unlock all its descendants\\n                unlockDecendants(c)\\n                \\n            return\\n        \\n        # unlocks all of its descendants\\n        unlockDecendants(num)\\n        \\n        return True\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n       \\n        # Init\\n        self.parent = parent\\n        self.n = len(parent)\\n        self.locked = defaultdict(lambda: None)\\n        \\n        # Make children from parent array\\n        self.children = defaultdict(lambda: [])\\n        for i in range(1, self.n):\\n            self.children[parent[i]].append(i)\\n        \\n        return\\n    \\n    def lock(self, num: int, user: int) -> bool:\\n        # lock a node if the node is unlocked.\\n        if not self.locked[num]:\\n            self.locked[num] = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        # unlock a node if it is locked by the same user\\n        if self.locked[num] == user:\\n            self.locked.pop(num, None)\\n            return True\\n        return False\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        \\n        # Check if the node is unlocked\\n        if self.locked[num]:\\n            return False\\n        \\n        def isAnyDecendantLocked(p: int) -> bool:\\n            \\n            # Get decendants\\n            for c in self.children[p]:\\n            \\n                # Check if the decendant is within range and it\\'s locked\\n                # or any of it\\'s decendants are locked.\\n                if c < self.n and (self.locked[c] or isAnyDecendantLocked(c)):\\n                    return True\\n            \\n            \\n            return False # default condition\\n        \\n        # Check It has at least one locked descendant\\n        if not isAnyDecendantLocked(num):\\n            return False\\n        \\n        def isAnyAncestorLocked(c: int) -> bool:\\n            \\n            # Get ancestor\\n            p = self.parent[c]\\n            \\n            # Check if it\\'s root and it\\'s locked\\n            if p == 0 and self.locked[p]:\\n                return True\\n            # Check if it\\'s not root and it\\'s locked or any of is ancestor locked\\n            elif p > 0 and (self.locked[p] or isAnyAncestorLocked(p)):\\n                return True\\n            else: # Else do nothing\\n                pass\\n            \\n            return False # default condition\\n        \\n        # Check It does not have any locked ancestors\\n        if isAnyAncestorLocked(num):\\n            return False\\n        \\n        # Locks the given node for the given user\\n        self.lock(num, user)\\n        \\n        def unlockDecendants(p: int):\\n            \\n            # For all the descendants\\n            for c in self.children[p]:\\n            \\n                # Unlock this \\n                if c < self.n and self.locked[c]:\\n                    self.unlock(c, self.locked[c])\\n                \\n                # Unlock all its descendants\\n                unlockDecendants(c)\\n                \\n            return\\n        \\n        # unlocks all of its descendants\\n        unlockDecendants(num)\\n        \\n        return True\\n        \\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447231,
                "title": "faster-than-100-memory-100-dont-create-graphs",
                "content": "Most time consuming part in this class is looping over all the descendents during upgrade operation.\\nSince we are only interested in the children that are locked, and it seems locking is sparse, we can track locked nodes separately. During upgrade, we check if any of the locked nodes fall under the given parent. If so, for all those nodes we remove locks on them.\\n\\n```\\nclass LockingTree {\\n\\n  int[] parent;\\n  int[] user;\\n  HashSet<Integer> locked;\\n\\n  public LockingTree(int[] parent) {\\n    this.parent = parent;\\n    user = new int[parent.length];\\n    locked = new HashSet<>();\\n  }\\n\\n  public boolean lock(int num, int u) {\\n    if (user[num] == 0) {\\n      user[num] = u;\\n      locked.add(num);\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  public boolean unlock(int num, int u) {\\n    if (user[num] == u) {\\n      user[num] = 0;\\n      locked.remove(num);\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  public boolean upgrade(int num, int u) {\\n    //1. the node is unlocked\\n    if (user[num] != 0) {\\n      return false;\\n    }\\n\\n    //2. No parents are locked\\n    int p = parent[num];\\n    while (p != -1) {\\n      if (user[p] != 0) {\\n        return false; //locked parent\\n      }\\n      p = parent[p];\\n    }\\n\\n    //3. Atleast one child is locked\\n    var lockedChildren = locked.stream().filter(i -> isParentChild(num, i)).collect(Collectors.toList());\\n\\n    if (lockedChildren.isEmpty()) {\\n      return false;\\n    }\\n\\n    for (int c : lockedChildren) {\\n      user[c] = 0;\\n      locked.remove(c);\\n    }\\n    user[num] = u;\\n    locked.add(num);\\n    return true;\\n  }\\n\\n  private boolean isParentChild(int father, int child) {\\n    int p = parent[child];\\n    while (p != -1) {\\n      if (p == father) {\\n        return true;\\n      }\\n      p = parent[p];\\n    }\\n    return false;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\n\\n  int[] parent;\\n  int[] user;\\n  HashSet<Integer> locked;\\n\\n  public LockingTree(int[] parent) {\\n    this.parent = parent;\\n    user = new int[parent.length];\\n    locked = new HashSet<>();\\n  }\\n\\n  public boolean lock(int num, int u) {\\n    if (user[num] == 0) {\\n      user[num] = u;\\n      locked.add(num);\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  public boolean unlock(int num, int u) {\\n    if (user[num] == u) {\\n      user[num] = 0;\\n      locked.remove(num);\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  public boolean upgrade(int num, int u) {\\n    //1. the node is unlocked\\n    if (user[num] != 0) {\\n      return false;\\n    }\\n\\n    //2. No parents are locked\\n    int p = parent[num];\\n    while (p != -1) {\\n      if (user[p] != 0) {\\n        return false; //locked parent\\n      }\\n      p = parent[p];\\n    }\\n\\n    //3. Atleast one child is locked\\n    var lockedChildren = locked.stream().filter(i -> isParentChild(num, i)).collect(Collectors.toList());\\n\\n    if (lockedChildren.isEmpty()) {\\n      return false;\\n    }\\n\\n    for (int c : lockedChildren) {\\n      user[c] = 0;\\n      locked.remove(c);\\n    }\\n    user[num] = u;\\n    locked.add(num);\\n    return true;\\n  }\\n\\n  private boolean isParentChild(int father, int child) {\\n    int p = parent[child];\\n    while (p != -1) {\\n      if (p == father) {\\n        return true;\\n      }\\n      p = parent[p];\\n    }\\n    return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447185,
                "title": "c-bfs-solution",
                "content": "```\\n#include <unordered_set>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nconst int LOCKED = 1;\\nconst int UNLOCKED = 0;\\n\\n\\n\\nclass LockingTree {\\nprivate:\\n    vector<int> locks;\\n    vector<vector<int> > nodes_children;\\n    vector<int> parent;\\n    \\n    bool checkTreeAncestorHasLocks(int num) const {\\n        int n = num;\\n        \\n        while(n > -1) {\\n            if(locks[n] != 0) {\\n                return true;\\n            }\\n            n = parent[n];\\n        }\\n        return false;\\n    }\\n    \\n    bool checkDescendantHasLocks(int num) const {\\n        const vector<int>& children = nodes_children[num];\\n        if(children.empty()) {\\n            return false;\\n        }\\n        \\n        for(int n: children) {\\n            if(locks[n] != 0) {\\n                return true;\\n            }\\n        }\\n        \\n        for(int n: children) {\\n            if(checkDescendantHasLocks(n)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void unlockDescendants(int num) {\\n        vector<int>& children = nodes_children[num];\\n        for(int n : children) {\\n            locks[n] = 0;\\n            unlockDescendants(n);\\n        }\\n    }\\n    \\npublic:\\n    LockingTree(vector<int>& parent): parent(parent), locks(parent.size()), nodes_children(parent.size()) {\\n        for(int i = 0; i < parent.size(); i++) {\\n            cout << i << \" \" \\n                << \"parent: \" << parent[i]\\n                << endl;\\n        }\\n        \\n        for(int i = 0; i < parent.size(); i++) {\\n            if(parent[i] < 0) {\\n                continue;\\n            }\\n            nodes_children[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locks[num] != 0) {\\n            return false;\\n        }\\n        locks[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locks[num] == 0) {\\n            return false;\\n        }\\n        if(locks[num] != user) {\\n            return false;\\n        }\\n        locks[num] = 0;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(locks[num] != 0) {\\n            return false;\\n        }\\n        \\n        if(checkTreeAncestorHasLocks(num)) {\\n            return false;\\n        }\\n        \\n        if(!checkDescendantHasLocks(num)) {\\n            return false;\\n        }\\n        \\n        unlockDescendants(num);\\n        locks[num] = user;\\n        return true;\\n    }\\n};\\n ```",
                "solutionTags": [],
                "code": "```\\n#include <unordered_set>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nconst int LOCKED = 1;\\nconst int UNLOCKED = 0;\\n\\n\\n\\nclass LockingTree {\\nprivate:\\n    vector<int> locks;\\n    vector<vector<int> > nodes_children;\\n    vector<int> parent;\\n    \\n    bool checkTreeAncestorHasLocks(int num) const {\\n        int n = num;\\n        \\n        while(n > -1) {\\n            if(locks[n] != 0) {\\n                return true;\\n            }\\n            n = parent[n];\\n        }\\n        return false;\\n    }\\n    \\n    bool checkDescendantHasLocks(int num) const {\\n        const vector<int>& children = nodes_children[num];\\n        if(children.empty()) {\\n            return false;\\n        }\\n        \\n        for(int n: children) {\\n            if(locks[n] != 0) {\\n                return true;\\n            }\\n        }\\n        \\n        for(int n: children) {\\n            if(checkDescendantHasLocks(n)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void unlockDescendants(int num) {\\n        vector<int>& children = nodes_children[num];\\n        for(int n : children) {\\n            locks[n] = 0;\\n            unlockDescendants(n);\\n        }\\n    }\\n    \\npublic:\\n    LockingTree(vector<int>& parent): parent(parent), locks(parent.size()), nodes_children(parent.size()) {\\n        for(int i = 0; i < parent.size(); i++) {\\n            cout << i << \" \" \\n                << \"parent: \" << parent[i]\\n                << endl;\\n        }\\n        \\n        for(int i = 0; i < parent.size(); i++) {\\n            if(parent[i] < 0) {\\n                continue;\\n            }\\n            nodes_children[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locks[num] != 0) {\\n            return false;\\n        }\\n        locks[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locks[num] == 0) {\\n            return false;\\n        }\\n        if(locks[num] != user) {\\n            return false;\\n        }\\n        locks[num] = 0;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(locks[num] != 0) {\\n            return false;\\n        }\\n        \\n        if(checkTreeAncestorHasLocks(num)) {\\n            return false;\\n        }\\n        \\n        if(!checkDescendantHasLocks(num)) {\\n            return false;\\n        }\\n        \\n        unlockDescendants(num);\\n        locks[num] = user;\\n        return true;\\n    }\\n};\\n ```",
                "codeTag": "C++"
            },
            {
                "id": 1447054,
                "title": "python-3-dfs-recursion",
                "content": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.N = len(parent)\\n        self.child = [[] for _ in range(self.N)]\\n        self.parent = parent[:]\\n        for idx, p in enumerate(parent):\\n            if p == -1:\\n                continue\\n            self.child[p].append(idx)\\n        self.mp = {}\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.mp:\\n            return False\\n        self.mp[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if num not in self.mp or self.mp[num] != user:\\n            return False\\n        del self.mp[num]\\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        def dfs(node):\\n            flg = False\\n            for ch in self.child[node]:\\n                if ch in self.mp:\\n                    flg = True\\n                    del self.mp[ch]\\n                flg |= dfs(ch)\\n            return flg\\n        if num in self.mp:\\n            return False\\n        \\n        node = num\\n        while self.parent[node] >= 0:\\n            node = self.parent[node]\\n            if node in self.mp:\\n                return False\\n        \\n        if not dfs(num):\\n            return False\\n        \\n        self.mp[num] = user\\n        return True\\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.N = len(parent)\\n        self.child = [[] for _ in range(self.N)]\\n        self.parent = parent[:]\\n        for idx, p in enumerate(parent):\\n            if p == -1:\\n                continue\\n            self.child[p].append(idx)\\n        self.mp = {}\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if num in self.mp:\\n            return False\\n        self.mp[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if num not in self.mp or self.mp[num] != user:\\n            return False\\n        del self.mp[num]\\n        return True\\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        def dfs(node):\\n            flg = False\\n            for ch in self.child[node]:\\n                if ch in self.mp:\\n                    flg = True\\n                    del self.mp[ch]\\n                flg |= dfs(ch)\\n            return flg\\n        if num in self.mp:\\n            return False\\n        \\n        node = num\\n        while self.parent[node] >= 0:\\n            node = self.parent[node]\\n            if node in self.mp:\\n                return False\\n        \\n        if not dfs(num):\\n            return False\\n        \\n        self.mp[num] = user\\n        return True\\n\\n\\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447041,
                "title": "python-dfs-straightforward-solution-with-comment",
                "content": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.parent = -1\\n        self.children = set()\\n        self.locked = -1\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.nodes = [Node(i) for i in range(len(parent))]\\n        for i in range(1, len(parent)):\\n            self.nodes[i].parent = parent[i]\\n            self.nodes[parent[i]].children.add(i)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.nodes[num].locked == -1:\\n            self.nodes[num].locked = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.nodes[num].locked == user:\\n            self.nodes[num].locked = -1\\n            return True\\n        return False        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.nodes[num].locked != -1:\\n            return False\\n        #check parent before unlock children \\n        self.locked_parent = False\\n        self.check_parent(self.nodes[num].parent)\\n        if self.locked_parent:\\n            return False\\n        #check and unlock the children\\n        self.locked_child = False\\n        for child in self.nodes[num].children:\\n            self.unlock_children(child)\\n        if not self.locked_child:\\n            return False\\n\\t\\t#upgrade the node\\n        self.nodes[num].locked = user\\n        return True\\n        \\n    def unlock_children(self, num):\\n        if self.nodes[num].locked != -1:\\n            self.locked_child = True\\n            self.nodes[num].locked = -1\\n        if not self.nodes[num].children:\\n            return \\n        for child in self.nodes[num].children:\\n            self.unlock_children(child)\\n        return \\n    \\n    def check_parent(self, num):\\n        if num == -1:\\n            return \\n        if self.nodes[num].locked != -1:\\n            self.locked_parent = True\\n        self.check_parent(self.nodes[num].parent)\\n        return \\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.parent = -1\\n        self.children = set()\\n        self.locked = -1\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self.nodes = [Node(i) for i in range(len(parent))]\\n        for i in range(1, len(parent)):\\n            self.nodes[i].parent = parent[i]\\n            self.nodes[parent[i]].children.add(i)\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.nodes[num].locked == -1:\\n            self.nodes[num].locked = user\\n            return True\\n        return False\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.nodes[num].locked == user:\\n            self.nodes[num].locked = -1\\n            return True\\n        return False        \\n\\n    def upgrade(self, num: int, user: int) -> bool:\\n        if self.nodes[num].locked != -1:\\n            return False\\n        #check parent before unlock children \\n        self.locked_parent = False\\n        self.check_parent(self.nodes[num].parent)\\n        if self.locked_parent:\\n            return False\\n        #check and unlock the children\\n        self.locked_child = False\\n        for child in self.nodes[num].children:\\n            self.unlock_children(child)\\n        if not self.locked_child:\\n            return False\\n\\t\\t#upgrade the node\\n        self.nodes[num].locked = user\\n        return True\\n        \\n    def unlock_children(self, num):\\n        if self.nodes[num].locked != -1:\\n            self.locked_child = True\\n            self.nodes[num].locked = -1\\n        if not self.nodes[num].children:\\n            return \\n        for child in self.nodes[num].children:\\n            self.unlock_children(child)\\n        return \\n    \\n    def check_parent(self, num):\\n        if num == -1:\\n            return \\n        if self.nodes[num].locked != -1:\\n            self.locked_parent = True\\n        self.check_parent(self.nodes[num].parent)\\n        return \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1446378,
                "title": "store-the-sub-trees-dfs-c",
                "content": "Calculate the subtrees of neighbours of current_node in dfs and then calculate the subtree for the current_node.\\n```\\n//https://leetcode.com/contest/biweekly-contest-60/problems/operations-on-tree/\\n\\nclass LockingTree {\\npublic:\\n    \\n    vector<int> par;\\n    vector<int> locked;\\n    vector<int> tree[2005], subtree[2005];\\n    int n; // size of the tree\\n    vector<int> dfs(int u, vector<int>& parent){\\n        \\n        vector<int> ans;\\n        ans.push_back(u);\\n        for(auto nbr : tree[u]){\\n            \\n            if(nbr!=parent[u]){\\n                dfs(nbr,parent);\\n                for(int j=0; j<subtree[nbr].size() ; j++){\\n                    ans.push_back(subtree[nbr][j]);\\n                }\\n            }\\n        }\\n        return subtree[u] = ans;\\n    }\\n    void moveup(vector<int>& a,int x){\\n        //x=par[x];\\n        while(x!=0){\\n            x = par[x];\\n            a.push_back(x);\\n        }\\n        a.push_back(x);\\n        return;\\n    }\\n    \\n    LockingTree(vector<int>& parent){\\n        \\n        n = parent.size();\\n        par.resize(n,0);\\n        locked.resize(n,0);\\n        for(int i=0 ; i<n ; i++){\\n\\n            par[i] = parent[i];\\n            if(i != 0){\\n                tree[i].push_back(par[i]);\\n                tree[par[i]].push_back(i);\\n            }\\n        }\\n        dfs(0,par);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locked[num]>0)\\n            return false;\\n        locked[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked[num]!=user)\\n            return false;\\n        locked[num] = 0;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        vector<int> ancestors;\\n        moveup(ancestors,num);\\n        if(locked[num]>0)\\n            return false;\\n        bool flag = false;\\n        if(subtree[num].size()==1)\\n            return false;\\n        \\n        for(int i=1; i<subtree[num].size() ; i++){\\n            if(locked[subtree[num][i]]>0){\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if(!flag)\\n            return false;\\n        \\n        for(int i=0 ;i<ancestors.size() ; i++){\\n            if(locked[ancestors[i]]>0)\\n                return false;\\n        }\\n        locked[num]=user;\\n        for(int i=1; i<subtree[num].size(); i++){\\n            locked[subtree[num][i]]=0;\\n        }\\n        return true;\\n        // could have used buinary lifting here ??\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n//https://leetcode.com/contest/biweekly-contest-60/problems/operations-on-tree/\\n\\nclass LockingTree {\\npublic:\\n    \\n    vector<int> par;\\n    vector<int> locked;\\n    vector<int> tree[2005], subtree[2005];\\n    int n; // size of the tree\\n    vector<int> dfs(int u, vector<int>& parent){\\n        \\n        vector<int> ans;\\n        ans.push_back(u);\\n        for(auto nbr : tree[u]){\\n            \\n            if(nbr!=parent[u]){\\n                dfs(nbr,parent);\\n                for(int j=0; j<subtree[nbr].size() ; j++){\\n                    ans.push_back(subtree[nbr][j]);\\n                }\\n            }\\n        }\\n        return subtree[u] = ans;\\n    }\\n    void moveup(vector<int>& a,int x){\\n        //x=par[x];\\n        while(x!=0){\\n            x = par[x];\\n            a.push_back(x);\\n        }\\n        a.push_back(x);\\n        return;\\n    }\\n    \\n    LockingTree(vector<int>& parent){\\n        \\n        n = parent.size();\\n        par.resize(n,0);\\n        locked.resize(n,0);\\n        for(int i=0 ; i<n ; i++){\\n\\n            par[i] = parent[i];\\n            if(i != 0){\\n                tree[i].push_back(par[i]);\\n                tree[par[i]].push_back(i);\\n            }\\n        }\\n        dfs(0,par);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(locked[num]>0)\\n            return false;\\n        locked[num] = user;\\n        return true;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(locked[num]!=user)\\n            return false;\\n        locked[num] = 0;\\n        return true;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        vector<int> ancestors;\\n        moveup(ancestors,num);\\n        if(locked[num]>0)\\n            return false;\\n        bool flag = false;\\n        if(subtree[num].size()==1)\\n            return false;\\n        \\n        for(int i=1; i<subtree[num].size() ; i++){\\n            if(locked[subtree[num][i]]>0){\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if(!flag)\\n            return false;\\n        \\n        for(int i=0 ;i<ancestors.size() ; i++){\\n            if(locked[ancestors[i]]>0)\\n                return false;\\n        }\\n        locked[num]=user;\\n        for(int i=1; i<subtree[num].size(); i++){\\n            locked[subtree[num][i]]=0;\\n        }\\n        return true;\\n        // could have used buinary lifting here ??\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446309,
                "title": "python3-explained-easy-to-understand",
                "content": "* Construct custom Tree class with fields - parent and children (as we need both)\\n* At class level maintain few variables.\\n\\t* self.dic -- maps integer value to the node object\\n\\t* self.locked -- dictionary which maps node value -> person who locked that node\\n\\t* self.root -- root of the input tree\\n\\n**Func - 1: lock()** : check if node is locked. If not create new <num, user> in self.locked.  \\n**Func - 2: unlock()** : check if node is already locked or not. If yes, check the mapping is valid or not. If satisfies both conditions then delete <num, user> from self.locked.\\n**Func - 3 upgrade()**: It uses 3 helper functions:\\n\\t* Condition - 1: We check whether node is locked or not.\\n\\t* Condition - 2: one_locked_descendant() -- checks whether it has at least one descendant locked.\\n\\t* Condition - 3: no_locked_ancestors() -- checks whether it has any locked ancestors.\\n\\t\\n\\t* Note: To check condition-2, we need children attribute in Tree class.\\n\\t* To upgrade node -> cond1 should be False and cond2, cond3 should be True.\\n\\t* If all conditions are met, we will simply unlock all descendent using unlock_all_descendant() helper method.\\n\\t* Also lock the queried node.\\n\\n```\\nclass Tree:\\n    def __init__(self, val):\\n        self.val = val\\n        self.parent = None\\n        self.children = []\\n        \\nclass LockingTree:\\n    def __init__(self, parent: List[int]):\\n        root = Tree(0)\\n        root.parent = -1\\n        \\n        self.dic = {0: root}\\n        \\n        for ind, n in enumerate(parent[1:]):\\n            if(ind + 1 not in self.dic):\\n                new = Tree(ind+1)\\n            else:\\n                new = self.dic[ind+1]\\n            \\n            if(n not in self.dic):\\n                self.dic[n] = Tree(n)\\n                \\n            new.parent = self.dic[n]\\n            \\n            self.dic[n].children.append(new)\\n            self.dic[ind+1] = new\\n            \\n        self.root = root\\n        \\n        self.locked = {}\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if(num in self.locked):\\n            return False\\n        \\n        self.locked[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if(num not in self.locked or self.locked[num] != user):\\n            return False\\n        \\n        del self.locked[num]\\n        return True\\n\\n    def no_locked_ancestors(self, node):\\n        if(node == -1):\\n            return True\\n        \\n        if(node.val in self.locked):\\n            return False\\n        \\n        if(node.parent != -1):\\n            return self.no_locked_ancestors(node.parent)\\n        \\n        return True\\n    \\n    def one_locked_descendant(self, node):\\n        if(node.val in self.locked):\\n            return True\\n        \\n        for child in node.children:\\n            ex = self.one_locked_descendant(child)\\n            \\n            if(ex):\\n                return True\\n            \\n        return False\\n        \\n    def unlock_all_descendant(self, node):\\n        if(node.val in self.locked):\\n            del self.locked[node.val]\\n            \\n        for curr in node.children:\\n            self.unlock_all_descendant(curr)\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        cond1 = num in self.locked\\n        cond2 = self.one_locked_descendant(self.dic[num])\\n        cond3 = self.no_locked_ancestors(self.dic[num].parent) \\n        \\n        if(cond1 or not cond2 or not cond3):\\n            return False\\n        \\n        self.unlock_all_descendant(self.dic[num])\\n        self.lock(num, user)\\n        return True\\n        \\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Tree:\\n    def __init__(self, val):\\n        self.val = val\\n        self.parent = None\\n        self.children = []\\n        \\nclass LockingTree:\\n    def __init__(self, parent: List[int]):\\n        root = Tree(0)\\n        root.parent = -1\\n        \\n        self.dic = {0: root}\\n        \\n        for ind, n in enumerate(parent[1:]):\\n            if(ind + 1 not in self.dic):\\n                new = Tree(ind+1)\\n            else:\\n                new = self.dic[ind+1]\\n            \\n            if(n not in self.dic):\\n                self.dic[n] = Tree(n)\\n                \\n            new.parent = self.dic[n]\\n            \\n            self.dic[n].children.append(new)\\n            self.dic[ind+1] = new\\n            \\n        self.root = root\\n        \\n        self.locked = {}\\n\\n    def lock(self, num: int, user: int) -> bool:\\n        if(num in self.locked):\\n            return False\\n        \\n        self.locked[num] = user\\n        return True\\n\\n    def unlock(self, num: int, user: int) -> bool:\\n        if(num not in self.locked or self.locked[num] != user):\\n            return False\\n        \\n        del self.locked[num]\\n        return True\\n\\n    def no_locked_ancestors(self, node):\\n        if(node == -1):\\n            return True\\n        \\n        if(node.val in self.locked):\\n            return False\\n        \\n        if(node.parent != -1):\\n            return self.no_locked_ancestors(node.parent)\\n        \\n        return True\\n    \\n    def one_locked_descendant(self, node):\\n        if(node.val in self.locked):\\n            return True\\n        \\n        for child in node.children:\\n            ex = self.one_locked_descendant(child)\\n            \\n            if(ex):\\n                return True\\n            \\n        return False\\n        \\n    def unlock_all_descendant(self, node):\\n        if(node.val in self.locked):\\n            del self.locked[node.val]\\n            \\n        for curr in node.children:\\n            self.unlock_all_descendant(curr)\\n        \\n    def upgrade(self, num: int, user: int) -> bool:\\n        cond1 = num in self.locked\\n        cond2 = self.one_locked_descendant(self.dic[num])\\n        cond3 = self.no_locked_ancestors(self.dic[num].parent) \\n        \\n        if(cond1 or not cond2 or not cond3):\\n            return False\\n        \\n        self.unlock_all_descendant(self.dic[num])\\n        self.lock(num, user)\\n        return True\\n        \\n# Your LockingTree object will be instantiated and called as such:\\n# obj = LockingTree(parent)\\n# param_1 = obj.lock(num,user)\\n# param_2 = obj.unlock(num,user)\\n# param_3 = obj.upgrade(num,user)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446048,
                "title": "python-fast-dfs-solution-with-detailed-explanation-and-comments",
                "content": "```\\nimport collections\\nclass LockingTree:\\n    def __init__(self, parent: List[int]):\\n        self.tree=collections.defaultdict(set)\\n        n=len(parent)\\n        for i in range(1,n):\\n            self.tree[parent[i]].add(i)\\n        self.locked=collections.defaultdict(int)\\n        #unlocked state is represented by -1\\n        for i in range(n):\\n            self.locked[i]=-1\\n        self.parents=parent\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]==-1:\\n            self.locked[num]=user\\n            return True\\n        return False\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num]==user:\\n            self.locked[num]=-1\\n            return True\\n        return False\\n    def upgrade(self, num: int, user: int) -> bool:\\n        #condition 1\\n        if self.locked[num]!=-1:return False\\n\\n        #condition 3\\n        #checking for locked parent\\n        parent=[self.parents[num]]\\n        locked_par=False\\n        while parent:\\n            par=parent.pop()\\n            if par==-1:continue\\n            if self.locked[par]!=-1:\\n                locked_par=True\\n                break\\n            parent.append(self.parents[par])\\n        #if it has locked parent return False\\n        if locked_par==True:return False\\n\\n        #condition 2\\n        #checking for locked children\\n        locked_children=[]\\n        children=[num]\\n        while children:\\n            child=children.pop()\\n            if self.locked[child]!=-1:\\n                locked_children.append(child)\\n            for i in self.tree[child]:\\n                children.append(i)\\n        #checking if locked children exist ie condition\\n        if len(locked_children)==0:return False\\n\\n        #all the condition are met therfore doing the neccesary tasks\\n        self.locked[num]=user\\n        for child in locked_children:\\n            self.locked[child]=-1\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nimport collections\\nclass LockingTree:\\n    def __init__(self, parent: List[int]):\\n        self.tree=collections.defaultdict(set)\\n        n=len(parent)\\n        for i in range(1,n):\\n            self.tree[parent[i]].add(i)\\n        self.locked=collections.defaultdict(int)\\n        #unlocked state is represented by -1\\n        for i in range(n):\\n            self.locked[i]=-1\\n        self.parents=parent\\n    def lock(self, num: int, user: int) -> bool:\\n        if self.locked[num]==-1:\\n            self.locked[num]=user\\n            return True\\n        return False\\n    def unlock(self, num: int, user: int) -> bool:\\n        if self.locked[num]==user:\\n            self.locked[num]=-1\\n            return True\\n        return False\\n    def upgrade(self, num: int, user: int) -> bool:\\n        #condition 1\\n        if self.locked[num]!=-1:return False\\n\\n        #condition 3\\n        #checking for locked parent\\n        parent=[self.parents[num]]\\n        locked_par=False\\n        while parent:\\n            par=parent.pop()\\n            if par==-1:continue\\n            if self.locked[par]!=-1:\\n                locked_par=True\\n                break\\n            parent.append(self.parents[par])\\n        #if it has locked parent return False\\n        if locked_par==True:return False\\n\\n        #condition 2\\n        #checking for locked children\\n        locked_children=[]\\n        children=[num]\\n        while children:\\n            child=children.pop()\\n            if self.locked[child]!=-1:\\n                locked_children.append(child)\\n            for i in self.tree[child]:\\n                children.append(i)\\n        #checking if locked children exist ie condition\\n        if len(locked_children)==0:return False\\n\\n        #all the condition are met therfore doing the neccesary tasks\\n        self.locked[num]=user\\n        for child in locked_children:\\n            self.locked[child]=-1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445946,
                "title": "c-clean-code-using-map-and-recursion",
                "content": "```\\nclass LockingTree {\\npublic:\\n    vector<int> p;\\n    unordered_map<int,int> lockToUser;\\n    vector<vector<int>> child;\\n    \\n    LockingTree(vector<int>& parent) {\\n        p = parent;\\n        int n = p.size();\\n        child.resize(n);\\n        for(int i=1; i<n; i++){\\n            child[p[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(lockToUser.find(num) == lockToUser.end()){\\n            lockToUser[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(lockToUser.find(num) != lockToUser.end()){\\n            if(lockToUser[num] == user){\\n                lockToUser.erase(num);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void checkDes(int num, bool &check2){\\n        for(auto ch:child[num]){\\n            if(lockToUser.find(ch) != lockToUser.end()){\\n                check2 = true;\\n                return;\\n            }\\n            checkDes(ch, check2);\\n        }\\n    }\\n    \\n    void checkPar(int num, bool &check3){\\n        while(num!=0){\\n            num = p[num];\\n            if(lockToUser.find(num) != lockToUser.end()){\\n                check3 = false;\\n                return;\\n            }\\n        }\\n    }\\n    \\n    void unlblockDes(int num){\\n        for(auto ch:child[num]){\\n            if(lockToUser.find(ch) != lockToUser.end()){\\n                lockToUser.erase(ch);\\n            }\\n            unlblockDes(ch);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        bool check1 = lockToUser.find(num) == lockToUser.end();\\n        if(check1){\\n            bool check2 = false;\\n            checkDes(num, check2);\\n            if(check2){\\n                bool check3 = true;\\n                checkPar(num, check3);\\n                if(check3){\\n                    lockToUser[num] = user;\\n                    unlblockDes(num);\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LockingTree {\\npublic:\\n    vector<int> p;\\n    unordered_map<int,int> lockToUser;\\n    vector<vector<int>> child;\\n    \\n    LockingTree(vector<int>& parent) {\\n        p = parent;\\n        int n = p.size();\\n        child.resize(n);\\n        for(int i=1; i<n; i++){\\n            child[p[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(lockToUser.find(num) == lockToUser.end()){\\n            lockToUser[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(lockToUser.find(num) != lockToUser.end()){\\n            if(lockToUser[num] == user){\\n                lockToUser.erase(num);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void checkDes(int num, bool &check2){\\n        for(auto ch:child[num]){\\n            if(lockToUser.find(ch) != lockToUser.end()){\\n                check2 = true;\\n                return;\\n            }\\n            checkDes(ch, check2);\\n        }\\n    }\\n    \\n    void checkPar(int num, bool &check3){\\n        while(num!=0){\\n            num = p[num];\\n            if(lockToUser.find(num) != lockToUser.end()){\\n                check3 = false;\\n                return;\\n            }\\n        }\\n    }\\n    \\n    void unlblockDes(int num){\\n        for(auto ch:child[num]){\\n            if(lockToUser.find(ch) != lockToUser.end()){\\n                lockToUser.erase(ch);\\n            }\\n            unlblockDes(ch);\\n        }\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        bool check1 = lockToUser.find(num) == lockToUser.end();\\n        if(check1){\\n            bool check2 = false;\\n            checkDes(num, check2);\\n            if(check2){\\n                bool check3 = true;\\n                checkPar(num, check3);\\n                if(check3){\\n                    lockToUser[num] = user;\\n                    unlblockDes(num);\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445520,
                "title": "java-store-children-s-of-every-node-bfs",
                "content": "```\\nclass LockingTree {\\n    \\n    ArrayList<Integer> [] decendants = null;\\n    int[] lockStatus = null;\\n    int[] parent = null;\\n    \\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        \\n        this.parent = parent;\\n        decendants = new ArrayList[n];\\n        lockStatus = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n        decendants[i] =  new ArrayList<>();            \\n        \\n        fillDecendants();\\n    }\\n    \\n    private void fillDecendants(){\\n        for(int i=1; i<parent.length; i++){\\n            decendants[parent[i]].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(lockStatus[num]!=0) return false;\\n        \\n        lockStatus[num] = user;\\n        \\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(lockStatus[num]!=user) return false;\\n        \\n        lockStatus[num] = 0;\\n        \\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if(lockStatus[num]!=0 || hasLockedAncestors(num) || !hasLockedDecendants(num)) return false;\\n        \\n        lockStatus[num] = user;\\n        unlockDecendants(num);\\n        \\n        return true;\\n        \\n    }\\n    \\n    private void unlockDecendants(int num){\\n        \\n         for(int i=0; i<decendants[num].size(); i++){\\n             int decendant = decendants[num].get(i);\\n             lockStatus[decendant] = 0;\\n             unlockDecendants(decendant);\\n        }\\n    }\\n    \\n    private boolean hasLockedDecendants(int num){\\n        if(lockStatus[num] != 0) return true;\\n        \\n        for(int i=0; i<decendants[num].size(); i++){\\n            if(hasLockedDecendants(decendants[num].get(i))) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean hasLockedAncestors(int num){\\n        int n = num;\\n        while(parent[n]!=-1){\\n            n = parent[n];\\n            if(lockStatus[n] != 0) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass LockingTree {\\n    \\n    ArrayList<Integer> [] decendants = null;\\n    int[] lockStatus = null;\\n    int[] parent = null;\\n    \\n    public LockingTree(int[] parent) {\\n        int n = parent.length;\\n        \\n        this.parent = parent;\\n        decendants = new ArrayList[n];\\n        lockStatus = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n        decendants[i] =  new ArrayList<>();            \\n        \\n        fillDecendants();\\n    }\\n    \\n    private void fillDecendants(){\\n        for(int i=1; i<parent.length; i++){\\n            decendants[parent[i]].add(i);\\n        }\\n    }\\n    \\n    public boolean lock(int num, int user) {\\n        if(lockStatus[num]!=0) return false;\\n        \\n        lockStatus[num] = user;\\n        \\n        return true;\\n    }\\n    \\n    public boolean unlock(int num, int user) {\\n        if(lockStatus[num]!=user) return false;\\n        \\n        lockStatus[num] = 0;\\n        \\n        return true;\\n    }\\n    \\n    public boolean upgrade(int num, int user) {\\n        if(lockStatus[num]!=0 || hasLockedAncestors(num) || !hasLockedDecendants(num)) return false;\\n        \\n        lockStatus[num] = user;\\n        unlockDecendants(num);\\n        \\n        return true;\\n        \\n    }\\n    \\n    private void unlockDecendants(int num){\\n        \\n         for(int i=0; i<decendants[num].size(); i++){\\n             int decendant = decendants[num].get(i);\\n             lockStatus[decendant] = 0;\\n             unlockDecendants(decendant);\\n        }\\n    }\\n    \\n    private boolean hasLockedDecendants(int num){\\n        if(lockStatus[num] != 0) return true;\\n        \\n        for(int i=0; i<decendants[num].size(); i++){\\n            if(hasLockedDecendants(decendants[num].get(i))) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean hasLockedAncestors(int num){\\n        int n = num;\\n        while(parent[n]!=-1){\\n            n = parent[n];\\n            if(lockStatus[n] != 0) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445422,
                "title": "c-using-map-and-bfs",
                "content": "\\n\\n\\n```\\nclass LockingTree {\\npublic:\\n    unordered_map<int,int>mp, p; \\n    unordered_map<int, vector<int>>tree;\\n    \\n    LockingTree(vector<int>& parent) {\\n        \\n        for(int i = 0; i < parent.size(); i++)\\n        {\\n            p[i] = parent[i];\\n            tree[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        \\n        if(mp[num] == 0)\\n        {\\n            mp[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        \\n        if(mp[num] == user)\\n        {\\n            mp[num] = 0;\\n            return true;\\n        } \\n        return false;    \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        if(mp[num] != 0)       //check if the node is unlock or not\\n            return false;\\n        \\n        bool ok1 = true, ok2 = false;\\n        int cur = num;\\n        \\n        while(cur != -1)           //to check if any ancestor is locked\\n        {\\n            if(mp[cur] != 0)\\n            {\\n                ok1 = false;\\n                break;\\n            }\\n            cur = p[cur];\\n        }\\n        \\n        if(!ok1)\\n            return false;\\n        \\n        queue<int>q;\\n        q.push(num);\\n       \\n        while(!q.empty())                //bfs traversal to check if there is any descendant that is locked (BFS traversal)\\n        {\\n            int temp = q.front();\\n            q.pop();\\n            \\n            if(mp[temp] != 0)\\n            {\\n                ok2 = true;\\n                mp[temp] = 0;\\n            }\\n\\n            for(auto itr = tree[temp].begin(); itr != tree[temp].end(); itr++)\\n            {\\n                q.push(*itr);\\n            }\\n        }\\n        \\n        if(ok2)\\n        {\\n            mp[num] = user;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "\\n\\n\\n```\\nclass LockingTree {\\npublic:\\n    unordered_map<int,int>mp, p; \\n    unordered_map<int, vector<int>>tree;\\n    \\n    LockingTree(vector<int>& parent) {\\n        \\n        for(int i = 0; i < parent.size(); i++)\\n        {\\n            p[i] = parent[i];\\n            tree[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        \\n        if(mp[num] == 0)\\n        {\\n            mp[num] = user;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        \\n        if(mp[num] == user)\\n        {\\n            mp[num] = 0;\\n            return true;\\n        } \\n        return false;    \\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        \\n        if(mp[num] != 0)       //check if the node is unlock or not\\n            return false;\\n        \\n        bool ok1 = true, ok2 = false;\\n        int cur = num;\\n        \\n        while(cur != -1)           //to check if any ancestor is locked\\n        {\\n            if(mp[cur] != 0)\\n            {\\n                ok1 = false;\\n                break;\\n            }\\n            cur = p[cur];\\n        }\\n        \\n        if(!ok1)\\n            return false;\\n        \\n        queue<int>q;\\n        q.push(num);\\n       \\n        while(!q.empty())                //bfs traversal to check if there is any descendant that is locked (BFS traversal)\\n        {\\n            int temp = q.front();\\n            q.pop();\\n            \\n            if(mp[temp] != 0)\\n            {\\n                ok2 = true;\\n                mp[temp] = 0;\\n            }\\n\\n            for(auto itr = tree[temp].begin(); itr != tree[temp].end(); itr++)\\n            {\\n                q.push(*itr);\\n            }\\n        }\\n        \\n        if(ok2)\\n        {\\n            mp[num] = user;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1445411,
                "title": "c-328-ms-faster-than-100-optimized-upgrade-operation",
                "content": "Upgrade function call can be optimized if we keep a track of number of locked descendents for every node.\\n\\n```\\n\\nclass LockingTree {\\npublic:\\n    \\n    vector<int> p; // parent array\\n    vector<int> d; // num of locked descendents of ith node\\n    vector<int> l; // lock status\\n    vector<vector<int> > tree; // tree for descendent traversal\\n    \\n    LockingTree(vector<int>& parent) {\\n        p = parent;\\n        d.resize(parent.size(), 0);\\n        l.resize(parent.size(), 0);\\n        tree.resize(parent.size(), vector<int>());\\n        \\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]!=-1)\\n                tree[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(l[num]==0){\\n            l[num] = user;\\n            int x = num;\\n            while(x!=0){\\n                x = p[x];\\n                d[x]++;\\n            }\\n            d[x]++;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(l[num]==user){\\n            l[num]=0;\\n            int x = num;\\n            while(x!=0){\\n                x = p[x];\\n                d[x]--;\\n            }\\n            d[x]--;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    void unlock_descendents(int x){\\n        l[x] = 0;\\n        for(auto i: tree[x])\\n            unlock_descendents(i);\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(l[num]==0 && d[num]>0){\\n            bool f = 1;\\n            int x=num;\\n            while(x!=0){\\n                x = p[x];\\n                f = f && (l[x]==0);\\n            }\\n            f = f && (l[x]==0);\\n            if(f){\\n                unlock_descendents(num);\\n                l[num] = user;\\n                return 1;   \\n            }else\\n                return 0;\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass LockingTree {\\npublic:\\n    \\n    vector<int> p; // parent array\\n    vector<int> d; // num of locked descendents of ith node\\n    vector<int> l; // lock status\\n    vector<vector<int> > tree; // tree for descendent traversal\\n    \\n    LockingTree(vector<int>& parent) {\\n        p = parent;\\n        d.resize(parent.size(), 0);\\n        l.resize(parent.size(), 0);\\n        tree.resize(parent.size(), vector<int>());\\n        \\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]!=-1)\\n                tree[parent[i]].push_back(i);\\n        }\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(l[num]==0){\\n            l[num] = user;\\n            int x = num;\\n            while(x!=0){\\n                x = p[x];\\n                d[x]++;\\n            }\\n            d[x]++;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(l[num]==user){\\n            l[num]=0;\\n            int x = num;\\n            while(x!=0){\\n                x = p[x];\\n                d[x]--;\\n            }\\n            d[x]--;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    void unlock_descendents(int x){\\n        l[x] = 0;\\n        for(auto i: tree[x])\\n            unlock_descendents(i);\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        if(l[num]==0 && d[num]>0){\\n            bool f = 1;\\n            int x=num;\\n            while(x!=0){\\n                x = p[x];\\n                f = f && (l[x]==0);\\n            }\\n            f = f && (l[x]==0);\\n            if(f){\\n                unlock_descendents(num);\\n                l[num] = user;\\n                return 1;   \\n            }else\\n                return 0;\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your LockingTree object will be instantiated and called as such:\\n * LockingTree* obj = new LockingTree(parent);\\n * bool param_1 = obj->lock(num,user);\\n * bool param_2 = obj->unlock(num,user);\\n * bool param_3 = obj->upgrade(num,user);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445379,
                "title": "readable-clean-python-with-docstrings",
                "content": "Added annotations and docstrings to make code clear and readable, we aslo extracted some common methods into private functions to keep the logic clean in the public APIs.\\n\\n**Runtime: 1956 ms\\nMemory Usage: 16.2 MB**\\n\\n```\\nANY = -2\\n\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self._parent = parent\\n        self._kids = self._create_kids()\\n        self._locked = {}  # node -> user\\n                \\n    def lock(self, node: int, user: int) -> bool:\\n        \"\"\"Public lock method.\"\"\"\\n        return self._lock(node, user)\\n        \\n    def unlock(self, node: int, user: int) -> bool:\\n        \"\"\"Public unlock method.\"\"\"\\n        return self._unlock(node, user)\\n        \\n    def upgrade(self, node: int, user: int) -> bool:\\n        \"\"\"Public upgrade method.\"\"\"\\n        if self._is_locked(node):\\n            return False\\n        if not self._check_no_locked_ancestors(node):\\n            return False\\n        if not self._check_and_unlock_descendant(node):\\n            return False\\n        return self._lock(node, user)\\n\\n    def _create_kids(self) -> None:\\n        \"\"\"Creates kids relationship.\"\"\"\\n        n = len(self._parent)\\n        kids = [[] for _ in range(n)]\\n        for kid in range(n):\\n            father = self._parent[kid]\\n            if father >= 0:\\n                kids[father].append(kid)\\n        return kids\\n    \\n    def _is_locked(self, node: int) -> bool:\\n        \"\"\"Returns if the node is locked.\"\"\"\\n        return node in self._locked\\n    \\n    def _get_lock_usr(self, node: int) -> int:\\n        \"\"\"Gets the user who locked the node.\"\"\"\\n        return self._locked.get(node)\\n    \\n    def _lock(self, node: int, user: int) -> bool:\\n        \"\"\"Locks the node by the user.\"\"\"\\n        if self._is_locked(node):\\n            return False\\n        self._locked[node] = user\\n        return True\\n\\n    def _unlock(self, node: int, user: int, force: bool = False) -> bool:\\n        \"\"\"Unlocks the node by the user.\"\"\"\\n        if not self._is_locked(node):\\n            return False\\n        if not force:\\n            if self._get_lock_usr(node) != user:\\n                return False\\n        del self._locked[node]\\n        return True\\n    \\n    def _check_no_locked_ancestors(self, node: int) -> bool:\\n        \"\"\"Checks if no locked ancestors.\"\"\"\\n        cur_node = node\\n        while cur_node >= 0:\\n            if self._is_locked(cur_node):\\n                return False\\n            cur_node = self._parent[cur_node]\\n        return True\\n    \\n    def _check_and_unlock_descendant(self, node: int) -> bool:\\n        \"\"\"Checks and unlocks the descendant.\"\"\"\\n        queue = self._kids[node].copy()\\n        has_lock = False\\n        while queue:\\n            kid = queue.pop(0)\\n            if self._is_locked(kid):\\n                has_lock = True\\n                self._unlock(kid, ANY, force=True)\\n            for grand_kid in self._kids[kid]:\\n                queue.append(grand_kid)\\n        return has_lock\\n\\n```",
                "solutionTags": [],
                "code": "```\\nANY = -2\\n\\nclass LockingTree:\\n\\n    def __init__(self, parent: List[int]):\\n        self._parent = parent\\n        self._kids = self._create_kids()\\n        self._locked = {}  # node -> user\\n                \\n    def lock(self, node: int, user: int) -> bool:\\n        \"\"\"Public lock method.\"\"\"\\n        return self._lock(node, user)\\n        \\n    def unlock(self, node: int, user: int) -> bool:\\n        \"\"\"Public unlock method.\"\"\"\\n        return self._unlock(node, user)\\n        \\n    def upgrade(self, node: int, user: int) -> bool:\\n        \"\"\"Public upgrade method.\"\"\"\\n        if self._is_locked(node):\\n            return False\\n        if not self._check_no_locked_ancestors(node):\\n            return False\\n        if not self._check_and_unlock_descendant(node):\\n            return False\\n        return self._lock(node, user)\\n\\n    def _create_kids(self) -> None:\\n        \"\"\"Creates kids relationship.\"\"\"\\n        n = len(self._parent)\\n        kids = [[] for _ in range(n)]\\n        for kid in range(n):\\n            father = self._parent[kid]\\n            if father >= 0:\\n                kids[father].append(kid)\\n        return kids\\n    \\n    def _is_locked(self, node: int) -> bool:\\n        \"\"\"Returns if the node is locked.\"\"\"\\n        return node in self._locked\\n    \\n    def _get_lock_usr(self, node: int) -> int:\\n        \"\"\"Gets the user who locked the node.\"\"\"\\n        return self._locked.get(node)\\n    \\n    def _lock(self, node: int, user: int) -> bool:\\n        \"\"\"Locks the node by the user.\"\"\"\\n        if self._is_locked(node):\\n            return False\\n        self._locked[node] = user\\n        return True\\n\\n    def _unlock(self, node: int, user: int, force: bool = False) -> bool:\\n        \"\"\"Unlocks the node by the user.\"\"\"\\n        if not self._is_locked(node):\\n            return False\\n        if not force:\\n            if self._get_lock_usr(node) != user:\\n                return False\\n        del self._locked[node]\\n        return True\\n    \\n    def _check_no_locked_ancestors(self, node: int) -> bool:\\n        \"\"\"Checks if no locked ancestors.\"\"\"\\n        cur_node = node\\n        while cur_node >= 0:\\n            if self._is_locked(cur_node):\\n                return False\\n            cur_node = self._parent[cur_node]\\n        return True\\n    \\n    def _check_and_unlock_descendant(self, node: int) -> bool:\\n        \"\"\"Checks and unlocks the descendant.\"\"\"\\n        queue = self._kids[node].copy()\\n        has_lock = False\\n        while queue:\\n            kid = queue.pop(0)\\n            if self._is_locked(kid):\\n                has_lock = True\\n                self._unlock(kid, ANY, force=True)\\n            for grand_kid in self._kids[kid]:\\n                queue.append(grand_kid)\\n        return has_lock\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445095,
                "title": "unordered-map-queue-for-bfs",
                "content": "using vector for storing locked data, unordered_map for descendent, queue for BFS\\n\\n```\\nclass LockingTree {\\npublic:\\n    //this vector is for storing parent data(parent of i = tree[i] )\\n    vector<int> tree;\\n    //this umap have key as a node and value as a vector of next child nodes\\n    unordered_map<int, vector<int>> umap; \\n    //this vector is for storing node and locked user data(if node is unlocked then vec[i] = -1)\\n    vector<int> lvec;\\n    \\n    LockingTree(vector<int>& parent) {\\n        tree = parent;\\n        for(int i =  0; i < parent.size(); i++)\\n            umap[parent[i]].push_back(i);\\n        lvec.assign(parent.size(), -1);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(lvec[num] == -1){\\n            lvec[num] = user;\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(lvec[num] == user){\\n            lvec[num] = -1;\\n            return true;            \\n        }\\n        else\\n            return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        int i = num;\\n        while(i != -1){\\n            if(lvec[i] != -1)\\n                return false;                \\n            i = tree[i];\\n        }\\n\\n        bool check = false;\\n        queue<int> q;\\n        q.push(num);\\n        \\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n            if(lvec[cur] != -1){\\n                check = true;\\n                lvec[cur] = -1;\\n            }\\n            for(auto it : umap[cur])\\n                q.push(it);\\n        }\\n        \\n        if(!check)\\n            return false;\\n            \\n        lvec[num] = user;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass LockingTree {\\npublic:\\n    //this vector is for storing parent data(parent of i = tree[i] )\\n    vector<int> tree;\\n    //this umap have key as a node and value as a vector of next child nodes\\n    unordered_map<int, vector<int>> umap; \\n    //this vector is for storing node and locked user data(if node is unlocked then vec[i] = -1)\\n    vector<int> lvec;\\n    \\n    LockingTree(vector<int>& parent) {\\n        tree = parent;\\n        for(int i =  0; i < parent.size(); i++)\\n            umap[parent[i]].push_back(i);\\n        lvec.assign(parent.size(), -1);\\n    }\\n    \\n    bool lock(int num, int user) {\\n        if(lvec[num] == -1){\\n            lvec[num] = user;\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n    \\n    bool unlock(int num, int user) {\\n        if(lvec[num] == user){\\n            lvec[num] = -1;\\n            return true;            \\n        }\\n        else\\n            return false;\\n    }\\n    \\n    bool upgrade(int num, int user) {\\n        int i = num;\\n        while(i != -1){\\n            if(lvec[i] != -1)\\n                return false;                \\n            i = tree[i];\\n        }\\n\\n        bool check = false;\\n        queue<int> q;\\n        q.push(num);\\n        \\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n            if(lvec[cur] != -1){\\n                check = true;\\n                lvec[cur] = -1;\\n            }\\n            for(auto it : umap[cur])\\n                q.push(it);\\n        }\\n        \\n        if(!check)\\n            return false;\\n            \\n        lvec[num] = user;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1890628,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "pls note tree is not necessary binary as in example"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Here are some test cases if you need:\\n\\n```\\n[\"LockingTree\", \"lock\", \"unlock\", \"lock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"upgrade\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"upgrade\", \"lock\"]\\n[[[-1, 0, 0, 2, 2, 3, 5, 0, 2, 0, 1, 7, 3, 8, 8, 0, 9, 4, 5, 5]], [4, 8], [3, 2], [0, 4], [9, 9], [0, 3], [0, 7], [5, 9], [4, 9], [0, 4], [5, 6], [4, 5], [4, 1], [5, 4], [2, 7], [9, 9], [2, 7], [2, 2], [1, 1], [8, 6]]\\n\\n[\"LockingTree\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"upgrade\", \"lock\", \"upgrade\", \"unlock\", \"unlock\", \"upgrade\", \"upgrade\", \"unlock\", \"lock\"]\\n[[[-1, 0, 0, 0, 3, 4, 5, 5, 3, 5, 6, 10, 2, 0, 0, 10, 14, 6, 2, 18]], [2, 3], [1, 3], [2, 3], [2, 3], [1, 3], [1, 3], [1, 3], [2, 3], [0, 1], [3, 3], [1, 1], [2, 2], [0, 1], [0, 3], [1, 2], [2, 2], [2, 3], [3, 1], [1, 3]] \\n```\\n\\nPython code to generate test cases\\n\\n```\\nparentLength = 2000\\noperationLength = 2000\\nparents = [-1]\\nfor i in range(1, parentLength):\\n    parents.append(random.randint(0, i-1))\\n\\noperations = [\"LockingTree\"]\\nfor i in range(1, operationLength):\\n    operations.append(random.choice([\"lock\", \"unlock\", \"upgrade\"]))\\n\\nargs = [[parents]]\\nfor i in range(1, operationLength):\\n    args.append([random.randint(0, 5), random.randint(1, 5)])\\n\\nprint(json.dumps(operations))\\nprint(json.dumps(args))\\n```\\n\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This question is deadly if you are oblivious enough  to the  explanation"
                    },
                    {
                        "username": "Shuvadeep_saha",
                        "content": "As per my understanding, the problem considers a node to be descendant of itself (at least this is when all the test cases pass). So when a node (that the user is trying to upgrade to) is locked this would also imply that at least one of its descendants are locked. Then how are all the three conditions in the `upgrade()` function satisfied? The fist condition `the node is unlocked` becomes void. Any suggestions anyone?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "DFS for ascendant check, BFS for descendant check\\nA little bit boring"
                    },
                    {
                        "username": "DeathNote",
                        "content": "I dont quite understand parentList, is it n-th child node map to value of parent\\'s node ?... quite confused."
                    },
                    {
                        "username": "sk4142",
                        "content": "For test case 1: parentList = [-1,0,0,1,1,2,2]. At i = 3, parent[3] = 1. This means that 3\\'s parent is 1. "
                    },
                    {
                        "username": "barnik_b",
                        "content": "\"You are given a tree with ```n``` nodes numbered from ```0``` to ```n - 1``` in the form of a parent array parent where parent[i] is the parent of the ith node.\"\n\nparent[i] indicates there is an edge from node ```i``` to ```parent[i]``` (aka node ```i's``` parent). That's why ```parent[0] = -1``` since the root node does not have a parent, Hope this clears your doubt."
                    }
                ]
            },
            {
                "id": 1981696,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "pls note tree is not necessary binary as in example"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Here are some test cases if you need:\\n\\n```\\n[\"LockingTree\", \"lock\", \"unlock\", \"lock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"upgrade\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"upgrade\", \"lock\"]\\n[[[-1, 0, 0, 2, 2, 3, 5, 0, 2, 0, 1, 7, 3, 8, 8, 0, 9, 4, 5, 5]], [4, 8], [3, 2], [0, 4], [9, 9], [0, 3], [0, 7], [5, 9], [4, 9], [0, 4], [5, 6], [4, 5], [4, 1], [5, 4], [2, 7], [9, 9], [2, 7], [2, 2], [1, 1], [8, 6]]\\n\\n[\"LockingTree\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"upgrade\", \"lock\", \"upgrade\", \"unlock\", \"unlock\", \"upgrade\", \"upgrade\", \"unlock\", \"lock\"]\\n[[[-1, 0, 0, 0, 3, 4, 5, 5, 3, 5, 6, 10, 2, 0, 0, 10, 14, 6, 2, 18]], [2, 3], [1, 3], [2, 3], [2, 3], [1, 3], [1, 3], [1, 3], [2, 3], [0, 1], [3, 3], [1, 1], [2, 2], [0, 1], [0, 3], [1, 2], [2, 2], [2, 3], [3, 1], [1, 3]] \\n```\\n\\nPython code to generate test cases\\n\\n```\\nparentLength = 2000\\noperationLength = 2000\\nparents = [-1]\\nfor i in range(1, parentLength):\\n    parents.append(random.randint(0, i-1))\\n\\noperations = [\"LockingTree\"]\\nfor i in range(1, operationLength):\\n    operations.append(random.choice([\"lock\", \"unlock\", \"upgrade\"]))\\n\\nargs = [[parents]]\\nfor i in range(1, operationLength):\\n    args.append([random.randint(0, 5), random.randint(1, 5)])\\n\\nprint(json.dumps(operations))\\nprint(json.dumps(args))\\n```\\n\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This question is deadly if you are oblivious enough  to the  explanation"
                    },
                    {
                        "username": "Shuvadeep_saha",
                        "content": "As per my understanding, the problem considers a node to be descendant of itself (at least this is when all the test cases pass). So when a node (that the user is trying to upgrade to) is locked this would also imply that at least one of its descendants are locked. Then how are all the three conditions in the `upgrade()` function satisfied? The fist condition `the node is unlocked` becomes void. Any suggestions anyone?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "DFS for ascendant check, BFS for descendant check\\nA little bit boring"
                    },
                    {
                        "username": "DeathNote",
                        "content": "I dont quite understand parentList, is it n-th child node map to value of parent\\'s node ?... quite confused."
                    },
                    {
                        "username": "sk4142",
                        "content": "For test case 1: parentList = [-1,0,0,1,1,2,2]. At i = 3, parent[3] = 1. This means that 3\\'s parent is 1. "
                    },
                    {
                        "username": "barnik_b",
                        "content": "\"You are given a tree with ```n``` nodes numbered from ```0``` to ```n - 1``` in the form of a parent array parent where parent[i] is the parent of the ith node.\"\n\nparent[i] indicates there is an edge from node ```i``` to ```parent[i]``` (aka node ```i's``` parent). That's why ```parent[0] = -1``` since the root node does not have a parent, Hope this clears your doubt."
                    }
                ]
            },
            {
                "id": 1936782,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "pls note tree is not necessary binary as in example"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Here are some test cases if you need:\\n\\n```\\n[\"LockingTree\", \"lock\", \"unlock\", \"lock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"upgrade\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"upgrade\", \"lock\"]\\n[[[-1, 0, 0, 2, 2, 3, 5, 0, 2, 0, 1, 7, 3, 8, 8, 0, 9, 4, 5, 5]], [4, 8], [3, 2], [0, 4], [9, 9], [0, 3], [0, 7], [5, 9], [4, 9], [0, 4], [5, 6], [4, 5], [4, 1], [5, 4], [2, 7], [9, 9], [2, 7], [2, 2], [1, 1], [8, 6]]\\n\\n[\"LockingTree\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"upgrade\", \"lock\", \"upgrade\", \"unlock\", \"unlock\", \"upgrade\", \"upgrade\", \"unlock\", \"lock\"]\\n[[[-1, 0, 0, 0, 3, 4, 5, 5, 3, 5, 6, 10, 2, 0, 0, 10, 14, 6, 2, 18]], [2, 3], [1, 3], [2, 3], [2, 3], [1, 3], [1, 3], [1, 3], [2, 3], [0, 1], [3, 3], [1, 1], [2, 2], [0, 1], [0, 3], [1, 2], [2, 2], [2, 3], [3, 1], [1, 3]] \\n```\\n\\nPython code to generate test cases\\n\\n```\\nparentLength = 2000\\noperationLength = 2000\\nparents = [-1]\\nfor i in range(1, parentLength):\\n    parents.append(random.randint(0, i-1))\\n\\noperations = [\"LockingTree\"]\\nfor i in range(1, operationLength):\\n    operations.append(random.choice([\"lock\", \"unlock\", \"upgrade\"]))\\n\\nargs = [[parents]]\\nfor i in range(1, operationLength):\\n    args.append([random.randint(0, 5), random.randint(1, 5)])\\n\\nprint(json.dumps(operations))\\nprint(json.dumps(args))\\n```\\n\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This question is deadly if you are oblivious enough  to the  explanation"
                    },
                    {
                        "username": "Shuvadeep_saha",
                        "content": "As per my understanding, the problem considers a node to be descendant of itself (at least this is when all the test cases pass). So when a node (that the user is trying to upgrade to) is locked this would also imply that at least one of its descendants are locked. Then how are all the three conditions in the `upgrade()` function satisfied? The fist condition `the node is unlocked` becomes void. Any suggestions anyone?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "DFS for ascendant check, BFS for descendant check\\nA little bit boring"
                    },
                    {
                        "username": "DeathNote",
                        "content": "I dont quite understand parentList, is it n-th child node map to value of parent\\'s node ?... quite confused."
                    },
                    {
                        "username": "sk4142",
                        "content": "For test case 1: parentList = [-1,0,0,1,1,2,2]. At i = 3, parent[3] = 1. This means that 3\\'s parent is 1. "
                    },
                    {
                        "username": "barnik_b",
                        "content": "\"You are given a tree with ```n``` nodes numbered from ```0``` to ```n - 1``` in the form of a parent array parent where parent[i] is the parent of the ith node.\"\n\nparent[i] indicates there is an edge from node ```i``` to ```parent[i]``` (aka node ```i's``` parent). That's why ```parent[0] = -1``` since the root node does not have a parent, Hope this clears your doubt."
                    }
                ]
            },
            {
                "id": 2009843,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "pls note tree is not necessary binary as in example"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Here are some test cases if you need:\\n\\n```\\n[\"LockingTree\", \"lock\", \"unlock\", \"lock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"upgrade\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"upgrade\", \"lock\"]\\n[[[-1, 0, 0, 2, 2, 3, 5, 0, 2, 0, 1, 7, 3, 8, 8, 0, 9, 4, 5, 5]], [4, 8], [3, 2], [0, 4], [9, 9], [0, 3], [0, 7], [5, 9], [4, 9], [0, 4], [5, 6], [4, 5], [4, 1], [5, 4], [2, 7], [9, 9], [2, 7], [2, 2], [1, 1], [8, 6]]\\n\\n[\"LockingTree\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"upgrade\", \"lock\", \"upgrade\", \"unlock\", \"unlock\", \"upgrade\", \"upgrade\", \"unlock\", \"lock\"]\\n[[[-1, 0, 0, 0, 3, 4, 5, 5, 3, 5, 6, 10, 2, 0, 0, 10, 14, 6, 2, 18]], [2, 3], [1, 3], [2, 3], [2, 3], [1, 3], [1, 3], [1, 3], [2, 3], [0, 1], [3, 3], [1, 1], [2, 2], [0, 1], [0, 3], [1, 2], [2, 2], [2, 3], [3, 1], [1, 3]] \\n```\\n\\nPython code to generate test cases\\n\\n```\\nparentLength = 2000\\noperationLength = 2000\\nparents = [-1]\\nfor i in range(1, parentLength):\\n    parents.append(random.randint(0, i-1))\\n\\noperations = [\"LockingTree\"]\\nfor i in range(1, operationLength):\\n    operations.append(random.choice([\"lock\", \"unlock\", \"upgrade\"]))\\n\\nargs = [[parents]]\\nfor i in range(1, operationLength):\\n    args.append([random.randint(0, 5), random.randint(1, 5)])\\n\\nprint(json.dumps(operations))\\nprint(json.dumps(args))\\n```\\n\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This question is deadly if you are oblivious enough  to the  explanation"
                    },
                    {
                        "username": "Shuvadeep_saha",
                        "content": "As per my understanding, the problem considers a node to be descendant of itself (at least this is when all the test cases pass). So when a node (that the user is trying to upgrade to) is locked this would also imply that at least one of its descendants are locked. Then how are all the three conditions in the `upgrade()` function satisfied? The fist condition `the node is unlocked` becomes void. Any suggestions anyone?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "DFS for ascendant check, BFS for descendant check\\nA little bit boring"
                    },
                    {
                        "username": "DeathNote",
                        "content": "I dont quite understand parentList, is it n-th child node map to value of parent\\'s node ?... quite confused."
                    },
                    {
                        "username": "sk4142",
                        "content": "For test case 1: parentList = [-1,0,0,1,1,2,2]. At i = 3, parent[3] = 1. This means that 3\\'s parent is 1. "
                    },
                    {
                        "username": "barnik_b",
                        "content": "\"You are given a tree with ```n``` nodes numbered from ```0``` to ```n - 1``` in the form of a parent array parent where parent[i] is the parent of the ith node.\"\n\nparent[i] indicates there is an edge from node ```i``` to ```parent[i]``` (aka node ```i's``` parent). That's why ```parent[0] = -1``` since the root node does not have a parent, Hope this clears your doubt."
                    }
                ]
            },
            {
                "id": 1981697,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "pls note tree is not necessary binary as in example"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Here are some test cases if you need:\\n\\n```\\n[\"LockingTree\", \"lock\", \"unlock\", \"lock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"upgrade\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"upgrade\", \"lock\"]\\n[[[-1, 0, 0, 2, 2, 3, 5, 0, 2, 0, 1, 7, 3, 8, 8, 0, 9, 4, 5, 5]], [4, 8], [3, 2], [0, 4], [9, 9], [0, 3], [0, 7], [5, 9], [4, 9], [0, 4], [5, 6], [4, 5], [4, 1], [5, 4], [2, 7], [9, 9], [2, 7], [2, 2], [1, 1], [8, 6]]\\n\\n[\"LockingTree\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"upgrade\", \"lock\", \"upgrade\", \"unlock\", \"unlock\", \"upgrade\", \"upgrade\", \"unlock\", \"lock\"]\\n[[[-1, 0, 0, 0, 3, 4, 5, 5, 3, 5, 6, 10, 2, 0, 0, 10, 14, 6, 2, 18]], [2, 3], [1, 3], [2, 3], [2, 3], [1, 3], [1, 3], [1, 3], [2, 3], [0, 1], [3, 3], [1, 1], [2, 2], [0, 1], [0, 3], [1, 2], [2, 2], [2, 3], [3, 1], [1, 3]] \\n```\\n\\nPython code to generate test cases\\n\\n```\\nparentLength = 2000\\noperationLength = 2000\\nparents = [-1]\\nfor i in range(1, parentLength):\\n    parents.append(random.randint(0, i-1))\\n\\noperations = [\"LockingTree\"]\\nfor i in range(1, operationLength):\\n    operations.append(random.choice([\"lock\", \"unlock\", \"upgrade\"]))\\n\\nargs = [[parents]]\\nfor i in range(1, operationLength):\\n    args.append([random.randint(0, 5), random.randint(1, 5)])\\n\\nprint(json.dumps(operations))\\nprint(json.dumps(args))\\n```\\n\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This question is deadly if you are oblivious enough  to the  explanation"
                    },
                    {
                        "username": "Shuvadeep_saha",
                        "content": "As per my understanding, the problem considers a node to be descendant of itself (at least this is when all the test cases pass). So when a node (that the user is trying to upgrade to) is locked this would also imply that at least one of its descendants are locked. Then how are all the three conditions in the `upgrade()` function satisfied? The fist condition `the node is unlocked` becomes void. Any suggestions anyone?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "DFS for ascendant check, BFS for descendant check\\nA little bit boring"
                    },
                    {
                        "username": "DeathNote",
                        "content": "I dont quite understand parentList, is it n-th child node map to value of parent\\'s node ?... quite confused."
                    },
                    {
                        "username": "sk4142",
                        "content": "For test case 1: parentList = [-1,0,0,1,1,2,2]. At i = 3, parent[3] = 1. This means that 3\\'s parent is 1. "
                    },
                    {
                        "username": "barnik_b",
                        "content": "\"You are given a tree with ```n``` nodes numbered from ```0``` to ```n - 1``` in the form of a parent array parent where parent[i] is the parent of the ith node.\"\n\nparent[i] indicates there is an edge from node ```i``` to ```parent[i]``` (aka node ```i's``` parent). That's why ```parent[0] = -1``` since the root node does not have a parent, Hope this clears your doubt."
                    }
                ]
            },
            {
                "id": 1941817,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "pls note tree is not necessary binary as in example"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Here are some test cases if you need:\\n\\n```\\n[\"LockingTree\", \"lock\", \"unlock\", \"lock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"upgrade\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"upgrade\", \"lock\"]\\n[[[-1, 0, 0, 2, 2, 3, 5, 0, 2, 0, 1, 7, 3, 8, 8, 0, 9, 4, 5, 5]], [4, 8], [3, 2], [0, 4], [9, 9], [0, 3], [0, 7], [5, 9], [4, 9], [0, 4], [5, 6], [4, 5], [4, 1], [5, 4], [2, 7], [9, 9], [2, 7], [2, 2], [1, 1], [8, 6]]\\n\\n[\"LockingTree\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"upgrade\", \"lock\", \"upgrade\", \"unlock\", \"unlock\", \"upgrade\", \"upgrade\", \"unlock\", \"lock\"]\\n[[[-1, 0, 0, 0, 3, 4, 5, 5, 3, 5, 6, 10, 2, 0, 0, 10, 14, 6, 2, 18]], [2, 3], [1, 3], [2, 3], [2, 3], [1, 3], [1, 3], [1, 3], [2, 3], [0, 1], [3, 3], [1, 1], [2, 2], [0, 1], [0, 3], [1, 2], [2, 2], [2, 3], [3, 1], [1, 3]] \\n```\\n\\nPython code to generate test cases\\n\\n```\\nparentLength = 2000\\noperationLength = 2000\\nparents = [-1]\\nfor i in range(1, parentLength):\\n    parents.append(random.randint(0, i-1))\\n\\noperations = [\"LockingTree\"]\\nfor i in range(1, operationLength):\\n    operations.append(random.choice([\"lock\", \"unlock\", \"upgrade\"]))\\n\\nargs = [[parents]]\\nfor i in range(1, operationLength):\\n    args.append([random.randint(0, 5), random.randint(1, 5)])\\n\\nprint(json.dumps(operations))\\nprint(json.dumps(args))\\n```\\n\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This question is deadly if you are oblivious enough  to the  explanation"
                    },
                    {
                        "username": "Shuvadeep_saha",
                        "content": "As per my understanding, the problem considers a node to be descendant of itself (at least this is when all the test cases pass). So when a node (that the user is trying to upgrade to) is locked this would also imply that at least one of its descendants are locked. Then how are all the three conditions in the `upgrade()` function satisfied? The fist condition `the node is unlocked` becomes void. Any suggestions anyone?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "DFS for ascendant check, BFS for descendant check\\nA little bit boring"
                    },
                    {
                        "username": "DeathNote",
                        "content": "I dont quite understand parentList, is it n-th child node map to value of parent\\'s node ?... quite confused."
                    },
                    {
                        "username": "sk4142",
                        "content": "For test case 1: parentList = [-1,0,0,1,1,2,2]. At i = 3, parent[3] = 1. This means that 3\\'s parent is 1. "
                    },
                    {
                        "username": "barnik_b",
                        "content": "\"You are given a tree with ```n``` nodes numbered from ```0``` to ```n - 1``` in the form of a parent array parent where parent[i] is the parent of the ith node.\"\n\nparent[i] indicates there is an edge from node ```i``` to ```parent[i]``` (aka node ```i's``` parent). That's why ```parent[0] = -1``` since the root node does not have a parent, Hope this clears your doubt."
                    }
                ]
            }
        ]
    }
]