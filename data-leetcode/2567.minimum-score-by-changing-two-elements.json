[
    {
        "title": "Minimum Score by Changing Two Elements",
        "question_content": "You are given a 0-indexed integer array nums.\n\n\tThe low score of nums is the minimum value of |nums[i]&nbsp;- nums[j]| over all 0 <= i < j < nums.length.\n\tThe high score of&nbsp;nums is the maximum value of |nums[i]&nbsp;- nums[j]| over all 0 <= i < j < nums.length.\n\tThe score of nums is the sum of the high and low scores of nums.\n\nTo minimize the score of nums, we can change the value of at most two elements of nums.\nReturn the minimum possible score after changing&nbsp;the value of at most two elements of nums.\nNote that |x| denotes the absolute value of x.\n&nbsp;\nExample 1:\n\nInput: nums = [1,4,3]\nOutput: 0\nExplanation: Change value of nums[1] and nums[2] to 1 so that nums becomes [1,1,1]. Now, the value of |nums[i] - nums[j]| is always equal to 0, so we return 0 + 0 = 0.\n\nExample 2:\n\nInput: nums = [1,4,7,8,5]\nOutput: 3\nExplanation: Change nums[0] and nums[1] to be 6. Now nums becomes [6,6,7,8,5].\nOur low score is achieved when i = 0 and j = 1, in which case |nums[i] - nums[j]| = |6 - 6| = 0.\nOur high score is achieved when i = 3 and j = 4, in which case |nums[i] - nums[j]| = |8 - 5| = 3.\nThe sum of our high and low score is 3, which we can prove to be minimal.\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3201904,
                "title": "explained-two-solutions-with-without-sorting-very-simple-easy-to-understand",
                "content": "Up Vote if you like the solution \\n\\n# Approach\\n\\nFirst of all we can simply replace two numbers with the same value, that results in the lowest difference to zero in all cases.\\nSo now the problem statement becomes, high (max difference) should be lowest. \\nSo to achieve this, we need to decrease the difference between the smallest and largest value. This further can be achieved by doing one out of these three cases :\\n1. remove the smallest two numbers\\n2. remove the largest two numbers\\n3. remove the smallest and largest\\n\\nso considering above three cases we have to take the minimum value possible.\\n\\nNote: I have written remove the smallest/largest number, this means => changing the smallest/largest number to any other number in the array.\\n\\nTo find smallest two and largest two number we can simply sort the array and we will have the value. Another way can be just keep track of two smallest and two largest values in the array which can be done easily using priority queue or just by tracking smallest three and largest three variables.\\n \\n\\n# Solution 1 : with Sorting\\n```\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int case1 = nums.back() - nums[2];\\n        int case2 = nums[nums.size() - 3] - nums[0];\\n        int case3 = nums[nums.size() - 2] - nums[1];\\n        return min({case1, case2, case3});\\n    }\\n```\\n\\n# Solution 2: with out sorting\\n```\\n/*\\nAfter sorting the order of the variables are as follows :\\ns1, s2, s3 ......... l3, l2, l1\\ns1 is smallest & l1 is largest.\\n*/\\n\\n    int minimizeSum(vector<int>& nums) {\\n        int s1 = INT_MAX, s2 = INT_MAX, s3 = INT_MAX, l1 = 0, l2 = 0, l3 = 0;\\n        for(auto n: nums){\\n            if(s1 > n) { s3 = s2; s2 = s1; s1 = n; }\\n            else if(s2 > n) { s3 = s2; s2 = n; }\\n            else if(s3 > n) { s3 = n; }\\n\\n            if(l1 < n) { l3 = l2; l2  = l1; l1 = n; }\\n            else if(l2 < n ) { l3 = l2; l2 = n; }\\n            else if(l3 < n ) { l3 = n; }\\n        }\\n        return min({l1 - s3, l3 - s1, l2 - s2});\\n    }\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int case1 = nums.back() - nums[2];\\n        int case2 = nums[nums.size() - 3] - nums[0];\\n        int case3 = nums[nums.size() - 2] - nums[1];\\n        return min({case1, case2, case3});\\n    }\\n```\n```\\n/*\\nAfter sorting the order of the variables are as follows :\\ns1, s2, s3 ......... l3, l2, l1\\ns1 is smallest & l1 is largest.\\n*/\\n\\n    int minimizeSum(vector<int>& nums) {\\n        int s1 = INT_MAX, s2 = INT_MAX, s3 = INT_MAX, l1 = 0, l2 = 0, l3 = 0;\\n        for(auto n: nums){\\n            if(s1 > n) { s3 = s2; s2 = s1; s1 = n; }\\n            else if(s2 > n) { s3 = s2; s2 = n; }\\n            else if(s3 > n) { s3 = n; }\\n\\n            if(l1 < n) { l3 = l2; l2  = l1; l1 = n; }\\n            else if(l2 < n ) { l3 = l2; l2 = n; }\\n            else if(l3 < n ) { l3 = n; }\\n        }\\n        return min({l1 - s3, l3 - s1, l2 - s2});\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202969,
                "title": "simple-diagram-explanation",
                "content": "# Idea\\n- Sort `nums` so that we can easily access maximum and minimum values\\n- We will always make the low score $$0$$ by creating duplicate values\\n- Now we have changed the question to finding the minimum maximum value difference by changing two values\\n- We have three options:\\n    - Change the two largest values to the third largest value. Third largest value now becomes the max value.\\n    - Change the two smallest values to the third smallest value. Third smallest value now becomes the min value.\\n    - Change largest value to second largest value and smallest value to second smallest value. Second largest becomes max value and second smallest becomes min value.\\n- It must be one of these three options because we have to create duplicates to satisfy the low score constraint and the high score always deals with difference between maximum and minimum.\\n\\n\\n# Example\\n\\n- Let us use `nums = [1,4,7,8,5]`\\n\\n![1.jfif](https://assets.leetcode.com/users/images/cd239624-970e-4050-b0d4-d691e9a1fdc8_1676750417.0719316.jpeg)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return min(nums[n-1]-nums[2], min(nums[n-2]-nums[1], nums[n-3]-nums[0]));\\n    }\\n};\\n```\\n- Notice from the code that we do not actually need to change the values, we just need to compare the elements of interest by the three options.\\n#### If this helped please leave an upvote. Thanks!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return min(nums[n-1]-nums[2], min(nums[n-2]-nums[1], nums[n-3]-nums[0]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202016,
                "title": "java-c-python-change-biggest-or-smallest",
                "content": "# **Intuition**\\nChange the biggest or the smallest,\\nto be other existing number.\\n<br>\\n\\n# **Explanation**\\nChange two biggest,\\nthen the high score is `A[n-3] - A[0]`\\n\\nChange the biggest and the smallest,\\nthen the high score is `A[n-2] - A[1]`\\n\\nChange two smallest,\\nthen the high score is `A[n-1] - A[2]`\\n\\nFor the low score,\\nwe can always have 2 same numbers,\\nso low score is 0.\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n\\nAlso we can one pass,\\nand find out the 3 biggest and 3 smallest in `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimizeSum(int[] A) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        return Math.min(Math.min(A[n - 1] - A[2], A[n - 3] - A[0]), A[n - 2] - A[1]);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimizeSum(vector<int>& A) {\\n        int n = A.size();\\n        sort(A.begin(), A.end());\\n        return min({A[n - 1] - A[2], A[n - 3] - A[0], A[n - 2] - A[1]});\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimizeSum(self, A):\\n        A.sort()\\n        return min(A[-1] - A[2], A[-2] - A[1], A[-3] - A[0])\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimizeSum(int[] A) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        return Math.min(Math.min(A[n - 1] - A[2], A[n - 3] - A[0]), A[n - 2] - A[1]);\\n    }\\n```\n```cpp\\n    int minimizeSum(vector<int>& A) {\\n        int n = A.size();\\n        sort(A.begin(), A.end());\\n        return min({A[n - 1] - A[2], A[n - 3] - A[0], A[n - 2] - A[1]});\\n    }\\n```\n```py\\n    def minimizeSum(self, A):\\n        A.sort()\\n        return min(A[-1] - A[2], A[-2] - A[1], A[-3] - A[0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3201949,
                "title": "c-python-short-and-easy-to-understand-with-sorting",
                "content": "# Intuition\\nWe see that we have to sort the array to easily find **low** score and **high** score\\n\\n# Approach\\nAfter sorting the array, we have 3 ways to optimize this problem:\\n- Increase `nums[0], nums[1] equal to nums[2]`, now `low=0`,  `high=nums[n-1]-nums[2]`\\n- Reduce `nums[n-1], nums[n-2] equal to nums[n-3]`, now `low=0`, `high=nums[n-3]-nums[0]`\\n- Increase `nums[0] equal to nums[1]`, `nums[n-1] equal to nums[n-2]`, now `low=0`, `high=nums[n-2]-nums[1]`\\n\\nSo we just need to choose the smallest **high** score\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n# Code\\n## C++\\n```C++\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int> &nums) {\\n        std::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return min({nums[n - 1] - nums[2], nums[n - 3] - nums[0], nums[n - 2] - nums[1]});\\n    }\\n};\\n```\\n## Python\\n```python\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[-1] - nums[2], nums[-3] - nums[0], nums[-2] - nums[1])\\n```\\n\\t\\t",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int> &nums) {\\n        std::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return min({nums[n - 1] - nums[2], nums[n - 3] - nums[0], nums[n - 2] - nums[1]});\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[-1] - nums[2], nums[-3] - nums[0], nums[-2] - nums[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202126,
                "title": "3-step-logic-video-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nhttps://youtu.be/pBJgRVQEDPE\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int x = arr[n-3]-arr[0];\\n        int y = arr[n-1]-arr[2];\\n        int z = arr[n-2]-arr[1];\\n        \\n        return min({x, y, z});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int x = arr[n-3]-arr[0];\\n        int y = arr[n-1]-arr[2];\\n        int z = arr[n-2]-arr[1];\\n        \\n        return min({x, y, z});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202070,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\n```cpp\\n// the idea is to change two numbers to an existing number \\n// so that the low score will be always 0.\\n// to minimize the high score, we can either choose \\n// - 2 biggest numbers\\n// - 2 smallest numbers, or \\n// - 1 biggest and 1 smallest\\n// we just take the min of them\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        return min({\\n            // choose the biggest 2\\n\\t\\t\\t// now nums[n - 3] becomes the biggest\\n\\t\\t\\t// and nums[0] is still the smallest\\n            abs(nums[n - 3] - nums[0]),\\n            // choose the smallest & the biggest\\n\\t\\t\\t// now nums[n - 2] becomes the biggest\\n\\t\\t\\t// and nums[1] becomes the smallest\\n            abs(nums[n - 2] - nums[1]), \\n            // choose the smallest 2\\n\\t\\t\\t// now nums[n - 1] is still the biggest\\n\\t\\t\\t// and nums[2] becomes the smallest\\n            abs(nums[n - 1] - nums[2])\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```cpp\\n// the idea is to change two numbers to an existing number \\n// so that the low score will be always 0.\\n// to minimize the high score, we can either choose \\n// - 2 biggest numbers\\n// - 2 smallest numbers, or \\n// - 1 biggest and 1 smallest\\n// we just take the min of them\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        return min({\\n            // choose the biggest 2\\n\\t\\t\\t// now nums[n - 3] becomes the biggest\\n\\t\\t\\t// and nums[0] is still the smallest\\n            abs(nums[n - 3] - nums[0]),\\n            // choose the smallest & the biggest\\n\\t\\t\\t// now nums[n - 2] becomes the biggest\\n\\t\\t\\t// and nums[1] becomes the smallest\\n            abs(nums[n - 2] - nums[1]), \\n            // choose the smallest 2\\n\\t\\t\\t// now nums[n - 1] is still the biggest\\n\\t\\t\\t// and nums[2] becomes the smallest\\n            abs(nums[n - 1] - nums[2])\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201855,
                "title": "o-n",
                "content": "We can always make the low score zero. Therefore, we should focus on reducing the high score.\\n\\nFor that, we can either remove two smallest, one smallest and one largest, or two largest elements.\\n\\nWe use partial sort to find two largest and two smallest elements, so that the time complexity is O(n).\\n\\n**C++**\\n```cpp\\nint minimizeSum(vector<int>& n) {\\n    partial_sort(begin(n), begin(n) + 3, end(n));\\n    partial_sort(rbegin(n), rbegin(n) + 3, rend(n) - 3, greater{});\\n    return min({ n[n.size() - 3] - n[0],\\n                 n[n.size() - 2] - n[1], \\n                 n[n.size() - 1] - n[2] });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minimizeSum(vector<int>& n) {\\n    partial_sort(begin(n), begin(n) + 3, end(n));\\n    partial_sort(rbegin(n), rbegin(n) + 3, rend(n) - 3, greater{});\\n    return min({ n[n.size() - 3] - n[0],\\n                 n[n.size() - 2] - n[1], \\n                 n[n.size() - 1] - n[2] });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3201956,
                "title": "sorting-three-cases-only",
                "content": "# Approach\\n* Sort the array\\n* There can be three cases: \\n    \\n1) pick first two and make them third                **Example:-[1,2,8,9,11]**\\n2) pick last two and make it third last element            **Example:- [1,2,3,9,11]**\\n3) pick first and last and make them second and second last element      **Example:- [1,4,5,7,8]**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        \\n        int n=nums.size();\\n        sort(begin(nums),end(nums));\\n        \\n        int ans1=abs(nums[n-1]-nums[2]);\\n        int ans2=abs(nums[1]-nums[n-2]);\\n        int ans3=abs(nums[0]-nums[n-3]);\\n        \\n        return min(ans1,min(ans2,ans3));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        \\n        int n=nums.size();\\n        sort(begin(nums),end(nums));\\n        \\n        int ans1=abs(nums[n-1]-nums[2]);\\n        int ans2=abs(nums[1]-nums[n-2]);\\n        int ans3=abs(nums[0]-nums[n-3]);\\n        \\n        return min(ans1,min(ans2,ans3));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202505,
                "title": "video-solution-with-sorting-easy-to-understand-c",
                "content": "# Video Solution\\nhttps://youtu.be/B3iSW6gKXXk\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int ans = min(  min( nums[n-1] - nums[2] , nums[n-3] - nums[0] ) , nums[n-2] - nums[1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int ans = min(  min( nums[n-1] - nums[2] , nums[n-3] - nums[0] ) , nums[n-2] - nums[1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202036,
                "title": "python-2-line-solution-w-explanation",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis question reduces to minimizing the range of `nums` by changing 2 elements in `nums`. We can minimize the range by doing one of 3 options:\\n1. Increase the smallest two numbers. Therefore, the range in this option will be `largest - third smallest`.\\n2. Increase the smallest number and decrease the largest number. Therefore, the range in this option will be `second largest - second smallest`.\\n3. Decrease the largest two numbers. Therefore, the range in this option will be `third largest - smallest`.\\n\\nWe return the minimum of these three options to find the minimum score possible.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[-1]-nums[2],nums[-2]-nums[1],nums[-3]-nums[0])     \\n```\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[-1]-nums[2],nums[-2]-nums[1],nums[-3]-nums[0])     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201915,
                "title": "simple-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int a=nums[nums.length-1]-nums[0];\\n        int b=nums[nums.length-1]-nums[2];\\n        int c=nums[nums.length-3]-nums[0];\\n        int d=nums[nums.length-2]-nums[1];\\n        return Math.min(a,Math.min(b,Math.min(c,d)));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int a=nums[nums.length-1]-nums[0];\\n        int b=nums[nums.length-1]-nums[2];\\n        int c=nums[nums.length-3]-nums[0];\\n        int d=nums[nums.length-2]-nums[1];\\n        return Math.min(a,Math.min(b,Math.min(c,d)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202055,
                "title": "sorting-two-liner-easy-understandable-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>&v) {\\n        int i,n=v.size();\\n        sort(v.begin(),v.end());\\n        return min({v[n-1]-v[2],v[n-3]-v[0],v[n-2]-v[1]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>&v) {\\n        int i,n=v.size();\\n        sort(v.begin(),v.end());\\n        return min({v[n-1]-v[2],v[n-3]-v[0],v[n-2]-v[1]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581613,
                "title": "o-n-tc-o-1-sc-100-beats-most-efficient-approach-c-solution",
                "content": "# Intuition\\nThere Is No Need Of Sorting Here , By the Observation Of Some Random Test Cases i got know that, we just need to keep track first 3 minimum elements and first 3 maximum elements . then apply the appropriate conditions to get the answer.\\n# Approach\\n**1 Condition**\\nConsider the array : [1,4,5,6,7,8]\\nNow the optimal solution in this case is changing \\nchanging 1 , 4 to 5\\nNow the array becomes [5,5,5,6,7,8].\\nNow the answer is |5-5 | + | 8-5 | =3.\\nif you observe carefully the answer is simply the difference between \\nfirst maximum element and the third minimum element.\\n**2 Condition**\\nConsider the array : [8,28,42,58,75]\\nNow the optimal solution in this case is changing \\nchanging 8  to 42 and 75 to 42\\nNow the array becomes [42,28,42,58,42].\\nNow the answer is |42-42 | + |58 - 28 | =30.\\nif you observe carefully the answer is simply the difference between \\nsecond maximum element and the second minimum element.\\n**3 Condition**\\nConsider the array : [9,27,33,59,81]\\nNow the optimal solution in this case is changing \\nchanging  51  to 33 and 81 to 33\\nNow the array becomes [9,27,33,33,33].\\nNow the answer is |33-33 | + |33 - 9 | =24.\\nif you observe carefully the answer is simply the difference between \\nthird maximum element and the first minimum element.\\n\\nSO THE ANSWER LIES ON THESE THREE CONDITIONS ONLY , SO FIND FIRST 3 MINIMUM ELEMENT AND FIRST 3 MAXIMUM ELEMENTS  THEN RETURN THE RESULT.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n       int min1=1e9,min2=1e9,min3=1e9,maxi1=0,maxi2=0,maxi3=0;\\n       for(auto i:nums)\\n       {\\n           if(i<min1){  min3=min2;min2=min1;min1=i; }\\n           else if(i<min2) { min3=min2, min2=i;}\\n           else if(i<min3) min3=i;\\n           if(i>maxi1) { maxi3=maxi2,maxi2=maxi1 ,maxi1=i;}\\n           else if(i>maxi2) {maxi3=maxi2,maxi2=i;}\\n           else if(i>maxi3) maxi3=i;\\n       }\\n      return min(maxi1-min3,min(abs(maxi2-min2),maxi3-min1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n       int min1=1e9,min2=1e9,min3=1e9,maxi1=0,maxi2=0,maxi3=0;\\n       for(auto i:nums)\\n       {\\n           if(i<min1){  min3=min2;min2=min1;min1=i; }\\n           else if(i<min2) { min3=min2, min2=i;}\\n           else if(i<min3) min3=i;\\n           if(i>maxi1) { maxi3=maxi2,maxi2=maxi1 ,maxi1=i;}\\n           else if(i>maxi2) {maxi3=maxi2,maxi2=i;}\\n           else if(i>maxi3) maxi3=i;\\n       }\\n      return min(maxi1-min3,min(abs(maxi2-min2),maxi3-min1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202690,
                "title": "easy-peasy-c-code-o-n-logn-time-complexity-o-1-space-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(n logn) for sorting the vector\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& a) {\\n        int n = a.size();\\n        if(n==3){\\n            return 0;\\n        }\\n        sort(a.begin(),a.end());\\n        int one = a[n-1] - a[2];\\n        int two = a[n-3] - a[0];\\n        int three = a[n-2] - a[1];\\n        return min({one,two,three});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& a) {\\n        int n = a.size();\\n        if(n==3){\\n            return 0;\\n        }\\n        sort(a.begin(),a.end());\\n        int one = a[n-1] - a[2];\\n        int two = a[n-3] - a[0];\\n        int three = a[n-2] - a[1];\\n        return min({one,two,three});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201879,
                "title": "simple-c-easiest-solution-with-3-cases",
                "content": "# Intuition\\nSort the vector to focus mainly on minimum and maximum values.\\nFind the cases where we can minimize the score\\nMinimum diff can always be made 0 by making two elements equal.\\nTo minimize the maximum diff there can be\\nthree cases possible:\\n1. First and last element can be made equal to its adjacent value. So, the max diff becomes v[v.size()-2]-v[1] (bcuz we make v[0]=v[1] & v[v.size()-1]=v[v.size()-2])\\n2. First 2 elements can be made equal to 3rd elemnt.So, the max diff becomes v[v.size()-1]-v[2] (bcuz we make v[0]=v[1]=v[2])\\n3. Last 2 elements can be made equal to last but 3rd element. So, the max diff becomes v[v.size()-3]-v[0] (bcuz we make v[v.size()-1]=v[v.size()-2]=v[v.size()-3])\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n/*\\n1st case score: v[v.size()-2]-v[1]+0\\n2st case score: v[v.size()-1]-v[2]+0\\n3st case score: v[v.size()-3]-v[0]+0\\n*/\\n        return min(min(v[v.size()-2]-v[1] ,v[v.size()-1]-v[2]),v[v.size()-3]-v[0]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n/*\\n1st case score: v[v.size()-2]-v[1]+0\\n2st case score: v[v.size()-1]-v[2]+0\\n3st case score: v[v.size()-3]-v[0]+0\\n*/\\n        return min(min(v[v.size()-2]-v[1] ,v[v.size()-1]-v[2]),v[v.size()-3]-v[0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208433,
                "title": "python-3-2-lines-w-a-terse-explanation-t-m-83-100",
                "content": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n\\n        nums.sort()\\n\\n        return min(nums[-1] - nums[2],  #  [a,b,c, ..., x,y,z] => [c,c,c, ..., x,y,z]\\n                   nums[-2] - nums[1],  #  [a,b,c, ..., x,y,z] => [b,b,c, ..., x,y,y] \\n                   nums[-3] - nums[0])  #  [a,b,c, ..., x,y,z] => [a,b,c, ..., x,x,x]\\n\\n                                        #  Return  min((z-c)+(c-c), (x-a)+(x-x), (y-b)+(b-b))\\n```\\n[https://leetcode.com/problems/minimum-score-by-changing-two-elements/submissions/901346564/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*NlogN*) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n\\n        nums.sort()\\n\\n        return min(nums[-1] - nums[2],  #  [a,b,c, ..., x,y,z] => [c,c,c, ..., x,y,z]\\n                   nums[-2] - nums[1],  #  [a,b,c, ..., x,y,z] => [b,b,c, ..., x,y,y] \\n                   nums[-3] - nums[0])  #  [a,b,c, ..., x,y,z] => [a,b,c, ..., x,x,x]\\n\\n                                        #  Return  min((z-c)+(c-c), (x-a)+(x-x), (y-b)+(b-b))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202790,
                "title": "simplest-java-solution-with-time-and-space-complexity-explaination",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first checks if the **length of the input array is 3**, and if so, **returns 0.** This is because, in this case, *all elements in the array can be made equal by replacing any two elements with the third element, and hence, the sum of differences will be 0.*\\nThen, the code sorts the input array using the Arrays.sort() method, which sorts the elements of the array in ascending order.\\n\\nAfter sorting, the code calculates three possible values for the minimized sum of absolute differences, by removing any two elements and replacing them with any element from the remaining elements in the array:\\n\\n- A : **removing the first two elements of the sorted array** and replacing them with any element in the middle of the array, and then calculating the absolute difference between the maximum element and the minimum element in the resulting array.\\n- B : **removing the last two elements of the sorted array** and replacing them with any element in the middle of the array, and then calculating the absolute difference between the maximum element and the minimum element in the resulting array.\\n- C : **removing the first and last elements of the sorted array** and replacing them with any element in the middle of the array, and then calculating the absolute difference between the maximum element and the minimum element in the resulting array.\\n\\nFinally, the code returns the minimum value of a, b, and c using the Math.min() method. This value represents the minimized sum of absolute differences between all pairs of elements in the input array that can be achieved by removing any two elements and replacing them with any element from the remaining elements in the array.\\n\\n# Complexity\\n- ***Time complexity:***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is ***O(nlogn)***, where n is the length of the input array nums.\\n\\nThis is because the code first *sorts the input array* using Arrays.sort(nums), which has a time complexity of O(nlogn) for an array of length n.\\n\\nThen, the code calculates three possible values for the minimized sum of absolute differences by performing some simple arithmetic operations, which take constant time.\\n\\nFinally, the code returns the minimum value of the three possible values using the Math.min() method, which also takes constant time.\\n\\nTherefore, ***the overall time complexity of this code is dominated by the time complexity of sorting the input array, which is O(nlogn).***\\n\\n- ***Space complexity:***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**The space complexity of this code is O(1)**, which means that it uses a constant amount of extra space regardless of the size of the input array nums.\\n\\nThe only extra space used in this code are the integer **variables a, b, and c,** which store the three possible values of the minimized sum of absolute differences. These variables take a **constant amount of space** and do not depend on the size of the input array.\\n\\nIn addition, the Arrays.sort(nums) method sorts the input array in-place, without creating a new array, so it does not increase the space complexity of the code.\\n\\n***Therefore, the space complexity of this code is O(1).***\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        \\n        //because you can make any two elements equal to the third element and hence the array will have all elements equal and so the diffrence will be 0 for all pairs\\n        \\n        if(nums.length==3){\\n            return 0;\\n        }\\n        \\n        Arrays.sort(nums);\\n        \\n        //remove first two i.e replacing first two elements with any element in between the array\\n        int a=nums[nums.length-1]-nums[2];\\n        \\n        //remove last two i.e replacing last two elements with any element in between the array\\n        int b=nums[nums.length-3]-nums[0];\\n        \\n        //remove last and first i.e replacing first and last elements with any element in between the array\\n        int c=nums[nums.length-2]-nums[1];\\n        \\n        return Math.min(a,Math.min(b,c));\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        \\n        //because you can make any two elements equal to the third element and hence the array will have all elements equal and so the diffrence will be 0 for all pairs\\n        \\n        if(nums.length==3){\\n            return 0;\\n        }\\n        \\n        Arrays.sort(nums);\\n        \\n        //remove first two i.e replacing first two elements with any element in between the array\\n        int a=nums[nums.length-1]-nums[2];\\n        \\n        //remove last two i.e replacing last two elements with any element in between the array\\n        int b=nums[nums.length-3]-nums[0];\\n        \\n        //remove last and first i.e replacing first and last elements with any element in between the array\\n        int c=nums[nums.length-2]-nums[1];\\n        \\n        return Math.min(a,Math.min(b,c));\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202090,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[-2] - nums[1],\\n                   nums[-1] - nums[2],\\n                   nums[-3] - nums[0])\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[-2] - nums[1],\\n                   nums[-1] - nums[2],\\n                   nums[-3] - nums[0])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202033,
                "title": "c-2-liner-code",
                "content": "Self-explanatory\\nOnly three windows are possible to minimze\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        return min({nums[n-3]-nums[0],nums[n-2]-nums[1],nums[n-1]-nums[2]});\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        return min({nums[n-3]-nums[0],nums[n-2]-nums[1],nums[n-1]-nums[2]});\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541555,
                "title": "using-sort-c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        return min({v[v.size()-3]-v[0],v[v.size()-2]-v[1],v[v.size()-1]-v[2]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        return min({v[v.size()-3]-v[0],v[v.size()-2]-v[1],v[v.size()-1]-v[2]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207689,
                "title": "javascript-solution",
                "content": "# Intuition\\nThe answer will be in one of 3 cases. We set Max and second Max elements to third Max. We set Min and second Min elements to third Min element. We set Max to second Max and Min to second Min.\\n\\n# Approach\\nTo simplify the code we sort the array. The answer will be the following Math.min(nums[end-2]-nums[0], nums[end-1]-nums[1], nums[end]-nums[2])\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimizeSum = function(nums) { \\n    let arr = nums.sort((a,b) => a - b);\\n    let end = nums.length -1;\\n    \\n    return Math.min(nums[end-2]-nums[0], nums[end-1]-nums[1], nums[end]-nums[2]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimizeSum = function(nums) { \\n    let arr = nums.sort((a,b) => a - b);\\n    let end = nums.length -1;\\n    \\n    return Math.min(nums[end-2]-nums[0], nums[end-1]-nums[1], nums[end]-nums[2]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204058,
                "title": "one-line-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return min({nums[nums.size()-1]-nums[2],nums[nums.size()-3]-nums[0],nums[nums.size()-2]-nums[1]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return min({nums[nums.size()-1]-nums[2],nums[nums.size()-3]-nums[0],nums[nums.size()-2]-nums[1]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202588,
                "title": "easiest-c-solution-5-line-code-very-easy",
                "content": "# Intuition\\nThere can only be 3 cases, either \\n- Change the first 2 elements\\n- We change the last 2 elements\\n- We change the 1st and the last element\\n\\n# Approach\\nWe sort the given array, then we can calculate all the 3 cases just by considering the difference between the mentioned values.\\nAlso, we don\\'t need a seperate calculation for \\'low\\', since we will always replace the choosen values with the same values.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nint minimizeSum(vector<int>& v) {\\n        int ans=INT_MAX;\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n        ans=min(ans,v[n-1]-v[2]);\\n        ans=min(ans,v[n-3]-v[0]);\\n        ans=min(ans,v[n-2]-v[1]);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minimizeSum(vector<int>& v) {\\n        int ans=INT_MAX;\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n        ans=min(ans,v[n-1]-v[2]);\\n        ans=min(ans,v[n-3]-v[0]);\\n        ans=min(ans,v[n-2]-v[1]);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3201867,
                "title": "c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n\\n        sort(nums.begin(), nums.end());\\n        int n= nums.size();\\n        \\n        int val  = min  (abs(nums[0] - nums[n-3]) , min( abs(nums[n-2]-nums[1]), abs(nums[2] - nums[n-1] ) ) );\\n        return  val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n\\n        sort(nums.begin(), nums.end());\\n        int n= nums.size();\\n        \\n        int val  = min  (abs(nums[0] - nums[n-3]) , min( abs(nums[n-2]-nums[1]), abs(nums[2] - nums[n-1] ) ) );\\n        return  val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201858,
                "title": "java-2-3-lines-sorting",
                "content": "**Observations**\\nIf two numbers are equal, low is 0. We\\'ll use this to remove `low` from consideration \\nThere are three possibilities to minimize score:\\n1. Set least two elements as third least\\n2. Set greatest two elements as third greatest\\n3. Set least to second least and greatest to second greatest\\n\\n```\\nclass Solution\\n{\\n    public int minimizeSum(int[] nums)\\n    {\\n        Arrays.sort(nums);\\n        return Math.min(Math.min(nums[nums.length-1]-nums[2],nums[nums.length-3]-nums[0]),nums[nums.length-2] - nums[1]);\\n    }\\n}\\n```\\nReadable:\\n```\\nclass Solution\\n{\\n    public int minimizeSum(int[] nums)\\n    {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        return Math.min(Math.min(nums[n-1]-nums[2] , nums[n-3]-nums[0]), nums[n-2] - nums[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int minimizeSum(int[] nums)\\n    {\\n        Arrays.sort(nums);\\n        return Math.min(Math.min(nums[nums.length-1]-nums[2],nums[nums.length-3]-nums[0]),nums[nums.length-2] - nums[1]);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int minimizeSum(int[] nums)\\n    {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        return Math.min(Math.min(nums[n-1]-nums[2] , nums[n-3]-nums[0]), nums[n-2] - nums[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478667,
                "title": "beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int case1=nums[n-3]-nums[0];//change two of largest to the third largest\\n        int case2=nums[n-1]-nums[2];//change two of smallest to the third smallest\\n        int case3=nums[n-2]-nums[1];//change the smallest to next smallest and greatest to prev greatest \\n        return min(case1,min(case2,case3));\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int case1=nums[n-3]-nums[0];//change two of largest to the third largest\\n        int case2=nums[n-1]-nums[2];//change two of smallest to the third smallest\\n        int case3=nums[n-2]-nums[1];//change the smallest to next smallest and greatest to prev greatest \\n        return min(case1,min(case2,case3));\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206400,
                "title": "c-intuitive-approach",
                "content": "# Intuition\\nTo get minimum score either we need to make smallest element as larget or largest element as smallest in the array.\\n\\n# Approach\\nWe have three cases by which we can get minimum score\\n## Case-1:\\nWe can make first two elements as maximum element.\\n**Example-**\\n[1,4,7,8,5]\\n[1,4,5,7,8] (sorted)\\n[8,8,5,7,8] (applied case-1)\\nScore = (8-5)-(8-8) = 3\\n\\n## Case-2:\\nWe can make last two elements as minimum element.\\n**Example-**\\n[1,4,3]\\n[1,3,4] (sorted)\\n[1,1,1]\\nScore = (1-1)-(1-1)=0\\n\\n## Case-3:\\nWe can make 1st and last position element as 2nd minimum element or 2nd maximum element.\\n**Example-**\\n[58,42,8,75,28]\\n[8,28,42,58,75] (sorted)\\n[28,28,42,58,28]\\nScore = (58-28)-(28-28)=30\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        //case-1 make first two elements as maximum element \\n        int high1 = nums[n-1] - nums[2]; \\n        \\n        //case-2 make last two elements  as minimum element\\n        int high2 = nums[n-3] - nums[0];\\n        \\n        //case-3 make 1st and last position element as 2nd minimum element or 2nd maximum element\\n        int high3 = nums[n-2] - nums[1];\\n        \\n        return min({high1, high2, high3});        \\n    }\\n};\\n```\\n\\n# Please upvote if you like this approach",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        //case-1 make first two elements as maximum element \\n        int high1 = nums[n-1] - nums[2]; \\n        \\n        //case-2 make last two elements  as minimum element\\n        int high2 = nums[n-3] - nums[0];\\n        \\n        //case-3 make 1st and last position element as 2nd minimum element or 2nd maximum element\\n        int high3 = nums[n-2] - nums[1];\\n        \\n        return min({high1, high2, high3});        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205563,
                "title": "python-short-and-clean-beats-100-2-solutions-sorting-and-heap",
                "content": "# Approach 1: Sort\\n1. Sort `nums` to `s_nums` for random access to maxes and mins.\\n\\n2. If there were `0` changes allowed:\\n    There\\'s nothing to do.\\n    The best we can do is: `s_nums[n - 1] - s_nums[0]`.\\n    \\n    Note: Abbriviating `s_num[a] - s_num[b]` as `|a, b|` from henceforth.\\n    Hence the above becomes `|n - 1, 0|`\\n\\n3. If there were `1` change allowed:\\n    We can change the first or the last number to the adjacent one.\\n    The best we can do is:\\n    `min(|n - 1, 1| (changing the first), |n - 2, 0| (changing the last)`.\\n\\n4. If there were `2` change allowed:\\n    The best we can do is:\\n    `min(|n - 1, 2|, |n - 2, 1|, |n - 3, 0|)`\\n\\n5. Extending the same, If there were `k` changes allowed:\\n    The best we can do is:\\n    `min(|n - 1, k|, |n - 2, k - 1|, ...., |n - k - 1, 0|)`\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minimizeSum(self, nums: list[int]) -> int:\\n        s_nums = sorted(nums)\\n        k = 2\\n        return min(\\n            s_nums[i] - s_nums[j]\\n            for i, j in zip(range(-1, -k - 2, -1), range(k, -1, -1))\\n        )\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: Heap\\nSince we only need first `k` minimum and first `k` maximum elements in `nums`, given atmost `k` changes allowed, we can use a `min heap` and `max heap` respectively.\\n\\nThis allows to reduce the time complexity from $$n + n * log(n)$$ to $$n + k * log(n)$$.\\n\\n# Complexity\\n- Time complexity: $$O(n + k * log(n))$$\\nFor given question, `k = 2`, `=>` $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`n is the length of nums`,\\n`k is the number of number of values that can be changed`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minimizeSum(self, nums: list[int]) -> int:\\n        k, n = 2, len(nums)\\n        min_hq, max_hq = list(nums), list(map(neg, nums))\\n        heapify(min_hq); heapify(max_hq)\\n\\n        maxs = tuple(-heappop(max_hq) for _ in range(min(k + 1, n)))\\n        mins = tuple( heappop(min_hq) for _ in range(min(k + 1, n)))\\n\\n        return min(map(sub, maxs, reversed(mins)))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizeSum(self, nums: list[int]) -> int:\\n        s_nums = sorted(nums)\\n        k = 2\\n        return min(\\n            s_nums[i] - s_nums[j]\\n            for i, j in zip(range(-1, -k - 2, -1), range(k, -1, -1))\\n        )\\n\\n\\n```\n```python\\nclass Solution:\\n    def minimizeSum(self, nums: list[int]) -> int:\\n        k, n = 2, len(nums)\\n        min_hq, max_hq = list(nums), list(map(neg, nums))\\n        heapify(min_hq); heapify(max_hq)\\n\\n        maxs = tuple(-heappop(max_hq) for _ in range(min(k + 1, n)))\\n        mins = tuple( heappop(min_hq) for _ in range(min(k + 1, n)))\\n\\n        return min(map(sub, maxs, reversed(mins)))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203067,
                "title": "greedy-kotlin-lambda-o-n-log-n",
                "content": "Consider the sorted scenario, where the index of the nums is\\n```0 1 2 3 4 .... n-3, n-2, n-1```\\nWe need to find the min value of\\n* `nums[n-1]` vs `nums[2]`\\n* `nums[n-2]` vs `nums[1]`\\n* `nums[n-3]` vs `nums[0]`\\nThe commonality is `n-1-2 = n-3`, `n-2-1 = n-3` and `n-3-0 = n-3`. So we write the following lambda to find the `nums[n-3+it]` vs `nums[it]`\\n\\n```kotlin\\nclass Solution {\\n  fun minimizeSum(nums: IntArray): Int {\\n    nums.sort()\\n    return (0 until 3).map {\\n      nums[nums.size - 3 + it] - nums[it]\\n    }.minOrNull()!!\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```0 1 2 3 4 .... n-3, n-2, n-1```\n```kotlin\\nclass Solution {\\n  fun minimizeSum(nums: IntArray): Int {\\n    nums.sort()\\n    return (0 until 3).map {\\n      nums[nums.size - 3 + it] - nums[it]\\n    }.minOrNull()!!\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202109,
                "title": "java-solution-with-detailed-explanation",
                "content": "# Intuition\\nSince we can change the value of atmost 2 elements, we are left with three choices, I will explain why these three choices only.\\n\\nWe know the max score we can achieve is by subtracting the min element from the max element.\\nNow we are given a condition that we can change atmost two values, and so we can reduce the min score to 0(always) by choosing any two numbers are setting them to same value, so the problem boils down to simply reduce the max score which is (arr[max_Index] - arr[min_Index])\\n\\nNow we have three choices:\\n\\nFirst: we decide to change the value of first two minimum elements of the array to the third one and then calculate the score.\\n\\nSecond: we decide to change the value of first two maxmium elements of the array to the third one and then calculate the score.\\n\\nThird: we decide to change the value of minimum element to 2nd minimum element and the value of first maximum element to 2nd maximum element and then we calculate score.\\n\\nThen we will return the min of all the three choices\\n\\nThe reason we did this was because we know that we need to minimize the maximum score, and the maimum score is nothing but the the difference between two extremes of the arrays, and by these three choices we tried to reduce this maximum difference.\\n\\nNow to find the required max and min values, we can also do this in linear-pass instead of sorting, but I\\'ll leave that as an exercise for you.\\n\\nDo Upvote!\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = nums[nums.length-3] - nums[0];\\n        min = Math.min(nums[nums.length-1] - nums[2], min);\\n        min = Math.min(nums[nums.length-2] - nums[1], min);\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = nums[nums.length-3] - nums[0];\\n        min = Math.min(nums[nums.length-1] - nums[2], min);\\n        min = Math.min(nums[nums.length-2] - nums[1], min);\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202083,
                "title": "c-2-line-easy-code",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return min({nums[n-1]-nums[2],nums[n-3]-nums[0],nums[n-2]-nums[1]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return min({nums[n-1]-nums[2],nums[n-3]-nums[0],nums[n-2]-nums[1]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201851,
                "title": "java-best-choice-from-three-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust sort the array and use greedy method.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**We can alwasy make lower score to 0 by keeping same number, so we can focus on high score.**\\n\\nTo get minimum high score, we should keep minimum of |hightest - lowerest| value.\\nWe have three cases:\\n1. Change `nums[0]` and `nums[1]` to `nums[2]`\\n2. Change `nums[0]` to `nums[1]` and `nums[n - 1]` to `nums[n - 2]`\\n3. Change `nums[n - 2]` and `nums[n - 1]` to `nums[n - 3]`\\n\\n# Complexity\\n- Time complexity: $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimizeSum(int[] nums) {\\n    final int n = nums.length;\\n    Arrays.sort(nums);\\n    // high score\\n    int high = Integer.MAX_VALUE;\\n    // left and right\\n    high = Math.min(high, nums[n - 2] - nums[1]);\\n\\n    // right and right\\n    high = Math.min(high, nums[n - 3] - nums[0]);\\n\\n    // left and left\\n    high = Math.min(high, nums[n - 1] - nums[2]);\\n\\n    return high;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n  public int minimizeSum(int[] nums) {\\n    final int n = nums.length;\\n    Arrays.sort(nums);\\n    // high score\\n    int high = Integer.MAX_VALUE;\\n    // left and right\\n    high = Math.min(high, nums[n - 2] - nums[1]);\\n\\n    // right and right\\n    high = Math.min(high, nums[n - 3] - nums[0]);\\n\\n    // left and left\\n    high = Math.min(high, nums[n - 1] - nums[2]);\\n\\n    return high;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872837,
                "title": "5-lines-code-dp-easy-c-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to **choose two numbers** from **minimum or maximum** but which two elements will we **choose**.........\\uD83E\\uDD14\\uD83E\\uDD14\\uD83E\\uDD14\\uD83E\\uDD14\\nHere I used **dp concept** to select two elements so as to **minimize the score sum**.\\n\\n# Complexity\\n- Time complexity:O(N * Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> arr,int i,int j,int k)\\n    {\\n         if(k>=2) return arr[j]-arr[i];\\n         return min(solve(arr,i+1,j,k+1),solve(arr,i,j-1,k+1));\\n    }\\n    int minimizeSum(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        if(arr.size()<=3) return 0;\\n        return solve(arr,0,arr.size()-1,0);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/897fffe7-61e0-4168-b721-02355350e7cc_1691338716.6880965.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> arr,int i,int j,int k)\\n    {\\n         if(k>=2) return arr[j]-arr[i];\\n         return min(solve(arr,i+1,j,k+1),solve(arr,i,j-1,k+1));\\n    }\\n    int minimizeSum(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        if(arr.size()<=3) return 0;\\n        return solve(arr,0,arr.size()-1,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373008,
                "title": "java-very-easy-solution",
                "content": "### Approach\\nSort the array in ascending order\\nThree Cases can occur-\\n1. Remove first two elements\\n2. Remove last two elements\\n3. Remove first and the last element\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int d1=(nums[nums.length-1]-nums[2]);\\n        int d2=(nums[nums.length-1-2]-nums[0]);\\n        int d3=(nums[nums.length-1-1]-nums[1]);\\n        return (int)(Math.min(d1,Math.min(d2,d3)));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int d1=(nums[nums.length-1]-nums[2]);\\n        int d2=(nums[nums.length-1-2]-nums[0]);\\n        int d3=(nums[nums.length-1-1]-nums[1]);\\n        return (int)(Math.min(d1,Math.min(d2,d3)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215900,
                "title": "sorting-approach-java-solution-clean-code",
                "content": "# Intuition\\nIf we make two elements equal then value of `low` will be `0`. Hence we can utilize both the two operations in minimizing the value of `high`\\n\\n# Approach\\n- Sort the array in acending order\\n- We can minimize the value of `high` using any of the following three operations:\\n    1. If we make `nums[0] = nums[n - 1]` & `nums[1] = nums[n - 1]` then `ans` will be `nums[n - 1] - nums[2]`\\n    2. If we make `nums[n - 1] = nums[0]` & `nums[n - 2] = nums[0]` then `ans` will be `nums[n - 3] - nums[0]`\\n    3. If we make `nums[0] = nums[1]` & `nums[n - 1] = nums[n - 2]` then `ans` will be `nums[n - 2] - nums[1]`\\n\\n- Take **minimum** of above three answers\\n\\n# Complexity\\n- Time complexity: $O(n * logn)$\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Math.min(nums[n - 1] - nums[2],nums[n - 3] - nums[0]);\\n        ans = Math.min(ans,nums[n - 2] - nums[1]);\\n        return ans;\\n    }\\n}\\n```\\n\\n# Upvote if you like it \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Math.min(nums[n - 1] - nums[2],nums[n - 3] - nums[0]);\\n        ans = Math.min(ans,nums[n - 2] - nums[1]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212713,
                "title": "2-lines-of-code-explaination",
                "content": "First we will sort the list so we can easily access minimum and maximum values.\\n\\nThere are total 3 ways in which we can get answer.\\n1. By changing First two values - In this case we will chage first two values to make difference zero. Now lowest value we have is nums[2] and largest is nums[-1].\\n2. By changing Last two values - In this case we will chage last two values to to make difference zero. Now lowest value we have is nums[0] and largest is nums[-3].\\n3. By changing Last value and First Values - In this case we will chage first value and last value to make difference zero. Now lowest value is nums[1] and largest is nums[-2].\\n\\nWe will select minimum from this three values.\\n\\n**Plot - We really dont need two change these values, we will calculate difference between values in which we are interested.**\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[-1] - nums[2], nums[-2] - nums[1], nums[-3] - nums[0])\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[-1] - nums[2], nums[-2] - nums[1], nums[-3] - nums[0])\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210755,
                "title": "sort-greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return min({nums[n - 3] - nums[0], nums[n - 1] - nums[2], nums[n - 2] - nums[1]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return min({nums[n - 3] - nums[0], nums[n - 1] - nums[2], nums[n - 2] - nums[1]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209195,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        // if(nums.size()==3){return 0;}\\n        // vector<int>v=nums;\\n        // int mini=*min_element(nums.begin(), nums.end()), k=2;\\n        // while(k--){\\n        //     int maxi=*max_element(nums.begin(), nums.end());\\n        //     for(int i=0; i<nums.size(); i++){\\n        //         if(nums[i]==maxi){nums[i]=mini;}\\n        //     }\\n        // }\\n        // int n1=*min_element(nums.begin(), nums.end()), n2=*max_element(nums.begin(), nums.end());\\n        // int k1=2, maxi1=*max_element(v.begin(), v.end());\\n        // cout<<maxi1<<endl;\\n        // while(k1--){\\n        //     int mini1=*min_element(v.begin(), v.end());\\n        //     for(int i=0; i<v.size(); i++){\\n        //         if(v[i]==mini1){v[i]=maxi1;}\\n        //     }\\n        // }\\n        // int nn1=*min_element(v.begin(), v.end()), nn2=*max_element(v.begin(), v.end());\\n        // cout<<nn2-nn1<<\" \"<<n2-n1<<endl;\\n        return min({nums[nums.size()-1]-nums[0], nums[nums.size()-2]-nums[1], nums[nums.size()-1]-nums[2], nums[nums.size()-3]-nums[0]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        // if(nums.size()==3){return 0;}\\n        // vector<int>v=nums;\\n        // int mini=*min_element(nums.begin(), nums.end()), k=2;\\n        // while(k--){\\n        //     int maxi=*max_element(nums.begin(), nums.end());\\n        //     for(int i=0; i<nums.size(); i++){\\n        //         if(nums[i]==maxi){nums[i]=mini;}\\n        //     }\\n        // }\\n        // int n1=*min_element(nums.begin(), nums.end()), n2=*max_element(nums.begin(), nums.end());\\n        // int k1=2, maxi1=*max_element(v.begin(), v.end());\\n        // cout<<maxi1<<endl;\\n        // while(k1--){\\n        //     int mini1=*min_element(v.begin(), v.end());\\n        //     for(int i=0; i<v.size(); i++){\\n        //         if(v[i]==mini1){v[i]=maxi1;}\\n        //     }\\n        // }\\n        // int nn1=*min_element(v.begin(), v.end()), nn2=*max_element(v.begin(), v.end());\\n        // cout<<nn2-nn1<<\" \"<<n2-n1<<endl;\\n        return min({nums[nums.size()-1]-nums[0], nums[nums.size()-2]-nums[1], nums[nums.size()-1]-nums[2], nums[nums.size()-3]-nums[0]});\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3204775,
                "title": "explanation-and-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we make two numbers equal, we can make the __low__ score equal to `0`. So only thing left is to find minimum __high__ score.\\nThe __high__ score will depend on the minimum and the maximum value in the array. So, we should either decrease the maximum values or increase the minimum values. There are __three__ posibilitites:\\n- We decrease the top two values to third highest value.\\n- We increase the bottom two value to third smallest value.\\n- We increase the bottom value to second smallest value and decrease the top value to second highest value.\\n\\nIn all the above cases, __low__ will be `0`.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 3) return 0;\\n        sort(nums.begin(), nums.end());\\n        return min(nums[n - 1] - nums[2], min(nums[n - 3] - nums[0], nums[n - 2] - nums[1]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 3) return 0;\\n        sort(nums.begin(), nums.end());\\n        return min(nums[n - 1] - nums[2], min(nums[n - 3] - nums[0], nums[n - 2] - nums[1]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202737,
                "title": "c-easy-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo Minimine our Ans We need to do two things :\\n1. Maximize the maximum difference of two numbers. \\n2. Minimize the minimum difference of two numbers.\\n\\nNow to minimize the difference of two number we can always minimze it to zero by changing one number to another number .\\nTo maximize the difference of two number we have three options :\\nA. Change last two number to first number .\\nB. Change first two number to last number .\\nC. Change first number to second number and last number to second last number .\\n\\n\\n# Complexity\\n- Time complexity: O(Log(n))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin() , nums.end());\\n        \\n        //Option A\\n        int op1 = nums[n-3] - nums[0];\\n        //Option B\\n        int op2 = nums[n-1] - nums[2];\\n        //Option C\\n        int op3 = nums[n-2] - nums[1];\\n        \\n        \\n        return min(op1 , min(op2, op3));\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin() , nums.end());\\n        \\n        //Option A\\n        int op1 = nums[n-3] - nums[0];\\n        //Option B\\n        int op2 = nums[n-1] - nums[2];\\n        //Option C\\n        int op3 = nums[n-2] - nums[1];\\n        \\n        \\n        return min(op1 , min(op2, op3));\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202647,
                "title": "c-most-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        //increase the smallest two numbers\\n        int a=nums[n-1]-nums[2];\\n        //decrease the two largest nos\\n        int b=nums[n-3]-nums[0];\\n        //increase the smallest no and decrease the largest no\\n        int c=nums[n-2]-nums[1];\\n        return min({a,b,c});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        //increase the smallest two numbers\\n        int a=nums[n-1]-nums[2];\\n        //decrease the two largest nos\\n        int b=nums[n-3]-nums[0];\\n        //increase the smallest no and decrease the largest no\\n        int c=nums[n-2]-nums[1];\\n        return min({a,b,c});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202593,
                "title": "python-solution-2-lines-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        n,_ = len(nums),nums.sort()\\n        return min([nums[n-1]-nums[0],nums[n-3]-nums[0],nums[n-1]-nums[2],nums[n-2]-nums[1]])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        n,_ = len(nums),nums.sort()\\n        return min([nums[n-1]-nums[0],nums[n-3]-nums[0],nums[n-1]-nums[2],nums[n-2]-nums[1]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202534,
                "title": "java-sorting-detailed-solution",
                "content": "# class Solution {\\n    public int minimizeSum(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        //Remove first and last elem\\n        int a=nums[n-2]-nums[1];\\n        //Remove first two elements\\n        int b=nums[n-1]-nums[2];\\n        //Remove last two elements\\n        int c=nums[n-3]-nums[0];\\n        //return minimum of all\\n        return Math.min(a,Math.min(b,c));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int minimizeSum(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        //Remove first and last elem\\n        int a=nums[n-2]-nums[1];\\n        //Remove first two elements\\n        int b=nums[n-1]-nums[2];\\n        //Remove last two elements\\n        int c=nums[n-3]-nums[0];\\n        //return minimum of all\\n        return Math.min(a,Math.min(b,c));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3202515,
                "title": "only-2-line-answer-easy-to-understand-both-line-explain-good",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have 3 case for 2 element remove\\n1. 2 minimum\\n2. 2 maximum\\n3. 1 minimum and 1 maximum\\n\\nfor all cases low always 0 \\nand high is (as a que maximum-minimum) after remove \\n2 element \\n\\n1. ```nums[nums.size()-1]-nums[2]```\\n2. ```nums[nums.size()-3]-nums[0]```\\n3. ```nums[nums.size()-2]-nums[1]```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->  \\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n       \\n       return min({nums[nums.size()-2]-nums[1],nums[nums.size()-1]-nums[2],nums[nums.size()-3]-nums[0]});\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```nums[nums.size()-1]-nums[2]```\n```nums[nums.size()-3]-nums[0]```\n```nums[nums.size()-2]-nums[1]```\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n       \\n       return min({nums[nums.size()-2]-nums[1],nums[nums.size()-1]-nums[2],nums[nums.size()-3]-nums[0]});\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202265,
                "title": "c-simple-4-line-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size()==3){\\n            return 0;\\n        }\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int ans1 = nums[n-3] - nums[0];\\n        int ans2 = nums[n-2] - nums[1];\\n        int ans3 = nums[n-1] - nums[2];\\n        return min(min(ans1,ans2),min(ans2,ans3));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size()==3){\\n            return 0;\\n        }\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int ans1 = nums[n-3] - nums[0];\\n        int ans2 = nums[n-2] - nums[1];\\n        int ans3 = nums[n-1] - nums[2];\\n        return min(min(ans1,ans2),min(ans2,ans3));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202184,
                "title": "100-acceptance-very-easy-approach-reducing-the-maximum-difference-in-interval",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& num) {\\n        if(num.size()==3){\\n            return 0;\\n        }\\n        sort(num.begin(),num.end());\\n        int n=num.size();\\n        int mini=min(num[n-1]-num[2],num[n-3]-num[0]);\\n        return min(mini,num[n-2]-num[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& num) {\\n        if(num.size()==3){\\n            return 0;\\n        }\\n        sort(num.begin(),num.end());\\n        int n=num.size();\\n        int mini=min(num[n-1]-num[2],num[n-3]-num[0]);\\n        return min(mini,num[n-2]-num[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201950,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int ref=nums[2];\\n        int high=nums[nums.length-1]-ref;\\n        int ref2=nums[nums.length-3];\\n        int high2=ref2-nums[0];\\n        \\n        int high3=nums[nums.length-2]-nums[1];\\n        return Math.min(Math.min(high,high2),high3);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int ref=nums[2];\\n        int high=nums[nums.length-1]-ref;\\n        int ref2=nums[nums.length-3];\\n        int high2=ref2-nums[0];\\n        \\n        int high3=nums[nums.length-2]-nums[1];\\n        return Math.min(Math.min(high,high2),high3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201894,
                "title": "think-about-corner-elements-after-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        return min({\\n           a.back() - a[2],\\n           a[size(a)-2] - a[1],\\n           a[size(a)-3] - a[0]\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        return min({\\n           a.back() - a[2],\\n           a[size(a)-2] - a[1],\\n           a[size(a)-3] - a[0]\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201884,
                "title": "3-liner-easy-c-code",
                "content": "Just check three cases\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        return min({nums[n-1]-nums[2], nums[n-3]-nums[0], nums[n-2]-nums[1]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        return min({nums[n-1]-nums[2], nums[n-3]-nums[0], nums[n-2]-nums[1]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201876,
                "title": "c-3-choices-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size()<=3) return 0;\\n        \\n        vector<int> first,middle;\\n        sort(nums.begin(),nums.end());\\n        first = nums;\\n        middle = nums;\\n        \\n        nums[0] = nums[2];\\n        nums[1] = nums[2];\\n        int ans1 = nums.back()-nums[0];\\n        \\n        first[first.size()-1] = first[0];\\n        first[first.size()-2] = first[0];\\n        sort(first.begin(),first.end());\\n        int ans2 = first.back()-first[0];\\n        \\n        \\n        middle[middle.size()-1] = middle[1];\\n        middle[0] = middle[1];\\n        sort(middle.begin(),middle.end());\\n        int ans3 = middle.back()-middle[0];\\n        \\n        \\n        return min(ans1,min(ans2,ans3));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size()<=3) return 0;\\n        \\n        vector<int> first,middle;\\n        sort(nums.begin(),nums.end());\\n        first = nums;\\n        middle = nums;\\n        \\n        nums[0] = nums[2];\\n        nums[1] = nums[2];\\n        int ans1 = nums.back()-nums[0];\\n        \\n        first[first.size()-1] = first[0];\\n        first[first.size()-2] = first[0];\\n        sort(first.begin(),first.end());\\n        int ans2 = first.back()-first[0];\\n        \\n        \\n        middle[middle.size()-1] = middle[1];\\n        middle[0] = middle[1];\\n        sort(middle.begin(),middle.end());\\n        int ans3 = middle.back()-middle[0];\\n        \\n        \\n        return min(ans1,min(ans2,ans3));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063188,
                "title": "easy-3-steps-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n    sort(nums.begin(),nums.end());\\n    int n = nums.size();\\n    int a = nums[n-3] - nums[0];\\n    int b = nums[n-1] - nums[2];\\n    int c = nums[n-2] - nums[1];\\n    return min(a,min(b,c));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n    sort(nums.begin(),nums.end());\\n    int n = nums.size();\\n    int a = nums[n-3] - nums[0];\\n    int b = nums[n-1] - nums[2];\\n    int c = nums[n-2] - nums[1];\\n    return min(a,min(b,c));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973268,
                "title": "c-simple-solution-using-sorting",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n       \\n        // nums[0] = nums[n-1], nums[1]=a[n-1]  for mx1\\n        int mx1 = abs(nums[n-1]-nums[2]);\\n\\n        // nums[n-2] = nums[0], nums[n-1]=nums[0]  for mx2\\n        int mx2 = abs(nums[n-3]-nums[0]);\\n        \\n        // nums[n-1] = nums[n-2], nums[0]=nums[1]  for mx3\\n        int mx3 = nums[n-2]-nums[1];\\n       \\n       // min is always 0.\\n\\n        return min(mx1, min(mx2, mx3));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n       \\n        // nums[0] = nums[n-1], nums[1]=a[n-1]  for mx1\\n        int mx1 = abs(nums[n-1]-nums[2]);\\n\\n        // nums[n-2] = nums[0], nums[n-1]=nums[0]  for mx2\\n        int mx2 = abs(nums[n-3]-nums[0]);\\n        \\n        // nums[n-1] = nums[n-2], nums[0]=nums[1]  for mx3\\n        int mx3 = nums[n-2]-nums[1];\\n       \\n       // min is always 0.\\n\\n        return min(mx1, min(mx2, mx3));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968207,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int a = nums[n-2]-nums[1];\\n        int b = nums[n-1]-nums[2];\\n        int c = nums[n-3]-nums[0];\\n        a = Math.min(a,b);\\n        return Math.min(a,c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int a = nums[n-2]-nums[1];\\n        int b = nums[n-1]-nums[2];\\n        int c = nums[n-3]-nums[0];\\n        a = Math.min(a,b);\\n        return Math.min(a,c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962916,
                "title": "golang-sorting-100-solution",
                "content": "# Code\\n```go\\nfunc minimizeSum(nums []int) int {\\n\\tsort.Ints(nums)\\n\\tdiff1 := nums[len(nums)-2] - nums[1]\\n\\tdiff2 := nums[len(nums)-1] - nums[2]\\n\\tdiff3 := nums[len(nums)-3] - nums[0]\\n\\treturn min(diff1, diff2, diff3)\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```go\\nfunc minimizeSum(nums []int) int {\\n\\tsort.Ints(nums)\\n\\tdiff1 := nums[len(nums)-2] - nums[1]\\n\\tdiff2 := nums[len(nums)-1] - nums[2]\\n\\tdiff3 := nums[len(nums)-3] - nums[0]\\n\\treturn min(diff1, diff2, diff3)\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911308,
                "title": "simple-c-solution-beats-97-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n\\n        if(nums.size()<=3) return 0;\\n        sort(nums.begin(), nums.end());\\n        int sol = nums[nums.size() - 1] - nums[2];\\n        int sol2 = nums[nums.size() - 2] - nums[1];\\n        int sol3 = nums[nums.size()-3] - nums[0];\\n        return min(min(sol, sol2), sol3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n\\n        if(nums.size()<=3) return 0;\\n        sort(nums.begin(), nums.end());\\n        int sol = nums[nums.size() - 1] - nums[2];\\n        int sol2 = nums[nums.size() - 2] - nums[1];\\n        int sol3 = nums[nums.size()-3] - nums[0];\\n        return min(min(sol, sol2), sol3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903004,
                "title": "c-only-three-cases-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int ans1 = abs(nums[2]-nums[n-1]);\\n        int ans2 = abs(nums[1]-nums[n-2]);\\n        int ans3 = abs(nums[0]-nums[n-3]);\\n        return min(ans1,min(ans2,ans3));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int ans1 = abs(nums[2]-nums[n-1]);\\n        int ans2 = abs(nums[1]-nums[n-2]);\\n        int ans3 = abs(nums[0]-nums[n-3]);\\n        return min(ans1,min(ans2,ans3));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752124,
                "title": "python3-following-the-hints",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        nums.sort()\\n        i = 0\\n        j = N-1\\n        return min(abs(nums[j]-nums[i+2]), abs(nums[j-1]-nums[i+1]), abs(nums[j-2]-nums[i]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        nums.sort()\\n        i = 0\\n        j = N-1\\n        return min(abs(nums[j]-nums[i+2]), abs(nums[j-1]-nums[i+1]), abs(nums[j-2]-nums[i]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749589,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n         Arrays.sort(nums);\\n        int n=nums.length-1;\\n        int d1=(nums[n]-nums[2]);\\n        int d2=(nums[n-2]-nums[0]);\\n        int d3=(nums[n-1]-nums[1]);\\n        return (int)(Math.min(d1,Math.min(d2,d3)));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n         Arrays.sort(nums);\\n        int n=nums.length-1;\\n        int d1=(nums[n]-nums[2]);\\n        int d2=(nums[n-2]-nums[0]);\\n        int d3=(nums[n-1]-nums[1]);\\n        return (int)(Math.min(d1,Math.min(d2,d3)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746516,
                "title": "easy-solution-sort-1-line-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        # there\\'s only 3 cases - replace 2 lowest wih a higher value, replace 2 highest with a lower value, replace 1 lower and 1 highest with higher/lower value\\n        return min(nums[-1] - nums[2], min(nums[-3] - nums[0], nums[-2] - nums[1]));\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        # there\\'s only 3 cases - replace 2 lowest wih a higher value, replace 2 highest with a lower value, replace 1 lower and 1 highest with higher/lower value\\n        return min(nums[-1] - nums[2], min(nums[-3] - nums[0], nums[-2] - nums[1]));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742546,
                "title": "sorting-compress-maximum-difference-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int first=nums[n-1]-nums[2];\\n        int second=nums[n-3]-nums[0];\\n        int third=nums[n-2]-nums[1];\\n\\n        return min(first,min(second,third));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int first=nums[n-1]-nums[2];\\n        int second=nums[n-3]-nums[0];\\n        int third=nums[n-2]-nums[1];\\n\\n        return min(first,min(second,third));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706061,
                "title": "golang-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(N Log N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nfunc minimizeSum(nums []int) int {\\n  sort.Ints(nums)\\n  n := len(nums)\\n  // Since we can only make at most 2 modifications\\n  // We either change the first two elements, last two elements\\n  // or the first and last element.\\n  res := nums[n-3] - nums[0]\\n  if nums[n-2] - nums[1] < res {\\n    res = nums[n-2] - nums[1]\\n  }\\n  if nums[n-1] - nums[2] < res {\\n    res = nums[n-1] - nums[2]\\n  }\\n  return res\\n}\\n\\nfunc abs(a int) int {\\n  if a < 0 {\\n    return -a\\n  }\\n  return a\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nfunc minimizeSum(nums []int) int {\\n  sort.Ints(nums)\\n  n := len(nums)\\n  // Since we can only make at most 2 modifications\\n  // We either change the first two elements, last two elements\\n  // or the first and last element.\\n  res := nums[n-3] - nums[0]\\n  if nums[n-2] - nums[1] < res {\\n    res = nums[n-2] - nums[1]\\n  }\\n  if nums[n-1] - nums[2] < res {\\n    res = nums[n-1] - nums[2]\\n  }\\n  return res\\n}\\n\\nfunc abs(a int) int {\\n  if a < 0 {\\n    return -a\\n  }\\n  return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695487,
                "title": "easy-short-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the vector .\\n2. Find the difference between -\\n    a. First and the third last element ( in this case we changed the last two elements to be same as any element in the vector).\\n\\n    b.Second and second last element(in this case we changed the first and last element)\\n\\n    c. 3rd and last element ( in this case we changed the first two elements)\\n\\nThis way we can get the maximum difference between two numbers after changing two values. \\nThe minimun difference will always be zero since we are always having alteast 3 numbers having the same value. \\n\\n3. Now find the minimun of all three values to get the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size() == 1 || nums.size() == 2 || nums.size() == 3) return 0;\\n        sort(nums.begin(),nums.end());\\n        \\n       int max1 =  nums[nums.size()-2] - nums[1];\\n       int max2 =  nums[nums.size()-3] - nums[0];\\n       int max3 =  nums[nums.size()-1] - nums[2];\\n\\n       int max4 = min(max1 , min(max2 , max3));\\n       return max4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size() == 1 || nums.size() == 2 || nums.size() == 3) return 0;\\n        sort(nums.begin(),nums.end());\\n        \\n       int max1 =  nums[nums.size()-2] - nums[1];\\n       int max2 =  nums[nums.size()-3] - nums[0];\\n       int max3 =  nums[nums.size()-1] - nums[2];\\n\\n       int max4 = min(max1 , min(max2 , max3));\\n       return max4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673112,
                "title": "ok",
                "content": "```\\nint minimizeSum(vector<int>& n)\\n{\\n\\tint m[]{INT_MAX, INT_MAX, INT_MAX}, M[3]{};\\n\\tfor(const auto & n : n)\\n\\t\\tm[2] = n<=m[0] ? exchange(m[1], exchange(m[0], n)) : n<=m[1] ? exchange(m[1], n) : n<m[2] ? n : m[2],\\n\\t\\tM[2] = n>=M[0] ? exchange(M[1], exchange(M[0], n)) : n>=M[1] ? exchange(M[1], n) : n>M[2] ? n : M[2];\\n\\treturn min({M[0]-m[2], M[1]-m[1], M[2]-m[0]});\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minimizeSum(vector<int>& n)\\n{\\n\\tint m[]{INT_MAX, INT_MAX, INT_MAX}, M[3]{};\\n\\tfor(const auto & n : n)\\n\\t\\tm[2] = n<=m[0] ? exchange(m[1], exchange(m[0], n)) : n<=m[1] ? exchange(m[1], n) : n<m[2] ? n : m[2],\\n\\t\\tM[2] = n>=M[0] ? exchange(M[1], exchange(M[0], n)) : n>=M[1] ? exchange(M[1], n) : n>M[2] ? n : M[2];\\n\\treturn min({M[0]-m[2], M[1]-m[1], M[2]-m[0]});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664094,
                "title": "3-line-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n(O(n logn))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) { \\n        \\n        int n = nums.length;\\n        Arrays.sort(nums);\\n       \\n        \\n        int ch1 = nums[n-1] - nums[2];  // change the value of 1st and 2nd ele to Max value, find max\\n        int ch2 = nums[n-3] - nums[0];  // change the value of last and 2nd last to Min value, find max\\n        int ch3 = nums[n-2]-nums[1];   // change the value of 1st and last ele to Max value, find max\\n        \\n        return  Math.min(ch1, Math.min(ch2,ch3));   // calculate min of 3 choice\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) { \\n        \\n        int n = nums.length;\\n        Arrays.sort(nums);\\n       \\n        \\n        int ch1 = nums[n-1] - nums[2];  // change the value of 1st and 2nd ele to Max value, find max\\n        int ch2 = nums[n-3] - nums[0];  // change the value of last and 2nd last to Min value, find max\\n        int ch3 = nums[n-2]-nums[1];   // change the value of 1st and last ele to Max value, find max\\n        \\n        return  Math.min(ch1, Math.min(ch2,ch3));   // calculate min of 3 choice\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657173,
                "title": "easy-c",
                "content": "We want the minimum of (min + high). So to make things easier, we first sort the array.\\nAlso, we are given that we can replace at most any two values. So let\\'s make cases here -\\n\\n1) we replace the first and the last values i.e. we replace nums[0] with nums[1] and nums[n-1] with nums[n-2] i.e. the difference = nums[n-2] - nums[1]\\n\\n2) we replace the first two values i.e. we replace nums[0] with nums[2] and nums[1] with nums[2] as well i.e. difference = nums[n-1] - nums[2]\\n\\n2) we replace the last two values i.e. we replace nums[n-1] with nums[n-3] and nums[n-2] with nums[n-3] as well i.e. difference = nums[n-3] - nums[0\\n\\nWe return the minimum of above.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        return min({nums[n-2] - nums[1], nums[n-1] - nums[2], nums[n-3] - nums[0]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        return min({nums[n-2] - nums[1], nums[n-1] - nums[2], nums[n-3] - nums[0]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624295,
                "title": "c-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        return min({nums[n-3]-nums[0],nums[n-2]-nums[1],nums[n-1]-nums[2]});  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        return min({nums[n-3]-nums[0],nums[n-2]-nums[1],nums[n-1]-nums[2]});  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561185,
                "title": "c-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> v=nums;\\n        int n=nums.size();\\n        nums[0]=nums[1];\\n        nums[n-1]=nums[n-2];\\n        int m= nums[n-1]-nums[0];\\n\\n        nums=v;\\n        nums[0]=nums[n-1];\\n        nums[1]=nums[0];\\n         sort(nums.begin(),nums.end());\\n         m=min(m,nums[n-1]-nums[0]);\\n\\n         nums=v;\\n        nums[n-1]=nums[0];\\n        nums[n-2]=nums[0];\\n         sort(nums.begin(),nums.end());\\n         m=min(m,nums[n-1]-nums[0]);\\n\\n      return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> v=nums;\\n        int n=nums.size();\\n        nums[0]=nums[1];\\n        nums[n-1]=nums[n-2];\\n        int m= nums[n-1]-nums[0];\\n\\n        nums=v;\\n        nums[0]=nums[n-1];\\n        nums[1]=nums[0];\\n         sort(nums.begin(),nums.end());\\n         m=min(m,nums[n-1]-nums[0]);\\n\\n         nums=v;\\n        nums[n-1]=nums[0];\\n        nums[n-2]=nums[0];\\n         sort(nums.begin(),nums.end());\\n         m=min(m,nums[n-1]-nums[0]);\\n\\n      return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535485,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        Array.Sort(nums);\\n        return Math.Min(nums[^3] - nums[0], Math.Min(nums[^1] - nums[2], nums[^2] - nums[1]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        Array.Sort(nums);\\n        return Math.Min(nums[^3] - nums[0], Math.Min(nums[^1] - nums[2], nums[^2] - nums[1]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507712,
                "title": "two-liner-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[:-2][-1]-nums[0],nums[-1]-nums[2:][0],nums[1:-1][-1]-nums[1:-1][0])\\n      \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Brainteaser",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[:-2][-1]-nums[0],nums[-1]-nums[2:][0],nums[1:-1][-1]-nums[1:-1][0])\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492666,
                "title": "c-solution-easy-to-understand-with-explanation",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N log N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        // minimize high // I make low is 0 because I conver element to equal another in array\\n        Array.Sort(nums);\\n        // convert first two element to third elment\\n        int case1 = nums[nums.Length - 1] - nums[2];\\n        // convert last two element to last third elment\\n        int case2 =  nums[nums.Length - 3] - nums[0];\\n        // convert first element to second & last to perivous one\\n        int case3 =  nums[nums.Length - 2] - nums[1];\\n        return Math.Min(Math.Min(case1,case2),case3);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        // minimize high // I make low is 0 because I conver element to equal another in array\\n        Array.Sort(nums);\\n        // convert first two element to third elment\\n        int case1 = nums[nums.Length - 1] - nums[2];\\n        // convert last two element to last third elment\\n        int case2 =  nums[nums.Length - 3] - nums[0];\\n        // convert first element to second & last to perivous one\\n        int case3 =  nums[nums.Length - 2] - nums[1];\\n        return Math.Min(Math.Min(case1,case2),case3);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438197,
                "title": "simple-o-n-solution-c-first-3-last-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& a) {\\n        int n = a.size();\\n        if(n==3){\\n            return 0;\\n        }\\n        sort(a.begin(),a.end());// can do wihtout sorting but would have to run an O(n) search 3 times\\n        int b = a[n-1] - a[2];\\n        int c = a[n-3] - a[0];\\n        int d = a[n-2] - a[1];\\n        return min(b,min(c,d));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& a) {\\n        int n = a.size();\\n        if(n==3){\\n            return 0;\\n        }\\n        sort(a.begin(),a.end());// can do wihtout sorting but would have to run an O(n) search 3 times\\n        int b = a[n-1] - a[2];\\n        int c = a[n-3] - a[0];\\n        int d = a[n-2] - a[1];\\n        return min(b,min(c,d));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437083,
                "title": "java-2ms-99-80-w-o-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        // Arrays.sort(nums);\\n        // return Math.min(nums[nums.length-3]-nums[0], \\n        //        Math.min(nums[nums.length-2]-nums[1],\\n        //                 nums[nums.length-1]-nums[2]));\\n        int inf = 1_000_000_001;\\n        int l1=inf, l2=inf, l3=inf;\\n        int h1=0, h2=0, h3=0;\\n\\n        for(int x:nums){\\n            if(x<l1){\\n                l3=l2; l2=l1; l1=x;\\n            }else if(x<l2){\\n                l3=l2; l2=x;\\n            }else if(x<l3){\\n                l3=x;\\n            }\\n\\n            if(x>h1){\\n                h3=h2; h2=h1; h1=x;\\n            }else if(x>h2){\\n                h3=h2; h2=x;\\n            }else if(x>h3){\\n                h3=x;\\n            }\\n        }\\n\\n        return Math.min(h3-l1, Math.min(h2-l2, h1-l3));\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        // Arrays.sort(nums);\\n        // return Math.min(nums[nums.length-3]-nums[0], \\n        //        Math.min(nums[nums.length-2]-nums[1],\\n        //                 nums[nums.length-1]-nums[2]));\\n        int inf = 1_000_000_001;\\n        int l1=inf, l2=inf, l3=inf;\\n        int h1=0, h2=0, h3=0;\\n\\n        for(int x:nums){\\n            if(x<l1){\\n                l3=l2; l2=l1; l1=x;\\n            }else if(x<l2){\\n                l3=l2; l2=x;\\n            }else if(x<l3){\\n                l3=x;\\n            }\\n\\n            if(x>h1){\\n                h3=h2; h2=h1; h1=x;\\n            }else if(x>h2){\\n                h3=h2; h2=x;\\n            }else if(x>h3){\\n                h3=x;\\n            }\\n        }\\n\\n        return Math.min(h3-l1, Math.min(h2-l2, h1-l3));\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408642,
                "title": "c-greedy",
                "content": "# Intuition\\nChange 2 smallest, 2 largest or smallest and largest and then return the minimum sum among the three.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& num,int& ans)\\n    {\\n        int maxi = INT_MIN,mini = INT_MAX;\\n        int n = num.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            maxi = max(maxi,abs(num[i]-num[i-1]));\\n            mini = min(mini,abs(num[i]-num[i-1]));\\n        }\\n        maxi = max(maxi,abs(num[0]-num[n-1]));\\n        mini = min(mini,abs(num[0]-num[n-1]));\\n        ans = mini+maxi;\\n    }\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int> num1(n);\\n        vector<int> num2(n);\\n        vector<int> num3(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            num1[i] = nums[i];\\n            num2[i] = nums[i];\\n            num3[i] = nums[i];\\n        }\\n        int ans1 = 0,ans2 = 0,ans3 = 0;\\n        num1[0] = num1[1] = num1[2];\\n        num2[n-1] = num2[n-2] = num2[n-3];\\n        num3[0] = num3[1];\\n        num3[n-1] = num3[0];\\n        solve(num1,ans1);\\n        solve(num2,ans2);\\n        solve(num3,ans3);\\n        return min({ans1,ans2,ans3});\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& num,int& ans)\\n    {\\n        int maxi = INT_MIN,mini = INT_MAX;\\n        int n = num.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            maxi = max(maxi,abs(num[i]-num[i-1]));\\n            mini = min(mini,abs(num[i]-num[i-1]));\\n        }\\n        maxi = max(maxi,abs(num[0]-num[n-1]));\\n        mini = min(mini,abs(num[0]-num[n-1]));\\n        ans = mini+maxi;\\n    }\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int> num1(n);\\n        vector<int> num2(n);\\n        vector<int> num3(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            num1[i] = nums[i];\\n            num2[i] = nums[i];\\n            num3[i] = nums[i];\\n        }\\n        int ans1 = 0,ans2 = 0,ans3 = 0;\\n        num1[0] = num1[1] = num1[2];\\n        num2[n-1] = num2[n-2] = num2[n-3];\\n        num3[0] = num3[1];\\n        num3[n-1] = num3[0];\\n        solve(num1,ans1);\\n        solve(num2,ans2);\\n        solve(num3,ans3);\\n        return min({ans1,ans2,ans3});\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379854,
                "title": "simple-solution-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        int n = nums.size();\\n\\n        int arr[3];\\n\\n        arr[0] = nums[n-1] - nums[2];\\n        arr[1] = nums[n-2] - nums[1];\\n        arr[2] = nums[n-3] - nums[0];\\n\\n        sort(arr,arr+3);\\n\\n        return arr[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        int n = nums.size();\\n\\n        int arr[3];\\n\\n        arr[0] = nums[n-1] - nums[2];\\n        arr[1] = nums[n-2] - nums[1];\\n        arr[2] = nums[n-3] - nums[0];\\n\\n        sort(arr,arr+3);\\n\\n        return arr[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354647,
                "title": "c-esay-two-approch-o-nlongn-o-n",
                "content": "\\n```\\n/*\\n\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size()<4) return 0;\\n        int n=nums.size();int ans =0;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        return min({nums[n-3]-nums[0] ,nums[n-2]-nums[1], nums[n-1]-nums[2]});\\n\\n        \\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size()<4) return 0;\\n        int n=nums.size();\\n\\n        partial_sort(nums.begin(),nums.begin()+3,nums.end());\\n        \\n       partial_sort(rbegin(nums), rbegin(nums) + 3, rend(nums) - 3, greater{});\\n\\n        return min({nums[n-3]-nums[0] ,nums[n-2]-nums[1], nums[n-1]-nums[2]});\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size()<4) return 0;\\n        int n=nums.size();int ans =0;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        return min({nums[n-3]-nums[0] ,nums[n-2]-nums[1], nums[n-1]-nums[2]});\\n\\n        \\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size()<4) return 0;\\n        int n=nums.size();\\n\\n        partial_sort(nums.begin(),nums.begin()+3,nums.end());\\n        \\n       partial_sort(rbegin(nums), rbegin(nums) + 3, rend(nums) - 3, greater{});\\n\\n        return min({nums[n-3]-nums[0] ,nums[n-2]-nums[1], nums[n-1]-nums[2]});\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349237,
                "title": "minimum-score-by-changing-two-elements-easy-code-sort-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n      Arrays.sort(nums);\\n      int n = nums.length;\\n      int x = Math.min(nums[n-1]-nums[2],nums[n-3]-nums[0]);\\n      return Math.min(x,nums[n-2]-nums[1]);  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n      Arrays.sort(nums);\\n      int n = nums.length;\\n      int x = Math.min(nums[n-1]-nums[2],nums[n-3]-nums[0]);\\n      return Math.min(x,nums[n-2]-nums[1]);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339651,
                "title": "eassy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=nums[n-1]-nums[2];\\n        ans=min(ans,nums[n-2]-nums[1]);\\n        ans=min(ans,nums[n-3]-nums[0]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=nums[n-1]-nums[2];\\n        ans=min(ans,nums[n-2]-nums[1]);\\n        ans=min(ans,nums[n-3]-nums[0]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326235,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=nums[n-1]-nums[2];\\n        ans=min(ans,nums[n-2]-nums[1]);\\n        ans=min(ans,nums[n-3]-nums[0]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=nums[n-1]-nums[2];\\n        ans=min(ans,nums[n-2]-nums[1]);\\n        ans=min(ans,nums[n-3]-nums[0]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310911,
                "title": "most-easy-solution-of-minimum-score-by-changing-two-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n      sort(nums.begin(), nums.end());\\n      int n = nums.size();\\n\\n      cout << nums[n-2]-nums[1] << \" \" << nums[n-1]-nums[2] << \" \" << nums[n-3]-nums[0] << endl;\\n\\n      return min(nums[n-2]-nums[1], min(nums[n-1]-nums[2], nums[n-3]-nums[0]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n      sort(nums.begin(), nums.end());\\n      int n = nums.size();\\n\\n      cout << nums[n-2]-nums[1] << \" \" << nums[n-1]-nums[2] << \" \" << nums[n-3]-nums[0] << endl;\\n\\n      return min(nums[n-2]-nums[1], min(nums[n-1]-nums[2], nums[n-3]-nums[0]));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3300424,
                "title": "direct-approach-java-a",
                "content": "# Intuition\\nFirst & Last 2 elements only comes to play\\n\\n# Approach\\nDirect mathematical\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        //Atleast 4 elements required to get more than 1 as sum\\n        if(nums.length <= 3)\\n          return 0;\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        //Only 3 ways are possible to get the minimum sum as \\n        //The solution is limited to max 2 changes \\n        int val1 = nums[len-1] - nums[2];\\n        int val2 = nums[len-3] - nums[0];\\n        int val3 = nums[len-2] - nums[1];\\n        int res = val1 < val2 ? val1 : val2;\\n        res = res < val3 ? res : val3;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        //Atleast 4 elements required to get more than 1 as sum\\n        if(nums.length <= 3)\\n          return 0;\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        //Only 3 ways are possible to get the minimum sum as \\n        //The solution is limited to max 2 changes \\n        int val1 = nums[len-1] - nums[2];\\n        int val2 = nums[len-3] - nums[0];\\n        int val3 = nums[len-2] - nums[1];\\n        int res = val1 < val2 ? val1 : val2;\\n        res = res < val3 ? res : val3;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296941,
                "title": "easy-simple-solution-c-3-line-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        return min(nums[n-2]-nums[1], min(nums[n-1]-nums[2], nums[n-3]-nums[0]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        return min(nums[n-2]-nums[1], min(nums[n-1]-nums[2], nums[n-3]-nums[0]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296876,
                "title": "math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        left = nums[-1] - nums[2]\\n        right = nums[-3] - nums[0]\\n        mid = nums[-2] - nums[1]\\n        return min(left, min(mid, right))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        left = nums[-1] - nums[2]\\n        right = nums[-3] - nums[0]\\n        mid = nums[-2] - nums[1]\\n        return min(left, min(mid, right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289399,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size()-1;\\n        int ans=abs(nums[1]-nums[n-1]);\\n        ans=min(ans,abs(nums[0]-nums[n-2]));\\n        ans=min(ans,abs(nums[2]-nums[n]));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size()-1;\\n        int ans=abs(nums[1]-nums[n-1]);\\n        ans=min(ans,abs(nums[0]-nums[n-2]));\\n        ans=min(ans,abs(nums[2]-nums[n]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284973,
                "title": "n-log-n-easy-and-explained-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust sort the vector and after that from the vector take 3 element from lst  and 3 element from the start and and take one int_max;\\nso that we can store the small no as it is given we have to return smallest possible score so after that take last element and take 3rd from the start check check it with int_max;\\nafter that take both start 2nd and lst 2nd do the same after that check lst 3rd and start 1st abd again check we are doing it because we only can change 2 element so by doing it we can change and get the minimum score \\nbecause we can just \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:n(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int m=INT_MAX;\\n        int n=nums.size()-1;\\n        int h=nums[n]-nums[2];\\n        if(h<m){\\n            m=h;\\n        }\\n        int g=nums[n-1]-nums[1];\\n        if(g<m){\\n            m=g;\\n        }\\n        int k=nums[n-2]-nums[0];\\n        if(k<m){\\n            m=k;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int m=INT_MAX;\\n        int n=nums.size()-1;\\n        int h=nums[n]-nums[2];\\n        if(h<m){\\n            m=h;\\n        }\\n        int g=nums[n-1]-nums[1];\\n        if(g<m){\\n            m=g;\\n        }\\n        int k=nums[n-2]-nums[0];\\n        if(k<m){\\n            m=k;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240452,
                "title": "sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOption 1.First element can me made as max as second smallest element and last element can me made smaller as much as second last element. So their diff will be max;\\nOption 2.First two elements can be made greater than third smallest element then diff b/w greatest and third smallest will be max;\\noption 3.last two elements can be made smaller than thir greatest element then the diff b/w samllest and third greatest element will be maximum .\\nAnswer will be minimum of above three options;\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n    int n=nums.size();\\n    if(n==3) return 0;// if size is 3 then all elements can be made equal and difference will be 0\\n    sort(nums.begin(),nums.end());\\n    return min(abs(nums[1]-nums[n-2]),min(abs(nums[2]-nums[n-1]),abs(nums[0]-nums[n-3])));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n    int n=nums.size();\\n    if(n==3) return 0;// if size is 3 then all elements can be made equal and difference will be 0\\n    sort(nums.begin(),nums.end());\\n    return min(abs(nums[1]-nums[n-2]),min(abs(nums[2]-nums[n-1]),abs(nums[0]-nums[n-3])));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240293,
                "title": "java-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimizeSum(int[] nums) {\\n    Arrays.sort(nums);\\n    int n = nums.length - 1;\\n    return Math.min(nums[n-1] - nums[1], Math.min(nums[n] - nums[2], nums[n-2] - nums[0]));      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minimizeSum(int[] nums) {\\n    Arrays.sort(nums);\\n    int n = nums.length - 1;\\n    return Math.min(nums[n-1] - nums[1], Math.min(nums[n] - nums[2], nums[n-2] - nums[0]));      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237673,
                "title": "cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = abs(nums[1] - nums[nums.size()-2]);\\n        ans = min(ans, abs(nums[2] - nums[nums.size()-1]));\\n        ans = min(ans, abs(nums[0] - nums[nums.size()-3]));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = abs(nums[1] - nums[nums.size()-2]);\\n        ans = min(ans, abs(nums[2] - nums[nums.size()-1]));\\n        ans = min(ans, abs(nums[0] - nums[nums.size()-3]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236654,
                "title": "easy-3-liner-answer-only-3-cases-to-handle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your tim)e complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n    sort(nums.begin(),nums.end());\\n    return min(nums[n-1]-nums[2],min(nums[n-3]-nums[0],nums[n-2]-nums[1]));\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n    sort(nums.begin(),nums.end());\\n    return min(nums[n-1]-nums[2],min(nums[n-3]-nums[0],nums[n-2]-nums[1]));\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235513,
                "title": "simple-logic-and-sorting",
                "content": "We have only 3 options:\\n1. change the 2 smallest elements\\n2. change the 2 largest elements\\n3. change the largest and smallest element\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& a) {\\n        int n=a.size();\\n        if(n<4)\\n            return 0;\\n        \\n        sort(a.begin(),a.end());\\n        // 3 options \\n        // 1. change a[0], a[1]\\n        \\n        int cd=a[n-1]-a[2];\\n        \\n        // 2. change a[n-1],a[n-2]\\n        cd=min(cd,a[n-3]-a[0]);\\n        \\n        // 3. change a[n-1],a[0]\\n        cd=min(cd,a[n-2]-a[1]);\\n        \\n        return cd;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& a) {\\n        int n=a.size();\\n        if(n<4)\\n            return 0;\\n        \\n        sort(a.begin(),a.end());\\n        // 3 options \\n        // 1. change a[0], a[1]\\n        \\n        int cd=a[n-1]-a[2];\\n        \\n        // 2. change a[n-1],a[n-2]\\n        cd=min(cd,a[n-3]-a[0]);\\n        \\n        // 3. change a[n-1],a[0]\\n        cd=min(cd,a[n-2]-a[1]);\\n        \\n        return cd;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232655,
                "title": "python-solution-o-nlogn-tc-sort-and-compare-based",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(\\n            abs(nums[-1] - nums[2]),\\n            abs(nums[-3] - nums[0]),\\n            abs(nums[-2] - nums[1])\\n        )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(\\n            abs(nums[-1] - nums[2]),\\n            abs(nums[-3] - nums[0]),\\n            abs(nums[-2] - nums[1])\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230202,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func minimizeSum(_ nums: [Int]) -> Int {\\n        [nums.sorted()].map{zip($0,$0[($0.count-3)...]).map{$0.1-$0.0}.min()!}[0]\\n    }\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func minimizeSum(_ nums: [Int]) -> Int {\\n        [nums.sorted()] // wrap sorted array in array monad, so `map()` elements will be the entire array, not just elems.\\n        .map{ sortedArray in \\n            zip(sortedArray, sortedArray[(sortedArray.count-3)...]) // zip lowest three, and highest three elements\\n            .map{ zippedElems in  // map to array of scores (result size 3)\\n                 let (lowScore, highScore) = zippedElems\\n                 let score = highScore - lowScore\\n                 return score\\n            } \\n            .min()! // of the three scores, choose the lowest\\n        }\\n        .first! // unwrap monad (now minimum score)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizeSum(_ nums: [Int]) -> Int {\\n        [nums.sorted()].map{zip($0,$0[($0.count-3)...]).map{$0.1-$0.0}.min()!}[0]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minimizeSum(_ nums: [Int]) -> Int {\\n        [nums.sorted()] // wrap sorted array in array monad, so `map()` elements will be the entire array, not just elems.\\n        .map{ sortedArray in \\n            zip(sortedArray, sortedArray[(sortedArray.count-3)...]) // zip lowest three, and highest three elements\\n            .map{ zippedElems in  // map to array of scores (result size 3)\\n                 let (lowScore, highScore) = zippedElems\\n                 let score = highScore - lowScore\\n                 return score\\n            } \\n            .min()! // of the three scores, choose the lowest\\n        }\\n        .first! // unwrap monad (now minimum score)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230040,
                "title": "c-sort-and-3-cases",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        if (nums.Length == 3) return 0;\\n        Array.Sort(nums);\\n        //change 2 nums to same value: low = 0;\\n        //left 2 \\n        var left2 = (nums[nums.Length - 1] - nums[2]) + 0;\\n        //left 1 and right 1\\n        var leftRight = (nums[nums.Length - 2] - nums[1]) + 0;\\n        //right 2\\n        var right2 = (nums[nums.Length - 3] - nums[0]) + 0;\\n\\n        return Math.Min(Math.Min(left2, leftRight), right2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        if (nums.Length == 3) return 0;\\n        Array.Sort(nums);\\n        //change 2 nums to same value: low = 0;\\n        //left 2 \\n        var left2 = (nums[nums.Length - 1] - nums[2]) + 0;\\n        //left 1 and right 1\\n        var leftRight = (nums[nums.Length - 2] - nums[1]) + 0;\\n        //right 2\\n        var right2 = (nums[nums.Length - 3] - nums[0]) + 0;\\n\\n        return Math.Min(Math.Min(left2, leftRight), right2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229284,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        if(nums.Length <= 3){\\n            return 0;\\n        }\\n        Array.Sort(nums);\\n        int len = nums.Length;\\n        int num1 = Math.Abs(nums[len-1] - nums[2]);\\n        int num2 = Math.Abs(nums[len-2] - nums[1]);\\n        int num3 = Math.Abs(nums[len-3] - nums[0]);\\n        return Math.Min(num1, Math.Min(num2,num3));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        if(nums.Length <= 3){\\n            return 0;\\n        }\\n        Array.Sort(nums);\\n        int len = nums.Length;\\n        int num1 = Math.Abs(nums[len-1] - nums[2]);\\n        int num2 = Math.Abs(nums[len-2] - nums[1]);\\n        int num3 = Math.Abs(nums[len-3] - nums[0]);\\n        return Math.Min(num1, Math.Min(num2,num3));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227754,
                "title": "c-golang-sorting",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = INT_MAX;\\n        int n = nums.size();\\n        for(int i = n - 3; i < n; i++) {\\n            ans = min(ans, nums[i] - nums[i - n + 3]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n\\nfunc minimizeSum(nums []int) int {\\n    sort.Ints(nums)\\n    var ans int = math.MaxInt\\n    var n int = len(nums)\\n    for i := n - 3; i < n; i++ {\\n        ans = min(ans, nums[i] - nums[i - n + 3])\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = INT_MAX;\\n        int n = nums.size();\\n        for(int i = n - 3; i < n; i++) {\\n            ans = min(ans, nums[i] - nums[i - n + 3]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n\\nfunc minimizeSum(nums []int) int {\\n    sort.Ints(nums)\\n    var ans int = math.MaxInt\\n    var n int = len(nums)\\n    for i := n - 3; i < n; i++ {\\n        ans = min(ans, nums[i] - nums[i - n + 3])\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225236,
                "title": "c-sorting-easy-to-uderstand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n&&i<3;i++)\\n        {\\n            ans=min(ans,abs(nums[(n-3+i)%n]-nums[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n&&i<3;i++)\\n        {\\n            ans=min(ans,abs(nums[(n-3+i)%n]-nums[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222186,
                "title": "java-easy-solution-priorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        \\n\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        PriorityQueue<Integer>pq1=new PriorityQueue<>(Collections.reverseOrder());\\n        int max=0;\\n        int min=Integer.MAX_VALUE;\\n        for(int i:nums){\\n            pq.add(i);\\n            pq1.add(i);\\n            min=Math.min(min,i);\\n            max=Math.max(max,i);\\n        }\\n        while(!pq.isEmpty()){\\n            int t=pq.poll();\\n            int t1=pq.poll();\\n            int t2=pq.poll();\\n\\n        \\n            max=Math.abs(max-t2);\\n            break;\\n            \\n\\n        }\\n        while(!pq1.isEmpty()){\\n            int t=pq1.poll();\\n            int t1=pq1.poll();\\n            int t2=pq1.poll();\\n\\n            \\n            min=Math.abs(t2-min);\\n            break;\\n        }\\n\\n        Arrays.sort(nums);\\n        int a=nums[1];\\n        int b=nums[nums.length-2];\\n        int z=Math.abs(a-b);\\n        return Math.min(min,Math.min(max,z));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        \\n\\n        PriorityQueue<Integer>pq=new PriorityQueue<>();\\n        PriorityQueue<Integer>pq1=new PriorityQueue<>(Collections.reverseOrder());\\n        int max=0;\\n        int min=Integer.MAX_VALUE;\\n        for(int i:nums){\\n            pq.add(i);\\n            pq1.add(i);\\n            min=Math.min(min,i);\\n            max=Math.max(max,i);\\n        }\\n        while(!pq.isEmpty()){\\n            int t=pq.poll();\\n            int t1=pq.poll();\\n            int t2=pq.poll();\\n\\n        \\n            max=Math.abs(max-t2);\\n            break;\\n            \\n\\n        }\\n        while(!pq1.isEmpty()){\\n            int t=pq1.poll();\\n            int t1=pq1.poll();\\n            int t2=pq1.poll();\\n\\n            \\n            min=Math.abs(t2-min);\\n            break;\\n        }\\n\\n        Arrays.sort(nums);\\n        int a=nums[1];\\n        int b=nums[nums.length-2];\\n        int z=Math.abs(a-b);\\n        return Math.min(min,Math.min(max,z));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218208,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return min({nums[n-1]-nums[2],nums[n-2]-nums[1],nums[n-3]-nums[0]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return min({nums[n-1]-nums[2],nums[n-2]-nums[1],nums[n-3]-nums[0]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217226,
                "title": "swift-solution-not-well-optimized-but-worked",
                "content": "# Approach\\n1. Sort the array.\\n2. Find the minimum difference between the last 3 elements and the first 3 elements.\\n3. Return the minimum difference.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    func minimizeSum(_ nums: [Int]) -> Int \\n    {\\n        let n = nums.count\\n        let sortedNums = nums.sorted()\\n        var high = Int.max\\n        high = min(high, sortedNums[n - 2] - sortedNums[1])\\n        high = min(high, sortedNums[n - 3] - sortedNums[0])\\n        high = min(high, sortedNums[n - 1] - sortedNums[2])\\n        return high\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution \\n{\\n    func minimizeSum(_ nums: [Int]) -> Int \\n    {\\n        let n = nums.count\\n        let sortedNums = nums.sorted()\\n        var high = Int.max\\n        high = min(high, sortedNums[n - 2] - sortedNums[1])\\n        high = min(high, sortedNums[n - 3] - sortedNums[0])\\n        high = min(high, sortedNums[n - 1] - sortedNums[2])\\n        return high\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216143,
                "title": "java-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        if(nums.length<=3)return 0;\\n        int l = nums.length;\\n        Arrays.sort(nums);\\n        return Math.min(nums[l-1] - nums[2],Math.min(nums[l-2]-nums[1],nums[l-3] - nums[0]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        if(nums.length<=3)return 0;\\n        int l = nums.length;\\n        Arrays.sort(nums);\\n        return Math.min(nums[l-1] - nums[2],Math.min(nums[l-2]-nums[1],nums[l-3] - nums[0]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215485,
                "title": "easily-explained-approach",
                "content": "# Intuition\\n-> To find such positions after sorting where the maximum difference between the elements will minimum.\\n-> We are just checking the maximum difference because the minimum will be zero as we will replace with same elements.\\n-> So we have to find such positions where the maximum difference will be minimum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> When we will sort this array than we have to find the positions where we can replace the elements.\\n-> We have 3 cases:\\n    `Case 1:`\\n=> If we replace the 1st 2 elements, then the maximum difference will be `nums[n-1] - nums[2]`\\n    `Case 2:`\\n=> If we replace the last 2 elements, then the maximum difference will be `nums[n-3] - nums[0]`\\n`Case 3`\\n=> If we replace the 1st and last elements then the maximum difference will be `nums[n-2]-nums[1]`\\n\\n**At last we will return the minimum of these 3 cases**\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n*log(n)) (As we are sorting the array.)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int last2same = nums[n-3] - nums[0];\\n        int first2same = nums[n-1] - nums[2];\\n        int firstLastSame = nums[n-2] -  nums[1];\\n        return min({last2same, first2same, firstLastSame});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int last2same = nums[n-3] - nums[0];\\n        int first2same = nums[n-1] - nums[2];\\n        int firstLastSame = nums[n-2] -  nums[1];\\n        return min({last2same, first2same, firstLastSame});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214684,
                "title": "swift-solution-o-nlogn",
                "content": "# Code\\n```\\nclass Solution {\\n    func minimizeSum(_ nums: [Int]) -> Int {\\n        let nums = nums.sorted()\\n        return min(\\n            nums.dropFirst(2).score,\\n            nums.dropLast(2).score,\\n            nums.dropFirst().dropLast().score\\n        )\\n    }\\n}\\n\\nextension ArraySlice where Element == Int {\\n    var score: Int {\\n        (last ?? 0) - (first ?? 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizeSum(_ nums: [Int]) -> Int {\\n        let nums = nums.sorted()\\n        return min(\\n            nums.dropFirst(2).score,\\n            nums.dropLast(2).score,\\n            nums.dropFirst().dropLast().score\\n        )\\n    }\\n}\\n\\nextension ArraySlice where Element == Int {\\n    var score: Int {\\n        (last ?? 0) - (first ?? 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214014,
                "title": "1-liner-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 4){\\n            return 0;\\n        }\\n        else{\\n            return min({nums[n-3]-nums[0], nums[n-1]-nums[2], nums[n-2]-nums[1]});\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 4){\\n            return 0;\\n        }\\n        else{\\n            return min({nums[n-3]-nums[0], nums[n-1]-nums[2], nums[n-2]-nums[1]});\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213624,
                "title": "java-sorting-answer-simple",
                "content": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        if(nums.length == 3) return 0;\\n        int n = nums.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        return Math.min(\\n            Math.min(nums[n-1] - nums[0], nums[(n-1)] - nums[(2)]),\\n            Math.min(nums[(n-3)] - nums[(0)], nums[(n-2)] - nums[(1)])\\n        );    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        if(nums.length == 3) return 0;\\n        int n = nums.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        return Math.min(\\n            Math.min(nums[n-1] - nums[0], nums[(n-1)] - nums[(2)]),\\n            Math.min(nums[(n-3)] - nums[(0)], nums[(n-2)] - nums[(1)])\\n        );    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211878,
                "title": "c-greedy-explained",
                "content": "# Approach\\nSince we only need to replace any two elements in array. We\\'ll focus on reducing either minimum difference or maximum difference or mix of both.\\n\\nSo, firstly we\\'ll sort the array, that way we\\'ll get to know elements involved in minimum and maximum difference.\\n\\nThen, we\\'ll simply do either of following 3 possibilities :\\n1) replace first two elements with 3rd element\\n2) replace last two elements i.e n-1 and n-2 with n-3 th element\\n3) replace first and last element with any of 2nd or n-2th element\\n\\nThus, our search scope is reduced to only above three differences.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        \\n        // 3 possibilities\\n        ans = min(ans,abs(nums[n-1]-nums[2]));\\n        ans = min(ans,abs(nums[n-3]-nums[0]));\\n        ans = min(ans,abs(nums[n-2]-nums[1]));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        \\n        // 3 possibilities\\n        ans = min(ans,abs(nums[n-1]-nums[2]));\\n        ans = min(ans,abs(nums[n-3]-nums[0]));\\n        ans = min(ans,abs(nums[n-2]-nums[1]));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210719,
                "title": "easy-soln-using-python-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        \\n        m1 =nums[-1]-nums[2]\\n        #print(m1)\\n        m2 = nums[-3]-nums[0]\\n        m3 = nums[-2] - nums[1]\\n        #print(m2)\\n        \\n        return min(min(m1,m2), m3)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        \\n        m1 =nums[-1]-nums[2]\\n        #print(m1)\\n        m2 = nums[-3]-nums[0]\\n        m3 = nums[-2] - nums[1]\\n        #print(m2)\\n        \\n        return min(min(m1,m2), m3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207976,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can change at most 2 numbers, so the `low` value is 0\\nNow we need to find the minimum of `high` value\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minimizeSum(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        let nums = nums.sorted()\\n        return min(min(nums[n-1] - nums[2], nums[n-2]-nums[1]), nums[n-3]-nums[0])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizeSum(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        let nums = nums.sorted()\\n        return min(min(nums[n-1] - nums[2], nums[n-2]-nums[1]), nums[n-3]-nums[0])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207867,
                "title": "python-simple-solution-with-just-checking-three-cases-explained",
                "content": "Actually, the min and max score is the minmum and maximum of all the differences between any two numbers in the array.\\n\\nTherefore, to make the calculation easlier, we can sort the array. The maximum score will be the difference between the last number and the first number. The minimum score will be the min of differences between all two adjacent numbers.\\n\\nThe minimize the score, we need: 1) minimize the difference between nums[0] and nums[-1]; 2) can possiblely create two equal numbers so that the min score is 0;\\n\\nSince the array is sorted, therefore, there are three cases, we can do by changing to numbers:\\n1) increase the first two numbers to match the third number: nums[0] == nums[1] == nums[3]\\n2) decrease the last two largest numbers to match the third last number: nums[-1] == nums[-2] == nums[-3]\\n3) increase the first number and decreaes the last number: nums[0] == nums[1], nums[-1] == nums[-2]\\n\\nWe just need to return the minimum score among the above three cases.\\n\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        # speical case\\n        if len(nums) == 3:\\n            return 0\\n        \\n        nums.sort()\\n        # case 1: increase the front two minimum\\n        front_score = nums[-1] - nums[2]\\n        # case 2: decrease the back two maximum\\n        back_score = nums[-3] - nums[0]\\n        # case 3: increase the minimum and decrease the maximum\\n        both_score = nums[-2] - nums[1]\\n        \\n        return min(front_score, back_score, both_score)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        # speical case\\n        if len(nums) == 3:\\n            return 0\\n        \\n        nums.sort()\\n        # case 1: increase the front two minimum\\n        front_score = nums[-1] - nums[2]\\n        # case 2: decrease the back two maximum\\n        back_score = nums[-3] - nums[0]\\n        # case 3: increase the minimum and decrease the maximum\\n        both_score = nums[-2] - nums[1]\\n        \\n        return min(front_score, back_score, both_score)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207428,
                "title": "python-2-liner",
                "content": "\\n\\n# Approach\\nWe can change 2 values, so the \"low\" score is always going to be 0.\\nHence we need to find minimum of the \"high\" score. To do it:\\n1. sort the nums\\n2. current \"high\" is nums[-1]-nums[0], but we can make 2 changes, so we  \"remove\" 2 values from the front, two from the back or one from each. By \"remove\" I mean: change this value to any value that is in the \"middle\".\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n\\n        nums.sort()\\n        return min(nums[-3]-nums[0],nums[-2]-nums[1],nums[-1]-nums[2])        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n\\n        nums.sort()\\n        return min(nums[-3]-nums[0],nums[-2]-nums[1],nums[-1]-nums[2])        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206740,
                "title": "clean-2-line-python-solution",
                "content": "First sort the array so easy to access max/min.\\nThere are 3 possible cases:\\n1) Make nums[0] = nums[1] and nums[len(nums)-1] = nums[len(nums)-2] (take away the smallest and biggest)\\n2) Make nums[0] = nums[2] and nums[1] = nums[2] (take away the 2 smallest values)\\n3) Makes nums[len(nums)-1] = nums[len(nums)-3] and nums[len(nums)-2] = nums[len(nums)-3] (take away the 2 largest values)\\n\\nThe answer is the minimum of these three cases\\n\\n```\\n\\ndef minimizeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        return min(nums[len(nums)-2]-nums[1],nums[len(nums)-1]-nums[2],nums[len(nums)-3]-nums[0])",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "First sort the array so easy to access max/min.\\nThere are 3 possible cases:\\n1) Make nums[0] = nums[1] and nums[len(nums)-1] = nums[len(nums)-2] (take away the smallest and biggest)\\n2) Make nums[0] = nums[2] and nums[1] = nums[2] (take away the 2 smallest values)\\n3) Makes nums[len(nums)-1] = nums[len(nums)-3] and nums[len(nums)-2] = nums[len(nums)-3] (take away the 2 largest values)\\n\\nThe answer is the minimum of these three cases\\n\\n```\\n\\ndef minimizeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        return min(nums[len(nums)-2]-nums[1],nums[len(nums)-1]-nums[2],nums[len(nums)-3]-nums[0])",
                "codeTag": "Python3"
            },
            {
                "id": 3206619,
                "title": "c-my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: **O(nlogn)**\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        if (nums.Length == 3)\\n            return 0;\\n\\n        Array.Sort(nums);\\n        int diff1 = nums[nums.Length - 1] - nums[2];\\n        int diff2 = nums[nums.Length - 3] - nums[0];\\n        int diff3 = nums[nums.Length - 2] - nums[1];\\n        return Math.Min(diff1, Math.Min(diff2, diff3));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        if (nums.Length == 3)\\n            return 0;\\n\\n        Array.Sort(nums);\\n        int diff1 = nums[nums.Length - 1] - nums[2];\\n        int diff2 = nums[nums.Length - 3] - nums[0];\\n        int diff3 = nums[nums.Length - 2] - nums[1];\\n        return Math.Min(diff1, Math.Min(diff2, diff3));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206107,
                "title": "c-easy-to-implement",
                "content": "# Intuition\\nWe can minimize in following three different ways:\\n1. Minimize 2 units from right side.\\n2. Minimize 2 units from left side.\\n3. Minimize 1 unit from right and 1 unit from left.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n     int n=nums.size();\\n    sort(nums.begin(),nums.end());\\n    return min({(nums[n-1]-nums[2]),(nums[n-3]-nums[0]),(nums[n-2]-nums[1])});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n     int n=nums.size();\\n    sort(nums.begin(),nums.end());\\n    return min({(nums[n-1]-nums[2]),(nums[n-3]-nums[0]),(nums[n-2]-nums[1])});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205776,
                "title": "implementing-the-most-intuitive-solution-slow-python3-you-might-had-intuition-during-contest",
                "content": "Lots of thinking. l o l\\n\\n```\\nfrom collections import Counter\\nimport bisect\\n\\nclass Solution:\\n    def minimizeSum(self, nums) :\\n        g=Counter(nums)\\n        nums.sort()\\n        sets=set()\\n        \\n        for ele in nums:\\n            sets.add(ele)\\n            \\n        order=[]\\n        for ele in sets:\\n            order.append(ele)\\n            \\n        order.sort()\\n      \\n        if len(nums)==3:\\n            return 0\\n        else:\\n            maxm=order[-1]\\n            minm=order[0]\\n            if g[maxm]>=3 or g[minm]>=3:\\n                if g[maxm]>=3 and g[minm]>=3:\\n                    high=maxm-minm\\n                if g[maxm]>=3 and g[minm]<3:\\n                    if g[minm]==2:\\n                        high=order[-1]-order[1]\\n                    if g[minm]==1:\\n                        if g[order[1]]==1:\\n                            high=order[-1]-order[2]\\n                        else:\\n                            high=order[-1]-order[1]\\n                            \\n                if g[minm]>=3 and g[maxm]<3:\\n                    if g[maxm]==2:\\n                        high=order[-2]-order[0]\\n                    if g[maxm]==1:\\n                        if g[order[-2]]==1:\\n                            high=order[-3]-order[0]\\n                        else:\\n                            high=order[-2]-order[0]\\n                \\n                \\n            else:\\n                if g[maxm]==2 and g[minm]==2:\\n                    high1=order[-1]-order[1]\\n                    high2=order[-2]-order[0]\\n                    high=min(high1,high2) #as low is zero \\n                    \\n                elif g[maxm]==2 and g[minm]==1:\\n            \\n                    high=order[-2]-order[0]\\n                    if g[order[1]]==1:\\n                        high=min(high,order[-1]-order[2])\\n                    else:\\n                        high=min(high,order[-1]-order[1])\\n                    \\n                elif g[minm]==2 and g[maxm]==1:\\n                 \\n                    high=order[-1]-order[1]\\n                    if g[order[-2]]==1:\\n                        high=min(high,order[-3]-order[0])\\n                    else:\\n                        high=min(high,order[-2]-order[0])\\n                else:\\n                    high=float(\\'inf\\')\\n                    if g[order[1]]==1 and g[order[-2]]==1:\\n                        high1=order[-2]-order[1]\\n                        high2=order[-3]-order[0]\\n                        high3=order[-1]-order[2]\\n                        high=min(high1,high2,high3)\\n                        \\n                    elif g[order[1]]==1 and g[order[-2]]!=1:\\n                        high=min(high,order[-2]-order[1])\\n                        high=min(high,order[-1]-order[2])\\n                        \\n                    elif g[order[-2]]==1 and g[order[1]]!=1:\\n                        high=min(high,order[-2]-order[1])\\n                        high=min(high,order[-3]-order[0])\\n                    else:\\n                        high=min(high,order[-2]-order[1])\\n                        \\n                \\n            return high\\n                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nfrom collections import Counter\\nimport bisect\\n\\nclass Solution:\\n    def minimizeSum(self, nums) :\\n        g=Counter(nums)\\n        nums.sort()\\n        sets=set()\\n        \\n        for ele in nums:\\n            sets.add(ele)\\n            \\n        order=[]\\n        for ele in sets:\\n            order.append(ele)\\n            \\n        order.sort()\\n      \\n        if len(nums)==3:\\n            return 0\\n        else:\\n            maxm=order[-1]\\n            minm=order[0]\\n            if g[maxm]>=3 or g[minm]>=3:\\n                if g[maxm]>=3 and g[minm]>=3:\\n                    high=maxm-minm\\n                if g[maxm]>=3 and g[minm]<3:\\n                    if g[minm]==2:\\n                        high=order[-1]-order[1]\\n                    if g[minm]==1:\\n                        if g[order[1]]==1:\\n                            high=order[-1]-order[2]\\n                        else:\\n                            high=order[-1]-order[1]\\n                            \\n                if g[minm]>=3 and g[maxm]<3:\\n                    if g[maxm]==2:\\n                        high=order[-2]-order[0]\\n                    if g[maxm]==1:\\n                        if g[order[-2]]==1:\\n                            high=order[-3]-order[0]\\n                        else:\\n                            high=order[-2]-order[0]\\n                \\n                \\n            else:\\n                if g[maxm]==2 and g[minm]==2:\\n                    high1=order[-1]-order[1]\\n                    high2=order[-2]-order[0]\\n                    high=min(high1,high2) #as low is zero \\n                    \\n                elif g[maxm]==2 and g[minm]==1:\\n            \\n                    high=order[-2]-order[0]\\n                    if g[order[1]]==1:\\n                        high=min(high,order[-1]-order[2])\\n                    else:\\n                        high=min(high,order[-1]-order[1])\\n                    \\n                elif g[minm]==2 and g[maxm]==1:\\n                 \\n                    high=order[-1]-order[1]\\n                    if g[order[-2]]==1:\\n                        high=min(high,order[-3]-order[0])\\n                    else:\\n                        high=min(high,order[-2]-order[0])\\n                else:\\n                    high=float(\\'inf\\')\\n                    if g[order[1]]==1 and g[order[-2]]==1:\\n                        high1=order[-2]-order[1]\\n                        high2=order[-3]-order[0]\\n                        high3=order[-1]-order[2]\\n                        high=min(high1,high2,high3)\\n                        \\n                    elif g[order[1]]==1 and g[order[-2]]!=1:\\n                        high=min(high,order[-2]-order[1])\\n                        high=min(high,order[-1]-order[2])\\n                        \\n                    elif g[order[-2]]==1 and g[order[1]]!=1:\\n                        high=min(high,order[-2]-order[1])\\n                        high=min(high,order[-3]-order[0])\\n                    else:\\n                        high=min(high,order[-2]-order[1])\\n                        \\n                \\n            return high\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205170,
                "title": "c-sort-easy-explaination",
                "content": "![1](https://assets.leetcode.com/users/images/94b54e0f-8890-41f4-b664-f983e83d0fc6_1676797422.9794934.jpeg)\\n\\n\\n![image](https://assets.leetcode.com/users/images/d88638cb-b445-44b6-b99e-2ceace7c8f2c_1676797453.7412226.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        int min_sum=INT_MAX;\\n        int n=nums.size();\\n\\n        int diff1=abs(nums[2]-nums[n-1]);\\n        int diff2=abs(nums[1]-nums[n-2]);\\n        int diff3=abs(nums[0]-nums[n-3]);\\n        \\n        min_sum=min(diff1,min(diff2,diff3));\\n        return min_sum;\\n    }\\n};\\n```\\n[](https://github.com/Arnab-Patra006/Code_With_Pie/blob/main/LeetCode/6361.%20Minimum%20Score%20by%20Changing%20Two%20Elements.md!)\\n[GitHub Link](http://)\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        int min_sum=INT_MAX;\\n        int n=nums.size();\\n\\n        int diff1=abs(nums[2]-nums[n-1]);\\n        int diff2=abs(nums[1]-nums[n-2]);\\n        int diff3=abs(nums[0]-nums[n-3]);\\n        \\n        min_sum=min(diff1,min(diff2,diff3));\\n        return min_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204882,
                "title": "minimum-score-by-changing-two-elements-explained-step-by-step-intuition-python",
                "content": "# First let\\'s rephrase the question itself\\nWe are given an integer array nums\\nlow   : the minimum difference between any two numbers in the array\\nhigh  : the maximum difference between any two numbers in the array\\nscore : sum of low and high\\nwe want to minimize the score by changing/replacing at most 2 elements \\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo minimize the score. \\nwe have to minimize the low and high\\nwe can easily minimize the low to 0 .. This can be easily seen .. We are permitted to change at most 2 elements and if we just replace 2 elements by same value the low would be 0 . It can also be done in 1 operation also. This is always true\\n\\nNow score becomes = 0 + high = high\\nso now we want to minimize only the high i.e. the maximum difference between two elements\\n\\nwe know that the maximum difference between two elements can be easily found by sorting the elements. The difference between first and last element is the maximum you can get.\\n\\nNow the question becomes how to minimize this difference by performing atmost 2 operations\\n\\nThe array is [1,4,8,7,5]\\n![image.png](https://assets.leetcode.com/users/images/48c12b05-82ec-4547-9da3-d6fdc37de7be_1676791296.6209955.png)\\n\\nIn the above image you can see that the difference is maximum because the elements are at extreme boundaries.\\n\\nto minimize we can simply remove them and now our minimum is (7 - 4).\\n\\nWe also have to think of 2 edge cases.\\n\\nThe array is [25,79,74,72,65,31]\\n![image.png](https://assets.leetcode.com/users/images/9e31b893-3b07-41ac-a143-afdcbb64a81a_1676791577.0660012.png)\\n\\nI will explain one edge case and the second is similar to this. You can figure that out. If not i will answer in comments\\n\\n\\nif you remove first minimum and last minimum. The answer would be 43.\\nbecause the gap/difference between 31 and 65 is retained.\\n\\nIf we want to remove that gap we will have to remove first two elements.\\n![image.png](https://assets.leetcode.com/users/images/b855cc90-7ad8-41d2-9bb6-e1697f61629e_1676791961.9842944.png)\\n\\nNow we can see that the difference between 31 and 65 is removed and our new high becomes 14. \\n\\nSimilarly if the gap is present in the end side.\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nI think the code is self explanatory.\\n\\nIf we remove first and last element the new minimum becomes second element and new maximum becomes second last element \\n\\nIf we remove first two elements the new minimum becomes third element and new maximum becomes last element \\n\\nIf we remove last two element the new minimum becomes first element and new maximum becomes third last element \\n\\nNow the result will be the minimum of these three.\\n\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        min1 = abs(nums[1]-nums[-2])\\n        min2 = abs(nums[2]-nums[-1])\\n        min3 = abs(nums[0]-nums[-3])\\n        return min(min1,min2,min3)\\n```\\n\\nI hope you understood this. If so please upvote and comment if there\\'s any doubt\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        min1 = abs(nums[1]-nums[-2])\\n        min2 = abs(nums[2]-nums[-1])\\n        min3 = abs(nums[0]-nums[-3])\\n        return min(min1,min2,min3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204831,
                "title": "strange-question-steps-inside",
                "content": "# Approach\\nWe replace the largest element with the third smallest element: This will minimize the high score and keep the low score the same. We compute the difference between the largest element and the third smallest element to get the high score.\\n\\nWe replace the smallest element with the third largest element: This will minimize the low score and keep the high score the same. We compute the difference between the third largest element and the smallest element to get the low score.\\n\\nWe replace the second largest element with the second smallest element: This will minimize both the high and low scores. We compute the difference between the second largest element and the second smallest element to get the new high and low scores.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int min1=nums[n-1]-nums[2];\\n        int min2=nums[n-2]-nums[1];\\n        int min3=nums[n-3]-nums[0];\\n        return Math.min(min1,Math.min(min2,min3));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int min1=nums[n-1]-nums[2];\\n        int min2=nums[n-2]-nums[1];\\n        int min3=nums[n-3]-nums[0];\\n        return Math.min(min1,Math.min(min2,min3));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204772,
                "title": "short-and-easy-soln-sorting",
                "content": "# Approach\\nfirst of all sort the fiven vector\\n\\nthen we get three case to optimize our soln  \\n=> Increase nums[0], nums[1] equal to nums[2], now low=0, high=nums[n-1]-nums[2]\\n\\n=> Reduce nums[n-1], nums[n-2] equal to nums[n-3], now low=0, high=nums[n-3]-nums[0]\\n\\n=> Reduce nums[n-1] equal to nums[n-2] ,Increase nums[0] equal to nums[1],now low=0, high=nums[n-2]-nums[1]\\n\\n\\n             **OUR FINAL ANS WILL BE MINIMUM OF ALL THREE CASES**\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int r1= nums[nums.size()-2]-nums[1];\\n        int r2=nums[nums.size()-1]-nums[2];\\n        int r3= nums[nums.size()-3]-nums[0];\\n        r1= min(r1,r2);\\n        \\n            return min(r1,r3);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int r1= nums[nums.size()-2]-nums[1];\\n        int r2=nums[nums.size()-1]-nums[2];\\n        int r3= nums[nums.size()-3]-nums[0];\\n        r1= min(r1,r2);\\n        \\n            return min(r1,r3);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204618,
                "title": "c-dfs-with-depth-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen the length of nums is 3, we can always pick the larger 2 numbers and change them with the the smallest one in the array, therefore the low is always 0, the high is also 0, the result is 0.\\n\\nFor length > 3, the low is still always be 0 because by changing two numbers, we can always make low 0. \\n\\nNow we need to consider different combination to minimize the high, the principle is to change either the smallest or the largest so that we can minimize the high. (If we change any numbers in between, the high remains the same). Let\\'s say k is the number of changes we can make.\\n\\nK: 2\\nnums: [a b c d]\\n\\n1. remove a, the high of removing K=1 in [b, c, d]\\n2. remove d, the high of removing K=1 in [a, b, c]\\n\\nK: 1\\nnums: [b, c, d]\\n\\n1. remove b: the high of removing K=0 in [c, d]\\n2. remove d: the high of removing K=0 in [b, c]\\n\\nK: 1\\nnums: [a, b, c]\\n\\n1. remove a: the high of removing K=0 in [b, c]\\n2. remove c: the high of removing K=0 in [a, b]\\n\\nK: 0\\nnums: [c, d]\\nthe high is d - c\\n\\nK: 0\\nnums: [b, c] \\nthe high is c - b\\n\\nK: 0\\nnums: [b, c]\\nthe high is c - b\\n\\nK: 0\\nnums: [a, b]\\nthe high is b - a\\n\\nthe answer is the minimum of all highs when K = 0\\n\\nThis can be done with recursive DFS.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ret = INT_MAX;\\n    \\n    void dp(vector<int>& nums, int i, int j, int k) {\\n        if(k==0) {\\n            ret = min(ret, abs(nums[j] - nums[i]));\\n            return;\\n        }\\n                  \\n        dp(nums, i+1, j, k-1);\\n        dp(nums, i, j-1, k-1);\\n    }\\n    \\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size()==3) {\\n            return 0;\\n        }\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        dp(nums, 0, n-1, 2);\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ret = INT_MAX;\\n    \\n    void dp(vector<int>& nums, int i, int j, int k) {\\n        if(k==0) {\\n            ret = min(ret, abs(nums[j] - nums[i]));\\n            return;\\n        }\\n                  \\n        dp(nums, i+1, j, k-1);\\n        dp(nums, i, j-1, k-1);\\n    }\\n    \\n    int minimizeSum(vector<int>& nums) {\\n        if(nums.size()==3) {\\n            return 0;\\n        }\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        dp(nums, 0, n-1, 2);\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204529,
                "title": "python-linear-time-based-on-insertion-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can change at most 2 elements in nums. There\\'re only three choices of selection which can reduce score:\\n\\n1. change the most largest to the second largest, and change the most smallest to the second smallest. Final score is second largest - second smallest.\\n2. change both the most largest and the second largest to the third largest. Final score is third largest - most smallest.\\n3. change both the most smallest and the second smallest to the third smallest. Final score is most largest - third smallest.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe traverse the whole array nums, and record the top 3 largest numbers and the top 3 smallest numbers. Then return the minimum value among the 3 pairs of subtraction. To record the top 3 numbers in sequence, we can use insertion sort on array whose size is 4 here.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        smallCandidates, largeCandidates = [inf] * 4, [-inf] * 4\\n        for num in nums:\\n            smallCandidates[3] = num\\n            for idx in range(3, 0, -1):\\n                if smallCandidates[idx] >= smallCandidates[idx - 1]:\\n                    break\\n                smallCandidates[idx], smallCandidates[idx - 1] = smallCandidates[idx - 1], smallCandidates[idx]\\n            largeCandidates[3] = num\\n            for idx in range(3, 0, -1):\\n                if largeCandidates[idx] <= largeCandidates[idx - 1]:\\n                    break\\n                largeCandidates[idx], largeCandidates[idx - 1] = largeCandidates[idx - 1], largeCandidates[idx]\\n        return min(largeCandidates[0] - smallCandidates[2], largeCandidates[1] - smallCandidates[1], largeCandidates[2] - smallCandidates[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```python []\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        smallCandidates, largeCandidates = [inf] * 4, [-inf] * 4\\n        for num in nums:\\n            smallCandidates[3] = num\\n            for idx in range(3, 0, -1):\\n                if smallCandidates[idx] >= smallCandidates[idx - 1]:\\n                    break\\n                smallCandidates[idx], smallCandidates[idx - 1] = smallCandidates[idx - 1], smallCandidates[idx]\\n            largeCandidates[3] = num\\n            for idx in range(3, 0, -1):\\n                if largeCandidates[idx] <= largeCandidates[idx - 1]:\\n                    break\\n                largeCandidates[idx], largeCandidates[idx - 1] = largeCandidates[idx - 1], largeCandidates[idx]\\n        return min(largeCandidates[0] - smallCandidates[2], largeCandidates[1] - smallCandidates[1], largeCandidates[2] - smallCandidates[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204446,
                "title": "java-sort-easy-solution",
                "content": "# Approach\\nFirst, we can ignore below statement, because | nums[i] - nums[j] | also equal to | nums[j] - nums[i] |, so the index is not important.\\n> 0 <= i < j < nums.length \\n\\nThen we can sort the array.\\n\\nFor the low score part, we can ignore as well, since we can always let two changing element become same element, therefore low score always will be 0.\\n\\nFor the high score part, there will be 3 different scenario:\\n1. First and last element have replaced\\n2. First two element have replaced\\n3. Last two element have replaced\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        if(nums.length==3)\\n        {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(nums);\\n        return Math.min(nums[nums.length-3]-nums[0],Math.min(nums[nums.length-1]-nums[2],nums[nums.length-2]-nums[1]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        if(nums.length==3)\\n        {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(nums);\\n        return Math.min(nums[nums.length-3]-nums[0],Math.min(nums[nums.length-1]-nums[2],nums[nums.length-2]-nums[1]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204445,
                "title": "c-3-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& A) {\\n        sort(begin(A), end(A));\\n        int N = A.size();\\n        return min({A[N-1]-A[2], A[N-3]-A[0], A[N-2]-A[1]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& A) {\\n        sort(begin(A), end(A));\\n        int N = A.size();\\n        return min({A[N-1]-A[2], A[N-3]-A[0], A[N-2]-A[1]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204394,
                "title": "antarnab-100-faster-easy-java-coding-life",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution  {    public int minimizeSum(int[] A) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        return Math.min(Math.min(A[n - 1] - A[2], A[n - 3] - A[0]), A[n - 2] - A[1]);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution  {    public int minimizeSum(int[] A) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        return Math.min(Math.min(A[n - 1] - A[2], A[n - 3] - A[0]), A[n - 2] - A[1]);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204240,
                "title": "fundamental-approach-c-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 3)\\n            return 0;\\n        sort(nums.begin(), nums.end());\\n        return min(min(nums[n-1]-nums[2], nums[n-3]-nums[0]), nums[n-2]-nums[1]);\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: DeepCodes (YouTube)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 3)\\n            return 0;\\n        sort(nums.begin(), nums.end());\\n        return min(min(nums[n-1]-nums[2], nums[n-3]-nums[0]), nums[n-2]-nums[1]);\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: DeepCodes (YouTube)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204146,
                "title": "c-o-n-solution-insertion-sort-to-record-first-3-last-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can change at most 2 elements in `nums`. There\\'re only three choices of selection which can reduce score:\\n1. change the most largest to the second largest, and change the most smallest to the second smallest. Final score is `second largest - second smallest`.\\n2. change both the most largest and the second largest to the third largest. Final score is `third largest - most smallest`.\\n3. change both the most smallest and the second smallest to the third smallest. Final score is `most largest - third smallest`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe traverse the whole array `nums`, and record the top 3 largest numbers and the top 3 smallest numbers. Then return the minimum value among the 3 pairs of subtraction.\\n\\nTo record the top 3 numbers in sequence, we can use insertion sort on array whose size is 4 here.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        vector<int> small(4, INT_MAX), large(4, INT_MIN);\\n        for (auto n : nums) {\\n            small[3] = n;\\n            for (int i = 3; i > 0 && small[i] < small[i-1]; --i)\\n                swap(small[i], small[i-1]);\\n\\n            large[3] = n;\\n            for (int i = 3; i > 0 && large[i] > large[i-1]; --i)\\n                swap(large[i], large[i-1]);\\n        }\\n\\n        return min(large[0] - small[2], min(large[1] - small[1], large[2] - small[0]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        vector<int> small(4, INT_MAX), large(4, INT_MIN);\\n        for (auto n : nums) {\\n            small[3] = n;\\n            for (int i = 3; i > 0 && small[i] < small[i-1]; --i)\\n                swap(small[i], small[i-1]);\\n\\n            large[3] = n;\\n            for (int i = 3; i > 0 && large[i] > large[i-1]; --i)\\n                swap(large[i], large[i-1]);\\n        }\\n\\n        return min(large[0] - small[2], min(large[1] - small[1], large[2] - small[0]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204052,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimize_sum(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        nums.sort();\\n        let n = nums.len();\\n        let mut min = nums[n - 1] - nums[2];\\n        let v = nums[n - 3] - nums[0];\\n        let v2 = nums[n - 2] - nums[1];\\n        min = min.min(v);\\n        min = min.min(v2);\\n        min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimize_sum(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        nums.sort();\\n        let n = nums.len();\\n        let mut min = nums[n - 1] - nums[2];\\n        let v = nums[n - 3] - nums[0];\\n        let v2 = nums[n - 2] - nums[1];\\n        min = min.min(v);\\n        min = min.min(v2);\\n        min\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203953,
                "title": "solution-by-only-sort-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if (nums.size() <= 3)\\n            return 0;\\n        int ans = 0, l = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        ans = nums[l - 1] - nums[2];\\n        ans = min(ans, abs(nums[l - 3] - nums[0]));\\n        ans = min(ans, abs(nums[l - 2] - nums[1]));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        if (nums.size() <= 3)\\n            return 0;\\n        int ans = 0, l = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        ans = nums[l - 1] - nums[2];\\n        ans = min(ans, abs(nums[l - 3] - nums[0]));\\n        ans = min(ans, abs(nums[l - 2] - nums[1]));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203902,
                "title": "c-solution-runtime-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we are taking absolute value of the difference thus there is no need for keeping the array unsorted.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we can change 2 values the minimum difference would always be 0.\\nThere are only 3 ways to change the maximum difference.\\nFirst, we will sort the array.\\nThen, we would take the sorted array and subtract the minimum from the maximum by sequentially not taking into account -\\n1. The first two minimums in the array i.e the first 2 indexes as we have done the sorting\\n2. The first and the last element in the array.\\n3. The last 2 elements in the array.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int max1, max2, max3;\\n        sort(nums.begin(),nums.end());\\n        max1 = nums[nums.size()-1] - nums[2];\\n        max2 = nums[nums.size()-2] - nums[1];\\n        max3 = nums[nums.size()-3] - nums[0];\\n        int ans = min(max1, min(max2,max3));\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        int max1, max2, max3;\\n        sort(nums.begin(),nums.end());\\n        max1 = nums[nums.size()-1] - nums[2];\\n        max2 = nums[nums.size()-2] - nums[1];\\n        max3 = nums[nums.size()-3] - nums[0];\\n        int ans = min(max1, min(max2,max3));\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203892,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minimizeSum(vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    if (n < 4) {\\n      return 0;\\n    }\\n    \\n    sort(nums.begin(), nums.end());\\n    return min({nums.back() - nums[2], nums[n - 3] - nums.front(), nums[n - 2] - nums[1]});\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minimizeSum(vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    if (n < 4) {\\n      return 0;\\n    }\\n    \\n    sort(nums.begin(), nums.end());\\n    return min({nums.back() - nums[2], nums[n - 3] - nums.front(), nums[n - 2] - nums[1]});\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203462,
                "title": "just-2-line-solution-using-sorting",
                "content": "# Intuition\\nJust Change the elements which leads to max difference \\nFocus on minimizing max becuse min can be 0 by putting it to same to a value; \\n\\n# Approach\\nAfter Sorting Array only we need to change first two or last two or first and last because they can cause max difference.\\n\\n# Complexity\\n- Time complexity:\\nO(n logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        return Math.min(nums[nums.length-1]-nums[2],Math.min(nums[nums.length-3]-nums[0],nums[nums.length-2]-nums[1]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        return Math.min(nums[nums.length-1]-nums[2],Math.min(nums[nums.length-3]-nums[0],nums[nums.length-2]-nums[1]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203428,
                "title": "sort-easy-understanding-python",
                "content": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        \\n        if len(nums)==3:\\n            return 0\\n        \\n        nums.sort()\\n        return min(nums[-1]-nums[2],nums[-3]-nums[0],nums[-2]-nums[1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        \\n        if len(nums)==3:\\n            return 0\\n        \\n        nums.sort()\\n        return min(nums[-1]-nums[2],nums[-3]-nums[0],nums[-2]-nums[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203407,
                "title": "c-sliding-pairs-sorting-vs-linear-time-36ms-42mb",
                "content": "This problem took me a bit to figure out, but then it was all clear, despite the misleading examples:\\n* we don\\'t really care about the initial order of the input elements, since the largest difference will always come from the highest minus the smalles (or the other way around, it does not really matter);\\n* since we are going to replace two numbers, we really never care about the minimum difference, since we will always set that to `0` having at least two identical items;\\n* after sorting all the elements in increasing order (but same goes for decreasing), we can have three possible optimal scenarios:\\n    * we replace the first two values with the last one, so the overall score is made from the last value minus the new smallest one, the third - example of it being the best move: `{1,4,5,7,8}` becoming (after sorting again for ease of display) `{5,7,8,8,8}`;\\n    * we replace the first value with the second one and the penultimate with the last one, so the overall score is made from the penultimate value minus the second one, the third - example of it being the best move: `{8,28,42,58,75}` becoming `{28,28,42,58,58}`;\\n    * we replace the last two values with the first one, so the overall score is made from the first value minus the new highest one, the antepenultimate - example of it being the best move: `{1,4,5,17,18}` becoming (after sorting again for ease of display) `{1,1,1,4,5}`.\\n\\nNow, with that hopefully making some sense, we can quickly code our solution.\\n\\nJust for the sake of micro-optimisation, I first of all cut out an edge case: when we have an input of minimum length, the result has to be `0` (also, our three possible scenarios are basically one and the same there).\\n\\nIn all the other cases, we will `sort` `ns`, then `return` the minimum between the differences of:\\n* last and the third (ie: `ns[len - 1] - ns[2]`);\\n* the penultimate and the second (ie: `ns[len - 2] - ns[1]`);\\n* the antepenultimate and the first (ie: `ns[len - 3] - ns[0]`).\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& ns) {\\n        // edge case\\n        if (ns.size() == 3) return 0;\\n        // support variables\\n        int len = ns.size();\\n        sort(begin(ns), end(ns));\\n        return min(ns[len - 1] - ns[2], min(ns[len - 2] - ns[1], ns[len - 3] - ns[0]));\\n    }\\n};\\n```\\n\\nCan we do beter? Of course - since we need only the 3 highest and 3 lowest values, we can achieve that in just linear time using 2 simple arrays to store those values.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& ns) {\\n        // edge case\\n        if (ns.size() == 3) return 0;\\n        // support variables\\n        int lowest[] = {INT_MAX, INT_MAX, INT_MAX}, highest[] = {INT_MIN, INT_MIN, INT_MIN};\\n        for (int n: ns) {\\n            if (n < lowest[0]) lowest[2] = lowest[1], lowest[1] = lowest[0], lowest[0] = n;\\n            else if (n < lowest[1]) lowest[2] = lowest[1], lowest[1] = n;\\n            else if (n < lowest[2]) lowest[2] = n;\\n            if (n > highest[0]) highest[2] = highest[1], highest[1] = highest[0], highest[0] = n;\\n            else if (n > highest[1]) highest[2] = highest[1], highest[1] = n;\\n            else if (n > highest[2]) highest[2] = n;\\n        }\\n        return min(highest[0] - lowest[2],\\n            min(highest[1] - lowest[1], highest[2] - lowest[0]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sort"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& ns) {\\n        // edge case\\n        if (ns.size() == 3) return 0;\\n        // support variables\\n        int len = ns.size();\\n        sort(begin(ns), end(ns));\\n        return min(ns[len - 1] - ns[2], min(ns[len - 2] - ns[1], ns[len - 3] - ns[0]));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& ns) {\\n        // edge case\\n        if (ns.size() == 3) return 0;\\n        // support variables\\n        int lowest[] = {INT_MAX, INT_MAX, INT_MAX}, highest[] = {INT_MIN, INT_MIN, INT_MIN};\\n        for (int n: ns) {\\n            if (n < lowest[0]) lowest[2] = lowest[1], lowest[1] = lowest[0], lowest[0] = n;\\n            else if (n < lowest[1]) lowest[2] = lowest[1], lowest[1] = n;\\n            else if (n < lowest[2]) lowest[2] = n;\\n            if (n > highest[0]) highest[2] = highest[1], highest[1] = highest[0], highest[0] = n;\\n            else if (n > highest[1]) highest[2] = highest[1], highest[1] = n;\\n            else if (n > highest[2]) highest[2] = n;\\n        }\\n        return min(highest[0] - lowest[2],\\n            min(highest[1] - lowest[1], highest[2] - lowest[0]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203342,
                "title": "python3-sorting",
                "content": "\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[-1]-nums[2], nums[-2]-nums[1], nums[-3]-nums[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[-1]-nums[2], nums[-2]-nums[1], nums[-3]-nums[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203257,
                "title": "c-three-possibilities-to-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should check 3 possibilities:\\n\\n- we change two lowest items of the array\\n- we change two highest items of the array\\n- we change lowest and highest ietms o the array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array and check three possibilities\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * log(n))$$, can be dropped to $$O(n)$$ - to compute two highest and lowest a simple loop is enough\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$  \\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        if (nums.Length <= 2)\\n            return 0;\\n        \\n        Array.Sort(nums);\\n\\n        if (nums[0] == nums[nums.Length - 1])\\n            return 0;\\n\\n        int c1 = nums[nums.Length - 3] - nums[0];\\n        int c2 = nums[nums.Length - 2] - nums[1];\\n        int c3 = nums[nums.Length - 1] - nums[2];\\n\\n        return Math.Min(Math.Min(c1, c2), c3);  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeSum(int[] nums) {\\n        if (nums.Length <= 2)\\n            return 0;\\n        \\n        Array.Sort(nums);\\n\\n        if (nums[0] == nums[nums.Length - 1])\\n            return 0;\\n\\n        int c1 = nums[nums.Length - 3] - nums[0];\\n        int c2 = nums[nums.Length - 2] - nums[1];\\n        int c3 = nums[nums.Length - 1] - nums[2];\\n\\n        return Math.Min(Math.Min(c1, c2), c3);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203217,
                "title": "ts-solution",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction minimizeSum(nums: number[]): number {\\n  const sorted = nums.sort((a, b) => a - b);\\n  \\n  const n = sorted.length;\\n  // Firt two taken out\\n  const one = sorted[n - 1] - sorted[2];\\n  // Last two taken out\\n  const two = sorted[n - 3] - sorted[0];\\n  // First and last taken out\\n  const thr = sorted[n - 2] - sorted[1];\\n  \\n  return Math.min(one, two, thr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction minimizeSum(nums: number[]): number {\\n  const sorted = nums.sort((a, b) => a - b);\\n  \\n  const n = sorted.length;\\n  // Firt two taken out\\n  const one = sorted[n - 1] - sorted[2];\\n  // Last two taken out\\n  const two = sorted[n - 3] - sorted[0];\\n  // First and last taken out\\n  const thr = sorted[n - 2] - sorted[1];\\n  \\n  return Math.min(one, two, thr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203164,
                "title": "javascript-sorting",
                "content": "https://github.com/toantd90/leetcode-js-solutions\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nfunction minimizeSum(nums) {\\n  const length = nums.length;\\n  if (length == 3) return 0;\\n\\n  nums.sort((n1, n2) => n1 - n2);\\n\\n  return Math.min(\\n    nums[length - 2] - nums[1],\\n    nums[length - 1] - nums[2],\\n    nums[length - 3] - nums[0]\\n  );\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nfunction minimizeSum(nums) {\\n  const length = nums.length;\\n  if (length == 3) return 0;\\n\\n  nums.sort((n1, n2) => n1 - n2);\\n\\n  return Math.min(\\n    nums[length - 2] - nums[1],\\n    nums[length - 1] - nums[2],\\n    nums[length - 3] - nums[0]\\n  );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203138,
                "title": "simple-ruby-solution",
                "content": "# Intuition\\nThe answer would seem to be, (1) change the two highest values to one of the remaining ones; (2) change the two lowest values to one of the remaining ones; or (3) change the highest & lowest values to one of the remaining ones.\\n\\n# Approach\\nSo, sort the array, and then take the minimum of those three cases (i.e., third highest - lowest, second highest - second lowest, highest - third lowest).\\n\\n# Complexity\\n- Time complexity:\\nAll of the time complexity comes from Ruby\\'s sort, which is presumably O(n log(n))\\n\\n- Space complexity:\\nSpace complexity is O(n)? No new space, it\\'s just what is allocated for the nums array and anything required for its sorting.\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef minimize_sum(nums)\\n    return 0 if nums.length < 4\\n    nums.sort!\\n    return [nums[-1]-nums[2], nums[-2]-nums[1], nums[-3]-nums[0]].min\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef minimize_sum(nums)\\n    return 0 if nums.length < 4\\n    nums.sort!\\n    return [nums[-1]-nums[2], nums[-2]-nums[1], nums[-3]-nums[0]].min\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3203131,
                "title": "python-heapq",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        qmin = []\\n        qmax = []\\n        for n in nums:\\n            if len(qmax) < 3:\\n                heapq.heappush(qmax, n)\\n            elif n > qmax[0]:\\n                n = heapq.heapreplace(qmax, n)\\n                if len(qmin) < 3:\\n                    heapq.heappush(qmin, -n)\\n                elif n < -qmin[0]:\\n                    heapq.heapreplace(qmin, -n)\\n            elif len(qmin) < 3:\\n                heapq.heappush(qmin, -n)\\n            elif n < -qmin[0]:\\n                    heapq.heapreplace(qmin, -n)\\n        nums = []\\n        while qmin:\\n            nums.append(-heapq.heappop(qmin))\\n        nums.reverse()\\n        while qmax:\\n            nums.append(heapq.heappop(qmax))\\n        return min(nums[-1] - nums[2], nums[-2] - nums[1], nums[-3] - nums[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        qmin = []\\n        qmax = []\\n        for n in nums:\\n            if len(qmax) < 3:\\n                heapq.heappush(qmax, n)\\n            elif n > qmax[0]:\\n                n = heapq.heapreplace(qmax, n)\\n                if len(qmin) < 3:\\n                    heapq.heappush(qmin, -n)\\n                elif n < -qmin[0]:\\n                    heapq.heapreplace(qmin, -n)\\n            elif len(qmin) < 3:\\n                heapq.heappush(qmin, -n)\\n            elif n < -qmin[0]:\\n                    heapq.heapreplace(qmin, -n)\\n        nums = []\\n        while qmin:\\n            nums.append(-heapq.heappop(qmin))\\n        nums.reverse()\\n        while qmax:\\n            nums.append(heapq.heappop(qmax))\\n        return min(nums[-1] - nums[2], nums[-2] - nums[1], nums[-3] - nums[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203055,
                "title": "python-sort",
                "content": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = nums[-1] - nums[0]\\n        ans = min(ans, nums[-1] - nums[2])\\n        ans = min(ans, nums[-2] - nums[1])\\n        ans = min(ans, nums[-3] - nums[0])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = nums[-1] - nums[0]\\n        ans = min(ans, nums[-1] - nums[2])\\n        ans = min(ans, nums[-2] - nums[1])\\n        ans = min(ans, nums[-3] - nums[0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203048,
                "title": "simple-c-solution-sorting-observation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        // for(auto & x: nums) cout<<x<<\" \"; cout<<\"\\\\n\";\\n        int ans= min(nums[nums.size()-1]-nums[2], nums[nums.size()-3]-nums[0]);\\n        ans=min(ans, nums[nums.size()-2]-nums[1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        // for(auto & x: nums) cout<<x<<\" \"; cout<<\"\\\\n\";\\n        int ans= min(nums[nums.size()-1]-nums[2], nums[nums.size()-3]-nums[0]);\\n        ans=min(ans, nums[nums.size()-2]-nums[1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3202999,
                "title": "python-1-line-solution-time-o-n",
                "content": "```\\ndef minimizeSum(self, nums: List[int]) -> int:\\n\\treturn min(x-y for x, y in zip(nlargest(3, nums), nsmallest(3, nums)[::-1]))\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimizeSum(self, nums: List[int]) -> int:\\n\\treturn min(x-y for x, y in zip(nlargest(3, nums), nsmallest(3, nums)[::-1]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3202994,
                "title": "python-solution-just-caught-the-intution",
                "content": "it is so frustrating and highly demotivating when u spend hours of time in one particular questions and u still didn\\'t catch the intutions behind it, it drives me so batty that it just thumps up my curiosity level , just to get to know the intutions behind it.\\nbtw its worth exploring to all the great solutions out there. \\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int: \\n        if len(nums) == 3:\\n            return 0 \\n        nums = sorted(nums) \\n        #1 change two largest number to smallest , btw minimum value of any pairs will always be zero in all the cases\\n        res1 = abs(nums[-3]-nums[0])   \\n\\n        #2 changing smallest and largest to second largest ans second smallest\\n        res2 = abs(nums[-2]-nums[1])  \\n        #3 changing both smallest to largest\\n        res3 = abs(nums[-1]-nums[2]) \\n\\n        return min(res1,min(res2,res3))\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums: List[int]) -> int: \\n        if len(nums) == 3:\\n            return 0 \\n        nums = sorted(nums) \\n        #1 change two largest number to smallest , btw minimum value of any pairs will always be zero in all the cases\\n        res1 = abs(nums[-3]-nums[0])   \\n\\n        #2 changing smallest and largest to second largest ans second smallest\\n        res2 = abs(nums[-2]-nums[1])  \\n        #3 changing both smallest to largest\\n        res3 = abs(nums[-1]-nums[2]) \\n\\n        return min(res1,min(res2,res3))\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202984,
                "title": "c-3-line",
                "content": "```\\nint minimizeSum(vector<int>& nums) {\\n    const int n = nums.size();\\n    sort(nums.begin(), nums.end());\\n    return min({nums[n-1]-nums[2], nums[n-2]-nums[1], nums[n-3]-nums[0]});\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minimizeSum(vector<int>& nums) {\\n    const int n = nums.size();\\n    sort(nums.begin(), nums.end());\\n    return min({nums[n-1]-nums[2], nums[n-2]-nums[1], nums[n-3]-nums[0]});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202944,
                "title": "simple-solution",
                "content": "# Approach\\nif we just sort it and check for the following cases:\\n1) replacing last and second last elemet with the third last element.\\n2) replacing last element with second last and first element with the second element.\\n3) replacing first and second element with the third element. \\n\\nThis way all the cases will be covered.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int> &nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n\\n        return min({nums[n-1]-nums[2], nums[n-3]-nums[0], nums[n-2]-nums[1]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int> &nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n\\n        return min({nums[n-1]-nums[2], nums[n-3]-nums[0], nums[n-2]-nums[1]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202900,
                "title": "100-faster-java-sol",
                "content": "My very first post -- like if it helps, thank you!\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmin - as long as we have 2 identical elements, it goes to 0 -- and it can always be done by using 1 \"change\" chance we have out of 2 to equalize one element to another.\\n\\nmax - to minimize it, we need to make the largest element as close to the smallest one as possible. To narrow down the \"range\"(max - min), we first need to find the current range by sorting the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n0) By default, if we have less than equal to 3 elements in the array, we always have min+max = 0, because we can always have 3 identical elements.\\n\\n1) Sort the array, now range = nums[nums.length - 1] - nums[0]\\n\\n2) Imagine the case where A,B,C,D,E,F,G are in increasing order;\\n\\nunsorted: D,B,C,A,E,G,F\\nsorted:   A,B,C,D,E,F,G\\n\\nto narrow the range, we can take a total of 2 steps on Left(A,B) or Right(F,G) and equalize the left to C or the right to E (and this mitigates \"min\"!).\\n\\nObviously, regardless of how many elements there are, moving beyond C and E is meaningless because it won\\'t affect the result anyhow.\\n\\n3) Now there are only 3 cases of range we may have, namely:\\n\\n(A,E)\\n(B,F)\\n(C,G)\\n\\nComparing the three, and the smallest one is the one we want to find.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        \\n        int l = nums.length;\\n        \\n        if (l <= 3){\\n            return 0;\\n        }\\n            \\n        Arrays.sort(nums);\\n        \\n        int case1 = nums[l - 1] - nums[2];\\n        int case2 = nums[l - 2] - nums[1];\\n        int case3 = nums[l - 3] - nums[0];\\n        \\n        if (case1 <= case2 && case1 <= case3){\\n            return case1;\\n        }\\n        \\n        if (case2 <= case1 && case2 <= case3){\\n            return case2;\\n        }\\n        \\n        if (case3 <= case1 && case3 <= case2){\\n            return case3;\\n        }\\n        \\n        return nums[l - 1] - nums[0];\\n        \\n        }\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        \\n        int l = nums.length;\\n        \\n        if (l <= 3){\\n            return 0;\\n        }\\n            \\n        Arrays.sort(nums);\\n        \\n        int case1 = nums[l - 1] - nums[2];\\n        int case2 = nums[l - 2] - nums[1];\\n        int case3 = nums[l - 3] - nums[0];\\n        \\n        if (case1 <= case2 && case1 <= case3){\\n            return case1;\\n        }\\n        \\n        if (case2 <= case1 && case2 <= case3){\\n            return case2;\\n        }\\n        \\n        if (case3 <= case1 && case3 <= case2){\\n            return case3;\\n        }\\n        \\n        return nums[l - 1] - nums[0];\\n        \\n        }\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202863,
                "title": "very-easy-explanation-intuition-explained",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n//one of these 3 cases contains the optimal solution\\n        int op1 = nums[n-1] - nums[2]; //convert 1st and 2nd digit to 3rd digit\\n        int op2 = nums[n-3] - nums[0]; //convert last and second last digit to third last digit\\n        int op3 = nums[n-2] - nums[1]; //convert first digit equal to second digit and last digit equal to second last digit\\n        \\n//minScore = min(low) + min(high)\\n//but min(low) is always 0 becaure 2 or more elements become equal in the vector\\n//thus minScore is min(high) only\\n        int minScore = min({op1,op2,op3});\\n        return minScore;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n//one of these 3 cases contains the optimal solution\\n        int op1 = nums[n-1] - nums[2]; //convert 1st and 2nd digit to 3rd digit\\n        int op2 = nums[n-3] - nums[0]; //convert last and second last digit to third last digit\\n        int op3 = nums[n-2] - nums[1]; //convert first digit equal to second digit and last digit equal to second last digit\\n        \\n//minScore = min(low) + min(high)\\n//but min(low) is always 0 becaure 2 or more elements become equal in the vector\\n//thus minScore is min(high) only\\n        int minScore = min({op1,op2,op3});\\n        return minScore;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202759,
                "title": "best-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        std::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return min({nums[n - 1] - nums[2], nums[n - 3] - nums[0], nums[n - 2] - nums[1]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        std::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return min({nums[n - 1] - nums[2], nums[n - 3] - nums[0], nums[n - 2] - nums[1]});\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3202739,
                "title": "java-sorting-solution",
                "content": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        if (nums.length <= 3) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        int value1 = nums[nums.length - 2] - nums[1];\\n        int value2 = nums[nums.length - 1] - nums[2];\\n        int value3 = nums[nums.length - 3] - nums[0];\\n        return Math.min(value1, Math.min(value2, value3));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeSum(int[] nums) {\\n        if (nums.length <= 3) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        int value1 = nums[nums.length - 2] - nums[1];\\n        int value2 = nums[nums.length - 1] - nums[2];\\n        int value3 = nums[nums.length - 3] - nums[0];\\n        return Math.min(value1, Math.min(value2, value3));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202672,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeSum(self, nums):\\n        nums.sort()\\n        return min(nums[-1]-nums[2],nums[-3]-nums[0],nums[-2]-nums[1])\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeSum(self, nums):\\n        nums.sort()\\n        return min(nums[-1]-nums[2],nums[-3]-nums[0],nums[-2]-nums[1])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202658,
                "title": "explanation-with-pictures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to cluster the values close to each other. If they are closer their difference will be minimum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe condition ```0 <= i < j < nums.length``` simply means that pick any two different elements.\\n \\nHence order does not matter and we can sort the values to get a increasing sequence.\\n\\nThe advantage of sorting is that **high** score is just the difference of first and last element. **low** score will be 0 since we can make two values equal to each other.\\n\\nWhich two values to pick??\\n3 cases are formed :-\\n- *values cluster towards left* : The difference between values on left is less as compared to right. Pick last two values and set them equal to any other value. low score is 0 and max score is difference between first and third-last element.\\n![left.jpg](https://assets.leetcode.com/users/images/b08c43c1-d129-44be-ae04-a93aa04d5808_1676743907.547565.jpeg)\\n\\n\\n- *values cluster towards right* : The difference between values on right is less as compared to left. Pick first two values and set them equal to any other value. low score is 0 and max score is difference between third and last element.\\n![right.jpg](https://assets.leetcode.com/users/images/61307596-9f23-4dff-b3b5-3ec8d2602082_1676743941.6874514.jpeg)\\n\\n\\n\\n- *values cluster towards center* : The difference of both left and right is higher but of middle is low. Pick first and last element and set them equal to any other value. low score is 0 and high score is difference of second and second-last element.\\n![center.jpg](https://assets.leetcode.com/users/images/7e925074-8bb8-4896-a400-5d6193acddf4_1676743968.5682106.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity: $$ O(nlogn) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end() );\\n\\n        int left = abs(nums[0] - nums[n-3])\\n        int right = abs(nums[2] - nums[n-1]);\\n        int center = abs(nums[1] - nums[n-2]);\\n        \\n        return min(left, min(right, center));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```0 <= i < j < nums.length```\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end() );\\n\\n        int left = abs(nums[0] - nums[n-3])\\n        int right = abs(nums[2] - nums[n-1]);\\n        int center = abs(nums[1] - nums[n-2]);\\n        \\n        return min(left, min(right, center));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202643,
                "title": "short-and-concise-c-solution-using-sorting-technique-2-3-lines-of-code-only",
                "content": "# Intuition\\nWe can see that we have to sort the array and we\\'ll easily find low score and high score.\\n\\n# Approach\\nAfter sorting the array, we have 3 ways to optimize this problem:\\n\\n- Increase nums[0], nums[1] equal to nums[2], now low=0, high=nums[n-1]-nums[2]\\n- Reduce nums[n-1], nums[n-2] equal to nums[n-3], now low=0, high=nums[n-3]-nums[0]\\n- Increase nums[0] equal to nums[1], nums[n-1] equal to nums[n-2], now low=0, high=nums[n-2]-nums[1]\\n\\n\\nSo we just need to choose the smallest high score\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        long long ans = min((nums[n-3]-nums[0]), min((nums[n-2]-nums[1]), nums[n-1]-nums[2]));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        long long ans = min((nums[n-3]-nums[0]), min((nums[n-2]-nums[1]), nums[n-1]-nums[2]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202533,
                "title": "sorting",
                "content": "```ruby\\ndef minimize_sum a\\n    a.size < 4 ? 0 : begin\\n        a.sort!\\n        3.times.map { a[-3 + _1] - a[0 + _1] } .min\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef minimize_sum a\\n    a.size < 4 ? 0 : begin\\n        a.sort!\\n        3.times.map { a[-3 + _1] - a[0 + _1] } .min\\n    end\\nend\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1805826,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1805617,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1806991,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1805620,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1806871,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1805746,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1805604,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 2013127,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1940384,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1935280,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1805826,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1805617,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1806991,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1805620,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1806871,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1805746,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1805604,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 2013127,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1940384,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            },
            {
                "id": 1935280,
                "content": [
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "how is this coding problem?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "why are you disliking the problem?\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "do the whole leetcode community a favor, please consider to click the downvoting button!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Done"
                    },
                    {
                        "username": "Arcturus-",
                        "content": "Looking at the problem description, I don\\'t understand how we could have deduced that we were allowed to sort the array. I suppose it has something to do with the line:-\\n|nums[i] - nums[j]|  over all 0 <= i < j < nums.length\\nCan anyone please provide an explanation?"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "Same here. "
                    },
                    {
                        "username": "Arcturus-",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) Got It.Thanks!"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "We can sort the array as we aren't forming a subsequence or an list, we are just interested in forming pairs and then simply take their absolute difference so there's nothing here like 'LOSING THE ORDER'\nEx- 2 4 1\npossible pairs {2,4} {2,1} {4,1}\nSorted-> 1 2 4\npossible pairs {1,2} {1,4} {2,4} \nHope you get it "
                    },
                    {
                        "username": "husain_fr",
                        "content": "Can someone explain why the input array [31, 25, 72, 79, 74, 65] gives a minimum score of 14 in the context of the problem description?"
                    },
                    {
                        "username": "hong-quang-hung",
                        "content": "I think the description can be understand is remove two numers minimize. And find max distance of them, doesn\\'t it ?"
                    },
                    {
                        "username": "husain_fr",
                        "content": "[@Limbobo](/Limbobo)  ok!! thank you!\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "the same arr but sorted: [25, 31, 65, 72, 74, 79]\\nfirst two number change to 66 for example, it means that min = 66 - 66 = 0, max = 79 - 65 = 14"
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Why is this question getting so much hate?"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "no proper test cases \\n"
                    },
                    {
                        "username": "amit24x",
                        "content": "If anyone have doubt regarding [31,25,72,79,74,65] this test case, then,\\nif you change first two element to 74 then, array became [[74,74,72,79,74,65], whereas minval => 74-74 = 0 and maxval =   |79-65|  as in question mod are allow so answer is 14. that\\'s all\\n\\nhope you understand"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "because index ordering in this question matters"
                    },
                    {
                        "username": "miraj2399",
                        "content": "[31,25,72,79,74,65] expected = 14. How?\\n\"Return the minimum possible score after changing the value of at most two elements of nums.\" without changing anything, shouldn\\'t the answer be 11?"
                    },
                    {
                        "username": "osman93",
                        "content": "[@miraj2399](/miraj2399) In your calculation, there is no calculation of a maximum value. As I understand, you just chose 4 values such that sum of their differences will be minimum but that is not what the question asks. Once an array is given to you, the max difference and min differences are already set. You just have to change the given array here such that this maximum should be as small as possible amongst all alternatives.\\n\\nYou can also think that as finding the width of the interval of numbers since the maximum difference is equal to the difference between the maximum and minimum elements of the array. Consider the case [4,5,6,7,100]. The maximum difference here is 100-4=96. Now assume I am allowed to change 1 element of the array so that this maximum difference can be minimized. I think it is obvious that I should either change the first or the last element in this case. If I change the first value of 4 and set its new value to something in between the remaining interval of [5,100], the new maximum difference will be 100-5=95. This is less than the previous maximum difference but not with a large margin. On the other hand, the last element 100 is largely different from the remaining elements and if I update it instead, the new interval will be [4,7] and the maximum difference will be 7-4=3. This is the minimum possible alternative for maximum differences and solution to the problem."
                    },
                    {
                        "username": "miraj2399",
                        "content": "[@osman93](/osman93) \"after changing the value of at most two elements of nums\", that means i can change 0,1 or 2 elements. and changing 0 elements( no change) give the result that minimize the answer. That is how I come up with 11. (79-74)+(31-25)=11\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "check comment: https://leetcode.com/problems/minimum-score-by-changing-two-elements/discussion/comments/1805661"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello [@miraj2399](/miraj2399). I do not understand where you found the 11 but at least, let me clarify the situation for the 14 case. The minimums can be provided to be 0 everytime(trivial). What we have to do is changing two elements such that after the change, the maximum difference of the remaining element is the minimum possible. In this case changing the values of 25 and 31 into a value within interval [65,79] guarantees this and maximum is found by 79-65=14. I hope it is clear for you now."
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "The minimum possible value of the low score is 0, which can be achieved by introducing a duplicate. Consider changing to values already present in the array, then reduce the high score."
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "how is the answer for [59,27,9,81,33] is 24 if we convert 9  to 27  and 81 to 59 answer would be 33. how it is 24? "
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Change 59 and 81 to 33"
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "La descripci\\xF3n del problema en LeetCode podr\\xEDa ser m\\xE1s clara al explicar c\\xF3mo cambiar los elementos para minimizar el puntaje. Adem\\xE1s, la ambig\\xFCedad en las soluciones y las posibles inconsistencias en las pruebas podr\\xEDan dificultar la resoluci\\xF3n. Ser\\xEDa \\xFAtil mejorar la descripci\\xF3n, aclarar las soluciones aceptables y asegurar la precisi\\xF3n de los casos de prueba."
                    }
                ]
            }
        ]
    }
]