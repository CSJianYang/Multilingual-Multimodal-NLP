[
    {
        "title": "Number of Beautiful Partitions",
        "question_content": "You are given a string s that consists of the digits '1' to '9' and two integers k and minLength.\nA partition of s is called beautiful if:\n\n\ts is partitioned into k non-intersecting substrings.\n\tEach substring has a length of at least minLength.\n\tEach substring starts with a prime digit and ends with a non-prime digit. Prime digits are '2', '3', '5', and '7', and the rest of the digits are non-prime.\n\nReturn the number of beautiful partitions of s. Since the answer may be very large, return it modulo 109 + 7.\nA substring is a contiguous sequence of characters within a string.\n&nbsp;\nExample 1:\n\nInput: s = \"23542185131\", k = 3, minLength = 2\nOutput: 3\nExplanation: There exists three ways to create a beautiful partition:\n\"2354 | 218 | 5131\"\n\"2354 | 21851 | 31\"\n\"2354218 | 51 | 31\"\n\nExample 2:\n\nInput: s = \"23542185131\", k = 3, minLength = 3\nOutput: 1\nExplanation: There exists one way to create a beautiful partition: \"2354 | 218 | 5131\".\n\nExample 3:\n\nInput: s = \"3312958\", k = 3, minLength = 1\nOutput: 1\nExplanation: There exists one way to create a beautiful partition: \"331 | 29 | 58\".\n\n&nbsp;\nConstraints:\n\n\t1 <= k, minLength <= s.length <= 1000\n\ts consists of the digits '1' to '9'.",
        "solutions": [
            {
                "id": 2833126,
                "title": "c-python-short-dp-explained",
                "content": "# Intuition\\nWe will have to use dynamic programming because there are overlapping subproblems. n^3 dp will fail due to time constraints. To use n^2 dp we will keep a flag `at_start` which means that the substring starts at this point and as per the question the start should be prime.\\n\\n# Approach\\nDP\\n* The DP state is defined by `i`, `at_start` and `k`. `i` ranges from 0 to length of s, `at_start` is true of false and `k` ranges from k to 0. Hence time complexity = (length of s) * 2 * k\\n* If we reach the end of string (i == n) return k == 0 which means that we have exactly `k` substrings\\n* If `i > n` or `k` is prematurely 0 or s[i] is not a prime number and we are at start of string we return 0\\n* If s[i] is a prime number and we are at start of string move minLength characters ahead\\n* If s[i] is a prime number and we are *not* at start of string return the (i + 1) state because we cannot end the substring here\\n* If s[i] is not prime we can either set this as end of current substring or continue making the current substring longer. We sum both these cases and return the result\\n\\n# Complexity\\n- Time complexity: O(nk)\\n\\n- Space complexity: O(nk)\\n\\n# Code\\n**Python3**\\n```\\ndef beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n    n, primes, mod = len(s), set(\\'2357\\'), (10 ** 9) + 7\\n    @cache\\n    def dp(i, at_start, k):\\n        if i == n: return int(k == 0)\\n        if i > n or k == 0 or s[i] not in primes and at_start: return 0\\n        if s[i] in primes:\\n            if at_start: return dp(i + minLength - 1, False, k)\\n            else: return dp(i + 1, False, k)\\n        return (dp(i + 1, True, k - 1) + dp(i + 1, False, k)) % mod\\n    return dp(0, True, k)\\n```\\n\\n**C++**\\n```\\nunordered_set<char> prime {\\'2\\', \\'3\\', \\'5\\', \\'7\\'};\\nint mod = 1e9 + 7, minLength, dp[1001][2][1001]; \\nint beautifulPartitions(string s, int k, int ml) {\\n    minLength = ml;\\n    memset(dp, -1, sizeof dp);\\n    return dfs(0, true, k, s);\\n}\\nint dfs(int i, bool at_start, int k, string& s, int ans = 0) {\\n    if (i == s.size()) return k == 0;\\n    if (i > s.size() || k == 0 || !prime.count(s[i]) && at_start) return 0;\\n    if (dp[i][at_start][k] != -1) return dp[i][at_start][k];\\n    if (prime.count(s[i])) {\\n        if (at_start) ans = dfs(i + minLength - 1, false, k, s);\\n        else ans = dfs(i + 1, false, k, s);\\n    }\\n    else ans = (dfs(i + 1, true, k - 1, s) + dfs(i + 1, false, k, s)) % mod;\\n    return dp[i][at_start][k] = ans;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\ndef beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n    n, primes, mod = len(s), set(\\'2357\\'), (10 ** 9) + 7\\n    @cache\\n    def dp(i, at_start, k):\\n        if i == n: return int(k == 0)\\n        if i > n or k == 0 or s[i] not in primes and at_start: return 0\\n        if s[i] in primes:\\n            if at_start: return dp(i + minLength - 1, False, k)\\n            else: return dp(i + 1, False, k)\\n        return (dp(i + 1, True, k - 1) + dp(i + 1, False, k)) % mod\\n    return dp(0, True, k)\\n```\n```\\nunordered_set<char> prime {\\'2\\', \\'3\\', \\'5\\', \\'7\\'};\\nint mod = 1e9 + 7, minLength, dp[1001][2][1001]; \\nint beautifulPartitions(string s, int k, int ml) {\\n    minLength = ml;\\n    memset(dp, -1, sizeof dp);\\n    return dfs(0, true, k, s);\\n}\\nint dfs(int i, bool at_start, int k, string& s, int ans = 0) {\\n    if (i == s.size()) return k == 0;\\n    if (i > s.size() || k == 0 || !prime.count(s[i]) && at_start) return 0;\\n    if (dp[i][at_start][k] != -1) return dp[i][at_start][k];\\n    if (prime.count(s[i])) {\\n        if (at_start) ans = dfs(i + minLength - 1, false, k, s);\\n        else ans = dfs(i + 1, false, k, s);\\n    }\\n    else ans = (dfs(i + 1, true, k - 1, s) + dfs(i + 1, false, k, s)) % mod;\\n    return dp[i][at_start][k] = ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2831925,
                "title": "dp-basic-to-prefix-sum-optimization-o-k-n-2-to-o-k-n",
                "content": "### **State of DP:**\\n**dp[i][j] = # (number of) of ways to create `i` non-intersecting substrings using index from `0` to `j`**\\n\\n### **Transition of DP:**\\n```cpp\\n// since we want our substring to be of length atleast minLength, it must start from atleast \\n// (previous number of substrings * minLength) and end \\n// at max index: end - minLength\\n\\nfor startingIndex = [ ((i - 1) * minLength) - 1,  end - minLength ]\\n\\t\\t\\tif (isPrime(startingIndex) and not isPrime(end)):\\n\\t\\t\\t\\t\\tdp[i][end] += dp[i-1][startingIndex-1]\\n```\\n\\n### Base Case:\\n```\\n// for string of length 1 using s[0, j]\\ndp[1][j] = isPrime(s[0]) and not isPrime(s[j])\\n```\\n\\n### **Time Complexity: O(K * N^2)**\\n```cpp\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7;\\n    unordered_set<char> p = {\\'2\\', \\'3\\', \\'5\\', \\'7\\'};\\n\\n    bool isPrime(int x) {return (p.find(x) != p.end());}\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(k + 1, vector<long long>(n, 0LL));\\n        for (int j = 0; j < n; ++j) {\\n            dp[1][j] = (isPrime(s[0]) and !isPrime(s[j]));\\n        }\\n        for (int i = 2; i <= k; ++i) {\\n            for (int end = (i * minLength) - 1; end < n; ++end) {\\n                if (isPrime(s[end])) continue;\\n                for (int start = ((i - 1) * minLength) - 1; start <= (end - minLength); ++start) { \\n\\t\\t\\t\\t// we will reduce this loop to O(1) using prefix sum calculation in solution below\\n                    if (isPrime(s[start + 1])) {\\n                        dp[i][end] = (dp[i][end] + dp[i - 1][start]) % mod;\\n                    }\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Notice in the inner-most for loop, we need sum of values in the column range [((i - 1) * minLength) - 1, (end - minLength)]\\n\\t\\t\\t\\t// IF AND ONLY IF the next_index is capable of starting a valid substring\\n            }\\n        }\\n        return dp[k][n - 1];\\n    }\\n};\\n```\\n\\n\\n### **Prefix Sum Optimization**\\nNotice these `2` following facts:\\n1. `dp[i][j]` requires summation of only `dp[i-1][some_index]`. i.e. we only need some values of previous row to calculate current row\\n2. Those `some_index` are the indices which satisfies the condition of `isPrime(some_index + 1) == true`. \\n\\n```cpp\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7;\\n    unordered_set<char> p = {\\'2\\', \\'3\\', \\'5\\', \\'7\\'};\\n\\n    bool isPrime(int x) {return (p.find(x) != p.end());}\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(k + 1, vector<long long>(n, 0LL));\\n        for (int j = 0; j < n; ++j) {\\n            dp[1][j] = (isPrime(s[0]) and !isPrime(s[j]));\\n        }\\n        vector<long long> previous_row(n, 0);\\n        for (int i = 0; i + 1 < n; ++i) {\\n            if (isPrime(s[i + 1])) previous_row[i] = dp[1][i];  // update IFF next_index is prime and capable of starting a substring\\n            if (i - 1 >= 0) previous_row[i] = (previous_row[i] + previous_row[i - 1]) % mod;\\n        }\\n        for (int i = 2; i <= k; ++i) {\\n            vector<long long> current_row(n, 0LL);\\n            for (int end = (i * minLength) - 1; end < n; ++end) {\\n                if (isPrime(s[end])) continue;\\n\\n                // optimization usage\\n                long long prefixsum = previous_row[end - minLength];\\n                int start = ((i - 1) * minLength) - 1;\\n                if (start - 1 >= 0) prefixsum = (prefixsum - previous_row[start - 1] + mod) % mod;\\n                dp[i][end] = (dp[i][end] + prefixsum) % mod;\\n                \\n                // update current_row\\'s column only if the next_index is a prime and capable of starting a substring\\n                if (end + 1 < n and isPrime(s[end + 1])) current_row[end] = (current_row[end] + dp[i][end]) % mod;\\n            }\\n            // re-calclate prefix sum of current row dp values for each column\\n            for (int c = 1; c <= n - 1; ++c) {\\n                current_row[c] = (current_row[c] + current_row[c - 1]) % mod;\\n            }\\n\\n            // swap previous_row dp values and current_row dp values. why ?\\n            // Because current row will become previous row for next row\\n            swap(previous_row, current_row);\\n        }\\n        return dp[k][n - 1];\\n    }\\n};\\n```\\n\\n### **Time Complexity: O(N * K)**\\n### **Space Complexity: O(N * K)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```cpp\\n// since we want our substring to be of length atleast minLength, it must start from atleast \\n// (previous number of substrings * minLength) and end \\n// at max index: end - minLength\\n\\nfor startingIndex = [ ((i - 1) * minLength) - 1,  end - minLength ]\\n\\t\\t\\tif (isPrime(startingIndex) and not isPrime(end)):\\n\\t\\t\\t\\t\\tdp[i][end] += dp[i-1][startingIndex-1]\\n```\n```\\n// for string of length 1 using s[0, j]\\ndp[1][j] = isPrime(s[0]) and not isPrime(s[j])\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7;\\n    unordered_set<char> p = {\\'2\\', \\'3\\', \\'5\\', \\'7\\'};\\n\\n    bool isPrime(int x) {return (p.find(x) != p.end());}\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(k + 1, vector<long long>(n, 0LL));\\n        for (int j = 0; j < n; ++j) {\\n            dp[1][j] = (isPrime(s[0]) and !isPrime(s[j]));\\n        }\\n        for (int i = 2; i <= k; ++i) {\\n            for (int end = (i * minLength) - 1; end < n; ++end) {\\n                if (isPrime(s[end])) continue;\\n                for (int start = ((i - 1) * minLength) - 1; start <= (end - minLength); ++start) { \\n\\t\\t\\t\\t// we will reduce this loop to O(1) using prefix sum calculation in solution below\\n                    if (isPrime(s[start + 1])) {\\n                        dp[i][end] = (dp[i][end] + dp[i - 1][start]) % mod;\\n                    }\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Notice in the inner-most for loop, we need sum of values in the column range [((i - 1) * minLength) - 1, (end - minLength)]\\n\\t\\t\\t\\t// IF AND ONLY IF the next_index is capable of starting a valid substring\\n            }\\n        }\\n        return dp[k][n - 1];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7;\\n    unordered_set<char> p = {\\'2\\', \\'3\\', \\'5\\', \\'7\\'};\\n\\n    bool isPrime(int x) {return (p.find(x) != p.end());}\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(k + 1, vector<long long>(n, 0LL));\\n        for (int j = 0; j < n; ++j) {\\n            dp[1][j] = (isPrime(s[0]) and !isPrime(s[j]));\\n        }\\n        vector<long long> previous_row(n, 0);\\n        for (int i = 0; i + 1 < n; ++i) {\\n            if (isPrime(s[i + 1])) previous_row[i] = dp[1][i];  // update IFF next_index is prime and capable of starting a substring\\n            if (i - 1 >= 0) previous_row[i] = (previous_row[i] + previous_row[i - 1]) % mod;\\n        }\\n        for (int i = 2; i <= k; ++i) {\\n            vector<long long> current_row(n, 0LL);\\n            for (int end = (i * minLength) - 1; end < n; ++end) {\\n                if (isPrime(s[end])) continue;\\n\\n                // optimization usage\\n                long long prefixsum = previous_row[end - minLength];\\n                int start = ((i - 1) * minLength) - 1;\\n                if (start - 1 >= 0) prefixsum = (prefixsum - previous_row[start - 1] + mod) % mod;\\n                dp[i][end] = (dp[i][end] + prefixsum) % mod;\\n                \\n                // update current_row\\'s column only if the next_index is a prime and capable of starting a substring\\n                if (end + 1 < n and isPrime(s[end + 1])) current_row[end] = (current_row[end] + dp[i][end]) % mod;\\n            }\\n            // re-calclate prefix sum of current row dp values for each column\\n            for (int c = 1; c <= n - 1; ++c) {\\n                current_row[c] = (current_row[c] + current_row[c - 1]) % mod;\\n            }\\n\\n            // swap previous_row dp values and current_row dp values. why ?\\n            // Because current row will become previous row for next row\\n            swap(previous_row, current_row);\\n        }\\n        return dp[k][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833244,
                "title": "python-top-down-dp-clean-concise-o-n-k",
                "content": "# Intuition\\nFor each position, we have 2 options:\\n- Do not split on that position.\\n- Split on that position if we can (`s[i]` is prime, and `s[i - 1]` is non-prime).\\nNote that, after the split, we need to advance `i` by `minLength`.\\n\\n# Complexity\\n- Time complexity: `O(N * K)`, where `N <= 1000` is length of string `s`, `K <= N`\\n- Space complexity: `O(N * K)`\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n = len(s)\\n        MOD = 10**9 + 7\\n\\n        def isPrime(c):\\n            return c in [\\'2\\', \\'3\\', \\'5\\', \\'7\\']\\n\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if k == 0 and i <= n:\\n                return 1\\n            if i >= n:\\n                return 0\\n\\n            ans = dp(i+1, k)  # Skip\\n            if isPrime(s[i]) and not isPrime(s[i-1]):  # Split\\n                ans += dp(i+minLength, k-1)\\n            return ans % MOD\\n\\n        if not isPrime(s[0]) or isPrime(s[-1]): return 0\\n\\n        return dp(minLength, k-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n = len(s)\\n        MOD = 10**9 + 7\\n\\n        def isPrime(c):\\n            return c in [\\'2\\', \\'3\\', \\'5\\', \\'7\\']\\n\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if k == 0 and i <= n:\\n                return 1\\n            if i >= n:\\n                return 0\\n\\n            ans = dp(i+1, k)  # Skip\\n            if isPrime(s[i]) and not isPrime(s[i-1]):  # Split\\n                ans += dp(i+minLength, k-1)\\n            return ans % MOD\\n\\n        if not isPrime(s[0]) or isPrime(s[-1]): return 0\\n\\n        return dp(minLength, k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832416,
                "title": "c-recursive-dp-solution-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Dynamic Programming* approach to find and count beautiful partitions. Time complexity is **O(N\\\\*N\\\\*K)**. Space complexity is **O(N\\\\*K)**.\\n****\\n\\n**Comment.** The same solution in Python gives TLE, thus, I provide it in C++.\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    int beautifulPartitions(string s, int k, int m) \\n    {\\n        int primes[10] = {0,0,1,1,0,1,0,1,0,0};                   // fast detection of primes\\n        int n = s.size(), mod = 1000000007;\\n        \\n        int dp[1001][1001];                                       // 2D cache for recursive DP \\n        fill_n(&dp[0][0], 1001*1001, -1);                         // filled with -1 for \\'not seen\\'\\n        \\n        function<int(int,int)> dfs;                               // this recursive function computes\\n        dfs = [&](int i, int k) -> int                            // the number of beautiful partitions \\n        {                                                         // of \\'s\\' starting from position \\'i\\'\\n            if (dp[i][k] != -1) return dp[i][k];                  // using memoization/cache dp[i][k]\\n            \\n            if (k == 1)                                           // [1] for last partition, return 1 if there\\n                return dp[i][k] = n >= m + i;                     //     is at least m terminal digits, else 0\\n            \\n            if (i + m * k > n)                                    // [2] the number of remaining digits is not\\n                return dp[i][k] = 0;                              //     enough to cover k partitions of size m\\n            \\n            int res = 0;                                          // [3] scan valid initial positions \\'j\\' of the next\\n            for (int j = i+m; j <= n-m*(k-1); ++j)                //     partition and recursively update state;\\n                if (!primes[s[j-1]-\\'0\\'] and primes[s[j]-\\'0\\'])     //     there is no point to consider the full range\\n                    res = (res + dfs(j, k-1)) % mod;              //     for j (same as in [2], but 1 partition less)\\n            \\n            return dp[i][k] = res;\\n        };\\n        \\n        if (!primes[s[0]-\\'0\\'] or primes[s[n-1]-\\'0\\'])             // consider trivial cases when either\\n            return 0;                                            // initial or terminal digit is invalid\\n        \\n        return dfs(0,k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int beautifulPartitions(string s, int k, int m) \\n    {\\n        int primes[10] = {0,0,1,1,0,1,0,1,0,0};                   // fast detection of primes\\n        int n = s.size(), mod = 1000000007;\\n        \\n        int dp[1001][1001];                                       // 2D cache for recursive DP \\n        fill_n(&dp[0][0], 1001*1001, -1);                         // filled with -1 for \\'not seen\\'\\n        \\n        function<int(int,int)> dfs;                               // this recursive function computes\\n        dfs = [&](int i, int k) -> int                            // the number of beautiful partitions \\n        {                                                         // of \\'s\\' starting from position \\'i\\'\\n            if (dp[i][k] != -1) return dp[i][k];                  // using memoization/cache dp[i][k]\\n            \\n            if (k == 1)                                           // [1] for last partition, return 1 if there\\n                return dp[i][k] = n >= m + i;                     //     is at least m terminal digits, else 0\\n            \\n            if (i + m * k > n)                                    // [2] the number of remaining digits is not\\n                return dp[i][k] = 0;                              //     enough to cover k partitions of size m\\n            \\n            int res = 0;                                          // [3] scan valid initial positions \\'j\\' of the next\\n            for (int j = i+m; j <= n-m*(k-1); ++j)                //     partition and recursively update state;\\n                if (!primes[s[j-1]-\\'0\\'] and primes[s[j]-\\'0\\'])     //     there is no point to consider the full range\\n                    res = (res + dfs(j, k-1)) % mod;              //     for j (same as in [2], but 1 partition less)\\n            \\n            return dp[i][k] = res;\\n        };\\n        \\n        if (!primes[s[0]-\\'0\\'] or primes[s[n-1]-\\'0\\'])             // consider trivial cases when either\\n            return 0;                                            // initial or terminal digit is invalid\\n        \\n        return dfs(0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831654,
                "title": "0-1-knapsack",
                "content": "The original solution below may be easier to understand the logic. That solution is slow, as the complexity cubic.\\n\\nThe optimized solution transforms the original logic into 0-1 Knapsack. For each position, we explore two cases:\\n- Do not split on that position.\\n- Split on that position if we can (`s[i]` is prime, and `s[i - 1]` - non-prime).\\n\\nNote that, after the split, we need to advance `i` by `minLength`.\\n\\n#### Optimized Solution\\n**C++**\\n```cpp\\nint dp[1001][1000] = {};\\nbool isPrime(char ch) {\\n    return ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\' || ch == \\'7\\';\\n}\\nint dfs(int i, int k, int len, string &s) {\\n    if (i > s.size())\\n        return 0;    \\n    if (k == 0)\\n        return 1;\\n    if (dp[i][k] == 0) {\\n        dp[i][k] = 1 + dfs(i + 1, k, len, s);\\n        if (isPrime(s[i]) && !isPrime(s[i - 1]))\\n            dp[i][k] = (dp[i][k] + dfs(i + len, k - 1, len, s)) % 1000000007;\\n    }\\n    return dp[i][k] - 1;\\n}\\nint beautifulPartitions(string s, int k, int minLength) {\\n    return isPrime(s.front()) && !isPrime(s.back()) ? dfs(minLength, k - 1, minLength, s) : 0;\\n}\\n```\\n#### Original Solution\\n**C++**\\n```cpp\\nint dp[1001][1001] = {};\\nbool isPrime(char ch) {\\n    return ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\' || ch == \\'7\\';\\n}\\nint dfs(int i, int k, int len, string &s) {\\n    if (k == 0)\\n        return i == s.size();\\n    if (i + len * k > s.size() || !isPrime(s[i]))\\n        return 0;\\n    if (dp[i][k] == 0) {\\n        dp[i][k] = 1;\\n        for (int j = i + len - 1; j < s.size(); ++j)\\n            if (!isPrime(s[j]))\\n                dp[i][k] = (dp[i][k] + dfs(j + 1, k - 1, len, s)) % 1000000007;\\n    }\\n    return dp[i][k] - 1;\\n}\\nint beautifulPartitions(string s, int k, int minLength) {\\n    return dfs(0, k, minLength, s);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[1001][1000] = {};\\nbool isPrime(char ch) {\\n    return ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\' || ch == \\'7\\';\\n}\\nint dfs(int i, int k, int len, string &s) {\\n    if (i > s.size())\\n        return 0;    \\n    if (k == 0)\\n        return 1;\\n    if (dp[i][k] == 0) {\\n        dp[i][k] = 1 + dfs(i + 1, k, len, s);\\n        if (isPrime(s[i]) && !isPrime(s[i - 1]))\\n            dp[i][k] = (dp[i][k] + dfs(i + len, k - 1, len, s)) % 1000000007;\\n    }\\n    return dp[i][k] - 1;\\n}\\nint beautifulPartitions(string s, int k, int minLength) {\\n    return isPrime(s.front()) && !isPrime(s.back()) ? dfs(minLength, k - 1, minLength, s) : 0;\\n}\\n```\n```cpp\\nint dp[1001][1001] = {};\\nbool isPrime(char ch) {\\n    return ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\' || ch == \\'7\\';\\n}\\nint dfs(int i, int k, int len, string &s) {\\n    if (k == 0)\\n        return i == s.size();\\n    if (i + len * k > s.size() || !isPrime(s[i]))\\n        return 0;\\n    if (dp[i][k] == 0) {\\n        dp[i][k] = 1;\\n        for (int j = i + len - 1; j < s.size(); ++j)\\n            if (!isPrime(s[j]))\\n                dp[i][k] = (dp[i][k] + dfs(j + 1, k - 1, len, s)) % 1000000007;\\n    }\\n    return dp[i][k] - 1;\\n}\\nint beautifulPartitions(string s, int k, int minLength) {\\n    return dfs(0, k, minLength, s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2834170,
                "title": "16ms-100-dp-easy-to-understand-dfs-memo-java",
                "content": "# DFS+MEMO\\n- First we identify all the indices that you can make a cut, a non-prime number followed by a prime number\\n\\t- Save these indices to a separate list.\\n- It becomes a question of which combination of indices you want to select to satisify the two conditions:\\n\\t-  each partition has a length >= minLength\\n\\t-  Total number of partitions are exactly k\\n\\t\\t-  This means you select k-1 valid begin indices within the array, 1st begin is always 0\\n-  Complexity, where m is the number of valid indices for making a cut\\n\\t-  TC: O(k * m)\\n\\t-  SC:  O(k * m)\\n## Code\\n```java\\nclass Solution {\\n    private static int M = 1_000_000_007;\\n    private static boolean[] P = new boolean[10];\\n    public int beautifulPartitions(String s, int k, int minL) {\\n        int n = s.length();\\n        if (minL*k > n) return 0; // corner case 1: total length is not enough\\n\\n        P[2] = P[3] = P[5] = P[7] = true;\\n        if (!P[s.charAt(0)-\\'0\\'] || P[s.charAt(n-1)-\\'0\\']) return 0; // corner case 2: beginning or end is not valid\\n        if (k == 1) return 1; //  corner case 3\\n\\n        List<Integer> begins = getValidBeginIndices(s, n, minL);\\n        int m = begins.size();\\n        if (m < k - 1) return 0; // corner case 4\\n\\n        int[][] dp = new int[k][m];\\n        for (var _a : dp) Arrays.fill(_a, -1); // -1 means not visited\\n\\n        return dfs(begins, k-1, 0, 0, minL, dp); // select k-1 indices within array\\n    }\\n\\n    private int dfs(List<Integer> begins, int k, int idx, int pre, int len, int[][] dp) {\\n        if (k == 0) return 1; // selected everything\\n        if (dp[k][idx] > -1) return dp[k][idx];\\n\\n        dp[k][idx] = 0; // do not select current\\n        for (int i = idx; i <= begins.size()-k; i++) { // making sure there\\'s enough left\\n            int cur = begins.get(i);\\n            if (cur - pre < len) continue;\\n            dp[k][idx] = (dp[k][idx] + dfs(begins, k-1, i+1, cur, len, dp)) % M;\\n        }\\n\\n        return dp[k][idx];\\n    }\\n\\n    private List<Integer> getValidBeginIndices(String s, int n, int minL) {\\n        List<Integer> begins = new ArrayList<>(n / 2 + 1);\\n        for (int i = minL; i <= n - minL; i++) // find all valid beginning index\\n            if (P[s.charAt(i)-\\'0\\'] && !P[s.charAt(i - 1)-\\'0\\']) begins.add(i);\\n        return begins;\\n    }\\n}\\n```\\n# [18ms 100% DP](https://leetcode.com/submissions/detail/847896444/)\\n- dp[i-1][j] means number of Beautiful Partitions for partitioning substring [0, j) into i-1 partitions\\n\\t- when j is a valid end, dp[i][j] will come from sum of dp[i-1][pre], where pre is a good previous cut and at least minLength apart from j\\n\\t- There you go with dp[k][n]\\n- TC: O(k * (n - minLength)\\n- SC: O(n * k)\\n\\n```java\\nclass Solution {\\n    public int beautifulPartitions(String s, int k, int minL) {\\n        int n = s.length();\\n        if (minL*k > n) return 0; // corner case 1: total length is not enough\\n\\n        boolean[] P = new boolean[10];\\n        P[2] = P[3] = P[5] = P[7] = true;\\n\\n        if (!P[s.charAt(0)-\\'0\\'] || P[s.charAt(n-1)-\\'0\\']) return 0; // corner case 2: beginning or end is not valid\\n\\n        List<Integer> cuts = new ArrayList<>();\\n        cuts.add(0); // first beginning index\\n        for (int i = minL; i <= n-minL; i++)\\n            if (P[s.charAt(i)-\\'0\\'] && !P[s.charAt(i-1)-\\'0\\']) cuts.add(i); // each possible beginning index\\n\\n        if (cuts.size() < k) return 0; // corner case 3\\n\\n        int[][] dp = new int[k][cuts.size()];\\n        for (var _a : dp) Arrays.fill(_a, -1); // -1 means not visited\\n\\n        return dfs(cuts, k-1, 0, minL, dp);\\n    }\\n\\n    private int dfs(List<Integer> cuts, int k, int pre, int len, int[][] dp) {\\n        if (k == 0) return 1; // enough length for last segment\\n        if (dp[k][pre] > -1) return dp[k][pre];\\n\\n        dp[k][pre] = 0;\\n        // size: 10, k: 3, i can go up to: 10-3=7, so that we have 7~9 -> k options \\n        for (int i = pre+1; i <= cuts.size()-k; i++) {\\n            if (cuts.get(i) - cuts.get(pre) < len) continue;\\n            dp[k][pre] = (dp[k][pre] + dfs(cuts, k-1, i, len, dp)) % 1_000_000_007;\\n        }\\n\\n        return dp[k][pre];\\n    }\\n}\\n```\\n# [16ms DP, over engineering](https://leetcode.com/submissions/detail/847721032/)\\n[17ms](https://leetcode.com/submissions/detail/847753735/)\\n16ms and 17ms are using the same logic, very minor implementation difference\\n```java\\nclass Solution {\\n    private static boolean[] P = new boolean[10];\\n    private static int M = 1_000_000_007;\\n    public int beautifulPartitions(String s, int k, int minL) {\\n        int n = s.length();\\n        P[2] = P[3] = P[5] = P[7] = true;\\n        if (!P[s.charAt(0)-\\'0\\'] || P[s.charAt(n-1)-\\'0\\']) return 0; // early termination\\n\\n        return beautifulPartitions(getPre(s, n, minL), k, minL); // actual DP, above are prep work\\n    }\\n\\n    private int beautifulPartitions(int[] pre, int k, int minL) {\\n        int n = pre.length;\\n        int[][] dp = new int[k][n]; \\n\\n        for (int j = 1; j < n; j++) dp[0][j] = 1; // making 1 partition\\n        for (int i = 1; i < k; i++) { // making 2 to k partitions\\n            int[] psum = new int[n];\\n            for (int j = i; j < n; j++) { // for i partitions, len is at least minL * i\\n                psum[j] = (psum[j-1] + dp[i-1][j]) % M; // a good previous end\\n                dp[i][j] = (dp[i][j] + psum[pre[j]]) % M; // a ending point\\n            }\\n        }\\n        return dp[k-1][n-1]; // string[0,n] divided into k partitions\\n    }\\n\\n    private int[] getPre(String s, int n, int minL) { // valid indices for partition\\n        List<Integer> cuts = new ArrayList<>(n/2+1);\\n        for (int i = minL-1; i < n-2; i++) // find all good ending index for partition\\n            if (!P[s.charAt(i)-\\'0\\'] && P[s.charAt(i+1)-\\'0\\']) cuts.add(i);\\n\\n        int m = cuts.size()+2;\\n        int[] a = new int[m]; // optional conversion of list to array for speed\\n        a[1] = -1;a[m-1]=n-1; // -2 and -1 are useful dummies, n-1 is the last good ending index\\n        for (int i = 0; i < cuts.size(); i++) a[i+1] = cuts.get(i);\\n\\n        int[] pre = new int[m]; // largest pre idx for cur end to make a valid partition\\n        for (int i = 1; i < m; i++) pre[i] = bs(a, a[i]-minL);\\n\\n        return pre;\\n    }\\n\\n    private int bs(int[] a, int x) { // find the largest <=\\n        int l = 0, r = a.length;\\n        while (l < r) {\\n            int m = r- (r-l) / 2;\\n            if (a[m] == x) return m;\\n            else if (a[m] > x) r = m-1;\\n            else l = m;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    private static int M = 1_000_000_007;\\n    private static boolean[] P = new boolean[10];\\n    public int beautifulPartitions(String s, int k, int minL) {\\n        int n = s.length();\\n        if (minL*k > n) return 0; // corner case 1: total length is not enough\\n\\n        P[2] = P[3] = P[5] = P[7] = true;\\n        if (!P[s.charAt(0)-\\'0\\'] || P[s.charAt(n-1)-\\'0\\']) return 0; // corner case 2: beginning or end is not valid\\n        if (k == 1) return 1; //  corner case 3\\n\\n        List<Integer> begins = getValidBeginIndices(s, n, minL);\\n        int m = begins.size();\\n        if (m < k - 1) return 0; // corner case 4\\n\\n        int[][] dp = new int[k][m];\\n        for (var _a : dp) Arrays.fill(_a, -1); // -1 means not visited\\n\\n        return dfs(begins, k-1, 0, 0, minL, dp); // select k-1 indices within array\\n    }\\n\\n    private int dfs(List<Integer> begins, int k, int idx, int pre, int len, int[][] dp) {\\n        if (k == 0) return 1; // selected everything\\n        if (dp[k][idx] > -1) return dp[k][idx];\\n\\n        dp[k][idx] = 0; // do not select current\\n        for (int i = idx; i <= begins.size()-k; i++) { // making sure there\\'s enough left\\n            int cur = begins.get(i);\\n            if (cur - pre < len) continue;\\n            dp[k][idx] = (dp[k][idx] + dfs(begins, k-1, i+1, cur, len, dp)) % M;\\n        }\\n\\n        return dp[k][idx];\\n    }\\n\\n    private List<Integer> getValidBeginIndices(String s, int n, int minL) {\\n        List<Integer> begins = new ArrayList<>(n / 2 + 1);\\n        for (int i = minL; i <= n - minL; i++) // find all valid beginning index\\n            if (P[s.charAt(i)-\\'0\\'] && !P[s.charAt(i - 1)-\\'0\\']) begins.add(i);\\n        return begins;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int beautifulPartitions(String s, int k, int minL) {\\n        int n = s.length();\\n        if (minL*k > n) return 0; // corner case 1: total length is not enough\\n\\n        boolean[] P = new boolean[10];\\n        P[2] = P[3] = P[5] = P[7] = true;\\n\\n        if (!P[s.charAt(0)-\\'0\\'] || P[s.charAt(n-1)-\\'0\\']) return 0; // corner case 2: beginning or end is not valid\\n\\n        List<Integer> cuts = new ArrayList<>();\\n        cuts.add(0); // first beginning index\\n        for (int i = minL; i <= n-minL; i++)\\n            if (P[s.charAt(i)-\\'0\\'] && !P[s.charAt(i-1)-\\'0\\']) cuts.add(i); // each possible beginning index\\n\\n        if (cuts.size() < k) return 0; // corner case 3\\n\\n        int[][] dp = new int[k][cuts.size()];\\n        for (var _a : dp) Arrays.fill(_a, -1); // -1 means not visited\\n\\n        return dfs(cuts, k-1, 0, minL, dp);\\n    }\\n\\n    private int dfs(List<Integer> cuts, int k, int pre, int len, int[][] dp) {\\n        if (k == 0) return 1; // enough length for last segment\\n        if (dp[k][pre] > -1) return dp[k][pre];\\n\\n        dp[k][pre] = 0;\\n        // size: 10, k: 3, i can go up to: 10-3=7, so that we have 7~9 -> k options \\n        for (int i = pre+1; i <= cuts.size()-k; i++) {\\n            if (cuts.get(i) - cuts.get(pre) < len) continue;\\n            dp[k][pre] = (dp[k][pre] + dfs(cuts, k-1, i, len, dp)) % 1_000_000_007;\\n        }\\n\\n        return dp[k][pre];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    private static boolean[] P = new boolean[10];\\n    private static int M = 1_000_000_007;\\n    public int beautifulPartitions(String s, int k, int minL) {\\n        int n = s.length();\\n        P[2] = P[3] = P[5] = P[7] = true;\\n        if (!P[s.charAt(0)-\\'0\\'] || P[s.charAt(n-1)-\\'0\\']) return 0; // early termination\\n\\n        return beautifulPartitions(getPre(s, n, minL), k, minL); // actual DP, above are prep work\\n    }\\n\\n    private int beautifulPartitions(int[] pre, int k, int minL) {\\n        int n = pre.length;\\n        int[][] dp = new int[k][n]; \\n\\n        for (int j = 1; j < n; j++) dp[0][j] = 1; // making 1 partition\\n        for (int i = 1; i < k; i++) { // making 2 to k partitions\\n            int[] psum = new int[n];\\n            for (int j = i; j < n; j++) { // for i partitions, len is at least minL * i\\n                psum[j] = (psum[j-1] + dp[i-1][j]) % M; // a good previous end\\n                dp[i][j] = (dp[i][j] + psum[pre[j]]) % M; // a ending point\\n            }\\n        }\\n        return dp[k-1][n-1]; // string[0,n] divided into k partitions\\n    }\\n\\n    private int[] getPre(String s, int n, int minL) { // valid indices for partition\\n        List<Integer> cuts = new ArrayList<>(n/2+1);\\n        for (int i = minL-1; i < n-2; i++) // find all good ending index for partition\\n            if (!P[s.charAt(i)-\\'0\\'] && P[s.charAt(i+1)-\\'0\\']) cuts.add(i);\\n\\n        int m = cuts.size()+2;\\n        int[] a = new int[m]; // optional conversion of list to array for speed\\n        a[1] = -1;a[m-1]=n-1; // -2 and -1 are useful dummies, n-1 is the last good ending index\\n        for (int i = 0; i < cuts.size(); i++) a[i+1] = cuts.get(i);\\n\\n        int[] pre = new int[m]; // largest pre idx for cur end to make a valid partition\\n        for (int i = 1; i < m; i++) pre[i] = bs(a, a[i]-minL);\\n\\n        return pre;\\n    }\\n\\n    private int bs(int[] a, int x) { // find the largest <=\\n        int l = 0, r = a.length;\\n        while (l < r) {\\n            int m = r- (r-l) / 2;\\n            if (a[m] == x) return m;\\n            else if (a[m] > x) r = m-1;\\n            else l = m;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831799,
                "title": "c-o-nk-dp",
                "content": "# Intuition\\nDP\\n\\n# Approach\\nWe can model it as $dp[idx][k][active]$ where idx is the current index of the string, k is the number of substrings remaining, and active means if there is a substring under construction\\nThe transitions are defined by the constraints, if active is true we can end the current substring only if $S[idx]$ is not prime and conversely if active is not true we can only start a new substring if $S [ idx]$ is prime  \\n\\nTo comply with the substring size restriction, it is enough that when starting a new substring (active is false) we advance directly to the minimum necessary position that would be (idx+m)-1\\n\\n# Complexity\\n- Time complexity:\\n$O(nk)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1007][1007][2];\\n    string S;   \\n    int m;\\n    int n;\\n    const int mod = 1e9+7;\\n    int solve(int idx,int k,int active){\\n        if(k<0)return 0;\\n        if(idx ==n && k==0)return 1;\\n        if(idx>=n)return 0;\\n        if(k==0)return 0;\\n        int &x = dp[idx][k][active];\\n        if(x!=-1)return x;\\n        \\n        long long ans = 0;\\n        \\n        if(active){\\n            if(S[idx]==\\'1\\' || S[idx]== \\'4\\'|| S[idx]== \\'6\\'|| S[idx]== \\'8\\' || S[idx]== \\'9\\')\\n                (ans+=solve(idx+1,k-1,active^1))%=mod; \\n            (ans+=solve(idx+1,k,active))%=mod;\\n        }\\n        else{\\n            if(S[idx]==\\'1\\' || S[idx]== \\'4\\'|| S[idx]== \\'6\\'|| S[idx]== \\'8\\' || S[idx]== \\'9\\')\\n                return x = 0;\\n            \\n            (ans+=solve((idx+m)-1,k,active^1))%=mod;\\n        }\\n        return x = ans;\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp));\\n        S = s;\\n        m = minLength;\\n        n = s.size();\\n        return solve(0,k,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1007][1007][2];\\n    string S;   \\n    int m;\\n    int n;\\n    const int mod = 1e9+7;\\n    int solve(int idx,int k,int active){\\n        if(k<0)return 0;\\n        if(idx ==n && k==0)return 1;\\n        if(idx>=n)return 0;\\n        if(k==0)return 0;\\n        int &x = dp[idx][k][active];\\n        if(x!=-1)return x;\\n        \\n        long long ans = 0;\\n        \\n        if(active){\\n            if(S[idx]==\\'1\\' || S[idx]== \\'4\\'|| S[idx]== \\'6\\'|| S[idx]== \\'8\\' || S[idx]== \\'9\\')\\n                (ans+=solve(idx+1,k-1,active^1))%=mod; \\n            (ans+=solve(idx+1,k,active))%=mod;\\n        }\\n        else{\\n            if(S[idx]==\\'1\\' || S[idx]== \\'4\\'|| S[idx]== \\'6\\'|| S[idx]== \\'8\\' || S[idx]== \\'9\\')\\n                return x = 0;\\n            \\n            (ans+=solve((idx+m)-1,k,active^1))%=mod;\\n        }\\n        return x = ans;\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp));\\n        S = s;\\n        m = minLength;\\n        n = s.size();\\n        return solve(0,k,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831907,
                "title": "python-simple-dp-with-optimization",
                "content": "\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n = len(s)\\n        primes = [\\'2\\', \\'3\\', \\'5\\', \\'7\\']\\n        \\n        # pruning\\n        if k * minLength > n or s[0] not in primes or s[-1] in primes:\\n            return 0\\n        \\n        # posible starting indexes of a new partition\\n        ids = [0]\\n        for i in range(n-1):\\n            if s[i] not in primes and s[i+1] in primes:\\n                ids.append(i+1)\\n        m = len(ids)\\n\\n        @cache\\n        # dp(i, kk) means number of ways to partition s[ids[i]:n] into kk partitions\\n        def dp(i, kk):\\n            \\n            # kk==1: last remaining partition, needs to have length >= l\\n            if kk == 1:\\n                return 1 if ids[i]+minLength-1 <= n-1 else 0\\n            res = 0\\n            \\n            # iterate possible starting index of next partition\\n            for j in range(i+1, m-kk+2):\\n                if ids[j]-ids[i] >= minLength:\\n                    res += dp(j, kk-1)\\n            \\n            return res % (10**9+7)\\n        \\n        return dp(0, k)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n = len(s)\\n        primes = [\\'2\\', \\'3\\', \\'5\\', \\'7\\']\\n        \\n        # pruning\\n        if k * minLength > n or s[0] not in primes or s[-1] in primes:\\n            return 0\\n        \\n        # posible starting indexes of a new partition\\n        ids = [0]\\n        for i in range(n-1):\\n            if s[i] not in primes and s[i+1] in primes:\\n                ids.append(i+1)\\n        m = len(ids)\\n\\n        @cache\\n        # dp(i, kk) means number of ways to partition s[ids[i]:n] into kk partitions\\n        def dp(i, kk):\\n            \\n            # kk==1: last remaining partition, needs to have length >= l\\n            if kk == 1:\\n                return 1 if ids[i]+minLength-1 <= n-1 else 0\\n            res = 0\\n            \\n            # iterate possible starting index of next partition\\n            for j in range(i+1, m-kk+2):\\n                if ids[j]-ids[i] >= minLength:\\n                    res += dp(j, kk-1)\\n            \\n            return res % (10**9+7)\\n        \\n        return dp(0, k)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831883,
                "title": "so-unfair-judge-for-this-problem",
                "content": "Same solution passes after contest and fails during contest . Even  after contest sometimes the solution pass sometimes fails . Leetcode please look into this matter.\\nThe solution\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int dp[1001][1001];\\n    bool is_prime(char c){\\n        return c == \\'2\\' or c == \\'3\\' or c == \\'5\\' or c == \\'7\\';\\n    }\\n    int recur(int i , string &s , int k , int mini){\\n        if(i == s.size()){\\n            return k == 0;\\n        }\\n        if(k == 0 or s.size() - i < mini){\\n            return 0;\\n        }\\n        if(dp[i][k] != -1){\\n            return dp[i][k];\\n        }\\n        \\n        int ans = 0;\\n        if(is_prime(s[i])){\\n            \\n            for(int j = i + 1; j < s.size() ;j++){\\n                if(is_prime(s[j]) == false and j - i + 1 >= mini){\\n                    ans = (ans + recur(j + 1 , s, k - 1, mini )) % mod;\\n                }\\n            }\\n        }\\n        return dp[i][k] = ans;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        \\n        memset(dp , -1 ,sizeof(dp));\\n        \\n        return recur(0 , s , k , minLength);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int dp[1001][1001];\\n    bool is_prime(char c){\\n        return c == \\'2\\' or c == \\'3\\' or c == \\'5\\' or c == \\'7\\';\\n    }\\n    int recur(int i , string &s , int k , int mini){\\n        if(i == s.size()){\\n            return k == 0;\\n        }\\n        if(k == 0 or s.size() - i < mini){\\n            return 0;\\n        }\\n        if(dp[i][k] != -1){\\n            return dp[i][k];\\n        }\\n        \\n        int ans = 0;\\n        if(is_prime(s[i])){\\n            \\n            for(int j = i + 1; j < s.size() ;j++){\\n                if(is_prime(s[j]) == false and j - i + 1 >= mini){\\n                    ans = (ans + recur(j + 1 , s, k - 1, mini )) % mod;\\n                }\\n            }\\n        }\\n        return dp[i][k] = ans;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        \\n        memset(dp , -1 ,sizeof(dp));\\n        \\n        return recur(0 , s , k , minLength);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832643,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int n;\\n    int mod = 1e9 + 7;\\n    long long dp[1001][1001];\\n    bool yes(char & ch)\\n    {\\n        return (ch == \\'2\\') || (ch == \\'3\\') || (ch == \\'5\\') || (ch == \\'7\\');\\n    }\\n    long long find(string &s, int index, int k, int &len)\\n    {\\n        if (index + k * len > n || !yes(s[index]))\\n            return 0;\\n        if (dp[index][k] != -1)\\n        {\\n            return dp[index][k] % mod;\\n        }\\n        if (k == 1)\\n        {\\n            if (yes(s[index]) && (n - index) >= len && (!yes(s[n - 1])))\\n            {\\n                return 1ll;\\n            }\\n            return 0ll;\\n        }\\n        long long ans = 0;\\n        for (int i = index + len - 1; i < n; i++)\\n        {\\n            if ((!yes(s[i])))\\n            {\\n                ans += find(s, i + 1, k - 1, len) % mod;\\n            }\\n        }\\n        return dp[index][k] = ans % mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength)\\n    {\\n        n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        return find(s, 0, k, minLength) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int n;\\n    int mod = 1e9 + 7;\\n    long long dp[1001][1001];\\n    bool yes(char & ch)\\n    {\\n        return (ch == \\'2\\') || (ch == \\'3\\') || (ch == \\'5\\') || (ch == \\'7\\');\\n    }\\n    long long find(string &s, int index, int k, int &len)\\n    {\\n        if (index + k * len > n || !yes(s[index]))\\n            return 0;\\n        if (dp[index][k] != -1)\\n        {\\n            return dp[index][k] % mod;\\n        }\\n        if (k == 1)\\n        {\\n            if (yes(s[index]) && (n - index) >= len && (!yes(s[n - 1])))\\n            {\\n                return 1ll;\\n            }\\n            return 0ll;\\n        }\\n        long long ans = 0;\\n        for (int i = index + len - 1; i < n; i++)\\n        {\\n            if ((!yes(s[i])))\\n            {\\n                ans += find(s, i + 1, k - 1, len) % mod;\\n            }\\n        }\\n        return dp[index][k] = ans % mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength)\\n    {\\n        n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        return find(s, 0, k, minLength) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833135,
                "title": "simple-dp-explained",
                "content": "# Intuition\\n`dp[i][k]` - is the number of ways to make valid cuts for `A[i:n]` with k cuts left.\\n\\nWe iterate over s, and for a given index `i` we check whether it\\'s a valid position to partition our string (not ending at prime, and i+1 is prime). If it is, we partition on the given index and update our DP state.\\n\\n**Note**: important optimization to make is to break the loop when we can\\'t form `minSize*(k-1)` partitions anymore.\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n\\n    Set<Character> primes = Set.of(\\'2\\', \\'3\\', \\'5\\', \\'7\\');\\n    int n;\\n\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        n = s.length();\\n        if(primes.contains(s.charAt(s.length() - 1))) return 0;\\n        if(!primes.contains(s.charAt(0))) return 0;\\n        int[][] dp = new int[s.length() + 1][k];\\n        for(int[] A : dp) Arrays.fill(A, -1);\\n        return numOfWays(dp, 0, k - 1, s, minLength);\\n    }\\n\\n    private int numOfWays(int[][] dp, int index, int cutsLeft, String s, int minLength) {\\n        if(cutsLeft == 0) {\\n            if(n - index >= minLength) return 1;\\n            return 0;\\n        }\\n        if(dp[index][cutsLeft] != -1) return dp[index][cutsLeft];\\n\\n        int res = 0;\\n        for (int i = index; i < n - cutsLeft; i++) {\\n            if(i + (minLength * (cutsLeft - 1)) >= n) break; // must make that optimization to AC.\\n            \\n            if(!primes.contains(s.charAt(i)) && primes.contains(s.charAt(i + 1))) {\\n                if(i - index + 1 >= minLength) {\\n                    res = (res  + (numOfWays(dp, i + 1, cutsLeft - 1, s, minLength) % MOD)) % MOD;\\n                }\\n            }\\n        }\\n\\n        return dp[index][cutsLeft] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n\\n    Set<Character> primes = Set.of(\\'2\\', \\'3\\', \\'5\\', \\'7\\');\\n    int n;\\n\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        n = s.length();\\n        if(primes.contains(s.charAt(s.length() - 1))) return 0;\\n        if(!primes.contains(s.charAt(0))) return 0;\\n        int[][] dp = new int[s.length() + 1][k];\\n        for(int[] A : dp) Arrays.fill(A, -1);\\n        return numOfWays(dp, 0, k - 1, s, minLength);\\n    }\\n\\n    private int numOfWays(int[][] dp, int index, int cutsLeft, String s, int minLength) {\\n        if(cutsLeft == 0) {\\n            if(n - index >= minLength) return 1;\\n            return 0;\\n        }\\n        if(dp[index][cutsLeft] != -1) return dp[index][cutsLeft];\\n\\n        int res = 0;\\n        for (int i = index; i < n - cutsLeft; i++) {\\n            if(i + (minLength * (cutsLeft - 1)) >= n) break; // must make that optimization to AC.\\n            \\n            if(!primes.contains(s.charAt(i)) && primes.contains(s.charAt(i + 1))) {\\n                if(i - index + 1 >= minLength) {\\n                    res = (res  + (numOfWays(dp, i + 1, cutsLeft - 1, s, minLength) % MOD)) % MOD;\\n                }\\n            }\\n        }\\n\\n        return dp[index][cutsLeft] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834663,
                "title": "java-o-nk-solution-26-ms-beats-100",
                "content": "#### Intuition\\n* dp[k][i] means the number of ways to divide the substring which starts from index i into k parts. It\\'s pretty straightforward to calculate the dp array by top-down approach.\\n* However, the performance isn\\'t good enough. Even though I pruned the impossible branches, it still took 1287ms during the conest.\\n* To calculate dp[k][i], I need to find every index j which satisfies j - i + 1 >= minLength and calculate dp[k - 1][j + 1]. How can I improve the performance?\\n* Think it carefully. What dp[k][i] really needs is the number of end points after index j >= i + minLength - 1 that str[j] is not prime and str[j + 1] is prime. For example, if str[i...j + 1] and str[i...j+3] are the valid segments, then I calculate dp[k][i] by dp[k][i] = dp[k - 1][j + 2] + dp[k - 1][j + 4]. If I know the number of valid end points after j is 2, dp[k][i] is equal to some_precomputed_info[i + minLength - 1 = j] = 2.\\n* This gives me a hint that I can accumulate the information from dp[k - 1][i] just like making a prefix sum array. And it suggests I should use bottom-up approach to achieve the goal.\\n#### Algorithm\\n* described by the code and comments\\n#### Similar Problems\\n* [689 maximum-sum-of-3-non-overlapping-subarrays](https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)\\n```\\nclass Solution {\\n    private static int mod = (int) 1e9 + 7;\\n    public int beautifulPartitions(String s, int k, int l) {\\n        char[] cs = s.toCharArray();\\n        int n = cs.length;\\n\\t\\t// make sure the input is valid\\n        if (!prime(cs[0]) || prime(cs[n - 1])) return 0;\\n        int[][] dp = new int[k][n];\\n\\t\\t// base case. If k = 1, the only thing required is to check if a character is prime\\n        for (int i = n - l; 0 <= i; --i) dp[0][i] = prime(cs[i]) ? 1 : 0;        \\n        for (int i = 1; i < k; ++i) {\\n\\t\\t    // re-use dp[k - 1][] and compute the `prefix sum` backwards\\n\\t\\t    // sum is the number of valid end points\\n            for (int j = n - i * l, sum = 0; 0 <= j; --j) {\\n\\t\\t\\t    // if dp[][] is 0, store the sum. othewise, it could be a possible valid end point.\\n                if (0 == dp[i - 1][j]) dp[i - 1][j] = sum;\\n                else if (0 != j && 0 == dp[i - 1][j - 1]) sum = (sum + dp[i - 1][j]) % mod;\\n            }          \\n\\t\\t\\t// use 2 pointers [j, p] to find a valid substring\\n            for (int j = 0, p = l - 1; j + l * i < n; ++j) {                \\n                if (!prime(cs[j])) continue;\\n                p = Math.max(p, j + l - 1);\\n                while (prime(cs[p])) p++; // boundary check is skipped as the last character is not prime\\n                if (0 == dp[i - 1][p]) break; // early break because there\\'s no valid end points\\n                dp[i][j] = dp[i - 1][p];\\n            }\\n        }\\n        return dp[k - 1][0];\\n    }\\n    private boolean prime(char c) {\\n        return \\'2\\' == c || \\'3\\' == c || \\'5\\' == c || \\'7\\' == c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private static int mod = (int) 1e9 + 7;\\n    public int beautifulPartitions(String s, int k, int l) {\\n        char[] cs = s.toCharArray();\\n        int n = cs.length;\\n\\t\\t// make sure the input is valid\\n        if (!prime(cs[0]) || prime(cs[n - 1])) return 0;\\n        int[][] dp = new int[k][n];\\n\\t\\t// base case. If k = 1, the only thing required is to check if a character is prime\\n        for (int i = n - l; 0 <= i; --i) dp[0][i] = prime(cs[i]) ? 1 : 0;        \\n        for (int i = 1; i < k; ++i) {\\n\\t\\t    // re-use dp[k - 1][] and compute the `prefix sum` backwards\\n\\t\\t    // sum is the number of valid end points\\n            for (int j = n - i * l, sum = 0; 0 <= j; --j) {\\n\\t\\t\\t    // if dp[][] is 0, store the sum. othewise, it could be a possible valid end point.\\n                if (0 == dp[i - 1][j]) dp[i - 1][j] = sum;\\n                else if (0 != j && 0 == dp[i - 1][j - 1]) sum = (sum + dp[i - 1][j]) % mod;\\n            }          \\n\\t\\t\\t// use 2 pointers [j, p] to find a valid substring\\n            for (int j = 0, p = l - 1; j + l * i < n; ++j) {                \\n                if (!prime(cs[j])) continue;\\n                p = Math.max(p, j + l - 1);\\n                while (prime(cs[p])) p++; // boundary check is skipped as the last character is not prime\\n                if (0 == dp[i - 1][p]) break; // early break because there\\'s no valid end points\\n                dp[i][j] = dp[i - 1][p];\\n            }\\n        }\\n        return dp[k - 1][0];\\n    }\\n    private boolean prime(char c) {\\n        return \\'2\\' == c || \\'3\\' == c || \\'5\\' == c || \\'7\\' == c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832638,
                "title": "java-dp-60ms-100-time-o-s-length-k-easily-understand",
                "content": "```Java\\n/*\\n\\t\\twhen we get the index where we can seperate(cut) the string,. we have 2 choices, cut or don\\'t cut.\\n*/\\nclass Solution {\\n\\tprivate final static int MOD = 1_000_000_007;\\n\\n\\tpublic int beautifulPartitions(String s, int k, int minLength) {\\n\\t\\tint n = s.length();\\n\\t\\tif (!isPrime(s.charAt(0)) || isPrime(s.charAt(n - 1))) return 0;\\n\\n\\t\\tint[][] dp = new int[k][n];\\n\\t\\tArrays.fill(dp[0], 1);\\n\\t\\tfor (int i = 1; i < k; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (j - 0 >= minLength && n - j >= minLength \\n\\t\\t\\t\\t\\t&& !isPrime(s.charAt(j - 1)) && isPrime(s.charAt(j))) {\\n\\t\\t\\t\\t\\t// can cut here.\\n\\t\\t\\t\\t\\t// dp[i][j] = no cut + cut.\\n\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j - 1] + dp[i - 1][j - minLength]) % MOD;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i][j - 1];    // no cut here.\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[k - 1][n - 1];\\n\\t}\\n\\n\\tprivate boolean isPrime(char ch) {\\n\\t\\treturn ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\' || ch == \\'7\\';\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\n/*\\n\\t\\twhen we get the index where we can seperate(cut) the string,. we have 2 choices, cut or don\\'t cut.\\n*/\\nclass Solution {\\n\\tprivate final static int MOD = 1_000_000_007;\\n\\n\\tpublic int beautifulPartitions(String s, int k, int minLength) {\\n\\t\\tint n = s.length();\\n\\t\\tif (!isPrime(s.charAt(0)) || isPrime(s.charAt(n - 1))) return 0;\\n\\n\\t\\tint[][] dp = new int[k][n];\\n\\t\\tArrays.fill(dp[0], 1);\\n\\t\\tfor (int i = 1; i < k; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (j - 0 >= minLength && n - j >= minLength \\n\\t\\t\\t\\t\\t&& !isPrime(s.charAt(j - 1)) && isPrime(s.charAt(j))) {\\n\\t\\t\\t\\t\\t// can cut here.\\n\\t\\t\\t\\t\\t// dp[i][j] = no cut + cut.\\n\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j - 1] + dp[i - 1][j - minLength]) % MOD;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i][j - 1];    // no cut here.\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[k - 1][n - 1];\\n\\t}\\n\\n\\tprivate boolean isPrime(char ch) {\\n\\t\\treturn ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\' || ch == \\'7\\';\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832529,
                "title": "c-iterative-dp-solution-o-k-n-2-to-o-nk",
                "content": "This Question was asked in Google OA this Hiring season. But O(KN^2) was also acceptable in assessment.\\n**Solution optimizing Idea:** [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n\\n**Optimal Solution: O(nk)**\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    bool isprime(char &c){\\n        int val = c-\\'0\\';\\n        return (val==2 || val==3 || val==5 || val==7);\\n    }\\n    int beautifulPartitions(string s, int Kim, int m) {\\n        vector<vector<long long>> dp(Kim+2,vector<long long>(s.size()+2,0));\\n        for(int k = 1;k<=Kim;++k){\\n            long long re = 0;\\n            for(int i = 0; i<s.size();++i){\\n                if(i-m>=0 && isprime(s[i-m+1])) re = (re + dp[k-1][i-m])%mod;\\n                if(k==1){\\n                    if(i+1>=m && isprime(s[0]) && !isprime(s[i])) dp[k][i] = 1;\\n                }\\n                else{\\n                    if(!isprime(s[i])) dp[k][i] = re;\\n                }\\n            }\\n        }\\n        return dp[Kim][s.size()-1];\\n    }\\n};\\n```\\n**Recursive Solution: O(kN^2)**\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    bool isprime(char c){\\n        int val = c-\\'0\\';\\n        return (val==2 || val==3 || val==5 || val==7);\\n    }\\n    long long dfs(vector<vector<long long>>& dp,string &s,int m,int k,int in){\\n        if(in>=s.size()){\\n            if(k==0) return 1;\\n            else return 0;\\n        }\\n        if(dp[in][k]!=-1) return dp[in][k];\\n        if(!isprime(s[in])) return 0;\\n        if(k==1){\\n            if(isprime(s[in]) && !isprime(s[s.size()-1])) return s.size()-in>=m;\\n            else return 0;\\n        }\\n        long long re = 0;\\n        for(int i = in+m-1; i<s.size();++i){\\n            if(!isprime(s[i])) re+= dfs(dp,s,m,k-1,i+1);\\n            re%=mod;\\n        }\\n        return dp[in][k] = re;\\n    }\\n    int beautifulPartitions(string s, int k, int m) {\\n        vector<vector<long long>> dp(s.size()+1,vector<long long>(k+1,-1));\\n        return dfs(dp,s,m,k,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    bool isprime(char &c){\\n        int val = c-\\'0\\';\\n        return (val==2 || val==3 || val==5 || val==7);\\n    }\\n    int beautifulPartitions(string s, int Kim, int m) {\\n        vector<vector<long long>> dp(Kim+2,vector<long long>(s.size()+2,0));\\n        for(int k = 1;k<=Kim;++k){\\n            long long re = 0;\\n            for(int i = 0; i<s.size();++i){\\n                if(i-m>=0 && isprime(s[i-m+1])) re = (re + dp[k-1][i-m])%mod;\\n                if(k==1){\\n                    if(i+1>=m && isprime(s[0]) && !isprime(s[i])) dp[k][i] = 1;\\n                }\\n                else{\\n                    if(!isprime(s[i])) dp[k][i] = re;\\n                }\\n            }\\n        }\\n        return dp[Kim][s.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    bool isprime(char c){\\n        int val = c-\\'0\\';\\n        return (val==2 || val==3 || val==5 || val==7);\\n    }\\n    long long dfs(vector<vector<long long>>& dp,string &s,int m,int k,int in){\\n        if(in>=s.size()){\\n            if(k==0) return 1;\\n            else return 0;\\n        }\\n        if(dp[in][k]!=-1) return dp[in][k];\\n        if(!isprime(s[in])) return 0;\\n        if(k==1){\\n            if(isprime(s[in]) && !isprime(s[s.size()-1])) return s.size()-in>=m;\\n            else return 0;\\n        }\\n        long long re = 0;\\n        for(int i = in+m-1; i<s.size();++i){\\n            if(!isprime(s[i])) re+= dfs(dp,s,m,k-1,i+1);\\n            re%=mod;\\n        }\\n        return dp[in][k] = re;\\n    }\\n    int beautifulPartitions(string s, int k, int m) {\\n        vector<vector<long long>> dp(s.size()+1,vector<long long>(k+1,-1));\\n        return dfs(dp,s,m,k,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563893,
                "title": "c-memoization-brute-force-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mod;\\nint solve(string &str,int k,int m,int n,vector<vector<int>> &dp,int i){\\n    if(k<0 || n-i < m*k)return 0;\\n    if(i>=n){\\n        if(k==0)return 1;\\n        return 0;\\n    }\\n    if(dp[i][k] != -1){\\n        return dp[i][k];\\n    }\\n    int a = 0;\\n    for(int j = i+m-1; j < n && j < n-(k-1)*m; j++){\\n        if((str[i]==\\'2\\'||str[i]==\\'3\\'||str[i]==\\'5\\'||str[i]==\\'7\\')&&(str[j]==\\'1\\'||str[j]==\\'4\\'||str[j]==\\'6\\'||str[j]==\\'8\\'||str[j]==\\'9\\')){\\n            a = (solve(str,k-1,m,n,dp,j+1)*1LL+a)%mod;\\n        }\\n    }\\n    return dp[i][k] = (a%mod);\\n}\\n    int beautifulPartitions(string s, int k, int m) {\\n        int n = s.length();\\n        mod = 1e9+7;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,-1));\\n        int a = solve(s,k,m,n,dp,0);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod;\\nint solve(string &str,int k,int m,int n,vector<vector<int>> &dp,int i){\\n    if(k<0 || n-i < m*k)return 0;\\n    if(i>=n){\\n        if(k==0)return 1;\\n        return 0;\\n    }\\n    if(dp[i][k] != -1){\\n        return dp[i][k];\\n    }\\n    int a = 0;\\n    for(int j = i+m-1; j < n && j < n-(k-1)*m; j++){\\n        if((str[i]==\\'2\\'||str[i]==\\'3\\'||str[i]==\\'5\\'||str[i]==\\'7\\')&&(str[j]==\\'1\\'||str[j]==\\'4\\'||str[j]==\\'6\\'||str[j]==\\'8\\'||str[j]==\\'9\\')){\\n            a = (solve(str,k-1,m,n,dp,j+1)*1LL+a)%mod;\\n        }\\n    }\\n    return dp[i][k] = (a%mod);\\n}\\n    int beautifulPartitions(string s, int k, int m) {\\n        int n = s.length();\\n        mod = 1e9+7;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,-1));\\n        int a = solve(s,k,m,n,dp,0);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834217,
                "title": "c-easy-solution-o-n-k-time-dp-recursion-memoization-solution",
                "content": "# Intuition\\nAt index i, there can be two possibilities, either you partition the string or not. Check for the conditions for partition.\\n\\n# Approach\\nAt index i,\\nnotPartition = solve(i+1,k)\\n\\nif we can do partition i.e, the s[i-1] is not prime, and s[i] is prime\\npartition = solve(i+minLength, k-1)\\n// the next string will start from i+minLength because each substring should have the minimum length of minLength, and count of partition(k) will decrease\\n\\nreturn total ways notPartion+partition\\n\\n# Complexity\\n- Time complexity: O(N*K)\\n\\n- Space complexity: O(N*K) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        //if starting first char is not prime or last char is prime, we can not do partition\\n        if(!(s[0]==\\'2\\' || s[0]==\\'3\\' || s[0]==\\'5\\' || s[0]==\\'7\\') || (s[n-1]==\\'2\\' || s[n-1]==\\'3\\' || s[n-1]==\\'5\\' || s[n-1]==\\'7\\')) return 0;\\n        return solve(minLength,s,k,minLength,n,dp);\\n    }\\n/***************************************************************************/\\n    int solve(int i,string& s,int k, int minLength, int n,vector<vector<int>>& dp)\\n    {\\n        //base cases\\n        if(k==1)\\n        {\\n            //if length of last substring is smaller than minLength\\n            if(i>n) return 0;\\n            //otherwise\\n            return 1;\\n        }\\n        //string completed without all partition\\n        if(i==n) return 0;\\n        //if we cannot partition the remaining string in k substring\\n        if(n-i<((k-1)*minLength)) return 0;\\n\\n/*******************************************************************/\\n        \\n        //memoization\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n/*******************************************************************/\\n\\n        int partition=0, notPartition=0;\\n        //not partition\\n        notPartition = (solve(i+1,s,k,minLength,n,dp))%mod;\\n        \\n        //partition\\n        //if prev char is not prime, we can make a substring\\n        //also the cur char should be prime to start new substring\\n        if(!(s[i-1]==\\'2\\' || s[i-1]==\\'3\\' || s[i-1]==\\'5\\' || s[i-1]==\\'7\\') && (s[i]==\\'2\\' || s[i]==\\'3\\' || s[i]==\\'5\\' || s[i]==\\'7\\')){\\n            partition = (solve(i+minLength,s,k-1,minLength,n,dp))%mod;\\n        }\\n        \\n        //partition+notPartition\\n        return dp[i][k] = (partition+notPartition)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        //if starting first char is not prime or last char is prime, we can not do partition\\n        if(!(s[0]==\\'2\\' || s[0]==\\'3\\' || s[0]==\\'5\\' || s[0]==\\'7\\') || (s[n-1]==\\'2\\' || s[n-1]==\\'3\\' || s[n-1]==\\'5\\' || s[n-1]==\\'7\\')) return 0;\\n        return solve(minLength,s,k,minLength,n,dp);\\n    }\\n/***************************************************************************/\\n    int solve(int i,string& s,int k, int minLength, int n,vector<vector<int>>& dp)\\n    {\\n        //base cases\\n        if(k==1)\\n        {\\n            //if length of last substring is smaller than minLength\\n            if(i>n) return 0;\\n            //otherwise\\n            return 1;\\n        }\\n        //string completed without all partition\\n        if(i==n) return 0;\\n        //if we cannot partition the remaining string in k substring\\n        if(n-i<((k-1)*minLength)) return 0;\\n\\n/*******************************************************************/\\n        \\n        //memoization\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n/*******************************************************************/\\n\\n        int partition=0, notPartition=0;\\n        //not partition\\n        notPartition = (solve(i+1,s,k,minLength,n,dp))%mod;\\n        \\n        //partition\\n        //if prev char is not prime, we can make a substring\\n        //also the cur char should be prime to start new substring\\n        if(!(s[i-1]==\\'2\\' || s[i-1]==\\'3\\' || s[i-1]==\\'5\\' || s[i-1]==\\'7\\') && (s[i]==\\'2\\' || s[i]==\\'3\\' || s[i]==\\'5\\' || s[i]==\\'7\\')){\\n            partition = (solve(i+minLength,s,k-1,minLength,n,dp))%mod;\\n        }\\n        \\n        //partition+notPartition\\n        return dp[i][k] = (partition+notPartition)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832054,
                "title": "java-dfs-memo-clean-code",
                "content": "```java\\nclass Solution {\\n  private String s;\\n  private int minLength;\\n  private long[][] memo;\\n  private int mod = (int) 1e9 + 7;\\n\\n  public int beautifulPartitions(String s, int k, int minLength) {\\n    this.s = s;\\n    this.minLength = minLength;\\n    this.memo = new long[s.length()][k + 1];\\n    for (int i = 0; i < s.length(); i++) {\\n      Arrays.fill(memo[i], -1);\\n    }\\n\\t\\n    return (int) (f(0, k) % mod);\\n  }\\n\\n  private long f(int i, int k) {\\n    if (i == s.length() && k == 0) return 1;\\n    if (i >= s.length() || k < 0) return 0;\\n    if (memo[i][k] != -1) return memo[i][k];\\n\\n    long ret = 0;\\n    if (isPrime(s.charAt(i))) {\\n      //\\n      // xxxxxxxx\\n      // i      j\\n      //\\n      // j - i + 1 >= minLength\\n      //         j >= minLength + i - 1\\n      //\\n      for (int j = i + minLength - 1; j < s.length(); j++) {\\n        // Prune unnecessary search\\n        if ((j + 1) + (k - 1) * minLength > s.length()) break;\\n        if (isPrime(s.charAt(j))) continue;\\n        \\n        ret += f(j + 1, k - 1);\\n        ret %= mod;\\n      }\\n    }\\n\\t\\n    return memo[i][k] = ret;\\n  }\\n\\n  private boolean isPrime(char c) {\\n    return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n  private String s;\\n  private int minLength;\\n  private long[][] memo;\\n  private int mod = (int) 1e9 + 7;\\n\\n  public int beautifulPartitions(String s, int k, int minLength) {\\n    this.s = s;\\n    this.minLength = minLength;\\n    this.memo = new long[s.length()][k + 1];\\n    for (int i = 0; i < s.length(); i++) {\\n      Arrays.fill(memo[i], -1);\\n    }\\n\\t\\n    return (int) (f(0, k) % mod);\\n  }\\n\\n  private long f(int i, int k) {\\n    if (i == s.length() && k == 0) return 1;\\n    if (i >= s.length() || k < 0) return 0;\\n    if (memo[i][k] != -1) return memo[i][k];\\n\\n    long ret = 0;\\n    if (isPrime(s.charAt(i))) {\\n      //\\n      // xxxxxxxx\\n      // i      j\\n      //\\n      // j - i + 1 >= minLength\\n      //         j >= minLength + i - 1\\n      //\\n      for (int j = i + minLength - 1; j < s.length(); j++) {\\n        // Prune unnecessary search\\n        if ((j + 1) + (k - 1) * minLength > s.length()) break;\\n        if (isPrime(s.charAt(j))) continue;\\n        \\n        ret += f(j + 1, k - 1);\\n        ret %= mod;\\n      }\\n    }\\n\\t\\n    return memo[i][k] = ret;\\n  }\\n\\n  private boolean isPrime(char c) {\\n    return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832044,
                "title": "top-down-dp-o-nk-c-python",
                "content": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int mn) {\\n        int n = s.size();\\n        int cache[n + 1][k + 1][2];\\n        memset(cache, -1, sizeof cache);\\n        mn = max(mn, 2);\\n        const int mod = 1e9 + 7;\\n\\n        auto isPrime = [&](int x) -> bool {\\n            return x == \\'2\\' or x == \\'3\\' or x == \\'5\\' or x == \\'7\\';\\n        };\\n        \\n        function<int(int, int, int)> dp = [&](int i, int rem, int isActive) -> int {\\n            if (rem < 0) return 0;\\n            if (i >= n) {\\n                return rem == 0 and (isActive == 0);\\n            }    \\n            int &res = cache[i][rem][isActive];\\n            if (res != -1) return res;\\n            res = 0;\\n            if (!isActive) {\\n                if (!isPrime(s[i])) return 0;\\n                res = (res + dp(i + mn - 1, rem - 1, 1)) % mod;\\n            } else {\\n                res = (res + dp(i + 1, rem, 1)) % mod;\\n                if (!isPrime(s[i])) {\\n                    res = (res + dp(i + 1, rem, 0)) % mod;\\n                }\\n            }\\n            return res;\\n        };\\n        \\n        return dp(0, k, 0);\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, mn: int) -> int:\\n        n = len(s)\\n        mn = max(mn, 2)\\n        mod = 10 ** 9 + 7\\n        \\n        def isPrime(x) -> bool:\\n            return x == \\'2\\' or x == \\'3\\' or x == \\'5\\' or x == \\'7\\'\\n        \\n        @lru_cache(maxsize=None)\\n        def dp(i, rem, isActive) -> int:\\n            if rem < 0: return 0\\n            if i >= n:\\n                return rem == 0 and isActive == 0\\n            res = 0\\n            if not isActive:\\n                if not isPrime(s[i]): return 0\\n                res = (res + dp(i + mn - 1, rem - 1, 1)) % mod\\n            else:\\n                res = (res + dp(i + 1, rem, 1)) % mod\\n                if not isPrime(s[i]):\\n                    res = (res + dp(i + 1, rem, 0)) % mod\\n            return res\\n        \\n        return dp(0, k, 0)\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int mn) {\\n        int n = s.size();\\n        int cache[n + 1][k + 1][2];\\n        memset(cache, -1, sizeof cache);\\n        mn = max(mn, 2);\\n        const int mod = 1e9 + 7;\\n\\n        auto isPrime = [&](int x) -> bool {\\n            return x == \\'2\\' or x == \\'3\\' or x == \\'5\\' or x == \\'7\\';\\n        };\\n        \\n        function<int(int, int, int)> dp = [&](int i, int rem, int isActive) -> int {\\n            if (rem < 0) return 0;\\n            if (i >= n) {\\n                return rem == 0 and (isActive == 0);\\n            }    \\n            int &res = cache[i][rem][isActive];\\n            if (res != -1) return res;\\n            res = 0;\\n            if (!isActive) {\\n                if (!isPrime(s[i])) return 0;\\n                res = (res + dp(i + mn - 1, rem - 1, 1)) % mod;\\n            } else {\\n                res = (res + dp(i + 1, rem, 1)) % mod;\\n                if (!isPrime(s[i])) {\\n                    res = (res + dp(i + 1, rem, 0)) % mod;\\n                }\\n            }\\n            return res;\\n        };\\n        \\n        return dp(0, k, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831666,
                "title": "javascript-dp-binary-search",
                "content": "**Solution: DP & Binary Search**\\n\\nMemoize each `dp(i, k)`, where\\n* `i = index in s`\\n* `k = number of substrings left that we need to partition`\\n\\nStore the indexes of prime numbers in an array `nonPrimeIndexes`.\\n\\nFor each `dp(i, k)`,\\n  If `s[i]` is not prime, return `0` ways immediately.\\n*   We need to try each possible ending character of the substring, which must be a prime number.\\n*   Binary search for the minimum index in `nonPrimeIndexes` where `nonPrimeIndexes[index] >= i + minLength - 1`\\n*   Then, try each `nonPrime[i]` from the binary searched index onwards as the end of the current substring and count the number of ways.\\n\\nOptimization: \\n*   When the remaining length in `s` (`n - i`) is smaller than the smallest possible length (`minLength * k`), return `0` ways immediately since it is impossible.\\n*   Note: We know that each substring must have at least 2 characters even if minLength = 1 because we need a prime and a non-prime. So consider minLength as `Math.max(2, minLength)`.\\n  \\n```\\nvar beautifulPartitions = function(s, k, minLength) {\\n  let n = s.length, nonPrimeIndexes = [];\\n  for (let i = 0; i < n; i++) {\\n    if (!isPrime(s[i])) nonPrimeIndexes.push(i);\\n  }\\n  let memo = Array(n).fill(0).map(() => Array(k + 1).fill(-1)), MOD = 10 ** 9 + 7;\\n  return dp(0, k);\\n  \\n  function dp(i, k) {\\n    let remainingLen = n - i;\\n    if (remainingLen < Math.max(2, minLength) * k) return 0;\\n    if (i === n) return k === 0 ? 1 : 0;\\n    if (k === 0) return 0;\\n    if (memo[i][k] !== -1) return memo[i][k];\\n    \\n    if (!isPrime(s[i])) return 0;\\n    \\n    let ways = 0;\\n    let index = binarySearch(i + minLength - 1);\\n    for (let j = index; j < nonPrimeIndexes.length; j++) {\\n      ways = (ways + dp(nonPrimeIndexes[j] + 1, k - 1)) % MOD;\\n    }\\n    return memo[i][k] = ways;\\n  }  \\n  \\n  function isPrime(num) {\\n    return [\\'2\\', \\'3\\', \\'5\\', \\'7\\'].includes(num);\\n  }\\n  \\n  function binarySearch(min) { // binary search for the smallest index in nonPrimeIndexes where nonPrimeIndexes[index] >= min\\n    let low = 0, high = nonPrimeIndexes.length - 1;\\n    while (low < high) {\\n      let mid = Math.floor((low + high) / 2);\\n      if (nonPrimeIndexes[mid] >= min) high = mid;\\n      else low = mid + 1;\\n    }\\n    return nonPrimeIndexes[low] < min ? nonPrimeIndexes.length : low;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar beautifulPartitions = function(s, k, minLength) {\\n  let n = s.length, nonPrimeIndexes = [];\\n  for (let i = 0; i < n; i++) {\\n    if (!isPrime(s[i])) nonPrimeIndexes.push(i);\\n  }\\n  let memo = Array(n).fill(0).map(() => Array(k + 1).fill(-1)), MOD = 10 ** 9 + 7;\\n  return dp(0, k);\\n  \\n  function dp(i, k) {\\n    let remainingLen = n - i;\\n    if (remainingLen < Math.max(2, minLength) * k) return 0;\\n    if (i === n) return k === 0 ? 1 : 0;\\n    if (k === 0) return 0;\\n    if (memo[i][k] !== -1) return memo[i][k];\\n    \\n    if (!isPrime(s[i])) return 0;\\n    \\n    let ways = 0;\\n    let index = binarySearch(i + minLength - 1);\\n    for (let j = index; j < nonPrimeIndexes.length; j++) {\\n      ways = (ways + dp(nonPrimeIndexes[j] + 1, k - 1)) % MOD;\\n    }\\n    return memo[i][k] = ways;\\n  }  \\n  \\n  function isPrime(num) {\\n    return [\\'2\\', \\'3\\', \\'5\\', \\'7\\'].includes(num);\\n  }\\n  \\n  function binarySearch(min) { // binary search for the smallest index in nonPrimeIndexes where nonPrimeIndexes[index] >= min\\n    let low = 0, high = nonPrimeIndexes.length - 1;\\n    while (low < high) {\\n      let mid = Math.floor((low + high) / 2);\\n      if (nonPrimeIndexes[mid] >= min) high = mid;\\n      else low = mid + 1;\\n    }\\n    return nonPrimeIndexes[low] < min ? nonPrimeIndexes.length : low;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831657,
                "title": "dp-on-index-and-remaining-partitions-with-prefix-sum-optimization",
                "content": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(s)\\n        primes = \"2357\"\\n        isPrime = False\\n        isComp = False\\n        for c in s:\\n            if c in primes:\\n                isPrime = True\\n            else:\\n                isComp = True\\n        if not isPrime or not isComp:\\n            return 0\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        dp[n][0] = 1\\n        primesum = [[0] for _ in range(k + 1)]\\n        primesum[0][0] = 1\\n        for i in range(n - 1, -1, -1):\\n            if s[i] in primes:\\n                for l in range(1, k + 1):\\n                    if minLength <= len(primesum[l - 1]):\\n                        dp[i][l] += primesum[l - 1][-minLength]\\n            for l in range(k + 1):\\n                val = 0\\n                if s[i] in primes and (i == 0 or s[i - 1] not in primes):\\n                    val = dp[i][l]\\n                primesum[l].append(primesum[l][-1] + val)\\n        return dp[0][k] % M\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(s)\\n        primes = \"2357\"\\n        isPrime = False\\n        isComp = False\\n        for c in s:\\n            if c in primes:\\n                isPrime = True\\n            else:\\n                isComp = True\\n        if not isPrime or not isComp:\\n            return 0\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        dp[n][0] = 1\\n        primesum = [[0] for _ in range(k + 1)]\\n        primesum[0][0] = 1\\n        for i in range(n - 1, -1, -1):\\n            if s[i] in primes:\\n                for l in range(1, k + 1):\\n                    if minLength <= len(primesum[l - 1]):\\n                        dp[i][l] += primesum[l - 1][-minLength]\\n            for l in range(k + 1):\\n                val = 0\\n                if s[i] in primes and (i == 0 or s[i - 1] not in primes):\\n                    val = dp[i][l]\\n                primesum[l].append(primesum[l][-1] + val)\\n        return dp[0][k] % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834596,
                "title": "c-0-1-knapsack-very-intuitive-approach-and-easy-to-understand",
                "content": "**Please up vote/provide your comments:**\\nThis approach is simple Top-down DP using memoization.\\n1) Validate the string with basic checks - the first and last digit-character should be prime and non-prime respectively.\\n2) Start the 0-1 knapsack with the following configuration:\\n\\t\\ti) Set the string index to the mimimun length\\n\\t\\tii) Initialize the good partition to 1\\n3) Inside the 0-1 knapsack call, increment the count if the k parititions are beautiful with the base case.\\n4) The 0-1 knapsack:\\n\\t\\ti) Not-taken: Increment the string index\\n\\t\\tii) Taken: The paritition is counted only when the current new substring starts with prime and the previous one ends with non-prime digit-character.\\n\\n**Approach 1:**\\n```cpp\\nclass Solution {\\n    unordered_set<char> ps;\\n    int dp[1003][1003];\\n    const int MOD7 = 1e9+7;\\n    \\n    int dfs(int i, int j, int k, int minLength, string &s)\\n    {\\n        int n = s.size();\\n        if(i > n) return 0;\\n        \\n        if(i == n)\\n        {            \\n            if(j == k) return 1;\\n            else return 0;\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        // not taken\\n        int res = dfs(i + 1, j, k, minLength, s) % MOD7;\\n        // taken\\n        if(ps.count(s[i]) && (i == 0 || !ps.count(s[i-1])))\\n            res = (res + dfs(i + minLength, j + 1, k, minLength, s)) % MOD7;\\n        \\n        dp[i][j] = res;\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        ps = {\\'2\\',\\'3\\',\\'5\\',\\'7\\'};\\n        \\n        if (!ps.count(s[0]) || ps.count(s.back())) return 0;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return dfs(minLength, 1, k, minLength, s);\\n    }\\n};\\n\\n```\\n\\nIn the above approach, the first call to the Top-down DP is not what we usually do. Generally, the standard way is to always start with index zero for the string and for the beautiful partitions. Hence, modified the above approach so that the initial call to the dfs function has both indexes set to zero as follows:\\n\\n**Approach 2:**\\n```cpp\\nclass Solution {\\n    unordered_set<char> ps;\\n    int dp[1003][1003];\\n    const int MOD7 = 1e9+7;\\n    \\n    int dfs(int i, int j, int k, int minLength, string &s)\\n    {\\n        int n = s.size();\\n        if(i > n) return 0;\\n        \\n        if(i == n)\\n        {            \\n            if(j == k) return 1;\\n            else return 0;\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int res = 0;\\n        // not taken\\n        if (j > 0) res = dfs(i + 1, j, k, minLength, s) % MOD7;\\n        // taken\\n        if(ps.count(s[i]) && (i == 0 || !ps.count(s[i-1])))\\n            res = (res + dfs(i + minLength, j + 1, k, minLength, s)) % MOD7;\\n        \\n        dp[i][j] = res;\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        ps = {\\'2\\',\\'3\\',\\'5\\',\\'7\\'};\\n        \\n        if (!ps.count(s[0]) || ps.count(s.back())) return 0;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return dfs(0, 0, k, minLength, s);\\n    }\\n};\\n\\n```\\n**Please up vote/provide your comments or suggestions for improvement:**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\n    unordered_set<char> ps;\\n    int dp[1003][1003];\\n    const int MOD7 = 1e9+7;\\n    \\n    int dfs(int i, int j, int k, int minLength, string &s)\\n    {\\n        int n = s.size();\\n        if(i > n) return 0;\\n        \\n        if(i == n)\\n        {            \\n            if(j == k) return 1;\\n            else return 0;\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        // not taken\\n        int res = dfs(i + 1, j, k, minLength, s) % MOD7;\\n        // taken\\n        if(ps.count(s[i]) && (i == 0 || !ps.count(s[i-1])))\\n            res = (res + dfs(i + minLength, j + 1, k, minLength, s)) % MOD7;\\n        \\n        dp[i][j] = res;\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        ps = {\\'2\\',\\'3\\',\\'5\\',\\'7\\'};\\n        \\n        if (!ps.count(s[0]) || ps.count(s.back())) return 0;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return dfs(minLength, 1, k, minLength, s);\\n    }\\n};\\n\\n```\n```cpp\\nclass Solution {\\n    unordered_set<char> ps;\\n    int dp[1003][1003];\\n    const int MOD7 = 1e9+7;\\n    \\n    int dfs(int i, int j, int k, int minLength, string &s)\\n    {\\n        int n = s.size();\\n        if(i > n) return 0;\\n        \\n        if(i == n)\\n        {            \\n            if(j == k) return 1;\\n            else return 0;\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int res = 0;\\n        // not taken\\n        if (j > 0) res = dfs(i + 1, j, k, minLength, s) % MOD7;\\n        // taken\\n        if(ps.count(s[i]) && (i == 0 || !ps.count(s[i-1])))\\n            res = (res + dfs(i + minLength, j + 1, k, minLength, s)) % MOD7;\\n        \\n        dp[i][j] = res;\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        ps = {\\'2\\',\\'3\\',\\'5\\',\\'7\\'};\\n        \\n        if (!ps.count(s[0]) || ps.count(s.back())) return 0;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return dfs(0, 0, k, minLength, s);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834110,
                "title": "java-python-3-c-iterative-1d-dp-easy-to-understand-runtime-22ms-beats-100",
                "content": "First, we need to verify 3 special cases:\\n```\\nif (!isprime(s.charAt(0)) || isprime(s.charAt(s.length()-1))){return 0;}\\nif (s.length()<minLength){return 0;}\\nif (k==1){return 1;}\\n```\\nNext, we find all the indexes which can be starts of partitions (excluding 0 as 0 is a fixed one):\\n```\\n/* array of indexes which can be starts of partitions */\\nint[] primeid = new int[s.length()];\\nint ln = 0; /* length of primeid */\\nfor (int i=minLength;i<=s.length()-minLength;i++){\\n            if (isprime(s.charAt(i))&&!isprime(s.charAt(i-1))){\\n                primeid[ln]=i;\\n                ln++;\\n            }\\n        }\\n```\\nThe original problem is then reduced to finding the number of $K=(k-1)$ combinations of the indexes above where the difference between each indexes pair $>=minLength$. Bottom up dynamic programming can be used to solve this using two 1D arrays. Note that we have already verify the special case $k==1$, thus we now have $K=k-1>=1$ or the base case is $K=1$.\\n```\\nint[] dp1 = new int[ln]; /* number of satisfied K combinations */\\nint[] dp = new int[ln]; /* number of satisfied K+1 combinations */\\n```\\n$dp1[i]$ is the number of satisfied $K$ combinations using $primeid[0] ... primeid[i]$. \\n$dp[i]$ is the number of satisfied $K+1$ combinations using $primeid[0] ... primeid[i]$.\\n\\nBase case $K=1$:\\n```\\ndp1[i]=i+1; /* length of primeid[:i+1] */\\n```\\nDP relation: $dp[i]$ is the sum of\\n+ $dp[i-1]$, i.e. the number of $K+1$ combinations using $primeid[0] ... primeid[i-1]$,\\n+ and $dp1[j]$ where $j$ is the largest such that $primeid[i]-primeid[j]>=minLength$, i.e. the number of $K$ combinations using $primeid[0] ... primeid[j]$ where $primeid[i]$ can be further combined to form satisfied $K+1$ combinations.\\n \\n# Java\\n```\\n/* Runtime 22 ms Beats 100%, Memory 41.9 MB Beats 100% */\\nclass Solution {\\n    public boolean isprime(char c) {\\n        return c==\\'2\\'||c==\\'3\\'||c==\\'5\\'||c==\\'7\\';\\n    }\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        int n = s.length();\\n        if (!isprime(s.charAt(0)) || isprime(s.charAt(n-1))){return 0;}\\n        if (n<minLength){return 0;}\\n        if (k==1){return 1;}\\n        int[] primeid = new int[n];\\n        int ln = 0;\\n        for (int i=minLength;i<=n-minLength;i++){\\n            if (isprime(s.charAt(i))&&!isprime(s.charAt(i-1))){\\n                primeid[ln]=i;\\n                ln++;\\n            }\\n        }\\n        int mod = 1000000007;\\n        if (ln<k-1){return 0;}\\n        int[] dp1 = new int[ln];\\n        int[] dp = new int[ln];\\n        for (int i=0;i<ln;i++){\\n            dp1[i]=i+1;\\n            dp[i]=0;\\n            }\\n        for (int ik=2;ik<k;ik++){\\n            for (int i=ik-1;i<ln;i++){\\n                dp[i] = dp[i-1];\\n                for (int j=i-1;j>-1;j--){\\n                    if (primeid[i]-primeid[j]>=minLength){\\n                        dp[i] = (dp[i]+dp1[j])%mod;\\n                        break;\\n                    }\\n                }\\n            }\\n            for (int i=0;i<ln;i++){\\n                dp1[i]=dp[i];\\n                dp[i]=0;\\n            }\\n        }\\n        return dp1[ln-1];  \\n    }\\n}\\n```\\n# Python 3\\n```\\n# Runtime 458 ms Beats 100%, Memory 14.1 MB Beats 100%\\nclass Solution:\\n    def beautifulPartitions(self, s, k, minLength):\\n        prime = {\\'2\\',\\'3\\',\\'5\\',\\'7\\'}\\n        if s[0] not in prime or s[-1] in prime:\\n            return 0\\n        n = len(s)\\n        if n<minLength:\\n            return 0\\n        if k==1:\\n            return 1\\n        primeid = []\\n        for i in range(minLength,n-minLength+1):\\n            if s[i] in prime and s[i-1] not in prime:\\n                primeid.append(i)\\n        mod, ln = 1000000007, len(primeid)\\n        if ln<k-1: return 0\\n        dp1 = [i+1 for i in range(ln)] \\n        dp = [0]*ln\\n        for ik in range(2,k):\\n            for i in range(ik-1,ln):\\n                dp[i] = dp[i-1]\\n                for j in range(i-1,-1,-1):\\n                    if primeid[i]-primeid[j]>=minLength:\\n                        dp[i] = (dp[i]+dp1[j])%mod\\n                        break\\n            dp1 = dp[:]\\n            dp = [0]*ln\\n        return dp1[-1]\\n```\\n# C++\\n```\\n// Runtime 24 ms Beats 100%, Memory 6.6 MB Beats 100%\\nclass Solution {\\npublic:\\n    bool isprime(char c) {\\n        return c==\\'2\\'||c==\\'3\\'||c==\\'5\\'||c==\\'7\\';\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        if (!isprime(s[0]) || isprime(s[n-1])){return 0;}\\n        if (n<minLength){return 0;}\\n        if (k==1){return 1;}\\n        vector<int> primeid;\\n        for (int i=minLength;i<=n-minLength;i++){\\n            if (isprime(s[i])&&!isprime(s[i-1])){\\n                primeid.push_back(i);\\n            }\\n        }\\n        int mod = 1000000007;\\n        int ln = primeid.size();\\n        if (ln<k-1){return 0;}\\n        int dp1[ln], dp[ln];\\n        for (int i=0;i<ln;i++){\\n            dp1[i]=i+1;\\n            dp[i]=0;\\n            }\\n        for (int ik=2;ik<k;ik++){\\n            for (int i=ik-1;i<ln;i++){\\n                dp[i] = dp[i-1];\\n                for (int j=i-1;j>-1;j--){\\n                    if (primeid[i]-primeid[j]>=minLength){\\n                        dp[i] = (dp[i]+dp1[j])%mod;\\n                        break;\\n                    }\\n                }\\n            }\\n            for (int i=0;i<ln;i++){\\n                dp1[i]=dp[i];\\n                dp[i]=0;\\n            }\\n        }\\n        return dp1[ln-1];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nif (!isprime(s.charAt(0)) || isprime(s.charAt(s.length()-1))){return 0;}\\nif (s.length()<minLength){return 0;}\\nif (k==1){return 1;}\\n```\n```\\n/* array of indexes which can be starts of partitions */\\nint[] primeid = new int[s.length()];\\nint ln = 0; /* length of primeid */\\nfor (int i=minLength;i<=s.length()-minLength;i++){\\n            if (isprime(s.charAt(i))&&!isprime(s.charAt(i-1))){\\n                primeid[ln]=i;\\n                ln++;\\n            }\\n        }\\n```\n```\\nint[] dp1 = new int[ln]; /* number of satisfied K combinations */\\nint[] dp = new int[ln]; /* number of satisfied K+1 combinations */\\n```\n```\\ndp1[i]=i+1; /* length of primeid[:i+1] */\\n```\n```\\n/* Runtime 22 ms Beats 100%, Memory 41.9 MB Beats 100% */\\nclass Solution {\\n    public boolean isprime(char c) {\\n        return c==\\'2\\'||c==\\'3\\'||c==\\'5\\'||c==\\'7\\';\\n    }\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        int n = s.length();\\n        if (!isprime(s.charAt(0)) || isprime(s.charAt(n-1))){return 0;}\\n        if (n<minLength){return 0;}\\n        if (k==1){return 1;}\\n        int[] primeid = new int[n];\\n        int ln = 0;\\n        for (int i=minLength;i<=n-minLength;i++){\\n            if (isprime(s.charAt(i))&&!isprime(s.charAt(i-1))){\\n                primeid[ln]=i;\\n                ln++;\\n            }\\n        }\\n        int mod = 1000000007;\\n        if (ln<k-1){return 0;}\\n        int[] dp1 = new int[ln];\\n        int[] dp = new int[ln];\\n        for (int i=0;i<ln;i++){\\n            dp1[i]=i+1;\\n            dp[i]=0;\\n            }\\n        for (int ik=2;ik<k;ik++){\\n            for (int i=ik-1;i<ln;i++){\\n                dp[i] = dp[i-1];\\n                for (int j=i-1;j>-1;j--){\\n                    if (primeid[i]-primeid[j]>=minLength){\\n                        dp[i] = (dp[i]+dp1[j])%mod;\\n                        break;\\n                    }\\n                }\\n            }\\n            for (int i=0;i<ln;i++){\\n                dp1[i]=dp[i];\\n                dp[i]=0;\\n            }\\n        }\\n        return dp1[ln-1];  \\n    }\\n}\\n```\n```\\n# Runtime 458 ms Beats 100%, Memory 14.1 MB Beats 100%\\nclass Solution:\\n    def beautifulPartitions(self, s, k, minLength):\\n        prime = {\\'2\\',\\'3\\',\\'5\\',\\'7\\'}\\n        if s[0] not in prime or s[-1] in prime:\\n            return 0\\n        n = len(s)\\n        if n<minLength:\\n            return 0\\n        if k==1:\\n            return 1\\n        primeid = []\\n        for i in range(minLength,n-minLength+1):\\n            if s[i] in prime and s[i-1] not in prime:\\n                primeid.append(i)\\n        mod, ln = 1000000007, len(primeid)\\n        if ln<k-1: return 0\\n        dp1 = [i+1 for i in range(ln)] \\n        dp = [0]*ln\\n        for ik in range(2,k):\\n            for i in range(ik-1,ln):\\n                dp[i] = dp[i-1]\\n                for j in range(i-1,-1,-1):\\n                    if primeid[i]-primeid[j]>=minLength:\\n                        dp[i] = (dp[i]+dp1[j])%mod\\n                        break\\n            dp1 = dp[:]\\n            dp = [0]*ln\\n        return dp1[-1]\\n```\n```\\n// Runtime 24 ms Beats 100%, Memory 6.6 MB Beats 100%\\nclass Solution {\\npublic:\\n    bool isprime(char c) {\\n        return c==\\'2\\'||c==\\'3\\'||c==\\'5\\'||c==\\'7\\';\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        if (!isprime(s[0]) || isprime(s[n-1])){return 0;}\\n        if (n<minLength){return 0;}\\n        if (k==1){return 1;}\\n        vector<int> primeid;\\n        for (int i=minLength;i<=n-minLength;i++){\\n            if (isprime(s[i])&&!isprime(s[i-1])){\\n                primeid.push_back(i);\\n            }\\n        }\\n        int mod = 1000000007;\\n        int ln = primeid.size();\\n        if (ln<k-1){return 0;}\\n        int dp1[ln], dp[ln];\\n        for (int i=0;i<ln;i++){\\n            dp1[i]=i+1;\\n            dp[i]=0;\\n            }\\n        for (int ik=2;ik<k;ik++){\\n            for (int i=ik-1;i<ln;i++){\\n                dp[i] = dp[i-1];\\n                for (int j=i-1;j>-1;j--){\\n                    if (primeid[i]-primeid[j]>=minLength){\\n                        dp[i] = (dp[i]+dp1[j])%mod;\\n                        break;\\n                    }\\n                }\\n            }\\n            for (int i=0;i<ln;i++){\\n                dp1[i]=dp[i];\\n                dp[i]=0;\\n            }\\n        }\\n        return dp1[ln-1];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833388,
                "title": "c-recursion-memoization-dp-solution",
                "content": "**TC-->O(n*k)**\\n```\\nint dp[1001][1001];\\nint m=1e9+7;\\nbool isprime(string &s,int i)\\n{\\n    return  s[i]==\\'3\\' || s[i]==\\'7\\' || s[i]==\\'5\\' || s[i]==\\'2\\';\\n}\\nint count_beautiful(int i,string&s,int k,int lim)\\n{\\n    if(i==s.size() && k==0)return 1;\\n    if(i>=s.size() || k<0)return 0;\\n    if(dp[i][k]!=-1)return dp[i][k];\\n    int pick=0;\\n   //create a partition of lim length if curr char is prime and prev char is non-prime\\n    if(isprime(s,i) && !isprime(s,i-1))\\n    {\\n        pick=count_beautiful(i+lim,s,k-1,lim)%m;\\n    }\\n    \\n    //move on increase the prev patition\\n    int unpick=0;\\n    unpick=count_beautiful(i+1,s,k,lim)%m;\\n    \\n    return dp[i][k]=(unpick%m+pick%m)%m;\\n    \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=s.size();\\n        //valid string --->start with prime and end with non prime \\n        if(!isprime(s,0) || isprime(s,n-1))return 0;\\n        return count_beautiful(minLength,s,k-1,minLength);    \\n    }\\n};\\n```\\n\\n**Do Upvote if u liked my solution!!!**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint dp[1001][1001];\\nint m=1e9+7;\\nbool isprime(string &s,int i)\\n{\\n    return  s[i]==\\'3\\' || s[i]==\\'7\\' || s[i]==\\'5\\' || s[i]==\\'2\\';\\n}\\nint count_beautiful(int i,string&s,int k,int lim)\\n{\\n    if(i==s.size() && k==0)return 1;\\n    if(i>=s.size() || k<0)return 0;\\n    if(dp[i][k]!=-1)return dp[i][k];\\n    int pick=0;\\n   //create a partition of lim length if curr char is prime and prev char is non-prime\\n    if(isprime(s,i) && !isprime(s,i-1))\\n    {\\n        pick=count_beautiful(i+lim,s,k-1,lim)%m;\\n    }\\n    \\n    //move on increase the prev patition\\n    int unpick=0;\\n    unpick=count_beautiful(i+1,s,k,lim)%m;\\n    \\n    return dp[i][k]=(unpick%m+pick%m)%m;\\n    \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=s.size();\\n        //valid string --->start with prime and end with non prime \\n        if(!isprime(s,0) || isprime(s,n-1))return 0;\\n        return count_beautiful(minLength,s,k-1,minLength);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832165,
                "title": "c-dynamic-programming-memoization-commented-code",
                "content": "It is a simple DP solution, here `flag` is used to check the length of any substring is greater or equal to `minLength` or not.\\n\\n```\\nclass Solution {\\n    #define ll long long int\\n    const ll mod = 1e9 + 7;\\n    \\n    ll dp[1004][1004][2];\\n    \\n    // to check prime digit\\n    bool isPrime(char c) {\\n        return (c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\');\\n    }\\n    \\n    ll solve(string &s, int i, int flag, int k, int minLength) {\\n        // if i is last index and k == 0 then the condition is fullfilled so return 1.\\n        if(i == s.size()) {\\n            return (k == 0);\\n        }\\n        \\n        // if i is out of index or no partion to left to do then the condition will not be fullfill return 0.\\n        if(i >= s.size() || k <= 0) return 0;\\n        \\n        // to chech dp array.\\n        ll &ans = dp[i][k][flag];\\n        if(ans != -1) return ans;\\n        \\n        \\n        ans = 0;\\n        \\n        // if the minlength condition is fullfilled then,\\n        if(flag) {\\n            // if current index if non prime then it can be last index of any valid substring, so here we can partion the string and flag become 0, because the condition of minlength (0 at this time) become false.\\n            if(!isPrime(s[i])) ans += solve(s, i + 1, 0, k - 1, minLength) % mod;\\n            \\n            // we also have another option to proceed further without partioning.\\n            ans += solve(s, i + 1, flag, k, minLength) % mod;\\n        } \\n        \\n        // if the flag is false means we are at first char of one substring.\\n        else {\\n            // if first char is non prime we will not proceed further.\\n            if(!isPrime(s[i])) return 0;\\n            \\n            // if it is prime we can go directly to the size of minlength by (i + m - 1) and flag become active.\\n            ans += solve(s, i + minLength - 1, 1, k, minLength) % mod;\\n        }\\n        \\n        // to prevent the overflow.\\n        ans %= mod;\\n        return ans;\\n    }\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, 0, k, minLength);\\n    }\\n};\\n```\\n\\nplease **upvote**, if you find the solution helpful and easy.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long int\\n    const ll mod = 1e9 + 7;\\n    \\n    ll dp[1004][1004][2];\\n    \\n    // to check prime digit\\n    bool isPrime(char c) {\\n        return (c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\');\\n    }\\n    \\n    ll solve(string &s, int i, int flag, int k, int minLength) {\\n        // if i is last index and k == 0 then the condition is fullfilled so return 1.\\n        if(i == s.size()) {\\n            return (k == 0);\\n        }\\n        \\n        // if i is out of index or no partion to left to do then the condition will not be fullfill return 0.\\n        if(i >= s.size() || k <= 0) return 0;\\n        \\n        // to chech dp array.\\n        ll &ans = dp[i][k][flag];\\n        if(ans != -1) return ans;\\n        \\n        \\n        ans = 0;\\n        \\n        // if the minlength condition is fullfilled then,\\n        if(flag) {\\n            // if current index if non prime then it can be last index of any valid substring, so here we can partion the string and flag become 0, because the condition of minlength (0 at this time) become false.\\n            if(!isPrime(s[i])) ans += solve(s, i + 1, 0, k - 1, minLength) % mod;\\n            \\n            // we also have another option to proceed further without partioning.\\n            ans += solve(s, i + 1, flag, k, minLength) % mod;\\n        } \\n        \\n        // if the flag is false means we are at first char of one substring.\\n        else {\\n            // if first char is non prime we will not proceed further.\\n            if(!isPrime(s[i])) return 0;\\n            \\n            // if it is prime we can go directly to the size of minlength by (i + m - 1) and flag become active.\\n            ans += solve(s, i + minLength - 1, 1, k, minLength) % mod;\\n        }\\n        \\n        // to prevent the overflow.\\n        ans %= mod;\\n        return ans;\\n    }\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, 0, k, minLength);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832142,
                "title": "python3-solution-dp-100-faster-clean-concise",
                "content": "# Complexity\\n- Time complexity: $$O(N * K)$$\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulPartitions(self, S, K, M):\\n        N = len(S)\\n        P = \\'2357\\'\\n        help = lambda a, b: a not in P and b in P\\n        if not help(S[-1], S[0]) or K * M > N: return 0\\n        dp = [1] * (N - M)\\n        mod = 10 ** 9 + 7\\n        for j in range(1, K):\\n            dp2 = [0] * (N - M)\\n            for i in range(j * M - 1, N - M):\\n                dp2[i] = (dp2[i - 1] + dp[i - M] * int(help(S[i], S[i + 1]))) % mod\\n            dp = dp2\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, S, K, M):\\n        N = len(S)\\n        P = \\'2357\\'\\n        help = lambda a, b: a not in P and b in P\\n        if not help(S[-1], S[0]) or K * M > N: return 0\\n        dp = [1] * (N - M)\\n        mod = 10 ** 9 + 7\\n        for j in range(1, K):\\n            dp2 = [0] * (N - M)\\n            for i in range(j * M - 1, N - M):\\n                dp2[i] = (dp2[i - 1] + dp[i - M] * int(help(S[i], S[i + 1]))) % mod\\n            dp = dp2\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831782,
                "title": "2d-dp-o-nk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nk)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    boolean is[];\\n    public int beautifulPartitions(String s, int K, int minLength) {\\n        is = new boolean[10];\\n        is[2] = is[3] = is[5] = is[7] = true;\\n        \\n        int n = s.length();\\n        int a[] = new int[n + 1];\\n        for(int i = 0; i < n; i++) a[i + 1] = s.charAt(i) - \\'0\\';\\n        if(!is[a[1]]) {\\n            return 0;\\n        }\\n        \\n        long dp[][] = new long[n + 1][K + 1];\\n        long m[] = new long[K + 1];        \\n        dp[0][0] = 1;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            if(i >= minLength) {\\n                int idx = i - minLength;\\n                if(idx == 0 || (!is[a[idx]] && (idx + 1 > n || is[a[idx + 1]]))) { // keep maximum\\n                    for(int k = 0; k <= K; k++) {\\n                        m[k] += dp[idx][k];\\n                        m[k] %= mod;\\n                    }\\n                }\\n            }\\n            if(is[a[i]]) continue;\\n            for(int k = 1; k <= K; k++) {\\n                dp[i][k] += m[k - 1];\\n                dp[i][k] %= mod;\\n            }\\n        }\\n        return (int)(dp[n][K]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    boolean is[];\\n    public int beautifulPartitions(String s, int K, int minLength) {\\n        is = new boolean[10];\\n        is[2] = is[3] = is[5] = is[7] = true;\\n        \\n        int n = s.length();\\n        int a[] = new int[n + 1];\\n        for(int i = 0; i < n; i++) a[i + 1] = s.charAt(i) - \\'0\\';\\n        if(!is[a[1]]) {\\n            return 0;\\n        }\\n        \\n        long dp[][] = new long[n + 1][K + 1];\\n        long m[] = new long[K + 1];        \\n        dp[0][0] = 1;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            if(i >= minLength) {\\n                int idx = i - minLength;\\n                if(idx == 0 || (!is[a[idx]] && (idx + 1 > n || is[a[idx + 1]]))) { // keep maximum\\n                    for(int k = 0; k <= K; k++) {\\n                        m[k] += dp[idx][k];\\n                        m[k] %= mod;\\n                    }\\n                }\\n            }\\n            if(is[a[i]]) continue;\\n            for(int k = 1; k <= K; k++) {\\n                dp[i][k] += m[k - 1];\\n                dp[i][k] %= mod;\\n            }\\n        }\\n        return (int)(dp[n][K]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947971,
                "title": "step-wise-explanation-place-k-1-bars",
                "content": "My very first ovious thought was let\\'s start a function from (idx,k) and start checking from ( idx+len-1 ) for any valid cutting of string and sum those all possiblities \\nso here we have two variable in function **``` index ```** and **``` k ```**\\nand we are running a lop from index+len-1 which in at most can cost **``` n ```** intration  \\nso we end up in approx **```n^3 solution for solve(int idx, in k) function```**\\n\\nso it failed on 69th test case :(\\n\\nSo now we need to optimised :| \\nhow ?\\nwe can\\'t improve more than n^2 bcz we always need two variable index and k to keep track of current state what we can remove is inner for loop.\\n\\n``` Let\\'s think about no of ways to place k-1 bars that is same as dividing string in k pieces.```\\n\\n**```Implimentation:```**\\nwe need to call our **```find(index, k)```** not from **```(0,k)```** but from **```(len-1,k-1)```** bcz each bar should be place at least **``` minlength ```** from each other\\n\\n**```our find function will have two branches```** \\n\\n*    ``` select branch ```\\n                so if current index is a non prime number(end of substring) and next char is a prime number (start of new substring) and remaining length is more than minlength so that remaining bars can be placed\\nif this satisfies then we can place a bar here  right :) so we place a baar and call   ``` find (idx+len-1,k-1)  , (idx+len-1 bcz next baar should be at least mislength distanced )```, \\n\\n* ``` ignore it move to next index ```\\n           or we can also ignore current index and search for next index\\n\\nsum these two  branches and return them \\n\\ntake care of modulo stuffs...\\n \\n```\\nclass Solution {\\npublic:\\n    \\n    set<int> prime={3,2,5,7};\\n    set<int> np={1,4,6,8,9};\\n    int len=0;\\n    int n;\\n    string s;\\n    int m=1e9+7;\\n    \\n    long long dp[1001][1001];\\n    \\n    \\n    long long solve(int idx, int k)\\n    {\\n        if(idx==n && k==0) return 1;\\n        else if(idx==n || k<=0) return 0;\\n       \\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        long long ans=0;\\n        if(prime.find(s[idx]-\\'0\\')==prime.end()) return 0;\\n        \\n        for(int i=idx+len-1; i<n; i++)\\n        {\\n            if(np.find(s[i]-\\'0\\')!=np.end())\\n            {\\n                ans+=solve(i+1,k-1)%m;\\n                ans%=m;\\n                break;\\n            }\\n        }\\n        \\n        return dp[idx][k]=ans;\\n        \\n    }\\n    \\n    \\n    \\n    long long find(int idx, int k)\\n    {\\n        if(k==0) return 1;\\n        \\n        if(idx>=n) return 0;\\n        \\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        long long ans=0;\\n      \\n        if(idx+1<n)\\n        {\\n            if(np.find(s[idx]-\\'0\\')!=np.end() && prime.find(s[idx+1]-\\'0\\')!=prime.end() && n-1-(idx) >=len)\\n            {\\n                ans+=(1ll*find(idx+len, k-1))%m;\\n                ans%=m;\\n            }\\n        }\\n        \\n        ans+=(1ll*find(idx+1,k))%m;\\n        ans%=m;\\n        \\n        return dp[idx][k]=ans;\\n    }\\n    int beautifulPartitions(string s1, int k, int minLength) \\n    {\\n        \\n        s=s1;\\n        n=s.size();\\n        len=minLength;\\n        if(prime.find(s[0]-\\'0\\')==prime.end()|| np.find(s[n-1]-\\'0\\')==np.end()) return 0;\\n        memset(dp,-1,sizeof(dp));\\n        // return (int)solve(0,k);   // O(n^3) solution\\n        return (int)find(len-1,k-1); // O(n^2) solution\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` index ```\n``` k ```\n``` n ```\n```n^3 solution for solve(int idx, in k) function```\n``` Let\\'s think about no of ways to place k-1 bars that is same as dividing string in k pieces.```\n```Implimentation:```\n```find(index, k)```\n```(0,k)```\n```(len-1,k-1)```\n``` minlength ```\n```our find function will have two branches```\n``` select branch ```\n``` find (idx+len-1,k-1)  , (idx+len-1 bcz next baar should be at least mislength distanced )```\n``` ignore it move to next index ```\n```\\nclass Solution {\\npublic:\\n    \\n    set<int> prime={3,2,5,7};\\n    set<int> np={1,4,6,8,9};\\n    int len=0;\\n    int n;\\n    string s;\\n    int m=1e9+7;\\n    \\n    long long dp[1001][1001];\\n    \\n    \\n    long long solve(int idx, int k)\\n    {\\n        if(idx==n && k==0) return 1;\\n        else if(idx==n || k<=0) return 0;\\n       \\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        long long ans=0;\\n        if(prime.find(s[idx]-\\'0\\')==prime.end()) return 0;\\n        \\n        for(int i=idx+len-1; i<n; i++)\\n        {\\n            if(np.find(s[i]-\\'0\\')!=np.end())\\n            {\\n                ans+=solve(i+1,k-1)%m;\\n                ans%=m;\\n                break;\\n            }\\n        }\\n        \\n        return dp[idx][k]=ans;\\n        \\n    }\\n    \\n    \\n    \\n    long long find(int idx, int k)\\n    {\\n        if(k==0) return 1;\\n        \\n        if(idx>=n) return 0;\\n        \\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        long long ans=0;\\n      \\n        if(idx+1<n)\\n        {\\n            if(np.find(s[idx]-\\'0\\')!=np.end() && prime.find(s[idx+1]-\\'0\\')!=prime.end() && n-1-(idx) >=len)\\n            {\\n                ans+=(1ll*find(idx+len, k-1))%m;\\n                ans%=m;\\n            }\\n        }\\n        \\n        ans+=(1ll*find(idx+1,k))%m;\\n        ans%=m;\\n        \\n        return dp[idx][k]=ans;\\n    }\\n    int beautifulPartitions(string s1, int k, int minLength) \\n    {\\n        \\n        s=s1;\\n        n=s.size();\\n        len=minLength;\\n        if(prime.find(s[0]-\\'0\\')==prime.end()|| np.find(s[n-1]-\\'0\\')==np.end()) return 0;\\n        memset(dp,-1,sizeof(dp));\\n        // return (int)solve(0,k);   // O(n^3) solution\\n        return (int)find(len-1,k-1); // O(n^2) solution\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046226,
                "title": "c-55ms-o-nk-dynamic-programming-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSeeing the fact that we need to partition the string into some number of groups $$k$$ suggests highly that we should start out by finding all the points where we can split the string, and then do some sort of DP on these to determine the number of partitions. So, let\\'s figure out how to accomplish each of these steps.\\n\\nLet $$n$$ be the length of the string. The first thing is accomplished pretty easily -- we can split between index $$i - 1$$ and index $$i$$ if $$s[i - 1]$$ is not prime (so it can be the end of the previous string) and $$s[i]$$ is prime (so it can be the start of the new string). We also have \"fake\" split points at 0 and $$n$$ that we must use -- the former starts the first string while the latter terminates the final one.\\n\\nThen it falls to finding the dynamic program that we would like. Let $$dp[i][\\\\ell]$$ be the number of ways to split the first $$i$$ characters into $$\\\\ell$$ valid partitions, each of which has a large enough length. If $$i$$ does not correspond to a valid split point as defined earlier, this is obviously going to be 0 -- we can\\'t terminate the last string properly! If it is, then we can write the following recurrence, letting $$m = \\\\text{minLength}$$:\\n\\n$$dp[0][0] = 1$$ -- this is our base case.\\n\\n$$dp[i][\\\\ell] = \\\\displaystyle \\\\sum_{0 \\\\leq j \\\\leq i - m} dp[j][\\\\ell - 1]$$ -- we can solve for the number of ways to partition into $$\\\\ell$$ substrings by casing on the different beginning points for the last substring in the partition.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe perform the DP as stated above. Of course, if we do this directly, our runtime ends up being $$O(n^2 k)$$ because every computation at every level might rely on $$O(n)$$ values from the previous layer. We make one critical optimization that brings our runtime down from $$O(n^2 k)$$ to $$O(nk)$$. In particular, we notice that if an entry $$dp[j][\\\\ell - 1]$$ is in the sum for one entry $$dp[i][\\\\ell]$$, it is in the sum for all the entries with the same $$\\\\ell$$ and greater values of $$i$$. Therefore, we can just iterate through the $$\\\\ell - 1$$ DP values and keep adding them on once the current number we are considering for $$i$$ is large enough, and as we go through the $$i$$ in increasing order, we continue re-using this accumulated sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe number of split points is in $$O(n)$$ in the worst case, because we could alternate between prime and non-prime numbers. Each iteration of the dynamic programming recurrence must go through all of these potential split points once, and there are $$k$$ iterations, so $$O(nk)$$ overall.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince we only need layer $$\\\\ell - 1$$ to compute layer $$\\\\ell$$ of the DP, we need to store the previous layer and the current layer that we are computing at all times, but no other layers. This takes $$O(n)$$ space, and nothing else that we do needs more space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // check if a character corresponds to a prime number\\n    bool prime(char c) {\\n        return (c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\');\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // make sure beginning and. endare valid\\n        if(!prime(s[0]) || prime(s[s.length() - 1])) return 0;\\n        // set up modular arithmetic\\n        int mod = 1000000007;\\n        // find split points\\n        vector<int> splits;\\n        // dummy split point for beginning\\n        splits.push_back(0);\\n        // find split points\\n        for(int i = 1; i < s.length(); ++i) {\\n            if(prime(s[i]) && !prime(s[i - 1])) splits.push_back(i);\\n        }\\n        // dummy split point for end\\n        splits.push_back(s.length());\\n        // layer l - 1\\n        int prev[splits.size()];\\n        // layer l\\n        int curr[splits.size()];\\n        for(int i = 0; i < splits.size(); ++i) {\\n            prev[i] = 0;\\n            curr[i] = 0;\\n        }\\n        // base case -- dp[0][0] = 1\\n        prev[0] = 1;\\n        // go through layers 1 to k\\n        for(int j = 1; j <= k; ++j) {\\n            // index we\\'re at for previous layer\\n            int p = 0;\\n            // accumulated sum (long long to avoid overflow)\\n            long long acc = 0;\\n            // find each dp value for this layer\\n            for(int i = 1; i < splits.size(); ++i) {\\n                // add on previous layer values while we still can\\n                while(splits[i] - splits[p] >= minLength) {\\n                    acc += prev[p];\\n                    acc %= mod;\\n                    ++p;\\n                }\\n                // set value in the current layer\\n                curr[i] = acc;\\n            }\\n            // set up for next iteration\\n            for(int i = 0; i < splits.size(); ++i) {\\n                prev[i] = curr[i];\\n                curr[i] = 0;\\n            }\\n        }\\n        // answer is dp[n][k], which corresponds to the last split point\\n        return prev[splits.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // check if a character corresponds to a prime number\\n    bool prime(char c) {\\n        return (c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\');\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // make sure beginning and. endare valid\\n        if(!prime(s[0]) || prime(s[s.length() - 1])) return 0;\\n        // set up modular arithmetic\\n        int mod = 1000000007;\\n        // find split points\\n        vector<int> splits;\\n        // dummy split point for beginning\\n        splits.push_back(0);\\n        // find split points\\n        for(int i = 1; i < s.length(); ++i) {\\n            if(prime(s[i]) && !prime(s[i - 1])) splits.push_back(i);\\n        }\\n        // dummy split point for end\\n        splits.push_back(s.length());\\n        // layer l - 1\\n        int prev[splits.size()];\\n        // layer l\\n        int curr[splits.size()];\\n        for(int i = 0; i < splits.size(); ++i) {\\n            prev[i] = 0;\\n            curr[i] = 0;\\n        }\\n        // base case -- dp[0][0] = 1\\n        prev[0] = 1;\\n        // go through layers 1 to k\\n        for(int j = 1; j <= k; ++j) {\\n            // index we\\'re at for previous layer\\n            int p = 0;\\n            // accumulated sum (long long to avoid overflow)\\n            long long acc = 0;\\n            // find each dp value for this layer\\n            for(int i = 1; i < splits.size(); ++i) {\\n                // add on previous layer values while we still can\\n                while(splits[i] - splits[p] >= minLength) {\\n                    acc += prev[p];\\n                    acc %= mod;\\n                    ++p;\\n                }\\n                // set value in the current layer\\n                curr[i] = acc;\\n            }\\n            // set up for next iteration\\n            for(int i = 0; i < splits.size(); ++i) {\\n                prev[i] = curr[i];\\n                curr[i] = 0;\\n            }\\n        }\\n        // answer is dp[n][k], which corresponds to the last split point\\n        return prev[splits.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896730,
                "title": "c-easy",
                "content": "# Intuition:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//PLZ UPVOTE IF YOU LIKE\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int recursion(vector<int>&v,int idx,int k ,int minLength){\\n        if(k==0 && idx==v.size()-1 )return 1;\\n        if(k==0 || idx==v.size()-1)return 0;\\n        if(dp[idx][k]!=-1)return dp[idx][k];\\n        long long ans = 0;\\n        for(int i =idx+1;i<=v.size()-k;i++){\\n            if(v[i]-v[idx]<minLength)continue;\\n            ans+=recursion(v,i,k-1,minLength);\\n            ans=ans%1000000007;\\n        }\\n        return dp[idx][k]=(int)ans;\\n    }\\n    bool isPrime(int n){\\n        if(n==3||n==5||n==7||n==2){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if(!isPrime(s[0]-\\'0\\')|| isPrime(s[s.size()-1]-\\'0\\')){\\n            return 0;\\n        }\\n        vector<int>v;\\n        v.push_back(0);\\n        for(int i =1;i<s.size()-1;i++){\\n              if(!isPrime(s[i]-\\'0\\') && isPrime(s[i+1]-\\'0\\')){\\n                  v.push_back(i+1);\\n              }\\n        }\\n        if(v.size()<k)return 0;\\n        v.push_back(s.size());\\n        for(int i =0;i<1001;i++){\\n            for(int j =0;j<1001;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return recursion(v,0,k,minLength);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//PLZ UPVOTE IF YOU LIKE\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int recursion(vector<int>&v,int idx,int k ,int minLength){\\n        if(k==0 && idx==v.size()-1 )return 1;\\n        if(k==0 || idx==v.size()-1)return 0;\\n        if(dp[idx][k]!=-1)return dp[idx][k];\\n        long long ans = 0;\\n        for(int i =idx+1;i<=v.size()-k;i++){\\n            if(v[i]-v[idx]<minLength)continue;\\n            ans+=recursion(v,i,k-1,minLength);\\n            ans=ans%1000000007;\\n        }\\n        return dp[idx][k]=(int)ans;\\n    }\\n    bool isPrime(int n){\\n        if(n==3||n==5||n==7||n==2){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if(!isPrime(s[0]-\\'0\\')|| isPrime(s[s.size()-1]-\\'0\\')){\\n            return 0;\\n        }\\n        vector<int>v;\\n        v.push_back(0);\\n        for(int i =1;i<s.size()-1;i++){\\n              if(!isPrime(s[i]-\\'0\\') && isPrime(s[i+1]-\\'0\\')){\\n                  v.push_back(i+1);\\n              }\\n        }\\n        if(v.size()<k)return 0;\\n        v.push_back(s.size());\\n        for(int i =0;i<1001;i++){\\n            for(int j =0;j<1001;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return recursion(v,0,k,minLength);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844770,
                "title": "c-classic-partition-dp-memoization-o-n-k",
                "content": "```\\nstring s;\\nlong long dp[1001][1001];\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int minl = 0;\\n    int beautifulPartitions(string S, int k, int minLength) {\\n          minl = minLength; \\n          s = S;\\n          if(isprime(s[0]) && !isprime(s.back())) {\\n               memset(dp,-1,sizeof(dp));\\n               return solve(0,k);\\n          }else {\\n              return 0;\\n          }\\n    }\\n    long long solve(int pos,int k) {\\n        if(s.size() - pos < minl) return 0;\\n        if(k==1) return (int)s.size() - pos >= minl && isprime(s[pos]) && !isprime(s.back());\\n        if(dp[pos][k]!=-1) return dp[pos][k];\\n        long long cnt = 0;\\n        for(int i=pos; i<s.size(); i++) {\\n              if(isprime(s[i]) && i-1>pos && !isprime(s[i-1]) && i-pos>=minl) cnt=(cnt + solve(i,k-1)) % mod;\\n        }\\n        return dp[pos][k] = cnt;\\n    }\\n    bool isprime(char ch) {\\n         return ch - \\'0\\' == 2 || ch -\\'0\\' == 3 || ch - \\'0\\' == 5 || ch - \\'0\\' == 7;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nstring s;\\nlong long dp[1001][1001];\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int minl = 0;\\n    int beautifulPartitions(string S, int k, int minLength) {\\n          minl = minLength; \\n          s = S;\\n          if(isprime(s[0]) && !isprime(s.back())) {\\n               memset(dp,-1,sizeof(dp));\\n               return solve(0,k);\\n          }else {\\n              return 0;\\n          }\\n    }\\n    long long solve(int pos,int k) {\\n        if(s.size() - pos < minl) return 0;\\n        if(k==1) return (int)s.size() - pos >= minl && isprime(s[pos]) && !isprime(s.back());\\n        if(dp[pos][k]!=-1) return dp[pos][k];\\n        long long cnt = 0;\\n        for(int i=pos; i<s.size(); i++) {\\n              if(isprime(s[i]) && i-1>pos && !isprime(s[i-1]) && i-pos>=minl) cnt=(cnt + solve(i,k-1)) % mod;\\n        }\\n        return dp[pos][k] = cnt;\\n    }\\n    bool isprime(char ch) {\\n         return ch - \\'0\\' == 2 || ch -\\'0\\' == 3 || ch - \\'0\\' == 5 || ch - \\'0\\' == 7;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834992,
                "title": "my-javascript-solution-easy-for-understanding",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @param {number} minLength\\n * @return {number}\\n */\\nvar beautifulPartitions = function (s, k, minLength) {\\n  const ARR = s.split(\"\").map((c) => parseInt(c));\\n  const LEN = ARR.length;\\n  const PRIMES = new Set([2, 3, 5, 7]);\\n  const memo = new Map();\\n\\n  function waysOfPartition(idx, target) {\\n    if (idx >= LEN || LEN - idx < target * minLength || !PRIMES.has(ARR[idx]))\\n      return 0;\\n    else if (target === 1) return !PRIMES.has(ARR[LEN - 1]) ? 1 : 0;\\n\\n    let key = `${idx},${target}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    // ARR[idx] is prime\\n    let endIdx = idx + minLength - 1;\\n    while (PRIMES.has(ARR[endIdx])) endIdx++;\\n    if (endIdx >= LEN) {\\n      memo.set(key, 0);\\n      return 0;\\n    }\\n\\n    let sum = 0;\\n    // now, range [idx, endIdx] is valid, we keep going right to find all valid cases\\n    for (let rightIdx = 1 + endIdx; rightIdx < LEN; rightIdx++) {\\n      // check if [idx, rightIdx - 1] is still valid\\n      if (PRIMES.has(ARR[rightIdx - 1])) continue;\\n\\n      sum += waysOfPartition(rightIdx, target - 1);\\n    }\\n\\n    sum %= Math.pow(10, 9) + 7;\\n    memo.set(key, sum);\\n    return sum;\\n  }\\n\\n  return waysOfPartition(0, k);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @param {number} minLength\\n * @return {number}\\n */\\nvar beautifulPartitions = function (s, k, minLength) {\\n  const ARR = s.split(\"\").map((c) => parseInt(c));\\n  const LEN = ARR.length;\\n  const PRIMES = new Set([2, 3, 5, 7]);\\n  const memo = new Map();\\n\\n  function waysOfPartition(idx, target) {\\n    if (idx >= LEN || LEN - idx < target * minLength || !PRIMES.has(ARR[idx]))\\n      return 0;\\n    else if (target === 1) return !PRIMES.has(ARR[LEN - 1]) ? 1 : 0;\\n\\n    let key = `${idx},${target}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    // ARR[idx] is prime\\n    let endIdx = idx + minLength - 1;\\n    while (PRIMES.has(ARR[endIdx])) endIdx++;\\n    if (endIdx >= LEN) {\\n      memo.set(key, 0);\\n      return 0;\\n    }\\n\\n    let sum = 0;\\n    // now, range [idx, endIdx] is valid, we keep going right to find all valid cases\\n    for (let rightIdx = 1 + endIdx; rightIdx < LEN; rightIdx++) {\\n      // check if [idx, rightIdx - 1] is still valid\\n      if (PRIMES.has(ARR[rightIdx - 1])) continue;\\n\\n      sum += waysOfPartition(rightIdx, target - 1);\\n    }\\n\\n    sum %= Math.pow(10, 9) + 7;\\n    memo.set(key, sum);\\n    return sum;\\n  }\\n\\n  return waysOfPartition(0, k);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2833399,
                "title": "c-o-n-n-k-to-o-n-k",
                "content": "The commented solution is O(N * N * K) => TLE\\nIn the optimised solution, we simple look for the ending on a beautiful partition.\\n```\\nclass Solution {\\npublic:\\n    int m = 1e9+7;\\n    // // bool notPrime(char n){\\n    // //     return !(n==\\'2\\' || n==\\'3\\' || n==\\'5\\' || n==\\'7\\');\\n    // // }\\n//     // int dp[1001][1001];\\n//     // int f(string &s, int k, int minLen, int i){\\n//     //     if(!k) return i>=s.size();\\n//     //     if(i>=s.size() || notPrime(s[i])) return 0;\\n//     //     if(dp[k][i]!=-1) return dp[k][i];\\n//     //     int res = 0;\\n//     //     for(int j = i+minLen-1; j<s.size(); j++){\\n//     //         if(notPrime(s[j])) res = (res + f(s, k-1, minLen, j+1))%m;\\n//     //     }\\n//     //     return dp[k][i] = res;// 0 1 2 3 4\\n//     // }\\n//     // int beautifulPartitions(string s, int k, int minLen) {\\n//     //     memset(dp, -1, sizeof(dp));\\n//     //     return f(s, k, minLen, 0);\\n//     // }\\n    bool isPrime(char n){\\n        return (n==\\'2\\' || n==\\'3\\' || n==\\'5\\' || n==\\'7\\');\\n    }\\n    int dp[1001][1001];\\n    int f(string &s, int k, int minLen, int i){\\n        if(!k) return i<=s.size();//remaining part ends with non prime and is longer than minLen\\n        if(i>=s.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int res = f(s, k, minLen, i+1);//dont end here\\n        if(!isPrime(s[i-1]) && isPrime(s[i])){\\n            res = (res + f(s, k-1, minLen, i+minLen))%m;\\n        }\\n        \\n        return dp[i][k] = res;\\n    }\\n    int beautifulPartitions(string s, int k, int minLen) {\\n        if(isPrime(s.back()) || !isPrime(s[0])) return 0;\\n        memset(dp, -1, sizeof(dp));\\n        return f(s, k-1, minLen, minLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1e9+7;\\n    // // bool notPrime(char n){\\n    // //     return !(n==\\'2\\' || n==\\'3\\' || n==\\'5\\' || n==\\'7\\');\\n    // // }\\n//     // int dp[1001][1001];\\n//     // int f(string &s, int k, int minLen, int i){\\n//     //     if(!k) return i>=s.size();\\n//     //     if(i>=s.size() || notPrime(s[i])) return 0;\\n//     //     if(dp[k][i]!=-1) return dp[k][i];\\n//     //     int res = 0;\\n//     //     for(int j = i+minLen-1; j<s.size(); j++){\\n//     //         if(notPrime(s[j])) res = (res + f(s, k-1, minLen, j+1))%m;\\n//     //     }\\n//     //     return dp[k][i] = res;// 0 1 2 3 4\\n//     // }\\n//     // int beautifulPartitions(string s, int k, int minLen) {\\n//     //     memset(dp, -1, sizeof(dp));\\n//     //     return f(s, k, minLen, 0);\\n//     // }\\n    bool isPrime(char n){\\n        return (n==\\'2\\' || n==\\'3\\' || n==\\'5\\' || n==\\'7\\');\\n    }\\n    int dp[1001][1001];\\n    int f(string &s, int k, int minLen, int i){\\n        if(!k) return i<=s.size();//remaining part ends with non prime and is longer than minLen\\n        if(i>=s.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int res = f(s, k, minLen, i+1);//dont end here\\n        if(!isPrime(s[i-1]) && isPrime(s[i])){\\n            res = (res + f(s, k-1, minLen, i+minLen))%m;\\n        }\\n        \\n        return dp[i][k] = res;\\n    }\\n    int beautifulPartitions(string s, int k, int minLen) {\\n        if(isPrime(s.back()) || !isPrime(s[0])) return 0;\\n        memset(dp, -1, sizeof(dp));\\n        return f(s, k-1, minLen, minLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833001,
                "title": "first-think-simple-dp-then-do-prefix-for-optimisation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long m = 1e9+7;\\n    \\n    \\n    bool prime(int n){\\n        n = n-\\'0\\';\\n        if(n==2 || n==3 || n==5 || n==7)\\n            return true;\\n        return false;\\n    }\\n    \\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        \\n        if(!prime(s[0]) || prime(s.back()))\\n            return 0;\\n        \\n        \\n        int n = s.size();\\n        \\n        vector<vector<long long>> dp(k+1,vector<long long>(n+1,0));\\n        \\n        \\n        for(int j=minLength-1;j<n;j++){\\n            if(!prime(s[j]))dp[0][j]=1;\\n        }\\n        \\n        \\n        for(int c=1;c<k;c++){\\n            \\n            vector<long long> prefix(n+1,0);\\n            \\n            for(int i=1;i<n-1;i++){\\n                prefix[i] = prefix[i-1];\\n                if(prime(s[i+1]))\\n                    prefix[i] = (prefix[i] + dp[c-1][i])%m;\\n            }\\n            \\n            //two pointer approach\\n            //to find the first ith index \\n            //which statisfy all the constraint\\n            int i=n-2;\\n            \\n            for(int j=n-1;j>=0;j--){\\n                \\n                if(prime(s[j]))continue;\\n                \\n                while(i>=0 && (j-i+1<minLength || !prime(s[i])))i--;\\n                \\n                if(i>=0)dp[c][j] = prefix[i]; \\n            }\\n            \\n            \\n        }\\n        \\n        return dp[k-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long m = 1e9+7;\\n    \\n    \\n    bool prime(int n){\\n        n = n-\\'0\\';\\n        if(n==2 || n==3 || n==5 || n==7)\\n            return true;\\n        return false;\\n    }\\n    \\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        \\n        if(!prime(s[0]) || prime(s.back()))\\n            return 0;\\n        \\n        \\n        int n = s.size();\\n        \\n        vector<vector<long long>> dp(k+1,vector<long long>(n+1,0));\\n        \\n        \\n        for(int j=minLength-1;j<n;j++){\\n            if(!prime(s[j]))dp[0][j]=1;\\n        }\\n        \\n        \\n        for(int c=1;c<k;c++){\\n            \\n            vector<long long> prefix(n+1,0);\\n            \\n            for(int i=1;i<n-1;i++){\\n                prefix[i] = prefix[i-1];\\n                if(prime(s[i+1]))\\n                    prefix[i] = (prefix[i] + dp[c-1][i])%m;\\n            }\\n            \\n            //two pointer approach\\n            //to find the first ith index \\n            //which statisfy all the constraint\\n            int i=n-2;\\n            \\n            for(int j=n-1;j>=0;j--){\\n                \\n                if(prime(s[j]))continue;\\n                \\n                while(i>=0 && (j-i+1<minLength || !prime(s[i])))i--;\\n                \\n                if(i>=0)dp[c][j] = prefix[i]; \\n            }\\n            \\n            \\n        }\\n        \\n        return dp[k-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832082,
                "title": "c-o-nk-top-down-dp-clean-concise-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[1001][1001];\\n    int MOD = 1e9 + 7, n;\\n    bool isPrime(char& c){\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\'; \\n    }\\n    int beautifulPartitions(string s, int k, int len) {\\n        if(!isPrime(s[0]))\\n            return 0;\\n        memset(memo, -1, sizeof(memo));\\n        n = s.size();\\n        return dp(s, len, 0, k, len);\\n    }\\n    int dp(string& s, int idx, int cuts, int k, int len){\\n        if(idx > n)\\n            return 0;\\n        if(idx == n)\\n            return cuts == k - 1 && !isPrime(s.back());\\n        if(memo[idx][cuts] != -1)\\n            return memo[idx][cuts];\\n        int ans = dp(s, idx + 1, cuts, k, len) % MOD;\\n        ans %= MOD;\\n        if(isPrime(s[idx]) && !isPrime(s[idx - 1]))\\n            ans += dp(s, idx + len, cuts + 1, k, len) % MOD, ans %= MOD;\\n        return memo[idx][cuts] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[1001][1001];\\n    int MOD = 1e9 + 7, n;\\n    bool isPrime(char& c){\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\'; \\n    }\\n    int beautifulPartitions(string s, int k, int len) {\\n        if(!isPrime(s[0]))\\n            return 0;\\n        memset(memo, -1, sizeof(memo));\\n        n = s.size();\\n        return dp(s, len, 0, k, len);\\n    }\\n    int dp(string& s, int idx, int cuts, int k, int len){\\n        if(idx > n)\\n            return 0;\\n        if(idx == n)\\n            return cuts == k - 1 && !isPrime(s.back());\\n        if(memo[idx][cuts] != -1)\\n            return memo[idx][cuts];\\n        int ans = dp(s, idx + 1, cuts, k, len) % MOD;\\n        ans %= MOD;\\n        if(isPrime(s[idx]) && !isPrime(s[idx - 1]))\\n            ans += dp(s, idx + len, cuts + 1, k, len) % MOD, ans %= MOD;\\n        return memo[idx][cuts] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831901,
                "title": "simple-dp-memoization-problem",
                "content": "\\n\\nclass Solution {\\n\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n       // if last digit is prime then there is no possible solution return 0 then\\n       if(isPrime(s.charAt(s.length()-1))) return 0;\\n        dp=new long[k+1][s.length()];\\n        for(int i=0;i<=k;i++) Arrays.fill(dp[i],-1);\\n        return (int)bs(s,k,minLength,0);\\n    }\\n    long[][] dp;\\n    \\n    //will check if the char is prime or not\\n    public boolean isPrime(char num){\\n        if(num==\\'2\\'||num==\\'3\\'||num==\\'5\\'||num==\\'7\\') return true;\\n        return false;\\n    }\\n    \\n    public long bs(String s,int k,int ml,int idx){\\n        // base cases. if first digit is not prime than return \\n        if(k<0||idx>=s.length()||!isPrime(s.charAt(idx))) return 0;\\n        \\n        // if there is only one partition left return 1 because we have already checked that last digit not is prime\\n        if(k==1){\\n            return 1;\\n        }\\n        \\n        if(dp[k][idx]!=-1) return dp[k][idx];\\n        long ans=0;\\n        \\n        //will check for minLength and more if there is any substring which matches the case\\n        // s.length()-(k-1)*ml this is written because we want to give rest elements appropriate digits\\n        for(int i=idx+ml-1;i<s.length()-(k-1)*ml;i++){\\n            if(!isPrime(s.charAt(i))){\\n                ans=(ans+bs(s,k-1,ml,i+1))%1000000007;\\n            }\\n        }\\n        return dp[k][idx]=ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n       // if last digit is prime then there is no possible solution return 0 then\\n       if(isPrime(s.charAt(s.length()-1))) return 0;\\n        dp=new long[k+1][s.length()];\\n        for(int i=0;i<=k;i++) Arrays.fill(dp[i],-1);\\n        return (int)bs(s,k,minLength,0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2831865,
                "title": "java-simple-2d-dp",
                "content": "``` java\\nclass Solution {\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        if (k * minLength > s.length() || !isPrime(s.charAt(0)) || isPrime(s.charAt(s.length() - 1))) {\\n            return 0;\\n        }\\n        int[][] dp = new int[s.length() + 1][k + 1];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < s.length() - minLength + 1; i++) {\\n            if (isPrime(s.charAt(i)) && (i == 0 || !isPrime(s.charAt(i - 1)))) {\\n                for (int j = i + minLength - 1; j < s.length(); j++) {\\n                    if (!isPrime(s.charAt(j))) {\\n                        for (int p = 0; p < k; p++) {\\n                            dp[j + 1][p + 1] += dp[i][p];\\n                            dp[j + 1][p + 1] %= 1_000_000_007;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.length()][k];\\n    }\\n\\n    private boolean isPrime(char c) {\\n        if (c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "``` java\\nclass Solution {\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        if (k * minLength > s.length() || !isPrime(s.charAt(0)) || isPrime(s.charAt(s.length() - 1))) {\\n            return 0;\\n        }\\n        int[][] dp = new int[s.length() + 1][k + 1];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < s.length() - minLength + 1; i++) {\\n            if (isPrime(s.charAt(i)) && (i == 0 || !isPrime(s.charAt(i - 1)))) {\\n                for (int j = i + minLength - 1; j < s.length(); j++) {\\n                    if (!isPrime(s.charAt(j))) {\\n                        for (int p = 0; p < k; p++) {\\n                            dp[j + 1][p + 1] += dp[i][p];\\n                            dp[j + 1][p + 1] %= 1_000_000_007;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.length()][k];\\n    }\\n\\n    private boolean isPrime(char c) {\\n        if (c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831843,
                "title": "dp-memoization-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool isPrime(char ch) {\\n        return ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\' || ch == \\'7\\';\\n    }\\n    \\n    int solve(int ind, string &s, int k, int len, vector<vector<int>> &dp) { \\n        int n = s.size();\\n        if (ind == n) {\\n            return k == 0;\\n        }\\n        \\n        if (ind > n or k < 0 or ind + len * k > n or !isPrime(s[ind])) {\\n            return 0;\\n        }\\n        \\n        if (dp[ind][k] != -1)\\n            return dp[ind][k];\\n        \\n        int ans = 0;\\n        \\n        for (int i = ind + len - 1; i < n; i++) {\\n            if (isPrime(s[i])) {\\n                continue;\\n            }\\n            ans += solve(i + 1, s, k - 1, len, dp);\\n            ans %= int(1e9 + 7);\\n        }\\n        \\n        return dp[ind][k] = ans;\\n    }\\npublic:\\n    int beautifulPartitions(string s, int k, int len) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (n + 1, -1));\\n        return solve(0, s, k, len, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPrime(char ch) {\\n        return ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\' || ch == \\'7\\';\\n    }\\n    \\n    int solve(int ind, string &s, int k, int len, vector<vector<int>> &dp) { \\n        int n = s.size();\\n        if (ind == n) {\\n            return k == 0;\\n        }\\n        \\n        if (ind > n or k < 0 or ind + len * k > n or !isPrime(s[ind])) {\\n            return 0;\\n        }\\n        \\n        if (dp[ind][k] != -1)\\n            return dp[ind][k];\\n        \\n        int ans = 0;\\n        \\n        for (int i = ind + len - 1; i < n; i++) {\\n            if (isPrime(s[i])) {\\n                continue;\\n            }\\n            ans += solve(i + 1, s, k - 1, len, dp);\\n            ans %= int(1e9 + 7);\\n        }\\n        \\n        return dp[ind][k] = ans;\\n    }\\npublic:\\n    int beautifulPartitions(string s, int k, int len) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (n + 1, -1));\\n        return solve(0, s, k, len, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831824,
                "title": "easy-to-understand-recursive-solution",
                "content": "```\\n   int M = 1000000007;\\n    int len;\\n    int dp[1001][1001][2];\\n    int solve(string &s,int i,int k,int status){\\n        if(i>=s.size()){\\n            if(k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(k==0){\\n            return 0;\\n        }\\n        if(dp[i][k][status]!=-1){\\n            return dp[i][k][status];//memoization\\n        }\\n        if(status==1){\\n            //started the substring and now we have to end it or continue it\\n            int ans=0;\\n            if(s[i]==\\'1\\' || s[i]==\\'4\\' || s[i]==\\'6\\' || s[i]==\\'8\\' || s[i]==\\'9\\'){\\n                ans=max(ans, solve(s,i+1,k-1,0));//ending the substring\\n            }\\n            ans=((ans+solve(s,i+1,k,1))%M);//continuing the substring\\n            return dp[i][k][status]=ans%M;\\n        }\\n        if(status==0){\\n            //we have to start the substring\\n            int ans=0;\\n            if(s[i]==\\'2\\' || s[i]==\\'3\\' || s[i]==\\'5\\' || s[i]==\\'7\\'){\\n                ans=max(ans, solve(s,i+len-1,k,1));//starting the substring\\n            }\\n            return dp[i][k][status]=ans%M;\\n        }\\n        return 0;\\n    }\\n    int beautifulPartitions(string s,int k,int minLength){\\n        len=minLength;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,k,0);\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n   int M = 1000000007;\\n    int len;\\n    int dp[1001][1001][2];\\n    int solve(string &s,int i,int k,int status){\\n        if(i>=s.size()){\\n            if(k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(k==0){\\n            return 0;\\n        }\\n        if(dp[i][k][status]!=-1){\\n            return dp[i][k][status];//memoization\\n        }\\n        if(status==1){\\n            //started the substring and now we have to end it or continue it\\n            int ans=0;\\n            if(s[i]==\\'1\\' || s[i]==\\'4\\' || s[i]==\\'6\\' || s[i]==\\'8\\' || s[i]==\\'9\\'){\\n                ans=max(ans, solve(s,i+1,k-1,0));//ending the substring\\n            }\\n            ans=((ans+solve(s,i+1,k,1))%M);//continuing the substring\\n            return dp[i][k][status]=ans%M;\\n        }\\n        if(status==0){\\n            //we have to start the substring\\n            int ans=0;\\n            if(s[i]==\\'2\\' || s[i]==\\'3\\' || s[i]==\\'5\\' || s[i]==\\'7\\'){\\n                ans=max(ans, solve(s,i+len-1,k,1));//starting the substring\\n            }\\n            return dp[i][k][status]=ans%M;\\n        }\\n        return 0;\\n    }\\n    int beautifulPartitions(string s,int k,int minLength){\\n        len=minLength;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,k,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3951814,
                "title": "simple-c-dp-solution-beats-99",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore the eligible break points (ie,the index of the char in the string that is prime and the char behind it is not a prime) of the string in a vector and apply 2D dp (that stores index of break points and remaining k) \\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool prime(char a)\\n    {\\n        if(a==\\'2\\'|| a==\\'3\\' || a==\\'5\\' || a==\\'7\\')\\n        return true;\\n        return false;\\n    }\\n    int call(vector<int> &a,vector<vector<int>> &v,int k,int m,int i,int d)\\n    {\\n        \\n        if(k==0)\\n        return 1;\\n        if(i==a.size())\\n        {\\n            return 0;\\n        }\\n        if(a[i]-d<m)\\n        return call(a,v,k,m,i+1,d);\\n        if(k==1)\\n        return 1;\\n        if(v[i][k]!=-1)\\n        return v[i][k];\\n        long long int ans=0;\\n        ans=(call(a,v,k-1,m,i+1,a[i])+call(a,v,k,m,i+1,d));\\n        ans%=1000000007;\\n        return v[i][k]=ans;\\n\\n\\n    }\\n    int beautifulPartitions(string s, int k, int m) {\\n        if(!prime(s[0]) || prime(s[s.length()-1]))\\n        return 0;\\n        vector<int> a;\\n        for(int i=1;i<s.length()-1;i++)\\n        {\\n            if(prime(s[i]) && !prime(s[i-1]))\\n            a.push_back(i);\\n        }\\n        a.push_back(s.length());\\n        vector<vector<int>> v(a.size(),vector<int>(k+1,-1));\\n        return call(a,v,k,m,0,0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prime(char a)\\n    {\\n        if(a==\\'2\\'|| a==\\'3\\' || a==\\'5\\' || a==\\'7\\')\\n        return true;\\n        return false;\\n    }\\n    int call(vector<int> &a,vector<vector<int>> &v,int k,int m,int i,int d)\\n    {\\n        \\n        if(k==0)\\n        return 1;\\n        if(i==a.size())\\n        {\\n            return 0;\\n        }\\n        if(a[i]-d<m)\\n        return call(a,v,k,m,i+1,d);\\n        if(k==1)\\n        return 1;\\n        if(v[i][k]!=-1)\\n        return v[i][k];\\n        long long int ans=0;\\n        ans=(call(a,v,k-1,m,i+1,a[i])+call(a,v,k,m,i+1,d));\\n        ans%=1000000007;\\n        return v[i][k]=ans;\\n\\n\\n    }\\n    int beautifulPartitions(string s, int k, int m) {\\n        if(!prime(s[0]) || prime(s[s.length()-1]))\\n        return 0;\\n        vector<int> a;\\n        for(int i=1;i<s.length()-1;i++)\\n        {\\n            if(prime(s[i]) && !prime(s[i-1]))\\n            a.push_back(i);\\n        }\\n        a.push_back(s.length());\\n        vector<vector<int>> v(a.size(),vector<int>(k+1,-1));\\n        return call(a,v,k,m,0,0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939492,
                "title": "easy-and-very-simple-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nClearly explained with code. I tried to solve it using dp on subsequence where if current element is prime and previous element was non-prime and its size is within range then we can partition else we cannot.\\n\\n# Complexity\\n- Time complexity: O(N*K)\\n\\n- Space complexity: O(N*K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n\\nint help(int i,string &s,int k,int minLength,int n,vector<vector<int>>&dp){\\n    //base condition\\n    if(k==1) {\\n        if(i>n) return 0;\\n        else\\n        return 1;\\n    }\\n\\n//agr end pe reach ho gya aur kuch partition hua nahi to return 0\\n    if(i==n) return 0;\\n\\n    //can\\'t partition remaining string\\n    if(n-i<((k-1)*minLength)){\\n        return 0;\\n    }\\n\\n//memoisation\\n    if(dp[i][k]!=-1) return dp[i][k];\\n\\n    int part=0,notpart=0;\\n    //agr nahi possible h to\\n    notpart=help(i+1,s,k,minLength,n,dp)%mod;\\n\\n    //partition agr possible h to\\n    if(!(s[i-1]==\\'2\\' || s[i-1]==\\'3\\' || s[i-1]==\\'5\\' || s[i-1]==\\'7\\') and (s[i]==\\'2\\' || s[i]==\\'3\\' || s[i]==\\'5\\' || s[i]==\\'7\\')){\\n        part=help(i+minLength,s,k-1,minLength,n,dp)%mod; //next index to minlength k baad wala hi hoga\\n    }\\n    //dono ka sum return kr do\\n    return dp[i][k]=(part+notpart)%mod;\\n}\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n=s.size();\\n        //make 2-D dp \\n        vector<vector<int>>dp(n,vector<int>(k+1,-1));\\n        //agr starting index prime hua aur last index non prime hua to partition possible h\\n        if(!(s[n-1]==\\'2\\' || s[n-1]==\\'3\\' || s[n-1]==\\'5\\' || s[n-1]==\\'7\\') and (s[0]==\\'2\\' || s[0]==\\'3\\' || s[0]==\\'5\\' || s[0]==\\'7\\'))\\n        return help(minLength,s,k,minLength,n,dp);\\n\\n//warna to partition possible bilkul v nahi h\\nreturn 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n\\nint help(int i,string &s,int k,int minLength,int n,vector<vector<int>>&dp){\\n    //base condition\\n    if(k==1) {\\n        if(i>n) return 0;\\n        else\\n        return 1;\\n    }\\n\\n//agr end pe reach ho gya aur kuch partition hua nahi to return 0\\n    if(i==n) return 0;\\n\\n    //can\\'t partition remaining string\\n    if(n-i<((k-1)*minLength)){\\n        return 0;\\n    }\\n\\n//memoisation\\n    if(dp[i][k]!=-1) return dp[i][k];\\n\\n    int part=0,notpart=0;\\n    //agr nahi possible h to\\n    notpart=help(i+1,s,k,minLength,n,dp)%mod;\\n\\n    //partition agr possible h to\\n    if(!(s[i-1]==\\'2\\' || s[i-1]==\\'3\\' || s[i-1]==\\'5\\' || s[i-1]==\\'7\\') and (s[i]==\\'2\\' || s[i]==\\'3\\' || s[i]==\\'5\\' || s[i]==\\'7\\')){\\n        part=help(i+minLength,s,k-1,minLength,n,dp)%mod; //next index to minlength k baad wala hi hoga\\n    }\\n    //dono ka sum return kr do\\n    return dp[i][k]=(part+notpart)%mod;\\n}\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n=s.size();\\n        //make 2-D dp \\n        vector<vector<int>>dp(n,vector<int>(k+1,-1));\\n        //agr starting index prime hua aur last index non prime hua to partition possible h\\n        if(!(s[n-1]==\\'2\\' || s[n-1]==\\'3\\' || s[n-1]==\\'5\\' || s[n-1]==\\'7\\') and (s[0]==\\'2\\' || s[0]==\\'3\\' || s[0]==\\'5\\' || s[0]==\\'7\\'))\\n        return help(minLength,s,k,minLength,n,dp);\\n\\n//warna to partition possible bilkul v nahi h\\nreturn 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856627,
                "title": "simple-o-nk-time-and-space-complexity-solution",
                "content": "# Intuition\\n`dp[i][l]` = # of beautiful partitions for the first i char substr (s[0..i-1]) with l partitions.\\n\\nThen sub-optimial structure:\\n```\\ndp[i][l] = sum_{j <= i - minLength and str[j..i-1] is beautiful}dp[j][l-1]\\n```\\n\\nClassic DP, except for TLE : ( since the total time will be O(nk) * O(n)\\n# Approach\\nThe key insight is to realize we can reuse the result of dp[i-1][l] \\nwhen computing dp[i][l], provided we fill the table from i - 1 -> i\\nfor each l fixed. From dp[i-1][l] to dp[i][l], the only new thing to\\nconsider in the above recursion is dp[i-minLength][l-1]. So we track a `runningSum` to accumulate those. Note we can only use the `runningSum` when s[i-1] is composite: since the recursion turns the runningSum into 0 in that case.\\n\\n# Complexity\\n- Time complexity:\\nO(nk)\\n- Space complexity:\\nO(nk)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        vector<vector<int>> dp(k + 1, vector<int>(s.length() + 1, 0));\\n        const long M=1e9+7;\\n        auto isComposite = [](char c) {\\n           return c != \\'2\\' && c != \\'3\\' && c!=\\'5\\' &&  c!=\\'7\\'; \\n        };\\n        for (int l = 0; l <= k; l++) {\\n            long runningSum = 0;\\n            for (int i = 0; i <= s.length(); i++) {\\n                if (l == 0) {\\n                    dp[l][i] = i == 0;\\n                } else if (i == 0) {\\n                    dp[l][i] = l == 0;\\n                } else {\\n                    if (i < minLength) {\\n                        continue;\\n                    }\\n\\n                    int prevIdx = i - minLength;\\n                    if (!isComposite(s[prevIdx])) {\\n                        runningSum = (runningSum + dp[l-1][prevIdx]) % M;\\n                    }\\n                    \\n                    if (isComposite(s[i-1])) {\\n                        dp[l][i] = runningSum;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[k][s.length()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ndp[i][l] = sum_{j <= i - minLength and str[j..i-1] is beautiful}dp[j][l-1]\\n```\n```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        vector<vector<int>> dp(k + 1, vector<int>(s.length() + 1, 0));\\n        const long M=1e9+7;\\n        auto isComposite = [](char c) {\\n           return c != \\'2\\' && c != \\'3\\' && c!=\\'5\\' &&  c!=\\'7\\'; \\n        };\\n        for (int l = 0; l <= k; l++) {\\n            long runningSum = 0;\\n            for (int i = 0; i <= s.length(); i++) {\\n                if (l == 0) {\\n                    dp[l][i] = i == 0;\\n                } else if (i == 0) {\\n                    dp[l][i] = l == 0;\\n                } else {\\n                    if (i < minLength) {\\n                        continue;\\n                    }\\n\\n                    int prevIdx = i - minLength;\\n                    if (!isComposite(s[prevIdx])) {\\n                        runningSum = (runningSum + dp[l-1][prevIdx]) % M;\\n                    }\\n                    \\n                    if (isComposite(s[i-1])) {\\n                        dp[l][i] = runningSum;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[k][s.length()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849592,
                "title": "java-recursion-with-memorization",
                "content": "# Code\\n```\\nclass Solution {\\n    Set<Character> primes ;\\n    Set<Character> nonPrimes ;\\n\\n    private final int MOD = (int) 1e9+7;\\n\\n    //TopDown accepted\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        int[][] memo = new int[s.length()][k+1];\\n        for(int[] row : memo)\\n            Arrays.fill(row, -1);\\n        primes = Set.of(\\'2\\',\\'3\\',\\'5\\',\\'7\\');\\n        nonPrimes = Set.of(\\'1\\',\\'4\\',\\'6\\',\\'8\\',\\'9\\');\\n        return beautifulPartitions(s, 0, k, minLength, memo);\\n    }\\n\\n    public int beautifulPartitions(String s, int index, int k, int minLength, int[][] memo) {\\n        int N = s.length();\\n        if(index == N || k < 0)\\n            return k==0 ? 1 : 0; \\n\\n        char currentChar = s.charAt(index); \\n\\n        if(!primes.contains(currentChar))\\n            return 0; \\n        if(memo[index][k]!=-1)\\n            return memo[index][k];\\n\\n        int count = 0; \\n\\n        for(int i = index+minLength-1 ; i < N; i++){\\n            if(nonPrimes.contains(s.charAt(i))){\\n                count += beautifulPartitions(s, i+1, k-1, minLength, memo);\\n                count %=MOD;\\n            }\\n            int remaingChars = N-1-i;\\n            if(remaingChars < (k-1)*minLength){ \\n                break; // we cannot do k-1 partitions of length minLength with remaining characters , \\n            }\\n        }\\n\\n        memo[index][k] = count%MOD; \\n        return memo[index][k]; \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Set<Character> primes ;\\n    Set<Character> nonPrimes ;\\n\\n    private final int MOD = (int) 1e9+7;\\n\\n    //TopDown accepted\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        int[][] memo = new int[s.length()][k+1];\\n        for(int[] row : memo)\\n            Arrays.fill(row, -1);\\n        primes = Set.of(\\'2\\',\\'3\\',\\'5\\',\\'7\\');\\n        nonPrimes = Set.of(\\'1\\',\\'4\\',\\'6\\',\\'8\\',\\'9\\');\\n        return beautifulPartitions(s, 0, k, minLength, memo);\\n    }\\n\\n    public int beautifulPartitions(String s, int index, int k, int minLength, int[][] memo) {\\n        int N = s.length();\\n        if(index == N || k < 0)\\n            return k==0 ? 1 : 0; \\n\\n        char currentChar = s.charAt(index); \\n\\n        if(!primes.contains(currentChar))\\n            return 0; \\n        if(memo[index][k]!=-1)\\n            return memo[index][k];\\n\\n        int count = 0; \\n\\n        for(int i = index+minLength-1 ; i < N; i++){\\n            if(nonPrimes.contains(s.charAt(i))){\\n                count += beautifulPartitions(s, i+1, k-1, minLength, memo);\\n                count %=MOD;\\n            }\\n            int remaingChars = N-1-i;\\n            if(remaingChars < (k-1)*minLength){ \\n                break; // we cannot do k-1 partitions of length minLength with remaining characters , \\n            }\\n        }\\n\\n        memo[index][k] = count%MOD; \\n        return memo[index][k]; \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797464,
                "title": "c-dp-with-prefix-sum-50ms",
                "content": "```\\n#define ll long long\\n#define N 1000000007\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minlen) {\\n        int n=s.length();\\n    \\n        ll int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        ll int pre[n+1][k+1];\\n        memset(pre,0,sizeof(pre));\\n        pre[0][0]=1;\\n        for(int i=1;i<=n;i++)\\n            pre[i][0]=1;\\n        \\n        bool isprime[10]={0};\\n        isprime[2]=1;\\n        isprime[3]=1;\\n        isprime[5]=1;\\n        isprime[7]=1;\\n        dp[0][0]=1;\\n        if(isprime[s[0]-\\'0\\']==false)\\n            return 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=min(i,k);j++)\\n            {\\n                pre[i][j]=pre[i-1][j];\\n                if(isprime[s[i-1]-\\'0\\']==true)\\n                {\\n                    dp[i][j]=0;\\n                    continue;\\n                }\\n                \\n                if(i!=n && isprime[s[i]-\\'0\\']==false)\\n                {\\n                    dp[i][j]=0;\\n                    continue;\\n                }\\n                \\n                if(i-minlen <0)\\n                    continue;\\n                \\n                dp[i][j]=pre[i-minlen][j-1]%N;\\n                pre[i][j]=(pre[i-1][j]+dp[i][j])%N;\\n            }\\n        }\\n        \\n        return dp[n][k];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\n#define N 1000000007\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minlen) {\\n        int n=s.length();\\n    \\n        ll int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        ll int pre[n+1][k+1];\\n        memset(pre,0,sizeof(pre));\\n        pre[0][0]=1;\\n        for(int i=1;i<=n;i++)\\n            pre[i][0]=1;\\n        \\n        bool isprime[10]={0};\\n        isprime[2]=1;\\n        isprime[3]=1;\\n        isprime[5]=1;\\n        isprime[7]=1;\\n        dp[0][0]=1;\\n        if(isprime[s[0]-\\'0\\']==false)\\n            return 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=min(i,k);j++)\\n            {\\n                pre[i][j]=pre[i-1][j];\\n                if(isprime[s[i-1]-\\'0\\']==true)\\n                {\\n                    dp[i][j]=0;\\n                    continue;\\n                }\\n                \\n                if(i!=n && isprime[s[i]-\\'0\\']==false)\\n                {\\n                    dp[i][j]=0;\\n                    continue;\\n                }\\n                \\n                if(i-minlen <0)\\n                    continue;\\n                \\n                dp[i][j]=pre[i-minlen][j-1]%N;\\n                pre[i][j]=(pre[i-1][j]+dp[i][j])%N;\\n            }\\n        }\\n        \\n        return dp[n][k];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794517,
                "title": "rust-top-down-dp",
                "content": "# Code\\n```\\ntype Chr = u32;\\n\\npub struct DP {\\n    vec: Vec<Chr>,\\n    n: usize,\\n    k_max: usize,\\n    min_length: usize,\\n    \\n    memo: Vec<Vec<Option<usize>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(\\n        vec: Vec<Chr>,\\n        k_max: usize, min_length: usize\\n    ) -> Self {\\n        let n = vec.len();\\n\\n        let memo = vec![vec![None; k_max + 1]; n + 1];\\n\\n        Self {\\n            vec, n,\\n            k_max, min_length,\\n\\n            memo,\\n        }\\n    }\\n}\\n\\nconst MOD: usize = 1_000_000_007;\\n\\nimpl DP {\\n    pub fn solve(&mut self, i: usize, k: usize) -> usize {\\n        if i > self.n { return usize::MIN; }\\n        if k > self.k_max { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[i][k] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(i, k);\\n        self.memo[i][k] = Some(ret);\\n        ret\\n    }\\n\\n    fn is_prime(c: Chr) -> bool {\\n        [2, 3, 5, 7].contains(&c)\\n    }\\n\\n    fn solve_inner(&mut self, i: usize, k: usize) -> usize {\\n        if i >= self.n && k < 1 { return 1; } // found one\\n        if i >= self.n || k < 1 { return usize::MIN; } // still some left\\n\\n        if !Self::is_prime(self.vec[i]) {\\n            return usize::MIN; // does not start with prime\\n        }\\n\\n        let mut ret = usize::MIN;\\n        let i_start = i + self.min_length - 1;\\n        let i_end = self.n - (self.min_length * (k - 1)).min(self.n);\\n        for i_next in i_start..i_end {\\n            if Self::is_prime(self.vec[i_next]) {\\n                continue; // does not end with non-prime\\n            }\\n\\n            ret += self.solve(i_next + 1, k - 1);\\n            ret %= MOD;\\n        }\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    fn preproc(s: String) -> Vec<Chr> {\\n        s.chars()\\n            .map(|c| c as Chr - \\'0\\' as Chr)\\n            .collect::<Vec<_>>()\\n    }\\n\\n    pub fn beautiful_partitions(s: String, k: i32, min_length: i32) -> i32 {\\n        let k = k as usize;\\n        let min_length = min_length as usize;\\n\\n        let vec = Self::preproc(s);\\n\\n        let mut dp = DP::new(vec, k, min_length);\\n        dp.solve(0, k) as i32\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ntype Chr = u32;\\n\\npub struct DP {\\n    vec: Vec<Chr>,\\n    n: usize,\\n    k_max: usize,\\n    min_length: usize,\\n    \\n    memo: Vec<Vec<Option<usize>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(\\n        vec: Vec<Chr>,\\n        k_max: usize, min_length: usize\\n    ) -> Self {\\n        let n = vec.len();\\n\\n        let memo = vec![vec![None; k_max + 1]; n + 1];\\n\\n        Self {\\n            vec, n,\\n            k_max, min_length,\\n\\n            memo,\\n        }\\n    }\\n}\\n\\nconst MOD: usize = 1_000_000_007;\\n\\nimpl DP {\\n    pub fn solve(&mut self, i: usize, k: usize) -> usize {\\n        if i > self.n { return usize::MIN; }\\n        if k > self.k_max { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[i][k] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(i, k);\\n        self.memo[i][k] = Some(ret);\\n        ret\\n    }\\n\\n    fn is_prime(c: Chr) -> bool {\\n        [2, 3, 5, 7].contains(&c)\\n    }\\n\\n    fn solve_inner(&mut self, i: usize, k: usize) -> usize {\\n        if i >= self.n && k < 1 { return 1; } // found one\\n        if i >= self.n || k < 1 { return usize::MIN; } // still some left\\n\\n        if !Self::is_prime(self.vec[i]) {\\n            return usize::MIN; // does not start with prime\\n        }\\n\\n        let mut ret = usize::MIN;\\n        let i_start = i + self.min_length - 1;\\n        let i_end = self.n - (self.min_length * (k - 1)).min(self.n);\\n        for i_next in i_start..i_end {\\n            if Self::is_prime(self.vec[i_next]) {\\n                continue; // does not end with non-prime\\n            }\\n\\n            ret += self.solve(i_next + 1, k - 1);\\n            ret %= MOD;\\n        }\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    fn preproc(s: String) -> Vec<Chr> {\\n        s.chars()\\n            .map(|c| c as Chr - \\'0\\' as Chr)\\n            .collect::<Vec<_>>()\\n    }\\n\\n    pub fn beautiful_partitions(s: String, k: i32, min_length: i32) -> i32 {\\n        let k = k as usize;\\n        let min_length = min_length as usize;\\n\\n        let vec = Self::preproc(s);\\n\\n        let mut dp = DP::new(vec, k, min_length);\\n        dp.solve(0, k) as i32\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3727767,
                "title": "16ms-100-dp-easy-to-understand-dfs-memo-c",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Dp & memoization\\n    int dp[1001][1001];\\n    int mod=1e9+7;\\n    bool isPrime(char ch){\\n        int no=ch-\\'0\\';\\n        if(no==2 || no==3 || no==5 || no==7){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int find(int i,string& s,int k,int minlen,vector<pair<int,int>>& v){\\n        if(i==s.size()){\\n            if(k==0){\\n               \\n                return 1;\\n            }\\n            return 0;\\n        }\\n        //first optimization ,return is not possible to make partition\\n        if(k<=0 || s.size()-i < minlen*k){\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1){\\n            return dp[i][k];\\n        }\\n        int c=0;\\n        //second optimization in for loop \\n        for(int j=i+minlen-1;j<s.size() && j<s.size()-(k-1)*minlen;j++){\\n            if((j-i+1)>=minlen && k>0 && isPrime(s[i]) && !isPrime(s[j])){\\n                v.push_back({i,j});\\n                c=(c+find(j+1,s,k-1,minlen,v))%mod;\\n                v.pop_back();\\n            }\\n        }\\n        return dp[i][k]=c%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<pair<int,int>> v;\\n        return find(0,s,k,minLength,v);\\n    }\\n};\\n```\\n//Tip=This solution will work get accepted on leetcode but not accepted in interview because it\\'s time complexity is O(i*i*k) which can get TLE if we are not doing optimization",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Dp & memoization\\n    int dp[1001][1001];\\n    int mod=1e9+7;\\n    bool isPrime(char ch){\\n        int no=ch-\\'0\\';\\n        if(no==2 || no==3 || no==5 || no==7){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int find(int i,string& s,int k,int minlen,vector<pair<int,int>>& v){\\n        if(i==s.size()){\\n            if(k==0){\\n               \\n                return 1;\\n            }\\n            return 0;\\n        }\\n        //first optimization ,return is not possible to make partition\\n        if(k<=0 || s.size()-i < minlen*k){\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1){\\n            return dp[i][k];\\n        }\\n        int c=0;\\n        //second optimization in for loop \\n        for(int j=i+minlen-1;j<s.size() && j<s.size()-(k-1)*minlen;j++){\\n            if((j-i+1)>=minlen && k>0 && isPrime(s[i]) && !isPrime(s[j])){\\n                v.push_back({i,j});\\n                c=(c+find(j+1,s,k-1,minlen,v))%mod;\\n                v.pop_back();\\n            }\\n        }\\n        return dp[i][k]=c%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<pair<int,int>> v;\\n        return find(0,s,k,minLength,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701971,
                "title": "ez-memo-self-understandable-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int md=1e9+7;\\n    int helper(string &s,int k,int minl,int idx,vector<vector<int>>&dp){\\n        if(k<0)return 0;\\n        if(idx>=s.size()){\\n            if(k==0)return 1;\\n            return 0;\\n        }\\n        if(dp[idx][k]!=-1)return dp[idx][k]%md;\\n        int ans=0;\\n        int n=s.size();\\n        if(s[idx]==\\'2\\' || s[idx]==\\'3\\' || s[idx]==\\'5\\' || s[idx]==\\'7\\'){\\n            for(int i=idx+minl-1;i<min(n,n-(k-1)*minl);i++){\\n                if(s[i]==\\'1\\' || s[i]==\\'4\\' || s[i]==\\'6\\' || s[i]==\\'8\\' || s[i]==\\'9\\' || s[i]==\\'0\\'){\\n                    ans=(helper(s,k-1,minl,i+1,dp)+ans)%md;\\n                }\\n            }\\n        }\\n        return dp[idx][k]=ans%md;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        vector<vector<int>>dp(s.size()+1,vector<int>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%md;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int md=1e9+7;\\n    int helper(string &s,int k,int minl,int idx,vector<vector<int>>&dp){\\n        if(k<0)return 0;\\n        if(idx>=s.size()){\\n            if(k==0)return 1;\\n            return 0;\\n        }\\n        if(dp[idx][k]!=-1)return dp[idx][k]%md;\\n        int ans=0;\\n        int n=s.size();\\n        if(s[idx]==\\'2\\' || s[idx]==\\'3\\' || s[idx]==\\'5\\' || s[idx]==\\'7\\'){\\n            for(int i=idx+minl-1;i<min(n,n-(k-1)*minl);i++){\\n                if(s[i]==\\'1\\' || s[i]==\\'4\\' || s[i]==\\'6\\' || s[i]==\\'8\\' || s[i]==\\'9\\' || s[i]==\\'0\\'){\\n                    ans=(helper(s,k-1,minl,i+1,dp)+ans)%md;\\n                }\\n            }\\n        }\\n        return dp[idx][k]=ans%md;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        vector<vector<int>>dp(s.size()+1,vector<int>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%md;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594376,
                "title": "c-dp-prefixsum-o-nk",
                "content": "- First find all cut `pos`ition regardless of `minLength` constraint, \\n- Taking into  `minLength` constraint, this also gives subsolution `sum` of `k = 1` partition for substrings ending at cut `pos`itions.\\n- In each iterative dynamic programming step,\\n1. increase partition size by 1.\\n2. check previous `sum[i]` contributes to current `sum[j]` by adding substr `[i, j)`\\n3. This is also a typical prefix sum problem, because if previous `sum[i]` contributes to current `sum[j1]`, then it also contributes to `sum[j2]` for any `j2 > j1`.\\n```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int K, int minLength) {\\n        int mod = 1\\'000\\'000\\'007;\\n        auto isprime = [&s](int i) { auto n = s[i]; return n == \\'2\\' || n == \\'3\\' || n == \\'5\\' || n == \\'7\\'; };\\n        if(!isprime(0) || isprime(s.size()-1))\\n            return 0;\\n        \\n        vector<int> pos, sum;\\n        for(int i = 0; i < s.size(); ++i) {\\n            if(!isprime(i) && (i+1 == s.size() || isprime(i+1))) {\\n                pos.push_back(i+1);\\n                sum.push_back(i+1 >= minLength ? 1 : 0);\\n            }\\n        }\\n        for(int sz = sum.size(), k = 0; k < K-1; ++k) {\\n            vector<int> sum2(sz);\\n            for(int i = k, j = i+1; j < sz; ++j) {\\n                sum2[j] = (sum2[j-1] + sum2[j]) % mod;\\n                while(i < sz && pos[j] - pos[i] >= minLength)\\n                    sum2[j] = (sum[i++] + sum2[j]) % mod;\\n            }\\n            swap(sum, sum2);\\n        }\\n        return sum.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int K, int minLength) {\\n        int mod = 1\\'000\\'000\\'007;\\n        auto isprime = [&s](int i) { auto n = s[i]; return n == \\'2\\' || n == \\'3\\' || n == \\'5\\' || n == \\'7\\'; };\\n        if(!isprime(0) || isprime(s.size()-1))\\n            return 0;\\n        \\n        vector<int> pos, sum;\\n        for(int i = 0; i < s.size(); ++i) {\\n            if(!isprime(i) && (i+1 == s.size() || isprime(i+1))) {\\n                pos.push_back(i+1);\\n                sum.push_back(i+1 >= minLength ? 1 : 0);\\n            }\\n        }\\n        for(int sz = sum.size(), k = 0; k < K-1; ++k) {\\n            vector<int> sum2(sz);\\n            for(int i = k, j = i+1; j < sz; ++j) {\\n                sum2[j] = (sum2[j-1] + sum2[j]) % mod;\\n                while(i < sz && pos[j] - pos[i] >= minLength)\\n                    sum2[j] = (sum[i++] + sum2[j]) % mod;\\n            }\\n            swap(sum, sum2);\\n        }\\n        return sum.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574917,
                "title": "dp-recursion-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod=1000000007;\\n    long long dp[1001][1001];\\n    bool isPrime(int x){\\n        if(x==2||x==3||x==5||x==7) return 1;\\n        return 0;\\n    }\\n    long long find(int ind, string &s, int k, int len, int curr){\\n        if(ind==s.length()){\\n            return (curr==k);\\n        }\\n        if(!isPrime(s[ind]-\\'0\\')) return 0;\\n        if(ind+len*(k-curr)>s.size()) return 0;\\n        if(dp[ind][curr]!=-1) return dp[ind][curr];\\n        long long ans=0;\\n        for(int i=ind+len-1; i<s.length(); i++){\\n            if(!isPrime(s[i]-\\'0\\')){\\n                ans=(ans+find(i+1,s,k,len,curr+1))%mod;\\n            }\\n        }\\n        return dp[ind][curr]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=find(0,s,k,minLength,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=1000000007;\\n    long long dp[1001][1001];\\n    bool isPrime(int x){\\n        if(x==2||x==3||x==5||x==7) return 1;\\n        return 0;\\n    }\\n    long long find(int ind, string &s, int k, int len, int curr){\\n        if(ind==s.length()){\\n            return (curr==k);\\n        }\\n        if(!isPrime(s[ind]-\\'0\\')) return 0;\\n        if(ind+len*(k-curr)>s.size()) return 0;\\n        if(dp[ind][curr]!=-1) return dp[ind][curr];\\n        long long ans=0;\\n        for(int i=ind+len-1; i<s.length(); i++){\\n            if(!isPrime(s[i]-\\'0\\')){\\n                ans=(ans+find(i+1,s,k,len,curr+1))%mod;\\n            }\\n        }\\n        return dp[ind][curr]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=find(0,s,k,minLength,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482639,
                "title": "easiest-solution-there-is-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach and explination (TLE)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Example for explination (TLE)\\n\\n# Complexity (TLE)\\n\\n# Approach and explination\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Example for explination\\n\\n# Complexity\\n\\n# Code\\n```\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449436,
                "title": "simple-dp-solution-c",
                "content": "# Complexity\\n- Time complexity: O(L*K) l is the length of string s\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(L*K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // function to check if char is not prime  .\\n    bool notprime(char c){\\n        return !(c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c ==\\'7\\');\\n    }\\n\\n    int solve(vector<vector<int>> &dp, int ind,int k,const string& s,int &ml){\\n        if(ind == s.length()) return 1;\\n        if(k == 0) return dp[ind][k] = 0;\\n        if(dp[ind][k] != -1) return dp[ind][k];\\n        if(notprime(s[ind])) return dp[ind][k] = 0;\\n        int ans = 0;\\n        // we have to make k groups starting at ind and of min length ml\\n        for(int i = ind+ml-1;i<s.length()-(k-1)*ml;i++){\\n            // we will check if the end digit of string is not prime\\n            if(notprime(s[i])){ ans += solve(dp,i+1,k-1,s,ml); ans %= 1000000007; }\\n        }\\n        return dp[ind][k] = ans;\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if((s.length()/minLength) < k || (notprime(s[0]) || !notprime(s[s.length()-1]))) return 0;\\n        vector<vector<int>> dp(s.length()+1,vector<int>(k+1,-1));\\n        return solve(dp,0,k,s,minLength);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to check if char is not prime  .\\n    bool notprime(char c){\\n        return !(c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c ==\\'7\\');\\n    }\\n\\n    int solve(vector<vector<int>> &dp, int ind,int k,const string& s,int &ml){\\n        if(ind == s.length()) return 1;\\n        if(k == 0) return dp[ind][k] = 0;\\n        if(dp[ind][k] != -1) return dp[ind][k];\\n        if(notprime(s[ind])) return dp[ind][k] = 0;\\n        int ans = 0;\\n        // we have to make k groups starting at ind and of min length ml\\n        for(int i = ind+ml-1;i<s.length()-(k-1)*ml;i++){\\n            // we will check if the end digit of string is not prime\\n            if(notprime(s[i])){ ans += solve(dp,i+1,k-1,s,ml); ans %= 1000000007; }\\n        }\\n        return dp[ind][k] = ans;\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if((s.length()/minLength) < k || (notprime(s[0]) || !notprime(s[s.length()-1]))) return 0;\\n        vector<vector<int>> dp(s.length()+1,vector<int>(k+1,-1));\\n        return solve(dp,0,k,s,minLength);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420774,
                "title": "c-with-detailed-transition-equation-o-n-2-bottom-up-dp",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt\\'s easy to come up with the $$O(n^3)$$ solution.\\n$$dp[n][k]$$ means for the first $$n$$ elements, in how many ways we can have $$k$$ valid partitions. Then for each split-able position $$j$$, \\n$$dp[n][k] = \\\\sum_{j=1}^{n}{dp[j][k-1]}$$\\n\\nHowever, if we redesign the state representation, let $$dp[n][k]$$ be, in how many ways we can have $$k$$ incomplete partitions. By *incomplete*, it means the last partition may or may not have $$minLen$$ elements. With this definition, the transition would be\\n$$dp[n][k] = dp[n-minLen][k-1] + dp[n-1][k]$$ if we can split at n.\\nOtherwise $$dp[n][k] = dp[n-1][k]$$. The final answer would be $$dp[n-minLen][k]$$.\\n\\nNow we have the $$O(n^2)$$ solution. If we take a look at the first approach, we\\'d find that a large part of the states space were wasted (the ones unsplitable).\\n\\n# Code\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    const int MOD = 1000000000 + 7;\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        bool pd[10] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0};\\n        int n = s.length();\\n        if (!pd[s[0]-\\'0\\'] || pd[s[n-1]-\\'0\\']) {\\n            return 0;\\n        }\\n        memset(dp, 0, sizeof(dp));\\n        dp[0][1] = 1;\\n        for (int i = 1; i < n; i++) {\\n            dp[i][1] = 1;\\n            for (int j = 2; j <= k; j++) {\\n                if (pd[s[i] - \\'0\\'] && !pd[s[i-1] - \\'0\\']) {\\n                    int p = i - minLength;\\n                    if (p >= 0) {\\n                        dp[i][j] = (dp[i][j] + dp[p][j - 1]) % MOD;\\n                    }\\n                }\\n                dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\\n            }\\n        }\\n        return dp[n - minLength][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    const int MOD = 1000000000 + 7;\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        bool pd[10] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0};\\n        int n = s.length();\\n        if (!pd[s[0]-\\'0\\'] || pd[s[n-1]-\\'0\\']) {\\n            return 0;\\n        }\\n        memset(dp, 0, sizeof(dp));\\n        dp[0][1] = 1;\\n        for (int i = 1; i < n; i++) {\\n            dp[i][1] = 1;\\n            for (int j = 2; j <= k; j++) {\\n                if (pd[s[i] - \\'0\\'] && !pd[s[i-1] - \\'0\\']) {\\n                    int p = i - minLength;\\n                    if (p >= 0) {\\n                        dp[i][j] = (dp[i][j] + dp[p][j - 1]) % MOD;\\n                    }\\n                }\\n                dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\\n            }\\n        }\\n        return dp[n - minLength][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321135,
                "title": "solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n,k)\\n\\n- Space complexity:\\nO(1010*1010)\\n\\n# Code\\n```\\nint  dp [1010][1010];\\nstring ss;\\nint max_k;\\nint minlen;\\nint n;\\nconst int Mod = 1e9+7;\\n\\n\\n\\nclass Solution {\\n    \\nbool is_prime(char d)\\n{\\n    if(d==\\'2\\' or d==\\'3\\' or d==\\'5\\' or d==\\'7\\')\\n        return true;\\n    return false;\\n    \\n}\\n    \\n    \\nint call(int i,int k)\\n{\\n    \\n    if(k==max_k-1)\\n    {\\n        if(i>=n or i+minlen>n)\\n            return 0;\\n        \\n        if(is_prime(ss[i]) and !is_prime(ss[n-1]))\\n            return 1;\\n        \\n        return 0;\\n    }\\n     if(i>=n or i+minlen>n)\\n            return 0;\\n        \\n    \\n    if(dp[i][k]!=-1)\\n        return dp[i][k];\\n    \\n  \\n    int  ans = 0;\\n    \\n    for(int s = i+minlen-1; s<n; s++)\\n        if(is_prime(ss[i]) and !is_prime(ss[s]))\\n              ans= (ans+call(s+1,k+1))%Mod;\\n      \\n    return dp[i][k]=ans;\\n    \\n}\\n    \\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        ss=s;\\n        max_k=k;\\n        minlen=minLength;\\n        n=s.size();\\n        \\n        return call(0,0);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint  dp [1010][1010];\\nstring ss;\\nint max_k;\\nint minlen;\\nint n;\\nconst int Mod = 1e9+7;\\n\\n\\n\\nclass Solution {\\n    \\nbool is_prime(char d)\\n{\\n    if(d==\\'2\\' or d==\\'3\\' or d==\\'5\\' or d==\\'7\\')\\n        return true;\\n    return false;\\n    \\n}\\n    \\n    \\nint call(int i,int k)\\n{\\n    \\n    if(k==max_k-1)\\n    {\\n        if(i>=n or i+minlen>n)\\n            return 0;\\n        \\n        if(is_prime(ss[i]) and !is_prime(ss[n-1]))\\n            return 1;\\n        \\n        return 0;\\n    }\\n     if(i>=n or i+minlen>n)\\n            return 0;\\n        \\n    \\n    if(dp[i][k]!=-1)\\n        return dp[i][k];\\n    \\n  \\n    int  ans = 0;\\n    \\n    for(int s = i+minlen-1; s<n; s++)\\n        if(is_prime(ss[i]) and !is_prime(ss[s]))\\n              ans= (ans+call(s+1,k+1))%Mod;\\n      \\n    return dp[i][k]=ans;\\n    \\n}\\n    \\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        ss=s;\\n        max_k=k;\\n        minlen=minLength;\\n        n=s.size();\\n        \\n        return call(0,0);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289988,
                "title": "c-dp-o-n-k",
                "content": "```\\nclass Solution {\\npublic:\\n  int beautifulPartitions(string s, int k, int minLength) {\\n    if(!prime(s[0]) || prime(s.back())) return 0;\\n    init(s, k, minLength);\\n    int res =  (dp(n, k) + mod - dp(n-1, k)) % mod;\\n    return res;\\n  }\\n\\n  int dp(int i, int k) {\\n    if (i < 0 || k < 0) return 0;\\n    auto& res = vdp[i][k];\\n    if (res > -1) return res;\\n    res = dp(i - 1, k);\\n    if (isGood(i)) res += dp(i - minLen, k - 1);\\n    return res % mod;\\n  }\\n\\n  void init(const string &s, int k, int minLength) {\\n    n = s.size();\\n    minLen = minLength;\\n    vdp = vector(n + 1, vector(k + 1, -1LL));\\n    vdp[0][0] = 1;\\n    for (auto c : s) isPrime.push_back(prime(c));\\n  }\\n\\n  bool prime(char c){\\n      static const string primes = \"2357\";\\n      return primes.find(c) != string::npos;\\n  }\\n\\n  bool isGood(int i) { return (i == n || isPrime[i]) && (i==0 || !isPrime[i-1]); }\\n\\n  const long long mod = 1e9 + 7;\\n  int n;\\n  int minLen;\\n  vector<bool> isPrime;\\n  vector<vector<long long>> vdp;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int beautifulPartitions(string s, int k, int minLength) {\\n    if(!prime(s[0]) || prime(s.back())) return 0;\\n    init(s, k, minLength);\\n    int res =  (dp(n, k) + mod - dp(n-1, k)) % mod;\\n    return res;\\n  }\\n\\n  int dp(int i, int k) {\\n    if (i < 0 || k < 0) return 0;\\n    auto& res = vdp[i][k];\\n    if (res > -1) return res;\\n    res = dp(i - 1, k);\\n    if (isGood(i)) res += dp(i - minLen, k - 1);\\n    return res % mod;\\n  }\\n\\n  void init(const string &s, int k, int minLength) {\\n    n = s.size();\\n    minLen = minLength;\\n    vdp = vector(n + 1, vector(k + 1, -1LL));\\n    vdp[0][0] = 1;\\n    for (auto c : s) isPrime.push_back(prime(c));\\n  }\\n\\n  bool prime(char c){\\n      static const string primes = \"2357\";\\n      return primes.find(c) != string::npos;\\n  }\\n\\n  bool isGood(int i) { return (i == n || isPrime[i]) && (i==0 || !isPrime[i-1]); }\\n\\n  const long long mod = 1e9 + 7;\\n  int n;\\n  int minLen;\\n  vector<bool> isPrime;\\n  vector<vector<long long>> vdp;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273942,
                "title": "o-k-n-iterative-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int beautifulPartitions(string s, int k, int minL) {\\n        auto isPrime = [](char x)->bool{\\n            return (x == \\'2\\' || x == \\'3\\' || x == \\'5\\' || x == \\'7\\');\\n        };\\n        int dp[1004][1004]{};\\n        int n = s.size();\\n        \\n        dp[0][0] = 1;\\n        for(int j = 1; j <= k; j++){\\n            int preSum = 0;\\n            for(int i = 1; i <= n; i++){\\n                int lastPartitionBeginIdx = i - minL;\\n                if(lastPartitionBeginIdx == 0 && isPrime(s[0])){\\n                    (preSum += dp[0][j - 1] %mod)%=mod;\\n                }else if(lastPartitionBeginIdx > 0 && isPrime(s[lastPartitionBeginIdx]) && !isPrime(s[lastPartitionBeginIdx - 1])){\\n                    (preSum += dp[lastPartitionBeginIdx][j - 1] % mod)%=mod;\\n                }\\n                if(!isPrime(s[i - 1])){\\n                    dp[i][j] = preSum;\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int beautifulPartitions(string s, int k, int minL) {\\n        auto isPrime = [](char x)->bool{\\n            return (x == \\'2\\' || x == \\'3\\' || x == \\'5\\' || x == \\'7\\');\\n        };\\n        int dp[1004][1004]{};\\n        int n = s.size();\\n        \\n        dp[0][0] = 1;\\n        for(int j = 1; j <= k; j++){\\n            int preSum = 0;\\n            for(int i = 1; i <= n; i++){\\n                int lastPartitionBeginIdx = i - minL;\\n                if(lastPartitionBeginIdx == 0 && isPrime(s[0])){\\n                    (preSum += dp[0][j - 1] %mod)%=mod;\\n                }else if(lastPartitionBeginIdx > 0 && isPrime(s[lastPartitionBeginIdx]) && !isPrime(s[lastPartitionBeginIdx - 1])){\\n                    (preSum += dp[lastPartitionBeginIdx][j - 1] % mod)%=mod;\\n                }\\n                if(!isPrime(s[i - 1])){\\n                    dp[i][j] = preSum;\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206059,
                "title": "java-recursion-dp-memoization-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    private int mod=1000000007;\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        if(!checkPrime(s.charAt(0)) || checkPrime(s.charAt(s.length()-1)))    return 0;\\n        List<Integer> possibleDivisionInd= new ArrayList<>();\\n        possibleDivisionInd.add(0);\\n        boolean prevIsPrime=checkPrime(s.charAt(minLength-1));\\n        for(int i=minLength;i<=s.length()-minLength;i++){\\n            boolean currIsPrime=checkPrime(s.charAt(i));\\n            if(!prevIsPrime && currIsPrime) possibleDivisionInd.add(i);\\n            prevIsPrime=currIsPrime;\\n        }\\n        int n=possibleDivisionInd.size();\\n        if(n<k-1)   return 0;\\n        int dp[][]=new int[n][k];\\n        for(int i[]:dp) Arrays.fill(i,-1);\\n        return get_ans(possibleDivisionInd,0,k-1,minLength,dp,n);\\n    }\\n    private int get_ans(List<Integer> pTD,int ind,int k,int minLen,int[][] dp,int n){\\n        if(k==0)    return dp[ind][k]=(k==0?1:0);\\n        if(dp[ind][k]!=-1)    return dp[ind][k];\\n        int ans=0,minNextInd=pTD.get(ind)+minLen;\\n        for(int nextInd=ind+1;nextInd<n && n-nextInd>=k;nextInd++){   \\n            if(minNextInd<=pTD.get(nextInd)){\\n                ans=(ans+get_ans(pTD,nextInd,k-1,minLen,dp,n))%mod;\\n            }\\n        }\\n        return dp[ind][k]=ans;\\n    }\\n    private boolean checkPrime(char c){\\n        return (c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int mod=1000000007;\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        if(!checkPrime(s.charAt(0)) || checkPrime(s.charAt(s.length()-1)))    return 0;\\n        List<Integer> possibleDivisionInd= new ArrayList<>();\\n        possibleDivisionInd.add(0);\\n        boolean prevIsPrime=checkPrime(s.charAt(minLength-1));\\n        for(int i=minLength;i<=s.length()-minLength;i++){\\n            boolean currIsPrime=checkPrime(s.charAt(i));\\n            if(!prevIsPrime && currIsPrime) possibleDivisionInd.add(i);\\n            prevIsPrime=currIsPrime;\\n        }\\n        int n=possibleDivisionInd.size();\\n        if(n<k-1)   return 0;\\n        int dp[][]=new int[n][k];\\n        for(int i[]:dp) Arrays.fill(i,-1);\\n        return get_ans(possibleDivisionInd,0,k-1,minLength,dp,n);\\n    }\\n    private int get_ans(List<Integer> pTD,int ind,int k,int minLen,int[][] dp,int n){\\n        if(k==0)    return dp[ind][k]=(k==0?1:0);\\n        if(dp[ind][k]!=-1)    return dp[ind][k];\\n        int ans=0,minNextInd=pTD.get(ind)+minLen;\\n        for(int nextInd=ind+1;nextInd<n && n-nextInd>=k;nextInd++){   \\n            if(minNextInd<=pTD.get(nextInd)){\\n                ans=(ans+get_ans(pTD,nextInd,k-1,minLen,dp,n))%mod;\\n            }\\n        }\\n        return dp[ind][k]=ans;\\n    }\\n    private boolean checkPrime(char c){\\n        return (c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199810,
                "title": "c-dp-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m = 1e9+7;\\n    bool isPrime(char n){\\n        return (n==\\'2\\' || n==\\'3\\' || n==\\'5\\' || n==\\'7\\');\\n    }\\n    int dp[1001][1001];\\n    int f(string &s, int k, int minLen, int i){\\n        if(!k) return i<=s.size();\\n        if(i>=s.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int res = f(s, k, minLen, i+1);\\n        if(!isPrime(s[i-1]) && isPrime(s[i])){\\n            res = (res + f(s, k-1, minLen, i+minLen))%m;\\n        }\\n        \\n        return dp[i][k] = res;\\n    }\\n    int beautifulPartitions(string s, int k, int minLen) {\\n        if(isPrime(s.back()) || !isPrime(s[0])) return 0;\\n        memset(dp, -1, sizeof(dp));\\n        return f(s, k-1, minLen, minLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1e9+7;\\n    bool isPrime(char n){\\n        return (n==\\'2\\' || n==\\'3\\' || n==\\'5\\' || n==\\'7\\');\\n    }\\n    int dp[1001][1001];\\n    int f(string &s, int k, int minLen, int i){\\n        if(!k) return i<=s.size();\\n        if(i>=s.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int res = f(s, k, minLen, i+1);\\n        if(!isPrime(s[i-1]) && isPrime(s[i])){\\n            res = (res + f(s, k-1, minLen, i+minLen))%m;\\n        }\\n        \\n        return dp[i][k] = res;\\n    }\\n    int beautifulPartitions(string s, int k, int minLen) {\\n        if(isPrime(s.back()) || !isPrime(s[0])) return 0;\\n        memset(dp, -1, sizeof(dp));\\n        return f(s, k-1, minLen, minLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180970,
                "title": "c-very-easy-solution-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001] ;\\n    int mod= 1e9+7; \\n    bool prime(char & ch )\\n    {\\n       if(ch==\\'2\\' || ch==\\'3\\' || ch==\\'5\\' || ch==\\'7\\')\\n           return true ;\\n        return false ;\\n    }\\n    \\n      bool notprime(char &  ch )\\n    {\\n       if(ch!=\\'2\\' && ch!=\\'3\\' && ch!=\\'5\\' && ch!=\\'7\\')\\n           return true ;\\n        return false ;\\n    }\\n    \\n    int cal(int i, string & s, int n , int k , int ml)\\n    {\\n        if(k==1)\\n        {\\n            \\n            if( prime(s[i]) && notprime(s[n-1]) && (n-1 - i +1 )>=ml)\\n               {  return 1 ;}\\n            return 0 ; \\n        }\\n        \\n        if(dp[i][k]!=-1)\\n            return dp[i][k] ;\\n        \\n        \\n        long long a= 0; \\n        \\n        for(int j =i ;j<n; j++)\\n        {\\n            if( prime(s[i]) && notprime(s[j]) && j-i+1>=ml)\\n            {\\n                // cout << i << \" \" << j << endl ;\\n              a= (a+cal(j+1, s , n , k-1, ml ))%mod;   \\n            }\\n            \\n        }\\n        \\n        return dp[i][k] = a%mod; \\n        \\n    }\\n    \\n    \\n    \\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n       \\n        if(notprime(s[0]))\\n            return 0 ;\\n        \\n        memset(dp , -1, sizeof(dp)) ;\\n        return cal(0, s, s.length() , k ,minLength ) ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001] ;\\n    int mod= 1e9+7; \\n    bool prime(char & ch )\\n    {\\n       if(ch==\\'2\\' || ch==\\'3\\' || ch==\\'5\\' || ch==\\'7\\')\\n           return true ;\\n        return false ;\\n    }\\n    \\n      bool notprime(char &  ch )\\n    {\\n       if(ch!=\\'2\\' && ch!=\\'3\\' && ch!=\\'5\\' && ch!=\\'7\\')\\n           return true ;\\n        return false ;\\n    }\\n    \\n    int cal(int i, string & s, int n , int k , int ml)\\n    {\\n        if(k==1)\\n        {\\n            \\n            if( prime(s[i]) && notprime(s[n-1]) && (n-1 - i +1 )>=ml)\\n               {  return 1 ;}\\n            return 0 ; \\n        }\\n        \\n        if(dp[i][k]!=-1)\\n            return dp[i][k] ;\\n        \\n        \\n        long long a= 0; \\n        \\n        for(int j =i ;j<n; j++)\\n        {\\n            if( prime(s[i]) && notprime(s[j]) && j-i+1>=ml)\\n            {\\n                // cout << i << \" \" << j << endl ;\\n              a= (a+cal(j+1, s , n , k-1, ml ))%mod;   \\n            }\\n            \\n        }\\n        \\n        return dp[i][k] = a%mod; \\n        \\n    }\\n    \\n    \\n    \\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n       \\n        if(notprime(s[0]))\\n            return 0 ;\\n        \\n        memset(dp , -1, sizeof(dp)) ;\\n        return cal(0, s, s.length() , k ,minLength ) ;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3179146,
                "title": "efficient-python-solution-dp-beats-100-space-and-time",
                "content": "# Intuition\\nWe solve this problem using a 2d DP where $DP[i][j]$ stores how many ways we can have $i$ substrings using indices $0 ... j$. Note that it MUST use the last index $j$.\\nWe have the recursive case where $DP[i][j]$ is equal to all $sum(DP[i-1][0] ... DP[i-1[j-minlength])$ filtered by if they are followed by a prime number whenever the string at index $j$ is not prime. \\nThis is because if we choose index $x$ to be the prime that starts the $ith$ substring, there are $dp[i-1][x-1]$ ways to split the substring before $x$.\\nWe can save work by keeping a running count instead of restarting for each x.\\n\\n# Approach\\nSet up 2d matrix and go go go.\\n\\n# Complexity\\n- Time complexity:\\n$$O(NK)$$\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        MOD = 1000000007\\n        minLength = max(minLength, 2)  # need a length of at least 2 for prime start, nonprime end\\n        n = len(s)\\n        primes = [char in \"2357\" for char in s]\\n        if not primes[0] or primes[-1] or minLength * k > n:\\n            return 0\\n\\n        prev, dp = [0] * n, [0] * n\\n        prev[-1] = 1 # set last index in prev to 1 for first iteration. Won\\'t affect answer since last index guaranteed to be overriden on dp side and won\\'t be reused in prev side.\\n        for y in range(k):\\n            starts = 0\\n            for x in range((y + 1) * minLength - 1, n - (k - (y + 1)) * minLength): # save some work by not computing unused indices (not necessary)\\n                if primes[x - minLength + 1]: # look back at least minlength - 1 to find starts to preserve minLength\\n                    starts += prev[x-minLength]\\n\\n                if not primes[x]:\\n                    dp[x] = starts % MOD \\n            dp, prev = prev, dp\\n\\n        return prev[-1] % MOD  # FORGOT MOD AAAHAAHHHH\\n\\n```\\nI forgot the mod and spent a long time debugging my code :D\\n\\n![Screenshot 2023-02-12 at 10.25.39 PM.png](https://assets.leetcode.com/users/images/58138bb0-a5d1-453c-a69e-04ea68552af6_1676269571.714017.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        MOD = 1000000007\\n        minLength = max(minLength, 2)  # need a length of at least 2 for prime start, nonprime end\\n        n = len(s)\\n        primes = [char in \"2357\" for char in s]\\n        if not primes[0] or primes[-1] or minLength * k > n:\\n            return 0\\n\\n        prev, dp = [0] * n, [0] * n\\n        prev[-1] = 1 # set last index in prev to 1 for first iteration. Won\\'t affect answer since last index guaranteed to be overriden on dp side and won\\'t be reused in prev side.\\n        for y in range(k):\\n            starts = 0\\n            for x in range((y + 1) * minLength - 1, n - (k - (y + 1)) * minLength): # save some work by not computing unused indices (not necessary)\\n                if primes[x - minLength + 1]: # look back at least minlength - 1 to find starts to preserve minLength\\n                    starts += prev[x-minLength]\\n\\n                if not primes[x]:\\n                    dp[x] = starts % MOD \\n            dp, prev = prev, dp\\n\\n        return prev[-1] % MOD  # FORGOT MOD AAAHAAHHHH\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165081,
                "title": "bottom-up-dp",
                "content": "First, select out all valid split positions `pos`, here valid means before and after the split position, there are both at least `minLength` letters.\\n\\nLet `m` be the number of valid split positions, then number of taking `k-1` split positions in the `m` is the final result.\\n\\nLet `dp[i][j]` be number of taking `j` split positions in first `i` split positions, then\\n```\\nif i = 0 or j = 0: dp[i][j] = 1\\n\\nif i > 0 and j > 0: dp[i][j] = dp[i-1][j] + dp[l][j-1]\\nwhere l is the most right valid split postion before i if i has taken.\\n(e.g. l = max{x | pos[i] - pos[x] >= minLength})\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        primes = set(\\'2357\\')\\n        if s[0] not in primes or s[-1] in primes:\\n            return 0\\n        n = len(s)\\n        pos = [i+1 for i in range(n-1) if s[i] not in primes and s[i+1] in primes and i+1 >= minLength and n-i-1 >= minLength]  # valid split positions\\n        m = len(pos)\\n        # dp[i][j] means: number of taking j split positions in first i positions\\n        dp = [[0] * k for i in range(m + 1)]\\n        dp[0][0] = 1\\n        for i in range(1, m + 1):\\n            l = i - 1\\n            while l - 1 >= 0 and pos[i - 1] - pos[l - 1] < minLength:\\n                l -= 1\\n            dp[i][0] = 1\\n            for j in range(1, min(i + 1, k)):\\n                dp[i][j] = (dp[i - 1][j] + dp[l][j - 1]) % (10**9+7)\\n        return dp[m][k - 1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nif i = 0 or j = 0: dp[i][j] = 1\\n\\nif i > 0 and j > 0: dp[i][j] = dp[i-1][j] + dp[l][j-1]\\nwhere l is the most right valid split postion before i if i has taken.\\n(e.g. l = max{x | pos[i] - pos[x] >= minLength})\\n```\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        primes = set(\\'2357\\')\\n        if s[0] not in primes or s[-1] in primes:\\n            return 0\\n        n = len(s)\\n        pos = [i+1 for i in range(n-1) if s[i] not in primes and s[i+1] in primes and i+1 >= minLength and n-i-1 >= minLength]  # valid split positions\\n        m = len(pos)\\n        # dp[i][j] means: number of taking j split positions in first i positions\\n        dp = [[0] * k for i in range(m + 1)]\\n        dp[0][0] = 1\\n        for i in range(1, m + 1):\\n            l = i - 1\\n            while l - 1 >= 0 and pos[i - 1] - pos[l - 1] < minLength:\\n                l -= 1\\n            dp[i][0] = 1\\n            for j in range(1, min(i + 1, k)):\\n                dp[i][j] = (dp[i - 1][j] + dp[l][j - 1]) % (10**9+7)\\n        return dp[m][k - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076815,
                "title": "dp-with-o-nk-time-o-n-space-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs there are overlapping subproblems, a DP approach makes sense here.\\nWe can define $$f(n,k)$$ as the number of ways to create $$k$$ beautiful partitions ending at the $$n$$-th character of the input string.\\n\\n$$f(n,k)$$ can be calculated as a sum of $$f(i, k-1)$$, where the $$(i+1)$$-th character is prime for all $$i$$, and the $$n$$-th character is non-prime.\\n\\nFrom here, we can easily come up with a $$O(n^2 k)$$ time, $$O(nk)$$ space solution using a $$n$$ by $$k$$ matrix, and doing calculating each entry from the bottom-up (direct calculation takes $$O(n)$$ time). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA prefix sum can be used reduce the time complexity. For all i, $$f(i, k)$$ require a sum of $$f(j, k-1)$$, so we can perform the calculations for each $$k$$ in $$O(n)$$ time.  \\n\\nReducing space complexity: since the calculation of $$f(n,k)$$ only requires previously calculated values for $$(k-1)$$ partitions, we do not need a full $$n$$ x $$k$$ 2D vector, only 2 vectors of size $$n$$ to store $$f(j, k-1)$$ and $$f(i, k)$$ and reuse them while iterating over $$k$$.dp\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nk)$$\\n\\n- Space complexity:\\n\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        array<bool, 9> is_prime {false, true, true, false, true, false, true, false, false};\\n        vector<int> partition_count(s.length(), 0);\\n        vector<int> partition_temp(s.length(), 0);\\n\\n        if (!is_prime[s[0] - \\'1\\'] || is_prime[s[s.length() - 1] - \\'1\\']) return 0;\\n        if (minLength == 1) minLength = 2;\\n        if (minLength * k > s.length()) return 0;\\n        if (k == 1) return 1;\\n\\n        for (int i = minLength - 1; i < s.length(); ++i) {\\n            if (!is_prime[s[i] - \\'1\\']) partition_count[i] = 1;\\n        }\\n\\n        int mod = 1e9 + 7;\\n        for (int p = 2; p <= k; ++p) {\\n            int i = p * minLength - 1;\\n            int max = s.length() - (k-p)*minLength;\\n            int count {0};\\n            for (; i < max; ++i) {\\n                if (is_prime[s[i - minLength + 1] - \\'1\\']) count = (count + partition_count[i-minLength]) % mod;\\n                if (is_prime[s[i] - \\'1\\']) partition_temp[i] = 0;\\n                else partition_temp[i] = count;\\n            }\\n            swap(partition_count, partition_temp);\\n        }\\n\\n        return partition_count.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        array<bool, 9> is_prime {false, true, true, false, true, false, true, false, false};\\n        vector<int> partition_count(s.length(), 0);\\n        vector<int> partition_temp(s.length(), 0);\\n\\n        if (!is_prime[s[0] - \\'1\\'] || is_prime[s[s.length() - 1] - \\'1\\']) return 0;\\n        if (minLength == 1) minLength = 2;\\n        if (minLength * k > s.length()) return 0;\\n        if (k == 1) return 1;\\n\\n        for (int i = minLength - 1; i < s.length(); ++i) {\\n            if (!is_prime[s[i] - \\'1\\']) partition_count[i] = 1;\\n        }\\n\\n        int mod = 1e9 + 7;\\n        for (int p = 2; p <= k; ++p) {\\n            int i = p * minLength - 1;\\n            int max = s.length() - (k-p)*minLength;\\n            int count {0};\\n            for (; i < max; ++i) {\\n                if (is_prime[s[i - minLength + 1] - \\'1\\']) count = (count + partition_count[i-minLength]) % mod;\\n                if (is_prime[s[i] - \\'1\\']) partition_temp[i] = 0;\\n                else partition_temp[i] = count;\\n            }\\n            swap(partition_count, partition_temp);\\n        }\\n\\n        return partition_count.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047518,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s, k, minLength):\\n        n = len(s)\\n\\n        def is_prime(t):\\n            return t in [\"2\",\"3\",\"5\",\"7\"]\\n\\n        if not is_prime(s[0]) or is_prime(s[-1]):\\n            return 0\\n\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if i <= n and k == 0:\\n                return 1\\n\\n            if i >= n:\\n                return 0\\n\\n            count = dfs(i+1,k)\\n\\n            if is_prime(s[i]) and not is_prime(s[i-1]):\\n                count += dfs(i+minLength,k-1)\\n\\n            return count%(10**9+7)\\n\\n        return dfs(minLength,k-1)%(10**9+7)\\n\\n\\n            \\n\\n\\n\\n\\n                \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s, k, minLength):\\n        n = len(s)\\n\\n        def is_prime(t):\\n            return t in [\"2\",\"3\",\"5\",\"7\"]\\n\\n        if not is_prime(s[0]) or is_prime(s[-1]):\\n            return 0\\n\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if i <= n and k == 0:\\n                return 1\\n\\n            if i >= n:\\n                return 0\\n\\n            count = dfs(i+1,k)\\n\\n            if is_prime(s[i]) and not is_prime(s[i-1]):\\n                count += dfs(i+minLength,k-1)\\n\\n            return count%(10**9+7)\\n\\n        return dfs(minLength,k-1)%(10**9+7)\\n\\n\\n            \\n\\n\\n\\n\\n                \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041465,
                "title": "c-easy-to-understannd",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long Mod = 1e9+7;\\n    int k, minLength;\\n    int Size;\\n\\n    int isPrime(char c){\\n        return (c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\');\\n    }\\n    int solve(string &s, int index, int part,vector<vector<int>> &dp){\\n        if(dp[index][part] != -1){\\n            return dp[index][part];\\n        }\\n        if(part == 1 && Size-index >= minLength){\\n            return 1;\\n        }\\n        int res = 0;\\n        if(Size-index < part*minLength){\\n            return 0;\\n        }\\n        int startIndex = index + minLength-1;\\n        int endIndex = Size - (part-1)*minLength-1;\\n\\n        for(int i = startIndex; i <= endIndex; i++){\\n            if(!isPrime(s[i]) && isPrime(s[i+1])){\\n                res = (res + solve(s, i+1, part-1, dp))%Mod;\\n            }\\n        }\\n        return dp[index][part] = res;\\n    }\\n\\n    int beautifulPartitions(string s, int K, int MinLength) {\\n        Size = s.size();\\n        vector<vector<int>> dp(Size, vector<int>(K+1,-1));\\n        k = K;\\n        minLength = MinLength;\\n        \\n        if(!isPrime(s[0]) || isPrime(s[Size-1])){\\n            return 0;\\n        }\\n        return solve(s, 0, K, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long Mod = 1e9+7;\\n    int k, minLength;\\n    int Size;\\n\\n    int isPrime(char c){\\n        return (c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\');\\n    }\\n    int solve(string &s, int index, int part,vector<vector<int>> &dp){\\n        if(dp[index][part] != -1){\\n            return dp[index][part];\\n        }\\n        if(part == 1 && Size-index >= minLength){\\n            return 1;\\n        }\\n        int res = 0;\\n        if(Size-index < part*minLength){\\n            return 0;\\n        }\\n        int startIndex = index + minLength-1;\\n        int endIndex = Size - (part-1)*minLength-1;\\n\\n        for(int i = startIndex; i <= endIndex; i++){\\n            if(!isPrime(s[i]) && isPrime(s[i+1])){\\n                res = (res + solve(s, i+1, part-1, dp))%Mod;\\n            }\\n        }\\n        return dp[index][part] = res;\\n    }\\n\\n    int beautifulPartitions(string s, int K, int MinLength) {\\n        Size = s.size();\\n        vector<vector<int>> dp(Size, vector<int>(K+1,-1));\\n        k = K;\\n        minLength = MinLength;\\n        \\n        if(!isPrime(s[0]) || isPrime(s[Size-1])){\\n            return 0;\\n        }\\n        return solve(s, 0, K, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011432,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        auto prime = [](char c) {\\n            return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n        };\\n        if (!prime(s[0]) || prime(s[n - 1])) return 0;\\n        vector<vector<int>> f(n + 1, vector<int>(k + 1));\\n        vector<vector<int>> g(n + 1, vector<int>(k + 1));\\n        f[0][0] = g[0][0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (i >= minLength && !prime(s[i - 1]) && (i == n || prime(s[i]))) {\\n                for (int j = 1; j <= k; ++j) {\\n                    f[i][j] = g[i - minLength][j - 1];\\n                }\\n            }\\n            for (int j = 0; j <= k; ++j) {\\n                g[i][j] = (g[i - 1][j] + f[i][j]) % mod;\\n            }\\n        }\\n        return f[n][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        auto prime = [](char c) {\\n            return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n        };\\n        if (!prime(s[0]) || prime(s[n - 1])) return 0;\\n        vector<vector<int>> f(n + 1, vector<int>(k + 1));\\n        vector<vector<int>> g(n + 1, vector<int>(k + 1));\\n        f[0][0] = g[0][0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (i >= minLength && !prime(s[i - 1]) && (i == n || prime(s[i]))) {\\n                for (int j = 1; j <= k; ++j) {\\n                    f[i][j] = g[i - minLength][j - 1];\\n                }\\n            }\\n            for (int j = 0; j <= k; ++j) {\\n                g[i][j] = (g[i - 1][j] + f[i][j]) % mod;\\n            }\\n        }\\n        return f[n][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964072,
                "title": "c-dp-convert-string-to-binary",
                "content": "# Intuition\\nconsider string like a boolean array and proceed for knapsack I choose p for prime and c for composite string 326416 is ppccpc\\n\\n# Approach\\nWhenever there is cp pattern in string you can place a partition in between them. count case when you choose to put a partition there and also case when you decide not to.\\n\\n# Complexity\\n- Time complexity:\\nO(NK)\\n\\n- Space complexity:\\nideally O(NK)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int N;int K,ml;\\n    int dp[1001][1001];\\n    int mod=1e9+7;\\n    int recur(string& s,int startsAt,int left){\\n        if(dp[startsAt][left]!=-1)return dp[startsAt][left];\\n        if(left==1){\\n            return 1;\\n        }\\n        // pr(startsAt);\\n        int count=0;\\n        for(int i=startsAt;i<N-1;i++){\\n            if(i-startsAt+1>=ml && (N-1-i)>=ml && s[i]==\\'c\\' && s[i+1]==\\'p\\'){\\n                count=(count+recur(s,i+1,left-1))%mod;\\n            }\\n        }\\n        dp[startsAt][left]=count%mod;\\n        return count;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        N=s.length();K=k;ml=minLength;\\n        for(int i=0;i<N+1;i++){\\n            for(int j=0;j<N+1;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<N;i++){\\n            if(s[i]==\\'2\\'||s[i]==\\'3\\'||s[i]==\\'5\\'||s[i]==\\'7\\'){\\n                s[i]=\\'p\\';\\n            }\\n            else{\\n                s[i]=\\'c\\';\\n            }\\n        }\\n        if(s[0]==\\'c\\' || s[N-1]==\\'p\\')return 0;\\n        return recur(s,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N;int K,ml;\\n    int dp[1001][1001];\\n    int mod=1e9+7;\\n    int recur(string& s,int startsAt,int left){\\n        if(dp[startsAt][left]!=-1)return dp[startsAt][left];\\n        if(left==1){\\n            return 1;\\n        }\\n        // pr(startsAt);\\n        int count=0;\\n        for(int i=startsAt;i<N-1;i++){\\n            if(i-startsAt+1>=ml && (N-1-i)>=ml && s[i]==\\'c\\' && s[i+1]==\\'p\\'){\\n                count=(count+recur(s,i+1,left-1))%mod;\\n            }\\n        }\\n        dp[startsAt][left]=count%mod;\\n        return count;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        N=s.length();K=k;ml=minLength;\\n        for(int i=0;i<N+1;i++){\\n            for(int j=0;j<N+1;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<N;i++){\\n            if(s[i]==\\'2\\'||s[i]==\\'3\\'||s[i]==\\'5\\'||s[i]==\\'7\\'){\\n                s[i]=\\'p\\';\\n            }\\n            else{\\n                s[i]=\\'c\\';\\n            }\\n        }\\n        if(s[0]==\\'c\\' || s[N-1]==\\'p\\')return 0;\\n        return recur(s,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938852,
                "title": "c-fenwick-tree-solution-o-k-n-log-n",
                "content": "Fenwick tree dp implementation.\\n\\n```\\nint mod = 1e9 + 7;\\n\\nclass FenwickTree {        \\nprivate:\\n  vector<long> ft;                                   \\npublic:\\n  FenwickTree(int m) { \\n      ft.assign(m+1, 0); // create an empty FT\\n  }      \\n\\n  long rsq(int j) {                                // returns RSQ(1, j)\\n    j++; long sum = 0;\\n    for (; j; j -= j & -j) sum += (ft[j] % mod);\\n    return sum % mod;\\n  }\\n\\n  void update(int i, long v) {\\n    i++; v %= mod;\\n    for (; i < ft.size(); i += (i & (-i))) {\\n        ft[i] += v % mod;\\n        ft[i] %= mod;\\n    }\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        set<char> prime = {\\'2\\', \\'3\\', \\'5\\', \\'7\\'};\\n        \\n        FenwickTree prev(n);\\n        \\n        if (prime.count(s[0]) == 0 || prime.count(s[n-1]) == 1) return 0;\\n        if (k == 1) return 1;\\n        \\n        for (int i = 1; i < n-1; ++i) { // N log N\\n            if (i + 1 >= minLength && prime.count(s[i]) == 0 && prime.count(s[i+1]) == 1) prev.update(i, 1);\\n        }\\n        \\n        for (int l = 2; l < k; l++) { // K * N * log N\\n            FenwickTree next(n);\\n            for (int i = minLength*l-1; i < n - 1; ++i) {\\n                if (prime.count(s[i]) == 0 && prime.count(s[i+1]) == 1 && i - minLength >= 0) {\\n                    next.update(i, prev.rsq(i - minLength));\\n                }\\n            }\\n            prev = next;\\n        }\\n        \\n        return (int) prev.rsq(n - minLength - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nint mod = 1e9 + 7;\\n\\nclass FenwickTree {        \\nprivate:\\n  vector<long> ft;                                   \\npublic:\\n  FenwickTree(int m) { \\n      ft.assign(m+1, 0); // create an empty FT\\n  }      \\n\\n  long rsq(int j) {                                // returns RSQ(1, j)\\n    j++; long sum = 0;\\n    for (; j; j -= j & -j) sum += (ft[j] % mod);\\n    return sum % mod;\\n  }\\n\\n  void update(int i, long v) {\\n    i++; v %= mod;\\n    for (; i < ft.size(); i += (i & (-i))) {\\n        ft[i] += v % mod;\\n        ft[i] %= mod;\\n    }\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        set<char> prime = {\\'2\\', \\'3\\', \\'5\\', \\'7\\'};\\n        \\n        FenwickTree prev(n);\\n        \\n        if (prime.count(s[0]) == 0 || prime.count(s[n-1]) == 1) return 0;\\n        if (k == 1) return 1;\\n        \\n        for (int i = 1; i < n-1; ++i) { // N log N\\n            if (i + 1 >= minLength && prime.count(s[i]) == 0 && prime.count(s[i+1]) == 1) prev.update(i, 1);\\n        }\\n        \\n        for (int l = 2; l < k; l++) { // K * N * log N\\n            FenwickTree next(n);\\n            for (int i = minLength*l-1; i < n - 1; ++i) {\\n                if (prime.count(s[i]) == 0 && prime.count(s[i+1]) == 1 && i - minLength >= 0) {\\n                    next.update(i, prev.rsq(i - minLength));\\n                }\\n            }\\n            prev = next;\\n        }\\n        \\n        return (int) prev.rsq(n - minLength - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934164,
                "title": "c-solution-dp-big-o-of-n-2-easy-understanding",
                "content": "# Intuition\\nJust checking wheater current elm is non prime and next elm is non-prime \\n\\n# Approach\\n- **First possibility** \\n\\nIf both condition  satisfied then consider current element as consider as end of partition then make a call on i+MaxLen ( because minimum partition len should be ML )\\n\\n- **Second possibility** \\n\\nIt is also possible current element is not the end of partition then move make call on i+1\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ \\n\\n- Space complexity:\\n$$O(n^2)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    const int m=1e9+7;\\n    bool isprime(int n){\\n        if(n==2||n==3||n==5||n==7) return 1;\\n        return 0;\\n    }\\n    int helper(string &s, int &k, int &ML,int i,int n){\\n        \\n        if(i>s.length()-1) return 0;\\n        if(n==k) return 1;\\n        int ans=0;\\n        if(dp[i][n]!=-1) return dp[i][n];\\n        if(!isprime(s[i]-\\'0\\')&&isprime(s[i+1]-\\'0\\')){\\n            ans=(ans+helper(s,k,ML,i+ML,n+1)%m)%m;\\n        }\\n        ans=(ans+helper(s,k,ML,i+1,n)%m)%m;\\n        return dp[i][n]=ans%m;\\n        \\n    }\\n    int beautifulPartitions(string s, int k, int ML) {\\n        if(isprime(s[0]-\\'0\\')&&!isprime(s[s.length()-1]-\\'0\\')){\\n            memset(dp,-1,sizeof dp);\\n            return helper(s,k,ML,ML-1,1);\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**IF THIS POST IS HELPFUL FOR YOU SO PLEASE UPVOTE!! \\uD83D\\uDE4F\\uD83D\\uDE4F**\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    const int m=1e9+7;\\n    bool isprime(int n){\\n        if(n==2||n==3||n==5||n==7) return 1;\\n        return 0;\\n    }\\n    int helper(string &s, int &k, int &ML,int i,int n){\\n        \\n        if(i>s.length()-1) return 0;\\n        if(n==k) return 1;\\n        int ans=0;\\n        if(dp[i][n]!=-1) return dp[i][n];\\n        if(!isprime(s[i]-\\'0\\')&&isprime(s[i+1]-\\'0\\')){\\n            ans=(ans+helper(s,k,ML,i+ML,n+1)%m)%m;\\n        }\\n        ans=(ans+helper(s,k,ML,i+1,n)%m)%m;\\n        return dp[i][n]=ans%m;\\n        \\n    }\\n    int beautifulPartitions(string s, int k, int ML) {\\n        if(isprime(s[0]-\\'0\\')&&!isprime(s[s.length()-1]-\\'0\\')){\\n            memset(dp,-1,sizeof dp);\\n            return helper(s,k,ML,ML-1,1);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929252,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn beautiful_partitions(s: String, k: i32, min_length: i32) -> i32 {\\n        fn is_prime(b: u8) -> bool {\\n            matches!(b, b\\'2\\' | b\\'3\\' | b\\'5\\' | b\\'7\\')\\n        }\\n\\n        const MOD: i32 = 1_000_000_007;\\n        let len = s.len();\\n        let mut dp = vec![vec![0; len + 1]; k as usize + 1];\\n        dp[0][0] = 1;\\n        let mut sums = vec![0; k as usize + 1];\\n        let mut cur = 0;\\n        for i in 0..len {\\n            if !is_prime(s.as_bytes()[i]) {\\n                for pos in cur..=i as i32 - min_length + 1 {\\n                    let pos = pos as usize;\\n                    if is_prime(s.as_bytes()[pos]) {\\n                        for j in 0..=k {\\n                            let j = j as usize;\\n                            sums[j] = (sums[j] + dp[j][pos]) % MOD;\\n                        }\\n                    }\\n                }\\n                cur = 0.max(i as i32 - min_length + 2);\\n                dp[0][i] = 1;\\n                for j in 1..=k as usize {\\n                    dp[j][i + 1] = sums[j - 1];\\n                }\\n            }\\n        }\\n        dp[k as usize][len]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn beautiful_partitions(s: String, k: i32, min_length: i32) -> i32 {\\n        fn is_prime(b: u8) -> bool {\\n            matches!(b, b\\'2\\' | b\\'3\\' | b\\'5\\' | b\\'7\\')\\n        }\\n\\n        const MOD: i32 = 1_000_000_007;\\n        let len = s.len();\\n        let mut dp = vec![vec![0; len + 1]; k as usize + 1];\\n        dp[0][0] = 1;\\n        let mut sums = vec![0; k as usize + 1];\\n        let mut cur = 0;\\n        for i in 0..len {\\n            if !is_prime(s.as_bytes()[i]) {\\n                for pos in cur..=i as i32 - min_length + 1 {\\n                    let pos = pos as usize;\\n                    if is_prime(s.as_bytes()[pos]) {\\n                        for j in 0..=k {\\n                            let j = j as usize;\\n                            sums[j] = (sums[j] + dp[j][pos]) % MOD;\\n                        }\\n                    }\\n                }\\n                cur = 0.max(i as i32 - min_length + 2);\\n                dp[0][i] = 1;\\n                for j in 1..=k as usize {\\n                    dp[j][i + 1] = sums[j - 1];\\n                }\\n            }\\n        }\\n        dp[k as usize][len]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927541,
                "title": "java-0-1-knapsack-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    private static final int MOD = (int) Math.pow(10, 9) + 7;\\n    int[][] dp;\\n\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        dp = new int[s.length() + 1][s.length()];\\n        for(int[] dpObj : dp)\\n            Arrays.fill(dpObj, -1);\\n\\n        //If first char is not prime or last char is prime then return 0\\n        return isPrime(s.charAt(0)) && !isPrime(s.charAt(s.length()- 1)) \\n                ? solveRec(s, minLength, k - 1, minLength) \\n                : 0;\\n    }\\n\\n    private int solveRec(String s, int ind, int k, int minLength) {\\n        if (k == 0 && ind <= s.length())\\n            return 1;\\n        if (ind >= s.length())\\n            return 0;\\n\\n        if(dp[ind][k] != -1)\\n            return dp[ind][k];\\n\\n        int ways = 0;\\n        \\n        //Make part here if current char is prime and prev char was not prime\\n        if (isPrime(s.charAt(ind)) && !isPrime(s.charAt(ind - 1))) {\\n            ways = solveRec(s, ind + minLength, k - 1, minLength) % MOD;\\n        }\\n\\n        //Do not make part here\\n        ways += solveRec(s, ind + 1, k, minLength) % MOD;\\n\\n        return dp[ind][k] = ways % MOD;\\n    }\\n    private boolean isPrime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MOD = (int) Math.pow(10, 9) + 7;\\n    int[][] dp;\\n\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        dp = new int[s.length() + 1][s.length()];\\n        for(int[] dpObj : dp)\\n            Arrays.fill(dpObj, -1);\\n\\n        //If first char is not prime or last char is prime then return 0\\n        return isPrime(s.charAt(0)) && !isPrime(s.charAt(s.length()- 1)) \\n                ? solveRec(s, minLength, k - 1, minLength) \\n                : 0;\\n    }\\n\\n    private int solveRec(String s, int ind, int k, int minLength) {\\n        if (k == 0 && ind <= s.length())\\n            return 1;\\n        if (ind >= s.length())\\n            return 0;\\n\\n        if(dp[ind][k] != -1)\\n            return dp[ind][k];\\n\\n        int ways = 0;\\n        \\n        //Make part here if current char is prime and prev char was not prime\\n        if (isPrime(s.charAt(ind)) && !isPrime(s.charAt(ind - 1))) {\\n            ways = solveRec(s, ind + minLength, k - 1, minLength) % MOD;\\n        }\\n\\n        //Do not make part here\\n        ways += solveRec(s, ind + 1, k, minLength) % MOD;\\n\\n        return dp[ind][k] = ways % MOD;\\n    }\\n    private boolean isPrime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919778,
                "title": "dp-o-n-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @param {number} minLength\\n * @return {number}\\n */\\nvar beautifulPartitions = function(s, k, minLength) {\\n    const PRIMES = [\\'2\\', \\'3\\', \\'5\\', \\'7\\'];\\n    const MOD = 1000000007;\\n    if (s.length <= k * minLength || !PRIMES.includes(s[0]) || PRIMES.includes(s[s.length - 1])) {\\n        return 0;\\n    }\\n    // F[i][d] -> number of ways to choose d spliters in 0..i\\n    const F = new Array(s.length).fill().map(() => new Array(k).fill(0));\\n    for (let i = 0; i < s.length; i++) {\\n        F[i][0] = 1;\\n    }\\n\\n    minLength = Math.max(minLength, 2);\\n\\n    for (let i = minLength; i < s.length; i++) {\\n        const isSpliter = i + minLength <= s.length && PRIMES.includes(s[i]) && !PRIMES.includes(s[i - 1]);\\n        for (let d = 1; d < k; d++) {\\n            F[i][d] = (F[i][d] + F[i - 1][d]) % MOD;\\n            if (isSpliter) {\\n                F[i + minLength - 1][d] = F[i - 1][d - 1] % MOD;\\n            }\\n        }\\n    }\\n    return F[s.length - 1][k - 1];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @param {number} minLength\\n * @return {number}\\n */\\nvar beautifulPartitions = function(s, k, minLength) {\\n    const PRIMES = [\\'2\\', \\'3\\', \\'5\\', \\'7\\'];\\n    const MOD = 1000000007;\\n    if (s.length <= k * minLength || !PRIMES.includes(s[0]) || PRIMES.includes(s[s.length - 1])) {\\n        return 0;\\n    }\\n    // F[i][d] -> number of ways to choose d spliters in 0..i\\n    const F = new Array(s.length).fill().map(() => new Array(k).fill(0));\\n    for (let i = 0; i < s.length; i++) {\\n        F[i][0] = 1;\\n    }\\n\\n    minLength = Math.max(minLength, 2);\\n\\n    for (let i = minLength; i < s.length; i++) {\\n        const isSpliter = i + minLength <= s.length && PRIMES.includes(s[i]) && !PRIMES.includes(s[i - 1]);\\n        for (let d = 1; d < k; d++) {\\n            F[i][d] = (F[i][d] + F[i - 1][d]) % MOD;\\n            if (isSpliter) {\\n                F[i + minLength - 1][d] = F[i - 1][d - 1] % MOD;\\n            }\\n        }\\n    }\\n    return F[s.length - 1][k - 1];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2909311,
                "title": "c-dp-prefix-sum",
                "content": "# Approach\\nStraightforward 2D Dynamic Programming, use prefixsum to avoid cubical complexity\\n\\n# Complexity\\n- Time complexity:\\n$$O(len(s) * k)$$\\n\\n- Space complexity:\\n$$O(len(s) * k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        const int MOD = (int)(1E9 + 7);\\n        int len = s.length();\\n        vector<vector<int>> dp(k + 1, vector<int>(len + 1));\\n        dp[0][0] = 1;\\n        vector<int> sums(k + 1);\\n        int cur = 0;\\n        for (int i = 0; i < len; ++i) {\\n            if (s[i] != \\'2\\' && s[i] != \\'3\\' && s[i] != \\'5\\' && s[i] != \\'7\\') {\\n                for (int pos = cur; pos <= i - minLength + 1; ++pos) {\\n                    // cout << i << \" \" << pos << endl;\\n                    if (s[pos] == \\'2\\' || s[pos] == \\'3\\' || s[pos] == \\'5\\' || s[pos] == \\'7\\') {\\n                        for (int j = 0; j <= k; ++j) {\\n                            sums[j] = (sums[j] + dp[j][pos]) % MOD;\\n                        }\\n                    }\\n                }\\n                cur = max(0, i - minLength + 2);\\n                dp[0][i] = 1;\\n                for (int j = 1; j <= k; ++j) {\\n                    dp[j][i + 1] = sums[j - 1];\\n                }\\n            }\\n        }\\n        return dp[k][len];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        const int MOD = (int)(1E9 + 7);\\n        int len = s.length();\\n        vector<vector<int>> dp(k + 1, vector<int>(len + 1));\\n        dp[0][0] = 1;\\n        vector<int> sums(k + 1);\\n        int cur = 0;\\n        for (int i = 0; i < len; ++i) {\\n            if (s[i] != \\'2\\' && s[i] != \\'3\\' && s[i] != \\'5\\' && s[i] != \\'7\\') {\\n                for (int pos = cur; pos <= i - minLength + 1; ++pos) {\\n                    // cout << i << \" \" << pos << endl;\\n                    if (s[pos] == \\'2\\' || s[pos] == \\'3\\' || s[pos] == \\'5\\' || s[pos] == \\'7\\') {\\n                        for (int j = 0; j <= k; ++j) {\\n                            sums[j] = (sums[j] + dp[j][pos]) % MOD;\\n                        }\\n                    }\\n                }\\n                cur = max(0, i - minLength + 2);\\n                dp[0][i] = 1;\\n                for (int j = 1; j <= k; ++j) {\\n                    dp[j][i + 1] = sums[j - 1];\\n                }\\n            }\\n        }\\n        return dp[k][len];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2888587,
                "title": "dynamic-programming-top-down",
                "content": "# Approach\\nif cur is prime then if we can start a partion then start the partion consioisting minLength elements and if cannot start partition then continue\\n\\nif cur is non-prime then we can end continue or end the ongoing partition and start new from next index\\n\\ndp[i][p][st] denotes that from i-th index have to p partition, st denotes weather we can start new partiton or not\\n\\n# Complexity\\n- Time complexity:\\nO(n * k * 2)\\n\\n- Space complexity:\\nO(n * k * 2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int M = 1e9 + 7;\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        int dp[n][k + 1][2];\\n        memset(dp, -1, sizeof(dp));\\n        set<char> pr = {\\'2\\', \\'3\\', \\'5\\', \\'7\\'};\\n        function <int(int, int, int)> calc = [&](int i, int p, int st) {\\n            if (i == n) return (p == 0 ? 1 : 0);\\n            if (i > n || p == 0 || (!pr.count(s[i]) && st)) return 0;\\n            int &ans = dp[i][p][st];\\n            if (ans != -1) return ans;\\n            ans = 0;\\n            if (pr.count(s[i])) {\\n                // if cur is prime then if we can start a partion then start the partion consioisting minLength elements\\n                // and if cannot start partition then continue;\\n                if (st) ans += calc(i + minLength - 1, p, false);\\n                else ans += calc(i + 1, p, false);\\n            } else ans += (calc(i + 1, p, false) + calc(i + 1, p - 1, true)) % M;\\n            // if cur is non-prime then we can end continue or end the ongoing partition and start new from next index\\n            if (ans >= M) ans -= M;\\n            return ans;\\n        };\\n        // dp[i][p][st] denotes that from i-th index have to p partition, st denotes weather we can start new partiton or not  \\n        return calc(0, k, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9 + 7;\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        int dp[n][k + 1][2];\\n        memset(dp, -1, sizeof(dp));\\n        set<char> pr = {\\'2\\', \\'3\\', \\'5\\', \\'7\\'};\\n        function <int(int, int, int)> calc = [&](int i, int p, int st) {\\n            if (i == n) return (p == 0 ? 1 : 0);\\n            if (i > n || p == 0 || (!pr.count(s[i]) && st)) return 0;\\n            int &ans = dp[i][p][st];\\n            if (ans != -1) return ans;\\n            ans = 0;\\n            if (pr.count(s[i])) {\\n                // if cur is prime then if we can start a partion then start the partion consioisting minLength elements\\n                // and if cannot start partition then continue;\\n                if (st) ans += calc(i + minLength - 1, p, false);\\n                else ans += calc(i + 1, p, false);\\n            } else ans += (calc(i + 1, p, false) + calc(i + 1, p - 1, true)) % M;\\n            // if cur is non-prime then we can end continue or end the ongoing partition and start new from next index\\n            if (ans >= M) ans -= M;\\n            return ans;\\n        };\\n        // dp[i][p][st] denotes that from i-th index have to p partition, st denotes weather we can start new partiton or not  \\n        return calc(0, k, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876263,
                "title": "golang-bottom-up-dp-o-n-k",
                "content": "Here, I will introduce the thought from $O(N*N*K)$ to $O(N*K)$\\n\\n# From the begining\\nHere, I will define some variable and inforamtion to make you understand easiler.\\n1. We only can cut the string at `i` which satisfy `IsPrime(s[i]) && !IsPrime(s[i-1])`.\\n1. $CuttingPoint_i$: this means the $i$ point we can cut the string.\\n2. $dp$: this is a array cached the result we caculated before.\\n\\n# Some prototype\\nIn the first time, I think this is a dp solution like LIS(longest increasing subsequence).\\nSo, we can make `dp[i][k]` presents \"if we cut at point $i$ with $k$ cuts, how many result can we get?\"\\nWith this thought, we can write the following formula:\\n$$dp[i][k] = dp[CuttingPoint_i][k-1] + dp[CuttingPoint_{i-1}][k-1]...;\\ni - CuttingPoint_i \\\\geq minLength$$\\nAnd you can see that this solution\\'s complexity is $$O(K*K*N)$$.\\n\\n# Improvement\\nHow about we can makes `dp` cache another thing?\\nBecause in the formula before, the bottleneck is calculating the sum from  $CuttingPoint_0$ to $CuttimgPoint_i$.\\nTherefore, we can cache the sum into the `dp` array; we can represent the dp array as \"total count before current cutting point\" ($$dp[CuttingPoint_i][k]$$).\\nAnd we can wrtie the formula:\\n$$dp[CuttingPoint_i][k] = dp[CuttingPoint_{i-1}][k-1]+dp[CuttingPoint_{i-1}][k]; CuttingPoint_i - CuttingPoint_{i-1} \\\\geq minLength$$\\n\\nFinally, the time complexity is $$O(K*N)$$, and we can write the code.\\n\\n\\n# Code\\n```\\nconst mod = 1e+9 + 7\\n\\nfunc IsPrime(b byte) bool {\\n    return b == \\'2\\' || b == \\'3\\' || b == \\'5\\' || b == \\'7\\'\\n}\\n\\nfunc beautifulPartitions(s string, k int, minLength int) int {\\n    if !IsPrime(s[0]) || IsPrime(s[len(s)-1]) {\\n        return 0\\n    }\\n    if k == 1 {\\n        return 1\\n    }\\n    dp := make([]int, 0)\\n    cutPoints := []int{}\\n    prev := 0\\n    // put the valid cutting point into an array and caculate the dp[CuttingPoint_i][1]\\n    for i := 1; i < len(s); i++ {\\n        if IsPrime(s[i]) && !IsPrime(s[i-1]) &&\\n            len(s)-i >= minLength && i >= minLength {\\n            cutPoints = append(cutPoints, i)\\n            dp = append(dp, prev+1)\\n            prev++\\n        }\\n    }\\n    // if there is not any vaild cutting point here, quit early.\\n    if len(dp) == 0 {\\n        return 0\\n    }\\n    k--\\n    next := make([]int, len(cutPoints))\\n    // implement the formula\\n    for ; k != 1; k-- {\\n        prev := 0\\n        for idx, point := range cutPoints {\\n            next[idx] = 0\\n            for i := idx - 1; i >= 0; i-- {\\n                // we can use binary search here to increase the time.\\n                if point-cutPoints[i] >= minLength {\\n                    next[idx] += dp[i]\\n                    break\\n                }\\n            }\\n            next[idx] += prev\\n            next[idx] %= mod\\n            prev = next[idx]\\n        }\\n        dp, next = next, dp\\n    }\\n    return dp[len(dp)-1]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst mod = 1e+9 + 7\\n\\nfunc IsPrime(b byte) bool {\\n    return b == \\'2\\' || b == \\'3\\' || b == \\'5\\' || b == \\'7\\'\\n}\\n\\nfunc beautifulPartitions(s string, k int, minLength int) int {\\n    if !IsPrime(s[0]) || IsPrime(s[len(s)-1]) {\\n        return 0\\n    }\\n    if k == 1 {\\n        return 1\\n    }\\n    dp := make([]int, 0)\\n    cutPoints := []int{}\\n    prev := 0\\n    // put the valid cutting point into an array and caculate the dp[CuttingPoint_i][1]\\n    for i := 1; i < len(s); i++ {\\n        if IsPrime(s[i]) && !IsPrime(s[i-1]) &&\\n            len(s)-i >= minLength && i >= minLength {\\n            cutPoints = append(cutPoints, i)\\n            dp = append(dp, prev+1)\\n            prev++\\n        }\\n    }\\n    // if there is not any vaild cutting point here, quit early.\\n    if len(dp) == 0 {\\n        return 0\\n    }\\n    k--\\n    next := make([]int, len(cutPoints))\\n    // implement the formula\\n    for ; k != 1; k-- {\\n        prev := 0\\n        for idx, point := range cutPoints {\\n            next[idx] = 0\\n            for i := idx - 1; i >= 0; i-- {\\n                // we can use binary search here to increase the time.\\n                if point-cutPoints[i] >= minLength {\\n                    next[idx] += dp[i]\\n                    break\\n                }\\n            }\\n            next[idx] += prev\\n            next[idx] %= mod\\n            prev = next[idx]\\n        }\\n        dp, next = next, dp\\n    }\\n    return dp[len(dp)-1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2856363,
                "title": "c-easy-code-comments-dp-memoization",
                "content": "# Intuition\\nUse Dynamic programming to compute result for smaller string and use it to solve for bigger strings\\n\\n# Approach\\nUse Dynamic programming to compute result for smaller string and use it to solve for bigger strings\\n\\n# Complexity\\n- Time complexity:\\nO(n * k);\\n\\n- Space complexity:\\nO(n * k);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<char> prime;\\n    long long ans = 0;\\n    vector<vector<long long>> dp;\\n    int n;\\n    long long getCount(string& s, int curr, int k, int& ml){\\n        // If starting number is not prime then return 0\\n        if(prime.find(s[curr]) == prime.end())\\n            return 0;\\n        if(dp[curr][k] != -1){\\n            return dp[curr][k];\\n        }\\n        if(k == 0){\\n            // If this is the last partition check if size is greater than minimum size and the last digit of the string is non-prime\\n            if(prime.find(s[s.size()-1]) != prime.end() || s.size() - curr < ml){\\n                return dp[curr][k] = 0;\\n            }     \\n            return dp[curr][k] = 1;\\n        }\\n        \\n        // Curr string should have atleat the size of min length\\n        long long start = curr + ml - 1;\\n        long long count = 0;\\n        for(int i=start;i<s.size();i++){\\n            int left = n - i + 1;\\n            // Check if remaining characters can satisfy the number of partitions\\n            if((k+1) * 2 > left)\\n                break;\\n            if(prime.find(s[i]) == prime.end()){\\n                count += getCount(s, i+1, k-1, ml);\\n                count = count % 1000000007;\\n            }\\n        }\\n        count = count % 1000000007;\\n        return dp[curr][k] = count;\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        n = s.size();\\n        dp = vector<vector<long long>>(n+1, vector<long long>(n+1, -1));\\n            \\n        prime.insert(\\'2\\');\\n        prime.insert(\\'3\\');\\n        prime.insert(\\'5\\');\\n        prime.insert(\\'7\\');\\n        return getCount(s, 0, k-1, minLength);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<char> prime;\\n    long long ans = 0;\\n    vector<vector<long long>> dp;\\n    int n;\\n    long long getCount(string& s, int curr, int k, int& ml){\\n        // If starting number is not prime then return 0\\n        if(prime.find(s[curr]) == prime.end())\\n            return 0;\\n        if(dp[curr][k] != -1){\\n            return dp[curr][k];\\n        }\\n        if(k == 0){\\n            // If this is the last partition check if size is greater than minimum size and the last digit of the string is non-prime\\n            if(prime.find(s[s.size()-1]) != prime.end() || s.size() - curr < ml){\\n                return dp[curr][k] = 0;\\n            }     \\n            return dp[curr][k] = 1;\\n        }\\n        \\n        // Curr string should have atleat the size of min length\\n        long long start = curr + ml - 1;\\n        long long count = 0;\\n        for(int i=start;i<s.size();i++){\\n            int left = n - i + 1;\\n            // Check if remaining characters can satisfy the number of partitions\\n            if((k+1) * 2 > left)\\n                break;\\n            if(prime.find(s[i]) == prime.end()){\\n                count += getCount(s, i+1, k-1, ml);\\n                count = count % 1000000007;\\n            }\\n        }\\n        count = count % 1000000007;\\n        return dp[curr][k] = count;\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        n = s.size();\\n        dp = vector<vector<long long>>(n+1, vector<long long>(n+1, -1));\\n            \\n        prime.insert(\\'2\\');\\n        prime.insert(\\'3\\');\\n        prime.insert(\\'5\\');\\n        prime.insert(\\'7\\');\\n        return getCount(s, 0, k-1, minLength);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854655,
                "title": "python3-o-mk-dp-solution",
                "content": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        \\n        prime = {\\'2\\',\\'3\\',\\'5\\',\\'7\\'}\\n        \\n        if s[0] not in prime: return 0\\n        \\n        candidates = []\\n        \\n        for i in range(minLength-1, len(s)):\\n            if s[i] not in prime:\\n                candidates.append(i)\\n                \\n        if not candidates: return 0\\n                \\n        grid = [[0]*len(candidates) for _ in range(k)]\\n        \\n        grid[0] = [1]*len(candidates)\\n        \\n        for i in range(1, k):\\n            pointer1 = 0\\n            accu = 0\\n            for j in range(len(candidates)):\\n                ending = candidates[j]\\n                prev_ending = ending - minLength\\n                temp_res = 0\\n                flag = False\\n                for k in range(j-1, pointer1-1, -1):\\n                    if candidates[k] <= prev_ending and s[candidates[k]+1] in prime:\\n                        accu += grid[i-1][k]\\n                        if not flag: pointer1 = k + 1; flag = True\\n                grid[i][j] = accu\\n\\n        return grid[-1][-1] % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        \\n        prime = {\\'2\\',\\'3\\',\\'5\\',\\'7\\'}\\n        \\n        if s[0] not in prime: return 0\\n        \\n        candidates = []\\n        \\n        for i in range(minLength-1, len(s)):\\n            if s[i] not in prime:\\n                candidates.append(i)\\n                \\n        if not candidates: return 0\\n                \\n        grid = [[0]*len(candidates) for _ in range(k)]\\n        \\n        grid[0] = [1]*len(candidates)\\n        \\n        for i in range(1, k):\\n            pointer1 = 0\\n            accu = 0\\n            for j in range(len(candidates)):\\n                ending = candidates[j]\\n                prev_ending = ending - minLength\\n                temp_res = 0\\n                flag = False\\n                for k in range(j-1, pointer1-1, -1):\\n                    if candidates[k] <= prev_ending and s[candidates[k]+1] in prime:\\n                        accu += grid[i-1][k]\\n                        if not flag: pointer1 = k + 1; flag = True\\n                grid[i][j] = accu\\n\\n        return grid[-1][-1] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849827,
                "title": "python-dp-solution-commented-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        sz, MOD = len(s), 1000000007\\n        \\n        @cache\\n        def dp(idx: int, k: int, active: bool) -> int:\\n            # Base case 1: We run out of allowed number of substrings\\n            if k < 0:\\n                return 0\\n            # Base case 2: We successfully break the string into k substrings\\n            if idx == sz and k == 0:\\n                return 1\\n            # Base case 3: We reach either of the 2 ending points without being able \\n            # to successfully partition the string\\n            if idx >= sz or k == 0:\\n                return 0\\n            ans = 0\\n            if active:\\n                # Try ending the substring if we encounter a non-prime digit\\n                if s[idx] == \\'1\\' or s[idx] == \\'4\\'or s[idx]== \\'6\\'or s[idx]== \\'8\\' or s[idx]== \\'9\\':\\n                    ans += dp(idx + 1, k - 1, not active) \\n                # Try continuing the substring\\n                ans += dp(idx + 1, k, active)\\n            else:\\n                # If we encounter a non-prime digit when there ae no substrings currently active\\n                # return from there\\n                if s[idx] == \\'1\\' or s[idx] == \\'4\\'or s[idx]== \\'6\\'or s[idx]== \\'8\\' or s[idx]== \\'9\\':\\n                    return 0\\n                # Else start a new substring\\n                ans += dp(idx + minLength - 1, k, not active)\\n            return ans\\n        \\n        return dp(0, k, False) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        sz, MOD = len(s), 1000000007\\n        \\n        @cache\\n        def dp(idx: int, k: int, active: bool) -> int:\\n            # Base case 1: We run out of allowed number of substrings\\n            if k < 0:\\n                return 0\\n            # Base case 2: We successfully break the string into k substrings\\n            if idx == sz and k == 0:\\n                return 1\\n            # Base case 3: We reach either of the 2 ending points without being able \\n            # to successfully partition the string\\n            if idx >= sz or k == 0:\\n                return 0\\n            ans = 0\\n            if active:\\n                # Try ending the substring if we encounter a non-prime digit\\n                if s[idx] == \\'1\\' or s[idx] == \\'4\\'or s[idx]== \\'6\\'or s[idx]== \\'8\\' or s[idx]== \\'9\\':\\n                    ans += dp(idx + 1, k - 1, not active) \\n                # Try continuing the substring\\n                ans += dp(idx + 1, k, active)\\n            else:\\n                # If we encounter a non-prime digit when there ae no substrings currently active\\n                # return from there\\n                if s[idx] == \\'1\\' or s[idx] == \\'4\\'or s[idx]== \\'6\\'or s[idx]== \\'8\\' or s[idx]== \\'9\\':\\n                    return 0\\n                # Else start a new substring\\n                ans += dp(idx + minLength - 1, k, not active)\\n            return ans\\n        \\n        return dp(0, k, False) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849257,
                "title": "ez-python-short-dp",
                "content": "```\\nclass Solution:\\n    \\n    def beautifulPartitions(self, s: str, k: int, mm: int) -> int:\\n        \\n        N = len(s)\\n        MOD = 1_000_000_007\\n        \\n        isPrime = lambda c: c in {\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n\\n        @cache\\n        def dp(ci, remains):\\n            \\n            if remains == k and ci <= N:\\n                return 1\\n            \\n            if ci >= N:\\n                return 0\\n            \\n            ans = dp(ci + 1, remains) # skip\\n            if isPrime(s[ci]) and not isPrime(s[ci-1]): # try to split\\n                ans += dp(ci + mm, remains + 1) # notice we move ci + mm spaces to avoid element from [ci:ci+mm] being taken in next partition\\n            \\n            return ans\\n        \\n        if not isPrime(s[0]) or isPrime(s[-1]): return 0\\n        \\n        return dp(mm, 1) % MOD\\n\\n```\\n\\t\\nA TLE solution to build approach via recursion . Once recursion is clear, optimizing is not hard\\n```\\n    def beautifulPartitions_TLE(self, s: str, k: int, mm: int) -> int:\\n        \\n        primes = {\"2\", \"3\", \"5\", \"7\"}\\n        \\n        @cache\\n        def dp(ci, curr, partition):\\n            \\n            if ci == len(s):\\n                if partition == k - 1 and len(curr) >= mm:\\n                    return 1\\n                else:\\n                    return 0\\n            \\n            if partition == k:\\n                return 0 # way to many parts\\n            \\n            if curr == \"\" and s[ci] not in primes:\\n                return 0 # first letter has to be prime\\n            \\n            if len(curr) + 1 < mm:\\n                # we can only add \\n                return dp(ci + 1, curr + s[ci], partition)\\n            else:\\n                \\n                # if we are currently at prime\\n                if s[ci] not in primes:\\n                    # we can split \\n                    yend = dp(ci + 1, \"\", partition + 1)\\n                    nend = dp(ci + 1, curr + s[ci], partition)\\n                    return yend + nend\\n                else:\\n                    return dp(ci + 1, curr + s[ci] , partition)\\n            \\n        \\n        if s == \"\" or s[0] not in primes:\\n            return 0\\n        \\n        return dp(1, s[0], 0) % 1_000_000_007\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def beautifulPartitions(self, s: str, k: int, mm: int) -> int:\\n        \\n        N = len(s)\\n        MOD = 1_000_000_007\\n        \\n        isPrime = lambda c: c in {\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n\\n        @cache\\n        def dp(ci, remains):\\n            \\n            if remains == k and ci <= N:\\n                return 1\\n            \\n            if ci >= N:\\n                return 0\\n            \\n            ans = dp(ci + 1, remains) # skip\\n            if isPrime(s[ci]) and not isPrime(s[ci-1]): # try to split\\n                ans += dp(ci + mm, remains + 1) # notice we move ci + mm spaces to avoid element from [ci:ci+mm] being taken in next partition\\n            \\n            return ans\\n        \\n        if not isPrime(s[0]) or isPrime(s[-1]): return 0\\n        \\n        return dp(mm, 1) % MOD\\n\\n```\n```\\n    def beautifulPartitions_TLE(self, s: str, k: int, mm: int) -> int:\\n        \\n        primes = {\"2\", \"3\", \"5\", \"7\"}\\n        \\n        @cache\\n        def dp(ci, curr, partition):\\n            \\n            if ci == len(s):\\n                if partition == k - 1 and len(curr) >= mm:\\n                    return 1\\n                else:\\n                    return 0\\n            \\n            if partition == k:\\n                return 0 # way to many parts\\n            \\n            if curr == \"\" and s[ci] not in primes:\\n                return 0 # first letter has to be prime\\n            \\n            if len(curr) + 1 < mm:\\n                # we can only add \\n                return dp(ci + 1, curr + s[ci], partition)\\n            else:\\n                \\n                # if we are currently at prime\\n                if s[ci] not in primes:\\n                    # we can split \\n                    yend = dp(ci + 1, \"\", partition + 1)\\n                    nend = dp(ci + 1, curr + s[ci], partition)\\n                    return yend + nend\\n                else:\\n                    return dp(ci + 1, curr + s[ci] , partition)\\n            \\n        \\n        if s == \"\" or s[0] not in primes:\\n            return 0\\n        \\n        return dp(1, s[0], 0) % 1_000_000_007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848636,
                "title": "memorization",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive way, use memorization to boost speed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * k)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * k), N denotes the length of string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if (isPrime(s.back()) || !isPrime(s.front()) || s.size() < k * minLength) {\\n            return 0;\\n        }\\n        vector<vector<int>> memo(k + 1, vector<int>(s.size() + 1, -1));\\n        // Precomputer the base senario with only one partition.\\n        // Check if substring s[i...] is beautiful or not.\\n        for (int i = 0; i < s.size(); i++) {\\n            memo[1][i] = (isPrime(s[i]) && !isPrime(s.back()) && (s.size() - i) >= minLength) ? 1 : 0;\\n        }\\n        return dfs(s, k, minLength, 0, memo);\\n    }\\n\\n    bool isPrime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n\\n    const static int MOD = 1e9+7;\\n    int dfs(string& s, int k, int minLength, int idx, vector<vector<int>> &memo) {\\n        // each substring should start with a prime digit\\n        if (idx >= s.size() || !isPrime(s[idx])) {\\n            return 0;\\n        }\\n\\n        if (memo[k][idx] != -1) {\\n            return memo[k][idx];\\n        }\\n\\n        // now, \\n        //            k                     k-1   k-2             \\n        // idx, idx+1 ... idx+minLength-1 | xxx | xxx | \\n        //                                  minLength * (groups - 1)\\n        int total = 0;\\n        for (int i = idx + minLength - 1; i <= s.size() - (k - 1) * minLength; i++) {\\n            // choose s[idx ... i]\\n            if (!isPrime(s[i])) {\\n                total = (total + dfs(s, k - 1, minLength, i + 1, memo)) % MOD;\\n            }\\n        }\\n        return memo[k][idx] = total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if (isPrime(s.back()) || !isPrime(s.front()) || s.size() < k * minLength) {\\n            return 0;\\n        }\\n        vector<vector<int>> memo(k + 1, vector<int>(s.size() + 1, -1));\\n        // Precomputer the base senario with only one partition.\\n        // Check if substring s[i...] is beautiful or not.\\n        for (int i = 0; i < s.size(); i++) {\\n            memo[1][i] = (isPrime(s[i]) && !isPrime(s.back()) && (s.size() - i) >= minLength) ? 1 : 0;\\n        }\\n        return dfs(s, k, minLength, 0, memo);\\n    }\\n\\n    bool isPrime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n\\n    const static int MOD = 1e9+7;\\n    int dfs(string& s, int k, int minLength, int idx, vector<vector<int>> &memo) {\\n        // each substring should start with a prime digit\\n        if (idx >= s.size() || !isPrime(s[idx])) {\\n            return 0;\\n        }\\n\\n        if (memo[k][idx] != -1) {\\n            return memo[k][idx];\\n        }\\n\\n        // now, \\n        //            k                     k-1   k-2             \\n        // idx, idx+1 ... idx+minLength-1 | xxx | xxx | \\n        //                                  minLength * (groups - 1)\\n        int total = 0;\\n        for (int i = idx + minLength - 1; i <= s.size() - (k - 1) * minLength; i++) {\\n            // choose s[idx ... i]\\n            if (!isPrime(s[i])) {\\n                total = (total + dfs(s, k - 1, minLength, i + 1, memo)) % MOD;\\n            }\\n        }\\n        return memo[k][idx] = total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848124,
                "title": "n-2-dp-knapsack",
                "content": "# Code\\n```\\nclass Solution {\\n    int modulo=1e9+7;\\n    \\n    int isPrime[10]={0,0,1,1,0,1,0,1,0,0}; \\n\\n    // Fast Check for Prime Number or not.\\n    \\n    int dp[1001][1001];\\n    \\n    int helper(string &s,int k,int &minLength,int &n,int start=0){\\n        if(start==n || !isPrime[s[start]-\\'0\\'] || (n-start)<minLength)\\n            return 0;\\n        if(k==1)\\n            return isPrime[s[start]-\\'0\\'] && !isPrime[s[n-1]-\\'0\\'];\\n        if(dp[k][start]!=-1)\\n            return dp[k][start]%modulo;\\n        int ans=0;\\n        for(int i=start+minLength-1;i<n-(minLength*(k-1));i++){\\n            // Here main optimization is i should be \\n            // upto n-(minLength*(k-1)),as no requirement\\n            // to check for larger sets if k is not met.\\n            if(isPrime[s[i]-\\'0\\'])continue;\\n            ans=(ans+helper(s,k-1,minLength,n,i+1))%modulo;\\n        }\\n        return dp[k][start]=ans;\\n    }\\n    \\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof dp);\\n        return helper(s,k,minLength,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int modulo=1e9+7;\\n    \\n    int isPrime[10]={0,0,1,1,0,1,0,1,0,0}; \\n\\n    // Fast Check for Prime Number or not.\\n    \\n    int dp[1001][1001];\\n    \\n    int helper(string &s,int k,int &minLength,int &n,int start=0){\\n        if(start==n || !isPrime[s[start]-\\'0\\'] || (n-start)<minLength)\\n            return 0;\\n        if(k==1)\\n            return isPrime[s[start]-\\'0\\'] && !isPrime[s[n-1]-\\'0\\'];\\n        if(dp[k][start]!=-1)\\n            return dp[k][start]%modulo;\\n        int ans=0;\\n        for(int i=start+minLength-1;i<n-(minLength*(k-1));i++){\\n            // Here main optimization is i should be \\n            // upto n-(minLength*(k-1)),as no requirement\\n            // to check for larger sets if k is not met.\\n            if(isPrime[s[i]-\\'0\\'])continue;\\n            ans=(ans+helper(s,k-1,minLength,n,i+1))%modulo;\\n        }\\n        return dp[k][start]=ans;\\n    }\\n    \\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof dp);\\n        return helper(s,k,minLength,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846874,
                "title": "python-dp-memoization-explained",
                "content": "arr is array lengths of valid substrings computed by checking boundary conditions on s.\\nNow we need to choose k subarrays from arr considering min_length.\\nNow to take out factor of min_length , create an array called next_idx which stores index of first index on right side from where you can start ending current subarray.\\nNow our dp has 3 arguments, index of array and length of subarrays chosen and {started} to check if given subarray has already started in last iteration. Further Memoization is done.\\n\\nTime complexity - O(m^2)+O(m*len) , where m is length of arr and len is number of subarrays chosen and both are of order 1000.\\nThird argument i.e. {started} is O(2), hence constant.\\n\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, min_len: int) -> int:\\n        n=len(s)\\n        mod=10**9+7\\n        prime=set([\\'2\\',\\'3\\',\\'5\\',\\'7\\'])\\n        if s[0] not in prime or s[-1] in prime: return 0\\n        arr=[]\\n        last,i=0,1\\n        while i<n:\\n            if (i==n-1) or (s[i] not in prime and s[i+1] in prime):\\n                arr.append(i-last+1)\\n                last=i+1\\n                i+=2\\n            else:\\n                i+=1\\n        pre_sum={-1:0}\\n        m=len(arr)\\n        next_idx=[-1]*m\\n        for i,val in enumerate(arr):\\n            pre_sum[i]=pre_sum[i-1]+val\\n        for i in range(m):\\n            for j in range(i+1,m+1):\\n                if pre_sum[j-1]-pre_sum[i-1]>=min_len:\\n                    next_idx[i]=j-1\\n                    break\\n        @cache\\n        def dp(idx,length,started):\\n            if idx==m:\\n                return 1 if (length==k and not started) else 0\\n            ans=0\\n            if started:\\n                #end here\\n                ans+=dp(idx+1,length+1,0)\\n                #don\\'t end here\\n                ans+=dp(idx+1,length,1)\\n            else:\\n                #start from here\\n                if next_idx[idx]!=-1: \\n                    ans+=dp(next_idx[idx],length,1)\\n            return ans%mod\\n        return dp(0,0,0)\\n            \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, min_len: int) -> int:\\n        n=len(s)\\n        mod=10**9+7\\n        prime=set([\\'2\\',\\'3\\',\\'5\\',\\'7\\'])\\n        if s[0] not in prime or s[-1] in prime: return 0\\n        arr=[]\\n        last,i=0,1\\n        while i<n:\\n            if (i==n-1) or (s[i] not in prime and s[i+1] in prime):\\n                arr.append(i-last+1)\\n                last=i+1\\n                i+=2\\n            else:\\n                i+=1\\n        pre_sum={-1:0}\\n        m=len(arr)\\n        next_idx=[-1]*m\\n        for i,val in enumerate(arr):\\n            pre_sum[i]=pre_sum[i-1]+val\\n        for i in range(m):\\n            for j in range(i+1,m+1):\\n                if pre_sum[j-1]-pre_sum[i-1]>=min_len:\\n                    next_idx[i]=j-1\\n                    break\\n        @cache\\n        def dp(idx,length,started):\\n            if idx==m:\\n                return 1 if (length==k and not started) else 0\\n            ans=0\\n            if started:\\n                #end here\\n                ans+=dp(idx+1,length+1,0)\\n                #don\\'t end here\\n                ans+=dp(idx+1,length,1)\\n            else:\\n                #start from here\\n                if next_idx[idx]!=-1: \\n                    ans+=dp(next_idx[idx],length,1)\\n            return ans%mod\\n        return dp(0,0,0)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846082,
                "title": "c-o-k-n-dp-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int mL) {\\n        int n=s.size();\\n        int mod=1e9+7;\\n        unordered_map<int,int> mp;\\n        vector<vector<int>> m1(n,vector<int>(k+1,0));\\n        vector<vector<int>> m2(n,vector<int>(k+1,0));\\n        for(int i=0;i<=k;i++){\\n            mp[i]=0;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=1;j<=k;j++){\\n                mp[j]=(mp[j]+m2[i][j])%mod;\\n            }\\n            if(i+mL>n){\\n                continue;\\n            }\\n            if(s[i] !=\\'2\\'&&s[i]!=\\'3\\'&&s[i]!=\\'5\\'&&s[i]!=\\'7\\'){\\n                continue;\\n            }\\n            if(i-1>=0 && !(s[i-1] !=\\'2\\'&&s[i-1]!=\\'3\\'&&s[i-1]!=\\'5\\'&&s[i-1]!=\\'7\\')){\\n                continue;\\n            }\\n            if(abs(n-i)<mL){\\n                //cout<<i<<endl;\\n                continue;\\n            }\\n            \\n            if(s[n-1] !=\\'2\\'&&s[n-1]!=\\'3\\'&&s[n-1]!=\\'5\\'&&s[n-1]!=\\'7\\'){\\n                m1[i][1]=1;\\n                if(i-mL>=0){\\n                    m2[i-mL][1]=(m2[i-mL][1]+m1[i][1])%mod;\\n                }\\n            }\\n            \\n            for(int j=2;j<=k;j++){\\n                m1[i][j]=(m1[i][j]+mp[j-1])%mod;\\n                if(i-mL>=0){\\n                    m2[i-mL][j]=(m2[i-mL][j]+m1[i][j])%mod;\\n                }\\n            }\\n        }\\n        return m1[0][k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int mL) {\\n        int n=s.size();\\n        int mod=1e9+7;\\n        unordered_map<int,int> mp;\\n        vector<vector<int>> m1(n,vector<int>(k+1,0));\\n        vector<vector<int>> m2(n,vector<int>(k+1,0));\\n        for(int i=0;i<=k;i++){\\n            mp[i]=0;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=1;j<=k;j++){\\n                mp[j]=(mp[j]+m2[i][j])%mod;\\n            }\\n            if(i+mL>n){\\n                continue;\\n            }\\n            if(s[i] !=\\'2\\'&&s[i]!=\\'3\\'&&s[i]!=\\'5\\'&&s[i]!=\\'7\\'){\\n                continue;\\n            }\\n            if(i-1>=0 && !(s[i-1] !=\\'2\\'&&s[i-1]!=\\'3\\'&&s[i-1]!=\\'5\\'&&s[i-1]!=\\'7\\')){\\n                continue;\\n            }\\n            if(abs(n-i)<mL){\\n                //cout<<i<<endl;\\n                continue;\\n            }\\n            \\n            if(s[n-1] !=\\'2\\'&&s[n-1]!=\\'3\\'&&s[n-1]!=\\'5\\'&&s[n-1]!=\\'7\\'){\\n                m1[i][1]=1;\\n                if(i-mL>=0){\\n                    m2[i-mL][1]=(m2[i-mL][1]+m1[i][1])%mod;\\n                }\\n            }\\n            \\n            for(int j=2;j<=k;j++){\\n                m1[i][j]=(m1[i][j]+mp[j-1])%mod;\\n                if(i-mL>=0){\\n                    m2[i-mL][j]=(m2[i-mL][j]+m1[i][j])%mod;\\n                }\\n            }\\n        }\\n        return m1[0][k];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2846040,
                "title": "c-solution-time-complexity-o-n-k-space-complexity-o-n-k",
                "content": "The intuition is if  i get my starting point of substring and  it is confirm that the ending to be string is valid is after  i+k-1  th index so now i just have to take care of my variable i,k\\n\\n```\\nclass Solution {\\npublic:\\n    long long dp[1003][1003][2];\\n    long long mod=1e9+7;\\n    int k;\\n    bool check(char s)\\n    {\\n        int n=s-\\'0\\';\\n        return (n==2||n==3||n==5||n==7);\\n    }\\n    long long fun(int i,int l,int start,string &s,int minl)\\n    {\\n         if(i==s.length())\\n         {\\n              return (start==1&&l==k);\\n         }\\n        \\n         if(i>s.length())return 0;\\n        \\n         if(l>k)return 0;\\n        \\n         if(dp[i][l][start]!=-1)return dp[i][l][start];\\n        \\n         long long ans=0;\\n        \\n         if(start)\\n         {\\n              if(check(s[i]))\\n              {\\n                   ans=(ans+fun(i+minl-1,l,0,s,minl))%mod;\\n              }\\n              else\\n              {\\n                  return 0;\\n              }\\n         }\\n         else\\n         {\\n              if(!check(s[i]))\\n              {\\n                  ans=(ans+fun(i+1,l+1,1,s,minl))%mod;\\n              }\\n             \\n             ans=(ans+fun(i+1,l,0,s,minl))%mod;\\n         }\\n        \\n        \\n        return dp[i][l][start]=ans;\\n        \\n        \\n    }\\n    int beautifulPartitions(string s, int K, int minLength) {\\n        \\n        k=K;\\n        if(minLength==1)minLength++;\\n        \\n        int n=s.length()+1;\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n              for(int j=0;j<=n;j++)\\n              {\\n                    dp[i][j][0]=dp[i][j][1]=-1;\\n              }\\n        }\\n        \\n        return fun(0,0,1,s,minLength);\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[1003][1003][2];\\n    long long mod=1e9+7;\\n    int k;\\n    bool check(char s)\\n    {\\n        int n=s-\\'0\\';\\n        return (n==2||n==3||n==5||n==7);\\n    }\\n    long long fun(int i,int l,int start,string &s,int minl)\\n    {\\n         if(i==s.length())\\n         {\\n              return (start==1&&l==k);\\n         }\\n        \\n         if(i>s.length())return 0;\\n        \\n         if(l>k)return 0;\\n        \\n         if(dp[i][l][start]!=-1)return dp[i][l][start];\\n        \\n         long long ans=0;\\n        \\n         if(start)\\n         {\\n              if(check(s[i]))\\n              {\\n                   ans=(ans+fun(i+minl-1,l,0,s,minl))%mod;\\n              }\\n              else\\n              {\\n                  return 0;\\n              }\\n         }\\n         else\\n         {\\n              if(!check(s[i]))\\n              {\\n                  ans=(ans+fun(i+1,l+1,1,s,minl))%mod;\\n              }\\n             \\n             ans=(ans+fun(i+1,l,0,s,minl))%mod;\\n         }\\n        \\n        \\n        return dp[i][l][start]=ans;\\n        \\n        \\n    }\\n    int beautifulPartitions(string s, int K, int minLength) {\\n        \\n        k=K;\\n        if(minLength==1)minLength++;\\n        \\n        int n=s.length()+1;\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n              for(int j=0;j<=n;j++)\\n              {\\n                    dp[i][j][0]=dp[i][j][1]=-1;\\n              }\\n        }\\n        \\n        return fun(0,0,1,s,minLength);\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845349,
                "title": "c-ac-solution-commented-and-explained",
                "content": "TC:O(N * K)\\nSC:O(N * K)\\n```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n\\t//check if charecter is prime or not\\n    bool isPrime(char &c){\\n        if((c==\\'2\\') or (c==\\'3\\') or (c==\\'5\\') or (c==\\'7\\')){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int get(int endIndex,int nowK, string &s, int &k, int &minLength){\\n       \\n        if(endIndex>=s.size() or nowK>=k){\\n            return 0;\\n        }\\n         if(dp[endIndex][nowK]!=-1){\\n            return dp[endIndex][nowK];\\n        }\\n        \\n\\t\\t//if we reach the last charecter we check if last non prime\\n        if(endIndex==s.size()-1){\\n\\t\\t    //if non prime the and splits equal to k-1(k parts need k-1 splits) then return 1 else 0\\n            if(!isPrime(s[endIndex]))\\n            if(nowK==(k-1)){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        int count=0;\\n\\t\\t//if end index is non prime then the string can be split\\n        if(!isPrime(s[endIndex])){\\n            if(((endIndex<(s.size()-1)  and isPrime(s[endIndex+1])))){\\n\\t\\t\\t\\t//if we split then we start looking from the next valid end index which is atleast of length minLength\\n                count+=get(endIndex+minLength,nowK+1, s, k, minLength);\\n                count%=1000000007;\\n            }\\n            \\n            \\n        }\\n\\t\\t// dont split and go to next index\\n        count+=get(endIndex+1, nowK, s, k, minLength);\\n        count%=1000000007;\\n        dp[endIndex][nowK]=count;\\n        return dp[endIndex][nowK];\\n        return count;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp));\\n        if(!isPrime(s[0])){\\n           return 0; \\n        }\\n        return get(minLength-1,0,s,k,minLength);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n\\t//check if charecter is prime or not\\n    bool isPrime(char &c){\\n        if((c==\\'2\\') or (c==\\'3\\') or (c==\\'5\\') or (c==\\'7\\')){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int get(int endIndex,int nowK, string &s, int &k, int &minLength){\\n       \\n        if(endIndex>=s.size() or nowK>=k){\\n            return 0;\\n        }\\n         if(dp[endIndex][nowK]!=-1){\\n            return dp[endIndex][nowK];\\n        }\\n        \\n\\t\\t//if we reach the last charecter we check if last non prime\\n        if(endIndex==s.size()-1){\\n\\t\\t    //if non prime the and splits equal to k-1(k parts need k-1 splits) then return 1 else 0\\n            if(!isPrime(s[endIndex]))\\n            if(nowK==(k-1)){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        int count=0;\\n\\t\\t//if end index is non prime then the string can be split\\n        if(!isPrime(s[endIndex])){\\n            if(((endIndex<(s.size()-1)  and isPrime(s[endIndex+1])))){\\n\\t\\t\\t\\t//if we split then we start looking from the next valid end index which is atleast of length minLength\\n                count+=get(endIndex+minLength,nowK+1, s, k, minLength);\\n                count%=1000000007;\\n            }\\n            \\n            \\n        }\\n\\t\\t// dont split and go to next index\\n        count+=get(endIndex+1, nowK, s, k, minLength);\\n        count%=1000000007;\\n        dp[endIndex][nowK]=count;\\n        return dp[endIndex][nowK];\\n        return count;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp));\\n        if(!isPrime(s[0])){\\n           return 0; \\n        }\\n        return get(minLength-1,0,s,k,minLength);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845061,
                "title": "c-dp-understandable-approach",
                "content": "```\\n//Please upvote if you liked the solution\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n   int dp[1001][1001];\\n    bool isvalid(char &ch){\\n        \\n        if((ch==\\'2\\' || ch==\\'3\\' || ch==\\'5\\' || ch==\\'7\\')) return true;\\n        return false;\\n    }\\n    int func(string &s,int i,int k,int mini){\\n        \\n        if(k==1){\\n            if(s.size()-i>=mini &&!isvalid(s[s.size()-1]) && isvalid(s[i])) return 1;\\n            return 0;\\n        }\\n        if(i>=s.size()) return 0;\\n        if(!isvalid(s[i])) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n       \\n        \\n        long long ways=0;\\n        for(int j=i+mini-1;j<s.size();j++){\\n            if(!isvalid(s[j]))\\n            ways+=func(s,j+1,k-1,mini)%mod;\\n        }\\n        return dp[i][k]=ways%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp));\\n        return func(s,0,k,minLength);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Please upvote if you liked the solution\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n   int dp[1001][1001];\\n    bool isvalid(char &ch){\\n        \\n        if((ch==\\'2\\' || ch==\\'3\\' || ch==\\'5\\' || ch==\\'7\\')) return true;\\n        return false;\\n    }\\n    int func(string &s,int i,int k,int mini){\\n        \\n        if(k==1){\\n            if(s.size()-i>=mini &&!isvalid(s[s.size()-1]) && isvalid(s[i])) return 1;\\n            return 0;\\n        }\\n        if(i>=s.size()) return 0;\\n        if(!isvalid(s[i])) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n       \\n        \\n        long long ways=0;\\n        for(int j=i+mini-1;j<s.size();j++){\\n            if(!isvalid(s[j]))\\n            ways+=func(s,j+1,k-1,mini)%mod;\\n        }\\n        return dp[i][k]=ways%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp));\\n        return func(s,0,k,minLength);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843327,
                "title": "python-dp-solution-space-optimized",
                "content": "dp[i][j] means the number of partition method for **substring ending with s[j] resulting in i parts**\\n\\nAnother trick here is to map \\'2357\\' with \\'1\\' and others with \\'0\\'\\nThis makes the implementation much easier.\\n\\n2d space dp solution: space-O(nk)\\n```\\ndef beautifulPartitions(self, s: str, k: int, x: int) -> int:\\n\\ts = \\'\\'.join(\\'1\\' if c in \\'2357\\' else \\'0\\' for c in s)\\n\\tif s[0]+s[-1]!=\\'10\\':\\n\\t\\treturn 0\\n\\n\\tmod, n = 10**9+7, len(s)\\n\\tdp = [[0]*(n+1) for _ in range(k+1)]\\n\\tdp[0][0] = 1\\n\\tfor i in range(1, k+1):\\n\\t\\tcur = 0\\n\\t\\tfor j in range(x-1, n):\\n\\t\\t\\tif (j<x or s[j-x]==\\'0\\') and s[j-x+1]==\\'1\\':\\n\\t\\t\\t\\tcur = (cur+dp[i-1][j-x+1]) % mod\\n\\t\\t\\tdp[i][j+1] = cur\\n\\treturn dp[-1][-1]\\n```\\n\\nspace optimized dp solution: space-O(n)\\n```\\ndef beautifulPartitions(self, s: str, k: int, x: int) -> int:\\n\\ts = \\'\\'.join(\\'1\\' if c in \\'2357\\' else \\'0\\' for c in s)\\n\\tif s[0]+s[-1]!=\\'10\\':\\n\\t\\treturn 0\\n\\n\\tdp, mod, n = [1]+[0]*(len(s)), 10**9+7, len(s)\\n\\tfor _ in range(1, k+1):\\n\\t\\tcur, dp_cur = 0, [0]*(n+1)\\n\\t\\tfor i in range(x-1, n):\\n\\t\\t\\tif (i<x or s[i-x]==\\'0\\') and s[i-x+1]==\\'1\\':\\n\\t\\t\\t\\tcur = (cur+dp[i-x+1]) % mod\\n\\t\\t\\tdp_cur[i+1] = cur\\n\\t\\tdp = dp_cur\\n\\treturn dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautifulPartitions(self, s: str, k: int, x: int) -> int:\\n\\ts = \\'\\'.join(\\'1\\' if c in \\'2357\\' else \\'0\\' for c in s)\\n\\tif s[0]+s[-1]!=\\'10\\':\\n\\t\\treturn 0\\n\\n\\tmod, n = 10**9+7, len(s)\\n\\tdp = [[0]*(n+1) for _ in range(k+1)]\\n\\tdp[0][0] = 1\\n\\tfor i in range(1, k+1):\\n\\t\\tcur = 0\\n\\t\\tfor j in range(x-1, n):\\n\\t\\t\\tif (j<x or s[j-x]==\\'0\\') and s[j-x+1]==\\'1\\':\\n\\t\\t\\t\\tcur = (cur+dp[i-1][j-x+1]) % mod\\n\\t\\t\\tdp[i][j+1] = cur\\n\\treturn dp[-1][-1]\\n```\n```\\ndef beautifulPartitions(self, s: str, k: int, x: int) -> int:\\n\\ts = \\'\\'.join(\\'1\\' if c in \\'2357\\' else \\'0\\' for c in s)\\n\\tif s[0]+s[-1]!=\\'10\\':\\n\\t\\treturn 0\\n\\n\\tdp, mod, n = [1]+[0]*(len(s)), 10**9+7, len(s)\\n\\tfor _ in range(1, k+1):\\n\\t\\tcur, dp_cur = 0, [0]*(n+1)\\n\\t\\tfor i in range(x-1, n):\\n\\t\\t\\tif (i<x or s[i-x]==\\'0\\') and s[i-x+1]==\\'1\\':\\n\\t\\t\\t\\tcur = (cur+dp[i-x+1]) % mod\\n\\t\\t\\tdp_cur[i+1] = cur\\n\\t\\tdp = dp_cur\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2843239,
                "title": "c-recursion-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prime[10];\\n    long long cache[1001][1001];\\n    static const int mod = 1e9 + 7;\\n    long long dp(int i, int k, int& minLength, string& s) {\\n        if(i == s.size()) {\\n            return (k == 0 ? 1 : 0);\\n        }\\n        long long& ans = cache[i][k];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        if(prime[s[i] - \\'0\\']) {\\n            for(int j =  i + minLength - 1; j < (int) s.size(); j++) {\\n                if(prime[s[j] - \\'0\\'] == 0 && k - 1 >= 0) {\\n                    ans += dp(j + 1, k - 1, minLength, s) % mod;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        prime[2] = 1;\\n        prime[3] = 1;\\n        prime[5] = 1;\\n        prime[7] = 1;\\n        memset(cache, -1, sizeof(cache));\\n        long long ans = dp(0, k, minLength, s);\\n        ans %= mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prime[10];\\n    long long cache[1001][1001];\\n    static const int mod = 1e9 + 7;\\n    long long dp(int i, int k, int& minLength, string& s) {\\n        if(i == s.size()) {\\n            return (k == 0 ? 1 : 0);\\n        }\\n        long long& ans = cache[i][k];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        if(prime[s[i] - \\'0\\']) {\\n            for(int j =  i + minLength - 1; j < (int) s.size(); j++) {\\n                if(prime[s[j] - \\'0\\'] == 0 && k - 1 >= 0) {\\n                    ans += dp(j + 1, k - 1, minLength, s) % mod;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        prime[2] = 1;\\n        prime[3] = 1;\\n        prime[5] = 1;\\n        prime[7] = 1;\\n        memset(cache, -1, sizeof(cache));\\n        long long ans = dp(0, k, minLength, s);\\n        ans %= mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843045,
                "title": "c-dp-optimized-memoisation",
                "content": "**If Helpful PLease Like Or Upvoke\\uD83C\\uDF97**\\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int dp[1001][1001]={-1};\\n    \\n    bool is_prime(char c){\\n        return c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\';\\n    }\\n    \\n    long f(string &s,int idx,int k,int len){\\n        if(idx==s.size()&&k==0)\\n            return 1;\\n        if(idx>=s.size()||k<=0||idx>s.size()-len*k)\\n            return 0;\\n        \\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n        \\n        long temp=0;\\n        if(is_prime(s[idx])){\\n            for(int i=idx+len-1;i<s.size();i++)\\n                if(!is_prime(s[i]))\\n                    temp=(temp+f(s,i+1,k-1,len))%mod;\\n        }\\n        return dp[idx][k]=temp;        \\n    }\\n    \\npublic:\\n    int beautifulPartitions(string s, int k, int ml) {\\n        memset(dp,-1,sizeof dp);\\n        return f(s,0,k,ml);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    int dp[1001][1001]={-1};\\n    \\n    bool is_prime(char c){\\n        return c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\';\\n    }\\n    \\n    long f(string &s,int idx,int k,int len){\\n        if(idx==s.size()&&k==0)\\n            return 1;\\n        if(idx>=s.size()||k<=0||idx>s.size()-len*k)\\n            return 0;\\n        \\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n        \\n        long temp=0;\\n        if(is_prime(s[idx])){\\n            for(int i=idx+len-1;i<s.size();i++)\\n                if(!is_prime(s[i]))\\n                    temp=(temp+f(s,i+1,k-1,len))%mod;\\n        }\\n        return dp[idx][k]=temp;        \\n    }\\n    \\npublic:\\n    int beautifulPartitions(string s, int k, int ml) {\\n        memset(dp,-1,sizeof dp);\\n        return f(s,0,k,ml);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842943,
                "title": "simplest-dp-9-lines-o-kn-beats-100",
                "content": "# Intuition\\nIntuition is to solve this problem with DP. But, like many, I ran into TLE first with a naive solution which is $O(kN^2)$.\\n\\nRealizing that we can accumulate all possibilities in a running sum will help us achieve a $O(kN)$ solution.\\n\\n\\n\\n# Approach\\n$dp[i][j]$ is the number of ways to form $j$ partitions ending at position $i-1$. Therefore, we simply return $dp[n][k]$ as the answer at the end.\\n\\nWe set $dp[0][0] = 1$ to handle the boundary case, then we iterate over all $i$ and $j$, at each step:\\n\\n$$dp[i][j] = 0$$, *if $s[i-1]$ is prime*\\n$$dp[i][j] = \\\\sum dp[i\\'][j-1]$$, *if $s[i-1]$ is not prime (and therefore can end a partition)*\\n\\nNote that $$i\\'$$ must satisfy $$i - i\\' >= minLength$$, and $$i\\'$$ can start a partition meaning $$s[i\\'-1]$$ needs to be prime. Note that we don\\'t need to check if $s[i\\'-2]$ is non-prime, because its contribution will be zero anyway.\\n\\nIn this way, we can keep accumulating all $dp[i\\'][j-1]$ as we encounter them during the iteration, and assign the running sum to $dp[i][j]$ whenever $s[i-1]$ is not prime.\\n\\n# Complexity\\n- Time complexity:\\nO(kN)\\n\\n- Space complexity:\\nO(kN)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int ml) {\\n        int n = s.size(), mod = 1e9 + 7;\\n        int dp[1001][1001] = {};\\n        dp[0][0] = 1;\\n\\n        for (int j = 1; j <= k; j++) {\\n            int total = 0;\\n            for (int i = 1; i <= n; i++) {\\n                if (i >= ml && isPrime(s[i-ml])) total = (total + dp[i-ml][j-1]) % mod;\\n                if (!isPrime(s[i-1])) dp[i][j] = total;\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n\\n    bool isPrime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int ml) {\\n        int n = s.size(), mod = 1e9 + 7;\\n        int dp[1001][1001] = {};\\n        dp[0][0] = 1;\\n\\n        for (int j = 1; j <= k; j++) {\\n            int total = 0;\\n            for (int i = 1; i <= n; i++) {\\n                if (i >= ml && isPrime(s[i-ml])) total = (total + dp[i-ml][j-1]) % mod;\\n                if (!isPrime(s[i-1])) dp[i][j] = total;\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n\\n    bool isPrime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841517,
                "title": "dp-optimization-using-suffix-sum-o-k-n",
                "content": "```\\n#define ll long long \\nconst int mod=1e9+7;\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int mn) {\\n        int n=s.length();\\n        vector<vector<ll>> dp(n+2,vector<ll>(k+2,-1));\\n        vector<int> pr(12,0);\\n        for(auto e:{2,3,5,7})\\n            pr[e]=1;\\n        if(n<(k*mn) or !pr[s[0]-\\'0\\'] or pr[s.back()-\\'0\\'])\\n            return 0;\\n        vector<int> valid(n+2,0);\\n        for(int i=1;i<n;i++)\\n            if(!pr[s[i-1]-\\'0\\'] and pr[s[i]-\\'0\\'])\\n                valid[i]=1;\\n        valid[0]=1;\\n        for(int i=n-mn;i>=0;i--){\\n            if(pr[s[i]-\\'0\\'])\\n                dp[i][1]=1;\\n        }\\n        \\n        for(int i=2;i<=k;i++){\\n            vector<int> tot(n+2,0);\\n            for(int j=n-mn;j>=0;j--){\\n                tot[j]=tot[j+1];\\n                if(valid[j])\\n                    tot[j]=(tot[j]+dp[j][i-1])%mod;\\n            }\\n            for(int j=n-mn;j>=0;j--){\\n                if(pr[s[j]-\\'0\\'])\\n                    dp[j][i]=tot[j+mn];\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long \\nconst int mod=1e9+7;\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int mn) {\\n        int n=s.length();\\n        vector<vector<ll>> dp(n+2,vector<ll>(k+2,-1));\\n        vector<int> pr(12,0);\\n        for(auto e:{2,3,5,7})\\n            pr[e]=1;\\n        if(n<(k*mn) or !pr[s[0]-\\'0\\'] or pr[s.back()-\\'0\\'])\\n            return 0;\\n        vector<int> valid(n+2,0);\\n        for(int i=1;i<n;i++)\\n            if(!pr[s[i-1]-\\'0\\'] and pr[s[i]-\\'0\\'])\\n                valid[i]=1;\\n        valid[0]=1;\\n        for(int i=n-mn;i>=0;i--){\\n            if(pr[s[i]-\\'0\\'])\\n                dp[i][1]=1;\\n        }\\n        \\n        for(int i=2;i<=k;i++){\\n            vector<int> tot(n+2,0);\\n            for(int j=n-mn;j>=0;j--){\\n                tot[j]=tot[j+1];\\n                if(valid[j])\\n                    tot[j]=(tot[j]+dp[j][i-1])%mod;\\n            }\\n            for(int j=n-mn;j>=0;j--){\\n                if(pr[s[j]-\\'0\\'])\\n                    dp[j][i]=tot[j+mn];\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839362,
                "title": "asked-in-google-online-assessment",
                "content": "```\\nconst int mod=1000000007;\\n\\nclass Solution {\\n    bool isPrime(char c){\\n        if(c==\\'2\\'||c==\\'3\\'||c==\\'5\\'||c==\\'7\\')\\n            return true;\\n        return false;\\n    }\\n    \\n\\n    \\n    public:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        for(auto &e:s){\\n            if(isPrime(e))\\n                e=\\'1\\';\\n            else \\n                e=\\'0\\';\\n        }\\n        int n=s.size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        dp[0][0]=1;\\n        \\n      ///  cout<<s<<endl;\\n      \\n           int sum[n+1][n+1];\\n           memset(sum,0,sizeof(sum));\\n        \\n           if(s[0]==\\'1\\')\\n               sum[0][0]=1;\\n        \\n           for(int pos=1;pos<=n;pos++)\\n               sum[pos][0]+=sum[pos-1][0];\\n        \\n            for(int part=1;part<=k;part++){\\n                  for(int pos=1;pos<=n;pos++){\\n                if(s[pos-1]==\\'1\\')\\n                    continue;\\n                int r=pos-minLength;\\n                      if(r>=0){\\n                          dp[pos][part]=sum[r][part-1];\\n                      }\\n            }\\n                \\n                for(int pos=0;pos<=n;pos++){\\n                    if(pos<n && s[pos]==\\'1\\')\\n                        sum[pos][part]=dp[pos][part];\\n                    if(pos>0)\\n                    sum[pos][part]+=sum[pos-1][part];\\n                    sum[pos][part]%=mod;\\n                }\\n                \\n                \\n        }\\n        \\n        return dp[n][k];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int mod=1000000007;\\n\\nclass Solution {\\n    bool isPrime(char c){\\n        if(c==\\'2\\'||c==\\'3\\'||c==\\'5\\'||c==\\'7\\')\\n            return true;\\n        return false;\\n    }\\n    \\n\\n    \\n    public:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        for(auto &e:s){\\n            if(isPrime(e))\\n                e=\\'1\\';\\n            else \\n                e=\\'0\\';\\n        }\\n        int n=s.size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        dp[0][0]=1;\\n        \\n      ///  cout<<s<<endl;\\n      \\n           int sum[n+1][n+1];\\n           memset(sum,0,sizeof(sum));\\n        \\n           if(s[0]==\\'1\\')\\n               sum[0][0]=1;\\n        \\n           for(int pos=1;pos<=n;pos++)\\n               sum[pos][0]+=sum[pos-1][0];\\n        \\n            for(int part=1;part<=k;part++){\\n                  for(int pos=1;pos<=n;pos++){\\n                if(s[pos-1]==\\'1\\')\\n                    continue;\\n                int r=pos-minLength;\\n                      if(r>=0){\\n                          dp[pos][part]=sum[r][part-1];\\n                      }\\n            }\\n                \\n                for(int pos=0;pos<=n;pos++){\\n                    if(pos<n && s[pos]==\\'1\\')\\n                        sum[pos][part]=dp[pos][part];\\n                    if(pos>0)\\n                    sum[pos][part]+=sum[pos-1][part];\\n                    sum[pos][part]%=mod;\\n                }\\n                \\n                \\n        }\\n        \\n        return dp[n][k];\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2838755,
                "title": "c-dp-bottom-up-with-prefix-sum-optimisation",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    bool isPrime(char ch) {\\n        if (ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\'\\n           || ch == \\'7\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int add(int a, int b) {\\n        a += b;\\n        if (a >= mod) {\\n            a -= mod;\\n        }\\n        return a;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        s.push_back(\\'2\\');\\n        int n = s.size();\\n        if (!isPrime(s.front())) {\\n            return 0;\\n        }\\n        vector<vector<int>> dp(n, vector<int> (k));\\n        for (int i = 0; i < n - 1; i++) {\\n            if (i + 1 >= minLength && !isPrime(s[i]) && isPrime(s[i + 1])) {\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for (int K = 1; K < k; K++) {\\n            vector<int> sum(n);\\n            sum[0] = dp[0][K - 1];\\n            for (int i = 0; i < n - 1; i++) {\\n                sum[i + 1] = add(sum[i], dp[i + 1][K - 1]);\\n            }\\n            for (int i = 0; i < n - 1; i++) {\\n                if (!isPrime(s[i]) && isPrime(s[i + 1])) {\\n                    if (i - minLength >= 0) {\\n                        dp[i][K] = sum[i - minLength];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n - 2][k - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    bool isPrime(char ch) {\\n        if (ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\'\\n           || ch == \\'7\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int add(int a, int b) {\\n        a += b;\\n        if (a >= mod) {\\n            a -= mod;\\n        }\\n        return a;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        s.push_back(\\'2\\');\\n        int n = s.size();\\n        if (!isPrime(s.front())) {\\n            return 0;\\n        }\\n        vector<vector<int>> dp(n, vector<int> (k));\\n        for (int i = 0; i < n - 1; i++) {\\n            if (i + 1 >= minLength && !isPrime(s[i]) && isPrime(s[i + 1])) {\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for (int K = 1; K < k; K++) {\\n            vector<int> sum(n);\\n            sum[0] = dp[0][K - 1];\\n            for (int i = 0; i < n - 1; i++) {\\n                sum[i + 1] = add(sum[i], dp[i + 1][K - 1]);\\n            }\\n            for (int i = 0; i < n - 1; i++) {\\n                if (!isPrime(s[i]) && isPrime(s[i + 1])) {\\n                    if (i - minLength >= 0) {\\n                        dp[i][K] = sum[i - minLength];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n - 2][k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838268,
                "title": "dp-o-nk-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int solve(int len, vector<int> &parts, int cur, vector<vector<int>> &dp, int k, int minLength) {\\n        if (dp[cur][k] != -1) return dp[cur][k];\\n        // number of paritions left are less than required k\\n        // or last parition length is less than the minLength required\\n        if ((k > (parts.size()-cur)) || ((len-parts[cur]) < minLength))\\n            return 0;\\n        \\n        // if last partition left and we have enough parts left \\n        if ((k == 1) && (cur < parts.size())) {\\n            return 1;\\n        }\\n        \\n        int curResult = 0;\\n        // check for next parts in the segments\\n        for (int i = cur+1; i < parts.size(); i++) {\\n            int dist = parts[i] - parts[cur];\\n            if (dist < minLength) continue;\\n            curResult = curResult + solve(len,parts,i,dp,k-1,minLength) % mod;\\n            curResult = curResult % mod;\\n        }\\n        dp[cur][k] = curResult;\\n        return dp[cur][k];\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        vector<bool> prime(10,false);\\n        prime[2] = prime[3] = prime[5] = prime[7] = true;\\n        if (!prime[s[0]-\\'0\\'])\\n            return 0;\\n        int len = s.size();\\n        if (k == 1)\\n            return !prime[s[len-1]-\\'0\\']; \\n        \\n        vector<int> parts;\\n        parts.push_back(0);\\n        for (int i = 1;  i < len; i++) {\\n            if ((prime[s[i]-\\'0\\']) && (!prime[s[i-1]-\\'0\\'])) {\\n                parts.push_back(i);\\n            }\\n        }\\n        int n = parts.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return solve(len,parts,0,dp,k,minLength);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int solve(int len, vector<int> &parts, int cur, vector<vector<int>> &dp, int k, int minLength) {\\n        if (dp[cur][k] != -1) return dp[cur][k];\\n        // number of paritions left are less than required k\\n        // or last parition length is less than the minLength required\\n        if ((k > (parts.size()-cur)) || ((len-parts[cur]) < minLength))\\n            return 0;\\n        \\n        // if last partition left and we have enough parts left \\n        if ((k == 1) && (cur < parts.size())) {\\n            return 1;\\n        }\\n        \\n        int curResult = 0;\\n        // check for next parts in the segments\\n        for (int i = cur+1; i < parts.size(); i++) {\\n            int dist = parts[i] - parts[cur];\\n            if (dist < minLength) continue;\\n            curResult = curResult + solve(len,parts,i,dp,k-1,minLength) % mod;\\n            curResult = curResult % mod;\\n        }\\n        dp[cur][k] = curResult;\\n        return dp[cur][k];\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        vector<bool> prime(10,false);\\n        prime[2] = prime[3] = prime[5] = prime[7] = true;\\n        if (!prime[s[0]-\\'0\\'])\\n            return 0;\\n        int len = s.size();\\n        if (k == 1)\\n            return !prime[s[len-1]-\\'0\\']; \\n        \\n        vector<int> parts;\\n        parts.push_back(0);\\n        for (int i = 1;  i < len; i++) {\\n            if ((prime[s[i]-\\'0\\']) && (!prime[s[i-1]-\\'0\\'])) {\\n                parts.push_back(i);\\n            }\\n        }\\n        int n = parts.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return solve(len,parts,0,dp,k,minLength);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837603,
                "title": "python-top-down-dp-o-nk",
                "content": "```\\nfrom functools import cache\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, m: int) -> int:\\n        n = len(s)\\n        M = 10**9 + 7\\n        @cache\\n        def dfs(i, split, k):\\n            if k == 0 and i == n and split:\\n                return 1\\n            if i >= n: return 0\\n            if split:\\n                if int(s[i]) not in [2,3,5,7]: return 0\\n                return dfs(i+m-1, False, k)\\n            else:\\n                if int(s[i]) in [2,3,5,7]:\\n                    return dfs(i+1, False, k)\\n                return (dfs(i+1, True, k-1) + dfs(i+1, False, k))%M\\n        return dfs(0, True, k)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, m: int) -> int:\\n        n = len(s)\\n        M = 10**9 + 7\\n        @cache\\n        def dfs(i, split, k):\\n            if k == 0 and i == n and split:\\n                return 1\\n            if i >= n: return 0\\n            if split:\\n                if int(s[i]) not in [2,3,5,7]: return 0\\n                return dfs(i+m-1, False, k)\\n            else:\\n                if int(s[i]) in [2,3,5,7]:\\n                    return dfs(i+1, False, k)\\n                return (dfs(i+1, True, k-1) + dfs(i+1, False, k))%M\\n        return dfs(0, True, k)",
                "codeTag": "Java"
            },
            {
                "id": 2837438,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:  \\n        mod, primes, N = 10**9 + 7, \\'2357\\', len(s)\\n        \\n        if s[0] not in primes or s[-1] in primes: return 0\\n        \\n        dp = [[0] * (N + 1) for _ in range(k + 1)]\\n        dp[0][0] = 1\\n                        \\n        for parts in range(1, k + 1):\\n            count = 0\\n            for j in range(minLength - 1, N):\\n                    if (j < minLength or s[j - minLength] not in primes) and s[j - minLength + 1] in primes:\\n                        count =  (count + dp[parts - 1][j - minLength + 1]) % mod                    \\n                    dp[parts][j + 1] = count\\n\\n        return dp[k][N]\\n```\\nWith sufix calculation:\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:  \\n        mod, primes, N = 10**9 + 7, \\'2357\\', len(s)\\n        \\n        if s[0] not in primes or s[-1] in primes: return 0\\n                \\n        dp = [0] * (N + 1)\\n\\n        dp[N] = 0 if s[N - 1] in primes else 1\\n\\n        for _ in range(k):\\n            sufix = [0] * (N + 1)\\n            sufix, dp = dp, sufix\\n\\n            for i in range(N - 1, -1, -1):\\n                if i > 0 and s[i - 1] in primes:\\n                    sufix[i] = 0\\n          \\n                sufix[i] = (sufix[i] + sufix[i + 1]) % mod\\n            \\n            for i in range(N - minLength + 1):\\n                if s[i] in primes:\\n                    dp[i] = sufix[i + minLength]\\n                \\n        return dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:  \\n        mod, primes, N = 10**9 + 7, \\'2357\\', len(s)\\n        \\n        if s[0] not in primes or s[-1] in primes: return 0\\n        \\n        dp = [[0] * (N + 1) for _ in range(k + 1)]\\n        dp[0][0] = 1\\n                        \\n        for parts in range(1, k + 1):\\n            count = 0\\n            for j in range(minLength - 1, N):\\n                    if (j < minLength or s[j - minLength] not in primes) and s[j - minLength + 1] in primes:\\n                        count =  (count + dp[parts - 1][j - minLength + 1]) % mod                    \\n                    dp[parts][j + 1] = count\\n\\n        return dp[k][N]\\n```\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:  \\n        mod, primes, N = 10**9 + 7, \\'2357\\', len(s)\\n        \\n        if s[0] not in primes or s[-1] in primes: return 0\\n                \\n        dp = [0] * (N + 1)\\n\\n        dp[N] = 0 if s[N - 1] in primes else 1\\n\\n        for _ in range(k):\\n            sufix = [0] * (N + 1)\\n            sufix, dp = dp, sufix\\n\\n            for i in range(N - 1, -1, -1):\\n                if i > 0 and s[i - 1] in primes:\\n                    sufix[i] = 0\\n          \\n                sufix[i] = (sufix[i] + sufix[i + 1]) % mod\\n            \\n            for i in range(N - minLength + 1):\\n                if s[i] in primes:\\n                    dp[i] = sufix[i + minLength]\\n                \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837392,
                "title": "java-dp-o-k-n",
                "content": "```\\nclass Solution {\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        Set<Character> set = new HashSet<>(Arrays.asList(\\'2\\', \\'3\\', \\'5\\', \\'7\\'));\\n        if (!set.contains(s.charAt(0)) || set.contains(s.charAt(s.length() - 1)))\\n            return 0;\\n        int mod = (int)1e9 + 7;\\n        int n = s.length();\\n        long[][] dp = new long[n][k + 1];\\n        \\n        int[] primes = new int[n];\\n        primes[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (set.contains(s.charAt(i)) && !set.contains(s.charAt(i - 1)))  {\\n                primes[i] = i;\\n            }\\n            else    {\\n                primes[i] = primes[i - 1];\\n            }\\n        }\\n        \\n        long[][] presum = new long[n + 1][k + 1];\\n        \\n        for (int i = 0; i < n; i++)    {\\n            if (i < minLength - 1 || set.contains(s.charAt(i)))  {\\n                dp[i][1] = 0;\\n                continue;\\n            }\\n            dp[i][1] = 1;\\n        }\\n        \\n        for (int i = minLength - 1; i < n; i++)    {\\n            presum[i + 1][1] = presum[i][1];\\n            if (i == n - 1 || !set.contains(s.charAt(i)) && set.contains(s.charAt(i + 1)))  {\\n                presum[i + 1][1] = (presum[i + 1][1] + dp[i][1]) % mod;\\n            }\\n        }\\n        \\n        \\n        for (int j = 2; j <= k; j++)    {\\n            for (int i = j * minLength - 1; i < n; i++)    {\\n                if (set.contains(s.charAt(i)))  {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n                int idx = primes[i - minLength + 1];\\n                dp[i][j] = presum[idx][j - 1];\\n            }\\n            \\n            for (int i = j * minLength - 1; i < n; i++) {\\n                presum[i + 1][j] = presum[i][j];\\n                if (i == n - 1 || !set.contains(s.charAt(i)) && set.contains(s.charAt(i + 1)))  {\\n                    presum[i + 1][j] = (presum[i + 1][j] + dp[i][j]) % mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[n - 1][k];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        Set<Character> set = new HashSet<>(Arrays.asList(\\'2\\', \\'3\\', \\'5\\', \\'7\\'));\\n        if (!set.contains(s.charAt(0)) || set.contains(s.charAt(s.length() - 1)))\\n            return 0;\\n        int mod = (int)1e9 + 7;\\n        int n = s.length();\\n        long[][] dp = new long[n][k + 1];\\n        \\n        int[] primes = new int[n];\\n        primes[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (set.contains(s.charAt(i)) && !set.contains(s.charAt(i - 1)))  {\\n                primes[i] = i;\\n            }\\n            else    {\\n                primes[i] = primes[i - 1];\\n            }\\n        }\\n        \\n        long[][] presum = new long[n + 1][k + 1];\\n        \\n        for (int i = 0; i < n; i++)    {\\n            if (i < minLength - 1 || set.contains(s.charAt(i)))  {\\n                dp[i][1] = 0;\\n                continue;\\n            }\\n            dp[i][1] = 1;\\n        }\\n        \\n        for (int i = minLength - 1; i < n; i++)    {\\n            presum[i + 1][1] = presum[i][1];\\n            if (i == n - 1 || !set.contains(s.charAt(i)) && set.contains(s.charAt(i + 1)))  {\\n                presum[i + 1][1] = (presum[i + 1][1] + dp[i][1]) % mod;\\n            }\\n        }\\n        \\n        \\n        for (int j = 2; j <= k; j++)    {\\n            for (int i = j * minLength - 1; i < n; i++)    {\\n                if (set.contains(s.charAt(i)))  {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n                int idx = primes[i - minLength + 1];\\n                dp[i][j] = presum[idx][j - 1];\\n            }\\n            \\n            for (int i = j * minLength - 1; i < n; i++) {\\n                presum[i + 1][j] = presum[i][j];\\n                if (i == n - 1 || !set.contains(s.charAt(i)) && set.contains(s.charAt(i + 1)))  {\\n                    presum[i + 1][j] = (presum[i + 1][j] + dp[i][j]) % mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[n - 1][k];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836822,
                "title": "c-dynamic-programming-solution-easy-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool Prime[11];\\n\\t\\tvoid SieveOfEratosthenes(int n)\\n\\t\\t{\\n\\t\\t\\tfor (int p = 2; p * p <= n; p++) {\\n\\t\\t\\t\\tif (Prime[p] == true) {\\n\\t\\t\\t\\t\\tfor (int i = p * p; i <= n; i += p)\\n\\t\\t\\t\\t\\t\\tPrime[i] = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tPrime[1] = false;\\n\\t\\t}\\n\\t\\tint dp[1002][1002];\\n\\t\\tint n,N = 1e9 + 7;\\n\\t\\tstring s;\\n\\t\\tint cal(int i,int k,int mi){\\n\\t\\t\\tif(k==1){\\n\\t\\t\\t\\treturn (n-i >= mi);\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][k]!=-1) return dp[i][k];\\n\\t\\t\\tdp[i][k] = 0;\\n\\n\\t\\t\\tfor(int j=i+mi;j<n;j++){\\n\\t\\t\\t\\tif(Prime[s[j]-\\'0\\'] && !Prime[s[j-1]-\\'0\\']){\\n\\t\\t\\t\\t\\tdp[i][k] = (dp[i][k] + cal(j,k-1,mi))%N;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[i][k];\\n\\t\\t}\\n\\t\\tint beautifulPartitions(string st, int k, int minLength) {\\n\\t\\t\\tmemset(Prime,true,sizeof(Prime));\\n\\t\\t\\tn = st.size();\\n\\t\\t\\ts = st;\\n\\t\\t\\tSieveOfEratosthenes(10);\\n\\t\\t\\tif(!Prime[st[0]-\\'0\\'] | Prime[st[n-1]-\\'0\\']) return 0;\\n\\t\\t\\tmemset(dp,-1,sizeof(dp));\\n\\t\\t\\treturn cal(0,k,minLength);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool Prime[11];\\n\\t\\tvoid SieveOfEratosthenes(int n)\\n\\t\\t{\\n\\t\\t\\tfor (int p = 2; p * p <= n; p++) {\\n\\t\\t\\t\\tif (Prime[p] == true) {\\n\\t\\t\\t\\t\\tfor (int i = p * p; i <= n; i += p)\\n\\t\\t\\t\\t\\t\\tPrime[i] = false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2836357,
                "title": "c-dp-memorization-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[1001][1001];\\n    int mod=1000000007;\\n    \\n    bool isPrime(char c){\\n        return (c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\');\\n    }\\n    long long solve(int index,string &s,int k,int m,int n){\\n        if(index>=n){\\n            return (k==0)?1:0;\\n        }\\n        if(k==0){\\n            return 0;\\n        }\\n        if(index+m*k>n || !isPrime(s[index])){\\n            return 0;\\n        }\\n        if(dp[index][k]!=-1){\\n            return dp[index][k];\\n        }\\n        long long ans=0;\\n        for(int i=index+m-1;i<n;i++){\\n            \\n            if(!isPrime(s[i])){\\n                ans=(ans+solve(i+1,s,k-1,m,n))%mod;\\n            }\\n        }\\n        return dp[index][k]=ans;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp)); \\n        int n=s.size();\\n        \\n        return solve(0,s,k,minLength,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[1001][1001];\\n    int mod=1000000007;\\n    \\n    bool isPrime(char c){\\n        return (c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\');\\n    }\\n    long long solve(int index,string &s,int k,int m,int n){\\n        if(index>=n){\\n            return (k==0)?1:0;\\n        }\\n        if(k==0){\\n            return 0;\\n        }\\n        if(index+m*k>n || !isPrime(s[index])){\\n            return 0;\\n        }\\n        if(dp[index][k]!=-1){\\n            return dp[index][k];\\n        }\\n        long long ans=0;\\n        for(int i=index+m-1;i<n;i++){\\n            \\n            if(!isPrime(s[i])){\\n                ans=(ans+solve(i+1,s,k-1,m,n))%mod;\\n            }\\n        }\\n        return dp[index][k]=ans;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof(dp)); \\n        int n=s.size();\\n        \\n        return solve(0,s,k,minLength,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836098,
                "title": "c-beats-100-both-memory-and-time-o-nk-tc-o-n-sc",
                "content": "![\\u622A\\u5C4F2022-11-21 21.18.50.png](https://assets.leetcode.com/users/images/63223a14-00af-44eb-92be-a19c6e06a115_1669036782.5973449.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\times k)$$ ->\\n`n` is the length of string `s`.\\n`k` is the value of variable `k`.\\n\\n- Space complexity:\\n$$O(n)$$ ->\\n`n` is the length of string `s`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int beautifulPartitions(const string& s, const int k, const int minLength) {\\n        static const vector<bool> prime = {false, false, true, true, false, true, false, true, false, false};\\n        const int n = size(s);\\n        if (n < k * minLength || !prime[s[0] - \\'0\\'] || prime[s.back() - \\'0\\'])\\n            return 0;\\n        vector<int> dp(n + 1), dp2(n + 1);\\n        dp.back() = 1;\\n        for (int j = 0; j < k; ++j) {\\n            for (int i = n - j * minLength, a = 0, i_end = (k - j) * minLength; i >= i_end; dp[i--] = 0) {\\n                if (!prime[s[i - 1] - \\'0\\'] && (n == i || prime[s[i] - \\'0\\']))\\n                    a = (a + dp[i]) % 1000000007;\\n                dp2[i - minLength] = a;\\n            }\\n            swap(dp, dp2);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int beautifulPartitions(const string& s, const int k, const int minLength) {\\n        static const vector<bool> prime = {false, false, true, true, false, true, false, true, false, false};\\n        const int n = size(s);\\n        if (n < k * minLength || !prime[s[0] - \\'0\\'] || prime[s.back() - \\'0\\'])\\n            return 0;\\n        vector<int> dp(n + 1), dp2(n + 1);\\n        dp.back() = 1;\\n        for (int j = 0; j < k; ++j) {\\n            for (int i = n - j * minLength, a = 0, i_end = (k - j) * minLength; i >= i_end; dp[i--] = 0) {\\n                if (!prime[s[i - 1] - \\'0\\'] && (n == i || prime[s[i] - \\'0\\']))\\n                    a = (a + dp[i]) % 1000000007;\\n                dp2[i - minLength] = a;\\n            }\\n            swap(dp, dp2);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835831,
                "title": "o-n-k-c",
                "content": "\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    bool Prime(char c){\\n        int n = c-\\'0\\';\\n        if(n == 2 || n == 3 || n == 5 || n==7) return true;\\n        return false;\\n    }\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if(!Prime(s[0]) || Prime(s[s.size()-1])) return 0;\\n\\n        int n = s.size();\\n        vector<vector<int>> dp(k+1, vector<int>(n, 0));\\n\\n        for(int i=1*minLength-1; i<n; i++){\\n            if(!Prime(s[i])){\\n                if(i == n-1 || Prime(s[i+1])) dp[1][i] = 1;\\n            } \\n        }\\n\\n        vector<int> helper(n, 0);\\n        for(int i=1; i<n; i++){\\n            helper[i] = (helper[i-1]%mod + dp[1][i]%mod)%mod;\\n        }\\n  \\n        for(int i=2; i<k+1; i++){\\n            for(int j = (i*minLength)-1; j<n; j++){\\n                if(Prime(s[j])) continue;\\n                if(j < n-1 && !Prime(s[j+1])) continue;\\n\\n                int start = j-minLength+1;\\n                dp[i][j] = helper[start-1];\\n\\n            }\\n            for(int &j:helper) j = 0;\\n            for(int j=(i*minLength-1); j<n; j++){\\n                helper[j] = (helper[j-1]%mod+dp[i][j]%mod)%mod;\\n            }\\n        }\\n        \\n        return dp[k][n-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    bool Prime(char c){\\n        int n = c-\\'0\\';\\n        if(n == 2 || n == 3 || n == 5 || n==7) return true;\\n        return false;\\n    }\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if(!Prime(s[0]) || Prime(s[s.size()-1])) return 0;\\n\\n        int n = s.size();\\n        vector<vector<int>> dp(k+1, vector<int>(n, 0));\\n\\n        for(int i=1*minLength-1; i<n; i++){\\n            if(!Prime(s[i])){\\n                if(i == n-1 || Prime(s[i+1])) dp[1][i] = 1;\\n            } \\n        }\\n\\n        vector<int> helper(n, 0);\\n        for(int i=1; i<n; i++){\\n            helper[i] = (helper[i-1]%mod + dp[1][i]%mod)%mod;\\n        }\\n  \\n        for(int i=2; i<k+1; i++){\\n            for(int j = (i*minLength)-1; j<n; j++){\\n                if(Prime(s[j])) continue;\\n                if(j < n-1 && !Prime(s[j+1])) continue;\\n\\n                int start = j-minLength+1;\\n                dp[i][j] = helper[start-1];\\n\\n            }\\n            for(int &j:helper) j = 0;\\n            for(int j=(i*minLength-1); j<n; j++){\\n                helper[j] = (helper[j-1]%mod+dp[i][j]%mod)%mod;\\n            }\\n        }\\n        \\n        return dp[k][n-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835667,
                "title": "optimized-memoization-c",
                "content": "```\\n#define ll long long\\n#define mod 1000000007\\n\\nint dp[1000][1000] = {};\\n\\nclass Solution {\\npublic:\\n    \\n    bool isPrime(char& ch){\\n        if(ch==\\'2\\' || ch==\\'3\\' || ch==\\'5\\' || ch==\\'7\\') return true;\\n        return false;\\n    }\\n    \\n    int helper(string& s,int idx, int k, int minLength){\\n        if(k==0){\\n            return s.size()>=idx;\\n        }\\n        \\n        if(idx+(k*minLength)>s.size()) return 0;\\n        \\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        \\n        dp[idx][k]=0;\\n        dp[idx][k]=helper(s,idx+1,k,minLength);\\n        if(isPrime(s[idx]) && !isPrime(s[idx-1])){\\n            dp[idx][k]= (dp[idx][k]+helper(s,idx+minLength,k-1,minLength))%mod;\\n        }\\n        \\n        return dp[idx][k];\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if(!isPrime(s[0]) || isPrime(s.back())) return 0;\\n        memset(dp,-1,sizeof(dp));\\n        int ans = helper(s,minLength,k-1,minLength)%mod;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n#define mod 1000000007\\n\\nint dp[1000][1000] = {};\\n\\nclass Solution {\\npublic:\\n    \\n    bool isPrime(char& ch){\\n        if(ch==\\'2\\' || ch==\\'3\\' || ch==\\'5\\' || ch==\\'7\\') return true;\\n        return false;\\n    }\\n    \\n    int helper(string& s,int idx, int k, int minLength){\\n        if(k==0){\\n            return s.size()>=idx;\\n        }\\n        \\n        if(idx+(k*minLength)>s.size()) return 0;\\n        \\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        \\n        dp[idx][k]=0;\\n        dp[idx][k]=helper(s,idx+1,k,minLength);\\n        if(isPrime(s[idx]) && !isPrime(s[idx-1])){\\n            dp[idx][k]= (dp[idx][k]+helper(s,idx+minLength,k-1,minLength))%mod;\\n        }\\n        \\n        return dp[idx][k];\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if(!isPrime(s[0]) || isPrime(s.back())) return 0;\\n        memset(dp,-1,sizeof(dp));\\n        int ans = helper(s,minLength,k-1,minLength)%mod;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835651,
                "title": "python3-o-nk-beat-100-dp-and-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first glacne, it is a dp problem. there are dp[i][k] ways to partial string s[:i] into k parts. To get dp[i][k], we need to sum all dp[j][k - 1] where j + minLengh <= i. A naive solution will result in O(n^2k) solution. We notice that with patial k, we iterate i from begin to end, j is a contiue increasing array. We use a deque to check all j, once the head of deque out the minLengh bound, we can add dp[j][k - 1] to current acc value. In this way, the time complexity decrese to (nk). With dp space optimizing, the space can furter decrese to O(n).\\n\\n\\n# Code\\ntime O(nk), space O(nk)\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def beautifulPartitions(self, s: str, K: int, minLength: int) -> int:\\n        def isprime(d): return d in {\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n        if not isprime(s[0]) or isprime(s[-1]): return 0\\n        dp, partials, MOD = [[0] * K for _ in range(len(s))], [], 10 ** 9 + 7\\n        for i in range(minLength - 1, len(s)):\\n            if not isprime(s[i]):\\n                dp[i][0] = 1\\n                if i == len(s) - 1 or i < len(s) - 1 and isprime(s[i + 1]): partials.append(i)\\n        for k in range(1, K):\\n            acc, last = 0, deque()\\n            for i in partials:\\n                while last and last[0] + minLength <= i: acc += dp[last.popleft()][k - 1]\\n                acc %= MOD\\n                dp[i][k] = acc\\n                last.append(i)\\n        return dp[-1][K - 1]\\n```\\n\\ntime O(nk), space O(n)\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def beautifulPartitions(self, s: str, K: int, minLength: int) -> int:\\n        def isprime(d): return d in {\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n        if not isprime(s[0]) or isprime(s[-1]): return 0\\n        dp, partials, MOD = [[0] * len(s) for _ in range(2)], [], 10 ** 9 + 7\\n        for i in range(minLength - 1, len(s)):\\n            if not isprime(s[i]):\\n                dp[0][i] = 1\\n                if i == len(s) - 1 or i < len(s) - 1 and isprime(s[i + 1]): partials.append(i)\\n        for k in range(1, K):\\n            dp[k & 1] = [0] * len(s)\\n            acc, last = 0, deque()\\n            for i in partials:\\n                while last and last[0] + minLength <= i: acc += dp[(k - 1) & 1][last.popleft()]\\n                acc %= MOD\\n                dp[k & 1][i] = acc\\n                last.append(i)\\n        return dp[(K - 1) & 1][-1]\\n```\\n\\nHere is my O(n^2k) DP(TLE):\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        def isprime(d): return d in {\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n        if not isprime(s[0]) or isprime(s[-1]): return 0\\n        primes, partials = [isprime(d) for d in s], [[] for _ in range(len(s))]\\n        for i in range(1, len(s)):\\n            if not primes[i] or primes[i - 1]: continue\\n            for j in range(i + minLength - 1, len(s)):\\n                if not primes[j]: partials[j].append(i - 1)\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if k == 1: return 1\\n            ret, MOD = 0, 10 ** 9 + 7\\n            for j in reversed(partials[i]):\\n                if j + 1 < (k - 1) * minLength: break\\n                ret = ret + dp(j, k - 1)\\n            return ret  % MOD\\n        return dp(len(s) - 1, k)\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def beautifulPartitions(self, s: str, K: int, minLength: int) -> int:\\n        def isprime(d): return d in {\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n        if not isprime(s[0]) or isprime(s[-1]): return 0\\n        dp, partials, MOD = [[0] * K for _ in range(len(s))], [], 10 ** 9 + 7\\n        for i in range(minLength - 1, len(s)):\\n            if not isprime(s[i]):\\n                dp[i][0] = 1\\n                if i == len(s) - 1 or i < len(s) - 1 and isprime(s[i + 1]): partials.append(i)\\n        for k in range(1, K):\\n            acc, last = 0, deque()\\n            for i in partials:\\n                while last and last[0] + minLength <= i: acc += dp[last.popleft()][k - 1]\\n                acc %= MOD\\n                dp[i][k] = acc\\n                last.append(i)\\n        return dp[-1][K - 1]\\n```\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def beautifulPartitions(self, s: str, K: int, minLength: int) -> int:\\n        def isprime(d): return d in {\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n        if not isprime(s[0]) or isprime(s[-1]): return 0\\n        dp, partials, MOD = [[0] * len(s) for _ in range(2)], [], 10 ** 9 + 7\\n        for i in range(minLength - 1, len(s)):\\n            if not isprime(s[i]):\\n                dp[0][i] = 1\\n                if i == len(s) - 1 or i < len(s) - 1 and isprime(s[i + 1]): partials.append(i)\\n        for k in range(1, K):\\n            dp[k & 1] = [0] * len(s)\\n            acc, last = 0, deque()\\n            for i in partials:\\n                while last and last[0] + minLength <= i: acc += dp[(k - 1) & 1][last.popleft()]\\n                acc %= MOD\\n                dp[k & 1][i] = acc\\n                last.append(i)\\n        return dp[(K - 1) & 1][-1]\\n```\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        def isprime(d): return d in {\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n        if not isprime(s[0]) or isprime(s[-1]): return 0\\n        primes, partials = [isprime(d) for d in s], [[] for _ in range(len(s))]\\n        for i in range(1, len(s)):\\n            if not primes[i] or primes[i - 1]: continue\\n            for j in range(i + minLength - 1, len(s)):\\n                if not primes[j]: partials[j].append(i - 1)\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if k == 1: return 1\\n            ret, MOD = 0, 10 ** 9 + 7\\n            for j in reversed(partials[i]):\\n                if j + 1 < (k - 1) * minLength: break\\n                ret = ret + dp(j, k - 1)\\n            return ret  % MOD\\n        return dp(len(s) - 1, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835340,
                "title": "my-python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n, primes, mod = len(s), set(\\'2357\\'), (10 ** 9) + 7\\n        @cache\\n        def dp(i, at_start, k):\\n            if i == n: return int(k == 0)\\n            if i > n or k == 0 or s[i] not in primes and at_start: return 0\\n            if s[i] in primes:\\n                if at_start: return dp(i + minLength - 1, False, k)\\n                else: return dp(i + 1, False, k)\\n            return (dp(i + 1, True, k - 1) + dp(i + 1, False, k)) % mod\\n        return dp(0, True, k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n, primes, mod = len(s), set(\\'2357\\'), (10 ** 9) + 7\\n        @cache\\n        def dp(i, at_start, k):\\n            if i == n: return int(k == 0)\\n            if i > n or k == 0 or s[i] not in primes and at_start: return 0\\n            if s[i] in primes:\\n                if at_start: return dp(i + minLength - 1, False, k)\\n                else: return dp(i + 1, False, k)\\n            return (dp(i + 1, True, k - 1) + dp(i + 1, False, k)) % mod\\n        return dp(0, True, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835170,
                "title": "dp-python-simple",
                "content": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        sp={\"2\",\"3\",\"5\",\"7\"}\\n        if s[-1] in sp or s[0] not in sp:return 0\\n        @cache\\n        def dp(i,ok,ml):\\n            if i>=len(s) and ok<=0 and ml<=0:return 1\\n            if i>=len(s):return 0\\n            a=dp(i+1,ok,ml-1 if ml>=1 else 0)\\n            if ml<=0  and s[i] in sp and s[i-1] not in sp and ok > 0:\\n                a+=dp(i+1,ok-1,minLength-1)\\n            return a%((10**9)+7)\\n        return dp(0,k-1,minLength)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        sp={\"2\",\"3\",\"5\",\"7\"}\\n        if s[-1] in sp or s[0] not in sp:return 0\\n        @cache\\n        def dp(i,ok,ml):\\n            if i>=len(s) and ok<=0 and ml<=0:return 1\\n            if i>=len(s):return 0\\n            a=dp(i+1,ok,ml-1 if ml>=1 else 0)\\n            if ml<=0  and s[i] in sp and s[i-1] not in sp and ok > 0:\\n                a+=dp(i+1,ok-1,minLength-1)\\n            return a%((10**9)+7)\\n        return dp(0,k-1,minLength)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834900,
                "title": "dp-and-prefix-sum-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int K, int minLength) {\\n        int n = s.size();\\n        if (!IsPrime(s[0]) || IsPrime(s[n - 1])) {\\n            return 0;\\n        }\\n        vector<int> dp(n, 0);\\n        vector<int> DP(n, 0);\\n        for (int k = 1; k <= K; ++k) {\\n            fill(begin(dp), end(dp), 0);\\n            if (k == 1) {\\n                for (int i = 0; i < n; ++i) {\\n                    if (IsGoodEnd(s, i) && i + 1 >= minLength) {\\n                        dp[i] = 1;\\n                    }\\n                }\\n            } else {\\n                for (int i = 0; i < n; ++i) {\\n                    if (IsGoodEnd(s, i) && i >= minLength) {\\n                        dp[i] = DP[i - minLength];\\n                    }\\n                }\\n            }\\n            for (int i = 0; i < n; ++i) {\\n                DP[i] = (0L + dp[i] + (i ? DP[i - 1] : 0)) % int(1e9 + 7);\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n\\nprivate:\\n    bool IsPrime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n    bool IsGoodEnd(string& s, int i) {\\n        int n = s.size();\\n        if (i == 0) {\\n            return false;\\n        }\\n        if (i == n - 1) {\\n            return !IsPrime(s[i]);\\n        }\\n        return !IsPrime(s[i]) && IsPrime(s[i + 1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int K, int minLength) {\\n        int n = s.size();\\n        if (!IsPrime(s[0]) || IsPrime(s[n - 1])) {\\n            return 0;\\n        }\\n        vector<int> dp(n, 0);\\n        vector<int> DP(n, 0);\\n        for (int k = 1; k <= K; ++k) {\\n            fill(begin(dp), end(dp), 0);\\n            if (k == 1) {\\n                for (int i = 0; i < n; ++i) {\\n                    if (IsGoodEnd(s, i) && i + 1 >= minLength) {\\n                        dp[i] = 1;\\n                    }\\n                }\\n            } else {\\n                for (int i = 0; i < n; ++i) {\\n                    if (IsGoodEnd(s, i) && i >= minLength) {\\n                        dp[i] = DP[i - minLength];\\n                    }\\n                }\\n            }\\n            for (int i = 0; i < n; ++i) {\\n                DP[i] = (0L + dp[i] + (i ? DP[i - 1] : 0)) % int(1e9 + 7);\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n\\nprivate:\\n    bool IsPrime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n    bool IsGoodEnd(string& s, int i) {\\n        int n = s.size();\\n        if (i == 0) {\\n            return false;\\n        }\\n        if (i == n - 1) {\\n            return !IsPrime(s[i]);\\n        }\\n        return !IsPrime(s[i]) && IsPrime(s[i + 1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834774,
                "title": "python3-o-nk-time-adding-isactive-parameter-to-dp-works-like-charm",
                "content": "dp(i,k) means partition the subarray i~n into k parts. dp(0,k) is the final result.\\ni is the start point of subarray, inside dp, we will need to try all i~n to find the the endpoint j of subarray, and from j+1 do a new dp.\\nThis approach costs O(n\\\\*n\\\\*k) time: the 2 input parameters of dp takes O(n\\\\*k) time, plus the O(n) time loop inside dp, totally O(n\\\\*n\\\\*k) time. \\nLeetcode maximum tolerance is roughly O(50 million) time. We are likely getting TLE with this approach.\\n\\nThe key part is how to remove the O(n) loop inside of DP.\\nWe introduce a new parameter \"**isActive**\" to dp: dp(i,k,**isActive**)\\n**isActive**==True means current subarray is still extending and not closed yet. We do not count it. In this case, we can either choose to close the current subarray, cout it, and start a new subarray on i+1. Or choose to not close current subarray and keep extending it to i+1.\\n**isActive**==False means current subarray is already closed and counted, we must immediately startup a new subarray at i.\\nEither way, dp will move i+1 forward, no loop inside of dp. Time complexity depend only on dp input parameters, which is O(n\\\\*k\\\\*2) \\n\\n**Python3**\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        primes = \\'2357\\'\\n        if s[0] not in primes or s[-1] in primes:\\n            return 0\\n        @cache\\n        def dp(i,k,isActive):\\n            if k<0:\\n                return 0\\n            if i>=len(s):\\n                return k==0 and isActive==False\\n            if isActive==False:\\n                if s[i] not in primes:\\n                    return 0\\n                return dp(i+minLength-1,k,True)\\n            elif isActive == True:\\n                res = dp(i+1,k,True) # keep extending cur subarray\\n                if s[i] not in primes: # or end cur subarray\\n                    res += dp(i+1,k-1,False)\\n            return res % (10**9+7)\\n        return dp(0,k,False)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        primes = \\'2357\\'\\n        if s[0] not in primes or s[-1] in primes:\\n            return 0\\n        @cache\\n        def dp(i,k,isActive):\\n            if k<0:\\n                return 0\\n            if i>=len(s):\\n                return k==0 and isActive==False\\n            if isActive==False:\\n                if s[i] not in primes:\\n                    return 0\\n                return dp(i+minLength-1,k,True)\\n            elif isActive == True:\\n                res = dp(i+1,k,True) # keep extending cur subarray\\n                if s[i] not in primes: # or end cur subarray\\n                    res += dp(i+1,k-1,False)\\n            return res % (10**9+7)\\n        return dp(0,k,False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834587,
                "title": "c-explained-both-approaches-o-nk-and-o-n-n-k-dp",
                "content": "First discussing the O(n * n * k) approach.\\n\\nTo find: total number of ways of partitioning the string so that each partition starts with prime digit ends in non-prime digit and is atleast *minLength* long in length.\\n\\nAssuming we have information about dp[i][k] - > this indicates the number of ways in which I can split the string starting at position i into k valid segments. If we have this information for all i in 0 -> n-1 and k then we can get the value of dp[i][k+1] that is the next state.\\n\\nHow?\\nwhen calculating dp[i][k], it is sufficient to do\\n\\n\\nj = i + minLength (we see if i to j-1 can be a segment and then use the value of dp[j][k-1] to get the number of ways)\\n```\\nALGO:\\nfor(int j = i + minLength; j<=n-1; j++)\\n{\\n\\t// if i to j-1 can be a segment, check the constraints\\n\\tif( str[j-1] is composite AND str[j] is prime)\\n\\t{\\n\\t\\t// then i to j-1 can form a segment NOTE: minLength is already checked since j starts from i + minLength\\n\\t\\tdp[i][k] += dp[j][k-1];\\n\\t}\\n}\\n// This forms the crux of O(n*n*k) approach\\n// the entire operation has to be repeated for all i in range(0 -> n-1)\\n```\\n\\n\\nNow, to optimise, taking an example:\\n\\nsuppose, we are populating dp[0][3], at this point dp is populated for all values of k = 2.\\n\\nwe would run a loop as stated in above ALGO\\nand for all positions of j satisfying the constraints the value of dp[0][3] += dp[j][2].\\n\\nlet\\'s say that the values of j that satisfied were\\n\\nj = 3, 5, 9.\\n\\nthen dp[0][3] = dp[3][2] + dp[5][2] + dp[9][2];\\n\\nwhat if we had a suffixSum of all the dp states from the previous value of k, then as soon as the first value of j satisfying the constraint was found, we could have added the suffix value at that point because suffix[3] = suffix[3] + suffix[5] + suffix[9].\\n\\nThis forms the crux of O(n * k) approach, before populating the next state of dp we get a suffix sum\\n\\nCODE:\\n```\\nstatic const int mod = 1e9 + 7;\\nbool isPrime(char ch)\\n{\\n\\tif(ch == \\'2\\' || ch==\\'3\\' || ch==\\'5\\' || ch==\\'7\\')\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n\\n\\n// dp[i][k] indicates the number of ways we can split string starting at i if we \\n// have to make k cuts, or need to have k + 1 partitions of the string.\\nvoid getAnswer(string s, int k ,int minLength, int dp[1001][1001])\\n{\\n\\tint n = s.size();\\n\\tminLength = max(2, minLength); //minLength of 1 cannot yield anything \\n\\tdp[0][0] = 1;  // since we have already checked the failing case for s[0] non-prime or s[n-1] being prime, dp[0][0] at this point is always 1, that is if we are not to make any cuts to the string, the entire string is a valid string.\\n\\tfor(int i = 1; i<=n-1; i++)\\n\\t{\\n\\t\\t// just check if string starting from i is valid or not\\n\\t\\t// but since its part of string checking i - 1 is necessary\\n\\t\\tif(!isPrime(s[i-1]) && isPrime(s[i]) && n-i >= minLength)\\n\\t\\t\\tdp[i][0] = 1;\\n\\t}\\n\\n\\t// running for other values of k\\n\\tfor(int c = 1; c<=k; c++)\\n\\t{\\n\\t\\tvector<int> suffix(n, 0);\\n\\t\\tsuffix[n-1] = dp[n-1][c-1];\\n\\t\\t// store the suffix sum of last dp state i.e k - 1\\n\\t\\tfor(int i = n-2; i>=0; i--)\\n\\t\\t\\tsuffix[i] = (dp[i][c-1] % mod + suffix[i+1] % mod ) % mod;\\n\\t\\t\\t\\n\\t\\t// now populate dp[i][k] - string starting at i \\n\\t\\tfor(int i = 0; i<=n-1; i++)\\n\\t\\t{\\n\\t\\t\\t// s[i] should be prime and the last index should be non-prime\\n\\t\\t\\t// else the dp[i][k] is 0 cuz this segment will be invalid\\n\\t\\t\\tif(!isPrime(s[i]) || (i>=1 && isPrime(s[i-1])))\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i][c] = 0;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tint j = i + minLength;\\n\\t\\t\\t// find first index j which satisfies constraints, \\n\\t\\t\\t// index j should be prime j - 1 should be non-prime\\n\\t\\t\\t// and i to j-1 length >= minLength\\n\\t\\t\\tfor(; j<=n-1; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!isPrime(s[j - 1]) && isPrime(s[j]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// first satisfying index of j found here\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(j<=n-1)\\n\\t\\t\\t\\tdp[i][c] = suffix[j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[i][c] = 0;\\n\\t\\t}\\n\\t}\\n}\\n        \\nint beautifulPartitions(string s, int k, int minLength) {\\n\\n\\tint dp[1001][1001];\\n\\tmemset(dp, 0, sizeof(dp));\\n\\tint n = s.size();\\n\\t\\n\\t// checking if the string in itself is valid, NOTE: no need to check length condition, since minLength <= s.size() \\n\\t// in question constraints\\n\\tif(!isPrime(s[0]) || isPrime(s[n-1]))\\n\\t\\treturn 0;\\n\\t\\n\\t// in order to get k segments we need k-1 cuts.\\n\\tgetAnswer(s, k-1, minLength, dp);\\n\\t\\n\\t// return number of ways string starting at 0 can be cut in k-1 positions or k segments\\n\\treturn dp[0][k-1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nALGO:\\nfor(int j = i + minLength; j<=n-1; j++)\\n{\\n\\t// if i to j-1 can be a segment, check the constraints\\n\\tif( str[j-1] is composite AND str[j] is prime)\\n\\t{\\n\\t\\t// then i to j-1 can form a segment NOTE: minLength is already checked since j starts from i + minLength\\n\\t\\tdp[i][k] += dp[j][k-1];\\n\\t}\\n}\\n// This forms the crux of O(n*n*k) approach\\n// the entire operation has to be repeated for all i in range(0 -> n-1)\\n```\n```\\nstatic const int mod = 1e9 + 7;\\nbool isPrime(char ch)\\n{\\n\\tif(ch == \\'2\\' || ch==\\'3\\' || ch==\\'5\\' || ch==\\'7\\')\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n\\n\\n// dp[i][k] indicates the number of ways we can split string starting at i if we \\n// have to make k cuts, or need to have k + 1 partitions of the string.\\nvoid getAnswer(string s, int k ,int minLength, int dp[1001][1001])\\n{\\n\\tint n = s.size();\\n\\tminLength = max(2, minLength); //minLength of 1 cannot yield anything \\n\\tdp[0][0] = 1;  // since we have already checked the failing case for s[0] non-prime or s[n-1] being prime, dp[0][0] at this point is always 1, that is if we are not to make any cuts to the string, the entire string is a valid string.\\n\\tfor(int i = 1; i<=n-1; i++)\\n\\t{\\n\\t\\t// just check if string starting from i is valid or not\\n\\t\\t// but since its part of string checking i - 1 is necessary\\n\\t\\tif(!isPrime(s[i-1]) && isPrime(s[i]) && n-i >= minLength)\\n\\t\\t\\tdp[i][0] = 1;\\n\\t}\\n\\n\\t// running for other values of k\\n\\tfor(int c = 1; c<=k; c++)\\n\\t{\\n\\t\\tvector<int> suffix(n, 0);\\n\\t\\tsuffix[n-1] = dp[n-1][c-1];\\n\\t\\t// store the suffix sum of last dp state i.e k - 1\\n\\t\\tfor(int i = n-2; i>=0; i--)\\n\\t\\t\\tsuffix[i] = (dp[i][c-1] % mod + suffix[i+1] % mod ) % mod;\\n\\t\\t\\t\\n\\t\\t// now populate dp[i][k] - string starting at i \\n\\t\\tfor(int i = 0; i<=n-1; i++)\\n\\t\\t{\\n\\t\\t\\t// s[i] should be prime and the last index should be non-prime\\n\\t\\t\\t// else the dp[i][k] is 0 cuz this segment will be invalid\\n\\t\\t\\tif(!isPrime(s[i]) || (i>=1 && isPrime(s[i-1])))\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i][c] = 0;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tint j = i + minLength;\\n\\t\\t\\t// find first index j which satisfies constraints, \\n\\t\\t\\t// index j should be prime j - 1 should be non-prime\\n\\t\\t\\t// and i to j-1 length >= minLength\\n\\t\\t\\tfor(; j<=n-1; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!isPrime(s[j - 1]) && isPrime(s[j]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// first satisfying index of j found here\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(j<=n-1)\\n\\t\\t\\t\\tdp[i][c] = suffix[j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[i][c] = 0;\\n\\t\\t}\\n\\t}\\n}\\n        \\nint beautifulPartitions(string s, int k, int minLength) {\\n\\n\\tint dp[1001][1001];\\n\\tmemset(dp, 0, sizeof(dp));\\n\\tint n = s.size();\\n\\t\\n\\t// checking if the string in itself is valid, NOTE: no need to check length condition, since minLength <= s.size() \\n\\t// in question constraints\\n\\tif(!isPrime(s[0]) || isPrime(s[n-1]))\\n\\t\\treturn 0;\\n\\t\\n\\t// in order to get k segments we need k-1 cuts.\\n\\tgetAnswer(s, k-1, minLength, dp);\\n\\t\\n\\t// return number of ways string starting at 0 can be cut in k-1 positions or k segments\\n\\treturn dp[0][k-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2834492,
                "title": "python3-dp",
                "content": "class Solution:\\n\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        Primes = {2,3,5,7}\\n        \\n        def isPrime(x):\\n            if x in Primes:\\n                return True\\n            return False\\n        \\n        if not isPrime(int(s[0])) or isPrime(int(s[-1])):\\n            return 0\\n        \\n        startPoints = [0]\\n        for i in range(1,len(s)-1):\\n            if not isPrime(int(s[i])) and isPrime(int(s[i+1])):\\n                startPoints.append(i+1)\\n                \\n        if len(startPoints)<k:\\n            return 0\\n        startPoints.append(len(s))\\n        \\n        res = 0\\n        n = len(startPoints)\\n        N = n-1\\n        MOD = 10**9+7\\n        \\n        @lru_cache(None)\\n        def Helper(idx,k):\\n            if idx == N and k == 0:\\n                return 1\\n            if idx == N or k == 0:\\n                return 0\\n            res = 0\\n            for i in range(idx+1,n-k+1):\\n                if startPoints[i]-startPoints[idx]<minLength:\\n                    continue\\n                res = (res + Helper(i,k-1))%MOD\\n            return res \\n                \\n        return Helper(0,k)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        Primes = {2,3,5,7}",
                "codeTag": "Java"
            },
            {
                "id": 2834447,
                "title": "c-dp",
                "content": "`dp[i][k]` is the number of possible k-partitions ending at index i\\n```\\nclass Solution {\\npublic:\\n  bool isPrime(int d) {\\n    return d == 2 || d == 3 || d == 5 || d == 7;\\n  }\\n  \\n  bool isPrimeC(char c) {\\n    return isPrime(c - \\'0\\');\\n  }\\n  \\n  int beautifulPartitions(string s, int K, int minDistance) {\\n    int n = s.size();\\n    long mod = 1000000007;\\n    \\n    vector<vector<long>> dp(n, vector<long>(K + 1, 0));\\n    int lastComposite = -1;\\n    for (int i = 0; i < n; ++i) {\\n      for (int k = 1; k <= K; ++k) {\\n        if (isPrimeC(s[i])) continue;\\n        if (lastComposite >= 0) {\\n          dp[i][k] = dp[lastComposite][k];\\n        }\\n        // Cover all prime numbers not covered by the last composite.\\n        for (int j = 1 + (1 + lastComposite - minDistance);\\n             (1 + i - j) >= minDistance; ++j) {\\n          if (j < 0) continue;\\n          if (!isPrimeC(s[j])) continue;\\n          if (j == 0 && k == 1) {\\n            dp[i][k] += 1;\\n            dp[i][k] %= mod;\\n          } else if ((j - 1) >= 0) {\\n            dp[i][k] += dp[j - 1][k - 1];\\n            dp[i][k] %= mod;\\n          }\\n        }\\n      }\\n      if (!isPrimeC(s[i])) lastComposite = i;\\n    }\\n    \\n    return dp[n - 1][K];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  bool isPrime(int d) {\\n    return d == 2 || d == 3 || d == 5 || d == 7;\\n  }\\n  \\n  bool isPrimeC(char c) {\\n    return isPrime(c - \\'0\\');\\n  }\\n  \\n  int beautifulPartitions(string s, int K, int minDistance) {\\n    int n = s.size();\\n    long mod = 1000000007;\\n    \\n    vector<vector<long>> dp(n, vector<long>(K + 1, 0));\\n    int lastComposite = -1;\\n    for (int i = 0; i < n; ++i) {\\n      for (int k = 1; k <= K; ++k) {\\n        if (isPrimeC(s[i])) continue;\\n        if (lastComposite >= 0) {\\n          dp[i][k] = dp[lastComposite][k];\\n        }\\n        // Cover all prime numbers not covered by the last composite.\\n        for (int j = 1 + (1 + lastComposite - minDistance);\\n             (1 + i - j) >= minDistance; ++j) {\\n          if (j < 0) continue;\\n          if (!isPrimeC(s[j])) continue;\\n          if (j == 0 && k == 1) {\\n            dp[i][k] += 1;\\n            dp[i][k] %= mod;\\n          } else if ((j - 1) >= 0) {\\n            dp[i][k] += dp[j - 1][k - 1];\\n            dp[i][k] %= mod;\\n          }\\n        }\\n      }\\n      if (!isPrimeC(s[i])) lastComposite = i;\\n    }\\n    \\n    return dp[n - 1][K];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834380,
                "title": "c-26ms-100-dp-solution",
                "content": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n#define rep(i, aa, bb) for(int i = (aa); i <= (bb); i++)\\n#define repv(i, aa, bb) for(int i = (aa); i >= (bb); i--)\\n#define MAX(...) max({__VA_ARGS__})\\n\\ntypedef unsigned long long ULL;\\ntypedef long long LL;\\ntypedef pair<int, int> PII;\\ntypedef pair<string, int> PSI;\\n\\nclass Solution {\\npublic:\\n\\n    int mod = (int)1e9+7;\\n\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int dp[1010][1010];\\n        int tot[1010];\\n        unordered_set<char> st;\\n        queue<int> q;\\n        int n = s.size();\\n        st.insert(\\'2\\');\\n        st.insert(\\'3\\');\\n        st.insert(\\'5\\');\\n        st.insert(\\'7\\');\\n        if (st.count(s[0]) == 0 || st.count(s[n-1]) != 0) return 0;\\n        memset(dp, 0, sizeof dp);\\n        memset(tot, 0, sizeof tot);\\n        tot[0] = 1;\\n        repv(i, n-minLength, 0) {\\n            if (q.size() > 0 && q.front() == i+minLength) {\\n                int nxt = q.front();\\n                q.pop();\\n                rep(j, 1, k) {\\n                    if (dp[nxt][j] == 0) break;\\n                    tot[j] += dp[nxt][j];\\n                    tot[j] %= mod;\\n                }\\n            }\\n            if (st.count(s[i]) != 0 && (i == 0 || st.count(s[i-1]) == 0)) {\\n                q.push(i);\\n                rep(j, 1, k) {\\n                    if (tot[j-1] == 0) break;\\n                    dp[i][j] = tot[j-1];\\n                }\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/3396cfe1-997b-4087-a2df-4110791adf41_1668978031.5912695.png)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n#define rep(i, aa, bb) for(int i = (aa); i <= (bb); i++)\\n#define repv(i, aa, bb) for(int i = (aa); i >= (bb); i--)\\n#define MAX(...) max({__VA_ARGS__})\\n\\ntypedef unsigned long long ULL;\\ntypedef long long LL;\\ntypedef pair<int, int> PII;\\ntypedef pair<string, int> PSI;\\n\\nclass Solution {\\npublic:\\n\\n    int mod = (int)1e9+7;\\n\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int dp[1010][1010];\\n        int tot[1010];\\n        unordered_set<char> st;\\n        queue<int> q;\\n        int n = s.size();\\n        st.insert(\\'2\\');\\n        st.insert(\\'3\\');\\n        st.insert(\\'5\\');\\n        st.insert(\\'7\\');\\n        if (st.count(s[0]) == 0 || st.count(s[n-1]) != 0) return 0;\\n        memset(dp, 0, sizeof dp);\\n        memset(tot, 0, sizeof tot);\\n        tot[0] = 1;\\n        repv(i, n-minLength, 0) {\\n            if (q.size() > 0 && q.front() == i+minLength) {\\n                int nxt = q.front();\\n                q.pop();\\n                rep(j, 1, k) {\\n                    if (dp[nxt][j] == 0) break;\\n                    tot[j] += dp[nxt][j];\\n                    tot[j] %= mod;\\n                }\\n            }\\n            if (st.count(s[i]) != 0 && (i == 0 || st.count(s[i-1]) == 0)) {\\n                q.push(i);\\n                rep(j, 1, k) {\\n                    if (tot[j-1] == 0) break;\\n                    dp[i][j] = tot[j-1];\\n                }\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2834357,
                "title": "simple-dp-using-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n     int dp[1005][1005][2];\\n     int mod=1000000007;\\n     int rec(string & s ,int k,int ml, bool start,int idx,int st){\\n        \\n        if(k==0 && idx==s.length() && start) return 1;\\n        if(k<0 || idx>s.length()) return 0;\\n        if(dp[idx][k][start]!=-1) return dp[idx][k][start];\\n         \\n        long long z=0;long long l=0;long long r=0;\\n         \\n        if(start){\\n            if((s[idx]==\\'2\\'|| s[idx]==\\'3\\' || s[idx]==\\'5\\'|| s[idx]==\\'7\\'))\\n            z=rec(s,k,ml,false,idx+ml-1,st);\\n            z%=mod;\\n        }\\n         \\n        else{\\n            if(!(s[idx]==\\'2\\'|| s[idx]==\\'3\\' || s[idx]==\\'5\\'|| s[idx]==\\'7\\')) \\n             l=rec(s,k-1,ml,true,idx+1,idx);l%=mod;\\n             r=rec(s,k,ml,false,idx+1,st);l%=mod;\\n        }\\n         \\n            return dp[idx][k][start]=(z+l+r)%mod;\\n      }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp,-1,sizeof dp);\\n        \\n        return rec(s,k,minLength,true,0,-1);\\n    }\\n};\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n     int dp[1005][1005][2];\\n     int mod=1000000007;\\n     int rec(string & s ,int k,int ml, bool start,int idx,int st){\\n        \\n        if(k==0 && idx==s.length() && start) return 1;\\n        if(k<0 || idx>s.length()) return 0;\\n        if(dp[idx][k][start]!=-1) return dp[idx][k][start];\\n         \\n        long long z=0;long long l=0;long long r=0;\\n         \\n        if(start){\\n            if((s[idx]==\\'2\\'|| s[idx]==\\'3\\' || s[idx]==\\'5\\'|| s[idx]==\\'7\\'))\\n            z=rec(s,k,ml,false,idx+ml-1,st);\\n            z%=mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2834324,
                "title": "python3-bottom-up-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/5c8a821ed30357746d2547ce97888600f3208acc) for solutions of weekly 320. \\n\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        prime = \"2357\"\\n        dp = [[0]*(len(s)+1) for _ in range(k)]\\n        if s[0] in prime and s[-1] not in prime: \\n            for j in range(len(s)+1): dp[0][j] = 1\\n            for i in range(1, k): \\n                for j in range(len(s)-1, -1, -1): \\n                    dp[i][j] = dp[i][j+1]\\n                    if minLength <= j <= len(s)-minLength and s[j-1] not in prime and s[j] in prime: \\n                        dp[i][j] = (dp[i][j] + dp[i-1][j+minLength]) % 1_000_000_007\\n        return dp[-1][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        prime = \"2357\"\\n        dp = [[0]*(len(s)+1) for _ in range(k)]\\n        if s[0] in prime and s[-1] not in prime: \\n            for j in range(len(s)+1): dp[0][j] = 1\\n            for i in range(1, k): \\n                for j in range(len(s)-1, -1, -1): \\n                    dp[i][j] = dp[i][j+1]\\n                    if minLength <= j <= len(s)-minLength and s[j-1] not in prime and s[j] in prime: \\n                        dp[i][j] = (dp[i][j] + dp[i-1][j+minLength]) % 1_000_000_007\\n        return dp[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834197,
                "title": "c-dp-using-all-valid-start-of-partitions",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    bool isPrime(char c){\\n     \\n      return  (c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\');\\n    }\\n    int solve2(int ind,string &s,int k,vector<int>&valid,int ml,vector<vector<int>>&dp){\\n        if(k==0 && ind==valid.size()-1) return 1;\\n        if(k<=0 || ind==valid.size()-1) return 0;\\n        if(dp[ind][k]!=-1) return dp[ind][k];\\n        \\n        int ans=0;\\n        for(int i=ind+1;i<=valid.size()-k;i++){\\n            if(valid[i]-valid[ind]>=ml){\\n                ans=(ans+solve2(i,s,k-1,valid,ml,dp))%1000000007;\\n            }\\n            \\n        }\\n        return dp[ind][k]=ans;\\n        \\n    }\\n    int beautifulPartitions(string s, int k, int ml) {\\n        vector<int>valid;\\n      if(!isPrime(s[0]) || isPrime(s[s.size()-1])) return 0;\\n       valid.push_back(0);\\n        for(int ind=1;ind<s.size()-1;ind++){\\n            if((!isPrime(s[ind])) && (isPrime(s[ind+1])))\\n                 valid.push_back(ind+1);\\n        }\\n        if(valid.size()<k) return 0;\\n        valid.push_back(s.size());\\n        // for(auto it:valid) cout<<s[it]<<endl;\\n\\n        vector<vector<int>>dp(valid.size()+1,vector<int>(k+1,-1));\\n        return solve2(0,s,k,valid,ml,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    bool isPrime(char c){\\n     \\n      return  (c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\');\\n    }\\n    int solve2(int ind,string &s,int k,vector<int>&valid,int ml,vector<vector<int>>&dp){\\n        if(k==0 && ind==valid.size()-1) return 1;\\n        if(k<=0 || ind==valid.size()-1) return 0;\\n        if(dp[ind][k]!=-1) return dp[ind][k];\\n        \\n        int ans=0;\\n        for(int i=ind+1;i<=valid.size()-k;i++){\\n            if(valid[i]-valid[ind]>=ml){\\n                ans=(ans+solve2(i,s,k-1,valid,ml,dp))%1000000007;\\n            }\\n            \\n        }\\n        return dp[ind][k]=ans;\\n        \\n    }\\n    int beautifulPartitions(string s, int k, int ml) {\\n        vector<int>valid;\\n      if(!isPrime(s[0]) || isPrime(s[s.size()-1])) return 0;\\n       valid.push_back(0);\\n        for(int ind=1;ind<s.size()-1;ind++){\\n            if((!isPrime(s[ind])) && (isPrime(s[ind+1])))\\n                 valid.push_back(ind+1);\\n        }\\n        if(valid.size()<k) return 0;\\n        valid.push_back(s.size());\\n        // for(auto it:valid) cout<<s[it]<<endl;\\n\\n        vector<vector<int>>dp(valid.size()+1,vector<int>(k+1,-1));\\n        return solve2(0,s,k,valid,ml,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2834195,
                "title": "c-recursive-memo",
                "content": "# Intuition\\n\\n\\n# Approach\\n \\n\\n# Complexity\\n- Time complexity:\\n O(N*N*N)\\n\\n- Space complexity:\\n \\nO(N*K)\\n\\n# Code\\n```\\npublic class Solution {\\n    int M = (int)(1e9+7);\\n    HashSet<char> Prime = new (){\\'2\\',\\'3\\',\\'5\\',\\'7\\'};\\n    int[,] DP;\\n    \\n    public int BeautifulPartitions(string s, int k, int minLength) {\\n        int res = 0;\\n        if(!Prime.Contains(s[0]) || s.Length<k*minLength || Prime.Contains(s[s.Length-1])) return 0;\\n        DP = new int[s.Length,k+1];\\n        for(int i=0;i<s.Length;i++)\\n        {\\n            for(int j=0;j<k+1;j++)\\n            {\\n                DP[i,j] = -1;\\n            }\\n            DP[i,0] = 0;\\n        }\\n        return B(s,0,k,minLength);\\n    }\\n    \\n    private int B(string s, int start, int k, int m)\\n    {\\n        if(DP[start,k]==-1)\\n        {\\n           \\n        if(s.Length-start<k*m)\\n        {\\n            DP[start,k] = 0;\\n        }\\n        else if(k==1)\\n        {\\n            DP[start,k] = 1;\\n        } \\n        else\\n        {\\n        int sl = (k-1) * m;\\n        int res = 0;\\n        for(int i=m-1; i<s.Length-sl-start; i++)\\n        {\\n            if(start+i+1>=s.Length)\\n                break;\\n            if(!Prime.Contains(s[start+i]) && Prime.Contains(s[start+i+1]))\\n            {\\n                res += (B(s,start+i+1,k-1,m) % M);\\n                res = res % M;\\n            }\\n        }\\n             DP[start,k] = res;\\n        }\\n        }\\n        return DP[start,k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int M = (int)(1e9+7);\\n    HashSet<char> Prime = new (){\\'2\\',\\'3\\',\\'5\\',\\'7\\'};\\n    int[,] DP;\\n    \\n    public int BeautifulPartitions(string s, int k, int minLength) {\\n        int res = 0;\\n        if(!Prime.Contains(s[0]) || s.Length<k*minLength || Prime.Contains(s[s.Length-1])) return 0;\\n        DP = new int[s.Length,k+1];\\n        for(int i=0;i<s.Length;i++)\\n        {\\n            for(int j=0;j<k+1;j++)\\n            {\\n                DP[i,j] = -1;\\n            }\\n            DP[i,0] = 0;\\n        }\\n        return B(s,0,k,minLength);\\n    }\\n    \\n    private int B(string s, int start, int k, int m)\\n    {\\n        if(DP[start,k]==-1)\\n        {\\n           \\n        if(s.Length-start<k*m)\\n        {\\n            DP[start,k] = 0;\\n        }\\n        else if(k==1)\\n        {\\n            DP[start,k] = 1;\\n        } \\n        else\\n        {\\n        int sl = (k-1) * m;\\n        int res = 0;\\n        for(int i=m-1; i<s.Length-sl-start; i++)\\n        {\\n            if(start+i+1>=s.Length)\\n                break;\\n            if(!Prime.Contains(s[start+i]) && Prime.Contains(s[start+i+1]))\\n            {\\n                res += (B(s,start+i+1,k-1,m) % M);\\n                res = res % M;\\n            }\\n        }\\n             DP[start,k] = res;\\n        }\\n        }\\n        return DP[start,k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834065,
                "title": "c-tweaked-bottom-up-dp-o-n-k",
                "content": "A lot of people have trouble for this situation (tweaked example #1):\\n```\\ns = \"235421851\", k = 2, minLength = 2\\nOutput: 2\\n\\n\"2354 | 21851\"\\n\"2354218 | 51\"\\n```\\n\\nIf you do the naive DP, you are going to get the TC O(n^2*k) because you might be iterating through all the points you can partition at `dp[position][k left]`, which adds an extra factor of `n`.\\n\\nTo avoid this, let\\'s say we\\'re at `dp[0][2]`. We can see that we need to add the answers `dp[4][1] = 1` and `dp[7][1]` onto our answer. **Let\\'s keep a running sum `cur` which we keep adding the previous answers onto**.\\n\\nWe can update our  `cur` with a pointer. In my code, `partition_idx` contains all the possible positions we can start a new partition. If we know the location `j` points at compared to our position meets the miniimum length (`partition_idx[j] - partition_idx[i] >= minLength`), then we know we need this answer for our current position `i` , thus adding it to our `cur`.\\n\\n---\\n\\n```cpp\\nclass Solution {\\n  bool is_prime(char c) { return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\'; }\\n\\npublic:\\n  int beautifulPartitions(string s, int k, int minLength) {\\n    int n = s.size();\\n    if (!is_prime(s[0]) || is_prime(s[n - 1])) {\\n      return 0;\\n    }\\n\\n    vector<int> partition_idx;\\n    for (int i = 0; i < n; i++) {\\n      if (is_prime(s[i]) && (i == 0 || !is_prime(s[i - 1]))) {\\n        partition_idx.push_back(i);\\n      }\\n    }\\n\\n    int m = partition_idx.size();\\n    vector<int> dp(m);\\n    for (int i = 0; i < m && n - partition_idx[i] >= minLength; i++) {\\n      dp[i] = 1;\\n    }\\n    for (int k2 = 2; k2 <= k; k2++) {\\n      vector<int> ndp(m);\\n      int cur = 0;\\n      for (int i = m - 1, j = m - 1; i >= 0; i--) {\\n        while (j > i && partition_idx[j] - partition_idx[i] >= minLength) {\\n          cur += dp[j--];\\n          cur %= M;\\n        }\\n        ndp[i] = cur;\\n      }\\n      swap(dp, ndp);\\n    }\\n\\n    return dp[0];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\ns = \"235421851\", k = 2, minLength = 2\\nOutput: 2\\n\\n\"2354 | 21851\"\\n\"2354218 | 51\"\\n```\n```cpp\\nclass Solution {\\n  bool is_prime(char c) { return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\'; }\\n\\npublic:\\n  int beautifulPartitions(string s, int k, int minLength) {\\n    int n = s.size();\\n    if (!is_prime(s[0]) || is_prime(s[n - 1])) {\\n      return 0;\\n    }\\n\\n    vector<int> partition_idx;\\n    for (int i = 0; i < n; i++) {\\n      if (is_prime(s[i]) && (i == 0 || !is_prime(s[i - 1]))) {\\n        partition_idx.push_back(i);\\n      }\\n    }\\n\\n    int m = partition_idx.size();\\n    vector<int> dp(m);\\n    for (int i = 0; i < m && n - partition_idx[i] >= minLength; i++) {\\n      dp[i] = 1;\\n    }\\n    for (int k2 = 2; k2 <= k; k2++) {\\n      vector<int> ndp(m);\\n      int cur = 0;\\n      for (int i = m - 1, j = m - 1; i >= 0; i--) {\\n        while (j > i && partition_idx[j] - partition_idx[i] >= minLength) {\\n          cur += dp[j--];\\n          cur %= M;\\n        }\\n        ndp[i] = cur;\\n      }\\n      swap(dp, ndp);\\n    }\\n\\n    return dp[0];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834039,
                "title": "java-o-length-k-time-solution",
                "content": "consider a string `s` of length `n`.  \\nstring = {s[0], s[1], ...., s[n-1]}. Each partition of the substring is of length atleast `minLength`.  Hence if we know the number of ways of splitting the string {s[0],....., s[n-minLength-1]} with `k-1` partitions, we would know the answer of the complete string with k partitions.\\n\\nInstead of iterating over all the indices and adding them, use a prefix sum to keep track of the counts from the previous indices.\\n\\nTime Complexity : `O(L * K)` where L = length of the string, k = number of partitions\\nSpace Complexity : `O(L)` where L = length of the string [space used by memoization array]\\n\\n```java\\nclass Solution {\\n    \\n    private static int MODULO = (int)(1e9 + 7);\\n    \\n    private static boolean debug = false;\\n    \\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        \\n        // less than minlength, not starting with prime number, ending with prime number\\n        if ( s.length() < minLength || !isPrime(s.charAt(0)) || isPrime(s.charAt(s.length()-1)) ) {\\n            return 0;\\n        }\\n        \\n        // number of ways to split into 1 partition is 1\\n        if (k == 1) {\\n            return 1;\\n        }\\n        \\n        int[] kMinusOneWays = new int[s.length()];\\n        \\n        // instead of iterating over all the indices, it is enough to iterate over valid split indices\\n        int[] splitIndices = new int[s.length()];\\n        \\n        int splitLength = 0;\\n        \\n        for (int index = 1; index < s.length(); index++) {\\n            \\n            // identify all valid split indices\\n            if (isPrime(s.charAt(index)) && !isPrime(s.charAt(index-1))) {\\n                splitIndices[splitLength++] = index-1;\\n                \\n                // marking the initialization\\n                if ( index >=  minLength) {\\n                    kMinusOneWays[index-1] = 1;\\n                }\\n            }\\n        }\\n        \\n        // defintely atleast one partition of beautiful sub string. Hence add one to the last index\\n        splitIndices[splitLength++] = s.length()-1;\\n        \\n        kMinusOneWays[kMinusOneWays.length-1] = 1;\\n        \\n        for (int numberOfPartitions = 2; numberOfPartitions <= k; numberOfPartitions++) {\\n            \\n\\t\\t\\t// doing a prefix sum avoids another iteration of string length to calculate the number of ways\\n            prefixSum(kMinusOneWays, minLength);\\n            \\n            int[] kWays = new int[kMinusOneWays.length];\\n            \\n\\n            for (int endIndex : splitIndices) {\\n                \\n                int endOfPreviousSplit = endIndex-minLength;\\n                \\n                if (endOfPreviousSplit < 0) {\\n                    continue;\\n                }\\n                \\n                // for every valid split index assign the number of ways of splitting k-1 ways\\n                kWays[endIndex] = kMinusOneWays[endOfPreviousSplit];\\n            }\\n            \\n            kMinusOneWays = kWays;\\n        }\\n        \\n        return kMinusOneWays[kMinusOneWays.length-1];\\n    }\\n    \\n    private void prefixSum(int[] arr, int minLength) {\\n        \\n        int sum = 0;\\n        \\n        for (int index = 0; index < arr.length; index++) {\\n            sum = (sum + arr[index] ) % MODULO;\\n            \\n            arr[index] = sum;\\n        }\\n    }\\n    \\n    private boolean isPrime(char letter) {\\n        return (letter == \\'2\\' || letter == \\'3\\' || letter == \\'5\\' || letter == \\'7\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    private static int MODULO = (int)(1e9 + 7);\\n    \\n    private static boolean debug = false;\\n    \\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        \\n        // less than minlength, not starting with prime number, ending with prime number\\n        if ( s.length() < minLength || !isPrime(s.charAt(0)) || isPrime(s.charAt(s.length()-1)) ) {\\n            return 0;\\n        }\\n        \\n        // number of ways to split into 1 partition is 1\\n        if (k == 1) {\\n            return 1;\\n        }\\n        \\n        int[] kMinusOneWays = new int[s.length()];\\n        \\n        // instead of iterating over all the indices, it is enough to iterate over valid split indices\\n        int[] splitIndices = new int[s.length()];\\n        \\n        int splitLength = 0;\\n        \\n        for (int index = 1; index < s.length(); index++) {\\n            \\n            // identify all valid split indices\\n            if (isPrime(s.charAt(index)) && !isPrime(s.charAt(index-1))) {\\n                splitIndices[splitLength++] = index-1;\\n                \\n                // marking the initialization\\n                if ( index >=  minLength) {\\n                    kMinusOneWays[index-1] = 1;\\n                }\\n            }\\n        }\\n        \\n        // defintely atleast one partition of beautiful sub string. Hence add one to the last index\\n        splitIndices[splitLength++] = s.length()-1;\\n        \\n        kMinusOneWays[kMinusOneWays.length-1] = 1;\\n        \\n        for (int numberOfPartitions = 2; numberOfPartitions <= k; numberOfPartitions++) {\\n            \\n\\t\\t\\t// doing a prefix sum avoids another iteration of string length to calculate the number of ways\\n            prefixSum(kMinusOneWays, minLength);\\n            \\n            int[] kWays = new int[kMinusOneWays.length];\\n            \\n\\n            for (int endIndex : splitIndices) {\\n                \\n                int endOfPreviousSplit = endIndex-minLength;\\n                \\n                if (endOfPreviousSplit < 0) {\\n                    continue;\\n                }\\n                \\n                // for every valid split index assign the number of ways of splitting k-1 ways\\n                kWays[endIndex] = kMinusOneWays[endOfPreviousSplit];\\n            }\\n            \\n            kMinusOneWays = kWays;\\n        }\\n        \\n        return kMinusOneWays[kMinusOneWays.length-1];\\n    }\\n    \\n    private void prefixSum(int[] arr, int minLength) {\\n        \\n        int sum = 0;\\n        \\n        for (int index = 0; index < arr.length; index++) {\\n            sum = (sum + arr[index] ) % MODULO;\\n            \\n            arr[index] = sum;\\n        }\\n    }\\n    \\n    private boolean isPrime(char letter) {\\n        return (letter == \\'2\\' || letter == \\'3\\' || letter == \\'5\\' || letter == \\'7\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833157,
                "title": "dp-most-optimised",
                "content": "\\n    map<char,bool> mp1;\\n    long long len;\\n    long long k;\\n    vector<vector<long long>> dp[2];\\n    long long  mod=1e9+7;\\n    long long rec(string &s,int i,int p,bool y){\\n        if(p<0)return 0;\\n        if(i>s.length())return 0;\\n        if(s.length()==i){  if(p==0&&y)return 1; else return 0; }\\n        if(dp[y][i][p]!=-1)return dp[y][i][p];\\n        long long ans=0;\\n        if(mp1.find(s[i])!=mp1.end()){\\n            \\n            if(y){\\n                ans+=rec(s,i+len-1,p,false);\\n            }\\n            else\\n            ans+=rec(s,i+1,p,false);\\n            ans%=mod;\\n        }\\n        else if(y==false){\\n            \\n            ans+=rec(s,i+1,p,false);\\n            ans+=rec(s,i+1,p-1,true);\\n            ans%=mod;\\n            \\n            \\n        }\\n        return dp[y][i][p]=ans;\\n        \\n    }\\n    int beautifulPartitions(string s, int k1, int l) {\\n        \\n        mp1[\\'2\\']=true;\\n          mp1[\\'3\\']=true;\\n          mp1[\\'5\\']=true;\\n          mp1[\\'7\\']=true;\\n          \\n        len=max(l,2);\\n        k=k1;\\n        dp[0].assign(s.length(),vector<long long>(k1+1,-1));\\n                dp[1].assign(s.length(),vector<long long>(k1+1,-1));\\n\\n     int ans=  rec(s,0,k1,true);\\n   \\n        \\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    map<char,bool> mp1;\\n    long long len;\\n    long long k;\\n    vector<vector<long long>> dp[2];\\n    long long  mod=1e9+7;\\n    long long rec(string &s,int i,int p,bool y){\\n        if(p<0)return 0;\\n        if(i>s.length())return 0;\\n        if(s.length()==i){  if(p==0&&y)return 1; else return 0; }\\n        if(dp[y][i][p]!=-1)return dp[y][i][p];\\n        long long ans=0;\\n        if(mp1.find(s[i])!=mp1.end()){\\n            \\n            if(y){\\n                ans+=rec(s,i+len-1,p,false);\\n            }\\n            else\\n            ans+=rec(s,i+1,p,false);\\n            ans%=mod;\\n        }\\n        else if(y==false){\\n            \\n            ans+=rec(s,i+1,p,false);\\n            ans+=rec(s,i+1,p-1,true);\\n            ans%=mod;\\n            \\n            \\n        }\\n        return dp[y][i][p]=ans;\\n        \\n    }\\n    int beautifulPartitions(string s, int k1, int l) {\\n        \\n        mp1[\\'2\\']=true;\\n          mp1[\\'3\\']=true;\\n          mp1[\\'5\\']=true;\\n          mp1[\\'7\\']=true;\\n          \\n        len=max(l,2);\\n        k=k1;\\n        dp[0].assign(s.length(),vector<long long>(k1+1,-1));\\n                dp[1].assign(s.length(),vector<long long>(k1+1,-1));\\n\\n     int ans=  rec(s,0,k1,true);\\n   \\n        \\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2833096,
                "title": "python-top-down-after-a-bunch-of-tle-finally-works",
                "content": "skip-or-take works magically...\\n\\nRuntime: 2247 ms, faster than 83.33% of Python3 online submissions for Number of Beautiful Partitions.\\n\\n```python\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        MOD = int(1e9+7)\\n        def isPrime(num):\\n            return num == \"2\" or num == \"3\" or num == \"5\" or num == \"7\"\\n        n = len(s)\\n        \\n        if not isPrime(s[0]): return 0\\n        if isPrime(s[-1]): return 0\\n        \\n        @functools.lru_cache(None)\\n        def dfs(i, k):\\n            if i == n-1 and k == 1:\\n                return 1\\n            if i >= n-1 or k == 0:\\n                return 0\\n\\n            res = dfs(i+1, k) # skip current partition position\\n            if not isPrime(s[i]) and isPrime(s[i+1]): # found valid partition\\n                res += dfs(i+minLength, k-1) # keep finding next valid partition position\\n            return res % MOD\\n            \\n        return dfs(minLength-1, k)\\n```\\n\\n\\n\\n### TLE\\n```python\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        MOD = int(1e9+7)\\n        def isPrime(num):\\n            return num == \"2\" or num == \"3\" or num == \"5\" or num == \"7\"\\n        n = len(s)\\n        \\n        if not isPrime(s[0]): return 0\\n        if isPrime(s[-1]): return 0\\n        \\n        @functools.lru_cache(None)\\n        def dfs(i, k):\\n            if i == n and k == 0:\\n                return 1\\n            if i == n or k == 0:\\n                return 0\\n            \\n            if not isPrime(s[i]): return 0\\n\\n            res = 0\\n            for j in range(i+minLength, n+1):\\n                if (j == n or isPrime(s[j])) and not isPrime(s[j-1]):\\n                    if j-i < minLength: continue\\n                    res += dfs(j, k-1) % MOD\\n\\n            return res % MOD\\n        return dfs(0,k)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        MOD = int(1e9+7)\\n        def isPrime(num):\\n            return num == \"2\" or num == \"3\" or num == \"5\" or num == \"7\"\\n        n = len(s)\\n        \\n        if not isPrime(s[0]): return 0\\n        if isPrime(s[-1]): return 0\\n        \\n        @functools.lru_cache(None)\\n        def dfs(i, k):\\n            if i == n-1 and k == 1:\\n                return 1\\n            if i >= n-1 or k == 0:\\n                return 0\\n\\n            res = dfs(i+1, k) # skip current partition position\\n            if not isPrime(s[i]) and isPrime(s[i+1]): # found valid partition\\n                res += dfs(i+minLength, k-1) # keep finding next valid partition position\\n            return res % MOD\\n            \\n        return dfs(minLength-1, k)\\n```\n```python\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        MOD = int(1e9+7)\\n        def isPrime(num):\\n            return num == \"2\" or num == \"3\" or num == \"5\" or num == \"7\"\\n        n = len(s)\\n        \\n        if not isPrime(s[0]): return 0\\n        if isPrime(s[-1]): return 0\\n        \\n        @functools.lru_cache(None)\\n        def dfs(i, k):\\n            if i == n and k == 0:\\n                return 1\\n            if i == n or k == 0:\\n                return 0\\n            \\n            if not isPrime(s[i]): return 0\\n\\n            res = 0\\n            for j in range(i+minLength, n+1):\\n                if (j == n or isPrime(s[j])) and not isPrime(s[j-1]):\\n                    if j-i < minLength: continue\\n                    res += dfs(j, k-1) % MOD\\n\\n            return res % MOD\\n        return dfs(0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833066,
                "title": "c-dp-recursive-solution-well-explained",
                "content": "\\n**Please feel free to ask query and Upvote if you find it helpful**\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001] = {};    \\n    int Prime(char c){\\n        return c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\';\\n    }\\n    int recurse(int index, int k, int minLength,string &s){\\n        if(k==0){ // partitioned into k substrings\\n            return index == s.size(); // reached end of the string\\n        }\\n        if(index + k*minLength > s.size()){ // Not possible partion s in k non-intersecting substrings of minLength\\n            return 0;\\n            \\n        }\\n        if(!Prime(s[index])){ // partition starting at index should not start with non-prime\\n            return 0;\\n        }\\n        \\n        if(dp[index][k] ==0){ // subproblem not solved yet\\n            dp[index][k] =1; // dummy +1 which will confirm that we explored this subproblem. when return dp[index][k] we will do -1;\\n            \\n            // Iterate though next characters which might be end of our current partion substring string\\n            for(int j=index+minLength-1;j<s.size();j++){\\n                if(!Prime(s[j])){ // as substring should end with non-prime\\n                    // j+1 will be the start of next subtring and we need to find k-1 substring \\n                    dp[index][k] = (dp[index][k] + recurse(j+1,k-1,minLength,s))% 1000000007;;\\n                }\\n            }\\n        }\\n        \\n        return dp[index][k]-1;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        return recurse(0,k,minLength,s); // we need to find the ways of partitions string s into k non-intersecting substrings and we start with the first element of s\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001] = {};    \\n    int Prime(char c){\\n        return c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\';\\n    }\\n    int recurse(int index, int k, int minLength,string &s){\\n        if(k==0){ // partitioned into k substrings\\n            return index == s.size(); // reached end of the string\\n        }\\n        if(index + k*minLength > s.size()){ // Not possible partion s in k non-intersecting substrings of minLength\\n            return 0;\\n            \\n        }\\n        if(!Prime(s[index])){ // partition starting at index should not start with non-prime\\n            return 0;\\n        }\\n        \\n        if(dp[index][k] ==0){ // subproblem not solved yet\\n            dp[index][k] =1; // dummy +1 which will confirm that we explored this subproblem. when return dp[index][k] we will do -1;\\n            \\n            // Iterate though next characters which might be end of our current partion substring string\\n            for(int j=index+minLength-1;j<s.size();j++){\\n                if(!Prime(s[j])){ // as substring should end with non-prime\\n                    // j+1 will be the start of next subtring and we need to find k-1 substring \\n                    dp[index][k] = (dp[index][k] + recurse(j+1,k-1,minLength,s))% 1000000007;;\\n                }\\n            }\\n        }\\n        \\n        return dp[index][k]-1;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        return recurse(0,k,minLength,s); // we need to find the ways of partitions string s into k non-intersecting substrings and we start with the first element of s\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833005,
                "title": "c-bottom-up-dp-solution-o-nk",
                "content": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size(), mod = 1e9 + 7;\\n        vector<bool> isPrime(n);\\n        vector<bool> p = {false, true, true, false, true, false, true, false, false};\\n        for (int i = 0; i < n; i++) {\\n            int curr = s[i] - \\'1\\';\\n            isPrime[i] = p[curr];\\n        }\\n        int dp[1001][1001] = {};\\n        dp[0][0] = 1;\\n        vector<int> accu(k + 1, 0);\\n        for (int i = 1; i <= n; i++) {\\n            if (i >= minLength && isPrime[i - minLength]) {\\n                for (int cnt = 0; cnt < k; cnt++) {\\n                    accu[cnt] += dp[i - minLength][cnt];\\n                    accu[cnt] %= mod;\\n                }\\n            }\\n            if (isPrime[i - 1]) continue;\\n            for (int j = 1; j <= k; j++) {\\n                dp[i][j] += accu[j - 1];\\n                dp[i][j] %= mod;\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size(), mod = 1e9 + 7;\\n        vector<bool> isPrime(n);\\n        vector<bool> p = {false, true, true, false, true, false, true, false, false};\\n        for (int i = 0; i < n; i++) {\\n            int curr = s[i] - \\'1\\';\\n            isPrime[i] = p[curr];\\n        }\\n        int dp[1001][1001] = {};\\n        dp[0][0] = 1;\\n        vector<int> accu(k + 1, 0);\\n        for (int i = 1; i <= n; i++) {\\n            if (i >= minLength && isPrime[i - minLength]) {\\n                for (int cnt = 0; cnt < k; cnt++) {\\n                    accu[cnt] += dp[i - minLength][cnt];\\n                    accu[cnt] %= mod;\\n                }\\n            }\\n            if (isPrime[i - 1]) continue;\\n            for (int j = 1; j <= k; j++) {\\n                dp[i][j] += accu[j - 1];\\n                dp[i][j] %= mod;\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832930,
                "title": "c-recursion-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    long long dp[1001][1001];\\n    int n;\\n    bool isPrime(char ch){\\n        if(ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\' || ch == \\'7\\')\\n            return true;\\n        return false;\\n    }\\n    int solve(int i,int ml,int k,vector<int>&pos){\\n        if(k==0 && i == pos.size()-1) return 1;\\n        if(k==0 || i == pos.size()-1) return 0; \\n        if(dp[i][k] != -1) return dp[i][k];\\n        long long ans=0;\\n        for(int x=i+1;x<=pos.size()-k;x++){\\n            if(pos[x]-pos[i] < ml) continue;\\n            ans=(ans+solve(x,ml,k-1,pos))%mod;\\n        }\\n        return dp[i][k]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int ml) {\\n        n = s.size();\\n        if(!isPrime(s[0]) || isPrime(s[n-1])) return 0; \\n        vector<int>pos;\\n        pos.push_back(0);\\n        for(int i=1;i<n-1;i++){\\n            if(!isPrime(s[i]) && isPrime(s[i+1])){\\n                pos.push_back(i+1);\\n            }\\n        }\\n        if(pos.size() < k) return 0; \\n        pos.push_back(n);\\n        memset(dp , -1,sizeof dp);\\n        return solve(0,ml,k,pos)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    long long dp[1001][1001];\\n    int n;\\n    bool isPrime(char ch){\\n        if(ch == \\'2\\' || ch == \\'3\\' || ch == \\'5\\' || ch == \\'7\\')\\n            return true;\\n        return false;\\n    }\\n    int solve(int i,int ml,int k,vector<int>&pos){\\n        if(k==0 && i == pos.size()-1) return 1;\\n        if(k==0 || i == pos.size()-1) return 0; \\n        if(dp[i][k] != -1) return dp[i][k];\\n        long long ans=0;\\n        for(int x=i+1;x<=pos.size()-k;x++){\\n            if(pos[x]-pos[i] < ml) continue;\\n            ans=(ans+solve(x,ml,k-1,pos))%mod;\\n        }\\n        return dp[i][k]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int ml) {\\n        n = s.size();\\n        if(!isPrime(s[0]) || isPrime(s[n-1])) return 0; \\n        vector<int>pos;\\n        pos.push_back(0);\\n        for(int i=1;i<n-1;i++){\\n            if(!isPrime(s[i]) && isPrime(s[i+1])){\\n                pos.push_back(i+1);\\n            }\\n        }\\n        if(pos.size() < k) return 0; \\n        pos.push_back(n);\\n        memset(dp , -1,sizeof dp);\\n        return solve(0,ml,k,pos)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832876,
                "title": "top-down-dp-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int md = 1e9 + 7;\\n    bool isPrime(int n) {\\n        if(n==2 || n==3 || n==5 ||n==7) return true;\\n        else return false;\\n    }\\n    \\n    int solve(string& s, int idx, int k, int minLen) {\\n        if(!isPrime(s[idx]-\\'0\\')) return 0;\\n        if(k==1 && isPrime(s[idx]-\\'0\\') && s.size()-idx >= minLen) return 1;\\n        if(k==1) return 0;\\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        int ans = 0;\\n        for(int i=idx;i<s.size()-1;i++) {\\n            int len = i-idx+1;\\n            if(len >= minLen) {\\n                int end = s[i]-\\'0\\';\\n                if(!isPrime(end)) {\\n                    int rem = solve(s,i+1,k-1,minLen);\\n                    if(rem!=0) ans = (ans +  (rem % md))%md;\\n                }\\n            }\\n        }\\n        return dp[idx][k] = ans;\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLen) {\\n        if(s==\"\") return 0;\\n        memset(dp,-1,sizeof dp);\\n        if(!isPrime(s[0]-\\'0\\')) return 0;\\n        if(isPrime(s[s.size()-1]-\\'0\\')) return 0;\\n        if(s.size() < k*minLen) return 0;\\n        return solve(s,0,k,minLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int md = 1e9 + 7;\\n    bool isPrime(int n) {\\n        if(n==2 || n==3 || n==5 ||n==7) return true;\\n        else return false;\\n    }\\n    \\n    int solve(string& s, int idx, int k, int minLen) {\\n        if(!isPrime(s[idx]-\\'0\\')) return 0;\\n        if(k==1 && isPrime(s[idx]-\\'0\\') && s.size()-idx >= minLen) return 1;\\n        if(k==1) return 0;\\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        int ans = 0;\\n        for(int i=idx;i<s.size()-1;i++) {\\n            int len = i-idx+1;\\n            if(len >= minLen) {\\n                int end = s[i]-\\'0\\';\\n                if(!isPrime(end)) {\\n                    int rem = solve(s,i+1,k-1,minLen);\\n                    if(rem!=0) ans = (ans +  (rem % md))%md;\\n                }\\n            }\\n        }\\n        return dp[idx][k] = ans;\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLen) {\\n        if(s==\"\") return 0;\\n        memset(dp,-1,sizeof dp);\\n        if(!isPrime(s[0]-\\'0\\')) return 0;\\n        if(isPrime(s[s.size()-1]-\\'0\\')) return 0;\\n        if(s.size() < k*minLen) return 0;\\n        return solve(s,0,k,minLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832842,
                "title": "reduce-the-problem-to-a-smaller-version-of-itself",
                "content": "# Intuition - Reduce it to a smaller version of itself\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we make a partition $$S[L, R]$$, then we just have to count the number of ways to partition the first $$L - 1$$ characters into $$k - 1$$ parts. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet $$f(i, p)$$ represent the number of ways to partition the first $$i$$ characters into exactly $$p$$ parts. \\n* $$f(i, p) = \\\\sum f(j, p - 1)$$, where $$S[j + 1, i]$$ is a good part and of the minimum length. \\n\\nThe transition takes $$O(n)$$ time, but we can make it quicker by storing a prefix sum. \\n* Let $$S(i, p)$$ be the number of ways to make $$p$$ partitions among the first $$i$$ characters. (It may or may not be ending at $$i$$). \\n* $$S(i, p) = S(i - 1, p) + f(i, p)$$\\n* * One extra condition to check is that the $$i + 1$$-th digit is prime if a partition ends at $$i$$. Only add $$f(i, p)$$ if the next digit is prime. \\n# Complexity\\n- Time complexity: $$O(n \\\\times k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n \\\\times k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n[GitHub](https://github.com/MathProgrammer/LeetCode/tree/master/Contests/Weekly%20Contest%20320)\\n```\\nclass Solution {\\npublic:\\n    \\n    int is_prime(int d)\\n    {\\n        return (d == 2) || (d == 3) || (d == 5) || (d == 7);\\n    }\\n    \\n    int beautifulPartitions(string S, int k, int min_length) \\n    {\\n        if(!is_prime(S[0] - \\'0\\'))\\n        {\\n            return 0;\\n        }\\n        \\n        const int MOD = 1e9 + 7;\\n        vector <vector <long long> > no_of_partitions(S.size() + 1, vector <long long> (k + 1, 0));\\n        vector <vector <long long> > sum(S.size() + 1, vector <long long> (k + 1));\\n        for(int p = 1; p <= k ; p++)\\n        {\\n            for(int i = min_length - 1; i < S.size(); i++)\\n            {\\n                if(!is_prime(S[i] - \\'0\\'))\\n                {\\n                    if(p == 1)\\n                    {\\n                        no_of_partitions[i][p] = 1;\\n                    }\\n                    else \\n                    {\\n                        no_of_partitions[i][p] = (i == min_length - 1 ? 0 : sum[i - min_length][p - 1]);\\n                    }\\n                }\\n                \\n                sum[i][p] = (i == 0 ? 0 : sum[i - 1][p]);\\n                \\n                if(i + 1 == S.size() || is_prime(S[i + 1] - \\'0\\'))\\n                {\\n                    sum[i][p] += no_of_partitions[i][p];\\n                }\\n                \\n                sum[i][p] %= MOD;\\n            }\\n        }\\n        \\n        return no_of_partitions[S.size() - 1][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int is_prime(int d)\\n    {\\n        return (d == 2) || (d == 3) || (d == 5) || (d == 7);\\n    }\\n    \\n    int beautifulPartitions(string S, int k, int min_length) \\n    {\\n        if(!is_prime(S[0] - \\'0\\'))\\n        {\\n            return 0;\\n        }\\n        \\n        const int MOD = 1e9 + 7;\\n        vector <vector <long long> > no_of_partitions(S.size() + 1, vector <long long> (k + 1, 0));\\n        vector <vector <long long> > sum(S.size() + 1, vector <long long> (k + 1));\\n        for(int p = 1; p <= k ; p++)\\n        {\\n            for(int i = min_length - 1; i < S.size(); i++)\\n            {\\n                if(!is_prime(S[i] - \\'0\\'))\\n                {\\n                    if(p == 1)\\n                    {\\n                        no_of_partitions[i][p] = 1;\\n                    }\\n                    else \\n                    {\\n                        no_of_partitions[i][p] = (i == min_length - 1 ? 0 : sum[i - min_length][p - 1]);\\n                    }\\n                }\\n                \\n                sum[i][p] = (i == 0 ? 0 : sum[i - 1][p]);\\n                \\n                if(i + 1 == S.size() || is_prime(S[i + 1] - \\'0\\'))\\n                {\\n                    sum[i][p] += no_of_partitions[i][p];\\n                }\\n                \\n                sum[i][p] %= MOD;\\n            }\\n        }\\n        \\n        return no_of_partitions[S.size() - 1][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832841,
                "title": "java-top-down-dp-solution",
                "content": "```\\nclass Solution {\\n    private static int mod = 1_000_000_007;\\n    \\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        int[] arr = new int[s.length()];\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = s.charAt(i) - \\'0\\';\\n        }\\n        if (s.length() < k * minLength || !isPrime(arr[0]) || isPrime(arr[arr.length - 1])) {\\n            return 0;\\n        }\\n        \\n        List<Integer> segments = new ArrayList<>();\\n        int lastCut = -1;\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            if (!isPrime(arr[i]) && isPrime(arr[i + 1])) {\\n                segments.add(i - lastCut);\\n                lastCut = i;\\n            }\\n        }\\n        segments.add(arr.length - 1 - lastCut);\\n        Integer[][] memo = new Integer[segments.size()][k + 1];\\n        int res = dfs(segments, 0, k, minLength, memo);\\n        return res;\\n    }\\n    \\n    private int dfs(List<Integer> segments, int offset, int k, int minLength, Integer[][] memo) {\\n        if (offset == segments.size() && k == 0) {\\n            return 1;\\n        }\\n        if (offset == segments.size() || k == 0) {\\n            return 0;\\n        }\\n        if (segments.size() - offset < k) {\\n            return 0;\\n        }\\n        if (memo[offset][k] != null) {\\n            return memo[offset][k];\\n        }\\n        int res = 0;\\n        int len = 0;\\n        for (int i = offset; i < segments.size(); i++) {\\n            len += segments.get(i);\\n            if (len >= minLength) {\\n                res = (res + dfs(segments, i + 1, k - 1, minLength, memo)) % mod;\\n            }\\n        }\\n        memo[offset][k] = res;\\n        return res;\\n    }\\n    \\n    private boolean isPrime(int a) {\\n        return a == 2 || a == 3 || a == 5 || a == 7;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static int mod = 1_000_000_007;\\n    \\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        int[] arr = new int[s.length()];\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = s.charAt(i) - \\'0\\';\\n        }\\n        if (s.length() < k * minLength || !isPrime(arr[0]) || isPrime(arr[arr.length - 1])) {\\n            return 0;\\n        }\\n        \\n        List<Integer> segments = new ArrayList<>();\\n        int lastCut = -1;\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            if (!isPrime(arr[i]) && isPrime(arr[i + 1])) {\\n                segments.add(i - lastCut);\\n                lastCut = i;\\n            }\\n        }\\n        segments.add(arr.length - 1 - lastCut);\\n        Integer[][] memo = new Integer[segments.size()][k + 1];\\n        int res = dfs(segments, 0, k, minLength, memo);\\n        return res;\\n    }\\n    \\n    private int dfs(List<Integer> segments, int offset, int k, int minLength, Integer[][] memo) {\\n        if (offset == segments.size() && k == 0) {\\n            return 1;\\n        }\\n        if (offset == segments.size() || k == 0) {\\n            return 0;\\n        }\\n        if (segments.size() - offset < k) {\\n            return 0;\\n        }\\n        if (memo[offset][k] != null) {\\n            return memo[offset][k];\\n        }\\n        int res = 0;\\n        int len = 0;\\n        for (int i = offset; i < segments.size(); i++) {\\n            len += segments.get(i);\\n            if (len >= minLength) {\\n                res = (res + dfs(segments, i + 1, k - 1, minLength, memo)) % mod;\\n            }\\n        }\\n        memo[offset][k] = res;\\n        return res;\\n    }\\n    \\n    private boolean isPrime(int a) {\\n        return a == 2 || a == 3 || a == 5 || a == 7;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832826,
                "title": "simple-dp-with-some-constant-factor-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        int[][] dp = new int[s.length() + 1][s.length() + 1];\\n        dp[0][0] = 1;\\n        Set<Character> primeDigits = new HashSet<>();\\n        primeDigits.add(\\'2\\');\\n        primeDigits.add(\\'3\\');\\n        primeDigits.add(\\'5\\');\\n        primeDigits.add(\\'7\\');\\n        int mod = 1000000007;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (primeDigits.contains(s.charAt(i)) || (i != s.length() - 1 && !primeDigits.contains(s.charAt(i + 1)))) {\\n                continue;\\n            }\\n            for (int m = i - minLength + 1; m >= 0; --m) {\\n                if (!primeDigits.contains(s.charAt(m)) || (m > 0 && primeDigits.contains(s.charAt(m - 1)))) {\\n                    continue;\\n                }\\n                for (int j = 1; j <= k; ++j) {\\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[m][j - 1]) % mod;\\n                }\\n            }\\n        }\\n        return dp[s.length()][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        int[][] dp = new int[s.length() + 1][s.length() + 1];\\n        dp[0][0] = 1;\\n        Set<Character> primeDigits = new HashSet<>();\\n        primeDigits.add(\\'2\\');\\n        primeDigits.add(\\'3\\');\\n        primeDigits.add(\\'5\\');\\n        primeDigits.add(\\'7\\');\\n        int mod = 1000000007;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (primeDigits.contains(s.charAt(i)) || (i != s.length() - 1 && !primeDigits.contains(s.charAt(i + 1)))) {\\n                continue;\\n            }\\n            for (int m = i - minLength + 1; m >= 0; --m) {\\n                if (!primeDigits.contains(s.charAt(m)) || (m > 0 && primeDigits.contains(s.charAt(m - 1)))) {\\n                    continue;\\n                }\\n                for (int j = 1; j <= k; ++j) {\\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[m][j - 1]) % mod;\\n                }\\n            }\\n        }\\n        return dp[s.length()][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832811,
                "title": "dp-standard-knapsack-on-condition",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\n#define ll long long int\\nclass Solution {\\n    ll dp[1001][1001];\\n    set<char>p;\\n    const int M=1e9+7;\\n    int ml;\\n    ll helper(string &s,int k,int idx)\\n    {\\n\\t\\tif(idx>=s.length())return 0;\\n\\t\\tif(k==0)return 1;\\n        \\n        if(dp[idx][k]!=-1LL)return dp[idx][k];\\n        ll res=0;\\n        if(!p.count(s[idx])&&(idx+1<s.length())&&p.count(s[idx+1]))\\n        {\\n            res=(res%M+helper(s,k-1,idx+ml)%M)%M;\\n        }\\n        res=(res%M+helper(s,k,idx+1)%M)%M;\\n        return dp[idx][k]=res;\\n    }\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        p.insert(\\'2\\');p.insert(\\'3\\');p.insert(\\'5\\');p.insert(\\'7\\');\\n        ml=minLength;\\n        if(!p.count(s[0])||p.count(s.back()))return 0;\\n        memset(dp,-1LL,sizeof(dp));\\n        return helper(s,k-1,ml-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    ll dp[1001][1001];\\n    set<char>p;\\n    const int M=1e9+7;\\n    int ml;\\n    ll helper(string &s,int k,int idx)\\n    {\\n\\t\\tif(idx>=s.length())return 0;\\n\\t\\tif(k==0)return 1;\\n        \\n        if(dp[idx][k]!=-1LL)return dp[idx][k];\\n        ll res=0;\\n        if(!p.count(s[idx])&&(idx+1<s.length())&&p.count(s[idx+1]))\\n        {\\n            res=(res%M+helper(s,k-1,idx+ml)%M)%M;\\n        }\\n        res=(res%M+helper(s,k,idx+1)%M)%M;\\n        return dp[idx][k]=res;\\n    }\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        p.insert(\\'2\\');p.insert(\\'3\\');p.insert(\\'5\\');p.insert(\\'7\\');\\n        ml=minLength;\\n        if(!p.count(s[0])||p.count(s.back()))return 0;\\n        memset(dp,-1LL,sizeof(dp));\\n        return helper(s,k-1,ml-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832649,
                "title": "c-dp",
                "content": "\\n```\\nclass Solution {\\n    long long dp[1003][1003]; \\n    string str;\\n    int k,len; \\n    int mod=1000000007;\\n    vector<int> non; \\n    long long call(int ind ,int occ)\\n    {\\n        if(ind==str.size())\\n        {\\n            return occ==k; \\n        }\\n        long long &ret=dp[ind][occ];\\n        if(ret!=-1) return ret; \\n        ret=0; \\n        int d=str[ind]-\\'0\\';\\n        if(d!=2 and d!=3 and d!=5 and d!=7) return 0; \\n        for(auto x: non)\\n        {\\n            if(x<ind) continue; \\n            if(x-ind+1>=len) ret+=call(x+1,occ+1);\\n        }\\n        return ret%=mod; \\n    }\\npublic:\\n    int beautifulPartitions(string s, int a, int b) {\\n        memset(dp,-1,sizeof dp); \\n        str=s,k=a,len=b; \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\' or s[i]==\\'4\\' or s[i]==\\'6\\' or s[i]==\\'9\\' or s[i]==\\'8\\') non.push_back(i);\\n        }\\n        int ans=call(0,0);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long long dp[1003][1003]; \\n    string str;\\n    int k,len; \\n    int mod=1000000007;\\n    vector<int> non; \\n    long long call(int ind ,int occ)\\n    {\\n        if(ind==str.size())\\n        {\\n            return occ==k; \\n        }\\n        long long &ret=dp[ind][occ];\\n        if(ret!=-1) return ret; \\n        ret=0; \\n        int d=str[ind]-\\'0\\';\\n        if(d!=2 and d!=3 and d!=5 and d!=7) return 0; \\n        for(auto x: non)\\n        {\\n            if(x<ind) continue; \\n            if(x-ind+1>=len) ret+=call(x+1,occ+1);\\n        }\\n        return ret%=mod; \\n    }\\npublic:\\n    int beautifulPartitions(string s, int a, int b) {\\n        memset(dp,-1,sizeof dp); \\n        str=s,k=a,len=b; \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\' or s[i]==\\'4\\' or s[i]==\\'6\\' or s[i]==\\'9\\' or s[i]==\\'8\\') non.push_back(i);\\n        }\\n        int ans=call(0,0);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832537,
                "title": "c-o-nk-dp-with-sliding-window-suffix",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    const int M=1e9+7;\\n    bool prime(const char &c){\\n        return c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\';\\n    }\\n    bool cons(const char &c){\\n        return !prime(c);\\n    }\\npublic:\\n    int beautifulPartitions(string s, int k, int mn) {\\n        if(!cons(s.back()) || !prime(s[0]))\\n            return 0;\\n        vector<int>cur(k+1, 0);\\n        int n=s.size();\\n        vector<vector<int>>DP(n+1, vector<int>(k+1, 0));\\n        DP[n][0]=1;\\n        for(int i=n-1; i>=0; i--){\\n            if(i+mn<=n && cons(s[i+mn-1])){\\n                for(int j=0; j<=k; j++){\\n                    cur[j] = (cur[j]+DP[i+mn][j])%M;\\n                }\\n            }\\n            if(!prime(s[i]))\\n                continue;\\n            for(int j=1; j<=k; j++){\\n                DP[i][j] = (DP[i][j] + cur[j-1])%M;\\n            }\\n        }\\n        return DP[0][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const int M=1e9+7;\\n    bool prime(const char &c){\\n        return c==\\'2\\' || c==\\'3\\' || c==\\'5\\' || c==\\'7\\';\\n    }\\n    bool cons(const char &c){\\n        return !prime(c);\\n    }\\npublic:\\n    int beautifulPartitions(string s, int k, int mn) {\\n        if(!cons(s.back()) || !prime(s[0]))\\n            return 0;\\n        vector<int>cur(k+1, 0);\\n        int n=s.size();\\n        vector<vector<int>>DP(n+1, vector<int>(k+1, 0));\\n        DP[n][0]=1;\\n        for(int i=n-1; i>=0; i--){\\n            if(i+mn<=n && cons(s[i+mn-1])){\\n                for(int j=0; j<=k; j++){\\n                    cur[j] = (cur[j]+DP[i+mn][j])%M;\\n                }\\n            }\\n            if(!prime(s[i]))\\n                continue;\\n            for(int j=1; j<=k; j++){\\n                DP[i][j] = (DP[i][j] + cur[j-1])%M;\\n            }\\n        }\\n        return DP[0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832507,
                "title": "over-optimized-o-nk-dp-solution-400-ms",
                "content": "# Intuition\\nThere can only be beautiful partitions if the string starts with a prime digit and ends with a non-prime digit. Furthermore, a substring can only starts when a prime digit follows a non-prime digit so we can preprocess to reduce from `n` to `m`, where `m` is at most `n/2`. We can also dynamically resize sub-list of `dp` to make sure that in the beginning we are not adding up zero entries unnecessarily when there can only be few substrings so far.\\n\\n# Approach\\nThe rest is standard DP + prefix sum optimization. This solution runs in 403-416 ms.\\n\\n# Complexity\\n- Time complexity:\\nO(nk)\\n\\n- Space complexity:\\nO(nk)\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        mod = 10 ** 9 + 7\\n        n = len(s)\\n        prime = {\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n        if s[0] in prime and s[-1] not in prime:\\n            op = []\\n            for i in range(1, n - 1):\\n                if s[i] not in prime and s[i + 1] in prime:\\n                    op.append(i + 1)\\n            op.append(n)\\n            m = len(op)\\n            dp = [[] for _ in range(m)]\\n            pos = 0\\n            j = 0\\n            while j < m and op[j] - pos < minLength:\\n                j += 1\\n            if j < m:\\n                dp[j] = [0, 1]\\n            for i, pos in enumerate(op):\\n                if i:\\n                    length = len(dp[i - 1])\\n                    dp[i].extend([0] * (length - len(dp[i])))\\n                    for index in range(1, length):\\n                        dp[i][index] += dp[i - 1][index]\\n                        dp[i][index] %= mod\\n                while j < m and op[j] - pos < minLength:\\n                    j += 1\\n                if j < m:\\n                    length = min(k + 1, len(dp[i]) + 1)\\n                    dp[j].extend([0] * (length - len(dp[j])))                    \\n                    for index in range(1, length):\\n                        dp[j][index] += dp[i][index - 1]\\n                        dp[j][index] %= mod\\n            return dp[-1][-1] if len(dp[-1]) == (k + 1) else 0\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        mod = 10 ** 9 + 7\\n        n = len(s)\\n        prime = {\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n        if s[0] in prime and s[-1] not in prime:\\n            op = []\\n            for i in range(1, n - 1):\\n                if s[i] not in prime and s[i + 1] in prime:\\n                    op.append(i + 1)\\n            op.append(n)\\n            m = len(op)\\n            dp = [[] for _ in range(m)]\\n            pos = 0\\n            j = 0\\n            while j < m and op[j] - pos < minLength:\\n                j += 1\\n            if j < m:\\n                dp[j] = [0, 1]\\n            for i, pos in enumerate(op):\\n                if i:\\n                    length = len(dp[i - 1])\\n                    dp[i].extend([0] * (length - len(dp[i])))\\n                    for index in range(1, length):\\n                        dp[i][index] += dp[i - 1][index]\\n                        dp[i][index] %= mod\\n                while j < m and op[j] - pos < minLength:\\n                    j += 1\\n                if j < m:\\n                    length = min(k + 1, len(dp[i]) + 1)\\n                    dp[j].extend([0] * (length - len(dp[j])))                    \\n                    for index in range(1, length):\\n                        dp[j][index] += dp[i][index - 1]\\n                        dp[j][index] %= mod\\n            return dp[-1][-1] if len(dp[-1]) == (k + 1) else 0\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832491,
                "title": "my-solution",
                "content": "```\\n/**\\n * the dp solution is employed.\\n * let `n` be the length of the string `s`\\n * let `i`-beautiful partitions of a string `s` meet the following conditions,\\n * 1. `s` is partitioned into `i` non-intersecting substrings\\n * 2. each substring has a length of at least `minLength`\\n * 3. each substring starts with a prime digit and ends with a non-prime digit\\n *\\n * dp[i][j] stands for the number of `i`-beautiful partitions of\\n * the substring `s.substr(0, j)`,\\n * where `i` is in the range [0, `k`], both inclusive\\n *       `j` is in the range [0, `n`], both inclusive\\n *\\n * initial:\\n * dp[0][0] = 1\\n *\\n * induction:\\n * 1. if s[j - 1] is a prime digit, dp[i][j] = 0\\n * 2. otherwise,\\n *    dp[i][j] = dp[i - 1][j0] + dp[i - 1][j1] + ... + dp[i - 1][jk]\\n *    where `jl` is in the range [0, j - minLength], both inclusive, and\\n *          `s[jl]` is a prime digit\\n *    one observation is as below,\\n *    dp[i][j] = dp[i - 1][j0] + dp[i - 1][j1] + ... + dp[i - 1][jk]\\n *             = dp[i][j - 1] + (s[i] is a prime digit ? dp[i - 1][j - minLength] : 0)\\n *\\n * target:\\n * dp[k][n]\\n *\\n * Time Complexity: O(k * n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  int beautifulPartitions(const string &s, const int k, const int minLength) {\\n    constexpr int range = 2;\\n    constexpr bool is_prime[] = {false, false, true, true, false, true, false, true, false, false};\\n    constexpr char zero = \\'0\\';\\n    constexpr int mod = 1000000007;\\n    const int n = static_cast<int>(s.size());\\n    if (!is_prime[s.front() - zero] || is_prime[s.back() - zero] || k * minLength > n) {\\n      return 0;\\n    }\\n\\n    int dp[range][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = 1;\\n    for (int partitions = 1; partitions < k + 1; ++partitions) {\\n      int sum = 0;\\n      for (int length = minLength; length < n - ((k - partitions) * minLength) + 1; ++length) {\\n        const int start_index = length - minLength;\\n        if (is_prime[s[start_index] - zero]) {\\n          sum = (sum + dp[previous][start_index]) % mod;\\n        }\\n        if (length >= partitions * minLength && !is_prime[s[length - 1] - zero]) {\\n          dp[current][length] = sum;\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][n];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * the dp solution is employed.\\n * let `n` be the length of the string `s`\\n * let `i`-beautiful partitions of a string `s` meet the following conditions,\\n * 1. `s` is partitioned into `i` non-intersecting substrings\\n * 2. each substring has a length of at least `minLength`\\n * 3. each substring starts with a prime digit and ends with a non-prime digit\\n *\\n * dp[i][j] stands for the number of `i`-beautiful partitions of\\n * the substring `s.substr(0, j)`,\\n * where `i` is in the range [0, `k`], both inclusive\\n *       `j` is in the range [0, `n`], both inclusive\\n *\\n * initial:\\n * dp[0][0] = 1\\n *\\n * induction:\\n * 1. if s[j - 1] is a prime digit, dp[i][j] = 0\\n * 2. otherwise,\\n *    dp[i][j] = dp[i - 1][j0] + dp[i - 1][j1] + ... + dp[i - 1][jk]\\n *    where `jl` is in the range [0, j - minLength], both inclusive, and\\n *          `s[jl]` is a prime digit\\n *    one observation is as below,\\n *    dp[i][j] = dp[i - 1][j0] + dp[i - 1][j1] + ... + dp[i - 1][jk]\\n *             = dp[i][j - 1] + (s[i] is a prime digit ? dp[i - 1][j - minLength] : 0)\\n *\\n * target:\\n * dp[k][n]\\n *\\n * Time Complexity: O(k * n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  int beautifulPartitions(const string &s, const int k, const int minLength) {\\n    constexpr int range = 2;\\n    constexpr bool is_prime[] = {false, false, true, true, false, true, false, true, false, false};\\n    constexpr char zero = \\'0\\';\\n    constexpr int mod = 1000000007;\\n    const int n = static_cast<int>(s.size());\\n    if (!is_prime[s.front() - zero] || is_prime[s.back() - zero] || k * minLength > n) {\\n      return 0;\\n    }\\n\\n    int dp[range][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = 1;\\n    for (int partitions = 1; partitions < k + 1; ++partitions) {\\n      int sum = 0;\\n      for (int length = minLength; length < n - ((k - partitions) * minLength) + 1; ++length) {\\n        const int start_index = length - minLength;\\n        if (is_prime[s[start_index] - zero]) {\\n          sum = (sum + dp[previous][start_index]) % mod;\\n        }\\n        if (length >= partitions * minLength && !is_prime[s[length - 1] - zero]) {\\n          dp[current][length] = sum;\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][n];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832460,
                "title": "python-top-down-o-nk-solution-with-comparison",
                "content": "Before Diving Into the Optimal Solution, Let\\'s see a typical O(NNK) solution.\\n* The idea is recursively define a subslice by defining a start index of the current subslice as `idx`, and try all valid end indexes by using a loop.\\n\\n**Sub-Optimal Approach\\'s Code**\\n* Time Complexity: O(NNK)\\n* Memory Complexity: O(NK)\\n```\\nfrom functools import cache\\n\\nMODULO = 10**9 + 7\\n\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        N = len(s)\\n        primes = (\\'2\\', \\'3\\', \\'5\\', \\'7\\')\\n        \\n        @cache\\n        def count_valid_parts_from(idx, remaining): # O(NK) memory, O(NNK) Time.\\n            if idx == N:\\n                if remaining == 0:\\n                    return 1\\n                return 0\\n            \\n\\t\\t\\t# Early return.\\n            if remaining <= 0 or s[idx] not in primes:\\n                return 0\\n            \\n            local_sum = 0\\n            for next_start_idx in range(idx+minLength, N+1): \\n                if next_start_idx == N or s[next_start_idx-1] not in primes:\\n                    local_sum += count_valid_parts_from(next_start_idx, remaining-1) % MODULO\\n            return local_sum % MODULO\\n        \\n        # Main\\n        return count_valid_parts_from(0, k)\\n```\\n\\nThis is a typical form of Partitioning problem. But in this question, this will cause TLE.\\n\\n\\n**KeyInsight**\\n* We ONLY need to check the head of the subslice and the tail of the subslice. In that case, we don\\'t need to define subslices by loop since we don\\'t need to check the whole substring. \\n* Instead, We can reduce the time complexity by changing the local problem to \"Decide whether making the current index the last position of the current partition or not. \"\\n\\n**Optimal Approach\\'s Code**\\n\\n* Time Complexity: O(NK)\\n* Memory Complexity: O(NK)\\n\\n```\\nfrom functools import cache\\n\\nMODULO = 10**9 + 7\\n\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        N = len(s)\\n        primes = (\\'2\\', \\'3\\', \\'5\\', \\'7\\')\\n        \\n        @cache\\n        def split_patterns_from(end_idx, remaining): # N*k\\n            if end_idx == N-1: # This is the last partition. Handle as a base case.\\n                if s[end_idx] not in primes and remaining == 1:\\n                    return 1\\n                return 0\\n            \\n            if end_idx >= N or remaining <= 0: # Invalid case & Early return case.\\n                return 0\\n        \\n            # Decide splitting the current subslice here or not.\\n            local_sum = 0\\n            # Split case.\\n            if s[end_idx] not in primes and s[end_idx+1] in primes:\\n\\t\\t\\t\\t# Also ensuring the next subslice to have at least minLength characters.\\n                local_sum += split_patterns_from(end_idx+minLength, remaining-1) % MODULO\\n            # Non split case.\\n            local_sum += split_patterns_from(end_idx+1, remaining) % MODULO\\n            return local_sum % MODULO\\n        \\n        # Main\\n\\t\\t# Note: we can not check the first character by the above helper, so check it.\\n        return split_patterns_from(minLength-1, k) if s[0] in primes else 0\\n```\\n\\n**Runtime Result**\\n* Runtime: 1637 ms (100% Faster than others)\\n* Memory Usage: 334.6 MB\\n\\n\\n**Conclusion**\\n* Partitioning problems can have two forms of Recursion.\\n\\t1. Decide all subslice end indexes on every index\\n\\t\\t- This can be easier and faster if we had to verify all / most of the subslice elements.\\n\\t2. Decide whether to put a partition or not on every index.\\n\\t\\t- This can can be faster if we don\\'t need to judge whole substrings.\\n* In this question, form 2 will introduce a better result.\\n\\n\\nThank you.\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import cache\\n\\nMODULO = 10**9 + 7\\n\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        N = len(s)\\n        primes = (\\'2\\', \\'3\\', \\'5\\', \\'7\\')\\n        \\n        @cache\\n        def count_valid_parts_from(idx, remaining): # O(NK) memory, O(NNK) Time.\\n            if idx == N:\\n                if remaining == 0:\\n                    return 1\\n                return 0\\n            \\n\\t\\t\\t# Early return.\\n            if remaining <= 0 or s[idx] not in primes:\\n                return 0\\n            \\n            local_sum = 0\\n            for next_start_idx in range(idx+minLength, N+1): \\n                if next_start_idx == N or s[next_start_idx-1] not in primes:\\n                    local_sum += count_valid_parts_from(next_start_idx, remaining-1) % MODULO\\n            return local_sum % MODULO\\n        \\n        # Main\\n        return count_valid_parts_from(0, k)\\n```\n```\\nfrom functools import cache\\n\\nMODULO = 10**9 + 7\\n\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        N = len(s)\\n        primes = (\\'2\\', \\'3\\', \\'5\\', \\'7\\')\\n        \\n        @cache\\n        def split_patterns_from(end_idx, remaining): # N*k\\n            if end_idx == N-1: # This is the last partition. Handle as a base case.\\n                if s[end_idx] not in primes and remaining == 1:\\n                    return 1\\n                return 0\\n            \\n            if end_idx >= N or remaining <= 0: # Invalid case & Early return case.\\n                return 0\\n        \\n            # Decide splitting the current subslice here or not.\\n            local_sum = 0\\n            # Split case.\\n            if s[end_idx] not in primes and s[end_idx+1] in primes:\\n\\t\\t\\t\\t# Also ensuring the next subslice to have at least minLength characters.\\n                local_sum += split_patterns_from(end_idx+minLength, remaining-1) % MODULO\\n            # Non split case.\\n            local_sum += split_patterns_from(end_idx+1, remaining) % MODULO\\n            return local_sum % MODULO\\n        \\n        # Main\\n\\t\\t# Note: we can not check the first character by the above helper, so check it.\\n        return split_patterns_from(minLength-1, k) if s[0] in primes else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832429,
                "title": "c-bottom-up-dp-o-nk-time-o-n-space-55ms-beats-100",
                "content": "https://leetcode.com/submissions/detail/846762468/\\n```\\nclass Solution {\\n    enum { mod = int(1e9) + 7 };\\npublic:\\n    int beautifulPartitions(string s, int const k, int minLength) {\\n        const int n = s.size() - minLength + 1;\\n        vector<bool> data(s.size()); // is_prime\\n        for (int i = 0; i < s.size(); ++i) {\\n            char c = s[i] - \\'0\\';\\n            if (c == 2 || c == 3 || c == 5 || c == 7) data[i] = true;\\n        }\\n        if (!data.front() || data.back()) return 0;\\n        \\n        vector<int> dp(n), dp_next(n);\\n        dp[0] = 1;\\n        for (int i = 1; i < k; ++i) {\\n            int psum = 0;\\n            dp_next[0] = 0;\\n            for (int j = minLength; j < n; ++j) {\\n                psum = (psum + dp[j - minLength]) % mod;\\n                dp_next[j] = (!data[j-1] && data[j]) ? psum : 0;\\n            }\\n            swap(dp, dp_next);\\n        }\\n        return accumulate(dp.begin(), dp.end(), long(0)) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    enum { mod = int(1e9) + 7 };\\npublic:\\n    int beautifulPartitions(string s, int const k, int minLength) {\\n        const int n = s.size() - minLength + 1;\\n        vector<bool> data(s.size()); // is_prime\\n        for (int i = 0; i < s.size(); ++i) {\\n            char c = s[i] - \\'0\\';\\n            if (c == 2 || c == 3 || c == 5 || c == 7) data[i] = true;\\n        }\\n        if (!data.front() || data.back()) return 0;\\n        \\n        vector<int> dp(n), dp_next(n);\\n        dp[0] = 1;\\n        for (int i = 1; i < k; ++i) {\\n            int psum = 0;\\n            dp_next[0] = 0;\\n            for (int j = minLength; j < n; ++j) {\\n                psum = (psum + dp[j - minLength]) % mod;\\n                dp_next[j] = (!data[j-1] && data[j]) ? psum : 0;\\n            }\\n            swap(dp, dp_next);\\n        }\\n        return accumulate(dp.begin(), dp.end(), long(0)) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832418,
                "title": "python3-dp-accumulative-sum-o-n-k",
                "content": "# Approach\\nDynamic programming: \\ndp[i][k] is the number of ways to split string s[0:i+1] to k partitions\\ndp[i][k] = sum(dp[j-1][k-1]) with s[j][i+1] is a valid substring\\ndp[-1][0] = 1\\n\\nsum(dp[j-1][k-1]) can be optimized by an accumulative sum\\nsum[k] = sum(dp[x][k]) for x from 0 -> current possition\\n\\n# Complexity\\n- Time complexity: O(nk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nk)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        primes = {\\'2\\',\\'3\\',\\'5\\',\\'7\\'}\\n        # prunning\\n        if len(s) < k*minLength or s[0] not in primes or s[-1] in primes:\\n            return 0\\n\\n        dd_int = functools.partial(defaultdict, int)\\n        dp = defaultdict(dd_int)\\n        dp[-1][0] = 1\\n        stack = []\\n        MOD = 10**9+7\\n        accSum = [0] * (k+1)\\n        j = 0        \\n        \\n        for i in range(len(s)):\\n            if s[i] in primes:\\n                if s[i-1] not in primes: # prunning\\n                    stack.append(i)\\n                continue\\n\\n            while j < len(stack):\\n                if i-stack[j]+1 < minLength:\\n                    break\\n                    \\n                for u in range(k+1):\\n                    accSum[u] = (accSum[u] + dp[stack[j]-1][u]) % MOD\\n                    \\n                j += 1\\n\\n            for u in range(1, k+1):\\n                dp[i][u] = accSum[u-1]\\n                \\n        \\n        return dp[len(s)-1][k]\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        primes = {\\'2\\',\\'3\\',\\'5\\',\\'7\\'}\\n        # prunning\\n        if len(s) < k*minLength or s[0] not in primes or s[-1] in primes:\\n            return 0\\n\\n        dd_int = functools.partial(defaultdict, int)\\n        dp = defaultdict(dd_int)\\n        dp[-1][0] = 1\\n        stack = []\\n        MOD = 10**9+7\\n        accSum = [0] * (k+1)\\n        j = 0        \\n        \\n        for i in range(len(s)):\\n            if s[i] in primes:\\n                if s[i-1] not in primes: # prunning\\n                    stack.append(i)\\n                continue\\n\\n            while j < len(stack):\\n                if i-stack[j]+1 < minLength:\\n                    break\\n                    \\n                for u in range(k+1):\\n                    accSum[u] = (accSum[u] + dp[stack[j]-1][u]) % MOD\\n                    \\n                j += 1\\n\\n            for u in range(1, k+1):\\n                dp[i][u] = accSum[u-1]\\n                \\n        \\n        return dp[len(s)-1][k]\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832335,
                "title": "javascript-dp-561ms",
                "content": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(0); d.push(t); } return d; };\\n\\nconst mod = 1e9 + 7;\\nconst beautifulPartitions = (s, k, minLength) => {\\n    let n = s.length, primes = new Set([\\'2\\', \\'3\\', \\'5\\', \\'7\\']), dp = initialize2DArray(k + 1, n + 1);\\n    if (!primes.has(s[0]) || primes.has(s[n - 1])) return 0;\\n    s = s + \\'2\\';\\n    dp[0][0] = 1;\\n    for (let i = 0; i < k; i++) {\\n        let cnt = 0;\\n        for (let j = 1; j <= n; j++) {\\n            if (j - minLength >= 0) {\\n                cnt += dp[i][j - minLength];\\n                cnt %= mod;\\n            }\\n            if (primes.has(s[j]) && !primes.has(s[j - 1])) dp[i + 1][j] = cnt;\\n        }\\n\\n    }\\n    return dp[k][n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(0); d.push(t); } return d; };\\n\\nconst mod = 1e9 + 7;\\nconst beautifulPartitions = (s, k, minLength) => {\\n    let n = s.length, primes = new Set([\\'2\\', \\'3\\', \\'5\\', \\'7\\']), dp = initialize2DArray(k + 1, n + 1);\\n    if (!primes.has(s[0]) || primes.has(s[n - 1])) return 0;\\n    s = s + \\'2\\';\\n    dp[0][0] = 1;\\n    for (let i = 0; i < k; i++) {\\n        let cnt = 0;\\n        for (let j = 1; j <= n; j++) {\\n            if (j - minLength >= 0) {\\n                cnt += dp[i][j - minLength];\\n                cnt %= mod;\\n            }\\n            if (primes.has(s[j]) && !primes.has(s[j - 1])) dp[i + 1][j] = cnt;\\n        }\\n\\n    }\\n    return dp[k][n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832302,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tusing ll = long long;\\n    static const int mod = 1e9+7;\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        vector<vector<ll>> memo(s.size(), vector<ll>(k+1, -1));\\n        return dp(s, 0, k, minLength, memo);\\n    }\\n\\n    ll dp(string& s, int idx, int k, int minLength, vector<vector<ll>>& memo) {\\n        if(k == 0) return idx == s.size() ? 1 : 0;\\n        if(idx >= s.size() || s[idx] == \\'1\\' || s[idx] == \\'4\\' || s[idx] == \\'6\\' || s[idx] == \\'8\\' || s[idx] == \\'9\\') return 0;\\n        if(memo[idx][k] != -1) return memo[idx][k];\\n        ll res = 0;\\n        for(int i = idx+minLength-1; i < s.size() && (s.size()-i >= (k-1)*minLength); i++) {\\n            if((s[i] == \\'1\\' || s[i] == \\'4\\' || s[i] == \\'6\\' || s[i] == \\'8\\' || s[i] == \\'9\\')) res = (res + dp(s, i+1, k-1, minLength, memo))%mod;\\n        }\\n        return memo[idx][k] = res;\\n    }\\n\\t\\t\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tusing ll = long long;\\n    static const int mod = 1e9+7;\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        vector<vector<ll>> memo(s.size(), vector<ll>(k+1, -1));\\n        return dp(s, 0, k, minLength, memo);\\n    }\\n\\n    ll dp(string& s, int idx, int k, int minLength, vector<vector<ll>>& memo) {\\n        if(k == 0) return idx == s.size() ? 1 : 0;\\n        if(idx >= s.size() || s[idx] == \\'1\\' || s[idx] == \\'4\\' || s[idx] == \\'6\\' || s[idx] == \\'8\\' || s[idx] == \\'9\\') return 0;\\n        if(memo[idx][k] != -1) return memo[idx][k];\\n        ll res = 0;\\n        for(int i = idx+minLength-1; i < s.size() && (s.size()-i >= (k-1)*minLength); i++) {\\n            if((s[i] == \\'1\\' || s[i] == \\'4\\' || s[i] == \\'6\\' || s[i] == \\'8\\' || s[i] == \\'9\\')) res = (res + dp(s, i+1, k-1, minLength, memo))%mod;\\n        }\\n        return memo[idx][k] = res;\\n    }\\n\\t\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832291,
                "title": "c-dp-twopointer-o-kn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Smallest Beautiful Substring\\n\\nNotice that each **beautiful** string must be the combination of 1 or more substrings in the form of `A...AB...B`, where `A` is any **Prime** number and `B` is any **non-Prime** number.\\n\\nThus, for a given string we can find all the **smallest beautiful substrings**. Their **length** is the only information we need in this question.\\n\\nExample: `23542185131` has 4 substrings `2354` `218` `51` `31`. Their lengths are `{4,3,2,2}`.\\n\\n## Dynamic Programming\\n\\nThe question is equivelent to : Given an array of positive integers `p`, find the number of ways to split `p` into `k` subarrays, so that each subarray has its inner sum >=`minLength`.\\n\\nThis is a classic DP problem. Let $$f(n, k)$$ be the number of ways to split `p[0:n]` into `k` beautiful subarrays, then we have\\n\\n$ f(n,k) = f(m-1,k-1) + f(m-2,k-1) + ... + f(0,k-1) = \\\\sum_{i=0}^{m-1} f(i,k-1) $\\n\\nwhere `m` is the largest index that satisty $$ sum(p[m:n]) \\\\ge minLength $$\\n\\nFinding `m` for each `n` is not difficult. This could be solved by a classic **Two Pointer** solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(k*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long int LLI;\\n    const LLI MOD = 1e9+7;\\n\\n    bool isPrime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n\\n    vector<int> substringLengths(string s) {\\n        vector<int> lengths;\\n        int i = 0;\\n        for (int j=1; j<s.size(); j++) {\\n            if (isPrime(s[j]) && !isPrime(s[j-1])) {\\n                lengths.push_back(j - i);\\n                i = j;\\n            }\\n        }\\n        lengths.push_back(s.size() - i);\\n        return lengths;\\n    }\\n\\n    vector<int> latestStartIndex(vector<int> lengths, int minLength) {\\n        int n = lengths.size();\\n        vector<int> starts(n, -1);\\n        int tmpLength = 0;\\n        for (int i=n - 1, j=n - 1; i >= 0; i-- ) {\\n            tmpLength += lengths[i];\\n            while (tmpLength >= minLength) {\\n                tmpLength -= lengths[j];\\n                starts[j] = i;\\n                j--;\\n            }\\n        }\\n        return starts;\\n    }\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if (!isPrime(s[0]) || isPrime(s[s.size()-1])) return 0;\\n\\n        vector<int> lengths = substringLengths(s);\\n        vector<int> starts = latestStartIndex(lengths, minLength);\\n\\n        int n = lengths.size();\\n        vector<vector<LLI>> results(n, vector<LLI>(k));\\n        for (int sum=0, i=0; i<n; i++) {\\n            sum += lengths[i];\\n            if (sum >= minLength) results[i][0] = 1;\\n        }\\n\\n        for (int j=1; j<k; j++) {\\n            for (int i=1; i<n; i++) {\\n                results[i][j-1] += results[i-1][j-1];\\n                results[i][j-1] %= MOD;\\n            }\\n            for (int i=0; i<n; i++) {\\n                if (starts[i] < 1) {\\n                    results[i][j] = 0;\\n                } else {\\n                    results[i][j] = results[starts[i]-1][j-1];\\n                }\\n            }\\n        }\\n\\n        return results[n-1][k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int LLI;\\n    const LLI MOD = 1e9+7;\\n\\n    bool isPrime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n\\n    vector<int> substringLengths(string s) {\\n        vector<int> lengths;\\n        int i = 0;\\n        for (int j=1; j<s.size(); j++) {\\n            if (isPrime(s[j]) && !isPrime(s[j-1])) {\\n                lengths.push_back(j - i);\\n                i = j;\\n            }\\n        }\\n        lengths.push_back(s.size() - i);\\n        return lengths;\\n    }\\n\\n    vector<int> latestStartIndex(vector<int> lengths, int minLength) {\\n        int n = lengths.size();\\n        vector<int> starts(n, -1);\\n        int tmpLength = 0;\\n        for (int i=n - 1, j=n - 1; i >= 0; i-- ) {\\n            tmpLength += lengths[i];\\n            while (tmpLength >= minLength) {\\n                tmpLength -= lengths[j];\\n                starts[j] = i;\\n                j--;\\n            }\\n        }\\n        return starts;\\n    }\\n\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if (!isPrime(s[0]) || isPrime(s[s.size()-1])) return 0;\\n\\n        vector<int> lengths = substringLengths(s);\\n        vector<int> starts = latestStartIndex(lengths, minLength);\\n\\n        int n = lengths.size();\\n        vector<vector<LLI>> results(n, vector<LLI>(k));\\n        for (int sum=0, i=0; i<n; i++) {\\n            sum += lengths[i];\\n            if (sum >= minLength) results[i][0] = 1;\\n        }\\n\\n        for (int j=1; j<k; j++) {\\n            for (int i=1; i<n; i++) {\\n                results[i][j-1] += results[i-1][j-1];\\n                results[i][j-1] %= MOD;\\n            }\\n            for (int i=0; i<n; i++) {\\n                if (starts[i] < 1) {\\n                    results[i][j] = 0;\\n                } else {\\n                    results[i][j] = results[starts[i]-1][j-1];\\n                }\\n            }\\n        }\\n\\n        return results[n-1][k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832256,
                "title": "java-memoization-o-n-k-easily-explained",
                "content": "# Observations\\n- Every partion point i will not be prime and i+1 will be prime.\\n- No gap between partitions.\\n\\n# Intution & Approach\\n- Keep iterating the string with i;\\n- When i >= minLength, this can be a partition point.(only if !isPrime(s.charAt(i)) && isPrime(s.charAt(i + 1)) ) ;\\n- At every index i which satify above conditon, we have 2 choices -\\n- -  1. do not partion here [go(i + 1, k, s, minLength);]\\n- -  2. partion here [go(i + minLength, k - 1, s, minLength) ;]\\n- if(we are partioning then k--, and we should do i+ minLength so that partiton len is guarenteed to be >= minLength);\\n- and we add all the result from both the choices.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    int[][] dp;\\n    int MOD = 1000000007;\\n\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        int n = s.length();\\n        dp = new int[n + 5][k + 5];\\n        if (k == 1) {\\n            if (isPrime(s.charAt(0)) && !isPrime(s.charAt(s.length() - 1))) return 1;\\n            return 0;\\n        }\\n        for (int[] ints : dp) {\\n            Arrays.fill(ints, -1);\\n        }\\n        return go(minLength - 1, k, s, minLength);\\n    }\\n\\n    private int go(int i, int k, String s, int minLength) {\\n        if (i >= s.length()) return 0;\\n        if (i == s.length() - 1) {\\n            return k == 1 && !isPrime(s.charAt(s.length() - 1)) ? 1 : 0;\\n        }\\n        if (k < 1) return 0;\\n        if (dp[i][k] != -1) return dp[i][k];\\n        long ans = go(i + 1, k, s, minLength);\\n        if (!isPrime(s.charAt(i)) && isPrime(s.charAt(i + 1))) {\\n            ans = (ans % MOD + go(i + minLength, k - 1, s, minLength) % MOD) % MOD;\\n        }\\n        return dp[i][k] = (int) (ans % MOD);\\n    }\\n\\n    boolean isPrime(char x) {\\n        return x == \\'2\\' || x == \\'3\\' || x == \\'5\\' || x == \\'7\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    int[][] dp;\\n    int MOD = 1000000007;\\n\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        int n = s.length();\\n        dp = new int[n + 5][k + 5];\\n        if (k == 1) {\\n            if (isPrime(s.charAt(0)) && !isPrime(s.charAt(s.length() - 1))) return 1;\\n            return 0;\\n        }\\n        for (int[] ints : dp) {\\n            Arrays.fill(ints, -1);\\n        }\\n        return go(minLength - 1, k, s, minLength);\\n    }\\n\\n    private int go(int i, int k, String s, int minLength) {\\n        if (i >= s.length()) return 0;\\n        if (i == s.length() - 1) {\\n            return k == 1 && !isPrime(s.charAt(s.length() - 1)) ? 1 : 0;\\n        }\\n        if (k < 1) return 0;\\n        if (dp[i][k] != -1) return dp[i][k];\\n        long ans = go(i + 1, k, s, minLength);\\n        if (!isPrime(s.charAt(i)) && isPrime(s.charAt(i + 1))) {\\n            ans = (ans % MOD + go(i + minLength, k - 1, s, minLength) % MOD) % MOD;\\n        }\\n        return dp[i][k] = (int) (ans % MOD);\\n    }\\n\\n    boolean isPrime(char x) {\\n        return x == \\'2\\' || x == \\'3\\' || x == \\'5\\' || x == \\'7\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832208,
                "title": "c-o-nk-bottom-up-dp",
                "content": "dp[i][j] = sum of number of ways to split str[1..i], str[1..i-1], ..., str[1,1] into j substrings. Let me know if solution is not clear and I\\'ll add more explanation. \\n\\n```\\nclass Solution {\\npublic:\\n    bool is_prime(char ch){\\n        int dig=ch-\\'0\\';\\n        if(dig==2 || dig==3 || dig==5 || dig==7){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int beautifulPartitions(string s, int p, int m) {\\n        int n=s.size(), MOD=1e9+7;\\n        vector<vector<int> > dp(n+1, vector<int>(p+1, 0));\\n        dp[0][0]=is_prime(s[0]);\\n        for(int i=1; i<=n; i++) dp[i][0]+=dp[i-1][0];\\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=p; j++){\\n                if(!is_prime(s[i-1]) && i-m>=0 && (i==n || is_prime(s[i]))) dp[i][j]=(dp[i][j]+dp[i-m][j-1])%MOD;\\n                dp[i][j]=(dp[i][j]+dp[i-1][j])%MOD;\\n            }\\n        }\\n        return (dp[n][p]+MOD-dp[n-1][p])%MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_prime(char ch){\\n        int dig=ch-\\'0\\';\\n        if(dig==2 || dig==3 || dig==5 || dig==7){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int beautifulPartitions(string s, int p, int m) {\\n        int n=s.size(), MOD=1e9+7;\\n        vector<vector<int> > dp(n+1, vector<int>(p+1, 0));\\n        dp[0][0]=is_prime(s[0]);\\n        for(int i=1; i<=n; i++) dp[i][0]+=dp[i-1][0];\\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=p; j++){\\n                if(!is_prime(s[i-1]) && i-m>=0 && (i==n || is_prime(s[i]))) dp[i][j]=(dp[i][j]+dp[i-m][j-1])%MOD;\\n                dp[i][j]=(dp[i][j]+dp[i-1][j])%MOD;\\n            }\\n        }\\n        return (dp[n][p]+MOD-dp[n-1][p])%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832183,
                "title": "javascript-bottom-up-dp-o-nk",
                "content": "Basically 2D DP that we can turn into 1D.\\n\\nJust to define a couple terms:\\n- A valid start is a prime with a non-prime before it or it\\'s the beginning of the string\\n- A valid end is a non-prime with either a prime after it or it\\'s the end of the string.\\n\\nPick valid end of a partition. The number of ways we can partition using that end\\nis the the number of ways we can partition up to right before all the starts\\nat least ```minLength``` away from that ending.\\n\\n```\\nminLength = 4\\ns = \"start\"\\ne = \"end\"\\n sseseessee \\n |  |  |\\n -------->|  // there are 3 valid starts that can be used in the partition with the last end\\n\\t\\t\\t // sum up the number of ways you can reach the endings right before these\\n\\t\\t\\t // starts from the previous partition\\n```\\n\\nSo for each partition, at each valid end, add up all the valid ways you can reach each valid end right before\\nthe starts in range of the current end from the previous partiton.\\n\\nI\\'ll use a sliding window to keep tally of the sum of ways you can reach each end in range, and\\ninstead of using a 2D array to track the number of ways to partition between partitions, \\nwe\\'ll simplify and use two 1D arrays since we only care about the current and previous partition.\\n\\n\\n```javascript\\nvar beautifulPartitions = function(s, k, minLength) {\\n  if (!/[2357]/.test(s[0]) || !/[14689]/.test(s.at(-1))) return 0;\\n  \\n  const ends = [...s]\\n    .map((_, i) => i)\\n    .filter((i) => /[14689]/.test(s[i]) && /[^14689]/.test(s[i + 1]));\\n\\n  const MOD = 10 ** 9 + 7;\\n  let curr = ends.map((i) => i >= minLength - 1 ? 1 : 0);\\n  let next = ends.map(() => 0);\\n  \\n  for (let partition = 1; partition < k; partition += 1) {\\n    let p = 0;\\n    let numWays = 0;\\n    \\n    for (let i = 0; i < ends.length; i += 1) {\\n      next[i] = 0;\\n      while (p <= i && ends[i] - ends[p] >= minLength) {\\n        numWays = (numWays + curr[p]) % MOD;\\n        p += 1;\\n      }\\n      \\n      next[i] = numWays;\\n    }\\n    \\n    [curr, next] = [next, curr];\\n  }\\n  \\n  return curr.at(-1);\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```minLength```\n```\\nminLength = 4\\ns = \"start\"\\ne = \"end\"\\n sseseessee \\n |  |  |\\n -------->|  // there are 3 valid starts that can be used in the partition with the last end\\n\\t\\t\\t // sum up the number of ways you can reach the endings right before these\\n\\t\\t\\t // starts from the previous partition\\n```\n```javascript\\nvar beautifulPartitions = function(s, k, minLength) {\\n  if (!/[2357]/.test(s[0]) || !/[14689]/.test(s.at(-1))) return 0;\\n  \\n  const ends = [...s]\\n    .map((_, i) => i)\\n    .filter((i) => /[14689]/.test(s[i]) && /[^14689]/.test(s[i + 1]));\\n\\n  const MOD = 10 ** 9 + 7;\\n  let curr = ends.map((i) => i >= minLength - 1 ? 1 : 0);\\n  let next = ends.map(() => 0);\\n  \\n  for (let partition = 1; partition < k; partition += 1) {\\n    let p = 0;\\n    let numWays = 0;\\n    \\n    for (let i = 0; i < ends.length; i += 1) {\\n      next[i] = 0;\\n      while (p <= i && ends[i] - ends[p] >= minLength) {\\n        numWays = (numWays + curr[p]) % MOD;\\n        p += 1;\\n      }\\n      \\n      next[i] = numWays;\\n    }\\n    \\n    [curr, next] = [next, curr];\\n  }\\n  \\n  return curr.at(-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832131,
                "title": "dp-bottom-up-o-nk",
                "content": "my first submission was top-down and failed to optimize that solution. got TLE. then I rewrite it in an iterative way.\\n**state:** f[i][k]: answer from index I to end of the string, splitting into k substring.\\n**state trans:** f[i][k]=sum(f[j][k-1]) where i+minLength<=j<=s.length && s[j-1] is non-prime && s[j] is prime.\\nnote that for those j not satisfying \"s[j-1] is non-prime && s[j] is prime\", we have f[j][k-1]=0. so we can simply calculate a suffix sum array.\\n\\npay attention to the boundary.\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    bool prime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n    int beautifulPartitions(string s, int kk, int minLength) {\\n        if (kk * minLength > s.length()) return 0;\\n        vector<vector<long long>> f(s.length() + 1, vector<long long>(kk + 1, 0)); // idx, k\\n\\n        f[s.length()][0] = !prime(s[s.length()-1]);\\n        \\n        for (int k = 1; k <= kk; k++) {\\n            long long sum=0ll;\\n            for (int i = s.length() - minLength; i >= 0; i--) {\\n                sum=(sum+f[i+minLength][k-1])%mod;\\n                if (prime(s[i]) && (i == 0 || !prime(s[i - 1])))\\n                    f[i][k] = (sum + f[i][k]) % mod;\\n                \\n            }\\n        }\\n        return f[0][kk];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    bool prime(char c) {\\n        return c == \\'2\\' || c == \\'3\\' || c == \\'5\\' || c == \\'7\\';\\n    }\\n    int beautifulPartitions(string s, int kk, int minLength) {\\n        if (kk * minLength > s.length()) return 0;\\n        vector<vector<long long>> f(s.length() + 1, vector<long long>(kk + 1, 0)); // idx, k\\n\\n        f[s.length()][0] = !prime(s[s.length()-1]);\\n        \\n        for (int k = 1; k <= kk; k++) {\\n            long long sum=0ll;\\n            for (int i = s.length() - minLength; i >= 0; i--) {\\n                sum=(sum+f[i+minLength][k-1])%mod;\\n                if (prime(s[i]) && (i == 0 || !prime(s[i - 1])))\\n                    f[i][k] = (sum + f[i][k]) % mod;\\n                \\n            }\\n        }\\n        return f[0][kk];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832107,
                "title": "c-simple-dp-o-n-k",
                "content": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if (!isPrime(s[0]) || isPrime(s.back())) return 0;\\n        \\n        s += \\'2\\'; //\\n        \\n        int n = s.size(), mod = (int)1e9 + 7;\\n        vector<vector<long>> dp(k + 1, vector<long>(n, 0L));\\n        dp[0][0] = 1L;\\n        for (int i = 0; i < k; ++i) {\\n            long cnt = 0L;\\n            for (int j = 1; j < n; ++j) {\\n                if (j >= minLength) {\\n                    cnt += dp[i][j - minLength];\\n                    cnt %= mod;\\n                }\\n                if (isPrime(s[j]) && !isPrime(s[j - 1])) {\\n                    dp[i + 1][j] = cnt;\\n                }\\n            }\\n        }\\n        return (int)dp[k][n - 1];\\n    }\\n    \\n    bool isPrime(char x) {\\n        return x == \\'2\\' || x == \\'3\\' || x == \\'5\\' || x == \\'7\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if (!isPrime(s[0]) || isPrime(s.back())) return 0;\\n        \\n        s += \\'2\\'; //\\n        \\n        int n = s.size(), mod = (int)1e9 + 7;\\n        vector<vector<long>> dp(k + 1, vector<long>(n, 0L));\\n        dp[0][0] = 1L;\\n        for (int i = 0; i < k; ++i) {\\n            long cnt = 0L;\\n            for (int j = 1; j < n; ++j) {\\n                if (j >= minLength) {\\n                    cnt += dp[i][j - minLength];\\n                    cnt %= mod;\\n                }\\n                if (isPrime(s[j]) && !isPrime(s[j - 1])) {\\n                    dp[i + 1][j] = cnt;\\n                }\\n            }\\n        }\\n        return (int)dp[k][n - 1];\\n    }\\n    \\n    bool isPrime(char x) {\\n        return x == \\'2\\' || x == \\'3\\' || x == \\'5\\' || x == \\'7\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832091,
                "title": "why-does-this-give-tle-resolved-python-time-limits-are-too-strict",
                "content": "This solution gave TLE. seems like a well within O(nk) solution.\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n=len(s)\\n        primes=list(\"2357\")\\n        \\n        if s[-1] in primes or s[0] not in primes: return 0\\n        if n<k*minLength: return 0\\n        indices=[]\\n        for i in range(n-1):\\n            if s[i] not in primes and s[i+1] in primes:\\n                indices.append(i)\\n        indices.append(n-1)\\n                \\n        @cache\\n        def rec(idx,cuts):\\n            if idx==n: \\n                return cuts==k\\n            tmp=0\\n            for i in indices:\\n                if i-idx+1>=minLength:\\n                    tmp=(rec(i+1,cuts+1)+tmp)%(10**9+7)\\n            return tmp\\n        return rec(0,0)\\n```\\n\\nAccpeted Code:\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n=len(s)\\n        s=list(s)\\n        primes={\"2\",\"3\",\"5\",\"7\"}\\n        \\n        if s[-1] in primes or s[0] not in primes: return 0\\n        if n<k*minLength: return 0\\n        indices=[0]\\n        for i in range(n-1):\\n            if s[i] not in primes and s[i+1] in primes:\\n                indices.append(i+1)\\n                \\n        @cache\\n        def rec(i,cuts):\\n            if cuts==1: \\n                return int(indices[i]+minLength<=n)\\n            tmp=0\\n            for j in range(i+1,len(indices)-cuts+2):\\n                if indices[j]-indices[i]>=minLength:\\n                    tmp=(rec(j,cuts-1)+tmp)%(10**9+7)\\n            return tmp\\n        return rec(0,k)\\n        \\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n=len(s)\\n        primes=list(\"2357\")\\n        \\n        if s[-1] in primes or s[0] not in primes: return 0\\n        if n<k*minLength: return 0\\n        indices=[]\\n        for i in range(n-1):\\n            if s[i] not in primes and s[i+1] in primes:\\n                indices.append(i)\\n        indices.append(n-1)\\n                \\n        @cache\\n        def rec(idx,cuts):\\n            if idx==n: \\n                return cuts==k\\n            tmp=0\\n            for i in indices:\\n                if i-idx+1>=minLength:\\n                    tmp=(rec(i+1,cuts+1)+tmp)%(10**9+7)\\n            return tmp\\n        return rec(0,0)\\n```\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n=len(s)\\n        s=list(s)\\n        primes={\"2\",\"3\",\"5\",\"7\"}\\n        \\n        if s[-1] in primes or s[0] not in primes: return 0\\n        if n<k*minLength: return 0\\n        indices=[0]\\n        for i in range(n-1):\\n            if s[i] not in primes and s[i+1] in primes:\\n                indices.append(i+1)\\n                \\n        @cache\\n        def rec(i,cuts):\\n            if cuts==1: \\n                return int(indices[i]+minLength<=n)\\n            tmp=0\\n            for j in range(i+1,len(indices)-cuts+2):\\n                if indices[j]-indices[i]>=minLength:\\n                    tmp=(rec(j,cuts-1)+tmp)%(10**9+7)\\n            return tmp\\n        return rec(0,k)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832074,
                "title": "c-dp-prefix-sum-optimization-o-kn-2-to-o-kn",
                "content": "# DP\\ndp[i, j] - partition of string s into i non-intersecting substrings starting from index j\\n\\n# Complexity\\n- Time complexity: $$O(kn^2)$$\\n- Space complexity: $$O(kn)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    private const int mod = 1_000_000_007;\\n\\n    private ISet<char> prime;\\n\\n    public int BeautifulPartitions(string s, int k, int minLength)\\n    {\\n        int n = s.Length;\\n\\n        prime = new HashSet<char>\\n        {\\n            \\'2\\',\\n            \\'3\\',\\n            \\'5\\',\\n            \\'7\\'\\n        };\\n\\n        int[,] dp = new int[k + 1, n];\\n\\n        minLength = Math.Max(2, minLength);\\n\\n        for (int f = n - 2; f >= 0; f--)\\n        {\\n            if (prime.Contains(s[f]) && !prime.Contains(s[n - 1]) && n - f >= minLength)\\n            {\\n                dp[1, f] = 1;\\n            }\\n        }\\n\\n        for (int i = 2; i <= k; i++)\\n        {\\n            for (int f = n - 2; f >= 0; f--)\\n            {\\n                if (!prime.Contains(s[f]))\\n                {\\n                    continue;\\n                }\\n\\n                for (int e = f + minLength - 1; e < n - (i - 1) * minLength; e++)\\n                {\\n                    if (!prime.Contains(s[e]))\\n                    {\\n                        dp[i, f] = (dp[i, f] + dp[i - 1, e + 1]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[k, 0];\\n    }\\n}\\n```\\n\\n# DP + Prefix Sum\\ndp[i, j] - partition of string s into i non-intersecting substrings starting from index j\\nsuffix[i, j] - suffix sum of partition of string s into i non-intersecting substrings starting from index j with non-prime digit at index j-1\\n\\n# Complexity\\n- Time complexity: $$O(kn)$$\\n- Space complexity: $$O(kn)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    private const int mod = 1_000_000_007;\\n\\n    private ISet<char> prime;\\n\\n    public int BeautifulPartitions(string s, int k, int minLength)\\n    {\\n        int n = s.Length;\\n\\n        prime = new HashSet<char>\\n        {\\n            \\'2\\',\\n            \\'3\\',\\n            \\'5\\',\\n            \\'7\\'\\n        };\\n\\n        int[,] dp = new int[k + 1, n];\\n        int[,] suffix = new int[k + 1, n];\\n\\n        minLength = Math.Max(2, minLength);\\n\\n        int prev = 0;\\n        for (int f = n - 2; f >= 0; f--)\\n        {\\n            if (prime.Contains(s[f]) && !prime.Contains(s[n - 1]) && n - f >= minLength)\\n            {\\n                dp[1, f] = 1;\\n            }\\n\\n            if (f == 0 || !prime.Contains(s[f - 1]))\\n            {\\n                prev = (dp[1, f] + prev) % mod;\\n            }\\n            suffix[1, f] = prev;\\n        }\\n\\n        int start;\\n        int end;\\n        for (int i = 2; i <= k; i++)\\n        {\\n            prev = 0;\\n            for (int f = n - 2; f >= 0; f--)\\n            {\\n                start = Math.Min(n - 1, f + minLength);\\n                end = n - (i - 2) * minLength;\\n\\n                if (prime.Contains(s[f]) && start < end)\\n                {\\n                    dp[i, f] = (dp[i, f] + suffix[i - 1, start]) % mod;\\n                    if (end < n)\\n                    {\\n                        dp[i, f] = (dp[i, f] - suffix[i - 1, end]) % mod;\\n                    }\\n                }\\n\\n                if (f == 0 || !prime.Contains(s[f - 1]))\\n                {\\n                    prev = (dp[i, f] + prev) % mod;\\n                }\\n                suffix[i, f] = prev;\\n            }\\n        }\\n\\n        return dp[k, 0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private const int mod = 1_000_000_007;\\n\\n    private ISet<char> prime;\\n\\n    public int BeautifulPartitions(string s, int k, int minLength)\\n    {\\n        int n = s.Length;\\n\\n        prime = new HashSet<char>\\n        {\\n            \\'2\\',\\n            \\'3\\',\\n            \\'5\\',\\n            \\'7\\'\\n        };\\n\\n        int[,] dp = new int[k + 1, n];\\n\\n        minLength = Math.Max(2, minLength);\\n\\n        for (int f = n - 2; f >= 0; f--)\\n        {\\n            if (prime.Contains(s[f]) && !prime.Contains(s[n - 1]) && n - f >= minLength)\\n            {\\n                dp[1, f] = 1;\\n            }\\n        }\\n\\n        for (int i = 2; i <= k; i++)\\n        {\\n            for (int f = n - 2; f >= 0; f--)\\n            {\\n                if (!prime.Contains(s[f]))\\n                {\\n                    continue;\\n                }\\n\\n                for (int e = f + minLength - 1; e < n - (i - 1) * minLength; e++)\\n                {\\n                    if (!prime.Contains(s[e]))\\n                    {\\n                        dp[i, f] = (dp[i, f] + dp[i - 1, e + 1]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[k, 0];\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    private const int mod = 1_000_000_007;\\n\\n    private ISet<char> prime;\\n\\n    public int BeautifulPartitions(string s, int k, int minLength)\\n    {\\n        int n = s.Length;\\n\\n        prime = new HashSet<char>\\n        {\\n            \\'2\\',\\n            \\'3\\',\\n            \\'5\\',\\n            \\'7\\'\\n        };\\n\\n        int[,] dp = new int[k + 1, n];\\n        int[,] suffix = new int[k + 1, n];\\n\\n        minLength = Math.Max(2, minLength);\\n\\n        int prev = 0;\\n        for (int f = n - 2; f >= 0; f--)\\n        {\\n            if (prime.Contains(s[f]) && !prime.Contains(s[n - 1]) && n - f >= minLength)\\n            {\\n                dp[1, f] = 1;\\n            }\\n\\n            if (f == 0 || !prime.Contains(s[f - 1]))\\n            {\\n                prev = (dp[1, f] + prev) % mod;\\n            }\\n            suffix[1, f] = prev;\\n        }\\n\\n        int start;\\n        int end;\\n        for (int i = 2; i <= k; i++)\\n        {\\n            prev = 0;\\n            for (int f = n - 2; f >= 0; f--)\\n            {\\n                start = Math.Min(n - 1, f + minLength);\\n                end = n - (i - 2) * minLength;\\n\\n                if (prime.Contains(s[f]) && start < end)\\n                {\\n                    dp[i, f] = (dp[i, f] + suffix[i - 1, start]) % mod;\\n                    if (end < n)\\n                    {\\n                        dp[i, f] = (dp[i, f] - suffix[i - 1, end]) % mod;\\n                    }\\n                }\\n\\n                if (f == 0 || !prime.Contains(s[f - 1]))\\n                {\\n                    prev = (dp[i, f] + prev) % mod;\\n                }\\n                suffix[i, f] = prev;\\n            }\\n        }\\n\\n        return dp[k, 0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832064,
                "title": "o-nk-time-complexity-o-n-space-complexity-dp",
                "content": "# Intuition\\ndp[i][j] denotes the number ways to partition the string into number of j substrings using the first i chars in s.\\n\\nUse rotatary array to reduce space complexity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nk)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n# Code\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n = len(s)\\n        mod = 10 ** 9 + 7\\n        if k * minLength > n:\\n            return 0\\n\\n\\n        dp = [[0] * (2) for _ in range(n+1)]\\n        dp[0][0] = 1\\n        prime_indices = [i + 1 for i in range(n) if s[i] in \\'2357\\']\\n        m = len(prime_indices)\\n        \\n\\n        for j in range(1, k + 1):\\n            prefix_sum = 0\\n            left = 0\\n        \\n            for i in range(n + 1):\\n                if i < j * minLength:\\n                    dp[i][j%2] = 0\\n                    continue\\n                if s[i - 1] in \\'2357\\':\\n                    dp[i][j%2] = 0\\n                    continue\\n                while left < m and i - prime_indices[left] + 1 >= minLength:\\n                    prefix_sum += dp[prime_indices[left] - 1][(j - 1)%2]\\n                    left += 1\\n                dp[i][j%2] = prefix_sum\\n                dp[i][j%2] %= mod\\n\\n        return dp[-1][k%2] % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        n = len(s)\\n        mod = 10 ** 9 + 7\\n        if k * minLength > n:\\n            return 0\\n\\n\\n        dp = [[0] * (2) for _ in range(n+1)]\\n        dp[0][0] = 1\\n        prime_indices = [i + 1 for i in range(n) if s[i] in \\'2357\\']\\n        m = len(prime_indices)\\n        \\n\\n        for j in range(1, k + 1):\\n            prefix_sum = 0\\n            left = 0\\n        \\n            for i in range(n + 1):\\n                if i < j * minLength:\\n                    dp[i][j%2] = 0\\n                    continue\\n                if s[i - 1] in \\'2357\\':\\n                    dp[i][j%2] = 0\\n                    continue\\n                while left < m and i - prime_indices[left] + 1 >= minLength:\\n                    prefix_sum += dp[prime_indices[left] - 1][(j - 1)%2]\\n                    left += 1\\n                dp[i][j%2] = prefix_sum\\n                dp[i][j%2] %= mod\\n\\n        return dp[-1][k%2] % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832055,
                "title": "dynamic-programming-prefix-sum-trick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ninline bool is_prime(const char ch) {\\n    switch (ch) {\\n        case \\'2\\': case \\'3\\': case \\'5\\': case \\'7\\':\\n            return true;\\n        default:\\n            return false;\\n    }\\n}\\n\\nclass Solution {    \\n    static constexpr int kMod = 1E9 + 7;\\n    static constexpr bool kDebug = false;\\n    \\npublic:\\n    int beautifulPartitions(string s, int max_num_segments, int min_length) {\\n        if (s.empty()) {\\n            return 1;            \\n        }\\n        if (is_prime(s.back())) {\\n            return 0;\\n        }\\n             \\n        const int min_len = min_length;\\n        std::vector<std::vector<int>> tbl(max_num_segments + 1, std::vector<int>(s.size() + 1, 0));\\n        tbl[0][0] = 1;\\n        std::vector<std::vector<int>> tbl_psum(max_num_segments + 1, std::vector<int>(s.size() + 1, 0));\\n        \\n        for (int j = 0; j < s.size(); ++j) {\\n            if (is_prime(s[j])) {\\n                for (int nseg = max_num_segments; nseg >= 0; --nseg) {\\n                    tbl_psum[nseg][j + 1] = (tbl_psum[nseg][j] + tbl[nseg][j]) % kMod;\\n                }                                \\n                continue;\\n            }\\n            \\n            for (int nseg = max_num_segments; nseg >= 0; --nseg) {\\n                tbl_psum[nseg][j + 1] = tbl_psum[nseg][j];\\n            }                            \\n            \\n            const int i_max = j - min_len + 1;\\n            if (i_max >= 0) {\\n                for (int nseg = max_num_segments; nseg > 0; --nseg) {\\n                    tbl[nseg][j + 1] = tbl_psum[nseg - 1][i_max + 1];\\n                }\\n            }\\n        }\\n        \\n        return tbl.back().back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ninline bool is_prime(const char ch) {\\n    switch (ch) {\\n        case \\'2\\': case \\'3\\': case \\'5\\': case \\'7\\':\\n            return true;\\n        default:\\n            return false;\\n    }\\n}\\n\\nclass Solution {    \\n    static constexpr int kMod = 1E9 + 7;\\n    static constexpr bool kDebug = false;\\n    \\npublic:\\n    int beautifulPartitions(string s, int max_num_segments, int min_length) {\\n        if (s.empty()) {\\n            return 1;            \\n        }\\n        if (is_prime(s.back())) {\\n            return 0;\\n        }\\n             \\n        const int min_len = min_length;\\n        std::vector<std::vector<int>> tbl(max_num_segments + 1, std::vector<int>(s.size() + 1, 0));\\n        tbl[0][0] = 1;\\n        std::vector<std::vector<int>> tbl_psum(max_num_segments + 1, std::vector<int>(s.size() + 1, 0));\\n        \\n        for (int j = 0; j < s.size(); ++j) {\\n            if (is_prime(s[j])) {\\n                for (int nseg = max_num_segments; nseg >= 0; --nseg) {\\n                    tbl_psum[nseg][j + 1] = (tbl_psum[nseg][j] + tbl[nseg][j]) % kMod;\\n                }                                \\n                continue;\\n            }\\n            \\n            for (int nseg = max_num_segments; nseg >= 0; --nseg) {\\n                tbl_psum[nseg][j + 1] = tbl_psum[nseg][j];\\n            }                            \\n            \\n            const int i_max = j - min_len + 1;\\n            if (i_max >= 0) {\\n                for (int nseg = max_num_segments; nseg > 0; --nseg) {\\n                    tbl[nseg][j + 1] = tbl_psum[nseg - 1][i_max + 1];\\n                }\\n            }\\n        }\\n        \\n        return tbl.back().back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831994,
                "title": "c-two-pointer-prefix-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        ll mod = 1e9+7;\\n        int m = s.size();\\n        \\n        // find boundary for partition\\n        vector<int> bound;\\n        for (int i = 0; i+1 < m; ++i) {            \\n            if (!isPrime(s[i]) && isPrime(s[i+1]))\\n                bound.push_back(i);\\n        }\\n        // include last index\\n        bound.push_back(m-1);\\n        \\n        int n = bound.size();\\n        \\n        // if only last index is present that means there\\'s no boundary for partition\\n        if (bound.size() == 1) return 0;\\n        \\n        vector<vector<ll>> dp(k + 1, vector<ll>(n + 1));\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (bound[i]+1 >= minLength)\\n            dp[1][i+1] = 1;\\n        }\\n        // prefix sum\\n        for (int i = 1; i <= n; ++i) {\\n            dp[1][i] += dp[1][i-1];\\n        }\\n        \\n        for (int z = 2; z <= k; ++z) {\\n            // two pointer for finding boundary\\n            int left = 0, right = -1;\\n            for (int i = 0; i < n; ++i) {\\n                while (left < i && bound[left] + 1 < minLength) left++;\\n                while (right + 1 < i && bound[i] - bound[right+1] >= minLength) right++;\\n                if (left <= right) {\\n                    dp[z][i+1] = (dp[z-1][right+1] - dp[z-1][left] + mod) % mod;\\n                }\\n            }\\n            \\n            // prefix\\n            for (int i = 1; i <= n; ++i) {\\n                dp[z][i] = (dp[z][i] + dp[z][i-1]) % mod;\\n            }\\n        }\\n\\n        return (dp[k][n] + mod - dp[k][n-1]) % mod;\\n    }\\n    \\n    bool isPrime(char x) {\\n        return x == \\'2\\' || x == \\'3\\' || x == \\'5\\' || x == \\'7\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        ll mod = 1e9+7;\\n        int m = s.size();\\n        \\n        // find boundary for partition\\n        vector<int> bound;\\n        for (int i = 0; i+1 < m; ++i) {            \\n            if (!isPrime(s[i]) && isPrime(s[i+1]))\\n                bound.push_back(i);\\n        }\\n        // include last index\\n        bound.push_back(m-1);\\n        \\n        int n = bound.size();\\n        \\n        // if only last index is present that means there\\'s no boundary for partition\\n        if (bound.size() == 1) return 0;\\n        \\n        vector<vector<ll>> dp(k + 1, vector<ll>(n + 1));\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (bound[i]+1 >= minLength)\\n            dp[1][i+1] = 1;\\n        }\\n        // prefix sum\\n        for (int i = 1; i <= n; ++i) {\\n            dp[1][i] += dp[1][i-1];\\n        }\\n        \\n        for (int z = 2; z <= k; ++z) {\\n            // two pointer for finding boundary\\n            int left = 0, right = -1;\\n            for (int i = 0; i < n; ++i) {\\n                while (left < i && bound[left] + 1 < minLength) left++;\\n                while (right + 1 < i && bound[i] - bound[right+1] >= minLength) right++;\\n                if (left <= right) {\\n                    dp[z][i+1] = (dp[z-1][right+1] - dp[z-1][left] + mod) % mod;\\n                }\\n            }\\n            \\n            // prefix\\n            for (int i = 1; i <= n; ++i) {\\n                dp[z][i] = (dp[z][i] + dp[z][i-1]) % mod;\\n            }\\n        }\\n\\n        return (dp[k][n] + mod - dp[k][n-1]) % mod;\\n    }\\n    \\n    bool isPrime(char x) {\\n        return x == \\'2\\' || x == \\'3\\' || x == \\'5\\' || x == \\'7\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831988,
                "title": "java-2d-dp-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPrime(char a){\\n        if(a==\\'2\\' || a==\\'3\\' ||a==\\'5\\' || a==\\'7\\') return true;\\n        return false;\\n    }\\n    int mod=1000000007;\\n    int dp[][];\\n    public int fun(String s, int k, int minL,int cur,int n,int part){\\n        if(cur>=n){\\n            if(part==k) return 1;\\n            return 0;\\n        }\\n        if(!isPrime(s.charAt(cur))){\\n            return 0;\\n        }\\n        if(part>=k)  return 0;\\n        if(dp[cur][part]!=-1)   return dp[cur][part];\\n        int ans=0;\\n        for(int i=cur+minL-1;i<n;i++){\\n            if(!isPrime(s.charAt(i))){\\n                ans=(ans+fun(s,k,minL,i+1,n,part+1))%mod;\\n            }\\n        }\\n        return dp[cur][part]=ans;\\n    }\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        dp=new int[s.length()+4][k+4];\\n        for(int i=0;i<s.length();i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return fun(s,k,minLength,0,s.length(),0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrime(char a){\\n        if(a==\\'2\\' || a==\\'3\\' ||a==\\'5\\' || a==\\'7\\') return true;\\n        return false;\\n    }\\n    int mod=1000000007;\\n    int dp[][];\\n    public int fun(String s, int k, int minL,int cur,int n,int part){\\n        if(cur>=n){\\n            if(part==k) return 1;\\n            return 0;\\n        }\\n        if(!isPrime(s.charAt(cur))){\\n            return 0;\\n        }\\n        if(part>=k)  return 0;\\n        if(dp[cur][part]!=-1)   return dp[cur][part];\\n        int ans=0;\\n        for(int i=cur+minL-1;i<n;i++){\\n            if(!isPrime(s.charAt(i))){\\n                ans=(ans+fun(s,k,minL,i+1,n,part+1))%mod;\\n            }\\n        }\\n        return dp[cur][part]=ans;\\n    }\\n    public int beautifulPartitions(String s, int k, int minLength) {\\n        dp=new int[s.length()+4][k+4];\\n        for(int i=0;i<s.length();i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return fun(s,k,minLength,0,s.length(),0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831971,
                "title": "c-dp-memoization-o-nk",
                "content": "```\\nclass Solution {\\nprivate:\\n    string s;\\n    int k, len, n, dp[1001][1001], mod = 1e9 + 7;\\n    bool isPrime[10] = {0, 0, 1, 1, 0, 1, 0, 1};\\n    int dfs(int i, int j) {\\n        if (i > n) return 0;\\n        if (i == n) return j == k-1 && !isPrime[s.back()-\\'0\\'];\\n        if (dp[i][j] == -1) {\\n            int tmp = dfs(i+1, j);\\n            if (isPrime[s[i]-\\'0\\'] && !isPrime[s[i-1]-\\'0\\'])\\n                tmp = (tmp + dfs(i+len, j+1)) % mod;\\n            dp[i][j] = tmp;\\n        }\\n        return dp[i][j];\\n    }\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if (!isPrime[s[0]-\\'0\\']) return 0;\\n        this->s = s, this->k = k, len = minLength, n = size(s);\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(minLength, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    string s;\\n    int k, len, n, dp[1001][1001], mod = 1e9 + 7;\\n    bool isPrime[10] = {0, 0, 1, 1, 0, 1, 0, 1};\\n    int dfs(int i, int j) {\\n        if (i > n) return 0;\\n        if (i == n) return j == k-1 && !isPrime[s.back()-\\'0\\'];\\n        if (dp[i][j] == -1) {\\n            int tmp = dfs(i+1, j);\\n            if (isPrime[s[i]-\\'0\\'] && !isPrime[s[i-1]-\\'0\\'])\\n                tmp = (tmp + dfs(i+len, j+1)) % mod;\\n            dp[i][j] = tmp;\\n        }\\n        return dp[i][j];\\n    }\\npublic:\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        if (!isPrime[s[0]-\\'0\\']) return 0;\\n        this->s = s, this->k = k, len = minLength, n = size(s);\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(minLength, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831967,
                "title": "fastest-python-solution-so-far",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution is based on recursivity and counting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to get this solution accepted, I had to perform several optimizations to stay within the time limit. Too bad I could not find them during the contest.\\n\\n# Time Complexity:\\n$O(nk)$, where n is the length of the string (more precisely, the number of points where the string can be divided).\\n\\nThis solution also uses the least amount of memory among solutions submitted so far.\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        s=list(s)\\n        l0=len(s)\\n        prime={\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n        for i in range(l0):\\n            s[i]=s[i] in prime\\n        if not s[0]:\\n            return 0\\n        if s[-1]:\\n            return 0\\n        p=10**9+7\\n        stops=[0]\\n        for i in range(l0-1):\\n            if (not s[i]) and s[i+1]:\\n                stops.append(i+1)\\n        l1=len(stops)\\n\\n        def bp(i, k):\\n            if l0-stops[i]<k*minLength:\\n                return 0\\n            if k==1:\\n                return 1                    \\n            i1=i+1\\n            while i1<l1 and stops[i1]<stops[i]+minLength:\\n                i1+=1\\n            return sm[i1]%p\\n\\n        for j in range(1, k+1):\\n            table=[bp(i, j) for i in range(l1)]\\n            sm=[]\\n            tmp=0\\n            for t in table:\\n                sm.append(tmp)\\n                tmp+=t\\n            sm.append(tmp)\\n            for i in range(l1+1):\\n                sm[i]=tmp-sm[i]\\n        \\n        return table[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        s=list(s)\\n        l0=len(s)\\n        prime={\\'2\\', \\'3\\', \\'5\\', \\'7\\'}\\n        for i in range(l0):\\n            s[i]=s[i] in prime\\n        if not s[0]:\\n            return 0\\n        if s[-1]:\\n            return 0\\n        p=10**9+7\\n        stops=[0]\\n        for i in range(l0-1):\\n            if (not s[i]) and s[i+1]:\\n                stops.append(i+1)\\n        l1=len(stops)\\n\\n        def bp(i, k):\\n            if l0-stops[i]<k*minLength:\\n                return 0\\n            if k==1:\\n                return 1                    \\n            i1=i+1\\n            while i1<l1 and stops[i1]<stops[i]+minLength:\\n                i1+=1\\n            return sm[i1]%p\\n\\n        for j in range(1, k+1):\\n            table=[bp(i, j) for i in range(l1)]\\n            sm=[]\\n            tmp=0\\n            for t in table:\\n                sm.append(tmp)\\n                tmp+=t\\n            sm.append(tmp)\\n            for i in range(l1+1):\\n                sm[i]=tmp-sm[i]\\n        \\n        return table[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831926,
                "title": "c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    bool is_prime(char c){\\n        return (c == \\'2\\') | (c == \\'3\\') | (c == \\'5\\') | (c == \\'7\\');\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k + 1));\\n        dp[0][0] = is_prime(s[0]);\\n        for(int i=1;i<minLength;i++) dp[i] = dp[i-1];\\n        for(int i=minLength;i<n;i++){\\n            if(is_prime(s[i-1])){\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            if(!is_prime(s[i])){\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            for(int j=1;j<=k;j++)\\n                dp[i][j] += dp[i-minLength][j-1];\\n            \\n            for(int j=0;j<=k;j++){\\n                dp[i][j] += dp[i-1][j];\\n                dp[i][j] %= mod;\\n            }\\n        }\\n        return is_prime(s.back()) ? 0 : dp[n-minLength][k-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    bool is_prime(char c){\\n        return (c == \\'2\\') | (c == \\'3\\') | (c == \\'5\\') | (c == \\'7\\');\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k + 1));\\n        dp[0][0] = is_prime(s[0]);\\n        for(int i=1;i<minLength;i++) dp[i] = dp[i-1];\\n        for(int i=minLength;i<n;i++){\\n            if(is_prime(s[i-1])){\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            if(!is_prime(s[i])){\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            for(int j=1;j<=k;j++)\\n                dp[i][j] += dp[i-minLength][j-1];\\n            \\n            for(int j=0;j<=k;j++){\\n                dp[i][j] += dp[i-1][j];\\n                dp[i][j] %= mod;\\n            }\\n        }\\n        return is_prime(s.back()) ? 0 : dp[n-minLength][k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831908,
                "title": "2d-dp-o-n-k-caching-and-tabular-methods-easy-to-understand-python",
                "content": "I hope this solutions is easy to read.\\nPlease go through the solution in the following steps:\\n1. Read the recursive approach first and without considering `dp`\\n2. Now read what the `dp ` is being used for\\n3. Now understanding the tabular form should be easy.\\n\\n## Reason to start with minLength\\nSince the first partition will be atleast of length minLength\\n\\n## Approach\\nIf I come on an index then\\n1. If the char at index is a prime\\n\\t1. The partition on this point can be done only when the previous partition ends with non-prime number\\n\\t2. if above conditions passes, then I partition and increase the partition by 1\\n2. If either a number is prime or not, both can be taken as a part of previous partition  \\n\\n```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        if len(s) == 0:\\n            return 0\\n        primes = [\\'2\\', \\'3\\', \\'5\\', \\'7\\']\\n        if s[0] not in primes or s[-1] in primes:\\n            return 0\\n        if k == 1:\\n            if len(s) >= minLength:\\n                return 1\\n            return 0\\n        MOD = 10**9+7\\n        n = len(s)\\n        res = 0\\n\\n        ## Tabular method\\n#         dp = [[\\n#            0 for _ in range(k+1)\\n#         ] for _ in range(n+1)]\\n#         dp[n][k] = 1\\n        \\n#         for indx in range(n-1, minLength-1, -1):\\n#             for partitions in range(k, 0, -1):\\n#                 a = 0\\n#                 if s[indx] in primes and s[indx-1] not in primes and indx+minLength <= n and partitions+1 <= k:\\n#                     a = (a + dp[indx + minLength][partitions+1] )%MOD\\n#                 a = (a+dp[indx+1][partitions])%MOD\\n#                 dp[indx][partitions] = a\\n#         return dp[minLength][1]\\n    \\n    ## Recursion with caching\\n                \\n        dp = {} \\n        def helper(indx, partitions):\\n            nonlocal res\\n            \\n            if indx > n or partitions > k:\\n                return 0\\n            \\n            if indx == n:\\n                if partitions == k:\\n                    res  = (res + 1)%MOD\\n                    return 1\\n                return 0\\n            \\n            if (indx, partitions) in dp:\\n                res = (res + dp[(indx, partitions)])%MOD\\n                return dp[(indx, partitions)]\\n            \\n            a = 0\\n            if s[indx] in primes and s[indx - 1] not in primes:\\n                a = (a+helper(indx+minLength, partitions+1))%MOD\\n            a = (a+helper(indx+1, partitions))%MOD\\n#             Dp[(indx, partitions)] denotes the number of additions done when reached at this point\\n            dp[(indx, partitions)] = a%MOD\\n            \\n            return a\\n        \\n        helper(minLength, 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\\n        if len(s) == 0:\\n            return 0\\n        primes = [\\'2\\', \\'3\\', \\'5\\', \\'7\\']\\n        if s[0] not in primes or s[-1] in primes:\\n            return 0\\n        if k == 1:\\n            if len(s) >= minLength:\\n                return 1\\n            return 0\\n        MOD = 10**9+7\\n        n = len(s)\\n        res = 0\\n\\n        ## Tabular method\\n#         dp = [[\\n#            0 for _ in range(k+1)\\n#         ] for _ in range(n+1)]\\n#         dp[n][k] = 1\\n        \\n#         for indx in range(n-1, minLength-1, -1):\\n#             for partitions in range(k, 0, -1):\\n#                 a = 0\\n#                 if s[indx] in primes and s[indx-1] not in primes and indx+minLength <= n and partitions+1 <= k:\\n#                     a = (a + dp[indx + minLength][partitions+1] )%MOD\\n#                 a = (a+dp[indx+1][partitions])%MOD\\n#                 dp[indx][partitions] = a\\n#         return dp[minLength][1]\\n    \\n    ## Recursion with caching\\n                \\n        dp = {} \\n        def helper(indx, partitions):\\n            nonlocal res\\n            \\n            if indx > n or partitions > k:\\n                return 0\\n            \\n            if indx == n:\\n                if partitions == k:\\n                    res  = (res + 1)%MOD\\n                    return 1\\n                return 0\\n            \\n            if (indx, partitions) in dp:\\n                res = (res + dp[(indx, partitions)])%MOD\\n                return dp[(indx, partitions)]\\n            \\n            a = 0\\n            if s[indx] in primes and s[indx - 1] not in primes:\\n                a = (a+helper(indx+minLength, partitions+1))%MOD\\n            a = (a+helper(indx+1, partitions))%MOD\\n#             Dp[(indx, partitions)] denotes the number of additions done when reached at this point\\n            dp[(indx, partitions)] = a%MOD\\n            \\n            return a\\n        \\n        helper(minLength, 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831890,
                "title": "c-2d-dp-solution-change-to-remove-tle",
                "content": "Change:\\nI used the same logic in contest but the code threw a TLE. The only change I did now is make dp global. Earlier, I was passing it as a pass by reference.\\n\\n# Code\\n```\\nconst int mod = 1e9+7;\\nint dp[1007][1007];\\nclass Solution {\\npublic:\\n    long long solve(string &s, int i, int k, int &minLength){\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        if(i==s.length())return dp[i][k]= !k;\\n        if(!k)return dp[i][k] = 0;\\n        if(i + minLength*k>s.length() or (s[i]!=\\'2\\' and s[i]!=\\'3\\' and s[i]!=\\'5\\' and s[i]!=\\'7\\'))return dp[i][k]=0;\\n        if((i+ minLength - 1)>s.length())return dp[i][k]=0;\\n        int j = i+minLength-1;\\n        long long res=0;\\n        for(j;j<s.length();j++){\\n            if(s[j]!=\\'2\\' and s[j]!=\\'3\\' and s[j]!=\\'5\\' and s[j]!=\\'7\\'){\\n                res+= solve(s,j+1,k-1, minLength);\\n                res%=mod;\\n                \\n            }\\n        }\\n        return dp[i][k]=res%mod;\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, k, minLength);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int mod = 1e9+7;\\nint dp[1007][1007];\\nclass Solution {\\npublic:\\n    long long solve(string &s, int i, int k, int &minLength){\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        if(i==s.length())return dp[i][k]= !k;\\n        if(!k)return dp[i][k] = 0;\\n        if(i + minLength*k>s.length() or (s[i]!=\\'2\\' and s[i]!=\\'3\\' and s[i]!=\\'5\\' and s[i]!=\\'7\\'))return dp[i][k]=0;\\n        if((i+ minLength - 1)>s.length())return dp[i][k]=0;\\n        int j = i+minLength-1;\\n        long long res=0;\\n        for(j;j<s.length();j++){\\n            if(s[j]!=\\'2\\' and s[j]!=\\'3\\' and s[j]!=\\'5\\' and s[j]!=\\'7\\'){\\n                res+= solve(s,j+1,k-1, minLength);\\n                res%=mod;\\n                \\n            }\\n        }\\n        return dp[i][k]=res%mod;\\n    }\\n    \\n    int beautifulPartitions(string s, int k, int minLength) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, k, minLength);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1944890,
                "content": [
                    {
                        "username": "akhilg11",
                        "content": "TLE  at 74th testcase with empty input string....Frustrating"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why am i getting TLE at 70th testcase using this approach??\\n\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    unordered_map<char,int> m;\\n    int n;\\n    int ways(string &s,int index,int part,int k,int len,vector<vector<int>> &dp)\\n    {\\n        if(part==k-1)\\n        {\\n            if(m.find(s[n-1])==m.end()&&n-index>=len&&m.find(s[index])!=m.end()) return 1;\\n            return 0;\\n        }\\n        if(index>=n) return 0;\\n        if(dp[index][part]!=-1) return dp[index][part];\\n        long ans=0;\\n        for(int j=index+len-1;j<n;j++)\\n        {\\n            if(part<k-1&&m.find(s[j])==m.end()&&m.find(s[index])!=m.end())\\n            {\\n                ans=(ans+ways(s,j+1,part+1,k,len,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[index][part]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int len) {\\n        n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(k,-1));\\n        m[\\'2\\']++; m[\\'3\\']++; m[\\'5\\']++; m[\\'7\\']++;\\n        return ways(s,0,0,k,len,dp);\\n    }\\n};"
                    },
                    {
                        "username": "stefan1096",
                        "content": "We can choose the last index of each substring"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    },
                    {
                        "username": "nakanolab",
                        "content": "Since each substring starts with a prime digit and ends with a non-prime digit, **minLength is at least 2**. It looks to me that setting minLength = 1 in some test cases only tries to punish **suboptimal** solutions by bloating search space."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "How to solve TLE for this any suggestions\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "Thanks it worked\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            if((s.size()-index-1)<(k-1)*minlength)\\n            {\\n                break;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohit123456",
                        "content": "[@Yuvraj100](/Yuvraj100) Still TLE in Java"
                    },
                    {
                        "username": "Yuvraj100",
                        "content": "You need to check before making the recursive call whether (k-1) partitions of length = minlength are possible or not.\\nCODE\\nif((index+(minlength*(k-1)))>=s.size()) {\\n      break; \\n}"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    }
                ]
            },
            {
                "id": 1944885,
                "content": [
                    {
                        "username": "akhilg11",
                        "content": "TLE  at 74th testcase with empty input string....Frustrating"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why am i getting TLE at 70th testcase using this approach??\\n\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    unordered_map<char,int> m;\\n    int n;\\n    int ways(string &s,int index,int part,int k,int len,vector<vector<int>> &dp)\\n    {\\n        if(part==k-1)\\n        {\\n            if(m.find(s[n-1])==m.end()&&n-index>=len&&m.find(s[index])!=m.end()) return 1;\\n            return 0;\\n        }\\n        if(index>=n) return 0;\\n        if(dp[index][part]!=-1) return dp[index][part];\\n        long ans=0;\\n        for(int j=index+len-1;j<n;j++)\\n        {\\n            if(part<k-1&&m.find(s[j])==m.end()&&m.find(s[index])!=m.end())\\n            {\\n                ans=(ans+ways(s,j+1,part+1,k,len,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[index][part]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int len) {\\n        n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(k,-1));\\n        m[\\'2\\']++; m[\\'3\\']++; m[\\'5\\']++; m[\\'7\\']++;\\n        return ways(s,0,0,k,len,dp);\\n    }\\n};"
                    },
                    {
                        "username": "stefan1096",
                        "content": "We can choose the last index of each substring"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    },
                    {
                        "username": "nakanolab",
                        "content": "Since each substring starts with a prime digit and ends with a non-prime digit, **minLength is at least 2**. It looks to me that setting minLength = 1 in some test cases only tries to punish **suboptimal** solutions by bloating search space."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "How to solve TLE for this any suggestions\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "Thanks it worked\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            if((s.size()-index-1)<(k-1)*minlength)\\n            {\\n                break;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohit123456",
                        "content": "[@Yuvraj100](/Yuvraj100) Still TLE in Java"
                    },
                    {
                        "username": "Yuvraj100",
                        "content": "You need to check before making the recursive call whether (k-1) partitions of length = minlength are possible or not.\\nCODE\\nif((index+(minlength*(k-1)))>=s.size()) {\\n      break; \\n}"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    }
                ]
            },
            {
                "id": 1889385,
                "content": [
                    {
                        "username": "akhilg11",
                        "content": "TLE  at 74th testcase with empty input string....Frustrating"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why am i getting TLE at 70th testcase using this approach??\\n\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    unordered_map<char,int> m;\\n    int n;\\n    int ways(string &s,int index,int part,int k,int len,vector<vector<int>> &dp)\\n    {\\n        if(part==k-1)\\n        {\\n            if(m.find(s[n-1])==m.end()&&n-index>=len&&m.find(s[index])!=m.end()) return 1;\\n            return 0;\\n        }\\n        if(index>=n) return 0;\\n        if(dp[index][part]!=-1) return dp[index][part];\\n        long ans=0;\\n        for(int j=index+len-1;j<n;j++)\\n        {\\n            if(part<k-1&&m.find(s[j])==m.end()&&m.find(s[index])!=m.end())\\n            {\\n                ans=(ans+ways(s,j+1,part+1,k,len,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[index][part]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int len) {\\n        n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(k,-1));\\n        m[\\'2\\']++; m[\\'3\\']++; m[\\'5\\']++; m[\\'7\\']++;\\n        return ways(s,0,0,k,len,dp);\\n    }\\n};"
                    },
                    {
                        "username": "stefan1096",
                        "content": "We can choose the last index of each substring"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    },
                    {
                        "username": "nakanolab",
                        "content": "Since each substring starts with a prime digit and ends with a non-prime digit, **minLength is at least 2**. It looks to me that setting minLength = 1 in some test cases only tries to punish **suboptimal** solutions by bloating search space."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "How to solve TLE for this any suggestions\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "Thanks it worked\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            if((s.size()-index-1)<(k-1)*minlength)\\n            {\\n                break;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohit123456",
                        "content": "[@Yuvraj100](/Yuvraj100) Still TLE in Java"
                    },
                    {
                        "username": "Yuvraj100",
                        "content": "You need to check before making the recursive call whether (k-1) partitions of length = minlength are possible or not.\\nCODE\\nif((index+(minlength*(k-1)))>=s.size()) {\\n      break; \\n}"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    }
                ]
            },
            {
                "id": 1696215,
                "content": [
                    {
                        "username": "akhilg11",
                        "content": "TLE  at 74th testcase with empty input string....Frustrating"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why am i getting TLE at 70th testcase using this approach??\\n\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    unordered_map<char,int> m;\\n    int n;\\n    int ways(string &s,int index,int part,int k,int len,vector<vector<int>> &dp)\\n    {\\n        if(part==k-1)\\n        {\\n            if(m.find(s[n-1])==m.end()&&n-index>=len&&m.find(s[index])!=m.end()) return 1;\\n            return 0;\\n        }\\n        if(index>=n) return 0;\\n        if(dp[index][part]!=-1) return dp[index][part];\\n        long ans=0;\\n        for(int j=index+len-1;j<n;j++)\\n        {\\n            if(part<k-1&&m.find(s[j])==m.end()&&m.find(s[index])!=m.end())\\n            {\\n                ans=(ans+ways(s,j+1,part+1,k,len,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[index][part]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int len) {\\n        n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(k,-1));\\n        m[\\'2\\']++; m[\\'3\\']++; m[\\'5\\']++; m[\\'7\\']++;\\n        return ways(s,0,0,k,len,dp);\\n    }\\n};"
                    },
                    {
                        "username": "stefan1096",
                        "content": "We can choose the last index of each substring"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    },
                    {
                        "username": "nakanolab",
                        "content": "Since each substring starts with a prime digit and ends with a non-prime digit, **minLength is at least 2**. It looks to me that setting minLength = 1 in some test cases only tries to punish **suboptimal** solutions by bloating search space."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "How to solve TLE for this any suggestions\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "Thanks it worked\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            if((s.size()-index-1)<(k-1)*minlength)\\n            {\\n                break;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohit123456",
                        "content": "[@Yuvraj100](/Yuvraj100) Still TLE in Java"
                    },
                    {
                        "username": "Yuvraj100",
                        "content": "You need to check before making the recursive call whether (k-1) partitions of length = minlength are possible or not.\\nCODE\\nif((index+(minlength*(k-1)))>=s.size()) {\\n      break; \\n}"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    }
                ]
            },
            {
                "id": 1692486,
                "content": [
                    {
                        "username": "akhilg11",
                        "content": "TLE  at 74th testcase with empty input string....Frustrating"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why am i getting TLE at 70th testcase using this approach??\\n\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    unordered_map<char,int> m;\\n    int n;\\n    int ways(string &s,int index,int part,int k,int len,vector<vector<int>> &dp)\\n    {\\n        if(part==k-1)\\n        {\\n            if(m.find(s[n-1])==m.end()&&n-index>=len&&m.find(s[index])!=m.end()) return 1;\\n            return 0;\\n        }\\n        if(index>=n) return 0;\\n        if(dp[index][part]!=-1) return dp[index][part];\\n        long ans=0;\\n        for(int j=index+len-1;j<n;j++)\\n        {\\n            if(part<k-1&&m.find(s[j])==m.end()&&m.find(s[index])!=m.end())\\n            {\\n                ans=(ans+ways(s,j+1,part+1,k,len,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[index][part]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int len) {\\n        n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(k,-1));\\n        m[\\'2\\']++; m[\\'3\\']++; m[\\'5\\']++; m[\\'7\\']++;\\n        return ways(s,0,0,k,len,dp);\\n    }\\n};"
                    },
                    {
                        "username": "stefan1096",
                        "content": "We can choose the last index of each substring"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    },
                    {
                        "username": "nakanolab",
                        "content": "Since each substring starts with a prime digit and ends with a non-prime digit, **minLength is at least 2**. It looks to me that setting minLength = 1 in some test cases only tries to punish **suboptimal** solutions by bloating search space."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "How to solve TLE for this any suggestions\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "Thanks it worked\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            if((s.size()-index-1)<(k-1)*minlength)\\n            {\\n                break;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohit123456",
                        "content": "[@Yuvraj100](/Yuvraj100) Still TLE in Java"
                    },
                    {
                        "username": "Yuvraj100",
                        "content": "You need to check before making the recursive call whether (k-1) partitions of length = minlength are possible or not.\\nCODE\\nif((index+(minlength*(k-1)))>=s.size()) {\\n      break; \\n}"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    }
                ]
            },
            {
                "id": 1690144,
                "content": [
                    {
                        "username": "akhilg11",
                        "content": "TLE  at 74th testcase with empty input string....Frustrating"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why am i getting TLE at 70th testcase using this approach??\\n\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    unordered_map<char,int> m;\\n    int n;\\n    int ways(string &s,int index,int part,int k,int len,vector<vector<int>> &dp)\\n    {\\n        if(part==k-1)\\n        {\\n            if(m.find(s[n-1])==m.end()&&n-index>=len&&m.find(s[index])!=m.end()) return 1;\\n            return 0;\\n        }\\n        if(index>=n) return 0;\\n        if(dp[index][part]!=-1) return dp[index][part];\\n        long ans=0;\\n        for(int j=index+len-1;j<n;j++)\\n        {\\n            if(part<k-1&&m.find(s[j])==m.end()&&m.find(s[index])!=m.end())\\n            {\\n                ans=(ans+ways(s,j+1,part+1,k,len,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[index][part]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int len) {\\n        n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(k,-1));\\n        m[\\'2\\']++; m[\\'3\\']++; m[\\'5\\']++; m[\\'7\\']++;\\n        return ways(s,0,0,k,len,dp);\\n    }\\n};"
                    },
                    {
                        "username": "stefan1096",
                        "content": "We can choose the last index of each substring"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    },
                    {
                        "username": "nakanolab",
                        "content": "Since each substring starts with a prime digit and ends with a non-prime digit, **minLength is at least 2**. It looks to me that setting minLength = 1 in some test cases only tries to punish **suboptimal** solutions by bloating search space."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "How to solve TLE for this any suggestions\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "Thanks it worked\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            if((s.size()-index-1)<(k-1)*minlength)\\n            {\\n                break;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohit123456",
                        "content": "[@Yuvraj100](/Yuvraj100) Still TLE in Java"
                    },
                    {
                        "username": "Yuvraj100",
                        "content": "You need to check before making the recursive call whether (k-1) partitions of length = minlength are possible or not.\\nCODE\\nif((index+(minlength*(k-1)))>=s.size()) {\\n      break; \\n}"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    }
                ]
            },
            {
                "id": 1696214,
                "content": [
                    {
                        "username": "akhilg11",
                        "content": "TLE  at 74th testcase with empty input string....Frustrating"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Why am i getting TLE at 70th testcase using this approach??\\n\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    unordered_map<char,int> m;\\n    int n;\\n    int ways(string &s,int index,int part,int k,int len,vector<vector<int>> &dp)\\n    {\\n        if(part==k-1)\\n        {\\n            if(m.find(s[n-1])==m.end()&&n-index>=len&&m.find(s[index])!=m.end()) return 1;\\n            return 0;\\n        }\\n        if(index>=n) return 0;\\n        if(dp[index][part]!=-1) return dp[index][part];\\n        long ans=0;\\n        for(int j=index+len-1;j<n;j++)\\n        {\\n            if(part<k-1&&m.find(s[j])==m.end()&&m.find(s[index])!=m.end())\\n            {\\n                ans=(ans+ways(s,j+1,part+1,k,len,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[index][part]=ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int len) {\\n        n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(k,-1));\\n        m[\\'2\\']++; m[\\'3\\']++; m[\\'5\\']++; m[\\'7\\']++;\\n        return ways(s,0,0,k,len,dp);\\n    }\\n};"
                    },
                    {
                        "username": "stefan1096",
                        "content": "We can choose the last index of each substring"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    },
                    {
                        "username": "nakanolab",
                        "content": "Since each substring starts with a prime digit and ends with a non-prime digit, **minLength is at least 2**. It looks to me that setting minLength = 1 in some test cases only tries to punish **suboptimal** solutions by bloating search space."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "How to solve TLE for this any suggestions\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": "Thanks it worked\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long helper(string &s,int k,int minlength,int i,vector<vector<long long>>&dp)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(k==0)\\n            {\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if((s.size()-i)<k*minlength)\\n        {\\n            return 0;\\n        }\\n        if(s[i]!=\\'2\\' && s[i]!=\\'3\\' && s[i]!=\\'5\\' && s[i]!=\\'7\\')\\n        {\\n            // dp[i]=0;\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)\\n        {\\n            return dp[i][k]%mod;\\n        }\\n        long long ans=0;\\n        for(int index=i+minlength-1;index<s.size();index++)\\n        {\\n            if(s[index]!=\\'0\\' && s[index]!=\\'1\\' && s[index]!=\\'4\\' && s[index]!=\\'6\\' && s[index]!=\\'8\\' && s[index]!=\\'9\\')\\n            {\\n                continue;\\n            }\\n            if((s.size()-index-1)<(k-1)*minlength)\\n            {\\n                break;\\n            }\\n            ans=(ans%mod+helper(s,k-1,minlength,index+1,dp)%mod)%mod;\\n        }\\n        dp[i][k]=ans%mod;\\n        return ans%mod;\\n    }\\n    int beautifulPartitions(string s, int k, int minLength) {\\n        // vector<int>dp(s.size()+1,-1);\\n        if(s.size()==0)\\n        {\\n            return 0;\\n        }\\n        vector<vector<long long>>dp(s.size(),vector<long long>(k+1,-1));\\n        return helper(s,k,minLength,0,dp)%mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mohit123456",
                        "content": "[@Yuvraj100](/Yuvraj100) Still TLE in Java"
                    },
                    {
                        "username": "Yuvraj100",
                        "content": "You need to check before making the recursive call whether (k-1) partitions of length = minlength are possible or not.\\nCODE\\nif((index+(minlength*(k-1)))>=s.size()) {\\n      break; \\n}"
                    },
                    {
                        "username": "mahapatro",
                        "content": "if(i is prime)\\n        {\\n            if(at_start) ans=dfs(i=i+minLength-1,at_start=false)\\n            else ans=dfs(i=i+1,at_start=false);\\n        }  \\n        else\\n        {\\n            ans=(dfs(k=k-1,i=i+1,at_start=true)+dfs(i=i+1,at_start=false))\\n        }\\n\\nYou just have to implement this"
                    }
                ]
            }
        ]
    }
]