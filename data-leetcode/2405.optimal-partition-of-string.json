[
    {
        "title": "Optimal Partition of String",
        "question_content": "Given a string s, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once.\nReturn the minimum number of substrings in such a partition.\nNote that each character should belong to exactly one substring in a partition.\n&nbsp;\nExample 1:\n\nInput: s = \"abacaba\"\nOutput: 4\nExplanation:\nTwo possible partitions are (\"a\",\"ba\",\"cab\",\"a\") and (\"ab\",\"a\",\"ca\",\"ba\").\nIt can be shown that 4 is the minimum number of substrings needed.\n\nExample 2:\n\nInput: s = \"ssssss\"\nOutput: 6\nExplanation:\nThe only valid partition is (\"s\",\"s\",\"s\",\"s\",\"s\",\"s\").\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts consists of only English lowercase letters.",
        "solutions": [
            {
                "id": 3376693,
                "title": "image-explanation-3-approaches-o-1-space-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Optimal Partition of String` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/72e2c7ab-64dd-4db8-93d7-ec68553c6051_1680575575.5060904.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/ee9b1ecb-940e-46d1-9857-ea787937253f_1680571869.231118.png)\\n![image.png](https://assets.leetcode.com/users/images/39999dea-aeed-4d64-99bd-015d5e5f0cd3_1680571877.5683982.png)\\n![image.png](https://assets.leetcode.com/users/images/aed1c108-57e5-438c-857d-941fe7ec1bfa_1680571888.890583.png)\\n![image.png](https://assets.leetcode.com/users/images/82780752-ffda-49d1-9c87-e60511107216_1680571896.7639346.png)\\n![image.png](https://assets.leetcode.com/users/images/0d5df437-cdad-495f-b4cb-0b7daec48cf4_1680571904.0935264.png)\\n![image.png](https://assets.leetcode.com/users/images/a5163e36-e4de-4c8a-84c4-40e48af5bb7a_1680571921.6635892.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int i = 0, ans = 1,flag = 0;\\n        while(i < s.size()){\\n            int val = s[i] - \\'a\\';\\n            if( flag & (1<<val) ) {\\n                flag = 0;\\n                ans++;\\n            }\\n            flag = flag | (1<<val);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public int partitionString(String s) {\\n        int i = 0, ans = 1, flag = 0;\\n        while(i < s.length()) {\\n            int val = s.charAt(i) - \\'a\\';\\n            if ((flag & (1 << val)) != 0) {\\n                flag = 0;\\n                ans++;\\n            }\\n            flag = flag | (1 << val);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        i, ans, flag = 0, 1, 0\\n        while i < len(s):\\n            val = ord(s[i]) - ord(\\'a\\')\\n            if flag & (1 << val):\\n                flag = 0\\n                ans += 1\\n            flag |= 1 << val\\n            i += 1\\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Greedy",
                    "Bitmask"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int i = 0, ans = 1,flag = 0;\\n        while(i < s.size()){\\n            int val = s[i] - \\'a\\';\\n            if( flag & (1<<val) ) {\\n                flag = 0;\\n                ans++;\\n            }\\n            flag = flag | (1<<val);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public int partitionString(String s) {\\n        int i = 0, ans = 1, flag = 0;\\n        while(i < s.length()) {\\n            int val = s.charAt(i) - \\'a\\';\\n            if ((flag & (1 << val)) != 0) {\\n                flag = 0;\\n                ans++;\\n            }\\n            flag = flag | (1 << val);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        i, ans, flag = 0, 1, 0\\n        while i < len(s):\\n            val = ord(s[i]) - ord(\\'a\\')\\n            if flag & (1 << val):\\n                flag = 0\\n                ans += 1\\n            flag |= 1 << val\\n            i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560157,
                "title": "explained-with-o-1-space-very-easy-simple-to-understand",
                "content": "<b> Up Vote if you like the solution </b>\\n\\nKeep iterating till any of the element is seen double, once u find the repeated element, then simply increment the ans and reset seen flag\\nTo check if a char is repeated or not bit wise operator used, each bit of flag represents a char.\\n```\\nclass Solution {\\npublic:\\n    bool checkBit(int &flag, int &n){\\n        return flag & (1<<n);\\n    }\\n    void setBit(int &flag, int &n){\\n        flag = flag | (1<<n);\\n    }\\n    int partitionString(string s) {\\n        int flag = 0;\\n        int i = 0, ans = 1;\\n        while(i < s.size()){\\n            int n = s[i] - \\'a\\';\\n            if( checkBit(flag, n) ) {\\n                flag = 0;\\n                ans++;\\n            }\\n            setBit(flag, n);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<b> Also you may like to go through my interview preparation experience and study material I used to crack interview at Amazon :\\n[My journy to a FAANG company](https://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted) : \\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkBit(int &flag, int &n){\\n        return flag & (1<<n);\\n    }\\n    void setBit(int &flag, int &n){\\n        flag = flag | (1<<n);\\n    }\\n    int partitionString(string s) {\\n        int flag = 0;\\n        int i = 0, ans = 1;\\n        while(i < s.size()){\\n            int n = s[i] - \\'a\\';\\n            if( checkBit(flag, n) ) {\\n                flag = 0;\\n                ans++;\\n            }\\n            setBit(flag, n);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376662,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to partition the string into substrings where each substring should have unique characters. Therefore, if a character that has already appeared in the current substring appears again, we should create a new substring. We can keep track of the last occurrence of each character using a hash map, and iterate through the string to create substrings that contain only unique characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a hash map to keep track of the last occurrence of each character. We start with the first character of the string and add it to the hash map. Then, we iterate through the rest of the string, and for each character, we check if it has already appeared in the current substring (i.e., its last occurrence is after the start index of the current substring). If it has, we create a new substring and start a new count. Otherwise, we add the character to the hash map and continue iterating. At the end, we return the count plus one (to account for the last substring).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is $$O(n)$$, where n is the length of the input string. We iterate through the string once to create the substrings.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is $$O(k)$$, where k is the size of the character set (in this case, the English lowercase letters). We use a hash map to store the last occurrence of each character, which can have at most k entries.\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int partitionString(String s) {\\n        int idx = 0;\\n        int count = 0;\\n        Map<Character, Boolean> mp = new HashMap<>(); // use a HashMap instead of an unordered_map\\n        while (idx < s.length()) {\\n            if (mp.containsKey(s.charAt(idx))) { // if current character has already appeared in current substring\\n                count++; // increment count\\n                mp.clear(); // clear HashMap to start a new substring\\n            }\\n            mp.put(s.charAt(idx), true); // mark current character as seen\\n            idx++; // move to next character\\n        }\\n        return count + 1; // return number of substrings (add 1 because we need to count the last substring as well)\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int idx = 0;\\n        int count = 0;\\n        unordered_map<char, bool> mp; // unordered_map to keep track of characters in current substring\\n        while (idx < s.length()) {\\n            if (mp.find(s[idx]) != mp.end()) { // if current character has already appeared in current substring\\n                count++; // increment count\\n                mp.clear(); // clear unordered_map to start a new substring\\n            }\\n            mp[s[idx]] = true; // mark current character as seen\\n            idx++; // move to next character\\n        }\\n        return count + 1; // return number of substrings (add 1 because we need to count the last substring as well)\\n    }\\n};\\n```\\n\\n```Python []\\nclass Solution(object):\\n    def partitionString(self, s):\\n        idx = 0\\n        count = 0\\n        mp = {} # use a dictionary instead of a HashMap\\n        while idx < len(s):\\n            if s[idx] in mp: # if current character has already appeared in current substring\\n                count += 1 # increment count\\n                mp.clear() # clear dictionary to start a new substring\\n            mp[s[idx]] = True # mark current character as seen\\n            idx += 1 # move to next character\\n        return count + 1 # return number of substrings (add 1 because we need to count the last substring as well)\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int partitionString(String s) {\\n        int idx = 0;\\n        int count = 0;\\n        Map<Character, Boolean> mp = new HashMap<>(); // use a HashMap instead of an unordered_map\\n        while (idx < s.length()) {\\n            if (mp.containsKey(s.charAt(idx))) { // if current character has already appeared in current substring\\n                count++; // increment count\\n                mp.clear(); // clear HashMap to start a new substring\\n            }\\n            mp.put(s.charAt(idx), true); // mark current character as seen\\n            idx++; // move to next character\\n        }\\n        return count + 1; // return number of substrings (add 1 because we need to count the last substring as well)\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int idx = 0;\\n        int count = 0;\\n        unordered_map<char, bool> mp; // unordered_map to keep track of characters in current substring\\n        while (idx < s.length()) {\\n            if (mp.find(s[idx]) != mp.end()) { // if current character has already appeared in current substring\\n                count++; // increment count\\n                mp.clear(); // clear unordered_map to start a new substring\\n            }\\n            mp[s[idx]] = true; // mark current character as seen\\n            idx++; // move to next character\\n        }\\n        return count + 1; // return number of substrings (add 1 because we need to count the last substring as well)\\n    }\\n};\\n```\n```Python []\\nclass Solution(object):\\n    def partitionString(self, s):\\n        idx = 0\\n        count = 0\\n        mp = {} # use a dictionary instead of a HashMap\\n        while idx < len(s):\\n            if s[idx] in mp: # if current character has already appeared in current substring\\n                count += 1 # increment count\\n                mp.clear() # clear dictionary to start a new substring\\n            mp[s[idx]] = True # mark current character as seen\\n            idx += 1 # move to next character\\n        return count + 1 # return number of substrings (add 1 because we need to count the last substring as well)\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376981,
                "title": "python3-c-java-beats-99-83-greedy-bit-manipulation",
                "content": "![image.png](https://assets.leetcode.com/users/images/35fb642e-a256-4e8b-8bc6-b8cd349e7117_1680613271.7346802.png)\\n\\nThe variable ans is initialized to 1 as there will be at least one partition. The list ls will store the characters in the current partition.\\n\\nThe for loop iterates over each character in the string s. If the character is already present in the current partition ls, it means that the current partition cannot be extended any further. So, a new partition is started with the current character. The ls list is updated with this new character, and the ans variable is incremented by 1.\\n\\nIf the character is not already present in the current partition ls, it means that the current partition can be extended to include this character. So, the character is added to the ls list.\\n\\nFinally, the ans variable is returned, which gives the minimum number of partitions required to partition the given string as per the given constraint.\\n\\n# Please Upvote \\uD83D\\uDE07\\n## Solution with list\\n## Python3\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        ans=1\\n        ls=[]\\n        for i in s:\\n            if i in ls:\\n                ls=[i]\\n                ans+=1\\n            else:\\n                ls+=[i]\\n        return ans\\n```\\n\\nThis implementation uses a different approach to solve the problem. It uses a variable xor to keep track of the characters that appear in the current substring being constructed. It uses a bit-wise XOR operation to set the bits corresponding to the characters that appear in the current substring.\\n\\nAs we iterate through the string, for each character, we check if the bit corresponding to the character is already set in xor. If it is, that means we have found a new substring, and we reset xor and increment ans to count the new substring.\\n\\nAt the end of the loop, we have counted all the substrings, and we return ans.\\n\\nThe benefit of using the XOR operation is that we can use a single integer variable to keep track of which characters are present in the current substring, instead of using a list to store the characters as in the previous implementation. This can potentially save memory and be more efficient.\\n\\n## Solution with xor\\n<iframe src=\"https://leetcode.com/playground/HuRmy6Jy/shared\" frameBorder=\"0\" style=\"background-color:#F999\" width=\"600\" height=\"300\"></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        ans=1\\n        ls=[]\\n        for i in s:\\n            if i in ls:\\n                ls=[i]\\n                ans+=1\\n            else:\\n                ls+=[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376720,
                "title": "image-explanation-set-is-all-you-need-including-hints",
                "content": "# Intuition\\n**We should first determine, what is a substring based on this problem description..**\\n- The characters in each substring are unique. That is, no letter appears in a single substring more than once.\\n\\nAt first, we will start by adding characters to a substring. But when should we create a new substring?\\nWell, when we see the same character that\\'s already present in the substring, we then start a new substring. Thus increment our count and repeat this process until we iterate over the entire string s.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![image.png](https://assets.leetcode.com/users/images/752cffe9-5031-474d-a071-82ce22abc1dc_1680572726.9291408.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(26) = O(1)$$\\nIn worst case, we might need to store all 26 distinct characters into the hashset. But this is a constant value. So, space complexity is constant.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/7c01e326-8bc8-41a8-9383-7893fcb04698_1680573272.3885257.png)\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    public int partitionString(String s) {\\n        int subs = 1;\\n        Set<Character> charSet = new HashSet<>();\\n        for(char ch: s.toCharArray()){\\n            if(!charSet.contains(ch)){\\n                charSet.add(ch);\\n                continue;\\n            }\\n            subs++;\\n            charSet.clear();\\n            charSet.add(ch);\\n        }\\n        return subs;\\n    }\\n}\\n```\\n\\n![cc404213-285c-48ca-bce1-256072316360_1675559254.9353127.png](https://assets.leetcode.com/users/images/eaf86d0e-ebc4-4b5b-85a2-514793dd189e_1680573192.077646.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "``` Java []\\nclass Solution {\\n    public int partitionString(String s) {\\n        int subs = 1;\\n        Set<Character> charSet = new HashSet<>();\\n        for(char ch: s.toCharArray()){\\n            if(!charSet.contains(ch)){\\n                charSet.add(ch);\\n                continue;\\n            }\\n            subs++;\\n            charSet.clear();\\n            charSet.add(ch);\\n        }\\n        return subs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560159,
                "title": "greedy",
                "content": "The best strategy is to make each partition as long as possible (can be easily proven).\\n\\n**Track Position**\\nWe track the start of the current partition, and the last position of each character.\\n\\nThat way, we can detect if a character repeats in the current partition.\\n\\nThis solution is a bit more efficient as we do not need to reset the count.\\n\\n**Java**\\n```java\\npublic int partitionString(String s) {\\n    int[] pos = new int[26];\\n    int res = 0, last = 0;\\n    for (int i = 0; i < s.length(); ++i) {\\n        if (pos[s.charAt(i) - \\'a\\'] >= last) {\\n            ++res;\\n            last = i + 1;\\n        }\\n        pos[s.charAt(i) - \\'a\\'] = i + 1;\\n    }\\n    return res;  \\n}\\n```\\n**C++**\\n```cpp\\nint partitionString(string s) {\\n    int pos[26] = {}, res = 0, last = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (pos[s[i] - \\'a\\'] >= last) {\\n            ++res;\\n            last = i + 1;\\n        }\\n        pos[s[i] - \\'a\\'] = i + 1;\\n    }\\n    return res;        \\n}\\n```\\n**Track Count (Original Solution)**\\n\\n**C++**\\n```cpp\\nint partitionString(string s) {\\n    int cnt[26] = {}, res = 1;\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (cnt[s[i] - \\'a\\']) {\\n            ++res;\\n            fill(begin(cnt), end(cnt), 0);\\n        }\\n        ++cnt[s[i] - \\'a\\'];\\n    }\\n    return res;        \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int partitionString(String s) {\\n    int[] pos = new int[26];\\n    int res = 0, last = 0;\\n    for (int i = 0; i < s.length(); ++i) {\\n        if (pos[s.charAt(i) - \\'a\\'] >= last) {\\n            ++res;\\n            last = i + 1;\\n        }\\n        pos[s.charAt(i) - \\'a\\'] = i + 1;\\n    }\\n    return res;  \\n}\\n```\n```cpp\\nint partitionString(string s) {\\n    int pos[26] = {}, res = 0, last = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (pos[s[i] - \\'a\\'] >= last) {\\n            ++res;\\n            last = i + 1;\\n        }\\n        pos[s[i] - \\'a\\'] = i + 1;\\n    }\\n    return res;        \\n}\\n```\n```cpp\\nint partitionString(string s) {\\n    int cnt[26] = {}, res = 1;\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (cnt[s[i] - \\'a\\']) {\\n            ++res;\\n            fill(begin(cnt), end(cnt), 0);\\n        }\\n        ++cnt[s[i] - \\'a\\'];\\n    }\\n    return res;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3376536,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n# OR \\n**Click the Link in my Leetcode Profile to Subscribe**\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\n- We will iterate through the given string s.\\n- For each character in s, we will maintain the last position seen for that character.\\n- We will also maintain the last end position seen in a partition.\\n- If the last position seen for the current character is greater than or equal to the last end position seen, we have found a new partition.\\n- We increment the number of partitions seen and update the last end position seen.\\n- Finally, we return the total number of partitions seen.\\n\\n# Intuition:\\n\\n- We need to divide the string into minimum number of non-empty substrings such that each character appears in only one substring.\\n- We can keep track of the last position seen for each character in the string.\\n- If we encounter a character for which the last position seen is less than the last end position seen in the current partition, we know that the character has already appeared in a previous substring.\\n- In such a case, we need to start a new partition and update the last end position seen to the current index.\\n- We keep track of the number of partitions seen and return the result.\\n\\n```Python []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        last_pos = [0] * 26\\n        partitions = 0\\n        last_end = 0\\n        for i in range(len(s)):\\n            if last_pos[ord(s[i]) - ord(\\'a\\')] >= last_end:\\n                partitions += 1\\n                last_end = i + 1\\n            last_pos[ord(s[i]) - ord(\\'a\\')] = i + 1\\n        return partitions\\n\\n```\\n```Java []\\nclass Solution {\\n    public int partitionString(String s) {\\n        int[] last_pos = new int[26];\\n        int partitions = 0;\\n        int last_end = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (last_pos[s.charAt(i) - \\'a\\'] >= last_end) {\\n                partitions++;\\n                last_end = i + 1;\\n            }\\n            last_pos[s.charAt(i) - \\'a\\'] = i + 1;\\n        }\\n        return partitions;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int last_pos[26] = {}, partitions = 0, last_end = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (last_pos[s[i] - \\'a\\'] >= last_end) {\\n                partitions++;\\n                last_end = i + 1;\\n            }\\n            last_pos[s[i] - \\'a\\'] = i + 1;\\n        }\\n        return partitions;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```Python []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        last_pos = [0] * 26\\n        partitions = 0\\n        last_end = 0\\n        for i in range(len(s)):\\n            if last_pos[ord(s[i]) - ord(\\'a\\')] >= last_end:\\n                partitions += 1\\n                last_end = i + 1\\n            last_pos[ord(s[i]) - ord(\\'a\\')] = i + 1\\n        return partitions\\n\\n```\n```Java []\\nclass Solution {\\n    public int partitionString(String s) {\\n        int[] last_pos = new int[26];\\n        int partitions = 0;\\n        int last_end = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (last_pos[s.charAt(i) - \\'a\\'] >= last_end) {\\n                partitions++;\\n                last_end = i + 1;\\n            }\\n            last_pos[s.charAt(i) - \\'a\\'] = i + 1;\\n        }\\n        return partitions;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int last_pos[26] = {}, partitions = 0, last_end = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (last_pos[s[i] - \\'a\\'] >= last_end) {\\n                partitions++;\\n                last_end = i + 1;\\n            }\\n            last_pos[s[i] - \\'a\\'] = i + 1;\\n        }\\n        return partitions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376567,
                "title": "hashing-c-easy-approach",
                "content": "# **PLS UPVOTE \\uD83D\\uDC4D**\\n# Approach\\n- **Using hash function, characters of string are stored and when count exceeds more than one, reset the count and increment answer by 1**.\\n\\n---\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.size();\\n\\n        vector<int>hsh(26,0);\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(hsh[s[i]-\\'a\\'] != 0)\\n            {\\n                cnt++;\\n                for(int i = 0; i < 26; i++)\\n                {\\n                    hsh[i] = 0; // reset all count to 0\\n                }\\n                hsh[s[i]-\\'a\\']++;\\n            }\\n            else\\n            {\\n                hsh[s[i]-\\'a\\']++;\\n            }\\n        }\\n\\n        return cnt+1; //add 1 to store last string partition\\n    }\\n};\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/fb267570-aa65-422d-baa0-ee4de4ba10d0_1680568129.0276124.png)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.size();\\n\\n        vector<int>hsh(26,0);\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(hsh[s[i]-\\'a\\'] != 0)\\n            {\\n                cnt++;\\n                for(int i = 0; i < 26; i++)\\n                {\\n                    hsh[i] = 0; // reset all count to 0\\n                }\\n                hsh[s[i]-\\'a\\']++;\\n            }\\n            else\\n            {\\n                hsh[s[i]-\\'a\\']++;\\n            }\\n        }\\n\\n        return cnt+1; //add 1 to store last string partition\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560023,
                "title": "java-c-solution-beginner-friendly-with-comments",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```JAVA```\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count = (s.isEmpty()) ? 0 : 1;\\n        HashSet<Character> letters = new HashSet<Character>(); // creating a set to find unique letters in substring\\n        for (int i = 0; i < s.length(); i++) {\\n            if (letters.contains(s.charAt(i))) { // if we encounter a duplicate\\n                letters.clear(); // remove all letters in set\\n                count++; // increment count\\n            }\\n            letters.add(s.charAt(i)); \\n        }\\n        return count;\\n    }\\n}\\n```\\n```C++ Solution By @shiv99265(Posted In Comments)```\\n```\\nint partitionString(string s) {\\n   unordered_set<char>st;\\n    int count =1;\\n    for(int i = 0;i<s.size();i++){\\n        if(st.find(s[i])!=st.end()){\\n            count++;\\n            st.clear();\\n            st.insert(s[i]);\\n        }else\\n            st.insert(s[i]);\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Ordered Set"
                ],
                "code": "```JAVA```\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count = (s.isEmpty()) ? 0 : 1;\\n        HashSet<Character> letters = new HashSet<Character>(); // creating a set to find unique letters in substring\\n        for (int i = 0; i < s.length(); i++) {\\n            if (letters.contains(s.charAt(i))) { // if we encounter a duplicate\\n                letters.clear(); // remove all letters in set\\n                count++; // increment count\\n            }\\n            letters.add(s.charAt(i)); \\n        }\\n        return count;\\n    }\\n}\\n```\n```C++ Solution By @shiv99265(Posted In Comments)```\n```\\nint partitionString(string s) {\\n   unordered_set<char>st;\\n    int count =1;\\n    for(int i = 0;i<s.size();i++){\\n        if(st.find(s[i])!=st.end()){\\n            count++;\\n            st.clear();\\n            st.insert(s[i]);\\n        }else\\n            st.insert(s[i]);\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560044,
                "title": "python3-greedy",
                "content": "**Weekly Contest 310 Submission**\\n\\n**Greedy**\\n1. Iterate through each ```c``` in ```s```. Create a running set ```cur```. If ```c``` is ever already in ```cur``` increment ```res``` and reset ```cur```.\\n2. Return the number of times we reset ```cur``` + 1 (```res```).\\n\\n**Code**\\n```Python3 []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        cur = set()\\n        res = 1\\n        \\n        for c in s:\\n            if c in cur:\\n                cur = set()\\n                res += 1\\n            cur.add(c)\\n                \\n        return res\\n```\\nSimilar methodology to [2414. Length of the Longest Alphabetical Continuous Substring](https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/discuss/2590138/python3-one-pass) (single pass variable refresh)",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```c```\n```s```\n```cur```\n```c```\n```cur```\n```res```\n```cur```\n```cur```\n```res```\n```Python3 []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        cur = set()\\n        res = 1\\n        \\n        for c in s:\\n            if c in cur:\\n                cur = set()\\n                res += 1\\n            cur.add(c)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376595,
                "title": "easy-solutiong-with-hashing",
                "content": "Jai maa Bhavani \\uD83D\\uDEA9\\uD83D\\uDEA9\\uD83D\\uDD49\\uFE0F\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are using hash array to check if element appeared before or not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a hash array boolean type and fill it with false value at all the places\\nWe are cheking if a character appeared before if yes increment ans by one and fill hash array with false else we can make true in hash array at valid position \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are traversing string once so the time complexity is O(N)\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using extra 26 size boolean array (Constant space) so that space complexity is O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        boolean []hash = new boolean[26];\\n        Arrays.fill(hash,false);\\n\\n        int i = 0,ans = 1;\\n        while(i<s.length()){\\n            int n = s.charAt(i)-\\'a\\';\\n            if(hash[n]==true){\\n                Arrays.fill(hash,false);\\n                ans++;\\n            }\\n            hash[n] = true;\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\nHar Har Mahadev\\uD83D\\uDD49\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        boolean []hash = new boolean[26];\\n        Arrays.fill(hash,false);\\n\\n        int i = 0,ans = 1;\\n        while(i<s.length()){\\n            int n = s.charAt(i)-\\'a\\';\\n            if(hash[n]==true){\\n                Arrays.fill(hash,false);\\n                ans++;\\n            }\\n            hash[n] = true;\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560423,
                "title": "java-concise-and-efficient-bit-manipulation",
                "content": "Just be greedy, duplicate character found = new partition.\\n```\\n public int partitionString(String s) {\\n        int map = 0;\\n        int count = 1;\\n        for(char c : s.toCharArray()){\\n            if((map & (1<<c)) != 0) {\\n                count++;\\n                map = 0;\\n            }\\n            map ^= (1<<c);\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int partitionString(String s) {\\n        int map = 0;\\n        int count = 1;\\n        for(char c : s.toCharArray()){\\n            if((map & (1<<c)) != 0) {\\n                count++;\\n                map = 0;\\n            }\\n            map ^= (1<<c);\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3378543,
                "title": "easiest-c-string-implementation",
                "content": "# Intuition\\nWe just have to count substrings which have no duplicate characters.\\n\\n# Approach\\nIf the string length is 1, then obviously answer is 1.\\n\\nElse we have to count the no of distinct substrings.\\n\\nWe start by creating a set which will store distinct characters encountered till current time.\\n\\nInitially we insert the first character s[0] into the set.\\nWe then run a loop from i=1 to i=length-1 \\nwhich will check if the current character is not present in the set.\\nIn that case we will insert that character into the set.\\n\\nElse if that character is found , then we take this as a substring and increment our ans variable.\\nThen we clear the set and insert the current element into the set.\\n\\nOur final answer will obviously be ans+1 since we did not increment our ans variable when we were generating our final substring.\\n\\nThanks!\\n\\n# Complexity\\n- Time complexity:\\nO(n) for string traversal and O(n) for find() function.\\nSo overall  T.C : O(n).\\n\\n- Space complexity:\\nO(n) since we are creating a set which can have at max n elements in the worst case.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.length();\\n        if(n==1)\\n            return 1;\\n        \\n        int ans = 0;\\n        set<char>freq; \\n        freq.insert(s[0]);\\n\\n        for(int i=1; i<n ;i++){\\n            if(freq.find(s[i]) == freq.end() )\\n                freq.insert(s[i]);\\n            \\n            else\\n            {\\n                ans++;\\n                freq.clear();\\n                freq.insert(s[i]);\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.length();\\n        if(n==1)\\n            return 1;\\n        \\n        int ans = 0;\\n        set<char>freq; \\n        freq.insert(s[0]);\\n\\n        for(int i=1; i<n ;i++){\\n            if(freq.find(s[i]) == freq.end() )\\n                freq.insert(s[i]);\\n            \\n            else\\n            {\\n                ans++;\\n                freq.clear();\\n                freq.insert(s[i]);\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377417,
                "title": "c-easy-set-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set<char>st;\\n        int g=1;\\n        for(int i=0;i<s.size();i++){\\n            if(st.find(s[i])!=st.end()){\\n                g++;\\n                st.clear();\\n                st.insert(s[i]);\\n            }\\n            else {\\n                st.insert(s[i]);\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/c842b50a-e025-48ab-8dd8-72272b9952a8_1680585578.8252864.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set<char>st;\\n        int g=1;\\n        for(int i=0;i<s.size();i++){\\n            if(st.find(s[i])!=st.end()){\\n                g++;\\n                st.clear();\\n                st.insert(s[i]);\\n            }\\n            else {\\n                st.insert(s[i]);\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562388,
                "title": "c-greedy-bitmask-clean-code-fast-0ms",
                "content": "**TODO(heder): Insert cute cat meme to ask for upvotes. ;)**\\n\\n### Solution 1: greedy, bitmasking\\n\\nAs soon as we see a character the second time we need to start a new partition.\\n\\n```\\n    static int partitionString(const string& s) {\\n        int ans = 1;\\n        int seen = 0;\\n        for (char ch : s) {\\n            const int mask = 1 << (ch - \\'a\\');\\n            if (seen & mask) {\\n                ++ans;\\n                seen = 0;\\n            }\\n            seen |= mask;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**EDIT**: I could achieve a good speed up by using bitmasking (https://leetcode.com/submissions/detail/927759816/) instead of substration (disclaimer the runtimes are not very predictable), i.e.:\\n```\\n            const int mask = 1 << (ch & 31);\\n```\\n\\nIt\\'s intersting to see that clang produces quite different code for this minor change: https://godbolt.org/z/qK6haEjs9\\n\\n**Complexity Analysis**\\n  * Time Complexity: O(n), with n = size(s). We are looking at each character of the input exactly once.\\n  * Space Complexity: O(1)\\n\\n_As always: Feedback, questions, and comments are welcome. Please upvote if you find this post useful. Join us on [discord](https://discord.gg/Nqm4jJcyBf)._\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Bitmask"
                ],
                "code": "```\\n    static int partitionString(const string& s) {\\n        int ans = 1;\\n        int seen = 0;\\n        for (char ch : s) {\\n            const int mask = 1 << (ch - \\'a\\');\\n            if (seen & mask) {\\n                ++ans;\\n                seen = 0;\\n            }\\n            seen |= mask;\\n        }\\n        return ans;\\n    }\\n```\n```\\n            const int mask = 1 << (ch & 31);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2564809,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // the idea is to keep each partition as long as possible \\n    // so that we could have the minimum number of substrings\\n    int partitionString(string s) {\\n        // the minimum number of substring is at least 1\\n        // e.g. \"a\"\\n        int ans = 1;\\n        // cnt is used to count the frequency of each character\\n        vector<int> cnt(26);\\n        // for each character\\n        for (auto& c : s) {\\n            // we check if it exists before\\n            // if so, then we should create a new partition\\n            // because no letter appears in a single substring more than once\\n            if (cnt[c - \\'a\\']) {\\n                // reset the counter\\n                cnt = vector<int>(26);\\n                // create a new partition\\n                ans++;\\n            }\\n            // increase the frequency of the current character by 1\\n            cnt[c - \\'a\\']++;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // the idea is to keep each partition as long as possible \\n    // so that we could have the minimum number of substrings\\n    int partitionString(string s) {\\n        // the minimum number of substring is at least 1\\n        // e.g. \"a\"\\n        int ans = 1;\\n        // cnt is used to count the frequency of each character\\n        vector<int> cnt(26);\\n        // for each character\\n        for (auto& c : s) {\\n            // we check if it exists before\\n            // if so, then we should create a new partition\\n            // because no letter appears in a single substring more than once\\n            if (cnt[c - \\'a\\']) {\\n                // reset the counter\\n                cnt = vector<int>(26);\\n                // create a new partition\\n                ans++;\\n            }\\n            // increase the frequency of the current character by 1\\n            cnt[c - \\'a\\']++;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377167,
                "title": "java-easy-solution-explained-with-hashset-beginner-friendly",
                "content": "# Intuition\\nKeep it simple and *don\\'t overcomplicate* this by thinking of sliding window and other concepts. Since the question wants us to find partition input string into substrings when there is a repeating character, its clear that we can simply use ***Hashmap or even Set data structure*** to maintain which character we have already seen.\\n\\n---\\n\\n\\n# Approach\\n1) Intialise Set datastructure\\n2) Iterate over each character in the input string\\n2) We will keep adding character to set if it is not present.\\n3) If the set.contains() return true for a character, we know we have reached a point where duplication of some character has taken place\\n- so we clear the set since we found a partition.\\n- increment the substring count i.e count++\\n4) Keep repeating till string ends\\n5) Reason why ***count+1 is done***, +1 covers the last substring as well.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n): Since we traverse through entire string.\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/ab7232ea-232c-46d1-be02-9225fa524323_1680581501.9734488.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        int count=0;\\n\\n        for(int i=0;i<s.length();i++){\\n            if(set.contains(s.charAt(i))){\\n                count++;\\n                set.clear();\\n            }\\n            set.add(s.charAt(i));\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        int count=0;\\n\\n        for(int i=0;i<s.length();i++){\\n            if(set.contains(s.charAt(i))){\\n                count++;\\n                set.clear();\\n            }\\n            set.add(s.charAt(i));\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377064,
                "title": "c-beat-100-hashing-easy-5-line-code",
                "content": "\\n# Approach\\nThing is not repeat any character in our string so we will take record of each charecter in our string , if upcoming charter is going to repeat we will creat a new string and erase old record.\\n\\nusing `ar[26]` is best way to have record\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nConstant O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ar[26] , c=1;\\n        for(int a: s){\\n            if(ar[a-\\'a\\']==1){\\n                c++;\\n                memset(ar,0,sizeof(ar));\\n            }\\n            ar[a-\\'a\\'] = 1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ar[26] , c=1;\\n        for(int a: s){\\n            if(ar[a-\\'a\\']==1){\\n                c++;\\n                memset(ar,0,sizeof(ar));\\n            }\\n            ar[a-\\'a\\'] = 1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376615,
                "title": "java-easy-solution-using-hashset-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count=(s.isEmpty())? 0:1;\\n        \\n        s=s.toLowerCase();\\n        HashSet<Character> letter =new HashSet<Character>();\\n        for(int i=0;i<s.length();i++){\\n            if(letter.contains(s.charAt(i))){\\n                letter.clear();\\n                count ++;\\n            }\\n            letter.add(s.charAt(i));\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count=(s.isEmpty())? 0:1;\\n        \\n        s=s.toLowerCase();\\n        HashSet<Character> letter =new HashSet<Character>();\\n        for(int i=0;i<s.length();i++){\\n            if(letter.contains(s.charAt(i))){\\n                letter.clear();\\n                count ++;\\n            }\\n            letter.add(s.charAt(i));\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377259,
                "title": "c-easy-solution-with-explanation-two-approaches",
                "content": "# Intuition\\nAs we need to find substrings so we could see substrings to be divided as various windows to be seperated . Hence we could keep track of seen characters and as we see a duplicate character appear we can say that here is the place where window will be broken.\\n\\n# Approach - 1\\n1. We keep track of seen characters using a set of characters.\\n2. We keep increasing the window untill we see the characters are different .\\n3. As soon as we see a character that is same we break , increase count and clear our set for next iteration\\n\\n# Complexity\\n- Time complexity: O(N) * log (26)\\n\\n- Space complexity: O(26)\\n\\n# Code - 1\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set<char> st;\\n        int j = 0 , cnt = 0;\\n        for(int i = 0 ; i < s.size() ; i++){\\n            while(i < s.size() && st.find(s[i]) == st.end()){\\n                st.insert(s[i]);\\n                i++;\\n            }\\n            i--;\\n            cnt++;\\n            st.clear();\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# Approach - 2\\n1. We keep track of characters using a visited array.\\n2. We keep increasing the window untill we see the characters are different.\\n3. As soon as we see a character that is same we break , increase count and clear our array for next iteration.\\n4. we check at the last for any remaining characters.\\n\\n# Complexity\\n- Time complexity: O(N * 26)\\n\\n- Space complexity: O(26)\\n# Code - 2\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int cnt = 0;\\n        int streak = 0;\\n        vector<int> vis(26 , 0);\\n        vis[s[0] - \\'a\\'] = 1;\\n        for(int i = 1 ; i < s.size(); i++){\\n            if(vis[s[i] - \\'a\\'] == 0){\\n                vis[s[i] - \\'a\\'] = 1;\\n            }\\n            else{\\n                cnt++;\\n                for(int i = 0 ; i < 26 ; i++){\\n                    vis[i] = 0;\\n                }\\n                vis[s[i] - \\'a\\'] = 1;\\n            }\\n        }\\n        for(int i = 0 ; i < 26 ; i++){\\n            if(vis[i] == 1){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set<char> st;\\n        int j = 0 , cnt = 0;\\n        for(int i = 0 ; i < s.size() ; i++){\\n            while(i < s.size() && st.find(s[i]) == st.end()){\\n                st.insert(s[i]);\\n                i++;\\n            }\\n            i--;\\n            cnt++;\\n            st.clear();\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int cnt = 0;\\n        int streak = 0;\\n        vector<int> vis(26 , 0);\\n        vis[s[0] - \\'a\\'] = 1;\\n        for(int i = 1 ; i < s.size(); i++){\\n            if(vis[s[i] - \\'a\\'] == 0){\\n                vis[s[i] - \\'a\\'] = 1;\\n            }\\n            else{\\n                cnt++;\\n                for(int i = 0 ; i < 26 ; i++){\\n                    vis[i] = 0;\\n                }\\n                vis[s[i] - \\'a\\'] = 1;\\n            }\\n        }\\n        for(int i = 0 ; i < 26 ; i++){\\n            if(vis[i] == 1){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560283,
                "title": "easy-understandable-approach-explained-beginner-friendly",
                "content": "```\\n/*\\n    Approach\\n    \\n    As need to make partition by substrings, so the partition must be continuous in the given string\\n    The substring must be unique and the number of partitions must be minimum\\n    \\n    So, by starting traversing from left-to-right, put characters in a set until you found a character that already present in the set\\n    If found the character in the set, at this time the characters present in the set forms the longest substring\\n    now increase the counter and make set empty.\\n    \\n    Ex: s = \"abacaba\"\\n    initially, set = { }\\n    \\n    start traversing from left-to-right\\n    \\n    count = 0\\n    a -> not present in set -> {\\'a\\'}\\n    b -> not present in set -> { \\'a\\', \\'b\\' }\\n    a -> present in set -> count=1, set { } -> set{\\'a\\'} // put current character n set for future \\n    c -> not present in set -> { \\'a\\', \\'c\\' }\\n    a -> present in set -> count=2 , set{} -> set{\\'a\\'}\\n    b -> not present in set -> set{\\'a\\',\\'b\\'}\\n    a -> present in set -> count=3, set{} -> set{\\'a\\'}\\n    \\n    now traversing ends\\n    but set is not empty, so this will also make a substring\\n    Hence count++ -> count=4\\n    \\n    result  = 4\\n*/\\nclass Solution {\\n    public int partitionString(String s) {\\n        char[] arr = s.toCharArray();\\n        \\n        int count = 0;\\n        Set<Character> set = new HashSet<>();\\n        for(char e : arr){\\n            \\n            // If character found in set\\n            if(set.contains(e)){\\n                // increase the counter\\n                count++;\\n                \\n                // make set empty\\n                set = new HashSet<>();\\n            }\\n            set.add(e);\\n        }\\n        \\n        // If something present in the set, then that will also make a substring\\n        if(!set.isEmpty()) count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    Approach\\n    \\n    As need to make partition by substrings, so the partition must be continuous in the given string\\n    The substring must be unique and the number of partitions must be minimum\\n    \\n    So, by starting traversing from left-to-right, put characters in a set until you found a character that already present in the set\\n    If found the character in the set, at this time the characters present in the set forms the longest substring\\n    now increase the counter and make set empty.\\n    \\n    Ex: s = \"abacaba\"\\n    initially, set = { }\\n    \\n    start traversing from left-to-right\\n    \\n    count = 0\\n    a -> not present in set -> {\\'a\\'}\\n    b -> not present in set -> { \\'a\\', \\'b\\' }\\n    a -> present in set -> count=1, set { } -> set{\\'a\\'} // put current character n set for future \\n    c -> not present in set -> { \\'a\\', \\'c\\' }\\n    a -> present in set -> count=2 , set{} -> set{\\'a\\'}\\n    b -> not present in set -> set{\\'a\\',\\'b\\'}\\n    a -> present in set -> count=3, set{} -> set{\\'a\\'}\\n    \\n    now traversing ends\\n    but set is not empty, so this will also make a substring\\n    Hence count++ -> count=4\\n    \\n    result  = 4\\n*/\\nclass Solution {\\n    public int partitionString(String s) {\\n        char[] arr = s.toCharArray();\\n        \\n        int count = 0;\\n        Set<Character> set = new HashSet<>();\\n        for(char e : arr){\\n            \\n            // If character found in set\\n            if(set.contains(e)){\\n                // increase the counter\\n                count++;\\n                \\n                // make set empty\\n                set = new HashSet<>();\\n            }\\n            set.add(e);\\n        }\\n        \\n        // If something present in the set, then that will also make a substring\\n        if(!set.isEmpty()) count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377539,
                "title": "day-94-hash-table-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n*The intuition behind this code is to use an unordered_set to keep track of the unique characters seen in a substring, and to increment a count every time a new substring is found. The algorithm starts by initializing the index i to 0 and the minimum count of substrings to 0. Then, it enters a while loop which continues until i reaches the end of the string. Within the loop, it first increments the minimum count of substrings by 1, since we have found a new substring. Then, it enters another while loop which continues until we reach the end of the string or we encounter a character that has already been seen in the current substring. For each new character encountered, it is added to the unordered_set of unique characters seen so far. If the end of the string is reached or a repeat character is found, the unordered_set is cleared, and the outer while loop continues from where it left off, incrementing the minimum count of substrings as necessary. Finally, the minimum count of substrings is returned as the output. The basic idea is to keep track of the unique characters in each substring, and whenever we encounter a repeat character or the end of the string, we start a new substring and increment the minimum count.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Create an unordered_set of characters to keep track of unique characters in the current substring.\\n2. Initialize a variable i to 0 to keep track of the current index in the string.\\n3. Initialize a variable minCount to 0 to keep track of the minimum number of substrings required.\\n4. While i is less than the length of the string, do the following:\\n    - a. Increment minCount by 1 to count the current substring.\\n    - b. While i is less than the length of the string and the current character s[i] is not in the set checkUniqueAlphabet, do the following:\\n        - i. Add the current character s[i] to the set checkUniqueAlphabet.\\n        - ii. Increment i to move to the next character in the string.\\n    - c. Clear the set checkUniqueAlphabet to prepare for the next substring.\\n1. Return the minCount as the minimum number of substrings required.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_set<char> checkUniqueAlphabet;\\n        int i = 0;\\n        int minCount = 0;\\n        while (i < s.length()) {\\n            minCount++;\\n            while (i < s.length() && checkUniqueAlphabet.find(s[i]) == checkUniqueAlphabet.end()) {\\n                checkUniqueAlphabet.insert(s[i]);\\n                i++;\\n            }\\n            checkUniqueAlphabet.clear();\\n        }\\n        return minCount;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int partitionString(String s) {\\n        Set<Character> checkUniqueAlphabet = new HashSet<>();\\n        int i = 0;\\n        int minCount = 0;\\n        while (i < s.length()) {\\n            minCount++;\\n            while (i < s.length() && !checkUniqueAlphabet.contains(s.charAt(i))) {\\n                checkUniqueAlphabet.add(s.charAt(i));\\n                i++;\\n            }\\n            checkUniqueAlphabet.clear();\\n        }\\n        return minCount;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        checkUniqueAlphabet = set()\\n        i = 0\\n        minCount = 0\\n        while i < len(s):\\n            minCount += 1\\n            while i < len(s) and s[i] not in checkUniqueAlphabet:\\n                checkUniqueAlphabet.add(s[i])\\n                i += 1\\n            checkUniqueAlphabet.clear()\\n        return minCount\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(n)**, where n is the length of string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(26) = O(1)**, bcz in worst case there are 26 unique character\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_set<char> checkUniqueAlphabet;\\n        int i = 0;\\n        int minCount = 0;\\n        while (i < s.length()) {\\n            minCount++;\\n            while (i < s.length() && checkUniqueAlphabet.find(s[i]) == checkUniqueAlphabet.end()) {\\n                checkUniqueAlphabet.insert(s[i]);\\n                i++;\\n            }\\n            checkUniqueAlphabet.clear();\\n        }\\n        return minCount;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int partitionString(String s) {\\n        Set<Character> checkUniqueAlphabet = new HashSet<>();\\n        int i = 0;\\n        int minCount = 0;\\n        while (i < s.length()) {\\n            minCount++;\\n            while (i < s.length() && !checkUniqueAlphabet.contains(s.charAt(i))) {\\n                checkUniqueAlphabet.add(s.charAt(i));\\n                i++;\\n            }\\n            checkUniqueAlphabet.clear();\\n        }\\n        return minCount;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        checkUniqueAlphabet = set()\\n        i = 0\\n        minCount = 0\\n        while i < len(s):\\n            minCount += 1\\n            while i < len(s) and s[i] not in checkUniqueAlphabet:\\n                checkUniqueAlphabet.add(s[i])\\n                i += 1\\n            checkUniqueAlphabet.clear()\\n        return minCount\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376770,
                "title": "partition-of-string-java-array-o-n",
                "content": "Hi,\\n\\n**Approach:**\\n* \\tMaintain a array of size 26 to see if there is any count greater than 1.\\n* \\tIf more than 1 then add one to result value, repeat this process till length of string and that\\'s all.\\n\\nHope now it looks easy peasy, do upvote just one click away...\\n\\n#savesoil and save planet\\n\\n```\\n    public int partitionString(String s) {\\n        int[] alpha = new int[26];\\n        int res=1;\\n        for(int i=0; i<s.length();i++){\\n        \\tif(alpha[s.charAt(i)-\\'a\\']+1>1){\\n        \\t\\tres++;\\n        \\t\\talpha = new int[26];\\n        \\t}\\n        \\talpha[s.charAt(i)-\\'a\\']++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "Hi,\\n\\n**Approach:**\\n* \\tMaintain a array of size 26 to see if there is any count greater than 1.\\n* \\tIf more than 1 then add one to result value, repeat this process till length of string and that\\'s all.\\n\\nHope now it looks easy peasy, do upvote just one click away...\\n\\n#savesoil and save planet\\n\\n```\\n    public int partitionString(String s) {\\n        int[] alpha = new int[26];\\n        int res=1;\\n        for(int i=0; i<s.length();i++){\\n        \\tif(alpha[s.charAt(i)-\\'a\\']+1>1){\\n        \\t\\tres++;\\n        \\t\\talpha = new int[26];\\n        \\t}\\n        \\talpha[s.charAt(i)-\\'a\\']++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2564325,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int start_id = 0, end_id = 0, partition_count = 0;\\n        while(end_id < s.length()){\\n            if(s.substring(start_id, end_id).contains(s.charAt(end_id)+\"\")){\\n                partition_count++;\\n                start_id = end_id;\\n            }\\n            end_id++;\\n        }\\n        if(s.substring(start_id, end_id).contains(s.charAt(end_id-1)+\"\")){\\n            partition_count++;\\n        }\\n        return partition_count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar partitionString = function(s) {\\n    let start_id = 0, end_id = 0, partition_count = 0;\\n    while(end_id < s.length){\\n        if(s.substring(start_id, end_id).includes(s[end_id]+\"\")){\\n            partition_count++;\\n            start_id = end_id;\\n        }\\n        end_id++;\\n    }\\n    if(s.substring(start_id, end_id).includes(s[end_id-1]+\"\")){\\n        partition_count++;\\n    }\\n    return partition_count;\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def partitionString(self, s):\\n        start_id = end_id = partition_count = 0\\n        while end_id < len(s):\\n            if s[end_id] in s[start_id:end_id]:\\n                partition_count += 1\\n                start_id = end_id \\n            end_id += 1\\n        if s[end_id-1] in s[start_id:end_id]:\\n            partition_count += 1\\n        return partition_count\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int start_id = 0, end_id = 0, partition_count = 0;\\n        while(end_id < s.length()){\\n            if(s.substring(start_id, end_id).contains(s.charAt(end_id)+\"\")){\\n                partition_count++;\\n                start_id = end_id;\\n            }\\n            end_id++;\\n        }\\n        if(s.substring(start_id, end_id).contains(s.charAt(end_id-1)+\"\")){\\n            partition_count++;\\n        }\\n        return partition_count;\\n    }\\n}\\n```\n```\\nvar partitionString = function(s) {\\n    let start_id = 0, end_id = 0, partition_count = 0;\\n    while(end_id < s.length){\\n        if(s.substring(start_id, end_id).includes(s[end_id]+\"\")){\\n            partition_count++;\\n            start_id = end_id;\\n        }\\n        end_id++;\\n    }\\n    if(s.substring(start_id, end_id).includes(s[end_id-1]+\"\")){\\n        partition_count++;\\n    }\\n    return partition_count;\\n};\\n```\n```\\nclass Solution(object):\\n    def partitionString(self, s):\\n        start_id = end_id = partition_count = 0\\n        while end_id < len(s):\\n            if s[end_id] in s[start_id:end_id]:\\n                partition_count += 1\\n                start_id = end_id \\n            end_id += 1\\n        if s[end_id-1] in s[start_id:end_id]:\\n            partition_count += 1\\n        return partition_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560229,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n\\n        def isUnique(s):\\n            return len(set(s)) == len(s)\\n\\t\\t\\t\\n\\t\\tleft = 0\\n        res = 0\\n        for right in range(1,len(s)+1):\\n            if not isUnique(s[left:right]):\\n                res += 1\\n                left = right-1\\n                \\n        return res+1 # don\\'t forget there is still one partition we didn\\'t add into res\\n                \\n",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n\\n        def isUnique(s):\\n            return len(set(s)) == len(s)\\n\\t\\t\\t\\n\\t\\tleft = 0\\n        res = 0\\n        for right in range(1,len(s)+1):\\n            if not isUnique(s[left:right]):\\n                res += 1\\n                left = right-1\\n                \\n        return res+1 # don\\'t forget there is still one partition we didn\\'t add into res\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 2567843,
                "title": "java-7ms-100-bitmask-greedy",
                "content": "Straight forward greedy, add as much as possible into current partition, that\\'ll also make next partition much easier.\\n[7ms submission](https://leetcode.com/submissions/detail/798176446/)\\n# Bitmask\\n```java\\nclass Solution {\\n    public int partitionString(String s) {\\n        int res = 1, mask = 0; // at least 1 partition\\n        for (char c : s.toCharArray()) {\\n            int maskc = 1 << (c-\\'a\\');\\n            // if ((mask >> (c-\\'a\\') & 1) == 1) {\\n            if ((maskc & mask) > 0) { // this char has already been used in cur partition\\n                mask = maskc; // start a new partition with cur char\\n                res++; // count the new partition\\n            } else mask |= maskc; // add cur char to cur partition\\n        }\\n        return res;\\n    }\\n}\\n```\\n# Boolean Array\\nif bitmask is not user friendly, you could also use boolean array\\n```java\\nclass Solution {\\n    public int partitionString(String s) {\\n        int res = 1;\\n        boolean[] dup = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (dup[c-\\'a\\']) {\\n                dup = new boolean[26];\\n                res++;\\n            }\\n            dup[c-\\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    public int partitionString(String s) {\\n        int res = 1, mask = 0; // at least 1 partition\\n        for (char c : s.toCharArray()) {\\n            int maskc = 1 << (c-\\'a\\');\\n            // if ((mask >> (c-\\'a\\') & 1) == 1) {\\n            if ((maskc & mask) > 0) { // this char has already been used in cur partition\\n                mask = maskc; // start a new partition with cur char\\n                res++; // count the new partition\\n            } else mask |= maskc; // add cur char to cur partition\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int partitionString(String s) {\\n        int res = 1;\\n        boolean[] dup = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (dup[c-\\'a\\']) {\\n                dup = new boolean[26];\\n                res++;\\n            }\\n            dup[c-\\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380666,
                "title": "very-easy-java-solution-with-explanation-hashset",
                "content": "# PLEASE UPVOTE!!!\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraversing the string and looking for repeated letters using HashSet.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialise the result to length of the string.\\nTraversing the string, for each letter checking for its repetition in current set.\\nFor each letter in the current set result is minimised.\\nIf Present clear the set and insert the current letter.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(K)\\nwhere K is the longest substring with non repeating character.\\n\\n![leetcodeupvotetrick.png](https://assets.leetcode.com/users/images/96ab2132-248f-449b-83e3-6a2c7b924893_1680634082.7468045.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        int res = s.length()+1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if(!set.contains(s.charAt(i))){\\n                set.add(s.charAt(i));\\n                res--;\\n            }\\n            else{\\n                set.clear();\\n                set.add(s.charAt(i));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        int res = s.length()+1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if(!set.contains(s.charAt(i))){\\n                set.add(s.charAt(i));\\n                res--;\\n            }\\n            else{\\n                set.clear();\\n                set.add(s.charAt(i));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379212,
                "title": "set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar partitionString = function(s) {\\n    let cnt = 1;\\n    let set = new Set();\\n    for (let i = 0; i < s.length; i++) {\\n        if (!set.has(s[i])) {\\n            set.add(s[i]);\\n        } else {\\n            cnt++;\\n            set = new Set([s[i]]);\\n        }\\n    }\\n    return cnt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar partitionString = function(s) {\\n    let cnt = 1;\\n    let set = new Set();\\n    for (let i = 0; i < s.length; i++) {\\n        if (!set.has(s[i])) {\\n            set.add(s[i]);\\n        } else {\\n            cnt++;\\n            set = new Set([s[i]]);\\n        }\\n    }\\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3377456,
                "title": "solution-using-set",
                "content": "# Intuition\\nFirst determine, how you have to create substrings based on the problem description.\\n\\n# Approach\\nTraverse the string and start adding the elements in the set if it\\'s not already present. As soon as you encounter the element which is already present in the set, then make a partition.\\nWe are creating partitions hypothetically, just by clearing the set and increasing the value of the count variable as soon as we encounter any element which is already present in the set. Repeat this process until we iterate over the entire string.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\nIn worst case, we might need to store all the disticnt characters in the Hashset, which actually is a constant value. So, space complexity is constant.\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count =1;\\n        Set<Character> set = new HashSet<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            if(!set.contains(s.charAt(i))){\\n                set.add(s.charAt(i));\\n            }else{\\n                count++;\\n                set.clear();\\n                set.add(s.charAt(i));\\n                \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count =1;\\n        Set<Character> set = new HashSet<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            if(!set.contains(s.charAt(i))){\\n                set.add(s.charAt(i));\\n            }else{\\n                count++;\\n                set.clear();\\n                set.add(s.charAt(i));\\n                \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377263,
                "title": "python-short-and-clean-1-liner-2-approaches-hashset-bit-manipulation-functional-programming",
                "content": "# Approach 1: HashSet\\nTL;DR, Same as [Editorial solution](https://leetcode.com/problems/optimal-partition-of-string/editorial/).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is length of s`.\\n\\n# Code\\nImperative multi-liner:\\n```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        seen = set()\\n        count = 1\\n        for c in s:\\n            if c in seen: count += 1; seen = set()\\n            seen.add(c)\\n        return count\\n\\n\\n```\\nFunctional 1-liner:\\n```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        return reduce(\\n            lambda a, c: ({c}, a[1] + 1) if c in a[0] else (a[0].add(c) or a[0], a[1]),\\n            s,\\n            (set(), 1), # (seen hashset, count)\\n        )[1]\\n\\n\\n```\\n\\n---\\n# Approach 2: Bit Manipulation.\\nTL;DR, Same as [Editorial solution](https://leetcode.com/problems/optimal-partition-of-string/editorial/) but using bit manipulation instead of hashset.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of s`.\\n\\n# Code\\nImperative multi-liner:\\n```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        seen = 0\\n        count = 1\\n        for c in s:\\n            x = 1 << (ord(c) - ord(\"a\"))\\n            if seen & x: count += 1; seen = 0\\n            seen |= x\\n        return count\\n\\n\\n```\\nFunctional 1-liner:\\n```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        return reduce(\\n            lambda a, x: (x, a[1] + 1) if a[0] & x else (a[0] | x, a[1]),\\n            map(lambda c: 1 << (ord(c) - ord(\"a\")), s),\\n            (0, 1),  # (seen bit mask, count)\\n        )[1]\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        seen = set()\\n        count = 1\\n        for c in s:\\n            if c in seen: count += 1; seen = set()\\n            seen.add(c)\\n        return count\\n\\n\\n```\n```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        return reduce(\\n            lambda a, c: ({c}, a[1] + 1) if c in a[0] else (a[0].add(c) or a[0], a[1]),\\n            s,\\n            (set(), 1), # (seen hashset, count)\\n        )[1]\\n\\n\\n```\n```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        seen = 0\\n        count = 1\\n        for c in s:\\n            x = 1 << (ord(c) - ord(\"a\"))\\n            if seen & x: count += 1; seen = 0\\n            seen |= x\\n        return count\\n\\n\\n```\n```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        return reduce(\\n            lambda a, x: (x, a[1] + 1) if a[0] & x else (a[0] | x, a[1]),\\n            map(lambda c: 1 << (ord(c) - ord(\"a\")), s),\\n            (0, 1),  # (seen bit mask, count)\\n        )[1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376941,
                "title": "c-easiest-solution-hashmap-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easiest Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFHashMap Approach || Heavily commented**\\n# **Please Upvote as it really motivates me**\\nApproach :\\nwe will maintain a hashmap and keep putting the char untill we encounter a char which has already occured in the string previously and then we will increament our no. of substring count by one and clear the hash map\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n=s.size();\\n        unordered_map<char,int>m;\\n\\t\\t//we will have the ans equal to 1 always as we can take the whole string\\n        int ans=1;\\n\\t\\t//now we will start putting char in the hashmap\\n        for(int i=0;i<n;i++){\\n\\t\\t//checking if the char already occured\\n            if(m.count(s[i])){\\n\\t\\t\\t//increasing ans by 1\\n                ans++;\\n\\t\\t\\t//clearing the hashmap\\n                m.clear();\\n            }\\n\\t\\t\\t//putting char in hashmap\\n            m[s[i]]=i;\\n        }\\n\\t\\t//returning the ans\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n=s.size();\\n        unordered_map<char,int>m;\\n\\t\\t//we will have the ans equal to 1 always as we can take the whole string\\n        int ans=1;\\n\\t\\t//now we will start putting char in the hashmap\\n        for(int i=0;i<n;i++){\\n\\t\\t//checking if the char already occured\\n            if(m.count(s[i])){\\n\\t\\t\\t//increasing ans by 1\\n                ans++;\\n\\t\\t\\t//clearing the hashmap\\n                m.clear();\\n            }\\n\\t\\t\\t//putting char in hashmap\\n            m[s[i]]=i;\\n        }\\n\\t\\t//returning the ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562865,
                "title": "javascript-easy-to-understand-2-steps-solution-100",
                "content": "Runtime: 178 ms, faster than 100.00% of JavaScript online submissions for Optimal Partition of String.\\nMemory Usage: 49.7 MB, less than 100.00% of JavaScript online submissions for Optimal Partition of String.\\n\\n```\\nconst partitionString = (s, count=1, map = new Map()) => {\\n    for(let i=0; i<s.length; i++) {\\n        if(map.has(s[i])){\\n            count++;\\n            map = new Map();\\n        }\\n        map.set(s[i], 1);\\n    }\\n    return count;\\n};\\n```\\n\\nOpen for suggestions.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst partitionString = (s, count=1, map = new Map()) => {\\n    for(let i=0; i<s.length; i++) {\\n        if(map.has(s[i])){\\n            count++;\\n            map = new Map();\\n        }\\n        map.set(s[i], 1);\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560227,
                "title": "simple-beginner-solution-using-map-with-intuition-and-code-with-comments",
                "content": "We have to find the minimum number of substrings in such a way, when we partition the string into one or more substrings such that the characters in each substring are unique i.e. no letter appears in a single substring more than once.\\n\\nObservation:\\nSubstring doesn\\'t contain any character more than once. If it contains then we have to make another substring and increment count of substring.\\nSo we need to check the character present or not previously, this can be done using unordered_map.\\n\\nIntuition:\\n1. Create a unordered_map and map the characters.\\n2. If the character is not present in map then map it, else increment the count and clear the map to   check new substring characters.\\n3. Finally return count.   \\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_map<char,int> mp;  //create a map\\n        int cnt=1;                   //initialize count \\n        for(int i=0;i<s.size();i++){\\n            if(!mp[s[i]]){           //map character    \\n                mp[s[i]]++;\\n            }\\n            else{ \\n                cnt++;               //increment count\\n                mp.clear();          //clear map\\n                mp[s[i]]++;          //mapping current character.\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nTC: O(N) for iterating whole array\\nSC: O(N) for unordered_map\\nwhere N is size of num array.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_map<char,int> mp;  //create a map\\n        int cnt=1;                   //initialize count \\n        for(int i=0;i<s.size();i++){\\n            if(!mp[s[i]]){           //map character    \\n                mp[s[i]]++;\\n            }\\n            else{ \\n                cnt++;               //increment count\\n                mp.clear();          //clear map\\n                mp[s[i]]++;          //mapping current character.\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560088,
                "title": "sliding-window-explained-solution-simple-cpp-solution",
                "content": "###  Upvote if you like\\n\\n    // Simple Sliding Window Question........\\n    // logic:\\n    /* just make a map and for ever new character check if it is present in the map or not there may be 2 conditions \\n        1. the character is already present in the map in that case we have to increase the count and simply clear the map for next unique window\\n        2. if the character is not present then simply add it to the map.\\n        */\\n    int partitionString(string s) {\\n        int count = 1, i=0 , j=0;\\n        unordered_map<char,int>mp;\\n            int n = s.length();\\n        while(j<n)\\n        {\\n            if(mp.find(s[j])==mp.end())\\n            {\\n                mp[s[j]]++;\\n                j++;\\n            }\\n            else\\n            {\\n                count++;\\n                mp.clear();\\n            }\\n        }\\n        return count;\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "###  Upvote if you like\\n\\n    // Simple Sliding Window Question........\\n    // logic:\\n    /* just make a map and for ever new character check if it is present in the map or not there may be 2 conditions \\n        1. the character is already present in the map in that case we have to increase the count and simply clear the map for next unique window\\n        2. if the character is not present then simply add it to the map.\\n        */\\n    int partitionString(string s) {\\n        int count = 1, i=0 , j=0;\\n        unordered_map<char,int>mp;\\n            int n = s.length();\\n        while(j<n)\\n        {\\n            if(mp.find(s[j])==mp.end())\\n            {\\n                mp[s[j]]++;\\n                j++;\\n            }\\n            else\\n            {\\n                count++;\\n                mp.clear();\\n            }\\n        }\\n        return count;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3377087,
                "title": "day-369-java-c-python-bit-manipulation-o-1-explained-proof",
                "content": "![image.png](https://assets.leetcode.com/users/images/a2267944-10b8-41f2-b624-81a67ccea163_1680148646.205976.png)\\n\\n# Please Upvote as it really motivates me\\n# BIT manipulation\\n# Intuition &  Approach\\n##### \\u2022\\tThe problem of partitioning a string into as many parts as possible such that each letter appears in at most one part.\\n##### \\u2022\\tThe approach uses a bit manipulation technique to keep track of the occurrence of each character in the string. It initializes a variable \\'map\\' to 0 and a variable \\'count\\' to 1. Then, it iterates through each character in the string using a for-each loop.\\n##### \\u2022\\tFor each character, it checks if the character has already occurred in the current partition by using the bitwise AND operator with the \\'map\\' variable. If the result is not 0, it means the character has already occurred, and a new partition needs to be created. In this case, the \\'count\\' variable is incremented, and the \\'map\\' variable is reset to 0.\\n##### \\u2022\\tIf the character has not occurred in the current partition, it is added to the \\'map\\' variable using the bitwise XOR operator. This sets the bit corresponding to the character to 1 in the \\'map\\' variable.\\n##### \\u2022\\tAfter iterating through all the characters in the string, the function returns the \\'count\\' variable, which represents the number of partitions required to satisfy the given condition.\\n\\n\\n# Code\\n```JAVA []\\n    public int partitionString(String s) {\\n         int map = 0;\\n        int count = 1;\\n        for(char c : s.toCharArray()){\\n            if((map & (1<<c)) != 0) {\\n                count++;\\n                map = 0;\\n            }\\n            map ^= (1<<c);\\n        }\\n        return count;\\n}\\n```\\n```PYTHON []\\ndef partitionString(s: str) -> int:\\n    map = 0\\n    count = 1\\n    for c in s:\\n        if (map & (1 << ord(c))) != 0:\\n            count += 1\\n            map = 0\\n        map ^= (1 << ord(c))\\n    return count\\n```\\n```C++ []\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\nclass Solution\\n{\\npublic:\\n\\tint partitionString(std::string s)\\n\\t{\\n\\t\\tauto result = 0;\\n\\n\\t\\tfor (auto iter = std::cbegin(s); iter != std::cend(s);)\\n\\t\\t{\\n\\t\\t\\t++result;\\n\\n\\t\\t\\tauto set = 0U;\\n\\t\\t\\tfor (; iter != std::cend(s); ++iter)\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto c = *iter;\\n\\t\\t\\t\\tauto prior = set;\\n\\t\\t\\t\\tset |= 1U << (c - \\'a\\');\\n\\t\\t\\t\\tif (set == prior) { break; }\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```\\n# TC AND SC\\n##### \\u2022\\tOverall, the solution has a time complexity of O(n), where n is the length of the input string, as it iterates through the string only once.\\n# SC =O(1)\\n\\n# 2ND USING ARRAY\\n# Intuition &  Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### \\u2022\\tWe use an array of size 26 to keep track of the characters in the ongoing substring.\\n##### \\u2022\\tWe store the beginning of the current substring as well as keep track of the most recent position of each character.\\n##### \\u2022\\tThis allows us to determine whether the current character is already present in the current substring.\\n##### \\u2022\\tOther data structures, such as a hash set, can be used for minor space optimization in cases where we may not have all of the 26 characters added to the hash set.\\n##### \\u2022\\tHowever, we must clear the hash set completely at the start of each substring, resulting in some additional operations.\\n\\n```JAVA []\\nclass Solution {\\n    public int partitionString(String s) {\\n        int[] lastSeen = new int[26];\\n        Arrays.fill(lastSeen, -1);\\n        int count = 1, substringStart = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (lastSeen[s.charAt(i) - \\'a\\'] >= substringStart) {\\n                count++;\\n                substringStart = i;\\n            }\\n            lastSeen[s.charAt(i) - \\'a\\'] = i;\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        vector<int> lastSeen(26, -1);\\n        int count = 1, substringStart = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (lastSeen[s[i] - \\'a\\'] >= substringStart) {\\n                count++;\\n                substringStart = i;\\n            }\\n            lastSeen[s[i] - \\'a\\'] = i;\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n```PYTHON []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        lastSeen = [-1]*26\\n        count = 1\\n        substringStarting = 0\\n\\n        for i in range(len(s)):\\n            if lastSeen[ord(s[i]) - ord(\\'a\\')] >= substringStarting:\\n                count += 1\\n                substringStarting = i\\n            lastSeen[ord(s[i]) - ord(\\'a\\')] = i\\n\\n        return count\\n```\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# 3RD ONE LINER\\n```C++ []\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\n\\nclass Solution\\n{\\npublic:\\n\\tint partitionString(std::string const& s)\\n\\t{\\n\\t\\treturn std::accumulate(std::cbegin(s), std::cend(s), 1,\\n\\t\\t\\t[observed = std::array<int, 26>{0}](auto count, auto c) mutable\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (observed[c - \\'a\\'] == count) { ++count; }\\n\\t\\t\\t\\treturn observed[c - \\'a\\'] = count;\\n\\t\\t\\t});\\n\\t}\\n};\\n```\\n# dry run \\n\\u2022\\tFor the input string \"abacaba\", the function will iterate through each character in the string and keep track of the characters seen so far using a bit mask.\\n\\u2022\\tInitially, the bit mask is 0 and the count is 1.\\n\\u2022\\tFor the first character \\'a\\', the bit mask is updated to 1 (1<<\\'a\\') and the count remains 1.\\n\\u2022\\tFor the second character \\'b\\', the bit mask is updated to 3 (1<<\\'a\\' | 1<<\\'b\\') and the count remains 1.\\n\\u2022\\tFor the third character \\'a\\', the bit mask is updated to 2 (1<<\\'b\\') and the count remains 1.\\n\\u2022\\tFor the fourth character \\'c\\', the bit mask is updated to 10 (1<<\\'b\\' | 1<<\\'c\\') and the count remains 1.\\n\\u2022\\tFor the fifth character \\'a\\', the bit mask is updated to 8 (1<<\\'c\\') and the count remains 1.\\n\\u2022\\tFor the sixth character \\'b\\', the bit mask is updated to 24 (1<<\\'a\\' | 1<<\\'c\\' | 1<<\\'b\\') and the count remains 1.\\n\\u2022\\tFor the seventh character \\'a\\', the bit mask is updated to 16 (1<<\\'a\\' | 1<<\\'c\\') and the count is incremented to 2 because the bit mask already contains the character \\'a\\'.\\n\\u2022\\tThe final count is 4, which is the minimum number of substrings needed to partition the string.\\n\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```JAVA []\\n    public int partitionString(String s) {\\n         int map = 0;\\n        int count = 1;\\n        for(char c : s.toCharArray()){\\n            if((map & (1<<c)) != 0) {\\n                count++;\\n                map = 0;\\n            }\\n            map ^= (1<<c);\\n        }\\n        return count;\\n}\\n```\n```PYTHON []\\ndef partitionString(s: str) -> int:\\n    map = 0\\n    count = 1\\n    for c in s:\\n        if (map & (1 << ord(c))) != 0:\\n            count += 1\\n            map = 0\\n        map ^= (1 << ord(c))\\n    return count\\n```\n```C++ []\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\nclass Solution\\n{\\npublic:\\n\\tint partitionString(std::string s)\\n\\t{\\n\\t\\tauto result = 0;\\n\\n\\t\\tfor (auto iter = std::cbegin(s); iter != std::cend(s);)\\n\\t\\t{\\n\\t\\t\\t++result;\\n\\n\\t\\t\\tauto set = 0U;\\n\\t\\t\\tfor (; iter != std::cend(s); ++iter)\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto c = *iter;\\n\\t\\t\\t\\tauto prior = set;\\n\\t\\t\\t\\tset |= 1U << (c - \\'a\\');\\n\\t\\t\\t\\tif (set == prior) { break; }\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public int partitionString(String s) {\\n        int[] lastSeen = new int[26];\\n        Arrays.fill(lastSeen, -1);\\n        int count = 1, substringStart = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (lastSeen[s.charAt(i) - \\'a\\'] >= substringStart) {\\n                count++;\\n                substringStart = i;\\n            }\\n            lastSeen[s.charAt(i) - \\'a\\'] = i;\\n        }\\n\\n        return count;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        vector<int> lastSeen(26, -1);\\n        int count = 1, substringStart = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (lastSeen[s[i] - \\'a\\'] >= substringStart) {\\n                count++;\\n                substringStart = i;\\n            }\\n            lastSeen[s[i] - \\'a\\'] = i;\\n        }\\n\\n        return count;\\n    }\\n};\\n```\n```PYTHON []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        lastSeen = [-1]*26\\n        count = 1\\n        substringStarting = 0\\n\\n        for i in range(len(s)):\\n            if lastSeen[ord(s[i]) - ord(\\'a\\')] >= substringStarting:\\n                count += 1\\n                substringStarting = i\\n            lastSeen[ord(s[i]) - ord(\\'a\\')] = i\\n\\n        return count\\n```\n```C++ []\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\n\\nclass Solution\\n{\\npublic:\\n\\tint partitionString(std::string const& s)\\n\\t{\\n\\t\\treturn std::accumulate(std::cbegin(s), std::cend(s), 1,\\n\\t\\t\\t[observed = std::array<int, 26>{0}](auto count, auto c) mutable\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (observed[c - \\'a\\'] == count) { ++count; }\\n\\t\\t\\t\\treturn observed[c - \\'a\\'] = count;\\n\\t\\t\\t});\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3376750,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n\\n\\n        public int PartitionString(string s)\\n        {\\n            if (string.IsNullOrEmpty(s)) return 0;\\n            int result = 1;\\n\\n            HashSet<char> chars = new HashSet<char>();\\n\\n            foreach (char c in s)\\n            {\\n                if (chars.Contains(c))\\n                {\\n                    result++;\\n                    chars = new HashSet<char>() { c };\\n\\n                }\\n                else\\n                {\\n                    chars.Add(c);\\n                }\\n            }\\n\\n            return result;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n\\n        public int PartitionString(string s)\\n        {\\n            if (string.IsNullOrEmpty(s)) return 0;\\n            int result = 1;\\n\\n            HashSet<char> chars = new HashSet<char>();\\n\\n            foreach (char c in s)\\n            {\\n                if (chars.Contains(c))\\n                {\\n                    result++;\\n                    chars = new HashSet<char>() { c };\\n\\n                }\\n                else\\n                {\\n                    chars.Add(c);\\n                }\\n            }\\n\\n            return result;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376709,
                "title": "hash-map-easily-done-c-constant-space",
                "content": "# Intuition\\nClearly it is given that we have to find substrings with unique characters, so we have to use hashing.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nKeep iterating till any of the element is seen double, once u find the repeated element, then simply decrement all element freq which are greater than zero.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        vector<int> v(26,0);\\n        int count=1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            v[s[i]-\\'a\\']++;\\n            if(v[s[i]-\\'a\\']>1)\\n            {\\n                count++;\\n                for(int j=0;j<26;j++) if(v[j]>0) v[j]--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        vector<int> v(26,0);\\n        int count=1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            v[s[i]-\\'a\\']++;\\n            if(v[s[i]-\\'a\\']>1)\\n            {\\n                count++;\\n                for(int j=0;j<26;j++) if(v[j]>0) v[j]--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376611,
                "title": "c-100-simplest-solution-easy-to-understand",
                "content": "## Intuition / approach\\nObserve that no letters can be in more than one substring\\nTherefore, we can use a greedy approach:\\n-- Starting from the beginning of the string, store which letters appear for each index\\n-- If an index\\'s letter already exists, increment the result and reset the current letters (starting a new substring)\\n\\n## Code\\n\\nTime: $$O(n)$$\\nSpace: $$O(1)$$\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int partitionString(string str) {\\n        bool found[26]{};\\n        int res = 1;\\n        for (char c: str) {\\n            if (found[c-\\'a\\']) {\\n                // Because a duplicate appeared, we must begin a new substring\\n                ++res;\\n                memset(found, 0, sizeof found);\\n            }\\n            found[c-\\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n};\\n```\\nResetting the `found` array is pretty fast, but there are still 26 values to reset.\\nBy storing the current level of the `found` array using an int, we can \"reset\" the found array by simply increasing the level.\\nFortunately, we already have a variable to do that (the result variable)\\n```cpp\\nclass Solution {\\npublic:\\n    int partitionString(string str) {\\n        int found[26]{};\\n        int res = 1;\\n        for (char c: str) {\\n            if (found[c-\\'a\\'] == res) {\\n                // Because a duplicate appeared, we must begin a new substring\\n                ++res;  // This will also \"reset\" the array\\n            }\\n            found[c-\\'a\\'] = res;\\n        }\\n        return res;\\n    }\\n};\\n```\\nOr, use a bitwise solution to further increase the speed\\nNote that this only works because we have 26 keys (26 <= 32)\\n```cpp\\nclass Solution {\\npublic:\\n    int partitionString(string str) {\\n        int res = 1, found = 0;\\n        for (char c: str) {\\n            if (found & 1<<c-\\'a\\') {\\n                ++res;\\n                found = 0;\\n            }\\n            found |= 1<<c-\\'a\\';\\n        }\\n        return res;\\n    }\\n};\\n```\\nStill not fast enough? Add these lines at the start of your function\\n```cpp\\ncin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int partitionString(string str) {\\n        bool found[26]{};\\n        int res = 1;\\n        for (char c: str) {\\n            if (found[c-\\'a\\']) {\\n                // Because a duplicate appeared, we must begin a new substring\\n                ++res;\\n                memset(found, 0, sizeof found);\\n            }\\n            found[c-\\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int partitionString(string str) {\\n        int found[26]{};\\n        int res = 1;\\n        for (char c: str) {\\n            if (found[c-\\'a\\'] == res) {\\n                // Because a duplicate appeared, we must begin a new substring\\n                ++res;  // This will also \"reset\" the array\\n            }\\n            found[c-\\'a\\'] = res;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int partitionString(string str) {\\n        int res = 1, found = 0;\\n        for (char c: str) {\\n            if (found & 1<<c-\\'a\\') {\\n                ++res;\\n                found = 0;\\n            }\\n            found |= 1<<c-\\'a\\';\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\ncin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2561654,
                "title": "easy-solution-with-explaianation-using-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n      unordered_set<char>st;\\n        int n=s.length();\\n        int ans=0,i=0;\\n        \\n        while(i<n){\\n           while(i<n && st.count(s[i])==0){\\n               st.insert(s[i]);\\n               i++;\\n           } \\n           st.clear();\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n      unordered_set<char>st;\\n        int n=s.length();\\n        int ans=0,i=0;\\n        \\n        while(i<n){\\n           while(i<n && st.count(s[i])==0){\\n               st.insert(s[i]);\\n               i++;\\n           } \\n           st.clear();\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560069,
                "title": "python-easy-greedy-solution",
                "content": "```\\n    # python greedy solution\\n    def partitionString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"        \\n        res = 0\\n        seen = set()\\n        for c in s:\\n            if c not in seen:\\n                seen.add(c)\\n            else:\\n                seen.clear()\\n                res += 1\\n                seen.add(c)\\n        res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n    # python greedy solution\\n    def partitionString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"        \\n        res = 0\\n        seen = set()\\n        for c in s:\\n            if c not in seen:\\n                seen.add(c)\\n            else:\\n                seen.clear()\\n                res += 1\\n                seen.add(c)\\n        res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3999079,
                "title": "java-99-beats-0-n-2-solution-hashset-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int temp[] = new int[26];\\n        int count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            int a = s.charAt(i)-\\'a\\';\\n            if(temp[a]!=0){\\n                count++;\\n                Arrays.fill(temp,0);\\n                temp[a]++;\\n            }\\n            temp[a]++;\\n        }\\n        return count+1;\\n\\n\\n//        Another Solution (Using HashSet<>)\\n        // Set<Character> set = new HashSet<>();\\n        // int count = 0;\\n        // for(int i=0; i<s.length(); i++){\\n        //     if(!set.contains(s.charAt(i))) set.add(s.charAt(i));\\n        //     else{\\n        //         count++;\\n        //         set.clear(); set.add(s.charAt(i));\\n        //     }\\n        // }\\n        // return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int temp[] = new int[26];\\n        int count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            int a = s.charAt(i)-\\'a\\';\\n            if(temp[a]!=0){\\n                count++;\\n                Arrays.fill(temp,0);\\n                temp[a]++;\\n            }\\n            temp[a]++;\\n        }\\n        return count+1;\\n\\n\\n//        Another Solution (Using HashSet<>)\\n        // Set<Character> set = new HashSet<>();\\n        // int count = 0;\\n        // for(int i=0; i<s.length(); i++){\\n        //     if(!set.contains(s.charAt(i))) set.add(s.charAt(i));\\n        //     else{\\n        //         count++;\\n        //         set.clear(); set.add(s.charAt(i));\\n        //     }\\n        // }\\n        // return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931411,
                "title": "good-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        char[] arr = s.toCharArray();\\n        int i = 0;\\n        int count = 0;\\n        \\n        while (i < arr.length) {\\n            int j = i + 1;\\n            boolean[] seen = new boolean[26]; // To track characters seen in the current substring\\n            \\n            seen[arr[i] - \\'a\\'] = true; // Mark the first character as seen\\n            \\n            while (j < arr.length && !seen[arr[j] - \\'a\\']) {\\n                seen[arr[j] - \\'a\\'] = true; // Mark new characters as seen\\n                j++;\\n            }\\n            \\n            count++; // Increment the count for each substring\\n            i = j; // Move i to the next substring\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        char[] arr = s.toCharArray();\\n        int i = 0;\\n        int count = 0;\\n        \\n        while (i < arr.length) {\\n            int j = i + 1;\\n            boolean[] seen = new boolean[26]; // To track characters seen in the current substring\\n            \\n            seen[arr[i] - \\'a\\'] = true; // Mark the first character as seen\\n            \\n            while (j < arr.length && !seen[arr[j] - \\'a\\']) {\\n                seen[arr[j] - \\'a\\'] = true; // Mark new characters as seen\\n                j++;\\n            }\\n            \\n            count++; // Increment the count for each substring\\n            i = j; // Move i to the next substring\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654678,
                "title": "most-simple-prefix-count-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ans = 1;\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            if(v[i-\\'a\\']){\\n                ans++;\\n                fill(v.begin(),v.end(),0);\\n            }\\n            v[i-\\'a\\']++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ans = 1;\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            if(v[i-\\'a\\']){\\n                ans++;\\n                fill(v.begin(),v.end(),0);\\n            }\\n            v[i-\\'a\\']++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579169,
                "title": "pure-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nint partitionString(char * s){\\n    int ret = 1;\\n    char arr[26]={0};\\n    memset(arr, 0, 26);\\n\\n    for(int i = 0; i < strlen(s); i++)\\n    {\\n        arr[s[i]-\\'a\\']++;\\n        if(arr[s[i]-\\'a\\'] ==2)\\n        {\\n            ret++;\\n            memset(arr, 0, 26);\\n            i--;\\n        }\\n    }\\n    return ret;\\n}\\n \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint partitionString(char * s){\\n    int ret = 1;\\n    char arr[26]={0};\\n    memset(arr, 0, 26);\\n\\n    for(int i = 0; i < strlen(s); i++)\\n    {\\n        arr[s[i]-\\'a\\']++;\\n        if(arr[s[i]-\\'a\\'] ==2)\\n        {\\n            ret++;\\n            memset(arr, 0, 26);\\n            i--;\\n        }\\n    }\\n    return ret;\\n}\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3383011,
                "title": "simple-6-line-java-code-easy-to-understand-approach",
                "content": "# Intuition\\n1) Try to make a partition whenever you get same element.\\n2) Whenever you create new partition, add old partition to new list.\\n3) return size of that list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n***Remember, You can\\'t take maximum frequent element as problem explicitly says that a substring is needed.\\nSubstring is nothing but a continuous collection of strings.***\\n\\n1) Use a greedy approach to make every partition.\\n2) Whenever you find a element that already exist in a 1D ArrayList ```arr``` then add ```arr``` to ```main```(2D ArrayList).\\nif not then add elements to ```arr```.\\n```\\nif(!arr.contains(s.charAt(i))){ // if arr doesn\\'t contain repeating strings\\n    arr.add(s.charAt(i));\\n    i++;\\n}\\nelse{\\n    main.add(arr);// if it contains then add to main.\\n    arr = new ArrayList<>();\\n}\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int n = s.length();\\n        List<List<Character>> main = new ArrayList<>();\\n        List<Character> arr = new ArrayList<>();\\n        int i = 0; \\n        while(i < n){\\n            if(!arr.contains(s.charAt(i))){\\n                arr.add(s.charAt(i));\\n                i++;\\n            }\\n            else{\\n                main.add(arr);\\n                arr = new ArrayList<>();\\n            }\\n        }\\n        main.add(arr);\\n        return main.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```arr```\n```arr```\n```main```\n```arr```\n```\\nif(!arr.contains(s.charAt(i))){ // if arr doesn\\'t contain repeating strings\\n    arr.add(s.charAt(i));\\n    i++;\\n}\\nelse{\\n    main.add(arr);// if it contains then add to main.\\n    arr = new ArrayList<>();\\n}\\n```\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int n = s.length();\\n        List<List<Character>> main = new ArrayList<>();\\n        List<Character> arr = new ArrayList<>();\\n        int i = 0; \\n        while(i < n){\\n            if(!arr.contains(s.charAt(i))){\\n                arr.add(s.charAt(i));\\n                i++;\\n            }\\n            else{\\n                main.add(arr);\\n                arr = new ArrayList<>();\\n            }\\n        }\\n        main.add(arr);\\n        return main.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380904,
                "title": "greedy-algorithm-python3",
                "content": "\\n\\n# Greedy Approach \\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        partition=set()\\n        count=0\\n        for n in s:\\n            if n in partition:\\n                count+=1\\n                partition=set()\\n                partition.add(n)\\n            else:\\n                partition.add(n)\\n        return count+1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        partition=set()\\n        count=0\\n        for n in s:\\n            if n in partition:\\n                count+=1\\n                partition=set()\\n                partition.add(n)\\n            else:\\n                partition.add(n)\\n        return count+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379138,
                "title": "c-easy-solution-with-explanation-using-sets-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo here we have to partition the string into substrings where each substring should have unique characters. If a character appears in the string which has already appeared in the current substring , then we will create a new substring. Iterate through the string to create substrings that contains unique characters and maintain the count of each new sbstring created.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start with the first character of the string by iterating through it and putting it into a set. Then for every next character first we check if this character belongs to the set or not. \\n\\n-If $$yes$$, we will increase the count by unity and clear the existing string and insert our character into the empty set, just like using the analogy as if we are creating a substring.\\n\\n-If $$no$$, then we will simply insert this character into the set.\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s)\\n    {\\n        int n = s.length(), ans = 1;\\n\\n        set<char> st;\\n        st.insert(s[0]);\\n\\n        for (int i = 1; s[i] != \\'\\\\0\\'; i++)\\n        {\\n            auto pos = st.find(s[i]);\\n\\n            if (pos == st.end())\\n            {\\n                st.insert(s[i]);\\n            }\\n            else\\n            {\\n                ans++;\\n                st.clear();\\n                st.insert(s[i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s)\\n    {\\n        int n = s.length(), ans = 1;\\n\\n        set<char> st;\\n        st.insert(s[0]);\\n\\n        for (int i = 1; s[i] != \\'\\\\0\\'; i++)\\n        {\\n            auto pos = st.find(s[i]);\\n\\n            if (pos == st.end())\\n            {\\n                st.insert(s[i]);\\n            }\\n            else\\n            {\\n                ans++;\\n                st.clear();\\n                st.insert(s[i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378553,
                "title": "python-java-elegant-short-hashset-bitmask",
                "content": "# Hash Set\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n## Code\\n```python []\\nclass Solution:\\n\\n    def partitionString(self, s: str) -> int:\\n        used = set()\\n        partitions = 0\\n\\n        for c in s:\\n            if c in used:\\n                used.clear()\\n                partitions += 1\\n            used.add(c)\\n\\n        return partitions + 1\\n```\\n```java []\\npublic class Solution {\\n\\n    public int partitionString(String s) {\\n        HashSet<Character> usedChars = new HashSet<>();\\n        int numOfPartitions = 0;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (usedChars.contains(s.charAt(i))) {\\n                usedChars.clear();\\n                numOfPartitions += 1;\\n            }\\n            usedChars.add(s.charAt(i));\\n        }\\n\\n        return numOfPartitions + 1;\\n    }\\n}\\n\\n```\\n\\n# Bit Mask\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n## Code\\n```python []\\nclass Solution:\\n\\n    def partitionString(self, s: str) -> int:\\n        used = 0\\n        partitions = 0\\n\\n        for c in s:\\n            bit = 1 << ord(c) - ord(\\'a\\')\\n            if used & bit != 0:\\n                used = 0\\n                partitions += 1\\n            used |= bit\\n\\n        return partitions + 1\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "```python []\\nclass Solution:\\n\\n    def partitionString(self, s: str) -> int:\\n        used = set()\\n        partitions = 0\\n\\n        for c in s:\\n            if c in used:\\n                used.clear()\\n                partitions += 1\\n            used.add(c)\\n\\n        return partitions + 1\\n```\n```java []\\npublic class Solution {\\n\\n    public int partitionString(String s) {\\n        HashSet<Character> usedChars = new HashSet<>();\\n        int numOfPartitions = 0;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (usedChars.contains(s.charAt(i))) {\\n                usedChars.clear();\\n                numOfPartitions += 1;\\n            }\\n            usedChars.add(s.charAt(i));\\n        }\\n\\n        return numOfPartitions + 1;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n\\n    def partitionString(self, s: str) -> int:\\n        used = 0\\n        partitions = 0\\n\\n        for c in s:\\n            bit = 1 << ord(c) - ord(\\'a\\')\\n            if used & bit != 0:\\n                used = 0\\n                partitions += 1\\n            used |= bit\\n\\n        return partitions + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378467,
                "title": "easy-solve-13-lines-of-code-1-for-and-1-if-else",
                "content": "# Intuition\\nI solved something like this before!\\n\\n# Approach\\nI need to use ArrayList, to add char in it and everytime check if we already have this char in array, or not.\\nif we havent this char - we adding one\\nif we have this char - res++(new substring), clearing array(because we alredy have this substring and we need to start next one) and adding this symbol(because this is new substring)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun partitionString(s: String): Int {\\n        var arr: ArrayList<Char> = arrayListOf()\\n        var res = 1\\n        for (i in s) {\\n            if (i !in arr) {\\n                arr.add(i)\\n            }\\n            else {\\n                res++\\n                arr.clear()\\n                arr.add(i)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    fun partitionString(s: String): Int {\\n        var arr: ArrayList<Char> = arrayListOf()\\n        var res = 1\\n        for (i in s) {\\n            if (i !in arr) {\\n                arr.add(i)\\n            }\\n            else {\\n                res++\\n                arr.clear()\\n                arr.add(i)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378422,
                "title": "well-explained-code-in-java-using-hashset",
                "content": "# Approach\\nIt is done by using a HashSet data structure to keep track of the characters seen so far. It starts by initializing an integer variable count to 0 and an empty HashSet named set.\\n\\nThen, it iterates through each character c in the input string s, checking if it is already present in the set using the contains() method. If it is, it means that a new substring needs to be created, and the count variable is incremented. Then, a new HashSet is created and initialized with the current character c, and the process is repeated for the next substring.\\n\\nIf the character c is not already present in the set, it is added to the set, and the iteration continues to the next character.\\n\\nFinally, if the set is not empty after iterating through all the characters in the string, it means that there is one more substring that needs to be created, so the count variable is incremented.\\n\\nOnce all the characters have been processed, the count value is returned as the output of the method.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(n), where n is the length of the input string s. This is because the method iterates through each character in the string once, and the operations performed on each character take constant time.\\n\\n\\n\\n\\n- Space complexity:\\nThe space complexity is O(k), where k is the size of the character set in the input string. This is because the HashSet set can potentially store up to k characters, where k is the number of distinct characters in the input string. In the worst case, where all the characters in the string are distinct, the space complexity would be O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count = 0;\\n        HashSet<Character> set = new HashSet<>();\\n        for(char c : s.toCharArray()){\\n            if(set.contains(c)){\\n                count++;\\n                set = new HashSet<>();\\n                set.add(c);\\n            }else{\\n                set.add(c);\\n            }            \\n        }\\n        if(!set.isEmpty()){\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/35a7f7dc-8b37-47dd-9591-4689875129a0_1680599758.11999.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count = 0;\\n        HashSet<Character> set = new HashSet<>();\\n        for(char c : s.toCharArray()){\\n            if(set.contains(c)){\\n                count++;\\n                set = new HashSet<>();\\n                set.add(c);\\n            }else{\\n                set.add(c);\\n            }            \\n        }\\n        if(!set.isEmpty()){\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378141,
                "title": "easy-java-solution-hashset-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Add current char in a hashSet.\\n2. If current element is in already hashSet mean we need to start a new partion, clear the hashSet and store current element.\\n\\n# Complexity\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        Set<Character> set = new HashSet<>();\\n       \\n        int totalCount = 1; // nonempty string can be always in fit 1 partion\\n        \\n        for(char ch : s.toCharArray()) {\\n             // If current char is not present in set, add it\\n            if(!set.contains(ch)) {\\n                set.add(ch);\\n            } else {\\n               // if current char is present, clear the set and add current element, increase totalcount.\\n                set.clear();\\n                set.add(ch);\\n                totalCount++;\\n            }\\n        }\\n        return totalCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        Set<Character> set = new HashSet<>();\\n       \\n        int totalCount = 1; // nonempty string can be always in fit 1 partion\\n        \\n        for(char ch : s.toCharArray()) {\\n             // If current char is not present in set, add it\\n            if(!set.contains(ch)) {\\n                set.add(ch);\\n            } else {\\n               // if current char is present, clear the set and add current element, increase totalcount.\\n                set.clear();\\n                set.add(ch);\\n                totalCount++;\\n            }\\n        }\\n        return totalCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376891,
                "title": "my-10-line-java-code-with-hashset",
                "content": "# Intuition\\nUse HashSet.\\n\\n# Approach\\nTraverse through the string if diplicate is not there add character to the HashSet otherwise increase count and clear Hashset.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        int count=1,i=0;\\n        while(i<s.length())\\n        {\\n            if(!set.add(s.charAt(i)))\\n            {\\n                count++;\\n                set.clear();\\n            }\\n            else\\n                i++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n![87473a41-9c53-4e65-967e-15f92ebc9310_1677233624.267395.jpeg](https://assets.leetcode.com/users/images/585fa2c6-80c9-4586-a469-e232e34f3a44_1680576910.277929.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        int count=1,i=0;\\n        while(i<s.length())\\n        {\\n            if(!set.add(s.charAt(i)))\\n            {\\n                count++;\\n                set.clear();\\n            }\\n            else\\n                i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376879,
                "title": "simple-java-solution-in-linear-time",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count = 0;\\n        int i = 0;\\n        int n = s.length();\\n        s = s.toLowerCase();\\n        while(i<n){\\n            boolean[] vis = new boolean[26];\\n            for(int j = i; j<n; j++){\\n                int x = s.charAt(j) - \\'a\\';\\n                if(vis[x]){\\n                    i = j;\\n                    count++;\\n                    break;\\n                } else {\\n                    vis[x] = true;\\n                    if(j == n-1){\\n                        count++;\\n                        i = j+1;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count = 0;\\n        int i = 0;\\n        int n = s.length();\\n        s = s.toLowerCase();\\n        while(i<n){\\n            boolean[] vis = new boolean[26];\\n            for(int j = i; j<n; j++){\\n                int x = s.charAt(j) - \\'a\\';\\n                if(vis[x]){\\n                    i = j;\\n                    count++;\\n                    break;\\n                } else {\\n                    vis[x] = true;\\n                    if(j == n-1){\\n                        count++;\\n                        i = j+1;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376591,
                "title": "java-greedy-8-lines-simple-and-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int partitionString(String s) {\\n    var map = new boolean[26];\\n    var ans = 1;\\n\\n    for (var c : s.toCharArray()) {\\n      if (map[c - \\'a\\']) {\\n        ans++;\\n        Arrays.fill(map, false);\\n      }\\n      map[c - \\'a\\'] = true;\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n  public int partitionString(String s) {\\n    var map = new boolean[26];\\n    var ans = 1;\\n\\n    for (var c : s.toCharArray()) {\\n      if (map[c - \\'a\\']) {\\n        ans++;\\n        Arrays.fill(map, false);\\n      }\\n      map[c - \\'a\\'] = true;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376513,
                "title": "c-beats-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        const int N = s.size();\\n\\n        int result = 0;\\n        for (int i = 0; i < N;) {\\n            int j = i;\\n            int seen = 0;\\n\\n            while (j < N && (seen & (1 << (s[j] - \\'a\\'))) == 0) {\\n                seen ^= (1 << (s[j] - \\'a\\'));\\n                j++;\\n            }\\n\\n            result++;\\n            i = j;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        const int N = s.size();\\n\\n        int result = 0;\\n        for (int i = 0; i < N;) {\\n            int j = i;\\n            int seen = 0;\\n\\n            while (j < N && (seen & (1 << (s[j] - \\'a\\'))) == 0) {\\n                seen ^= (1 << (s[j] - \\'a\\'));\\n                j++;\\n            }\\n\\n            result++;\\n            i = j;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181534,
                "title": "easy-java-solution-using-hash-table-beats-96-online-submission",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Make a HashTable and initilize it to zero and start inputtiong the values**\\n2. **If the array has element set array to 0 and increase pointer**\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(26)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int ct = 1;\\n\\n        int[] arr = new int[26];\\n        Arrays.fill(arr, 0);\\n\\n        for(char it : s.toCharArray()){\\n            if(arr[it-\\'a\\'] > 0){\\n                ct++;\\n                Arrays.fill(arr, 0);\\n            }\\n            arr[it-\\'a\\']++;\\n        }\\n\\n        return ct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int ct = 1;\\n\\n        int[] arr = new int[26];\\n        Arrays.fill(arr, 0);\\n\\n        for(char it : s.toCharArray()){\\n            if(arr[it-\\'a\\'] > 0){\\n                ct++;\\n                Arrays.fill(arr, 0);\\n            }\\n            arr[it-\\'a\\']++;\\n        }\\n\\n        return ct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797273,
                "title": "worst-solution-ever-list",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nused first list to store char instead of set (Noice!!)\\nthen used another list to store res string instead of count variable (very Noice !!)\\nvalue added through iteration \\n(Rocket Science)\\nfor last element to add used condition \\n(should be Optimized)\\n\\n\\nl\\nPlease upvote if you liked\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        List<Character> list =new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        String str = \"\";\\n        for(int i =0; i<s.length(); i++){\\n            if(list.contains(s.charAt(i))){\\n                res.add(str);\\n                list = new ArrayList<>();\\n                str = \"\";\\n                \\n                i--;\\n            }else{\\n                str += s.charAt(i);\\n                list.add(s.charAt(i));\\n                if(i == s.length()-1){\\n                    list.clear();\\n                    res.add(str);\\n                }\\n            }\\n            System.out.println(str);\\n        }\\n        return res.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        List<Character> list =new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        String str = \"\";\\n        for(int i =0; i<s.length(); i++){\\n            if(list.contains(s.charAt(i))){\\n                res.add(str);\\n                list = new ArrayList<>();\\n                str = \"\";\\n                \\n                i--;\\n            }else{\\n                str += s.charAt(i);\\n                list.add(s.charAt(i));\\n                if(i == s.length()-1){\\n                    list.clear();\\n                    res.add(str);\\n                }\\n            }\\n            System.out.println(str);\\n        }\\n        return res.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581198,
                "title": "python3-2405-optimal-partition-of-string",
                "content": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n\\n        chSet, ans = set(), 1\\n\\n        for ch in s:\\n\\n            if ch in chSet:\\n                chSet.clear()\\n                ans+= 1\\n\\n            chSet.add(ch)\\n\\n        return  ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n\\n        chSet, ans = set(), 1\\n\\n        for ch in s:\\n\\n            if ch in chSet:\\n                chSet.clear()\\n                ans+= 1\\n\\n            chSet.add(ch)\\n\\n        return  ans",
                "codeTag": "Java"
            },
            {
                "id": 2562947,
                "title": "rust-0-ms-two-solutions-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/797212031/) employs a simple array to keep track of duplicate letters. It demonstrated **0 ms runtime (100.00%)** and used **2.3 MB memory (100.00%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn partition_string(s: String) -> i32 \\n    {\\n        // [1] use simple array to keep track of unique letters\\n        let mut letters = [false;26];\\n        \\n        // [2] count how many times we encountered duplicates\\n        s.bytes().map(|c| (c - b\\'a\\') as usize).filter(|&i| \\n            {\\n                let f = letters[i];\\n                if f { letters.fill(false); }\\n                letters[i] = true;\\n                f\\n            }\\n        ).count() as i32 + 1\\n    }\\n}\\n```\\n\\nThere is also a slower [solution](https://leetcode.com/submissions/detail/797184265/) with a HashSet:\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution \\n{\\n    pub fn partition_string(s: String) -> i32 \\n    {\\n        // [1] use HashSet to keep track of unique letters\\n        let mut letters: HashSet<char> = HashSet::with_capacity(26);\\n        \\n        // [2] count how many times we had to clear HashSet (i.e., encountered duplicates)\\n        s.chars().filter(|c| \\n            {\\n                let f = letters.contains(c);\\n                if f { letters.clear(); }\\n                letters.insert(*c);\\n                f\\n            }\\n        ).count() as i32 + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn partition_string(s: String) -> i32 \\n    {\\n        // [1] use simple array to keep track of unique letters\\n        let mut letters = [false;26];\\n        \\n        // [2] count how many times we encountered duplicates\\n        s.bytes().map(|c| (c - b\\'a\\') as usize).filter(|&i| \\n            {\\n                let f = letters[i];\\n                if f { letters.fill(false); }\\n                letters[i] = true;\\n                f\\n            }\\n        ).count() as i32 + 1\\n    }\\n}\\n```\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution \\n{\\n    pub fn partition_string(s: String) -> i32 \\n    {\\n        // [1] use HashSet to keep track of unique letters\\n        let mut letters: HashSet<char> = HashSet::with_capacity(26);\\n        \\n        // [2] count how many times we had to clear HashSet (i.e., encountered duplicates)\\n        s.chars().filter(|c| \\n            {\\n                let f = letters.contains(c);\\n                if f { letters.clear(); }\\n                letters.insert(*c);\\n                f\\n            }\\n        ).count() as i32 + 1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560881,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s)\\n    {\\n        int ans = 0;\\n        int n = s.size();\\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < n)\\n        {\\n            int mp[26] = {0};\\n\\n            while (j < n && mp[s[j]-\\'a\\'] != 1)\\n            {\\n                mp[s[j]-\\'a\\']++;\\n                j++;\\n            }\\n\\n            ans++;\\n\\n            if(i == j)\\n            i++; \\n\\n            else \\n            i = j;\\n\\n        }\\n\\n     return ans;\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s)\\n    {\\n        int ans = 0;\\n        int n = s.size();\\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < n)\\n        {\\n            int mp[26] = {0};\\n\\n            while (j < n && mp[s[j]-\\'a\\'] != 1)\\n            {\\n                mp[s[j]-\\'a\\']++;\\n                j++;\\n            }\\n\\n            ans++;\\n\\n            if(i == j)\\n            i++; \\n\\n            else \\n            i = j;\\n\\n        }\\n\\n     return ans;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560852,
                "title": "c-clean-code-hashset",
                "content": "if there is already a character present in the substring we cannot add another\\nWe can use a hashset ( unordered_set) to monitor if we have a character in our current string\\n\\nPlease upvote if you find this helpful :)\\n\\nC++ code:\\n```\\nclass Solution {\\nprivate:\\n    unordered_set<char> use;\\n    int ans=0;\\n    \\npublic:\\n    int partitionString(string s) {\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(use.find(s[i])==use.end()){\\n                use.insert(s[i]);\\n            }\\n            else{\\n                use.clear();\\n                ans++;\\n                use.insert(s[i]);\\n            }\\n        }\\n        \\n        return ++ans;\\n    }\\n};\\n``",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\nprivate:\\n    unordered_set<char> use;\\n    int ans=0;\\n    \\npublic:\\n    int partitionString(string s) {\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(use.find(s[i])==use.end()){\\n                use.insert(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2560771,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashset***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(Constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string str) {\\n        \\n        int n = str.size();\\n       \\n        int count = 0;\\n        \\n        // set will store the no. of different characters of a substring\\n        \\n        unordered_set<char> s;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            // store the characters in set untill we encounter a duplicate character\\n            \\n            while(i < n && s.count(str[i]) == 0)\\n            {\\n                s.insert(str[i]);\\n                \\n                i++;\\n            }\\n            \\n            // clear set for next substring\\n            \\n            s.clear();\\n            \\n            // increment count of substrings\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string str) {\\n        \\n        int n = str.size();\\n       \\n        int count = 0;\\n        \\n        // set will store the no. of different characters of a substring\\n        \\n        unordered_set<char> s;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            // store the characters in set untill we encounter a duplicate character\\n            \\n            while(i < n && s.count(str[i]) == 0)\\n            {\\n                s.insert(str[i]);\\n                \\n                i++;\\n            }\\n            \\n            // clear set for next substring\\n            \\n            s.clear();\\n            \\n            // increment count of substrings\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560261,
                "title": "java-solution-hashset",
                "content": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count=0;\\n        HashSet<Character> hs1=new HashSet<>();\\n        String str=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(!hs1.contains(s.charAt(i))){\\n                str=str+s.charAt(i);\\n                hs1.add(s.charAt(i));\\n            }\\n            else{\\n                count++;\\n                str=\"\";\\n                hs1.clear();\\n                i--;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count=0;\\n        HashSet<Character> hs1=new HashSet<>();\\n        String str=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(!hs1.contains(s.charAt(i))){\\n                str=str+s.charAt(i);\\n                hs1.add(s.charAt(i));\\n            }\\n            else{\\n                count++;\\n                str=\"\";\\n                hs1.clear();\\n                i--;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560110,
                "title": "easy-partition-dp-c",
                "content": "```\\nclass Solution {\\n    int n;\\n    int dp[100001];\\n    int partition(int i, string &s) {\\n        if(i == n)\\n            return 0;\\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        vector<int>count(26);\\n        int ans = 1e9;\\n        for(int j = i; j < n; j++) {\\n            if(count[s[j] - \\'a\\'] == 0) {\\n                count[s[j] - \\'a\\']++;\\n                ans = min(ans, 1 + partition(j + 1, s));\\n            } else {\\n                break;\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\npublic:\\n    int partitionString(string s) {\\n        memset(dp, -1, sizeof dp);\\n        n = s.length();\\n        int ans = partition(0, s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    int dp[100001];\\n    int partition(int i, string &s) {\\n        if(i == n)\\n            return 0;\\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        vector<int>count(26);\\n        int ans = 1e9;\\n        for(int j = i; j < n; j++) {\\n            if(count[s[j] - \\'a\\'] == 0) {\\n                count[s[j] - \\'a\\']++;\\n                ans = min(ans, 1 + partition(j + 1, s));\\n            } else {\\n                break;\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\npublic:\\n    int partitionString(string s) {\\n        memset(dp, -1, sizeof dp);\\n        n = s.length();\\n        int ans = partition(0, s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560087,
                "title": "c-use-hashmap-easy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int partitionString(string s) \\n    {\\n        unordered_map<int, int> mp;\\n        int high=0, cnt=0;\\n        \\n        while(high<s.size())\\n        {\\n            if(mp.find(s[high]-\\'a\\') != mp.end())\\n            {\\n                mp.clear();\\n                cnt++;\\n            }\\n            mp[s[high]-\\'a\\'] = high;\\n            high++;\\n        }\\n        if(!mp.empty()) cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int partitionString(string s) \\n    {\\n        unordered_map<int, int> mp;\\n        int high=0, cnt=0;\\n        \\n        while(high<s.size())\\n        {\\n            if(mp.find(s[high]-\\'a\\') != mp.end())\\n            {\\n                mp.clear();\\n                cnt++;\\n            }\\n            mp[s[high]-\\'a\\'] = high;\\n            high++;\\n        }\\n        if(!mp.empty()) cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073921,
                "title": "using-hashing-99-54-faster-5-line-easy-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n      vector<int>freq(26 , -1);\\n      int cnt = 1; // minimum substring will be of size 1\\n      int curr_subs = 0 ;\\n      for(int i = 0 ; i<s.size(); i++){\\n        char ch = s[i];\\n        if( freq[ch -\\'a\\'] >= curr_subs){\\n          cnt++;\\n          curr_subs = i;\\n        }\\n        freq[ch-\\'a\\'] = i ;\\n      }\\n      return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n      vector<int>freq(26 , -1);\\n      int cnt = 1; // minimum substring will be of size 1\\n      int curr_subs = 0 ;\\n      for(int i = 0 ; i<s.size(); i++){\\n        char ch = s[i];\\n        if( freq[ch -\\'a\\'] >= curr_subs){\\n          cnt++;\\n          curr_subs = i;\\n        }\\n        freq[ch-\\'a\\'] = i ;\\n      }\\n      return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407518,
                "title": "java",
                "content": "# Code\\nclass Solution {\\n    public int partitionString(String s) {\\n        int a = 1,i=0;\\n        String s1 = \"\";\\n        while(i<s.length())\\n        {\\n            String s3 = \"\"+s.charAt(i);\\n            if(s1.contains(s3))\\n            {\\n                a++;\\n                s1=\"\";\\n            }\\n            else{\\n                s1 = s1+s3;\\n                i++;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int partitionString(String s) {\\n        int a = 1,i=0;\\n        String s1 = \"\";\\n        while(i<s.length())\\n        {\\n            String s3 = \"\"+s.charAt(i);\\n            if(s1.contains(s3))\\n            {\\n                a++;\\n                s1=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3384206,
                "title": "simple-c-code-for-beginner",
                "content": "# Intuition\\n\\n\\nMy first thought was to iterate the complete string and keep track of each character which should be unique and at the time when any character repeat increment the answer value and erase the map and continue the process again. \\n\\n# Approach\\n1. Create a map of type <char,int>.\\n2. Create variable ans and initiate it with 0.\\n3. Now, Travese each character of string one by one and increment its count in map to track it\\'s occurance.\\n4. At the time if you get the count of the character, it mean that the character is already been traverse in the currebt substring.\\n5. Increment the answer and erase the map.\\n6. The same process will be repeated for the remanining part.\\n7. At last when entire string will be traversed then then return the final answer with one incremented for the last substring. \\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity: O(1)\\n\\n![IMG_20230406_001856.jpg](https://assets.leetcode.com/users/images/f3d48ea7-8f5e-4651-a67d-72348d60525e_1680720828.8575788.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_map<char,int> mp;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(!mp.count(s[i]))\\n            {\\n                mp[s[i]]++;\\n            }  \\n            else\\n            {\\n                ans++;\\n                mp.erase(mp.begin(),mp.end());\\n                mp[s[i]]++;\\n            }\\n        }\\n        return (ans+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_map<char,int> mp;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(!mp.count(s[i]))\\n            {\\n                mp[s[i]]++;\\n            }  \\n            else\\n            {\\n                ans++;\\n                mp.erase(mp.begin(),mp.end());\\n                mp[s[i]]++;\\n            }\\n        }\\n        return (ans+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380419,
                "title": "easiest-solution-using-unordered-map-beginners-friendly",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int partitionString(string s) {\\n\\n        int ans=1;\\n        unordered_map<char,int>mp;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            mp[s[i]]++;\\n            \\n            if(mp[s[i]]>1)\\n            {\\n                ans++;\\n                mp.clear();\\n            }\\n            else\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int partitionString(string s) {\\n\\n        int ans=1;\\n        unordered_map<char,int>mp;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            mp[s[i]]++;\\n            \\n            if(mp[s[i]]>1)\\n            {\\n                ans++;\\n                mp.clear();\\n            }\\n            else\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380189,
                "title": "easy-python-hash-table-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find the minimum number of substrings in a given string such that each character in a substring appears only once. One possible approach is to use a **dictionary** to keep track of the last index of each character and maintain a variable \"**start**\" to keep track of the starting index of the current substring. We iterate through the string and if a character is not present in the dictionary, we add it along with its index.If the character is already present in the dictionary, we check if its last occurrence is within the current substring (i.e., after \"start\"). If it is, we increment the **counter** and update the \"**start**\" to the current index. If not, we update the dictionary with the current index. At the end, we return the count plus one (for the last substring).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty **dictionary d**, a variable **start** to **-1**, and a **counter c** to **0.**\\n2. Iterate through the characters of the **string s**.\\n3. If the character is not in the dictionary d, add it along with its index.\\n4. If the character is already in the dictionary d, check if its last occurrence is after the current substring (i.e., after start).\\n5. If it is, **increment the counter c** and update the start to the current index.\\n6. If it is not, update the dictionary d with the current index.\\nAt the end, return the **count c plus one** (for the last substring).\\n\\n**If you found the solution helpful, please consider giving an upvote to help others find it too. Thank you!**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where n is the length of the string s. We iterate through each character of the string only once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where n is the length of the string s. The dictionary d can have at most n key-value pairs.\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        d={}\\n        start=-1\\n        n=len(s)\\n        c=0\\n        for i in range(n):\\n            if s[i] not in d:\\n                d[s[i]]=i\\n            else:\\n                if d[s[i]]>=start:\\n                    c+=1\\n                    start=i\\n                    d[s[i]]=i\\n                    # print(i,s[i],c)\\n                else:\\n                    d[s[i]]=i\\n        return c+1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        d={}\\n        start=-1\\n        n=len(s)\\n        c=0\\n        for i in range(n):\\n            if s[i] not in d:\\n                d[s[i]]=i\\n            else:\\n                if d[s[i]]>=start:\\n                    c+=1\\n                    start=i\\n                    d[s[i]]=i\\n                    # print(i,s[i],c)\\n                else:\\n                    d[s[i]]=i\\n        return c+1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380113,
                "title": "easy-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        d=\"\"\\n        lis=[]\\n        for i in range(len(s)):\\n            \\n            if(s[i] in d):\\n                lis.append(d)\\n                d=s[i]\\n            else:\\n                d+=s[i]\\n        lis.append(d)\\n        \\n        return(len(lis))\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        d=\"\"\\n        lis=[]\\n        for i in range(len(s)):\\n            \\n            if(s[i] in d):\\n                lis.append(d)\\n                d=s[i]\\n            else:\\n                d+=s[i]\\n        lis.append(d)\\n        \\n        return(len(lis))\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380008,
                "title": "unordered-map-easy-time-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_map<char,int>mp;\\n        int cnt=1;\\n        for(int i=0;i<s.size();i++){\\n           if(mp.find(s[i])!=mp.end()){\\n               mp.clear();\\n               cnt++;\\n           }\\n           mp[s[i]]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_map<char,int>mp;\\n        int cnt=1;\\n        for(int i=0;i<s.size();i++){\\n           if(mp.find(s[i])!=mp.end()){\\n               mp.clear();\\n               cnt++;\\n           }\\n           mp[s[i]]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379362,
                "title": "set-using-python3-o-n-beats-90",
                "content": "# Intuition\\nMaintain set for each substring.\\n\\n# Approach\\nStart with empty set. Iterate over string, i.e., for each char in string, check if it is already present in set (that means we need to create another partition, increment the number of partition by 1 and clear set and add the current char to set). If it is not present in the set, then just add the char to the set and move on to the next char. Return ans.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        ans = 0\\n        temp = set()\\n        for i in s:\\n            if i in temp:\\n                ans += 1\\n                temp.clear()\\n            temp.add(i)\\n        return ans+1\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        ans = 0\\n        temp = set()\\n        for i in s:\\n            if i in temp:\\n                ans += 1\\n                temp.clear()\\n            temp.add(i)\\n        return ans+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379361,
                "title": "simple-c-python-solution-daily-leetcode-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        vector<char> v;\\n        int ans=0;\\n        for(auto x:s)\\n        {\\n            if(find(v.begin(),v.end(),x)!=v.end())\\n            {\\n                ans++;\\n                v.clear();\\n            }\\n            v.push_back(x);\\n        }\\n        if(v.size()!=0)\\n        {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Python\\n\\n```\\nclass Solution(object):\\n    def partitionString(self, s):\\n        st=\\'\\'\\n        ans=0\\n        for i in s:\\n            if i in st:\\n                st=\\'\\';\\n                ans=ans+1;\\n            st=st+i\\n        if len(st)!=0:\\n            ans=ans+1\\n        return ans;\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        vector<char> v;\\n        int ans=0;\\n        for(auto x:s)\\n        {\\n            if(find(v.begin(),v.end(),x)!=v.end())\\n            {\\n                ans++;\\n                v.clear();\\n            }\\n            v.push_back(x);\\n        }\\n        if(v.size()!=0)\\n        {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def partitionString(self, s):\\n        st=\\'\\'\\n        ans=0\\n        for i in s:\\n            if i in st:\\n                st=\\'\\';\\n                ans=ans+1;\\n            st=st+i\\n        if len(st)!=0:\\n            ans=ans+1\\n        return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379324,
                "title": "day94-c-easy-map-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ans=1;\\n        map<char,int> m;\\n\\n        for(int i=0;i<s.size();i++){\\n            if(m.find(s[i])!=m.end()){//if find duplicate then clear the map\\n                m.clear();\\n                ans++;\\n                m[s[i]]++;\\n            }\\n            else{\\n                m[s[i]]++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ans=1;\\n        map<char,int> m;\\n\\n        for(int i=0;i<s.size();i++){\\n            if(m.find(s[i])!=m.end()){//if find duplicate then clear the map\\n                m.clear();\\n                ans++;\\n                m[s[i]]++;\\n            }\\n            else{\\n                m[s[i]]++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379151,
                "title": "int-26-java-basic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing int array of length 26 to store the number of occurences of characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe int array `arr[26]` is to store the number of occurence of the alphabet in the string. For example, the arr works like \\n```\\ns = \"abd\";\\narr = [1, 1, 0 ,1, 0, 0, 0, 0...]\\n      (a)(b)(c)(d)(e)(f)(g)(h)...\\n```\\n\\nIf the number of occurence of a character is not equal to zero, it implies that the character is already present. So, the array is set to zero again and the sub string count is incremented by 1.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        char characters[] = s.toCharArray();\\n        int arr[] = new int[26];\\n        int count = 0;\\n\\n        for(int i = 0; i < characters.length; i++) {\\n            char c = characters[i];\\n            if(arr[c - \\'a\\'] != 0) {\\n                count++;\\n                Arrays.fill(arr,0);\\n                arr[c - \\'a\\']++;\\n            } \\n            arr[c - \\'a\\']++;\\n        }\\n        return ++count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\ns = \"abd\";\\narr = [1, 1, 0 ,1, 0, 0, 0, 0...]\\n      (a)(b)(c)(d)(e)(f)(g)(h)...\\n```\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        char characters[] = s.toCharArray();\\n        int arr[] = new int[26];\\n        int count = 0;\\n\\n        for(int i = 0; i < characters.length; i++) {\\n            char c = characters[i];\\n            if(arr[c - \\'a\\'] != 0) {\\n                count++;\\n                Arrays.fill(arr,0);\\n                arr[c - \\'a\\']++;\\n            } \\n            arr[c - \\'a\\']++;\\n        }\\n        return ++count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379149,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        vector<int> update(26,0);\\n        vector<int> arr(26,0);\\n        string temp = \"\";\\n        int count = 0;\\n       \\n        for(int i = 0 ;i<s.size();i++){\\n            if(arr[s[i] - \\'a\\'] == 0){\\n                temp+=s[i];\\n                arr[s[i] - \\'a\\'] = 1;\\n            }\\n            else{\\n                temp = \"\";\\n                temp +=s[i];\\n                count++;\\n                arr = update;\\n                arr[s[i] - \\'a\\'] = 1;\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        vector<int> update(26,0);\\n        vector<int> arr(26,0);\\n        string temp = \"\";\\n        int count = 0;\\n       \\n        for(int i = 0 ;i<s.size();i++){\\n            if(arr[s[i] - \\'a\\'] == 0){\\n                temp+=s[i];\\n                arr[s[i] - \\'a\\'] = 1;\\n            }\\n            else{\\n                temp = \"\";\\n                temp +=s[i];\\n                count++;\\n                arr = update;\\n                arr[s[i] - \\'a\\'] = 1;\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379145,
                "title": "solution-using-greedy-algorithm-complete-explanation",
                "content": "\\n\\n# Approach\\nTo solve this problem, we can use a greedy approach. We start with the first character and keep adding characters to a substring as long as each new character is unique. Once we encounter a character that is already present in the substring, we create a new substring starting with that character. We repeat this process until we reach the end of the string.\\nWe use an unordered_set to keep track of the characters in the current substring. If we encounter a character that is already in the set, we increment the count and clear the set to start a new substring. We add 1 to the count at the end to account for the last substring that may not have been counted yet.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input string\\n\\n- Space complexity:\\nO(k), where k is the number of unique characters in the input string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.length();\\n        unordered_set<char> seen;\\n        int count = 0;\\n        int i = 0;\\n        while (i < n) {\\n            char c = s[i];\\n            if (seen.count(c) == 0) {\\n                seen.insert(c);\\n                i++;\\n            } else {\\n                count++;\\n                seen.clear();\\n            }\\n        }\\n        count++; \\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.length();\\n        unordered_set<char> seen;\\n        int count = 0;\\n        int i = 0;\\n        while (i < n) {\\n            char c = s[i];\\n            if (seen.count(c) == 0) {\\n                seen.insert(c);\\n                i++;\\n            } else {\\n                count++;\\n                seen.clear();\\n            }\\n        }\\n        count++; \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379001,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_map<char, bool> mp;\\n        int ans = 1;\\n        for(auto c: s) {\\n            if(mp[c]) ans++, mp.clear();\\n            mp[c] = true;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_map<char, bool> mp;\\n        int ans = 1;\\n        for(auto c: s) {\\n            if(mp[c]) ans++, mp.clear();\\n            mp[c] = true;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378696,
                "title": "sliding-window",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int feq[26] = {0};\\n        int ch, n = s.length();\\n        int l, r, part = 1;\\n        for(l = r = 0; r < n; r++) {\\n            ch = s[r] - \\'a\\';\\n            feq[ch]++;\\n            if(feq[ch] > 1) {\\n                part++;\\n                while(l < r)\\n                    feq[s[l++] - \\'a\\']--;\\n            }\\n        }\\n        return part;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int feq[26] = {0};\\n        int ch, n = s.length();\\n        int l, r, part = 1;\\n        for(l = r = 0; r < n; r++) {\\n            ch = s[r] - \\'a\\';\\n            feq[ch]++;\\n            if(feq[ch] > 1) {\\n                part++;\\n                while(l < r)\\n                    feq[s[l++] - \\'a\\']--;\\n            }\\n        }\\n        return part;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378452,
                "title": "c-easiest-way-solved-solution-well-explained-approach-tc-sc-gauravthinks",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Make a map to store the frequency of a character of substring****\\n(keep in mind we are talking about the frequency of a substring not the whole given string) .\\n- traverse over the given string ```s``` and:\\n- i) check if the current index\\'s ```character``` has occured in map ```nakhsa``` or not. If it does not exist store it into ```naksha```  and increase the traversal pointer ```i```. This means we are considering that character in a substring as this character has not occured before in the ```substring```.\\n\\n- - ii) If the current index\\'s character has occured before in the same substring, then raise the ```result/ counter``` by one, which  means we can not accomodate duplicate characters in the same substring again and wee need another substring form now-onwards to store the remaining characters. \\n here in this string ----------->  ```\"ab|ac|ab|a\"``` \\nwe break the substring at index 2( the moment we again get a within the same subtring and increase the counter by 1) and so on\\n- - ii.1) Also``` earse the map frequency``` if we encounter duplicate characters again, so that fresh frequency of next characters could be stored again for``` new substrings``` ahead.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) as we traverse over the string only once throughout\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) for map\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int i=0; // starting index\\n        int n= s.size();\\n        unordered_map<int, int> naksha;\\n        int count=0;\\n        while(i<n){\\n            if(naksha[s[i]]==0){\\n                naksha[s[i]]++; // if the character do not exist already upto now in the string, then update its frequency in map and consider it in a valid substring\\n                i++; // and also increment the traversal pointer\\n            }\\n            else{ // else if within the same substring(jisme traverse karte karte hum current index par pahuche hai) contains same character twice, then break the string by increasing the \\'count\\' variable and clear the map so that next substring\\'s character could be tracked in map\\n                count++; \\n                naksha.clear();\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```\\nIf you liked the solution and explanation, then do Upvote the solution and subscribe to our YouTube Channel down below.\\n\\n# @GauravThinks <----- youtube channel",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map"
                ],
                "code": "```s```\n```character```\n```nakhsa```\n```naksha```\n```i```\n```substring```\n```result/ counter```\n```\"ab|ac|ab|a\"```\n``` earse the map frequency```\n``` new substrings```\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int i=0; // starting index\\n        int n= s.size();\\n        unordered_map<int, int> naksha;\\n        int count=0;\\n        while(i<n){\\n            if(naksha[s[i]]==0){\\n                naksha[s[i]]++; // if the character do not exist already upto now in the string, then update its frequency in map and consider it in a valid substring\\n                i++; // and also increment the traversal pointer\\n            }\\n            else{ // else if within the same substring(jisme traverse karte karte hum current index par pahuche hai) contains same character twice, then break the string by increasing the \\'count\\' variable and clear the map so that next substring\\'s character could be tracked in map\\n                count++; \\n                naksha.clear();\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378306,
                "title": "daily-leetcode-challenge-04-april-c-solution",
                "content": "# Approach \\nHashmap\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int partitionString(string s) {\\n        int ans = 1;\\n        set<char> m;\\n        for(auto i:s){\\n            if(m.find(i)!=m.end()){\\n                m.clear();\\n                ans++;\\n            }\\n            m.insert(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int partitionString(string s) {\\n        int ans = 1;\\n        set<char> m;\\n        for(auto i:s){\\n            if(m.find(i)!=m.end()){\\n                m.clear();\\n                ans++;\\n            }\\n            m.insert(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377854,
                "title": "java-full-explaination-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDeclare a HashSet of Characters and then intialize a count with value 0. Now we will iterate over each character of the string and check if that chacacter is already present in the array if it is already present then increase the count and clear the hashset so that it can again start collecting new unique character.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n        int count = 0;\\n        for(int i = 0 ; i < s.length(); i ++){\\n            //char at that index present in the hashset\\n            if(hs.contains(s.charAt(i))){\\n                //increase the count by 1\\n                count++;\\n                //clear the hashset so that it can again start collecting new unique char.\\n                hs.clear();\\n            }\\n            hs.add(s.charAt(i));\\n        }\\n        //returning count + 1 because we are counting total cuts in \\n        //the string and we need to return total new substrings\\n        return count+1;\\n    }\\n}\\n```\\n**Another solution with same approach but more efficient\\nUsing Array with constant space and no HashSet**\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int hash[] = new int[26];\\n        int count = 0;\\n        for(int i = 0 ; i < s.length(); i ++){\\n            if(hash[s.charAt(i) - \\'a\\'] == 1){\\n                count++;\\n                hash = new int[26];\\n            }\\n            hash[s.charAt(i)-\\'a\\']++;\\n        }\\n        return count+1;\\n    }\\n}\\n```\\n**Please UpVote\\nIf You like the code**\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n        int count = 0;\\n        for(int i = 0 ; i < s.length(); i ++){\\n            //char at that index present in the hashset\\n            if(hs.contains(s.charAt(i))){\\n                //increase the count by 1\\n                count++;\\n                //clear the hashset so that it can again start collecting new unique char.\\n                hs.clear();\\n            }\\n            hs.add(s.charAt(i));\\n        }\\n        //returning count + 1 because we are counting total cuts in \\n        //the string and we need to return total new substrings\\n        return count+1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int hash[] = new int[26];\\n        int count = 0;\\n        for(int i = 0 ; i < s.length(); i ++){\\n            if(hash[s.charAt(i) - \\'a\\'] == 1){\\n                count++;\\n                hash = new int[26];\\n            }\\n            hash[s.charAt(i)-\\'a\\']++;\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377635,
                "title": "most-optimal-c-solution-using-bit-mask",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int partitionString(string s) {\\n       int bit =0;\\n        int ans=1;\\n\\n       for(int i=0;i<s.length();i++){\\n          int k =s[i]-\\'a\\';\\n          if(bit&(1<<k)){ // if the bit is already set(means the char is already present in the segment)\\n              ans++;\\n              bit=0;\\n          }\\n          bit|=(1<<k); // set the bit corresponding to the char \\n       }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int partitionString(string s) {\\n       int bit =0;\\n        int ans=1;\\n\\n       for(int i=0;i<s.length();i++){\\n          int k =s[i]-\\'a\\';\\n          if(bit&(1<<k)){ // if the bit is already set(means the char is already present in the segment)\\n              ans++;\\n              bit=0;\\n          }\\n          bit|=(1<<k); // set the bit corresponding to the char \\n       }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377571,
                "title": "c-code-using-map-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we need to find substrings so we could see substrings to be divided as various windows to be seperated . Hence we could keep track of seen characters and as we see a duplicate character appear we can say that here is the place where window will be broken.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a map to keep track of the frequency of each character in the string. Then, it iterates through the string character by character. If the character has been encountered before, it means that a partition needs to be created before this character, as all its previous occurrences need to be in the same partition. Therefore, the \"c\" variable is incremented to keep track of the number of partitions needed. The map is then cleared, as we need to start counting the frequency of characters in the new partition.\\n\\nIf the current character has not been encountered before, its frequency is incremented in the map.\\n\\nOnce the loop is completed, if the map is not empty, it means that a partition needs to be created for the remaining characters in the string.\\n\\nFinally, the function returns the value of \"c,\" which is the minimum number of partitions required to partition the string as described\\xA0above.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as using unordered map (O(1) to find in map and o(n) for iterate whole string)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) using map data structure.\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n         int n=s.size();\\n         int c=0;\\n         unordered_map<char,int> mp;\\n         for(int i=0;i<s.size();i++){\\n             if(mp.find(s[i])!=mp.end()){\\n                 c++;\\n                 mp.clear();\\n             }\\n                 mp[s[i]]++;   \\n         }\\n         if(mp.size()>0) c++;\\n         return c;\\n\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionString(string s) {\\n         int n=s.size();\\n         int c=0;\\n         unordered_map<char,int> mp;\\n         for(int i=0;i<s.size();i++){\\n             if(mp.find(s[i])!=mp.end()){\\n                 c++;\\n                 mp.clear();\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3377431,
                "title": "easy-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n\\n        int i = 0;\\n        int count = 0;\\n\\n        while(i<s.length()){\\n            char c = s.charAt(i);\\n            if(hs.add(c)){\\n              i++;\\n            }\\n            \\n            else{\\n                count++;\\n                hs.clear();\\n                hs.add(c);\\n                i++;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n\\n        int i = 0;\\n        int count = 0;\\n\\n        while(i<s.length()){\\n            char c = s.charAt(i);\\n            if(hs.add(c)){\\n              i++;\\n            }\\n            \\n            else{\\n                count++;\\n                hs.clear();\\n                hs.add(c);\\n                i++;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377422,
                "title": "python-3-one-line",
                "content": "```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        return (d:=\\'\\') or sum(c==(d:=(d+c,c)[c in d]) for c in s)\\n```\\n\\nDerived from that one (pretty fast, even without a set it\\'s 99.6%):\\n```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        d = \\'\\'\\n        r = 1\\n        for c in s:\\n            if c in d:\\n                d = c\\n                r += 1\\n            else:\\n                d += c\\n        return r\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        return (d:=\\'\\') or sum(c==(d:=(d+c,c)[c in d]) for c in s)\\n```\n```python\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        d = \\'\\'\\n        r = 1\\n        for c in s:\\n            if c in d:\\n                d = c\\n                r += 1\\n            else:\\n                d += c\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377391,
                "title": "c-code-kindly-upvote-please",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIntuitively, we can consider adding characters to a substring as long as we don\\'t see a character that has already been added to the current substring. When we see a character that is already present in the substring, we start a new substring and repeat this process until we iterate over the entire string s.\\n\\nThe intuition is correct because there is no point in not adding a character if it is not present in the current substring. We should add it so that it forms larger substrings, resulting in a lower total number of substrings formed.\\n\\nWe\\'ll use an array of size 26 to keep track of the characters in the ongoing substring. We will store the beginning of the current substring as well as keep track of the most recent position of each character. This allows us to determine whether the current character is already present in the current substring.\\n\\nOther data structures, such as a hash set, can be used for minor space optimization in cases where we may not have all of the 26 characters added to the hash set, but we must clear it completely at the start of each substring, resulting in some additional operations.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n       vector<int> lastSeen(26,-1);\\n        int count =1;\\n        int substringStart = 0;\\n        for(int i = 0;i<s.length();i++){\\n          if(lastSeen[s[i]-\\'a\\']>=substringStart){\\n            count++;\\n            substringStart = i;\\n          }\\n          lastSeen[s[i]-\\'a\\']= i;\\n        } \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n       vector<int> lastSeen(26,-1);\\n        int count =1;\\n        int substringStart = 0;\\n        for(int i = 0;i<s.length();i++){\\n          if(lastSeen[s[i]-\\'a\\']>=substringStart){\\n            count++;\\n            substringStart = i;\\n          }\\n          lastSeen[s[i]-\\'a\\']= i;\\n        } \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377381,
                "title": "c-easy-solution-bit-manipulation-hashset-o-1-space",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nBit manipulation\\n```\\npublic class Solution {\\n    public int PartitionString(string s) {\\n        var count = 1;\\n        var bits = 0;\\n\\n        foreach (var c in s) {\\n            var bit = 1 << (c - \\'a\\');\\n            if ((bits & bit) == 0) {\\n                bits |= bit;\\n            } else {\\n                bits = bit;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n\\nHashset\\n```\\npublic class Solution {\\n    public int PartitionString(string s) {\\n        var set = new HashSet<char>();\\n        var count = 1;\\n\\n        foreach (var c in s) {\\n            if (set.Contains(c)) {\\n                set.Clear();\\n                count++;\\n            }\\n            set.Add(c);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/2d4440de-f790-49ce-82cc-adda90f47cdc_1680584984.0496461.png)\\n",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int PartitionString(string s) {\\n        var count = 1;\\n        var bits = 0;\\n\\n        foreach (var c in s) {\\n            var bit = 1 << (c - \\'a\\');\\n            if ((bits & bit) == 0) {\\n                bits |= bit;\\n            } else {\\n                bits = bit;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int PartitionString(string s) {\\n        var set = new HashSet<char>();\\n        var count = 1;\\n\\n        foreach (var c in s) {\\n            if (set.Contains(c)) {\\n                set.Clear();\\n                count++;\\n            }\\n            set.Add(c);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377360,
                "title": "easy-java-solution-without-using-extra-space-beats-92-online-submissions",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int ct = 1;\\n\\n        int map = 0;\\n\\n        for(char it : s.toCharArray()){\\n            if((map & (1<<it)) != 0){\\n                map = 0;\\n                ct++;\\n            }\\n\\n            map ^= (1<<it);\\n        }\\n\\n        return ct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int ct = 1;\\n\\n        int map = 0;\\n\\n        for(char it : s.toCharArray()){\\n            if((map & (1<<it)) != 0){\\n                map = 0;\\n                ct++;\\n            }\\n\\n            map ^= (1<<it);\\n        }\\n\\n        return ct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377258,
                "title": "optimal-partition-of-string-c-easy-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) \\n    {\\n        vector<int>temp(26,0);\\n        int count = 1;\\n\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            if(temp[s[i]-\\'a\\'] != 0)\\n            {\\n                count++;\\n                vector<int>t(26,0);\\n                temp = t;\\n            }\\n            temp[s[i]-\\'a\\']++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) \\n    {\\n        vector<int>temp(26,0);\\n        int count = 1;\\n\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            if(temp[s[i]-\\'a\\'] != 0)\\n            {\\n                count++;\\n                vector<int>t(26,0);\\n                temp = t;\\n            }\\n            temp[s[i]-\\'a\\']++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377166,
                "title": "python-beats-93-67-very-simple-and-easy-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the minimum number od substring which have all character unique .\\nIt rather an very simple , we just have iterate the string , record current subbstring and count instances where array gets duplicate emelent.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We initialises an dictionary(or list/Array) to record the current substring through which we are iterating.\\n2. After initialising an Variable to count number of substring , we iterate through string.\\n3. If we char is in dictionary , we increase count by 1 and clear dictionary and stores current char into dictionary.\\n4. Else we add the char to dictionary\\n5. At last we cheak if lenght of dictionary is 0 or not.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n Thank you for visiting solution and consider upvoting if it helped.\\n Have a error free day !\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        dic={}\\n        c=0\\n        for i in s:\\n            if(i in dic):\\n                c+=1\\n                dic={}\\n                dic[i]=1\\n            else:\\n                dic[i]=1\\n        if len(dic)!=0:\\n            c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        dic={}\\n        c=0\\n        for i in s:\\n            if(i in dic):\\n                c+=1\\n                dic={}\\n                dic[i]=1\\n            else:\\n                dic[i]=1\\n        if len(dic)!=0:\\n            c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376970,
                "title": "easy-java-fast-100",
                "content": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count=1;\\n        Set<Character> hs=new HashSet<>();\\n        for(Character ch:s.toCharArray()){\\n            if(!hs.contains(ch)){\\n                hs.add(ch);\\n            }\\n            else{\\n                hs.clear();\\n                hs.add(ch);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count=1;\\n        Set<Character> hs=new HashSet<>();\\n        for(Character ch:s.toCharArray()){\\n            if(!hs.contains(ch)){\\n                hs.add(ch);\\n            }\\n            else{\\n                hs.clear();\\n                hs.add(ch);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376631,
                "title": "optimal-solution-beats-96-2-easy-java-solution-begginer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int [] a = new int[125];\\n        int c=1;\\n        for(int i=0;i<s.length();i++){\\n           a[s.charAt(i)]++;\\n         if(a[s.charAt(i)]>1){\\n          c++;\\n          Arrays.fill(a,0);\\n          a[s.charAt(i)]++;\\n         }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int [] a = new int[125];\\n        int c=1;\\n        for(int i=0;i<s.length();i++){\\n           a[s.charAt(i)]++;\\n         if(a[s.charAt(i)]>1){\\n          c++;\\n          Arrays.fill(a,0);\\n          a[s.charAt(i)]++;\\n         }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376592,
                "title": "bit-manipulation-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can take advantage of the fact that an integer has a 32-bit length. Since the English alphabet has only 26 characters, it will fit within this 32-bit range. To do this, we can assign each alphabet a unique bit in the integer value, starting from the rightmost bit for \\'a\\' and going up to the 26th bit for \\'z\\'.\\n\\nFor instance, when we encounter the letter \\'a\\', we\\'ll set the 0th bit of the integer to 1, and so on for the remaining alphabets. During each iteration of our program, we will first check if the bit at the position of \\'a\\' is set or not. If it\\'s set, we\\'ll set the value of \\'x\\' to 0 and increment the value of \\'ans\\' by 1.\\n\\n# Complexity\\n- Time complexity: $$O(len(s))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ans=1, x=0;\\n        for(char&e:s){\\n            if(x&(1<<(e-\\'a\\'))) x=0,ans++;\\n            x |= (1<<(e-\\'a\\'));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```C []\\nint partitionString(char * s){\\n    int ans=1, x=0;\\n    while(*s != \\'\\\\0\\'){\\n        char e = *s++;\\n        if(x&(1<<(e-\\'a\\'))) x=0,ans++;\\n        x |= (1<<(e-\\'a\\'));\\n    }\\n    return ans;\\n}\\n```\\n```Python []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        x,ans=0,1\\n        for e in s:\\n            if x&(1<<(ord(e)-97)): x=0;ans+=1\\n            x |= (1<<(ord(e)-97))\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy",
                    "Bitmask"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ans=1, x=0;\\n        for(char&e:s){\\n            if(x&(1<<(e-\\'a\\'))) x=0,ans++;\\n            x |= (1<<(e-\\'a\\'));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```C []\\nint partitionString(char * s){\\n    int ans=1, x=0;\\n    while(*s != \\'\\\\0\\'){\\n        char e = *s++;\\n        if(x&(1<<(e-\\'a\\'))) x=0,ans++;\\n        x |= (1<<(e-\\'a\\'));\\n    }\\n    return ans;\\n}\\n```\n```Python []\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        x,ans=0,1\\n        for e in s:\\n            if x&(1<<(ord(e)-97)): x=0;ans+=1\\n            x |= (1<<(ord(e)-97))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376538,
                "title": "rust-bitmask-solution",
                "content": "```rust []\\nimpl Solution {\\n    pub fn partition_string(s: String) -> i32 {\\n        let mut res = 1;\\n        let mut mask = 0;\\n        for c in s.chars() {\\n            let cur = 1 << (c as u8 - b\\'a\\');\\n            if (mask & cur) == cur {\\n                res += 1;\\n                mask = 0;\\n            }\\n            mask ^= cur;\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy",
                    "Bitmask"
                ],
                "code": "```rust []\\nimpl Solution {\\n    pub fn partition_string(s: String) -> i32 {\\n        let mut res = 1;\\n        let mut mask = 0;\\n        for c in s.chars() {\\n            let cur = 1 << (c as u8 - b\\'a\\');\\n            if (mask & cur) == cur {\\n                res += 1;\\n                mask = 0;\\n            }\\n            mask ^= cur;\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3376508,
                "title": "daily-leetcoding-challenge-april-day-4",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/optimal-partition-of-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/optimal-partition-of-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3316226,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n\\n        ans = 0\\n        ss = \"\"\\n\\n\\n        for i in s:\\n            if i not in ss:\\n                ss += i\\n            else:\\n                ans += 1\\n                ss = i\\n\\n        \\n        return ans + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n\\n        ans = 0\\n        ss = \"\"\\n\\n\\n        for i in s:\\n            if i not in ss:\\n                ss += i\\n            else:\\n                ans += 1\\n                ss = i\\n\\n        \\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239160,
                "title": "c-and-python-simple-clear-concise-one-pass-hash-table",
                "content": "\\n# Code\\n**C++ Solution:-**\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        map<char, int> hashmap;\\n        int i = 0, n = s.size();\\n        int ans = 1;\\n        while (i < n) {\\n            hashmap[s[i]]++;\\n            if (hashmap[s[i]] == 2) {\\n                ans += 1;\\n                i -= 1;\\n                hashmap.clear();\\n            }\\n            i += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Python Solution:-**\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        hashmap = defaultdict(int)\\n        i = 0\\n        n = len(s)\\n        ans = 0\\n        while i < n:\\n            hashmap[s[i]] += 1\\n            if hashmap[s[i]] == 2:\\n                ans += 1\\n                i -= 1\\n                hashmap = defaultdict(int)\\n            i += 1\\n        return ans + 1\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        map<char, int> hashmap;\\n        int i = 0, n = s.size();\\n        int ans = 1;\\n        while (i < n) {\\n            hashmap[s[i]]++;\\n            if (hashmap[s[i]] == 2) {\\n                ans += 1;\\n                i -= 1;\\n                hashmap.clear();\\n            }\\n            i += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        hashmap = defaultdict(int)\\n        i = 0\\n        n = len(s)\\n        ans = 0\\n        while i < n:\\n            hashmap[s[i]] += 1\\n            if hashmap[s[i]] == 2:\\n                ans += 1\\n                i -= 1\\n                hashmap = defaultdict(int)\\n            i += 1\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942426,
                "title": "bit-manipulation-c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nint partitionString(char * s){\\n    int ans = 0, len = strlen(s);\\n    int bitmask = 0, offset;\\n    for(int i = 0; i < len; i++)\\n    {\\n        offset = s[i] - \\'a\\';\\n        if(bitmask & (1 << offset)){\\n            ans++;\\n            bitmask = 0;\\n        }\\n        bitmask |= (1 << offset);\\n    }\\n    if(bitmask)\\n        ans++;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint partitionString(char * s){\\n    int ans = 0, len = strlen(s);\\n    int bitmask = 0, offset;\\n    for(int i = 0; i < len; i++)\\n    {\\n        offset = s[i] - \\'a\\';\\n        if(bitmask & (1 << offset)){\\n            ans++;\\n            bitmask = 0;\\n        }\\n        bitmask |= (1 << offset);\\n    }\\n    if(bitmask)\\n        ans++;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2877847,
                "title": "80-faster-easy-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &v){\\n        for(auto &i: v){\\n            if(i>1)return true;\\n        }\\n        return false;\\n    }\\n    int partitionString(string s) {\\n        int ans = 1;\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n            if(check(v)){\\n                fill(v.begin(),v.end(),0);\\n                v[i-\\'a\\']++;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &v){\\n        for(auto &i: v){\\n            if(i>1)return true;\\n        }\\n        return false;\\n    }\\n    int partitionString(string s) {\\n        int ans = 1;\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n            if(check(v)){\\n                fill(v.begin(),v.end(),0);\\n                v[i-\\'a\\']++;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832326,
                "title": "easiest-beginner-python-solution",
                "content": "**Hi there!**\\n\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        e = \"\" \\n        g = []\\n        for i in range(len(s)):  \\n            if s[i] not in e: \\n                e = e+s[i]  \\n            else: \\n                g.append(e) \\n                e = \"\" \\n                e = e+s[i] \\n        return len(g)+1\\n        \\n        \\n``` \\n\\n**Please upvote. It would only motivate me to work harder :)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        e = \"\" \\n        g = []\\n        for i in range(len(s)):  \\n            if s[i] not in e: \\n                e = e+s[i]  \\n            else: \\n                g.append(e) \\n                e = \"\" \\n                e = e+s[i] \\n        return len(g)+1\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828956,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int partitionString(string s) \\n    {\\n       int idx=0;\\n   \\n       int count=0;\\n\\n       unordered_map<char,bool>mp;\\n\\n       while(idx < s.length())\\n       {\\n           if(mp.find(s[idx])!=mp.end())\\n           {\\n                count++;\\n                mp.clear();\\n\\n           }  \\n           mp[s[idx]]=true;\\n           idx++; \\t  \\n       }\\n       return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int partitionString(string s) \\n    {\\n       int idx=0;\\n   \\n       int count=0;\\n\\n       unordered_map<char,bool>mp;\\n\\n       while(idx < s.length())\\n       {\\n           if(mp.find(s[idx])!=mp.end())\\n           {\\n                count++;\\n                mp.clear();\\n\\n           }  \\n           mp[s[idx]]=true;\\n           idx++; \\t  \\n       }\\n       return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771544,
                "title": "java-greedy",
                "content": "\\tclass Solution {\\n\\t\\tpublic int partitionString(String s) {\\n\\t\\t\\tint res=0;\\n\\t\\t\\tHashSet<Character> set = new HashSet<>();\\n\\t\\t\\tfor(int i=0; i<s.length(); ++i){\\n\\t\\t\\t\\tif(set.contains(s.charAt(i))){\\n\\t\\t\\t\\t\\tres ++; \\n\\t\\t\\t\\t\\tset.clear();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tset.add(s.charAt(i));\\n\\t\\t\\t}\\n\\t\\t\\treturn set.size() == 0? res : res+1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int partitionString(String s) {\\n\\t\\t\\tint res=0;\\n\\t\\t\\tHashSet<Character> set = new HashSet<>();\\n\\t\\t\\tfor(int i=0; i<s.length(); ++i){\\n\\t\\t\\t\\tif(set.contains(s.charAt(i))){\\n\\t\\t\\t\\t\\tres ++; \\n\\t\\t\\t\\t\\tset.clear();\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2712392,
                "title": "easy-python-solution-t-c-better-than-96-users",
                "content": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        sets=set()\\n        ans=1\\n        for i in s:\\n            if i in sets:\\n                ans+=1\\n                sets=set()\\n            sets.add(i)\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        sets=set()\\n        ans=1\\n        for i in s:\\n            if i in sets:\\n                ans+=1\\n                sets=set()\\n            sets.add(i)\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709086,
                "title": "c-with-o-1-space-very-easy-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) \\n    {\\n       int num=0;\\n   \\n       int idx=0;\\n       int count=0;\\n       while(idx < s.length())\\n       {\\n           char ch = s[idx];\\n           int offset = ch - \\'a\\';\\n\\n           if((num & (1<<offset)) > 0)\\n           {\\n             count++;\\n             num=0;\\t\\n           }\\t\\n           num = num ^ (1<<offset);\\n           idx++;\\n       }\\n       return count+1;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) \\n    {\\n       int num=0;\\n   \\n       int idx=0;\\n       int count=0;\\n       while(idx < s.length())\\n       {\\n           char ch = s[idx];\\n           int offset = ch - \\'a\\';\\n\\n           if((num & (1<<offset)) > 0)\\n           {\\n             count++;\\n             num=0;\\t\\n           }\\t\\n           num = num ^ (1<<offset);\\n           idx++;\\n       }\\n       return count+1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614501,
                "title": "java-3-solutions",
                "content": "## 1. Using HashSet (1):\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count = 1;\\n        Set<Character> set = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            if (set.contains(c)) {\\n                count++; \\n                set = new HashSet();\\n                // set.clear();\\n            }\\n            set.add(c);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n##### Time complexity: $$O(n)$$ \\n##### Space complexity: $$O(n)$$\\n\\n---\\n\\n## 2. Using HashSet (2):\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int subs = 0, i = 0;\\n        Set<Character> set = new HashSet<>();\\n        while (i < s.length()) {\\n            while (i < s.length() && !set.contains(s.charAt(i))) {\\n                set.add(s.charAt(i)); i++;\\n            }\\n            subs++;\\n            set = new HashSet<>();\\n        }\\n\\n        return subs;\\n    }\\n}\\n```\\n##### Time complexity: $$O(n)$$ \\n##### Space complexity: $$O(n)$$\\n---\\n## 3. Using boolean array (FAST):\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count = 1;\\n        boolean[] arr = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (arr[c - \\'a\\']) {\\n                count++;\\n                arr = new boolean[26];\\n            }\\n            arr[c - \\'a\\'] = true;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```\\n##### Time complexity: $$O(n)$$ \\n##### Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count = 1;\\n        Set<Character> set = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            if (set.contains(c)) {\\n                count++; \\n                set = new HashSet();\\n                // set.clear();\\n            }\\n            set.add(c);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int subs = 0, i = 0;\\n        Set<Character> set = new HashSet<>();\\n        while (i < s.length()) {\\n            while (i < s.length() && !set.contains(s.charAt(i))) {\\n                set.add(s.charAt(i)); i++;\\n            }\\n            subs++;\\n            set = new HashSet<>();\\n        }\\n\\n        return subs;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count = 1;\\n        boolean[] arr = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (arr[c - \\'a\\']) {\\n                count++;\\n                arr = new boolean[26];\\n            }\\n            arr[c - \\'a\\'] = true;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568685,
                "title": "javascript-o-n-time-and-o-1-space-faster-than-99-less-space-than-96",
                "content": "![image](https://assets.leetcode.com/users/images/21f6e9e9-c6e0-4f82-914e-77ba10ec0d5e_1663027090.9824224.png)\\n\\n\\n```\\n/**\\n * Time complexity = O(n)\\n * Space complexity = O(1)\\n * @param {string} s\\n * @return {number}\\n */\\nconst partitionString = (s) => {\\n    const freq = new Array(26).fill(0);\\n    let result = 1;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        const index = s.charAt(i).charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n        freq[index]++;\\n        \\n        if(freq[index] > 1) {\\n            result++;\\n            freq.fill(0);\\n            freq[index]++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Time complexity = O(n)\\n * Space complexity = O(1)\\n * @param {string} s\\n * @return {number}\\n */\\nconst partitionString = (s) => {\\n    const freq = new Array(26).fill(0);\\n    let result = 1;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        const index = s.charAt(i).charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n        freq[index]++;\\n        \\n        if(freq[index] > 1) {\\n            result++;\\n            freq.fill(0);\\n            freq[index]++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2565920,
                "title": "one-pass-set-for-substring-100-speed",
                "content": "![image](https://assets.leetcode.com/users/images/d3124629-c69b-49a6-86fd-5771ee8065fa_1662974822.6240685.png)\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        sub_set, ans = set(), 1\\n        for c in s:\\n            if c in sub_set:\\n                ans += 1\\n                sub_set = {c}\\n            else:\\n                sub_set.add(c)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        sub_set, ans = set(), 1\\n        for c in s:\\n            if c in sub_set:\\n                ans += 1\\n                sub_set = {c}\\n            else:\\n                sub_set.add(c)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563827,
                "title": "c-solution-very-easy-simple-to-understand",
                "content": "Solution -->\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int count=0;\\n        unordered_map<char,int> map;\\n        for(int i=0;i<s.size();i++){\\n            map[s[i]]++;\\n            if(map[s[i]]>1){\\n                map.clear();\\n                map[s[i]]=1;\\n                count++;\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int count=0;\\n        unordered_map<char,int> map;\\n        for(int i=0;i<s.size();i++){\\n            map[s[i]]++;\\n            if(map[s[i]]>1){\\n                map.clear();\\n                map[s[i]]=1;\\n                count++;\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561802,
                "title": "python-easy-solution-hashset-solution-greedy-approach",
                "content": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        res=0\\n        hashset=set()\\n        for i in range(len(s)):\\n            if s[i] not in hashset:\\n                hashset.add(s[i])\\n            else:\\n                res+=1\\n                hashset.clear()\\n                hashset.add(s[i])\\n        if len(list(hashset))==0:\\n            return res\\n        return res+1\\n            \\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        res=0\\n        hashset=set()\\n        for i in range(len(s)):\\n            if s[i] not in hashset:\\n                hashset.add(s[i])\\n            else:\\n                res+=1\\n                hashset.clear()\\n                hashset.add(s[i])\\n        if len(list(hashset))==0:\\n            return res\\n        return res+1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560918,
                "title": "java-easy-set",
                "content": "```class Solution {\\n    public int partitionString(String s) {\\n        int j= 0;\\n        int c = 1;\\n\\t\\t// Make Set of Character.\\n        HashSet<Character> hs = new HashSet<>();\\n        while(j < s.length()){\\n            \\n            if(!hs.contains(s.charAt(j))){\\n                //System.out.println(s.charAt(j));\\n                hs.add(s.charAt(j));\\n            }else{\\n                c++;\\n                hs = new HashSet<>();\\n                //System.out.println(s.charAt(j) + \" \" + \" else \");\\n                hs.add(s.charAt(j));\\n            }\\n            j++;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public int partitionString(String s) {\\n        int j= 0;\\n        int c = 1;\\n\\t\\t// Make Set of Character.\\n        HashSet<Character> hs = new HashSet<>();\\n        while(j < s.length()){\\n            \\n            if(!hs.contains(s.charAt(j))){\\n                //System.out.println(s.charAt(j));\\n                hs.add(s.charAt(j));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2560712,
                "title": "simple-unordered-set-solution-o-n-time",
                "content": "```cpp\\nclass Solution {\\npublic:\\n\\tint partitionString(string &s) {\\n\\t\\tint cnt = 1;\\n\\t\\tunordered_set<char> st;\\n\\t\\tfor (char &c : s) {\\n\\t\\t\\tif (st.find(c) == st.end()) {\\n\\t\\t\\t\\tst.insert(c);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tst.insert(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n};\\n```\\n\\nDo **upvote** and **share**.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\tint partitionString(string &s) {\\n\\t\\tint cnt = 1;\\n\\t\\tunordered_set<char> st;\\n\\t\\tfor (char &c : s) {\\n\\t\\t\\tif (st.find(c) == st.end()) {\\n\\t\\t\\t\\tst.insert(c);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tst.insert(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560472,
                "title": "easiest-set-approach-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set <char> st;\\n        int res = 1;\\n        for (char ch : s){\\n            if (st.find(ch) != st.end()){\\n                st.clear();\\n                res++;\\n            }\\n            st.insert(ch);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set <char> st;\\n        int res = 1;\\n        for (char ch : s){\\n            if (st.find(ch) != st.end()){\\n                st.clear();\\n                res++;\\n            }\\n            st.insert(ch);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560460,
                "title": "c-simple-approach-beginner-friendly-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        map<char, int> mpp;\\n        int ans=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            \\n            mpp[s[i]]++;\\n            \\n            // if more than one char appears in single substring\\n            if(mpp[s[i]]>1){  \\n                mpp.clear();\\n                 ans++;\\n                 i--;\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        map<char, int> mpp;\\n        int ans=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            \\n            mpp[s[i]]++;\\n            \\n            // if more than one char appears in single substring\\n            if(mpp[s[i]]>1){  \\n                mpp.clear();\\n                 ans++;\\n                 i--;\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560247,
                "title": "c-solution-o-1-space-o-n-time",
                "content": "```\\n\\n   class Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ans = 1;\\n        int hash[26] = {0};\\n        int n = s.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(hash[s[i] - \\'a\\'] != 0)\\n            {\\n                memset(hash,0,sizeof(hash));\\n                ans++;\\n                hash[s[i] - \\'a\\']++;\\n            }\\n            else\\n                hash[s[i] - \\'a\\']++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ans = 1;\\n        int hash[26] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2560182,
                "title": "c-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int l=s.length(), c=0;\\n        unordered_set<char> se;\\n        for(int i=0; i<l; ++i){\\n            if(se.find(s[i]) != se.end()){\\n                c++;\\n                se.clear();\\n                i--;\\n            }\\n            else{\\n                se.insert(s[i]);\\n            }\\n        }\\n        return c+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int l=s.length(), c=0;\\n        unordered_set<char> se;\\n        for(int i=0; i<l; ++i){\\n            if(se.find(s[i]) != se.end()){\\n                c++;\\n                se.clear();\\n                i--;\\n            }\\n            else{\\n                se.insert(s[i]);\\n            }\\n        }\\n        return c+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560089,
                "title": "easy-recursive-and-memoized-dp-java-ac-solution",
                "content": "**Recursive** :\\n\\n```\\nclass Solution {\\n    public int partitionString(String s) {   \\n        return partitionStringRecursion(s, 0, new HashSet<>());\\n    }\\n    \\n    private int partitionStringRecursion(String s, int index, Set<Character> chars) {\\n        // Base Condition\\n        if (index == s.length()) {\\n            return 1;\\n        }\\n        \\n        int charCanBeAdded = 0, charCannotBeAdded = 0;\\n        if (chars.add(s.charAt(index))) {\\n            charCanBeAdded = partitionStringRecursion(s, index+1, chars);\\n        } else {\\n            charCannotBeAdded = 1 + partitionStringRecursion(s, index, new HashSet<>());\\n        }\\n        return Math.max(charCanBeAdded, charCannotBeAdded);\\n    }\\n}\\n```\\n\\n**Memoized**:\\n```\\nclass Solution {\\n    public int partitionString(String s) {   \\n        return partitionStringRecursion(s, 0, new HashSet<>(), new Integer[s.length()+1]);\\n    }\\n    \\n    private int partitionStringRecursion(String s, int index, Set<Character> chars, Integer[] cache) {\\n        // Base Condition\\n        if (index == s.length()) {\\n            return 1;\\n        }\\n        \\n        if (cache[index] != null) {\\n            return cache[index];\\n        }\\n        \\n        int charCanBeAdded = 0, charCannotBeAdded = 0;\\n        if (chars.add(s.charAt(index))) {\\n            charCanBeAdded = partitionStringRecursion(s, index+1, chars, cache);\\n        } else {\\n            charCannotBeAdded = 1 + partitionStringRecursion(s, index, new HashSet<>(), cache);\\n        }\\n        return cache[index] = Math.max(charCanBeAdded, charCannotBeAdded);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {   \\n        return partitionStringRecursion(s, 0, new HashSet<>());\\n    }\\n    \\n    private int partitionStringRecursion(String s, int index, Set<Character> chars) {\\n        // Base Condition\\n        if (index == s.length()) {\\n            return 1;\\n        }\\n        \\n        int charCanBeAdded = 0, charCannotBeAdded = 0;\\n        if (chars.add(s.charAt(index))) {\\n            charCanBeAdded = partitionStringRecursion(s, index+1, chars);\\n        } else {\\n            charCannotBeAdded = 1 + partitionStringRecursion(s, index, new HashSet<>());\\n        }\\n        return Math.max(charCanBeAdded, charCannotBeAdded);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int partitionString(String s) {   \\n        return partitionStringRecursion(s, 0, new HashSet<>(), new Integer[s.length()+1]);\\n    }\\n    \\n    private int partitionStringRecursion(String s, int index, Set<Character> chars, Integer[] cache) {\\n        // Base Condition\\n        if (index == s.length()) {\\n            return 1;\\n        }\\n        \\n        if (cache[index] != null) {\\n            return cache[index];\\n        }\\n        \\n        int charCanBeAdded = 0, charCannotBeAdded = 0;\\n        if (chars.add(s.charAt(index))) {\\n            charCanBeAdded = partitionStringRecursion(s, index+1, chars, cache);\\n        } else {\\n            charCannotBeAdded = 1 + partitionStringRecursion(s, index, new HashSet<>(), cache);\\n        }\\n        return cache[index] = Math.max(charCanBeAdded, charCannotBeAdded);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560032,
                "title": "c-easily-understandable-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) \\n    {\\n        int n = s.length();\\n        int ans=0;\\n        \\n        map<char,int> mp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(s[i])!=mp.end())\\n            {\\n                mp.clear();\\n                ans++;\\n            }\\n            mp[s[i]]=i;\\n        }\\n        \\n        if(!mp.empty()) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) \\n    {\\n        int n = s.length();\\n        int ans=0;\\n        \\n        map<char,int> mp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(s[i])!=mp.end())\\n            {\\n                mp.clear();\\n                ans++;\\n            }\\n            mp[s[i]]=i;\\n        }\\n        \\n        if(!mp.empty()) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086324,
                "title": "beginner-friendly-simple-solution-with-hashset-ds-in-typescript",
                "content": "# Intuition\\nThe problem description is the following:\\n- there\\'s a `s` string with alphabetical English lowercase chars\\n- our goal is to optimally split a string into **optimal** chunks, all of them **must contain** only unique chars\\n\\n```\\n# Example\\ns = \\'abacaba\\'\\n\\n# We want to focus your attention at fact,\\n# that all of the chars in EACH substring should be UNIQUE.\\n# So, how can we check it?\\n\\n# We could use Two Pointers, to form a Sliding Window,\\n# or HashTable/HashSet DS to know, how many unique chars we have\\n# at each step.\\n\\n# n = (ab)(ac)(ab)(a) => this is only one way to split this string.\\n\\n```\\n\\n# Approach\\n1. declare an empty `set` to store the chars inside **Sliding Window**, note that we **don\\'t have** a `left` pointer to form the window\\n2. declare an `ans` variable to store unique substrings\\n3. iterate over `s`\\n4. check, if the window condition is **broken**, i.e. the current char isn\\'t **unique**, and store the prev substring as a valid one by adding `ans++`\\n5. add current char to the `set`\\n6. return `ans`\\n\\n# Complexity\\n- Time complexity: **O(n)** to iterate over `s`\\n\\n- Space complexity: **O(n)**, in worst-case scenario all of the chars will be unique\\n\\n# Code\\n```\\nfunction partitionString(s: string): number {\\n    const set = new Set()\\n    let ans = 1\\n\\n    for (let right = 0; right < s.length; right++) {\\n        if (set.has(s[right])) {\\n            set.clear()\\n            ans += 1\\n        }\\n\\n        set.add(s[right])\\n    }\\n\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\n# Example\\ns = \\'abacaba\\'\\n\\n# We want to focus your attention at fact,\\n# that all of the chars in EACH substring should be UNIQUE.\\n# So, how can we check it?\\n\\n# We could use Two Pointers, to form a Sliding Window,\\n# or HashTable/HashSet DS to know, how many unique chars we have\\n# at each step.\\n\\n# n = (ab)(ac)(ab)(a) => this is only one way to split this string.\\n\\n```\n```\\nfunction partitionString(s: string): number {\\n    const set = new Set()\\n    let ans = 1\\n\\n    for (let right = 0; right < s.length; right++) {\\n        if (set.has(s[right])) {\\n            set.clear()\\n            ans += 1\\n        }\\n\\n        set.add(s[right])\\n    }\\n\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850440,
                "title": "java-solution-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n       int dp[] = new int[s.length()];\\n       Arrays.fill(dp,Integer.MAX_VALUE);\\n       return get(s,0,dp); \\n    }\\n    static int get(String s , int i , int[] dp){\\n        if(i==s.length()){\\n            return 0 ;\\n        }\\n        if(dp[i]!=Integer.MAX_VALUE) return dp[i];\\n        HashSet<Character> hs = new HashSet<>();\\n        int j = i ;\\n        int res = Integer.MAX_VALUE;\\n        while(j<s.length() && !hs.contains(s.charAt(j))){\\n            hs.add(s.charAt(j));\\n            j++;\\n            res=Math.min(res,1+get(s,j,dp));\\n        }\\n        if(j!=s.length()) res=Math.min(res,1+get(s,j,dp));\\n        dp[i]=res;\\n        return res ;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n       int dp[] = new int[s.length()];\\n       Arrays.fill(dp,Integer.MAX_VALUE);\\n       return get(s,0,dp); \\n    }\\n    static int get(String s , int i , int[] dp){\\n        if(i==s.length()){\\n            return 0 ;\\n        }\\n        if(dp[i]!=Integer.MAX_VALUE) return dp[i];\\n        HashSet<Character> hs = new HashSet<>();\\n        int j = i ;\\n        int res = Integer.MAX_VALUE;\\n        while(j<s.length() && !hs.contains(s.charAt(j))){\\n            hs.add(s.charAt(j));\\n            j++;\\n            res=Math.min(res,1+get(s,j,dp));\\n        }\\n        if(j!=s.length()) res=Math.min(res,1+get(s,j,dp));\\n        dp[i]=res;\\n        return res ;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831862,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ans = 1;\\n        int start = 0;\\n        for (int i=1 ; i<s.length() ; i++){\\n            for (int j=i-1 ; j>=start ; j--){\\n                if (s[i] == s[j]){\\n                    ans++;\\n                    start = i;\\n                    break;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int ans = 1;\\n        int start = 0;\\n        for (int i=1 ; i<s.length() ; i++){\\n            for (int j=i-1 ; j>=start ; j--){\\n                if (s[i] == s[j]){\\n                    ans++;\\n                    start = i;\\n                    break;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771081,
                "title": "c-being-greedy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.size();\\n        int j = 0, ans = 0;\\n        unordered_map<char,int> m;\\n\\n        while (j < n) {\\n            m[s[j]]++;\\n            if (m[s[j]] > 1) {\\n                ans++;\\n                j--;\\n                m.clear();\\n            }\\n            j++;\\n        }\\n\\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.size();\\n        int j = 0, ans = 0;\\n        unordered_map<char,int> m;\\n\\n        while (j < n) {\\n            m[s[j]]++;\\n            if (m[s[j]] > 1) {\\n                ans++;\\n                j--;\\n                m.clear();\\n            }\\n            j++;\\n        }\\n\\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713891,
                "title": "java-o-n-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            HashMap<Character,Integer>map=new HashMap<>();\\n            for(int j=i;j<s.length();j++){\\n                if(map.containsKey(s.charAt(j))){\\n                    i=j;\\n                    i--;\\n                    count++;\\n                    break;\\n                }\\n                else{\\n                   map.put(s.charAt(j),1);\\n                }\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            HashMap<Character,Integer>map=new HashMap<>();\\n            for(int j=i;j<s.length();j++){\\n                if(map.containsKey(s.charAt(j))){\\n                    i=j;\\n                    i--;\\n                    count++;\\n                    break;\\n                }\\n                else{\\n                   map.put(s.charAt(j),1);\\n                }\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655488,
                "title": "easy-python-solution",
                "content": "1. def partitionString(self, s: str) -> int:\\n\\t\\tseen = set()\\n        count = 1\\n        for c in s:\\n            if c in seen: \\n                count += 1\\n                seen = set()\\n            seen.add(c)\\n        return count",
                "solutionTags": [],
                "code": "1. def partitionString(self, s: str) -> int:\\n\\t\\tseen = set()\\n        count = 1\\n        for c in s:\\n            if c in seen: \\n                count += 1\\n                seen = set()\\n            seen.add(c)\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 3648793,
                "title": "simple-sol-using-dict-in-python",
                "content": "\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        dic={}\\n        c=1\\n        for i in s:\\n            if i in dic:\\n                c+=1\\n                dic={}\\n            dic[i]=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def partitionString(self, s: str) -> int:\\n        dic={}",
                "codeTag": "Java"
            },
            {
                "id": 3647752,
                "title": "java-easy-intuition-using-hashset",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n      HashSet<Character> set = new HashSet<>();\\n      int count = 1;\\n      for(char c : s.toCharArray()) {\\n          if(set.contains(c)) {\\n              count ++;\\n              set.clear();\\n          }\\n          set.add(c);\\n      }\\n      return count;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n      HashSet<Character> set = new HashSet<>();\\n      int count = 1;\\n      for(char c : s.toCharArray()) {\\n          if(set.contains(c)) {\\n              count ++;\\n              set.clear();\\n          }\\n          set.add(c);\\n      }\\n      return count;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616866,
                "title": "easy-peasy-hashset-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n=s.size();\\n        int res=1;\\n        unordered_set<char> ust;\\n        ust.insert(s[0]);\\n        for(int i=1; i<n; i++){\\n            if(ust.find(s[i])!=ust.end()){\\n                res++;\\n                ust.clear();\\n                ust.insert(s[i]);\\n            }\\n            ust.insert(s[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n=s.size();\\n        int res=1;\\n        unordered_set<char> ust;\\n        ust.insert(s[0]);\\n        for(int i=1; i<n; i++){\\n            if(ust.find(s[i])!=ust.end()){\\n                res++;\\n                ust.clear();\\n                ust.insert(s[i]);\\n            }\\n            ust.insert(s[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615427,
                "title": "bitset-and-bit-manipulation-solution",
                "content": "# bitset code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n\\n        bitset<26> f;\\n        for (int i=0; i<n; i++) {\\n            char x = s[i]-\\'a\\';\\n\\n            if (f.test(x)) {\\n                ans++;\\n                f.reset();\\n            }\\n\\n            f.set(x, 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n# bit manipulation\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n\\n        int mask = 0;\\n        for (auto i: s) {\\n            int x = i-\\'a\\';\\n            if ((mask >> x) & 1) {\\n                ans++;\\n                mask = 0;\\n            }\\n\\n            mask = mask | (1<<x);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n\\n        bitset<26> f;\\n        for (int i=0; i<n; i++) {\\n            char x = s[i]-\\'a\\';\\n\\n            if (f.test(x)) {\\n                ans++;\\n                f.reset();\\n            }\\n\\n            f.set(x, 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n\\n        int mask = 0;\\n        for (auto i: s) {\\n            int x = i-\\'a\\';\\n            if ((mask >> x) & 1) {\\n                ans++;\\n                mask = 0;\\n            }\\n\\n            mask = mask | (1<<x);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542721,
                "title": "c-easy-solution-hash-table-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* The intuition behind the code is to use an unordered_set to store the characters in each substring. The unordered_set is a data structure that allows us to quickly check if a character is already in the set. If the character is already in the set, then we know that it has already been used in a previous substring. In this case, we increment the counter and clear the unordered_set. This ensures that each substring will contain only unique characters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Create an unordered_set to store the characters in each substring.\\n2) Initialize a counter to 1.\\n3) Iterate over the characters in the string.\\n4) If the current character is already in the unordered_set, then increment the counter and clear the unordered_set.\\n5) Otherwise, add the current character to the unordered_set.\\n6) Repeat steps 3-5 until the end of the string is reached.\\n7) Return the counter.\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_set<char> str;\\n        int count = 1;\\n\\n        for(int i=0;i<s.size();i++){\\n            if(str.find(s[i]) != str.end()){\\n                count++;\\n                str.clear();\\n            }\\n            str.insert(s[i]);\\n        }\\n        return count;\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/2d456e31-42a4-440b-be0c-c31ad6915fda_1684523026.736528.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        unordered_set<char> str;\\n        int count = 1;\\n\\n        for(int i=0;i<s.size();i++){\\n            if(str.find(s[i]) != str.end()){\\n                count++;\\n                str.clear();\\n            }\\n            str.insert(s[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384809,
                "title": "c-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PartitionString(string s) \\n    {\\n        var hs = new HashSet<char>(); \\n        var result = 0;\\n\\n        foreach(var c in s)\\n        {\\n            if(hs.Contains(c))\\n            {\\n                hs.Clear();\\n                hs.Add(c);\\n                result++;\\n            }\\n            else\\n                hs.Add(c);\\n        }\\n\\n        return result + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PartitionString(string s) \\n    {\\n        var hs = new HashSet<char>(); \\n        var result = 0;\\n\\n        foreach(var c in s)\\n        {\\n            if(hs.Contains(c))\\n            {\\n                hs.Clear();\\n                hs.Add(c);\\n                result++;\\n            }\\n            else\\n                hs.Add(c);\\n        }\\n\\n        return result + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381765,
                "title": "python3-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        curr=set()\\n        count=1\\n        for c in s:\\n            if c in curr:\\n                curr=set()\\n                count+=1\\n            curr.add(c)\\n        return count    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        curr=set()\\n        count=1\\n        for c in s:\\n            if c in curr:\\n                curr=set()\\n                count+=1\\n            curr.add(c)\\n        return count    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380912,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n      \\n        int count=0;\\n        \\n       \\n              int[] arr = new int[26];\\n           \\n          int i=0;   \\n        while(i<s.length()){\\n            if(arr[((int)s.charAt(i))- 97]==0){\\n                arr[((int)s.charAt(i))- 97]=1;\\n                i++;\\n\\n            }\\n            else{\\n                count++;\\n                 Arrays.fill(arr,0);\\n                \\n               \\n            }\\n           \\n        }\\n        \\n    \\n    return count+1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n      \\n        int count=0;\\n        \\n       \\n              int[] arr = new int[26];\\n           \\n          int i=0;   \\n        while(i<s.length()){\\n            if(arr[((int)s.charAt(i))- 97]==0){\\n                arr[((int)s.charAt(i))- 97]=1;\\n                i++;\\n\\n            }\\n            else{\\n                count++;\\n                 Arrays.fill(arr,0);\\n                \\n               \\n            }\\n           \\n        }\\n        \\n    \\n    return count+1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380816,
                "title": "python-beginner-friendly-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        a=\"\" //temporary string\\n        res=1 //we start the count at 1 because if we don\\'t then our\\n              //answer will always be 1 less than the actual output\\n              //as we will exit the for loop before doing a last\\n              //increment\\n        for i in s:\\n            if i not in a: //checking if the character is already\\n                              //in the temporary string or not\\n                a+=i //concatenating the char to the string\\n            else: //if the character is already in the string\\n                a=i //we erase the previous substring and put the \\n                       //current character in the string\\n                res+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        a=\"\" //temporary string\\n        res=1 //we start the count at 1 because if we don\\'t then our\\n              //answer will always be 1 less than the actual output\\n              //as we will exit the for loop before doing a last\\n              //increment\\n        for i in s:\\n            if i not in a: //checking if the character is already\\n                              //in the temporary string or not\\n                a+=i //concatenating the char to the string\\n            else: //if the character is already in the string\\n                a=i //we erase the previous substring and put the \\n                       //current character in the string\\n                res+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380731,
                "title": "very-easy-and-simple-to-understand-with-o-1-space-complexity-greedy-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set<int> partition;\\n        int ans=1;\\n        for(int i=0; i<s.size(); i++){\\n            if(partition.find(s[i]) != partition.end()){\\n                ans++;\\n                partition.clear();\\n            }\\n            partition.insert(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set<int> partition;\\n        int ans=1;\\n        for(int i=0; i<s.size(); i++){\\n            if(partition.find(s[i]) != partition.end()){\\n                ans++;\\n                partition.clear();\\n            }\\n            partition.insert(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380644,
                "title": "swift-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func partitionString(_ s: String) -> Int {\\n        var tempArray: [Character] = []\\n        var resArray: [[Character]] = []\\n\\n        for char in s {\\n            if tempArray.contains(char)  {\\n                resArray.append(tempArray)\\n                tempArray = [char]\\n            } else {\\n                tempArray.append(char)\\n            }\\n        }\\n\\n        if !tempArray.isEmpty {\\n            resArray.append(tempArray)\\n        }\\n        return resArray.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func partitionString(_ s: String) -> Int {\\n        var tempArray: [Character] = []\\n        var resArray: [[Character]] = []\\n\\n        for char in s {\\n            if tempArray.contains(char)  {\\n                resArray.append(tempArray)\\n                tempArray = [char]\\n            } else {\\n                tempArray.append(char)\\n            }\\n        }\\n\\n        if !tempArray.isEmpty {\\n            resArray.append(tempArray)\\n        }\\n        return resArray.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380621,
                "title": "java-bitmasking-easy-solution-please-like-it-gives-me-more-strength",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int partitionString(String s) {\\n        int mask = 0;\\n        int result = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            int index = 1 << (s.charAt(i) - \\'a\\');\\n            if((mask & index) > 0) {\\n                mask = 0;\\n                result++;\\n            }\\n            mask |= index;\\n        }\\n        return result + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int partitionString(String s) {\\n        int mask = 0;\\n        int result = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            int index = 1 << (s.charAt(i) - \\'a\\');\\n            if((mask & index) > 0) {\\n                mask = 0;\\n                result++;\\n            }\\n            mask |= index;\\n        }\\n        return result + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380609,
                "title": "c-easy-solution-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n          vector<int>ans(26,0) ;\\n          int count  = 1;\\n        //   ans[]\\n          for(int i = 0 ; i < s.size() ; i ++ ){              \\n            ans[s[i]- \\'a\\'] ++; \\n            if(ans[s[i]- \\'a\\' ] ==2 ){\\n                count ++ ; \\n                fill(ans.begin() , ans.end() , 0) ;\\n                ans[s[i] - \\'a\\']++;\\n                continue ;\\n            }\\n          }\\n          return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n          vector<int>ans(26,0) ;\\n          int count  = 1;\\n        //   ans[]\\n          for(int i = 0 ; i < s.size() ; i ++ ){              \\n            ans[s[i]- \\'a\\'] ++; \\n            if(ans[s[i]- \\'a\\' ] ==2 ){\\n                count ++ ; \\n                fill(ans.begin() , ans.end() , 0) ;\\n                ans[s[i] - \\'a\\']++;\\n                continue ;\\n            }\\n          }\\n          return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380608,
                "title": "c-unordered-set-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n       unordered_set<int> a;\\n       int count=1;\\n       for(int i=0;i<s.length();i++){\\n           if(i==0){\\n               a.insert(s[i]);\\n               continue;\\n           }\\n           if(a.find(s[i])!=a.end()){\\n               count++;\\n               a.clear();\\n               a.insert(s[i]);\\n           }\\n           else{\\n               a.insert(s[i]);\\n           }\\n       }\\n       return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n       unordered_set<int> a;\\n       int count=1;\\n       for(int i=0;i<s.length();i++){\\n           if(i==0){\\n               a.insert(s[i]);\\n               continue;\\n           }\\n           if(a.find(s[i])!=a.end()){\\n               count++;\\n               a.clear();\\n               a.insert(s[i]);\\n           }\\n           else{\\n               a.insert(s[i]);\\n           }\\n       }\\n       return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380603,
                "title": "simple-c-solution-hashing-sets",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set<char> st;\\n        int ans=0;\\n        for (int i=0; i<s.size(); i++){\\n            if (st.find(s[i])!=st.end()){\\n                ans++;\\n                st.clear();\\n                st.insert(s[i]);\\n            }\\n            else st.insert(s[i]);\\n        }\\n        if (!st.empty())ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set<char> st;\\n        int ans=0;\\n        for (int i=0; i<s.size(); i++){\\n            if (st.find(s[i])!=st.end()){\\n                ans++;\\n                st.clear();\\n                st.insert(s[i]);\\n            }\\n            else st.insert(s[i]);\\n        }\\n        if (!st.empty())ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380569,
                "title": "not-good-but-average-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count=0;\\n        HashSet<Character> st = new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            if(st.contains(s.charAt(i)))\\n            {\\n                count++;\\n                st.clear();\\n\\n            }\\n            st.add(s.charAt(i));\\n\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int count=0;\\n        HashSet<Character> st = new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            if(st.contains(s.charAt(i)))\\n            {\\n                count++;\\n                st.clear();\\n\\n            }\\n            st.add(s.charAt(i));\\n\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380543,
                "title": "c-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int re=1;\\n        unordered_map<char,int> tem;\\n        for(int i=0; i<s.length(); i++){\\n           if(tem.find(s[i]) !=tem.end()){\\n               if(tem[s[i]]>0) re++,tem.clear();   \\n           }\\n           tem[s[i]]++;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        int re=1;\\n        unordered_map<char,int> tem;\\n        for(int i=0; i<s.length(); i++){\\n           if(tem.find(s[i]) !=tem.end()){\\n               if(tem[s[i]]>0) re++,tem.clear();   \\n           }\\n           tem[s[i]]++;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380504,
                "title": "most-simple-python-solution-no-hash-map-required-beats-97-code",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem is to create substrings of continous elements from main strings with no repetition values and find the minimum number of substrings required. \\n\\nSo inorder to keep track of existing substring instead of using hashmaps, we use an intermediate string. As we traverse through the main string we keep adding elements to the intermediate string. If a character is already present we assing the intermediate string to the new character and increment the value of count by 1 which represents the total number of substrings.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        count=1\\n        a=\"\"\\n        for i in s:\\n            if i in a:\\n                a=i\\n                count+=1\\n            else:\\n                a+=i\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        count=1\\n        a=\"\"\\n        for i in s:\\n            if i in a:\\n                a=i\\n                count+=1\\n            else:\\n                a+=i\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380479,
                "title": "easiest-and-fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        Set<Character> set=new HashSet<>();\\n      int count=1;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(set.add(ch)){\\n                continue;\\n            }else{\\n                set.clear();\\n                set.add(ch);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        Set<Character> set=new HashSet<>();\\n      int count=1;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(set.add(ch)){\\n                continue;\\n            }else{\\n                set.clear();\\n                set.add(ch);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380377,
                "title": "straight-forward-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        c=0\\n        res=set()\\n        for i in s:\\n            if i in res:\\n                c=c+1\\n                res=set()\\n            res.add(i)\\n        return c+1\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        c=0\\n        res=set()\\n        for i in s:\\n            if i in res:\\n                c=c+1\\n                res=set()\\n            res.add(i)\\n        return c+1\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380209,
                "title": "python-simple-and-clean-beats-90-09-mem",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find the minimum number of substrings in which the characters are unique. So, we can start by iterating over each character in the string and keeping track of the unique characters that we have seen so far. Whenever we encounter a character that we have already seen, we can start a new substring. We need to count the number of substrings we create and return the count as the answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable `count` to 1 to keep track of the number of substrings we have.\\n1. Initialize a defaultdict `seen` to keep track of the unique characters that we have seen so far.\\n1. Iterate over each character `letter` in the string `s`.\\n1. If we have already seen letter, then increment `count`, reset `seen` to an empty defaultdict, and mark letter as seen in `seen`.\\n1. Otherwise, mark letter as seen in `seen`.\\n1. Return `count` as the answer.\\n# Complexity\\n- Time complexity: $$O(n)$$, where `n` is the length of the string s. We need to iterate over each character in s once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$, where `k` is the number of unique characters in `s`. We need to store the unique characters that we have seen so far in seen.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        count = 1\\n        seen = defaultdict(lambda:False)\\n        for letter in s:\\n            if seen[letter]:\\n                count+=1\\n                seen = defaultdict(lambda:False)\\n                seen[letter] = True\\n            else:\\n                seen[letter] = True\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        count = 1\\n        seen = defaultdict(lambda:False)\\n        for letter in s:\\n            if seen[letter]:\\n                count+=1\\n                seen = defaultdict(lambda:False)\\n                seen[letter] = True\\n            else:\\n                seen[letter] = True\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380202,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int res = 0;\\n        int i = 0;\\n        while(i < s.length()){\\n            res++;\\n            int[] count = new int[26];\\n            while(i < s.length()){\\n                if(count[s.charAt(i) - \\'a\\'] > 0)\\n                    break;\\n                count[s.charAt(i)-\\'a\\']++;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int res = 0;\\n        int i = 0;\\n        while(i < s.length()){\\n            res++;\\n            int[] count = new int[26];\\n            while(i < s.length()){\\n                if(count[s.charAt(i) - \\'a\\'] > 0)\\n                    break;\\n                count[s.charAt(i)-\\'a\\']++;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380197,
                "title": "easy-and-fast-solution-in-java",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int a[]=new int[26],c=1,x;\\n        for(char i:s.toCharArray()){\\n            x=i-\\'a\\';\\n            if(a[x]==c) c++;\\n            a[x]=c;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionString(String s) {\\n        int a[]=new int[26],c=1,x;\\n        for(char i:s.toCharArray()){\\n            x=i-\\'a\\';\\n            if(a[x]==c) c++;\\n            a[x]=c;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380092,
                "title": "easy-solution-using-empty-string-python3-best-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we have to calculate the count of particition with unique character so we check the duplicacy and where we find duplicated we count +=1 and make string emply\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing string searching\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        s1=\"\"\\n        c=1\\n        for i in s:\\n            if s1==\"\":\\n                s1+=i\\n            elif i not in s1:\\n                s1+=i\\n            elif i in s1:\\n                c+=1\\n                s1=\"\"\\n                s1+=i\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionString(self, s: str) -> int:\\n        s1=\"\"\\n        c=1\\n        for i in s:\\n            if s1==\"\":\\n                s1+=i\\n            elif i not in s1:\\n                s1+=i\\n            elif i in s1:\\n                c+=1\\n                s1=\"\"\\n                s1+=i\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380018,
                "title": "simple-js-ts-soltution",
                "content": "# Intuition\\nMy intuition was to split the string so I can interate over it and have a results array to keep track of the length and last substring to check if the next letter was in the last substring.\\n\\n# Approach\\nPretty straightforward soltution with typescript where I loop over the split string and push the first item in the resuls array if there are no items yet. Then I check if the last substring that was pushed in has the next letter included in it and increment the lastIndex of the last substring that was inserted. Then if the last substring inserted doesn\\'t include the next letter then concat that letter to the last substring.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunction partitionString(s: string): number {\\n    const splits = s.split(\"\");\\n    const results: string[] = [];\\n    let lastIndex = 0;\\n    for (let i = 0; i < splits.length; i++) {\\n        if (!results.length) {\\n            results.push(splits[i])\\n        } else if (results[lastIndex].includes(splits[i])) {\\n            results.push(splits[i])\\n            lastIndex++\\n        } else {\\n            results[lastIndex] = results[lastIndex].concat(splits[i])\\n        }\\n    }\\n    return results.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction partitionString(s: string): number {\\n    const splits = s.split(\"\");\\n    const results: string[] = [];\\n    let lastIndex = 0;\\n    for (let i = 0; i < splits.length; i++) {\\n        if (!results.length) {\\n            results.push(splits[i])\\n        } else if (results[lastIndex].includes(splits[i])) {\\n            results.push(splits[i])\\n            lastIndex++\\n        } else {\\n            results[lastIndex] = results[lastIndex].concat(splits[i])\\n        }\\n    }\\n    return results.length;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1853041,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1760961,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853347,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1821238,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853152,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853595,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853269,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853407,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853661,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853139,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853041,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1760961,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853347,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1821238,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853152,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853595,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853269,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853407,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853661,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853139,
                "content": [
                    {
                        "username": "Casardo",
                        "content": "How is this not easy?"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@hadityakumar](/hadityakumar) It took me 1 minute"
                    },
                    {
                        "username": "gbiems",
                        "content": "Unfortunately (for me), I didn\\'t immediately realize that you should process as much of each string as possible to get the optimal solution. I thought that it would be necessary to recursively process each possible substring + all variants of remaining string, then pick the result with the smallest number of splits. It works for smaller problems, but it was tricky code to write and hits TLE very quickly (I think by 12/52 test cases or something like that) even with various pruning techniques. \\n\\nAs pretty much everyone who considers this an easy problem understands, there\\'s no need to do that. If you process the maximum number of characters at each split allowed, you\\'ll reach the optimal solution. There\\'s no need to branch and build a tree, because this approach will never provide a more optimal solution. It may provide an alternate equal solution, but never more optimal in terms of number of partitions. \\n\\nI saw the discussion post that this is \"easy\" and started to think... hmm, maybe I\\'m missing something here. But the problem is, someone *always* says it\\'s easy. But this time, yeah, if I\\'d known it genuinely is an easy problem, I\\'d have known there\\'s no way that branching approach was necessary. \\n\\n\"Easy\" in leetcode takes two main forms. There\\'s easy that\\'s just easy, straightforward, no real difficulty. Then there\\'s \"easy when you know how\". Some problems are still difficult to implement even when you have the approach explained to you, others suddenly become very easy. This is one of those problems that is very, very easy to code up as long as you realize the approach (or once you read the discussion and understand the approach). "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cswartzell](/cswartzell) I agree with [@Vitid](/vnk01). The problem is one of the sipmlest among mediumones, but in easy category they usually even spell out what method to use. Here you still have to think for yourself even if it's not that much thinking provided it's not your first time to ever manipulate a string"
                    },
                    {
                        "username": "hadityakumar",
                        "content": "Still took me 1 hour to solve"
                    },
                    {
                        "username": "psionl0",
                        "content": "It turns out to be easy because a brute force solution (searching for a repeating character) is no faster than counting letters. Otherwise, you would need to be familiar with letter counting algorithms to solve this problem."
                    },
                    {
                        "username": "vnk01",
                        "content": "[@cswartzell](/cswartzell) Yes it\\'s easy. What I mean is it\\'s not as easy like your typical easy probs, like straight up implementation of binary search a few days ago"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@vnk01](/vnk01) Add one when youve seen a letter before, start counting anew? Almost no problem is simpler"
                    },
                    {
                        "username": "vnk01",
                        "content": "This definitely more involved than vanilla easy questions "
                    },
                    {
                        "username": "bangychiller",
                        "content": "i am getting wrong answer for the testcase \"hdklqkcssgxlvehva\" , my answer is \\'2\\' and the expected one is \\'4\\' . According to the description of the question , the sub strings can look like ;- \"hdklqcsgxvac\" , \"klhv\" . i am counting the maximum frequency of any alphabet as the answer . correct me if i am missing out on something."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@sahle123](/sahle123) (hdklq),(kcs),(sgxlveh),(va) these are the 4. in 2nd, \\'k\\' was repeating so breaked, in third \\'s\\' was repeating and in 4th \\'v\\' was repeating.. always first char will repeat in greedy solution by maintaining an array of count of each alphaabets."
                    },
                    {
                        "username": "sahle123",
                        "content": "I had the same exact issue. It doesn\\'t make sense how it\\'s supposed to be 4."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) substring is a subset of adjacent characters (you essentially cut a slice of your string; that's a substring). You can generate n^2 distinct substrings \nA subsequence is a subset of characters whose relative order has been preserved (but not necessarily adjacent). You can think of a subsequence as a substring where some characters may have been skipped. You can generate 2^n distinct subsequences \nstring: \"123456789\"\n\"456\" is a substring (and also a subsequence)\n\"24789\" is a subsequence (but not a substring)\n\"21\" is neither because the order is not preserved. It is just a subset"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@viktorsukharev](/viktorsukharev)  THanx for clarification I too was getting wrong answer for this test case!! Btw there is difference in substring and subseqence which problem setters are not clear about!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@bhaskarcsawant](/bhaskarcsawant) The answer is only 2 if you don\\'t know the definition of a substring. Substring does mean subset of  adjacent characters. The problem statement is technically correct tho it could use a little note for clarification\\nNot giving you a hard time; I did exactly the same as OP after reading too fast too haha"
                    },
                    {
                        "username": "asurendrakumarpatel",
                        "content": "Same logic i also thought."
                    },
                    {
                        "username": "bhaskarcsawant",
                        "content": "I think this question needs to be more clear.  because they are asking to return \"Return the MINIMUM number of substrings in such a partition\" for this statement I think the ans should be 2."
                    },
                    {
                        "username": "hosua",
                        "content": "[@viktorsukharev](/viktorsukharev) Thanks for clearing that up"
                    },
                    {
                        "username": "bangychiller",
                        "content": "[@viktorsukharev](/viktorsukharev) oh , thanks a lot for pointing that out , didn\\'t find it in the question description."
                    },
                    {
                        "username": "viktorsukharev",
                        "content": "[@bangychiller](/bangychiller) By substring they mean a sequence of adjacent characters, we must not reorder them. For instance, in the given testcase the input could be partitioned as \"hdklq\", \"kcs\", \"sgxlveh\", \"va\""
                    },
                    {
                        "username": "Msey",
                        "content": "Something wrong with this question if I can solve it"
                    },
                    {
                        "username": "Msey",
                        "content": "[@AshishLearning](/AshishLearning) :)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23 You again."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "For this question, I can say that it's an easy one . If you have knowledge of set data structure."
                    },
                    {
                        "username": "schrodlm",
                        "content": "You dont even have to use set for this a vector of booleans is faster"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t overthink, simply use Set and partition the string as soon as some char reappear."
                    },
                    {
                        "username": "arison646",
                        "content": "Well If we talking hints there is no point in using any arrays since standard int has 32 bits thus being able to hold all of the data u need."
                    },
                    {
                        "username": "pcRipper",
                        "content": "amount of letters is just 26, i used a static bool array with `memset` to reset data"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "sometimes i feel reading discussion is more fruitful than solving such questions."
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I overthought and complicated the problem for no reason. \\n\\nStart with count as 1 and empty set. \\nIterate over the string and check is character is repeating. \\n   If yes we increment count, clear set and add the new character to set.\\n   If no we add the character to set and continue the loop.\\nReturn count.\\n"
                    },
                    {
                        "username": "sharma_pratham_02",
                        "content": "Thanks!"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "In example 1 one possible partition is missed that is ab, ac, ab, a."
                    },
                    {
                        "username": "motsebopat",
                        "content": "right, your code can provide different partitions, but the question asked, is the minimum number of partition your code will return"
                    },
                    {
                        "username": "nbranch1311",
                        "content": "Thank you, I kept looking at this and felt like I was gaslighting myself"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Thanks, I was about to ask. "
                    },
                    {
                        "username": "Godzilla1495",
                        "content": "I have confused about the answer. So my question is why we cannot get an answer: [\"ab\", \"ba\", \"bac\", \"ac\". \"cab\", \"a\"] ?"
                    },
                    {
                        "username": "Squeeze-",
                        "content": "I believe its because the question wants the minimum amount of partitions so yours is a partition of length 6 while it can be written as a partition of 4 so you would choose 4 over six"
                    },
                    {
                        "username": "raghavgupta_00",
                        "content": "you have to use single element only once"
                    },
                    {
                        "username": "daring-calf",
                        "content": "If I can bruteforce it greedily, it\\'s an easy one. "
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@user5313X](/user5313X) Lol. You got me. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Greedy solutions are usually my nemesis. It is most often really hard for me to prove that they work and won't miss a case, and I never go for a solution that I can't explain properly. So greedy is probably the #1 category I need to practise\n...\nWell, not in that case, for real problems I mean"
                    }
                ]
            },
            {
                "id": 1853273,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "Just remember It\\'s SUBSTRING ..Not a SUBSEQUENCE!!!!!!!!!"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "How is this a medium question? \\uD83D\\uDE35"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "4 days in and the problems haven\\'t been very hard so far. I think Leetcode is gonna hit us suddenly with a Hard problem that involves trie"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use a hash table for those characters in the string. this problem can be solved!\nUse a hash table to store the occurrence place of each character in the string s. When the next substring begins, reset the hash table. Quite simple idea."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/optimal-partition-of-string/solutions/3376710/easy-c-solution-using-hash-table-a-for-loop/"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Start traversing string from left to right and get all the substrings having unique characters.\\nUse map to check unique characters in the substrings generated by partitions."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Use Sliding Window Approach: \\n\\n You can start by initializing two pointers left and right to point to the first character in the string. Then, you can iterate over the string and do the following:\\n\\nIf the character at the right pointer is not in the current partition, add it to the partition and increment the right pointer.\\nIf the character at the right pointer is already in the current partition, update the left pointer to point to the next character after the last occurrence of the character in the current partition, and clear the current partition."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "[@cswartzell](/cswartzell) yes, at the very beginning, we set both \\'left\\' and \\'right\\' at the same place, in this case, the first character of the string, we initiate the answer variable as 1. Then, we let left hold its position while sliding right character by character to the right. Every time, we add one to the corresponding slot in the currency table(consisting of 26 slots, each of them is initiated as 0), according to the character the right pointer is pointing to(including the first position). When we get 2, we increment the answer variable, reset our table so that all slots are zero again, and move left to the position of right, and restart our process, until right has hit the end of the string."
                    },
                    {
                        "username": "cswartzell",
                        "content": "An interesting approach. How would you check if the character is in the current window? Iterate through the whole window each time you add a letter?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "bitmask can be used to check the duplicated letters to improve time and space consuming, pls refer to my c++ code:\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        int two_pow[26]; // prepare the mask value for the letter \\'a\\' to \\'z\\'\\n        for (int d = 0; d < 26; d++){\\n            if (d == 0) two_pow[d] = 1;\\n            else two_pow[d] = two_pow[d - 1] * 2;\\n        }\\n\\n        int sn = (int)s.size();\\n        int start = 0;\\n        int ret = 0;\\n        while(true){\\n            int mask = 0;\\n            int update_start = -1;\\n            for (int i = start; i < sn; i++){\\n                int letter = s[i] - \\'a\\';\\n                if ((two_pow[letter] & mask) == 0){// use bitmask to check whether s[i] is duplicated.\\n                    mask |= two_pow[letter];\\n                }\\n                else{\\n                    update_start = i;\\n                    ret++;\\n                    break;\\n                }                \\n            }\\n            if (update_start == -1) {\\n                ret += (bool)mask;\\n                break;\\n            }\\n            start = update_start;\\n        }\\n        return ret;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "alexeynazarov",
                        "content": "Explanation for the first example is a bit confusing (but not incorrect): partition for the greedy solution is (\"ab\",\"ac\",\"ab\",\"a\")."
                    },
                    {
                        "username": "14103263yash",
                        "content": "I think this note is wrong based on given example itself\\n`Note that each character should belong to exactly one substring in a partition.\\n`\\n"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I\\'m not too sure how to code this, but is it not possible to solve this issue using a sliding window, e.g.\\n\\n```python\\n    def partitionString(self, s: str) -> int:\\n        left = 0\\n        ans = 0\\n        char_set = set()\\n\\n        for right in range(len(s)):\\n            if s[right] in char_set:\\n                ans += 1 \\n                \\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n\\n            char_set.add(s[right])\\n\\n        return ans\\n```\\n\\nWhere the idea is we increment the sliding window for each unique subarray, and so increment our answer, and while that constraint is not met we shrink the size of the sliding window to find the next unique substring. Since the sliding window greedily takes the next greatest partition, shouldn\\'t we get the minimum number of substrings?"
                    }
                ]
            },
            {
                "id": 1853378,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "Just remember It\\'s SUBSTRING ..Not a SUBSEQUENCE!!!!!!!!!"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "How is this a medium question? \\uD83D\\uDE35"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "4 days in and the problems haven\\'t been very hard so far. I think Leetcode is gonna hit us suddenly with a Hard problem that involves trie"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use a hash table for those characters in the string. this problem can be solved!\nUse a hash table to store the occurrence place of each character in the string s. When the next substring begins, reset the hash table. Quite simple idea."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/optimal-partition-of-string/solutions/3376710/easy-c-solution-using-hash-table-a-for-loop/"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Start traversing string from left to right and get all the substrings having unique characters.\\nUse map to check unique characters in the substrings generated by partitions."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Use Sliding Window Approach: \\n\\n You can start by initializing two pointers left and right to point to the first character in the string. Then, you can iterate over the string and do the following:\\n\\nIf the character at the right pointer is not in the current partition, add it to the partition and increment the right pointer.\\nIf the character at the right pointer is already in the current partition, update the left pointer to point to the next character after the last occurrence of the character in the current partition, and clear the current partition."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "[@cswartzell](/cswartzell) yes, at the very beginning, we set both \\'left\\' and \\'right\\' at the same place, in this case, the first character of the string, we initiate the answer variable as 1. Then, we let left hold its position while sliding right character by character to the right. Every time, we add one to the corresponding slot in the currency table(consisting of 26 slots, each of them is initiated as 0), according to the character the right pointer is pointing to(including the first position). When we get 2, we increment the answer variable, reset our table so that all slots are zero again, and move left to the position of right, and restart our process, until right has hit the end of the string."
                    },
                    {
                        "username": "cswartzell",
                        "content": "An interesting approach. How would you check if the character is in the current window? Iterate through the whole window each time you add a letter?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "bitmask can be used to check the duplicated letters to improve time and space consuming, pls refer to my c++ code:\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        int two_pow[26]; // prepare the mask value for the letter \\'a\\' to \\'z\\'\\n        for (int d = 0; d < 26; d++){\\n            if (d == 0) two_pow[d] = 1;\\n            else two_pow[d] = two_pow[d - 1] * 2;\\n        }\\n\\n        int sn = (int)s.size();\\n        int start = 0;\\n        int ret = 0;\\n        while(true){\\n            int mask = 0;\\n            int update_start = -1;\\n            for (int i = start; i < sn; i++){\\n                int letter = s[i] - \\'a\\';\\n                if ((two_pow[letter] & mask) == 0){// use bitmask to check whether s[i] is duplicated.\\n                    mask |= two_pow[letter];\\n                }\\n                else{\\n                    update_start = i;\\n                    ret++;\\n                    break;\\n                }                \\n            }\\n            if (update_start == -1) {\\n                ret += (bool)mask;\\n                break;\\n            }\\n            start = update_start;\\n        }\\n        return ret;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "alexeynazarov",
                        "content": "Explanation for the first example is a bit confusing (but not incorrect): partition for the greedy solution is (\"ab\",\"ac\",\"ab\",\"a\")."
                    },
                    {
                        "username": "14103263yash",
                        "content": "I think this note is wrong based on given example itself\\n`Note that each character should belong to exactly one substring in a partition.\\n`\\n"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I\\'m not too sure how to code this, but is it not possible to solve this issue using a sliding window, e.g.\\n\\n```python\\n    def partitionString(self, s: str) -> int:\\n        left = 0\\n        ans = 0\\n        char_set = set()\\n\\n        for right in range(len(s)):\\n            if s[right] in char_set:\\n                ans += 1 \\n                \\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n\\n            char_set.add(s[right])\\n\\n        return ans\\n```\\n\\nWhere the idea is we increment the sliding window for each unique subarray, and so increment our answer, and while that constraint is not met we shrink the size of the sliding window to find the next unique substring. Since the sliding window greedily takes the next greatest partition, shouldn\\'t we get the minimum number of substrings?"
                    }
                ]
            },
            {
                "id": 1853227,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "Just remember It\\'s SUBSTRING ..Not a SUBSEQUENCE!!!!!!!!!"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "How is this a medium question? \\uD83D\\uDE35"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "4 days in and the problems haven\\'t been very hard so far. I think Leetcode is gonna hit us suddenly with a Hard problem that involves trie"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use a hash table for those characters in the string. this problem can be solved!\nUse a hash table to store the occurrence place of each character in the string s. When the next substring begins, reset the hash table. Quite simple idea."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/optimal-partition-of-string/solutions/3376710/easy-c-solution-using-hash-table-a-for-loop/"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Start traversing string from left to right and get all the substrings having unique characters.\\nUse map to check unique characters in the substrings generated by partitions."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Use Sliding Window Approach: \\n\\n You can start by initializing two pointers left and right to point to the first character in the string. Then, you can iterate over the string and do the following:\\n\\nIf the character at the right pointer is not in the current partition, add it to the partition and increment the right pointer.\\nIf the character at the right pointer is already in the current partition, update the left pointer to point to the next character after the last occurrence of the character in the current partition, and clear the current partition."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "[@cswartzell](/cswartzell) yes, at the very beginning, we set both \\'left\\' and \\'right\\' at the same place, in this case, the first character of the string, we initiate the answer variable as 1. Then, we let left hold its position while sliding right character by character to the right. Every time, we add one to the corresponding slot in the currency table(consisting of 26 slots, each of them is initiated as 0), according to the character the right pointer is pointing to(including the first position). When we get 2, we increment the answer variable, reset our table so that all slots are zero again, and move left to the position of right, and restart our process, until right has hit the end of the string."
                    },
                    {
                        "username": "cswartzell",
                        "content": "An interesting approach. How would you check if the character is in the current window? Iterate through the whole window each time you add a letter?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "bitmask can be used to check the duplicated letters to improve time and space consuming, pls refer to my c++ code:\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        int two_pow[26]; // prepare the mask value for the letter \\'a\\' to \\'z\\'\\n        for (int d = 0; d < 26; d++){\\n            if (d == 0) two_pow[d] = 1;\\n            else two_pow[d] = two_pow[d - 1] * 2;\\n        }\\n\\n        int sn = (int)s.size();\\n        int start = 0;\\n        int ret = 0;\\n        while(true){\\n            int mask = 0;\\n            int update_start = -1;\\n            for (int i = start; i < sn; i++){\\n                int letter = s[i] - \\'a\\';\\n                if ((two_pow[letter] & mask) == 0){// use bitmask to check whether s[i] is duplicated.\\n                    mask |= two_pow[letter];\\n                }\\n                else{\\n                    update_start = i;\\n                    ret++;\\n                    break;\\n                }                \\n            }\\n            if (update_start == -1) {\\n                ret += (bool)mask;\\n                break;\\n            }\\n            start = update_start;\\n        }\\n        return ret;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "alexeynazarov",
                        "content": "Explanation for the first example is a bit confusing (but not incorrect): partition for the greedy solution is (\"ab\",\"ac\",\"ab\",\"a\")."
                    },
                    {
                        "username": "14103263yash",
                        "content": "I think this note is wrong based on given example itself\\n`Note that each character should belong to exactly one substring in a partition.\\n`\\n"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I\\'m not too sure how to code this, but is it not possible to solve this issue using a sliding window, e.g.\\n\\n```python\\n    def partitionString(self, s: str) -> int:\\n        left = 0\\n        ans = 0\\n        char_set = set()\\n\\n        for right in range(len(s)):\\n            if s[right] in char_set:\\n                ans += 1 \\n                \\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n\\n            char_set.add(s[right])\\n\\n        return ans\\n```\\n\\nWhere the idea is we increment the sliding window for each unique subarray, and so increment our answer, and while that constraint is not met we shrink the size of the sliding window to find the next unique substring. Since the sliding window greedily takes the next greatest partition, shouldn\\'t we get the minimum number of substrings?"
                    }
                ]
            },
            {
                "id": 1853108,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "Just remember It\\'s SUBSTRING ..Not a SUBSEQUENCE!!!!!!!!!"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "How is this a medium question? \\uD83D\\uDE35"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "4 days in and the problems haven\\'t been very hard so far. I think Leetcode is gonna hit us suddenly with a Hard problem that involves trie"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use a hash table for those characters in the string. this problem can be solved!\nUse a hash table to store the occurrence place of each character in the string s. When the next substring begins, reset the hash table. Quite simple idea."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/optimal-partition-of-string/solutions/3376710/easy-c-solution-using-hash-table-a-for-loop/"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Start traversing string from left to right and get all the substrings having unique characters.\\nUse map to check unique characters in the substrings generated by partitions."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Use Sliding Window Approach: \\n\\n You can start by initializing two pointers left and right to point to the first character in the string. Then, you can iterate over the string and do the following:\\n\\nIf the character at the right pointer is not in the current partition, add it to the partition and increment the right pointer.\\nIf the character at the right pointer is already in the current partition, update the left pointer to point to the next character after the last occurrence of the character in the current partition, and clear the current partition."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "[@cswartzell](/cswartzell) yes, at the very beginning, we set both \\'left\\' and \\'right\\' at the same place, in this case, the first character of the string, we initiate the answer variable as 1. Then, we let left hold its position while sliding right character by character to the right. Every time, we add one to the corresponding slot in the currency table(consisting of 26 slots, each of them is initiated as 0), according to the character the right pointer is pointing to(including the first position). When we get 2, we increment the answer variable, reset our table so that all slots are zero again, and move left to the position of right, and restart our process, until right has hit the end of the string."
                    },
                    {
                        "username": "cswartzell",
                        "content": "An interesting approach. How would you check if the character is in the current window? Iterate through the whole window each time you add a letter?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "bitmask can be used to check the duplicated letters to improve time and space consuming, pls refer to my c++ code:\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        int two_pow[26]; // prepare the mask value for the letter \\'a\\' to \\'z\\'\\n        for (int d = 0; d < 26; d++){\\n            if (d == 0) two_pow[d] = 1;\\n            else two_pow[d] = two_pow[d - 1] * 2;\\n        }\\n\\n        int sn = (int)s.size();\\n        int start = 0;\\n        int ret = 0;\\n        while(true){\\n            int mask = 0;\\n            int update_start = -1;\\n            for (int i = start; i < sn; i++){\\n                int letter = s[i] - \\'a\\';\\n                if ((two_pow[letter] & mask) == 0){// use bitmask to check whether s[i] is duplicated.\\n                    mask |= two_pow[letter];\\n                }\\n                else{\\n                    update_start = i;\\n                    ret++;\\n                    break;\\n                }                \\n            }\\n            if (update_start == -1) {\\n                ret += (bool)mask;\\n                break;\\n            }\\n            start = update_start;\\n        }\\n        return ret;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "alexeynazarov",
                        "content": "Explanation for the first example is a bit confusing (but not incorrect): partition for the greedy solution is (\"ab\",\"ac\",\"ab\",\"a\")."
                    },
                    {
                        "username": "14103263yash",
                        "content": "I think this note is wrong based on given example itself\\n`Note that each character should belong to exactly one substring in a partition.\\n`\\n"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I\\'m not too sure how to code this, but is it not possible to solve this issue using a sliding window, e.g.\\n\\n```python\\n    def partitionString(self, s: str) -> int:\\n        left = 0\\n        ans = 0\\n        char_set = set()\\n\\n        for right in range(len(s)):\\n            if s[right] in char_set:\\n                ans += 1 \\n                \\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n\\n            char_set.add(s[right])\\n\\n        return ans\\n```\\n\\nWhere the idea is we increment the sliding window for each unique subarray, and so increment our answer, and while that constraint is not met we shrink the size of the sliding window to find the next unique substring. Since the sliding window greedily takes the next greatest partition, shouldn\\'t we get the minimum number of substrings?"
                    }
                ]
            },
            {
                "id": 1853077,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "Just remember It\\'s SUBSTRING ..Not a SUBSEQUENCE!!!!!!!!!"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "How is this a medium question? \\uD83D\\uDE35"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "4 days in and the problems haven\\'t been very hard so far. I think Leetcode is gonna hit us suddenly with a Hard problem that involves trie"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use a hash table for those characters in the string. this problem can be solved!\nUse a hash table to store the occurrence place of each character in the string s. When the next substring begins, reset the hash table. Quite simple idea."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/optimal-partition-of-string/solutions/3376710/easy-c-solution-using-hash-table-a-for-loop/"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Start traversing string from left to right and get all the substrings having unique characters.\\nUse map to check unique characters in the substrings generated by partitions."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Use Sliding Window Approach: \\n\\n You can start by initializing two pointers left and right to point to the first character in the string. Then, you can iterate over the string and do the following:\\n\\nIf the character at the right pointer is not in the current partition, add it to the partition and increment the right pointer.\\nIf the character at the right pointer is already in the current partition, update the left pointer to point to the next character after the last occurrence of the character in the current partition, and clear the current partition."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "[@cswartzell](/cswartzell) yes, at the very beginning, we set both \\'left\\' and \\'right\\' at the same place, in this case, the first character of the string, we initiate the answer variable as 1. Then, we let left hold its position while sliding right character by character to the right. Every time, we add one to the corresponding slot in the currency table(consisting of 26 slots, each of them is initiated as 0), according to the character the right pointer is pointing to(including the first position). When we get 2, we increment the answer variable, reset our table so that all slots are zero again, and move left to the position of right, and restart our process, until right has hit the end of the string."
                    },
                    {
                        "username": "cswartzell",
                        "content": "An interesting approach. How would you check if the character is in the current window? Iterate through the whole window each time you add a letter?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "bitmask can be used to check the duplicated letters to improve time and space consuming, pls refer to my c++ code:\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        int two_pow[26]; // prepare the mask value for the letter \\'a\\' to \\'z\\'\\n        for (int d = 0; d < 26; d++){\\n            if (d == 0) two_pow[d] = 1;\\n            else two_pow[d] = two_pow[d - 1] * 2;\\n        }\\n\\n        int sn = (int)s.size();\\n        int start = 0;\\n        int ret = 0;\\n        while(true){\\n            int mask = 0;\\n            int update_start = -1;\\n            for (int i = start; i < sn; i++){\\n                int letter = s[i] - \\'a\\';\\n                if ((two_pow[letter] & mask) == 0){// use bitmask to check whether s[i] is duplicated.\\n                    mask |= two_pow[letter];\\n                }\\n                else{\\n                    update_start = i;\\n                    ret++;\\n                    break;\\n                }                \\n            }\\n            if (update_start == -1) {\\n                ret += (bool)mask;\\n                break;\\n            }\\n            start = update_start;\\n        }\\n        return ret;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "alexeynazarov",
                        "content": "Explanation for the first example is a bit confusing (but not incorrect): partition for the greedy solution is (\"ab\",\"ac\",\"ab\",\"a\")."
                    },
                    {
                        "username": "14103263yash",
                        "content": "I think this note is wrong based on given example itself\\n`Note that each character should belong to exactly one substring in a partition.\\n`\\n"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I\\'m not too sure how to code this, but is it not possible to solve this issue using a sliding window, e.g.\\n\\n```python\\n    def partitionString(self, s: str) -> int:\\n        left = 0\\n        ans = 0\\n        char_set = set()\\n\\n        for right in range(len(s)):\\n            if s[right] in char_set:\\n                ans += 1 \\n                \\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n\\n            char_set.add(s[right])\\n\\n        return ans\\n```\\n\\nWhere the idea is we increment the sliding window for each unique subarray, and so increment our answer, and while that constraint is not met we shrink the size of the sliding window to find the next unique substring. Since the sliding window greedily takes the next greatest partition, shouldn\\'t we get the minimum number of substrings?"
                    }
                ]
            },
            {
                "id": 1746161,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "Just remember It\\'s SUBSTRING ..Not a SUBSEQUENCE!!!!!!!!!"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "How is this a medium question? \\uD83D\\uDE35"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "4 days in and the problems haven\\'t been very hard so far. I think Leetcode is gonna hit us suddenly with a Hard problem that involves trie"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use a hash table for those characters in the string. this problem can be solved!\nUse a hash table to store the occurrence place of each character in the string s. When the next substring begins, reset the hash table. Quite simple idea."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/optimal-partition-of-string/solutions/3376710/easy-c-solution-using-hash-table-a-for-loop/"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Start traversing string from left to right and get all the substrings having unique characters.\\nUse map to check unique characters in the substrings generated by partitions."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Use Sliding Window Approach: \\n\\n You can start by initializing two pointers left and right to point to the first character in the string. Then, you can iterate over the string and do the following:\\n\\nIf the character at the right pointer is not in the current partition, add it to the partition and increment the right pointer.\\nIf the character at the right pointer is already in the current partition, update the left pointer to point to the next character after the last occurrence of the character in the current partition, and clear the current partition."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "[@cswartzell](/cswartzell) yes, at the very beginning, we set both \\'left\\' and \\'right\\' at the same place, in this case, the first character of the string, we initiate the answer variable as 1. Then, we let left hold its position while sliding right character by character to the right. Every time, we add one to the corresponding slot in the currency table(consisting of 26 slots, each of them is initiated as 0), according to the character the right pointer is pointing to(including the first position). When we get 2, we increment the answer variable, reset our table so that all slots are zero again, and move left to the position of right, and restart our process, until right has hit the end of the string."
                    },
                    {
                        "username": "cswartzell",
                        "content": "An interesting approach. How would you check if the character is in the current window? Iterate through the whole window each time you add a letter?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "bitmask can be used to check the duplicated letters to improve time and space consuming, pls refer to my c++ code:\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        int two_pow[26]; // prepare the mask value for the letter \\'a\\' to \\'z\\'\\n        for (int d = 0; d < 26; d++){\\n            if (d == 0) two_pow[d] = 1;\\n            else two_pow[d] = two_pow[d - 1] * 2;\\n        }\\n\\n        int sn = (int)s.size();\\n        int start = 0;\\n        int ret = 0;\\n        while(true){\\n            int mask = 0;\\n            int update_start = -1;\\n            for (int i = start; i < sn; i++){\\n                int letter = s[i] - \\'a\\';\\n                if ((two_pow[letter] & mask) == 0){// use bitmask to check whether s[i] is duplicated.\\n                    mask |= two_pow[letter];\\n                }\\n                else{\\n                    update_start = i;\\n                    ret++;\\n                    break;\\n                }                \\n            }\\n            if (update_start == -1) {\\n                ret += (bool)mask;\\n                break;\\n            }\\n            start = update_start;\\n        }\\n        return ret;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "alexeynazarov",
                        "content": "Explanation for the first example is a bit confusing (but not incorrect): partition for the greedy solution is (\"ab\",\"ac\",\"ab\",\"a\")."
                    },
                    {
                        "username": "14103263yash",
                        "content": "I think this note is wrong based on given example itself\\n`Note that each character should belong to exactly one substring in a partition.\\n`\\n"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I\\'m not too sure how to code this, but is it not possible to solve this issue using a sliding window, e.g.\\n\\n```python\\n    def partitionString(self, s: str) -> int:\\n        left = 0\\n        ans = 0\\n        char_set = set()\\n\\n        for right in range(len(s)):\\n            if s[right] in char_set:\\n                ans += 1 \\n                \\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n\\n            char_set.add(s[right])\\n\\n        return ans\\n```\\n\\nWhere the idea is we increment the sliding window for each unique subarray, and so increment our answer, and while that constraint is not met we shrink the size of the sliding window to find the next unique substring. Since the sliding window greedily takes the next greatest partition, shouldn\\'t we get the minimum number of substrings?"
                    }
                ]
            },
            {
                "id": 1853144,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "Just remember It\\'s SUBSTRING ..Not a SUBSEQUENCE!!!!!!!!!"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "How is this a medium question? \\uD83D\\uDE35"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "4 days in and the problems haven\\'t been very hard so far. I think Leetcode is gonna hit us suddenly with a Hard problem that involves trie"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use a hash table for those characters in the string. this problem can be solved!\nUse a hash table to store the occurrence place of each character in the string s. When the next substring begins, reset the hash table. Quite simple idea."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/optimal-partition-of-string/solutions/3376710/easy-c-solution-using-hash-table-a-for-loop/"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Start traversing string from left to right and get all the substrings having unique characters.\\nUse map to check unique characters in the substrings generated by partitions."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Use Sliding Window Approach: \\n\\n You can start by initializing two pointers left and right to point to the first character in the string. Then, you can iterate over the string and do the following:\\n\\nIf the character at the right pointer is not in the current partition, add it to the partition and increment the right pointer.\\nIf the character at the right pointer is already in the current partition, update the left pointer to point to the next character after the last occurrence of the character in the current partition, and clear the current partition."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "[@cswartzell](/cswartzell) yes, at the very beginning, we set both \\'left\\' and \\'right\\' at the same place, in this case, the first character of the string, we initiate the answer variable as 1. Then, we let left hold its position while sliding right character by character to the right. Every time, we add one to the corresponding slot in the currency table(consisting of 26 slots, each of them is initiated as 0), according to the character the right pointer is pointing to(including the first position). When we get 2, we increment the answer variable, reset our table so that all slots are zero again, and move left to the position of right, and restart our process, until right has hit the end of the string."
                    },
                    {
                        "username": "cswartzell",
                        "content": "An interesting approach. How would you check if the character is in the current window? Iterate through the whole window each time you add a letter?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "bitmask can be used to check the duplicated letters to improve time and space consuming, pls refer to my c++ code:\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        int two_pow[26]; // prepare the mask value for the letter \\'a\\' to \\'z\\'\\n        for (int d = 0; d < 26; d++){\\n            if (d == 0) two_pow[d] = 1;\\n            else two_pow[d] = two_pow[d - 1] * 2;\\n        }\\n\\n        int sn = (int)s.size();\\n        int start = 0;\\n        int ret = 0;\\n        while(true){\\n            int mask = 0;\\n            int update_start = -1;\\n            for (int i = start; i < sn; i++){\\n                int letter = s[i] - \\'a\\';\\n                if ((two_pow[letter] & mask) == 0){// use bitmask to check whether s[i] is duplicated.\\n                    mask |= two_pow[letter];\\n                }\\n                else{\\n                    update_start = i;\\n                    ret++;\\n                    break;\\n                }                \\n            }\\n            if (update_start == -1) {\\n                ret += (bool)mask;\\n                break;\\n            }\\n            start = update_start;\\n        }\\n        return ret;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "alexeynazarov",
                        "content": "Explanation for the first example is a bit confusing (but not incorrect): partition for the greedy solution is (\"ab\",\"ac\",\"ab\",\"a\")."
                    },
                    {
                        "username": "14103263yash",
                        "content": "I think this note is wrong based on given example itself\\n`Note that each character should belong to exactly one substring in a partition.\\n`\\n"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I\\'m not too sure how to code this, but is it not possible to solve this issue using a sliding window, e.g.\\n\\n```python\\n    def partitionString(self, s: str) -> int:\\n        left = 0\\n        ans = 0\\n        char_set = set()\\n\\n        for right in range(len(s)):\\n            if s[right] in char_set:\\n                ans += 1 \\n                \\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n\\n            char_set.add(s[right])\\n\\n        return ans\\n```\\n\\nWhere the idea is we increment the sliding window for each unique subarray, and so increment our answer, and while that constraint is not met we shrink the size of the sliding window to find the next unique substring. Since the sliding window greedily takes the next greatest partition, shouldn\\'t we get the minimum number of substrings?"
                    }
                ]
            },
            {
                "id": 2071033,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "Just remember It\\'s SUBSTRING ..Not a SUBSEQUENCE!!!!!!!!!"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "How is this a medium question? \\uD83D\\uDE35"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "4 days in and the problems haven\\'t been very hard so far. I think Leetcode is gonna hit us suddenly with a Hard problem that involves trie"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use a hash table for those characters in the string. this problem can be solved!\nUse a hash table to store the occurrence place of each character in the string s. When the next substring begins, reset the hash table. Quite simple idea."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/optimal-partition-of-string/solutions/3376710/easy-c-solution-using-hash-table-a-for-loop/"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Start traversing string from left to right and get all the substrings having unique characters.\\nUse map to check unique characters in the substrings generated by partitions."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Use Sliding Window Approach: \\n\\n You can start by initializing two pointers left and right to point to the first character in the string. Then, you can iterate over the string and do the following:\\n\\nIf the character at the right pointer is not in the current partition, add it to the partition and increment the right pointer.\\nIf the character at the right pointer is already in the current partition, update the left pointer to point to the next character after the last occurrence of the character in the current partition, and clear the current partition."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "[@cswartzell](/cswartzell) yes, at the very beginning, we set both \\'left\\' and \\'right\\' at the same place, in this case, the first character of the string, we initiate the answer variable as 1. Then, we let left hold its position while sliding right character by character to the right. Every time, we add one to the corresponding slot in the currency table(consisting of 26 slots, each of them is initiated as 0), according to the character the right pointer is pointing to(including the first position). When we get 2, we increment the answer variable, reset our table so that all slots are zero again, and move left to the position of right, and restart our process, until right has hit the end of the string."
                    },
                    {
                        "username": "cswartzell",
                        "content": "An interesting approach. How would you check if the character is in the current window? Iterate through the whole window each time you add a letter?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "bitmask can be used to check the duplicated letters to improve time and space consuming, pls refer to my c++ code:\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        int two_pow[26]; // prepare the mask value for the letter \\'a\\' to \\'z\\'\\n        for (int d = 0; d < 26; d++){\\n            if (d == 0) two_pow[d] = 1;\\n            else two_pow[d] = two_pow[d - 1] * 2;\\n        }\\n\\n        int sn = (int)s.size();\\n        int start = 0;\\n        int ret = 0;\\n        while(true){\\n            int mask = 0;\\n            int update_start = -1;\\n            for (int i = start; i < sn; i++){\\n                int letter = s[i] - \\'a\\';\\n                if ((two_pow[letter] & mask) == 0){// use bitmask to check whether s[i] is duplicated.\\n                    mask |= two_pow[letter];\\n                }\\n                else{\\n                    update_start = i;\\n                    ret++;\\n                    break;\\n                }                \\n            }\\n            if (update_start == -1) {\\n                ret += (bool)mask;\\n                break;\\n            }\\n            start = update_start;\\n        }\\n        return ret;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "alexeynazarov",
                        "content": "Explanation for the first example is a bit confusing (but not incorrect): partition for the greedy solution is (\"ab\",\"ac\",\"ab\",\"a\")."
                    },
                    {
                        "username": "14103263yash",
                        "content": "I think this note is wrong based on given example itself\\n`Note that each character should belong to exactly one substring in a partition.\\n`\\n"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I\\'m not too sure how to code this, but is it not possible to solve this issue using a sliding window, e.g.\\n\\n```python\\n    def partitionString(self, s: str) -> int:\\n        left = 0\\n        ans = 0\\n        char_set = set()\\n\\n        for right in range(len(s)):\\n            if s[right] in char_set:\\n                ans += 1 \\n                \\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n\\n            char_set.add(s[right])\\n\\n        return ans\\n```\\n\\nWhere the idea is we increment the sliding window for each unique subarray, and so increment our answer, and while that constraint is not met we shrink the size of the sliding window to find the next unique substring. Since the sliding window greedily takes the next greatest partition, shouldn\\'t we get the minimum number of substrings?"
                    }
                ]
            },
            {
                "id": 2070066,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "Just remember It\\'s SUBSTRING ..Not a SUBSEQUENCE!!!!!!!!!"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "How is this a medium question? \\uD83D\\uDE35"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "4 days in and the problems haven\\'t been very hard so far. I think Leetcode is gonna hit us suddenly with a Hard problem that involves trie"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use a hash table for those characters in the string. this problem can be solved!\nUse a hash table to store the occurrence place of each character in the string s. When the next substring begins, reset the hash table. Quite simple idea."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/optimal-partition-of-string/solutions/3376710/easy-c-solution-using-hash-table-a-for-loop/"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Start traversing string from left to right and get all the substrings having unique characters.\\nUse map to check unique characters in the substrings generated by partitions."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Use Sliding Window Approach: \\n\\n You can start by initializing two pointers left and right to point to the first character in the string. Then, you can iterate over the string and do the following:\\n\\nIf the character at the right pointer is not in the current partition, add it to the partition and increment the right pointer.\\nIf the character at the right pointer is already in the current partition, update the left pointer to point to the next character after the last occurrence of the character in the current partition, and clear the current partition."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "[@cswartzell](/cswartzell) yes, at the very beginning, we set both \\'left\\' and \\'right\\' at the same place, in this case, the first character of the string, we initiate the answer variable as 1. Then, we let left hold its position while sliding right character by character to the right. Every time, we add one to the corresponding slot in the currency table(consisting of 26 slots, each of them is initiated as 0), according to the character the right pointer is pointing to(including the first position). When we get 2, we increment the answer variable, reset our table so that all slots are zero again, and move left to the position of right, and restart our process, until right has hit the end of the string."
                    },
                    {
                        "username": "cswartzell",
                        "content": "An interesting approach. How would you check if the character is in the current window? Iterate through the whole window each time you add a letter?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "bitmask can be used to check the duplicated letters to improve time and space consuming, pls refer to my c++ code:\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        int two_pow[26]; // prepare the mask value for the letter \\'a\\' to \\'z\\'\\n        for (int d = 0; d < 26; d++){\\n            if (d == 0) two_pow[d] = 1;\\n            else two_pow[d] = two_pow[d - 1] * 2;\\n        }\\n\\n        int sn = (int)s.size();\\n        int start = 0;\\n        int ret = 0;\\n        while(true){\\n            int mask = 0;\\n            int update_start = -1;\\n            for (int i = start; i < sn; i++){\\n                int letter = s[i] - \\'a\\';\\n                if ((two_pow[letter] & mask) == 0){// use bitmask to check whether s[i] is duplicated.\\n                    mask |= two_pow[letter];\\n                }\\n                else{\\n                    update_start = i;\\n                    ret++;\\n                    break;\\n                }                \\n            }\\n            if (update_start == -1) {\\n                ret += (bool)mask;\\n                break;\\n            }\\n            start = update_start;\\n        }\\n        return ret;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "alexeynazarov",
                        "content": "Explanation for the first example is a bit confusing (but not incorrect): partition for the greedy solution is (\"ab\",\"ac\",\"ab\",\"a\")."
                    },
                    {
                        "username": "14103263yash",
                        "content": "I think this note is wrong based on given example itself\\n`Note that each character should belong to exactly one substring in a partition.\\n`\\n"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I\\'m not too sure how to code this, but is it not possible to solve this issue using a sliding window, e.g.\\n\\n```python\\n    def partitionString(self, s: str) -> int:\\n        left = 0\\n        ans = 0\\n        char_set = set()\\n\\n        for right in range(len(s)):\\n            if s[right] in char_set:\\n                ans += 1 \\n                \\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n\\n            char_set.add(s[right])\\n\\n        return ans\\n```\\n\\nWhere the idea is we increment the sliding window for each unique subarray, and so increment our answer, and while that constraint is not met we shrink the size of the sliding window to find the next unique substring. Since the sliding window greedily takes the next greatest partition, shouldn\\'t we get the minimum number of substrings?"
                    }
                ]
            },
            {
                "id": 2053323,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "Just remember It\\'s SUBSTRING ..Not a SUBSEQUENCE!!!!!!!!!"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "How is this a medium question? \\uD83D\\uDE35"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "4 days in and the problems haven\\'t been very hard so far. I think Leetcode is gonna hit us suddenly with a Hard problem that involves trie"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use a hash table for those characters in the string. this problem can be solved!\nUse a hash table to store the occurrence place of each character in the string s. When the next substring begins, reset the hash table. Quite simple idea."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/optimal-partition-of-string/solutions/3376710/easy-c-solution-using-hash-table-a-for-loop/"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Start traversing string from left to right and get all the substrings having unique characters.\\nUse map to check unique characters in the substrings generated by partitions."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Use Sliding Window Approach: \\n\\n You can start by initializing two pointers left and right to point to the first character in the string. Then, you can iterate over the string and do the following:\\n\\nIf the character at the right pointer is not in the current partition, add it to the partition and increment the right pointer.\\nIf the character at the right pointer is already in the current partition, update the left pointer to point to the next character after the last occurrence of the character in the current partition, and clear the current partition."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "[@cswartzell](/cswartzell) yes, at the very beginning, we set both \\'left\\' and \\'right\\' at the same place, in this case, the first character of the string, we initiate the answer variable as 1. Then, we let left hold its position while sliding right character by character to the right. Every time, we add one to the corresponding slot in the currency table(consisting of 26 slots, each of them is initiated as 0), according to the character the right pointer is pointing to(including the first position). When we get 2, we increment the answer variable, reset our table so that all slots are zero again, and move left to the position of right, and restart our process, until right has hit the end of the string."
                    },
                    {
                        "username": "cswartzell",
                        "content": "An interesting approach. How would you check if the character is in the current window? Iterate through the whole window each time you add a letter?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "bitmask can be used to check the duplicated letters to improve time and space consuming, pls refer to my c++ code:\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        \\n        int two_pow[26]; // prepare the mask value for the letter \\'a\\' to \\'z\\'\\n        for (int d = 0; d < 26; d++){\\n            if (d == 0) two_pow[d] = 1;\\n            else two_pow[d] = two_pow[d - 1] * 2;\\n        }\\n\\n        int sn = (int)s.size();\\n        int start = 0;\\n        int ret = 0;\\n        while(true){\\n            int mask = 0;\\n            int update_start = -1;\\n            for (int i = start; i < sn; i++){\\n                int letter = s[i] - \\'a\\';\\n                if ((two_pow[letter] & mask) == 0){// use bitmask to check whether s[i] is duplicated.\\n                    mask |= two_pow[letter];\\n                }\\n                else{\\n                    update_start = i;\\n                    ret++;\\n                    break;\\n                }                \\n            }\\n            if (update_start == -1) {\\n                ret += (bool)mask;\\n                break;\\n            }\\n            start = update_start;\\n        }\\n        return ret;\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "alexeynazarov",
                        "content": "Explanation for the first example is a bit confusing (but not incorrect): partition for the greedy solution is (\"ab\",\"ac\",\"ab\",\"a\")."
                    },
                    {
                        "username": "14103263yash",
                        "content": "I think this note is wrong based on given example itself\\n`Note that each character should belong to exactly one substring in a partition.\\n`\\n"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I\\'m not too sure how to code this, but is it not possible to solve this issue using a sliding window, e.g.\\n\\n```python\\n    def partitionString(self, s: str) -> int:\\n        left = 0\\n        ans = 0\\n        char_set = set()\\n\\n        for right in range(len(s)):\\n            if s[right] in char_set:\\n                ans += 1 \\n                \\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n\\n            char_set.add(s[right])\\n\\n        return ans\\n```\\n\\nWhere the idea is we increment the sliding window for each unique subarray, and so increment our answer, and while that constraint is not met we shrink the size of the sliding window to find the next unique substring. Since the sliding window greedily takes the next greatest partition, shouldn\\'t we get the minimum number of substrings?"
                    }
                ]
            },
            {
                "id": 2038177,
                "content": [
                    {
                        "username": "Lone_007",
                        "content": "Easy one but to solve this you need to have knowledge of set data structure. Overall it is a good question."
                    },
                    {
                        "username": "gokulraamofficial",
                        "content": "Another episode of \"easy level questions tagged medium\""
                    },
                    {
                        "username": "rahulroy74",
                        "content": "How does\ns = \"hdklqkcssgxlvehva\" gives output as 4\ni could easily create 2 substring with all unique characters in it as:\nhdklqseav\nkcsgxlvh"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Would have been more interesting if all the sub-strings are checked for uniqueness across and within."
                    },
                    {
                        "username": "ssmatt",
                        "content": "Seems like they just want to bait people into buying leetcode premium by making the two amazon sample questions very easy and labelling them \"medium\""
                    },
                    {
                        "username": "jdc711",
                        "content": "Can someone help me understand the proof behind why the greedy approach works?"
                    },
                    {
                        "username": "marco_seven",
                        "content": "how is this possible, how can i solved this question , something is wrong with this question , it this question really from Amazon Spring \\'23 High Frequency"
                    },
                    {
                        "username": "agr__rachit",
                        "content": "I can\\'t understand why it is not a easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "a good one to get a hang on applications of set with string"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can\\'t it  be solved using set"
                    }
                ]
            },
            {
                "id": 2017885,
                "content": [
                    {
                        "username": "Lone_007",
                        "content": "Easy one but to solve this you need to have knowledge of set data structure. Overall it is a good question."
                    },
                    {
                        "username": "gokulraamofficial",
                        "content": "Another episode of \"easy level questions tagged medium\""
                    },
                    {
                        "username": "rahulroy74",
                        "content": "How does\ns = \"hdklqkcssgxlvehva\" gives output as 4\ni could easily create 2 substring with all unique characters in it as:\nhdklqseav\nkcsgxlvh"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Would have been more interesting if all the sub-strings are checked for uniqueness across and within."
                    },
                    {
                        "username": "ssmatt",
                        "content": "Seems like they just want to bait people into buying leetcode premium by making the two amazon sample questions very easy and labelling them \"medium\""
                    },
                    {
                        "username": "jdc711",
                        "content": "Can someone help me understand the proof behind why the greedy approach works?"
                    },
                    {
                        "username": "marco_seven",
                        "content": "how is this possible, how can i solved this question , something is wrong with this question , it this question really from Amazon Spring \\'23 High Frequency"
                    },
                    {
                        "username": "agr__rachit",
                        "content": "I can\\'t understand why it is not a easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "a good one to get a hang on applications of set with string"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can\\'t it  be solved using set"
                    }
                ]
            },
            {
                "id": 1999739,
                "content": [
                    {
                        "username": "Lone_007",
                        "content": "Easy one but to solve this you need to have knowledge of set data structure. Overall it is a good question."
                    },
                    {
                        "username": "gokulraamofficial",
                        "content": "Another episode of \"easy level questions tagged medium\""
                    },
                    {
                        "username": "rahulroy74",
                        "content": "How does\ns = \"hdklqkcssgxlvehva\" gives output as 4\ni could easily create 2 substring with all unique characters in it as:\nhdklqseav\nkcsgxlvh"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Would have been more interesting if all the sub-strings are checked for uniqueness across and within."
                    },
                    {
                        "username": "ssmatt",
                        "content": "Seems like they just want to bait people into buying leetcode premium by making the two amazon sample questions very easy and labelling them \"medium\""
                    },
                    {
                        "username": "jdc711",
                        "content": "Can someone help me understand the proof behind why the greedy approach works?"
                    },
                    {
                        "username": "marco_seven",
                        "content": "how is this possible, how can i solved this question , something is wrong with this question , it this question really from Amazon Spring \\'23 High Frequency"
                    },
                    {
                        "username": "agr__rachit",
                        "content": "I can\\'t understand why it is not a easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "a good one to get a hang on applications of set with string"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can\\'t it  be solved using set"
                    }
                ]
            },
            {
                "id": 1998987,
                "content": [
                    {
                        "username": "Lone_007",
                        "content": "Easy one but to solve this you need to have knowledge of set data structure. Overall it is a good question."
                    },
                    {
                        "username": "gokulraamofficial",
                        "content": "Another episode of \"easy level questions tagged medium\""
                    },
                    {
                        "username": "rahulroy74",
                        "content": "How does\ns = \"hdklqkcssgxlvehva\" gives output as 4\ni could easily create 2 substring with all unique characters in it as:\nhdklqseav\nkcsgxlvh"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Would have been more interesting if all the sub-strings are checked for uniqueness across and within."
                    },
                    {
                        "username": "ssmatt",
                        "content": "Seems like they just want to bait people into buying leetcode premium by making the two amazon sample questions very easy and labelling them \"medium\""
                    },
                    {
                        "username": "jdc711",
                        "content": "Can someone help me understand the proof behind why the greedy approach works?"
                    },
                    {
                        "username": "marco_seven",
                        "content": "how is this possible, how can i solved this question , something is wrong with this question , it this question really from Amazon Spring \\'23 High Frequency"
                    },
                    {
                        "username": "agr__rachit",
                        "content": "I can\\'t understand why it is not a easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "a good one to get a hang on applications of set with string"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can\\'t it  be solved using set"
                    }
                ]
            },
            {
                "id": 1968491,
                "content": [
                    {
                        "username": "Lone_007",
                        "content": "Easy one but to solve this you need to have knowledge of set data structure. Overall it is a good question."
                    },
                    {
                        "username": "gokulraamofficial",
                        "content": "Another episode of \"easy level questions tagged medium\""
                    },
                    {
                        "username": "rahulroy74",
                        "content": "How does\ns = \"hdklqkcssgxlvehva\" gives output as 4\ni could easily create 2 substring with all unique characters in it as:\nhdklqseav\nkcsgxlvh"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Would have been more interesting if all the sub-strings are checked for uniqueness across and within."
                    },
                    {
                        "username": "ssmatt",
                        "content": "Seems like they just want to bait people into buying leetcode premium by making the two amazon sample questions very easy and labelling them \"medium\""
                    },
                    {
                        "username": "jdc711",
                        "content": "Can someone help me understand the proof behind why the greedy approach works?"
                    },
                    {
                        "username": "marco_seven",
                        "content": "how is this possible, how can i solved this question , something is wrong with this question , it this question really from Amazon Spring \\'23 High Frequency"
                    },
                    {
                        "username": "agr__rachit",
                        "content": "I can\\'t understand why it is not a easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "a good one to get a hang on applications of set with string"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can\\'t it  be solved using set"
                    }
                ]
            },
            {
                "id": 1955465,
                "content": [
                    {
                        "username": "Lone_007",
                        "content": "Easy one but to solve this you need to have knowledge of set data structure. Overall it is a good question."
                    },
                    {
                        "username": "gokulraamofficial",
                        "content": "Another episode of \"easy level questions tagged medium\""
                    },
                    {
                        "username": "rahulroy74",
                        "content": "How does\ns = \"hdklqkcssgxlvehva\" gives output as 4\ni could easily create 2 substring with all unique characters in it as:\nhdklqseav\nkcsgxlvh"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Would have been more interesting if all the sub-strings are checked for uniqueness across and within."
                    },
                    {
                        "username": "ssmatt",
                        "content": "Seems like they just want to bait people into buying leetcode premium by making the two amazon sample questions very easy and labelling them \"medium\""
                    },
                    {
                        "username": "jdc711",
                        "content": "Can someone help me understand the proof behind why the greedy approach works?"
                    },
                    {
                        "username": "marco_seven",
                        "content": "how is this possible, how can i solved this question , something is wrong with this question , it this question really from Amazon Spring \\'23 High Frequency"
                    },
                    {
                        "username": "agr__rachit",
                        "content": "I can\\'t understand why it is not a easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "a good one to get a hang on applications of set with string"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can\\'t it  be solved using set"
                    }
                ]
            },
            {
                "id": 1941574,
                "content": [
                    {
                        "username": "Lone_007",
                        "content": "Easy one but to solve this you need to have knowledge of set data structure. Overall it is a good question."
                    },
                    {
                        "username": "gokulraamofficial",
                        "content": "Another episode of \"easy level questions tagged medium\""
                    },
                    {
                        "username": "rahulroy74",
                        "content": "How does\ns = \"hdklqkcssgxlvehva\" gives output as 4\ni could easily create 2 substring with all unique characters in it as:\nhdklqseav\nkcsgxlvh"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Would have been more interesting if all the sub-strings are checked for uniqueness across and within."
                    },
                    {
                        "username": "ssmatt",
                        "content": "Seems like they just want to bait people into buying leetcode premium by making the two amazon sample questions very easy and labelling them \"medium\""
                    },
                    {
                        "username": "jdc711",
                        "content": "Can someone help me understand the proof behind why the greedy approach works?"
                    },
                    {
                        "username": "marco_seven",
                        "content": "how is this possible, how can i solved this question , something is wrong with this question , it this question really from Amazon Spring \\'23 High Frequency"
                    },
                    {
                        "username": "agr__rachit",
                        "content": "I can\\'t understand why it is not a easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "a good one to get a hang on applications of set with string"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can\\'t it  be solved using set"
                    }
                ]
            },
            {
                "id": 1856545,
                "content": [
                    {
                        "username": "Lone_007",
                        "content": "Easy one but to solve this you need to have knowledge of set data structure. Overall it is a good question."
                    },
                    {
                        "username": "gokulraamofficial",
                        "content": "Another episode of \"easy level questions tagged medium\""
                    },
                    {
                        "username": "rahulroy74",
                        "content": "How does\ns = \"hdklqkcssgxlvehva\" gives output as 4\ni could easily create 2 substring with all unique characters in it as:\nhdklqseav\nkcsgxlvh"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Would have been more interesting if all the sub-strings are checked for uniqueness across and within."
                    },
                    {
                        "username": "ssmatt",
                        "content": "Seems like they just want to bait people into buying leetcode premium by making the two amazon sample questions very easy and labelling them \"medium\""
                    },
                    {
                        "username": "jdc711",
                        "content": "Can someone help me understand the proof behind why the greedy approach works?"
                    },
                    {
                        "username": "marco_seven",
                        "content": "how is this possible, how can i solved this question , something is wrong with this question , it this question really from Amazon Spring \\'23 High Frequency"
                    },
                    {
                        "username": "agr__rachit",
                        "content": "I can\\'t understand why it is not a easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "a good one to get a hang on applications of set with string"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can\\'t it  be solved using set"
                    }
                ]
            },
            {
                "id": 1854822,
                "content": [
                    {
                        "username": "Lone_007",
                        "content": "Easy one but to solve this you need to have knowledge of set data structure. Overall it is a good question."
                    },
                    {
                        "username": "gokulraamofficial",
                        "content": "Another episode of \"easy level questions tagged medium\""
                    },
                    {
                        "username": "rahulroy74",
                        "content": "How does\ns = \"hdklqkcssgxlvehva\" gives output as 4\ni could easily create 2 substring with all unique characters in it as:\nhdklqseav\nkcsgxlvh"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Would have been more interesting if all the sub-strings are checked for uniqueness across and within."
                    },
                    {
                        "username": "ssmatt",
                        "content": "Seems like they just want to bait people into buying leetcode premium by making the two amazon sample questions very easy and labelling them \"medium\""
                    },
                    {
                        "username": "jdc711",
                        "content": "Can someone help me understand the proof behind why the greedy approach works?"
                    },
                    {
                        "username": "marco_seven",
                        "content": "how is this possible, how can i solved this question , something is wrong with this question , it this question really from Amazon Spring \\'23 High Frequency"
                    },
                    {
                        "username": "agr__rachit",
                        "content": "I can\\'t understand why it is not a easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "a good one to get a hang on applications of set with string"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can\\'t it  be solved using set"
                    }
                ]
            },
            {
                "id": 1854821,
                "content": [
                    {
                        "username": "Lone_007",
                        "content": "Easy one but to solve this you need to have knowledge of set data structure. Overall it is a good question."
                    },
                    {
                        "username": "gokulraamofficial",
                        "content": "Another episode of \"easy level questions tagged medium\""
                    },
                    {
                        "username": "rahulroy74",
                        "content": "How does\ns = \"hdklqkcssgxlvehva\" gives output as 4\ni could easily create 2 substring with all unique characters in it as:\nhdklqseav\nkcsgxlvh"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Would have been more interesting if all the sub-strings are checked for uniqueness across and within."
                    },
                    {
                        "username": "ssmatt",
                        "content": "Seems like they just want to bait people into buying leetcode premium by making the two amazon sample questions very easy and labelling them \"medium\""
                    },
                    {
                        "username": "jdc711",
                        "content": "Can someone help me understand the proof behind why the greedy approach works?"
                    },
                    {
                        "username": "marco_seven",
                        "content": "how is this possible, how can i solved this question , something is wrong with this question , it this question really from Amazon Spring \\'23 High Frequency"
                    },
                    {
                        "username": "agr__rachit",
                        "content": "I can\\'t understand why it is not a easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "a good one to get a hang on applications of set with string"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can\\'t it  be solved using set"
                    }
                ]
            },
            {
                "id": 1854066,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Hint : take a unordered_set<char>st,\\nthen loop through the each char of the string s\\nif you see the s[i] is not in the set then insert it ,else increment your ans by 1 , clear the set and insert the current s[i] at last return the ans(ans is a variable initialize with 0)"
                    },
                    {
                        "username": "amaan7",
                        "content": "Guys i am able to come up correct approach but i am not able to code it , what should i do i am very much tensed !!! someone pls help (not talking of just this question had this issue with many many questions ) "
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": " let hash = new Set();\\n    console.log(s);\\n    let count = 1;\\n    if(s.trim().length == 0 || s == null){\\n        return 0;\\n    }\\n    for(let i = 0; i < s.length; i++){\\n        if(hash.has(s[i]) == false){\\n            hash.add(s[i]);\\n            console.log(hash);\\n        }else{\\n            hash = new Set();\\n            count +=1;\\n            i--;\\n        }\\n    }\\n    return count;     js Days....\\n"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This question would be Medium if the substrings may not be contiguous. In this case some extra backtracking would be needed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Looks like another sort of packing problem. Is it bin-packing week? Would be cool, I know nothing about it.\\nOr is it greedy week? Would also be nice, I\\'m not good at proving that greedy solutions work in more involved problems\\nHmm, what do you guys think, what is the theme of this week?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "I think two pointer approach would work here as well "
                    },
                    {
                        "username": "eduard92",
                        "content": "Ok guys I am on the daily challenge train. I honestly don\\'t know how I solved this question, I followed comments around here and it worked whatever I did.\\n\\nI started to overthink using two pointers and then save the substrings in a hashset and then return the count of that hashset.\\nBut then I read some comments and I don\\'t know why counting characters works when there already exists in the hashset. Maybe I mix up in my head that substrings should be unique? Or I mix up with all possible substring combinations of a string.. God damn it I watched at too many videos with DP and Sliding Window, now I see them everywhere.\\n\\nI can\\'t make the correlation in my head how I determine `\"ab\",\"a\",\"ca\",\"ba\"` results by counting characters. I think before clearing the hash in my code I am gonna add in a list whatever I have in the hash and look into values with the debugger in vscode.\\n\\nHere is the code:\\n\\n \\n            var hash = new HashSet<char>();\\n            var count = 1;\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                if (hash.Contains(s[i]))\\n                {\\n                    count++;\\n                    hash.Clear();\\n                    hash.Add(s[i]);\\n                }\\n                else\\n                {\\n                    hash.Add(s[i]);\\n                }\\n            }\\n\\n            return count;"
                    },
                    {
                        "username": "pj1999",
                        "content": "Both greedy and dp solutions got accepted..."
                    },
                    {
                        "username": "sushi27",
                        "content": "looks like leetcode going easy on us for two days"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "this has to be marked as very easy\\n"
                    }
                ]
            },
            {
                "id": 1853915,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Hint : take a unordered_set<char>st,\\nthen loop through the each char of the string s\\nif you see the s[i] is not in the set then insert it ,else increment your ans by 1 , clear the set and insert the current s[i] at last return the ans(ans is a variable initialize with 0)"
                    },
                    {
                        "username": "amaan7",
                        "content": "Guys i am able to come up correct approach but i am not able to code it , what should i do i am very much tensed !!! someone pls help (not talking of just this question had this issue with many many questions ) "
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": " let hash = new Set();\\n    console.log(s);\\n    let count = 1;\\n    if(s.trim().length == 0 || s == null){\\n        return 0;\\n    }\\n    for(let i = 0; i < s.length; i++){\\n        if(hash.has(s[i]) == false){\\n            hash.add(s[i]);\\n            console.log(hash);\\n        }else{\\n            hash = new Set();\\n            count +=1;\\n            i--;\\n        }\\n    }\\n    return count;     js Days....\\n"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This question would be Medium if the substrings may not be contiguous. In this case some extra backtracking would be needed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Looks like another sort of packing problem. Is it bin-packing week? Would be cool, I know nothing about it.\\nOr is it greedy week? Would also be nice, I\\'m not good at proving that greedy solutions work in more involved problems\\nHmm, what do you guys think, what is the theme of this week?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "I think two pointer approach would work here as well "
                    },
                    {
                        "username": "eduard92",
                        "content": "Ok guys I am on the daily challenge train. I honestly don\\'t know how I solved this question, I followed comments around here and it worked whatever I did.\\n\\nI started to overthink using two pointers and then save the substrings in a hashset and then return the count of that hashset.\\nBut then I read some comments and I don\\'t know why counting characters works when there already exists in the hashset. Maybe I mix up in my head that substrings should be unique? Or I mix up with all possible substring combinations of a string.. God damn it I watched at too many videos with DP and Sliding Window, now I see them everywhere.\\n\\nI can\\'t make the correlation in my head how I determine `\"ab\",\"a\",\"ca\",\"ba\"` results by counting characters. I think before clearing the hash in my code I am gonna add in a list whatever I have in the hash and look into values with the debugger in vscode.\\n\\nHere is the code:\\n\\n \\n            var hash = new HashSet<char>();\\n            var count = 1;\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                if (hash.Contains(s[i]))\\n                {\\n                    count++;\\n                    hash.Clear();\\n                    hash.Add(s[i]);\\n                }\\n                else\\n                {\\n                    hash.Add(s[i]);\\n                }\\n            }\\n\\n            return count;"
                    },
                    {
                        "username": "pj1999",
                        "content": "Both greedy and dp solutions got accepted..."
                    },
                    {
                        "username": "sushi27",
                        "content": "looks like leetcode going easy on us for two days"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "this has to be marked as very easy\\n"
                    }
                ]
            },
            {
                "id": 1853907,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Hint : take a unordered_set<char>st,\\nthen loop through the each char of the string s\\nif you see the s[i] is not in the set then insert it ,else increment your ans by 1 , clear the set and insert the current s[i] at last return the ans(ans is a variable initialize with 0)"
                    },
                    {
                        "username": "amaan7",
                        "content": "Guys i am able to come up correct approach but i am not able to code it , what should i do i am very much tensed !!! someone pls help (not talking of just this question had this issue with many many questions ) "
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": " let hash = new Set();\\n    console.log(s);\\n    let count = 1;\\n    if(s.trim().length == 0 || s == null){\\n        return 0;\\n    }\\n    for(let i = 0; i < s.length; i++){\\n        if(hash.has(s[i]) == false){\\n            hash.add(s[i]);\\n            console.log(hash);\\n        }else{\\n            hash = new Set();\\n            count +=1;\\n            i--;\\n        }\\n    }\\n    return count;     js Days....\\n"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This question would be Medium if the substrings may not be contiguous. In this case some extra backtracking would be needed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Looks like another sort of packing problem. Is it bin-packing week? Would be cool, I know nothing about it.\\nOr is it greedy week? Would also be nice, I\\'m not good at proving that greedy solutions work in more involved problems\\nHmm, what do you guys think, what is the theme of this week?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "I think two pointer approach would work here as well "
                    },
                    {
                        "username": "eduard92",
                        "content": "Ok guys I am on the daily challenge train. I honestly don\\'t know how I solved this question, I followed comments around here and it worked whatever I did.\\n\\nI started to overthink using two pointers and then save the substrings in a hashset and then return the count of that hashset.\\nBut then I read some comments and I don\\'t know why counting characters works when there already exists in the hashset. Maybe I mix up in my head that substrings should be unique? Or I mix up with all possible substring combinations of a string.. God damn it I watched at too many videos with DP and Sliding Window, now I see them everywhere.\\n\\nI can\\'t make the correlation in my head how I determine `\"ab\",\"a\",\"ca\",\"ba\"` results by counting characters. I think before clearing the hash in my code I am gonna add in a list whatever I have in the hash and look into values with the debugger in vscode.\\n\\nHere is the code:\\n\\n \\n            var hash = new HashSet<char>();\\n            var count = 1;\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                if (hash.Contains(s[i]))\\n                {\\n                    count++;\\n                    hash.Clear();\\n                    hash.Add(s[i]);\\n                }\\n                else\\n                {\\n                    hash.Add(s[i]);\\n                }\\n            }\\n\\n            return count;"
                    },
                    {
                        "username": "pj1999",
                        "content": "Both greedy and dp solutions got accepted..."
                    },
                    {
                        "username": "sushi27",
                        "content": "looks like leetcode going easy on us for two days"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "this has to be marked as very easy\\n"
                    }
                ]
            },
            {
                "id": 1853838,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Hint : take a unordered_set<char>st,\\nthen loop through the each char of the string s\\nif you see the s[i] is not in the set then insert it ,else increment your ans by 1 , clear the set and insert the current s[i] at last return the ans(ans is a variable initialize with 0)"
                    },
                    {
                        "username": "amaan7",
                        "content": "Guys i am able to come up correct approach but i am not able to code it , what should i do i am very much tensed !!! someone pls help (not talking of just this question had this issue with many many questions ) "
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": " let hash = new Set();\\n    console.log(s);\\n    let count = 1;\\n    if(s.trim().length == 0 || s == null){\\n        return 0;\\n    }\\n    for(let i = 0; i < s.length; i++){\\n        if(hash.has(s[i]) == false){\\n            hash.add(s[i]);\\n            console.log(hash);\\n        }else{\\n            hash = new Set();\\n            count +=1;\\n            i--;\\n        }\\n    }\\n    return count;     js Days....\\n"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This question would be Medium if the substrings may not be contiguous. In this case some extra backtracking would be needed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Looks like another sort of packing problem. Is it bin-packing week? Would be cool, I know nothing about it.\\nOr is it greedy week? Would also be nice, I\\'m not good at proving that greedy solutions work in more involved problems\\nHmm, what do you guys think, what is the theme of this week?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "I think two pointer approach would work here as well "
                    },
                    {
                        "username": "eduard92",
                        "content": "Ok guys I am on the daily challenge train. I honestly don\\'t know how I solved this question, I followed comments around here and it worked whatever I did.\\n\\nI started to overthink using two pointers and then save the substrings in a hashset and then return the count of that hashset.\\nBut then I read some comments and I don\\'t know why counting characters works when there already exists in the hashset. Maybe I mix up in my head that substrings should be unique? Or I mix up with all possible substring combinations of a string.. God damn it I watched at too many videos with DP and Sliding Window, now I see them everywhere.\\n\\nI can\\'t make the correlation in my head how I determine `\"ab\",\"a\",\"ca\",\"ba\"` results by counting characters. I think before clearing the hash in my code I am gonna add in a list whatever I have in the hash and look into values with the debugger in vscode.\\n\\nHere is the code:\\n\\n \\n            var hash = new HashSet<char>();\\n            var count = 1;\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                if (hash.Contains(s[i]))\\n                {\\n                    count++;\\n                    hash.Clear();\\n                    hash.Add(s[i]);\\n                }\\n                else\\n                {\\n                    hash.Add(s[i]);\\n                }\\n            }\\n\\n            return count;"
                    },
                    {
                        "username": "pj1999",
                        "content": "Both greedy and dp solutions got accepted..."
                    },
                    {
                        "username": "sushi27",
                        "content": "looks like leetcode going easy on us for two days"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "this has to be marked as very easy\\n"
                    }
                ]
            },
            {
                "id": 1853603,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Hint : take a unordered_set<char>st,\\nthen loop through the each char of the string s\\nif you see the s[i] is not in the set then insert it ,else increment your ans by 1 , clear the set and insert the current s[i] at last return the ans(ans is a variable initialize with 0)"
                    },
                    {
                        "username": "amaan7",
                        "content": "Guys i am able to come up correct approach but i am not able to code it , what should i do i am very much tensed !!! someone pls help (not talking of just this question had this issue with many many questions ) "
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": " let hash = new Set();\\n    console.log(s);\\n    let count = 1;\\n    if(s.trim().length == 0 || s == null){\\n        return 0;\\n    }\\n    for(let i = 0; i < s.length; i++){\\n        if(hash.has(s[i]) == false){\\n            hash.add(s[i]);\\n            console.log(hash);\\n        }else{\\n            hash = new Set();\\n            count +=1;\\n            i--;\\n        }\\n    }\\n    return count;     js Days....\\n"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This question would be Medium if the substrings may not be contiguous. In this case some extra backtracking would be needed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Looks like another sort of packing problem. Is it bin-packing week? Would be cool, I know nothing about it.\\nOr is it greedy week? Would also be nice, I\\'m not good at proving that greedy solutions work in more involved problems\\nHmm, what do you guys think, what is the theme of this week?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "I think two pointer approach would work here as well "
                    },
                    {
                        "username": "eduard92",
                        "content": "Ok guys I am on the daily challenge train. I honestly don\\'t know how I solved this question, I followed comments around here and it worked whatever I did.\\n\\nI started to overthink using two pointers and then save the substrings in a hashset and then return the count of that hashset.\\nBut then I read some comments and I don\\'t know why counting characters works when there already exists in the hashset. Maybe I mix up in my head that substrings should be unique? Or I mix up with all possible substring combinations of a string.. God damn it I watched at too many videos with DP and Sliding Window, now I see them everywhere.\\n\\nI can\\'t make the correlation in my head how I determine `\"ab\",\"a\",\"ca\",\"ba\"` results by counting characters. I think before clearing the hash in my code I am gonna add in a list whatever I have in the hash and look into values with the debugger in vscode.\\n\\nHere is the code:\\n\\n \\n            var hash = new HashSet<char>();\\n            var count = 1;\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                if (hash.Contains(s[i]))\\n                {\\n                    count++;\\n                    hash.Clear();\\n                    hash.Add(s[i]);\\n                }\\n                else\\n                {\\n                    hash.Add(s[i]);\\n                }\\n            }\\n\\n            return count;"
                    },
                    {
                        "username": "pj1999",
                        "content": "Both greedy and dp solutions got accepted..."
                    },
                    {
                        "username": "sushi27",
                        "content": "looks like leetcode going easy on us for two days"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "this has to be marked as very easy\\n"
                    }
                ]
            },
            {
                "id": 1853521,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Hint : take a unordered_set<char>st,\\nthen loop through the each char of the string s\\nif you see the s[i] is not in the set then insert it ,else increment your ans by 1 , clear the set and insert the current s[i] at last return the ans(ans is a variable initialize with 0)"
                    },
                    {
                        "username": "amaan7",
                        "content": "Guys i am able to come up correct approach but i am not able to code it , what should i do i am very much tensed !!! someone pls help (not talking of just this question had this issue with many many questions ) "
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": " let hash = new Set();\\n    console.log(s);\\n    let count = 1;\\n    if(s.trim().length == 0 || s == null){\\n        return 0;\\n    }\\n    for(let i = 0; i < s.length; i++){\\n        if(hash.has(s[i]) == false){\\n            hash.add(s[i]);\\n            console.log(hash);\\n        }else{\\n            hash = new Set();\\n            count +=1;\\n            i--;\\n        }\\n    }\\n    return count;     js Days....\\n"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This question would be Medium if the substrings may not be contiguous. In this case some extra backtracking would be needed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Looks like another sort of packing problem. Is it bin-packing week? Would be cool, I know nothing about it.\\nOr is it greedy week? Would also be nice, I\\'m not good at proving that greedy solutions work in more involved problems\\nHmm, what do you guys think, what is the theme of this week?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "I think two pointer approach would work here as well "
                    },
                    {
                        "username": "eduard92",
                        "content": "Ok guys I am on the daily challenge train. I honestly don\\'t know how I solved this question, I followed comments around here and it worked whatever I did.\\n\\nI started to overthink using two pointers and then save the substrings in a hashset and then return the count of that hashset.\\nBut then I read some comments and I don\\'t know why counting characters works when there already exists in the hashset. Maybe I mix up in my head that substrings should be unique? Or I mix up with all possible substring combinations of a string.. God damn it I watched at too many videos with DP and Sliding Window, now I see them everywhere.\\n\\nI can\\'t make the correlation in my head how I determine `\"ab\",\"a\",\"ca\",\"ba\"` results by counting characters. I think before clearing the hash in my code I am gonna add in a list whatever I have in the hash and look into values with the debugger in vscode.\\n\\nHere is the code:\\n\\n \\n            var hash = new HashSet<char>();\\n            var count = 1;\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                if (hash.Contains(s[i]))\\n                {\\n                    count++;\\n                    hash.Clear();\\n                    hash.Add(s[i]);\\n                }\\n                else\\n                {\\n                    hash.Add(s[i]);\\n                }\\n            }\\n\\n            return count;"
                    },
                    {
                        "username": "pj1999",
                        "content": "Both greedy and dp solutions got accepted..."
                    },
                    {
                        "username": "sushi27",
                        "content": "looks like leetcode going easy on us for two days"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "this has to be marked as very easy\\n"
                    }
                ]
            },
            {
                "id": 1853501,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Hint : take a unordered_set<char>st,\\nthen loop through the each char of the string s\\nif you see the s[i] is not in the set then insert it ,else increment your ans by 1 , clear the set and insert the current s[i] at last return the ans(ans is a variable initialize with 0)"
                    },
                    {
                        "username": "amaan7",
                        "content": "Guys i am able to come up correct approach but i am not able to code it , what should i do i am very much tensed !!! someone pls help (not talking of just this question had this issue with many many questions ) "
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": " let hash = new Set();\\n    console.log(s);\\n    let count = 1;\\n    if(s.trim().length == 0 || s == null){\\n        return 0;\\n    }\\n    for(let i = 0; i < s.length; i++){\\n        if(hash.has(s[i]) == false){\\n            hash.add(s[i]);\\n            console.log(hash);\\n        }else{\\n            hash = new Set();\\n            count +=1;\\n            i--;\\n        }\\n    }\\n    return count;     js Days....\\n"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This question would be Medium if the substrings may not be contiguous. In this case some extra backtracking would be needed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Looks like another sort of packing problem. Is it bin-packing week? Would be cool, I know nothing about it.\\nOr is it greedy week? Would also be nice, I\\'m not good at proving that greedy solutions work in more involved problems\\nHmm, what do you guys think, what is the theme of this week?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "I think two pointer approach would work here as well "
                    },
                    {
                        "username": "eduard92",
                        "content": "Ok guys I am on the daily challenge train. I honestly don\\'t know how I solved this question, I followed comments around here and it worked whatever I did.\\n\\nI started to overthink using two pointers and then save the substrings in a hashset and then return the count of that hashset.\\nBut then I read some comments and I don\\'t know why counting characters works when there already exists in the hashset. Maybe I mix up in my head that substrings should be unique? Or I mix up with all possible substring combinations of a string.. God damn it I watched at too many videos with DP and Sliding Window, now I see them everywhere.\\n\\nI can\\'t make the correlation in my head how I determine `\"ab\",\"a\",\"ca\",\"ba\"` results by counting characters. I think before clearing the hash in my code I am gonna add in a list whatever I have in the hash and look into values with the debugger in vscode.\\n\\nHere is the code:\\n\\n \\n            var hash = new HashSet<char>();\\n            var count = 1;\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                if (hash.Contains(s[i]))\\n                {\\n                    count++;\\n                    hash.Clear();\\n                    hash.Add(s[i]);\\n                }\\n                else\\n                {\\n                    hash.Add(s[i]);\\n                }\\n            }\\n\\n            return count;"
                    },
                    {
                        "username": "pj1999",
                        "content": "Both greedy and dp solutions got accepted..."
                    },
                    {
                        "username": "sushi27",
                        "content": "looks like leetcode going easy on us for two days"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "this has to be marked as very easy\\n"
                    }
                ]
            },
            {
                "id": 1853446,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Hint : take a unordered_set<char>st,\\nthen loop through the each char of the string s\\nif you see the s[i] is not in the set then insert it ,else increment your ans by 1 , clear the set and insert the current s[i] at last return the ans(ans is a variable initialize with 0)"
                    },
                    {
                        "username": "amaan7",
                        "content": "Guys i am able to come up correct approach but i am not able to code it , what should i do i am very much tensed !!! someone pls help (not talking of just this question had this issue with many many questions ) "
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": " let hash = new Set();\\n    console.log(s);\\n    let count = 1;\\n    if(s.trim().length == 0 || s == null){\\n        return 0;\\n    }\\n    for(let i = 0; i < s.length; i++){\\n        if(hash.has(s[i]) == false){\\n            hash.add(s[i]);\\n            console.log(hash);\\n        }else{\\n            hash = new Set();\\n            count +=1;\\n            i--;\\n        }\\n    }\\n    return count;     js Days....\\n"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This question would be Medium if the substrings may not be contiguous. In this case some extra backtracking would be needed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Looks like another sort of packing problem. Is it bin-packing week? Would be cool, I know nothing about it.\\nOr is it greedy week? Would also be nice, I\\'m not good at proving that greedy solutions work in more involved problems\\nHmm, what do you guys think, what is the theme of this week?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "I think two pointer approach would work here as well "
                    },
                    {
                        "username": "eduard92",
                        "content": "Ok guys I am on the daily challenge train. I honestly don\\'t know how I solved this question, I followed comments around here and it worked whatever I did.\\n\\nI started to overthink using two pointers and then save the substrings in a hashset and then return the count of that hashset.\\nBut then I read some comments and I don\\'t know why counting characters works when there already exists in the hashset. Maybe I mix up in my head that substrings should be unique? Or I mix up with all possible substring combinations of a string.. God damn it I watched at too many videos with DP and Sliding Window, now I see them everywhere.\\n\\nI can\\'t make the correlation in my head how I determine `\"ab\",\"a\",\"ca\",\"ba\"` results by counting characters. I think before clearing the hash in my code I am gonna add in a list whatever I have in the hash and look into values with the debugger in vscode.\\n\\nHere is the code:\\n\\n \\n            var hash = new HashSet<char>();\\n            var count = 1;\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                if (hash.Contains(s[i]))\\n                {\\n                    count++;\\n                    hash.Clear();\\n                    hash.Add(s[i]);\\n                }\\n                else\\n                {\\n                    hash.Add(s[i]);\\n                }\\n            }\\n\\n            return count;"
                    },
                    {
                        "username": "pj1999",
                        "content": "Both greedy and dp solutions got accepted..."
                    },
                    {
                        "username": "sushi27",
                        "content": "looks like leetcode going easy on us for two days"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "this has to be marked as very easy\\n"
                    }
                ]
            },
            {
                "id": 1853442,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Hint : take a unordered_set<char>st,\\nthen loop through the each char of the string s\\nif you see the s[i] is not in the set then insert it ,else increment your ans by 1 , clear the set and insert the current s[i] at last return the ans(ans is a variable initialize with 0)"
                    },
                    {
                        "username": "amaan7",
                        "content": "Guys i am able to come up correct approach but i am not able to code it , what should i do i am very much tensed !!! someone pls help (not talking of just this question had this issue with many many questions ) "
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": " let hash = new Set();\\n    console.log(s);\\n    let count = 1;\\n    if(s.trim().length == 0 || s == null){\\n        return 0;\\n    }\\n    for(let i = 0; i < s.length; i++){\\n        if(hash.has(s[i]) == false){\\n            hash.add(s[i]);\\n            console.log(hash);\\n        }else{\\n            hash = new Set();\\n            count +=1;\\n            i--;\\n        }\\n    }\\n    return count;     js Days....\\n"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This question would be Medium if the substrings may not be contiguous. In this case some extra backtracking would be needed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Looks like another sort of packing problem. Is it bin-packing week? Would be cool, I know nothing about it.\\nOr is it greedy week? Would also be nice, I\\'m not good at proving that greedy solutions work in more involved problems\\nHmm, what do you guys think, what is the theme of this week?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "I think two pointer approach would work here as well "
                    },
                    {
                        "username": "eduard92",
                        "content": "Ok guys I am on the daily challenge train. I honestly don\\'t know how I solved this question, I followed comments around here and it worked whatever I did.\\n\\nI started to overthink using two pointers and then save the substrings in a hashset and then return the count of that hashset.\\nBut then I read some comments and I don\\'t know why counting characters works when there already exists in the hashset. Maybe I mix up in my head that substrings should be unique? Or I mix up with all possible substring combinations of a string.. God damn it I watched at too many videos with DP and Sliding Window, now I see them everywhere.\\n\\nI can\\'t make the correlation in my head how I determine `\"ab\",\"a\",\"ca\",\"ba\"` results by counting characters. I think before clearing the hash in my code I am gonna add in a list whatever I have in the hash and look into values with the debugger in vscode.\\n\\nHere is the code:\\n\\n \\n            var hash = new HashSet<char>();\\n            var count = 1;\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                if (hash.Contains(s[i]))\\n                {\\n                    count++;\\n                    hash.Clear();\\n                    hash.Add(s[i]);\\n                }\\n                else\\n                {\\n                    hash.Add(s[i]);\\n                }\\n            }\\n\\n            return count;"
                    },
                    {
                        "username": "pj1999",
                        "content": "Both greedy and dp solutions got accepted..."
                    },
                    {
                        "username": "sushi27",
                        "content": "looks like leetcode going easy on us for two days"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "this has to be marked as very easy\\n"
                    }
                ]
            },
            {
                "id": 1853395,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Hint : take a unordered_set<char>st,\\nthen loop through the each char of the string s\\nif you see the s[i] is not in the set then insert it ,else increment your ans by 1 , clear the set and insert the current s[i] at last return the ans(ans is a variable initialize with 0)"
                    },
                    {
                        "username": "amaan7",
                        "content": "Guys i am able to come up correct approach but i am not able to code it , what should i do i am very much tensed !!! someone pls help (not talking of just this question had this issue with many many questions ) "
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": " let hash = new Set();\\n    console.log(s);\\n    let count = 1;\\n    if(s.trim().length == 0 || s == null){\\n        return 0;\\n    }\\n    for(let i = 0; i < s.length; i++){\\n        if(hash.has(s[i]) == false){\\n            hash.add(s[i]);\\n            console.log(hash);\\n        }else{\\n            hash = new Set();\\n            count +=1;\\n            i--;\\n        }\\n    }\\n    return count;     js Days....\\n"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This question would be Medium if the substrings may not be contiguous. In this case some extra backtracking would be needed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Looks like another sort of packing problem. Is it bin-packing week? Would be cool, I know nothing about it.\\nOr is it greedy week? Would also be nice, I\\'m not good at proving that greedy solutions work in more involved problems\\nHmm, what do you guys think, what is the theme of this week?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "I think two pointer approach would work here as well "
                    },
                    {
                        "username": "eduard92",
                        "content": "Ok guys I am on the daily challenge train. I honestly don\\'t know how I solved this question, I followed comments around here and it worked whatever I did.\\n\\nI started to overthink using two pointers and then save the substrings in a hashset and then return the count of that hashset.\\nBut then I read some comments and I don\\'t know why counting characters works when there already exists in the hashset. Maybe I mix up in my head that substrings should be unique? Or I mix up with all possible substring combinations of a string.. God damn it I watched at too many videos with DP and Sliding Window, now I see them everywhere.\\n\\nI can\\'t make the correlation in my head how I determine `\"ab\",\"a\",\"ca\",\"ba\"` results by counting characters. I think before clearing the hash in my code I am gonna add in a list whatever I have in the hash and look into values with the debugger in vscode.\\n\\nHere is the code:\\n\\n \\n            var hash = new HashSet<char>();\\n            var count = 1;\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                if (hash.Contains(s[i]))\\n                {\\n                    count++;\\n                    hash.Clear();\\n                    hash.Add(s[i]);\\n                }\\n                else\\n                {\\n                    hash.Add(s[i]);\\n                }\\n            }\\n\\n            return count;"
                    },
                    {
                        "username": "pj1999",
                        "content": "Both greedy and dp solutions got accepted..."
                    },
                    {
                        "username": "sushi27",
                        "content": "looks like leetcode going easy on us for two days"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "this has to be marked as very easy\\n"
                    }
                ]
            },
            {
                "id": 1853393,
                "content": [
                    {
                        "username": "vishalvvr3",
                        "content": " `\\n   map<char,int> mp;\\n\\n        vector<vector<char>> ans;\\n\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int maxs =0;\\n        for(auto i:mp)\\n        {\\n            maxs= max(i.second,maxs);\\n            cout<<i.first<<i.second<<endl;\\n        }\\n        return maxs;\\n`\\n\\nWhy is this not working"
                    },
                    {
                        "username": "DenisDefo",
                        "content": "A lot people write about set solution, but try solve it using array, make this task a bit more interesting!"
                    },
                    {
                        "username": "user2049D",
                        "content": "Really ? With a python list instead of a set, there is no significative difference in the result !"
                    },
                    {
                        "username": "psionl0",
                        "content": "The maximum length of a substring without repeating characters is 26 so even a brute force solution (searching for the first repeating character) will be close to O(N) time."
                    },
                    {
                        "username": "amangautam3002",
                        "content": "Eazy Peezy \\uD83D\\uDE2A"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Google PLEASE give me this question"
                    },
                    {
                        "username": "AlecLC",
                        "content": "So easy lol\\n\\nThis is the most optimal daily question and interview problem"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "Don\\u2019t think too deep. There\\u2019s no catch to the problem ;)"
                    },
                    {
                        "username": "el_harbin",
                        "content": "Example Testcase force me to think that in a partition every substring must be unique and question never specify that. Just because of this thing I am just trying to solve it recursively."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Should be marked as easy!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a HashSet to keep track of unique characters in the current partition.\\n- Initialize the count of partitions to 1.\\n- Iterate through the characters of the input string.\\n- For each character, check if it is already in the HashSet.\\n- If it is, increment the count of partitions and clear the HashSet to start a new partition.\\n- If it is not, add the character to the HashSet to keep track of the characters in the current partition.\\n- After iterating through the entire string, return the count of partitions as the minimum number of partitions needed to partition the input string such that each partition contains only characters that appear in that partition."
                    }
                ]
            },
            {
                "id": 1853391,
                "content": [
                    {
                        "username": "vishalvvr3",
                        "content": " `\\n   map<char,int> mp;\\n\\n        vector<vector<char>> ans;\\n\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int maxs =0;\\n        for(auto i:mp)\\n        {\\n            maxs= max(i.second,maxs);\\n            cout<<i.first<<i.second<<endl;\\n        }\\n        return maxs;\\n`\\n\\nWhy is this not working"
                    },
                    {
                        "username": "DenisDefo",
                        "content": "A lot people write about set solution, but try solve it using array, make this task a bit more interesting!"
                    },
                    {
                        "username": "user2049D",
                        "content": "Really ? With a python list instead of a set, there is no significative difference in the result !"
                    },
                    {
                        "username": "psionl0",
                        "content": "The maximum length of a substring without repeating characters is 26 so even a brute force solution (searching for the first repeating character) will be close to O(N) time."
                    },
                    {
                        "username": "amangautam3002",
                        "content": "Eazy Peezy \\uD83D\\uDE2A"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Google PLEASE give me this question"
                    },
                    {
                        "username": "AlecLC",
                        "content": "So easy lol\\n\\nThis is the most optimal daily question and interview problem"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "Don\\u2019t think too deep. There\\u2019s no catch to the problem ;)"
                    },
                    {
                        "username": "el_harbin",
                        "content": "Example Testcase force me to think that in a partition every substring must be unique and question never specify that. Just because of this thing I am just trying to solve it recursively."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Should be marked as easy!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a HashSet to keep track of unique characters in the current partition.\\n- Initialize the count of partitions to 1.\\n- Iterate through the characters of the input string.\\n- For each character, check if it is already in the HashSet.\\n- If it is, increment the count of partitions and clear the HashSet to start a new partition.\\n- If it is not, add the character to the HashSet to keep track of the characters in the current partition.\\n- After iterating through the entire string, return the count of partitions as the minimum number of partitions needed to partition the input string such that each partition contains only characters that appear in that partition."
                    }
                ]
            },
            {
                "id": 1853282,
                "content": [
                    {
                        "username": "vishalvvr3",
                        "content": " `\\n   map<char,int> mp;\\n\\n        vector<vector<char>> ans;\\n\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int maxs =0;\\n        for(auto i:mp)\\n        {\\n            maxs= max(i.second,maxs);\\n            cout<<i.first<<i.second<<endl;\\n        }\\n        return maxs;\\n`\\n\\nWhy is this not working"
                    },
                    {
                        "username": "DenisDefo",
                        "content": "A lot people write about set solution, but try solve it using array, make this task a bit more interesting!"
                    },
                    {
                        "username": "user2049D",
                        "content": "Really ? With a python list instead of a set, there is no significative difference in the result !"
                    },
                    {
                        "username": "psionl0",
                        "content": "The maximum length of a substring without repeating characters is 26 so even a brute force solution (searching for the first repeating character) will be close to O(N) time."
                    },
                    {
                        "username": "amangautam3002",
                        "content": "Eazy Peezy \\uD83D\\uDE2A"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Google PLEASE give me this question"
                    },
                    {
                        "username": "AlecLC",
                        "content": "So easy lol\\n\\nThis is the most optimal daily question and interview problem"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "Don\\u2019t think too deep. There\\u2019s no catch to the problem ;)"
                    },
                    {
                        "username": "el_harbin",
                        "content": "Example Testcase force me to think that in a partition every substring must be unique and question never specify that. Just because of this thing I am just trying to solve it recursively."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Should be marked as easy!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a HashSet to keep track of unique characters in the current partition.\\n- Initialize the count of partitions to 1.\\n- Iterate through the characters of the input string.\\n- For each character, check if it is already in the HashSet.\\n- If it is, increment the count of partitions and clear the HashSet to start a new partition.\\n- If it is not, add the character to the HashSet to keep track of the characters in the current partition.\\n- After iterating through the entire string, return the count of partitions as the minimum number of partitions needed to partition the input string such that each partition contains only characters that appear in that partition."
                    }
                ]
            },
            {
                "id": 1853276,
                "content": [
                    {
                        "username": "vishalvvr3",
                        "content": " `\\n   map<char,int> mp;\\n\\n        vector<vector<char>> ans;\\n\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int maxs =0;\\n        for(auto i:mp)\\n        {\\n            maxs= max(i.second,maxs);\\n            cout<<i.first<<i.second<<endl;\\n        }\\n        return maxs;\\n`\\n\\nWhy is this not working"
                    },
                    {
                        "username": "DenisDefo",
                        "content": "A lot people write about set solution, but try solve it using array, make this task a bit more interesting!"
                    },
                    {
                        "username": "user2049D",
                        "content": "Really ? With a python list instead of a set, there is no significative difference in the result !"
                    },
                    {
                        "username": "psionl0",
                        "content": "The maximum length of a substring without repeating characters is 26 so even a brute force solution (searching for the first repeating character) will be close to O(N) time."
                    },
                    {
                        "username": "amangautam3002",
                        "content": "Eazy Peezy \\uD83D\\uDE2A"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Google PLEASE give me this question"
                    },
                    {
                        "username": "AlecLC",
                        "content": "So easy lol\\n\\nThis is the most optimal daily question and interview problem"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "Don\\u2019t think too deep. There\\u2019s no catch to the problem ;)"
                    },
                    {
                        "username": "el_harbin",
                        "content": "Example Testcase force me to think that in a partition every substring must be unique and question never specify that. Just because of this thing I am just trying to solve it recursively."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Should be marked as easy!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a HashSet to keep track of unique characters in the current partition.\\n- Initialize the count of partitions to 1.\\n- Iterate through the characters of the input string.\\n- For each character, check if it is already in the HashSet.\\n- If it is, increment the count of partitions and clear the HashSet to start a new partition.\\n- If it is not, add the character to the HashSet to keep track of the characters in the current partition.\\n- After iterating through the entire string, return the count of partitions as the minimum number of partitions needed to partition the input string such that each partition contains only characters that appear in that partition."
                    }
                ]
            },
            {
                "id": 1853254,
                "content": [
                    {
                        "username": "vishalvvr3",
                        "content": " `\\n   map<char,int> mp;\\n\\n        vector<vector<char>> ans;\\n\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int maxs =0;\\n        for(auto i:mp)\\n        {\\n            maxs= max(i.second,maxs);\\n            cout<<i.first<<i.second<<endl;\\n        }\\n        return maxs;\\n`\\n\\nWhy is this not working"
                    },
                    {
                        "username": "DenisDefo",
                        "content": "A lot people write about set solution, but try solve it using array, make this task a bit more interesting!"
                    },
                    {
                        "username": "user2049D",
                        "content": "Really ? With a python list instead of a set, there is no significative difference in the result !"
                    },
                    {
                        "username": "psionl0",
                        "content": "The maximum length of a substring without repeating characters is 26 so even a brute force solution (searching for the first repeating character) will be close to O(N) time."
                    },
                    {
                        "username": "amangautam3002",
                        "content": "Eazy Peezy \\uD83D\\uDE2A"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Google PLEASE give me this question"
                    },
                    {
                        "username": "AlecLC",
                        "content": "So easy lol\\n\\nThis is the most optimal daily question and interview problem"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "Don\\u2019t think too deep. There\\u2019s no catch to the problem ;)"
                    },
                    {
                        "username": "el_harbin",
                        "content": "Example Testcase force me to think that in a partition every substring must be unique and question never specify that. Just because of this thing I am just trying to solve it recursively."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Should be marked as easy!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a HashSet to keep track of unique characters in the current partition.\\n- Initialize the count of partitions to 1.\\n- Iterate through the characters of the input string.\\n- For each character, check if it is already in the HashSet.\\n- If it is, increment the count of partitions and clear the HashSet to start a new partition.\\n- If it is not, add the character to the HashSet to keep track of the characters in the current partition.\\n- After iterating through the entire string, return the count of partitions as the minimum number of partitions needed to partition the input string such that each partition contains only characters that appear in that partition."
                    }
                ]
            },
            {
                "id": 1853243,
                "content": [
                    {
                        "username": "vishalvvr3",
                        "content": " `\\n   map<char,int> mp;\\n\\n        vector<vector<char>> ans;\\n\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int maxs =0;\\n        for(auto i:mp)\\n        {\\n            maxs= max(i.second,maxs);\\n            cout<<i.first<<i.second<<endl;\\n        }\\n        return maxs;\\n`\\n\\nWhy is this not working"
                    },
                    {
                        "username": "DenisDefo",
                        "content": "A lot people write about set solution, but try solve it using array, make this task a bit more interesting!"
                    },
                    {
                        "username": "user2049D",
                        "content": "Really ? With a python list instead of a set, there is no significative difference in the result !"
                    },
                    {
                        "username": "psionl0",
                        "content": "The maximum length of a substring without repeating characters is 26 so even a brute force solution (searching for the first repeating character) will be close to O(N) time."
                    },
                    {
                        "username": "amangautam3002",
                        "content": "Eazy Peezy \\uD83D\\uDE2A"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Google PLEASE give me this question"
                    },
                    {
                        "username": "AlecLC",
                        "content": "So easy lol\\n\\nThis is the most optimal daily question and interview problem"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "Don\\u2019t think too deep. There\\u2019s no catch to the problem ;)"
                    },
                    {
                        "username": "el_harbin",
                        "content": "Example Testcase force me to think that in a partition every substring must be unique and question never specify that. Just because of this thing I am just trying to solve it recursively."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Should be marked as easy!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a HashSet to keep track of unique characters in the current partition.\\n- Initialize the count of partitions to 1.\\n- Iterate through the characters of the input string.\\n- For each character, check if it is already in the HashSet.\\n- If it is, increment the count of partitions and clear the HashSet to start a new partition.\\n- If it is not, add the character to the HashSet to keep track of the characters in the current partition.\\n- After iterating through the entire string, return the count of partitions as the minimum number of partitions needed to partition the input string such that each partition contains only characters that appear in that partition."
                    }
                ]
            },
            {
                "id": 1853240,
                "content": [
                    {
                        "username": "vishalvvr3",
                        "content": " `\\n   map<char,int> mp;\\n\\n        vector<vector<char>> ans;\\n\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int maxs =0;\\n        for(auto i:mp)\\n        {\\n            maxs= max(i.second,maxs);\\n            cout<<i.first<<i.second<<endl;\\n        }\\n        return maxs;\\n`\\n\\nWhy is this not working"
                    },
                    {
                        "username": "DenisDefo",
                        "content": "A lot people write about set solution, but try solve it using array, make this task a bit more interesting!"
                    },
                    {
                        "username": "user2049D",
                        "content": "Really ? With a python list instead of a set, there is no significative difference in the result !"
                    },
                    {
                        "username": "psionl0",
                        "content": "The maximum length of a substring without repeating characters is 26 so even a brute force solution (searching for the first repeating character) will be close to O(N) time."
                    },
                    {
                        "username": "amangautam3002",
                        "content": "Eazy Peezy \\uD83D\\uDE2A"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Google PLEASE give me this question"
                    },
                    {
                        "username": "AlecLC",
                        "content": "So easy lol\\n\\nThis is the most optimal daily question and interview problem"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "Don\\u2019t think too deep. There\\u2019s no catch to the problem ;)"
                    },
                    {
                        "username": "el_harbin",
                        "content": "Example Testcase force me to think that in a partition every substring must be unique and question never specify that. Just because of this thing I am just trying to solve it recursively."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Should be marked as easy!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a HashSet to keep track of unique characters in the current partition.\\n- Initialize the count of partitions to 1.\\n- Iterate through the characters of the input string.\\n- For each character, check if it is already in the HashSet.\\n- If it is, increment the count of partitions and clear the HashSet to start a new partition.\\n- If it is not, add the character to the HashSet to keep track of the characters in the current partition.\\n- After iterating through the entire string, return the count of partitions as the minimum number of partitions needed to partition the input string such that each partition contains only characters that appear in that partition."
                    }
                ]
            },
            {
                "id": 1853225,
                "content": [
                    {
                        "username": "vishalvvr3",
                        "content": " `\\n   map<char,int> mp;\\n\\n        vector<vector<char>> ans;\\n\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int maxs =0;\\n        for(auto i:mp)\\n        {\\n            maxs= max(i.second,maxs);\\n            cout<<i.first<<i.second<<endl;\\n        }\\n        return maxs;\\n`\\n\\nWhy is this not working"
                    },
                    {
                        "username": "DenisDefo",
                        "content": "A lot people write about set solution, but try solve it using array, make this task a bit more interesting!"
                    },
                    {
                        "username": "user2049D",
                        "content": "Really ? With a python list instead of a set, there is no significative difference in the result !"
                    },
                    {
                        "username": "psionl0",
                        "content": "The maximum length of a substring without repeating characters is 26 so even a brute force solution (searching for the first repeating character) will be close to O(N) time."
                    },
                    {
                        "username": "amangautam3002",
                        "content": "Eazy Peezy \\uD83D\\uDE2A"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Google PLEASE give me this question"
                    },
                    {
                        "username": "AlecLC",
                        "content": "So easy lol\\n\\nThis is the most optimal daily question and interview problem"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "Don\\u2019t think too deep. There\\u2019s no catch to the problem ;)"
                    },
                    {
                        "username": "el_harbin",
                        "content": "Example Testcase force me to think that in a partition every substring must be unique and question never specify that. Just because of this thing I am just trying to solve it recursively."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Should be marked as easy!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a HashSet to keep track of unique characters in the current partition.\\n- Initialize the count of partitions to 1.\\n- Iterate through the characters of the input string.\\n- For each character, check if it is already in the HashSet.\\n- If it is, increment the count of partitions and clear the HashSet to start a new partition.\\n- If it is not, add the character to the HashSet to keep track of the characters in the current partition.\\n- After iterating through the entire string, return the count of partitions as the minimum number of partitions needed to partition the input string such that each partition contains only characters that appear in that partition."
                    }
                ]
            },
            {
                "id": 1853212,
                "content": [
                    {
                        "username": "vishalvvr3",
                        "content": " `\\n   map<char,int> mp;\\n\\n        vector<vector<char>> ans;\\n\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int maxs =0;\\n        for(auto i:mp)\\n        {\\n            maxs= max(i.second,maxs);\\n            cout<<i.first<<i.second<<endl;\\n        }\\n        return maxs;\\n`\\n\\nWhy is this not working"
                    },
                    {
                        "username": "DenisDefo",
                        "content": "A lot people write about set solution, but try solve it using array, make this task a bit more interesting!"
                    },
                    {
                        "username": "user2049D",
                        "content": "Really ? With a python list instead of a set, there is no significative difference in the result !"
                    },
                    {
                        "username": "psionl0",
                        "content": "The maximum length of a substring without repeating characters is 26 so even a brute force solution (searching for the first repeating character) will be close to O(N) time."
                    },
                    {
                        "username": "amangautam3002",
                        "content": "Eazy Peezy \\uD83D\\uDE2A"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Google PLEASE give me this question"
                    },
                    {
                        "username": "AlecLC",
                        "content": "So easy lol\\n\\nThis is the most optimal daily question and interview problem"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "Don\\u2019t think too deep. There\\u2019s no catch to the problem ;)"
                    },
                    {
                        "username": "el_harbin",
                        "content": "Example Testcase force me to think that in a partition every substring must be unique and question never specify that. Just because of this thing I am just trying to solve it recursively."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Should be marked as easy!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a HashSet to keep track of unique characters in the current partition.\\n- Initialize the count of partitions to 1.\\n- Iterate through the characters of the input string.\\n- For each character, check if it is already in the HashSet.\\n- If it is, increment the count of partitions and clear the HashSet to start a new partition.\\n- If it is not, add the character to the HashSet to keep track of the characters in the current partition.\\n- After iterating through the entire string, return the count of partitions as the minimum number of partitions needed to partition the input string such that each partition contains only characters that appear in that partition."
                    }
                ]
            },
            {
                "id": 1853206,
                "content": [
                    {
                        "username": "vishalvvr3",
                        "content": " `\\n   map<char,int> mp;\\n\\n        vector<vector<char>> ans;\\n\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int maxs =0;\\n        for(auto i:mp)\\n        {\\n            maxs= max(i.second,maxs);\\n            cout<<i.first<<i.second<<endl;\\n        }\\n        return maxs;\\n`\\n\\nWhy is this not working"
                    },
                    {
                        "username": "DenisDefo",
                        "content": "A lot people write about set solution, but try solve it using array, make this task a bit more interesting!"
                    },
                    {
                        "username": "user2049D",
                        "content": "Really ? With a python list instead of a set, there is no significative difference in the result !"
                    },
                    {
                        "username": "psionl0",
                        "content": "The maximum length of a substring without repeating characters is 26 so even a brute force solution (searching for the first repeating character) will be close to O(N) time."
                    },
                    {
                        "username": "amangautam3002",
                        "content": "Eazy Peezy \\uD83D\\uDE2A"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Google PLEASE give me this question"
                    },
                    {
                        "username": "AlecLC",
                        "content": "So easy lol\\n\\nThis is the most optimal daily question and interview problem"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "Don\\u2019t think too deep. There\\u2019s no catch to the problem ;)"
                    },
                    {
                        "username": "el_harbin",
                        "content": "Example Testcase force me to think that in a partition every substring must be unique and question never specify that. Just because of this thing I am just trying to solve it recursively."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Should be marked as easy!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a HashSet to keep track of unique characters in the current partition.\\n- Initialize the count of partitions to 1.\\n- Iterate through the characters of the input string.\\n- For each character, check if it is already in the HashSet.\\n- If it is, increment the count of partitions and clear the HashSet to start a new partition.\\n- If it is not, add the character to the HashSet to keep track of the characters in the current partition.\\n- After iterating through the entire string, return the count of partitions as the minimum number of partitions needed to partition the input string such that each partition contains only characters that appear in that partition."
                    }
                ]
            }
        ]
    }
]