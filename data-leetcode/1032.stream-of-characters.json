[
    {
        "title": "Stream of Characters",
        "question_content": "Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings words.\nFor example, if words = [\"abc\", \"xyz\"]&nbsp;and the stream added the four characters (one by one) 'a', 'x', 'y', and 'z', your algorithm should detect that the suffix \"xyz\" of the characters \"axyz\" matches \"xyz\" from words.\nImplement the StreamChecker class:\n\tStreamChecker(String[] words) Initializes the object with the strings array words.\n\tboolean query(char letter) Accepts a new character from the stream and returns true if any non-empty suffix from the stream forms a word that is in words.\n&nbsp;\nExample 1:\nInput\n[\"StreamChecker\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\"]\n[[[\"cd\", \"f\", \"kl\"]], [\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [\"f\"], [\"g\"], [\"h\"], [\"i\"], [\"j\"], [\"k\"], [\"l\"]]\nOutput\n[null, false, false, false, true, false, true, false, false, false, false, false, true]\nExplanation\nStreamChecker streamChecker = new StreamChecker([\"cd\", \"f\", \"kl\"]);\nstreamChecker.query(\"a\"); // return False\nstreamChecker.query(\"b\"); // return False\nstreamChecker.query(\"c\"); // return False\nstreamChecker.query(\"d\"); // return True, because 'cd' is in the wordlist\nstreamChecker.query(\"e\"); // return False\nstreamChecker.query(\"f\"); // return True, because 'f' is in the wordlist\nstreamChecker.query(\"g\"); // return False\nstreamChecker.query(\"h\"); // return False\nstreamChecker.query(\"i\"); // return False\nstreamChecker.query(\"j\"); // return False\nstreamChecker.query(\"k\"); // return False\nstreamChecker.query(\"l\"); // return True, because 'kl' is in the wordlist\n&nbsp;\nConstraints:\n\t1 <= words.length <= 2000\n\t1 <= words[i].length <= 200\n\twords[i] consists of lowercase English letters.\n\tletter is a lowercase English letter.\n\tAt most 4 * 104 calls will be made to query.",
        "solutions": [
            {
                "id": 278769,
                "title": "java-trie-solution",
                "content": "Store the words in the trie with reverse order, and check the query string from the end\\n```\\nclass StreamChecker {\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next = new TrieNode[26];\\n    }\\n\\n    TrieNode root = new TrieNode();\\n    StringBuilder sb = new StringBuilder();\\n\\n    public StreamChecker(String[] words) {\\n        createTrie(words);\\n    }\\n\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TrieNode node = root;\\n        for (int i = sb.length() - 1; i >= 0 && node != null; i--) {\\n            char c = sb.charAt(i);\\n            node = node.next[c - \\'a\\'];\\n            if (node != null && node.isWord) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void createTrie(String[] words) {\\n        for (String s : words) {\\n            TrieNode node = root;\\n            int len = s.length();\\n            for (int i = len - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (node.next[c - \\'a\\'] == null) {\\n                    node.next[c - \\'a\\'] = new TrieNode();\\n                }\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "Store the words in the trie with reverse order, and check the query string from the end\\n```\\nclass StreamChecker {\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next = new TrieNode[26];\\n    }\\n\\n    TrieNode root = new TrieNode();\\n    StringBuilder sb = new StringBuilder();\\n\\n    public StreamChecker(String[] words) {\\n        createTrie(words);\\n    }\\n\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TrieNode node = root;\\n        for (int i = sb.length() - 1; i >= 0 && node != null; i--) {\\n            char c = sb.charAt(i);\\n            node = node.next[c - \\'a\\'];\\n            if (node != null && node.isWord) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void createTrie(String[] words) {\\n        for (String s : words) {\\n            TrieNode node = root;\\n            int len = s.length();\\n            for (int i = len - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (node.next[c - \\'a\\'] == null) {\\n                    node.next[c - \\'a\\'] = new TrieNode();\\n                }\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 278250,
                "title": "python-trie-solution-with-explanation",
                "content": "# **We say**\\n`W = max(words.length)`,the maximum length of all words.\\n`N = words.size`, the number of words\\n`Q`, the number of calls of function `query`\\n<br>\\n\\n# **Solution 1: Check all words (TLE)**\\nIf we save the whole input character stream and compare with `words` one by one,\\nThe time complexity for each `query` will be `O(NW)`,\\ndepending on the size of `words`.\\n<br>\\n\\n# **Solution 2: Check Query Suffixes (Maybe AC, Maybe TLE)**\\n\\nWhile the `words.size` can be really big,\\nthe number of the suffixes of query stream is bounded.\\n\\nFor example, if the query stream is `\"abcd\"`,\\nthe suffix can be `\"abcd\"`, `\"bcd\"`, `\"cd\"`, `\"d\"`.\\n\\nWe can save all hashed words to a set.\\nFor each query, we check query stream\\'s all suffixes.\\nThe maximum length of words is `W`, we need to check `W` suffixes.\\n\\nThe time complexity for each `query` will be `O(W)` if we take the set search as `O(1)`.\\nThe overall time is `O(WQ)`.\\n<br>\\n\\n# **Solution 3: Trie (Accepted)**\\nOnly a part of suffixes can be the prefix of a word,\\nwaiting for characters coming to form a complete word.\\nInstead of checking all `W` suffixes in each query,\\nwe can just save those possible waiting prefixes in a `waiting` list.\\n\\n**Explanation**\\nInitialization:\\n1. Construct a trie\\n2. declare a global waiting list.\\n\\nQuery:\\n1. for each node in the `waiting` list,\\ncheck if there is child node for the new character.\\nIf so, add it to the new waiting list.\\n2. return true if any node in the `waiting`list is the end of a word.\\n\\n**Time Complexity**:\\n`waiting.size <= W`, where `W` is the maximum length of words.\\nSo that `O(query) = O(waiting.size) = O(W)`\\nWe will make `Q` queries, the overall time complexity is `O(QW)`\\n\\nNote that it has same complexity in the worst case as solution 2 (like \"aaaaaaaa\" for words and query),\\nIn general cases, it saves time checking all suffixes, and also the set search in a big set.\\n\\n**Space Complexity**:\\n\\n`waiting.size <= W`, where `W` is the maximum length of words.\\n`waiting` list will take `O(W)`\\n\\nAssume we have initially `N` words, at most `N` leaves in the `trie`.\\nThe size of trie is `O(NW)`.\\n\\n**Python:**\\nTime: 6000+ms\\n```py\\nclass StreamChecker(object):\\n\\n    def __init__(self, words):\\n        T = lambda: collections.defaultdict(T)\\n        self.trie = T()\\n        for w in words: reduce(dict.__getitem__, w, self.trie)[\\'#\\'] = True\\n        self.waiting = []\\n\\n    def query(self, letter):\\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\\n        return any(\"#\" in node for node in self.waiting)\\n```\\n<br>\\n\\n# Solution 4: Construct Trie with Reversed Words\\n\\nTime: 600 ~ 700ms\\nTime complexity: `O(WQ)`\\n\\n**Python**\\n```py\\n    def __init__(self, words):\\n        T = lambda: collections.defaultdict(T)\\n        self.trie = T()\\n        for w in words: reduce(dict.__getitem__, w[::-1], self.trie)[\\'#\\'] = True\\n        self.S = \"\"\\n        self.W = max(map(len, words))\\n\\n    def query(self, letter):\\n        self.S = (letter + self.S)[:self.W]\\n        cur = self.trie\\n        for c in self.S:\\n            if c in cur:\\n                cur = cur[c]\\n                if cur[\\'#\\'] == True:\\n                    return True\\n            else:\\n                break\\n        return False\\n```\\n",
                "solutionTags": [],
                "code": "```py\\nclass StreamChecker(object):\\n\\n    def __init__(self, words):\\n        T = lambda: collections.defaultdict(T)\\n        self.trie = T()\\n        for w in words: reduce(dict.__getitem__, w, self.trie)[\\'#\\'] = True\\n        self.waiting = []\\n\\n    def query(self, letter):\\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\\n        return any(\"#\" in node for node in self.waiting)\\n```\n```py\\n    def __init__(self, words):\\n        T = lambda: collections.defaultdict(T)\\n        self.trie = T()\\n        for w in words: reduce(dict.__getitem__, w[::-1], self.trie)[\\'#\\'] = True\\n        self.S = \"\"\\n        self.W = max(map(len, words))\\n\\n    def query(self, letter):\\n        self.S = (letter + self.S)[:self.W]\\n        cur = self.trie\\n        for c in self.S:\\n            if c in cur:\\n                cur = cur[c]\\n                if cur[\\'#\\'] == True:\\n                    return True\\n            else:\\n                break\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320837,
                "title": "easily-implemented-python-trie-solution",
                "content": "Please see and vote for my solutions for\\n[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/320224/Simple-Python-solution)\\n[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/409075/standard-python-prefix-tree-solution)\\n[1032. Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/320837/Standard-Python-Trie-Solution)\\n[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/319361/Simple-Python-solution)\\n[676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/320197/Simple-Python-solution)\\n[677. Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/320237/Simple-Python-solution)\\n[745. Prefix and Suffix Search](https://leetcode.com/problems/prefix-and-suffix-search/discuss/320712/Different-Python-solutions-with-thinking-process)\\n[425. Word Squares](https://leetcode.com/problems/word-squares/discuss/320916/Easily-implemented-Python-solution%3A-Backtrack-%2B-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)\\n\\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.letters = []\\n        self.trie = Trie()\\n        for w in words:\\n            self.trie.insert(w[::-1])\\n        \\n    def query(self, letter: str) -> bool:\\n        self.letters.append(letter)\\n        i = len(self.letters) - 1\\n        node = self.trie.root\\n        while i >= 0:\\n            if node.isEnd:\\n                return True\\n            if self.letters[i] not in node.children:\\n                return False\\n            node = node.children[self.letters[i]]\\n            i -= 1\\n        return node.isEnd\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.letters = []\\n        self.trie = Trie()\\n        for w in words:\\n            self.trie.insert(w[::-1])\\n        \\n    def query(self, letter: str) -> bool:\\n        self.letters.append(letter)\\n        i = len(self.letters) - 1\\n        node = self.trie.root\\n        while i >= 0:\\n            if node.isEnd:\\n                return True\\n            if self.letters[i] not in node.children:\\n                return False\\n            node = node.children[self.letters[i]]\\n            i -= 1\\n        return node.isEnd\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807429,
                "title": "c-trie-solution-simple-and-clean-explained",
                "content": "**Like it? please upvote...**\\n```\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        // insert reversed word into trie and keep track of the length of longest word\\n        for (auto& word: words) \\n        {\\n            trie.insert_reversed(word);\\n            if (word.length() > longest_word)\\n                longest_word = word.length();\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        queries.insert(queries.begin(), letter);\\n        // keep in queries only the \"longest word\" last queries, because we don\\'t need the other ones anymore\\n        if (queries.size() > longest_word)\\n            queries.pop_back();\\n        Trie* cur = &trie;\\n        for (auto it = queries.begin(); it!=queries.end();++it)\\n        {\\n            if (cur->is_leaf) return true;\\n            if (cur->children[*it -\\'a\\'] == NULL) return false;\\n            cur = cur->children[*it-\\'a\\'];\\n        }\\n        return cur->is_leaf;\\n    }\\nprivate:\\n    \\n    class Trie {\\n    public:\\n        Trie() {\\n            this->is_leaf = false;\\n            for(int i=0;i<26;i++)\\n                this->children[i] = NULL;\\n        }\\n        \\n        void insert_reversed(string word) {\\n            reverse(word.begin(), word.end());\\n            Trie* root = this;\\n            for(int i=0;i<word.length();i++)\\n            {\\n                int index = word[i] - \\'a\\';\\n                if (root->children[index] == NULL)\\n                    root->children[index] = new Trie();\\n                root = root->children[index];\\n            }\\n            root->is_leaf = true;\\n        }\\n        \\n    bool is_leaf;\\n    Trie* children[26];\\n    };\\n    \\n    Trie trie;\\n    vector<char> queries;\\n    int longest_word=0;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        // insert reversed word into trie and keep track of the length of longest word\\n        for (auto& word: words) \\n        {\\n            trie.insert_reversed(word);\\n            if (word.length() > longest_word)\\n                longest_word = word.length();\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        queries.insert(queries.begin(), letter);\\n        // keep in queries only the \"longest word\" last queries, because we don\\'t need the other ones anymore\\n        if (queries.size() > longest_word)\\n            queries.pop_back();\\n        Trie* cur = &trie;\\n        for (auto it = queries.begin(); it!=queries.end();++it)\\n        {\\n            if (cur->is_leaf) return true;\\n            if (cur->children[*it -\\'a\\'] == NULL) return false;\\n            cur = cur->children[*it-\\'a\\'];\\n        }\\n        return cur->is_leaf;\\n    }\\nprivate:\\n    \\n    class Trie {\\n    public:\\n        Trie() {\\n            this->is_leaf = false;\\n            for(int i=0;i<26;i++)\\n                this->children[i] = NULL;\\n        }\\n        \\n        void insert_reversed(string word) {\\n            reverse(word.begin(), word.end());\\n            Trie* root = this;\\n            for(int i=0;i<word.length();i++)\\n            {\\n                int index = word[i] - \\'a\\';\\n                if (root->children[index] == NULL)\\n                    root->children[index] = new Trie();\\n                root = root->children[index];\\n            }\\n            root->is_leaf = true;\\n        }\\n        \\n    bool is_leaf;\\n    Trie* children[26];\\n    };\\n    \\n    Trie trie;\\n    vector<char> queries;\\n    int longest_word=0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713356,
                "title": "explaining-by-examples-what-constitutes-an-expected-solution-for-future-readers",
                "content": "The Description section of this problem lacks good examples, and thus implementing a solution for this problem is probably accompanied by a feeling of \"I hope that *that\\'s* what is expected as a solution\", or even: \"Well, this is kind of an easy question, why would one need to use a Trie\"?\\n\\nI come to the rescue of future readers by giving a better example of an expected output.\\n\\nConsider the following words input:\\n```[\"baa\",\"aa\",\"aaaa\",\"abbbb\",\"aba\"]```\\n\\nWith the following queries input:\\n```[\\'a\\'],[\\'a\\'],[\\'a\\'],[\\'b\\'],[\\'a\\'],[\\'b\\'],[\\'a\\']```\\n\\nThe expected output is:\\n```false,true,true,false,true,false,true```\\n\\nLet\\'s focus on the reason behind each ```true``` result: \\n1. The first ```true``` is expected because the first query and the second query spell the given word ```aa```. \\n2. The second ```true``` is expected because the second query and the third query spell the given word ```aa```. \\n3. The third ```true``` is expected because the 3rd, 4th and 5th queries spell the given word ```aba```. \\n4. The fourth ```true``` is expected because the 5th, 6th and 7th queries spell the given word ```aba```. \\n\\nHopefully, this makes things harder for you :)\\n",
                "solutionTags": [],
                "code": "```[\"baa\",\"aa\",\"aaaa\",\"abbbb\",\"aba\"]```\n```[\\'a\\'],[\\'a\\'],[\\'a\\'],[\\'b\\'],[\\'a\\'],[\\'b\\'],[\\'a\\']```\n```false,true,true,false,true,false,true```\n```true```\n```true```\n```aa```\n```true```\n```aa```\n```true```\n```aba```\n```true```\n```aba```",
                "codeTag": "Unknown"
            },
            {
                "id": 1610834,
                "title": "c-python-3-simple-solution-w-explanation-hashset-trie-rolling-hash",
                "content": "We are given an array of words - `words` and then a stream of letters `c`. For each query, we need to find if any suffix string of query stream formed till now is found in `words` or not.\\n\\n---\\n\\n\\u274C ***Solution - I (Hashset)***\\n\\nWe can insert all the words into hashset and then check if any suffix of query stream exists in hashset or not. For efficiency, we need to insert the words in hashset in reverse order. That\\'s because in the `query` function we will be forming reverse suffix strings starting from the last word in query stream till the 1st word.\\n\\nAlso, since the query stream length can get much longer, we can optimize by only checking for suffix functions which are less than or equal to `L` in length (`L = length of longest word in words`).\\n\\n**C++**\\n```cpp\\nclass StreamChecker {\\n    unordered_set<string> st;\\n    string queryStream = \"\";\\n    int L = 0;\\npublic:\\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            reverse(begin(w), end(w));\\n            st.insert(w);\\n            L = max(L, (int)size(w));\\n        }\\n    }\\n    \\n    bool query(char c) {\\n        queryStream += c;\\n        string suff = \"\";\\n        for(int i = size(queryStream)-1; i >= max(0, (int)size(queryStream)-L); i--) {\\n            suff += queryStream[i];\\n            if(st.count(suff)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.st, self.L, self.qs = {w[::-1] for w in words}, len(max(words, key=len)), \"\"\\n\\n    def query(self, c):\\n        self.qs += c\\n        return any(self.qs[i:][::-1] in self.st for i in range(len(self.qs), max(-1, len(self.qs)-1-self.L), -1))\\n```\\n\\n***Time Complexity :*** \\n1. **`StreamChecker`** : `O(NL)`, where `N` is the number of elements in `words` and `L` is the maximum length of word.\\n2. **`query`** : <code>O(L<sup>2</sup>)</code>, we check for `L` different suffix strings of `queryStream` if each of them exists in hashset or not. It takes `O(L)` time for every string to be checked for existence in hashset\\n\\n\\tThus, the overall time complexity can be written as **<code>O(NL + QL<sup>2</sup>)</code>**, where `Q` is the number of queries\\n\\n***Space Complexity :*** `O(NL + Q)`, for maintaining hashset and query stream. Can be optmized down to `O(NL)` by maintaining query stream only upto length `L`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Trie on Reversed Words)***\\n\\nWe need to check if any suffix of query is found in `words`. In the previous approach, we were checking every reverse suffix string of query stream after a new letter was added in the stream. But we were doing this for many redundant cases as well. \\nFor eg. Consider `words = [\"hello\", \"world\"]` and current query stream is `\"abcsidhbfvdefg\"`. In this case, we were unnecessarily checking for all suffixes such as `\"g\", \"gf\", \"gfe\", \"gfed\", ...` (we were checking suffixes in reverse order) when we know that none of these suffix would match any word in `words` since they dont start from `h` or `w`. This can be generalized to cases where 1st letter matches but 2nd didnt match to any word, and so on...\\n\\nWe need a way to terminate earlier when we find that none of  suffix strings formed further from the current query stream would be found in `words`. This can be achieved by using a Trie. We will firstly insert all the word from `words` into Trie in reversed order. Note that reverse would be more efficient as that allows us to iteratively check existence of reverse suffix string from current query stream by adding one character after another till we either find the word in Trie or terminate when current suffix isnt found. While in the case of storing words without reversing would require us to form every possible suffix of current query stream and check existence in Trie for each one-by-one which would be similar to previous approach.\\n\\nSo, once we form the Trie by inserting reversed words, we keep adding new letters to current query stream and check if the suffix of this stream was present in `words`. \\n* We search in the Trie starting from the last word in current query stream. \\n* If a letter-link from current trie node to next node is found, we move to that node. \\n* This is done iteratively by taking next character from query stream and checking if letter-link for that character exists in Trie. \\n* If at any point we find a word ending at this node (denoted by `endsHere`), we return true as we found a suffix in the Trie.\\n* If we reach end of query stream or we dont find letter-link for next character from stream, then we return false as no suffix was found in Trie.\\n\\n\\n**C++**\\n```cpp\\nclass Trie {\\n    Trie* chars[26]{};\\n    bool endsHere = false;\\npublic:    \\n    void insert(string& s) {                              // inserts a string in Trie\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {                 // insert in reverse order\\n            if(!cur -> chars[s[i]-\\'a\\'])\\n                cur -> chars[s[i]-\\'a\\'] = new Trie();      // add new node for current character\\n            cur = cur -> chars[s[i]-\\'a\\'];                 // move to that character\\'s node\\n        }\\n        cur -> endsHere = true;                           // mark that a word ends at this node\\n    }\\n    bool search(string& s) {                              // searches for a suffix of string\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {\\n            if(!cur -> chars[s[i]-\\'a\\']) return false;     // no letter-link to next character exists\\n            cur = cur -> chars[s[i]-\\'a\\'];\\n            if(cur -> endsHere) return true;              // found a  word ending at this node => suffix of s found in Trie\\n        }\\n        return false;\\n    }\\n};\\nclass StreamChecker {\\n    Trie *T = new Trie();\\n    string queryStream = \"\";\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& w : words) T -> insert(w);\\n    }\\n    \\n    bool query(char c) {\\n        queryStream += c;                                  // add new character to query stream\\n        return T -> search(queryStream);                   // and search for any suffix in Trie\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.chars, self.ends_here = defaultdict(Trie), False\\n    def insert(self, s):\\n        cur = self\\n        for c in reversed(s):\\n            cur = cur.chars[c]\\n        cur.ends_here = True\\n    def search(self, s):\\n        cur = self\\n        for c in s:\\n            if c not in cur.chars: return False\\n            cur = cur.chars[c]\\n            if cur.ends_here: return True\\n    \\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.T, self.query_stream = Trie(), deque()\\n        for w in words:\\n            self.T.insert(w)\\n    def query(self, c):\\n        self.query_stream.appendleft(c)\\n        return self.T.search(self.query_stream)\\n```\\n\\n***Time Complexity :*** \\n1. **`StreamChecker`** : `O(NL)`, where `N` is the number of elements in `words` and `L` is the maximum length of word.\\n2. **`query`** : `O(L)`\\n\\n\\tThus, the overall time complexity can be written as **<code>O(NL + QL)</code>**.\\n\\n***Space Complexity :*** `O(NL + Q)`, for maintaining Trie and query stream. The space complexity can be brought down to `O(NL)` by only maintaining queryStream upto length `L` as follows - \\n\\n<blockquote>\\n<details>\\n<summary><b>Slightly Space-Optimized Version</b></summary>\\n\\n```cpp\\nclass Trie {\\n    Trie* chars[26]{};\\n    int endsHere = false;\\npublic:    \\n    void insert(string& s) {\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {\\n            if(!cur -> chars[s[i]-\\'a\\'])\\n                cur -> chars[s[i]-\\'a\\'] = new Trie();\\n            cur = cur -> chars[s[i]-\\'a\\'];\\n        }\\n        cur -> endsHere = true;\\n    }\\n    bool query(deque<char>& dq) {\\n        auto cur = this;\\n        for(auto c : dq) {\\n            if(!cur -> chars[c-\\'a\\']) return false;\\n            cur = cur -> chars[c-\\'a\\'];\\n            if(cur -> endsHere) return true;\\n        }\\n        return false;\\n    }\\n};\\nclass StreamChecker {\\n    Trie *T = new Trie();\\n    deque<char> queryStream;\\n    int L = 0;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& w : words) \\n            T -> insert(w),\\n            L = max(L, int(size(w)));\\n    }\\n    \\n    bool query(char c) {\\n        queryStream.push_front(c);\\n        if(size(dq) > L) queryStream.pop_back();\\n        return T -> query(queryStream);\\n    }\\n};\\n```\\n\\n***Time Complexity :*** \\n1. **`StreamChecker`** : `O(NL)`\\n2. **`query`** : `O(L)`\\n\\n\\tThus, the overall time complexity can be written as **<code>O(NL + QL)</code>**.\\n\\n***Space Complexity :*** `O(NL)`, for maintaining Trie\\n\\n</details>\\n</blockquote>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Hashset of Rolling Hashes of Suffix)***\\n\\nAs we have seen, the 1st approach failed due to begin unable to terminate early in redundant cases. To optimize this, we can use a custom/rolling hash function and store all suffix hashes of all words in a hashset: `suffixHash`. Finally, we will store the final hash of complete word as well in another hashset: `wordHash`.\\n\\nSimilarly, while checking for existence of suffix in `queryStream`, we will calculate the same rolling hash of suffix of query stream and if at any point the rolling hash is not found in `suffixHash`, we can terminate furter search here itself. If we find a hash that exists in `suffixHash`, then we will check if that hash exists in `wordHash` as well. If we find it there, we can return true since this denotes that we found suffix with same hash as that of an word from `words`.\\n\\nFor calculating rolling hash, we need a good function that gives unique hash to different strings and minimizes the collision. I have used a common hash function used for hashing strings (**[referred from here](https://cp-algorithms.com/string/string-hashing.html)**).\\n\\n**C++**\\n```cpp\\nclass StreamChecker {\\n    unordered_set<int> suffixHash, wordHash;\\n    string queryStream = \"\";\\n\\t// returns rolling hash after adding a new character c\\n    int rollingHash(long& hash, long& p_pow, char c, int mod = 1e9+7) {\\n        p_pow = (p_pow * 31) % mod;\\n        return hash = (hash + (c-\\'a\\'+1) * p_pow) % mod;\\n    }\\npublic:    \\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            long hash = 0, p_pow = 1;\\n            for(int i = size(w)-1; ~i; i--) \\n                suffixHash.insert(rollingHash(hash, p_pow, w[i]));                          // insert all suffix hashes of each word\\n            wordHash.insert(hash);                                                          // complete word hash\\n        }\\n    }\\n    bool query(char c) {\\n        queryStream += c;\\n        for(long i = size(queryStream)-1, hash = 0, p_pow = 1; ~i; i--)             \\n            if(!suffixHash.count(rollingHash(hash, p_pow, queryStream[i]))) return false;   // check if same suffix hash exists in suffixHash set.\\n            else if(wordHash.count(hash)) return true;                                      // check if there\\'s a word with same hash\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass StreamChecker:\\n    def rollingHash(self, Hash, p_pow, c, mod = 1e9+7):\\n        return ((Hash + ord(c) * p_pow) % mod, (p_pow * 31) % mod)\\n\\t\\t\\n    def __init__(self, words):\\n        self.suffix_hash, self.word_hash, self.query_stream = set(), set(), deque()\\n        for w in words:\\n            Hash, p_pow = 0, 1\\n            for c in w[::-1]:\\n                Hash, p_pow = self.rollingHash(Hash, p_pow, c)\\n                self.suffix_hash.add(Hash)\\n            self.word_hash.add(Hash)\\n            \\n    def query(self, c):\\n        self.query_stream.appendleft(c)\\n        Hash, p_pow = 0, 1\\n        for c in self.query_stream:\\n            Hash, p_pow = self.rollingHash(Hash, p_pow, c)\\n            if Hash not in self.suffix_hash: return False\\n            elif Hash in self.word_hash: return True\\n```\\n\\n***Time Complexity :*** \\n1. **`StreamChecker`** : `O(NL)`\\n2. **`query`** : `O(L)`\\n\\n\\tThus, the overall time complexity can be written as **<code>O(NL + QL)</code>**.\\n\\n***Space Complexity :*** `O(NL + Q)`, for maintaining `suffixHash`, `wordHash` & `queryStream`. Can be reduced to `O(NL)` in same way as above.\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass StreamChecker {\\n    unordered_set<string> st;\\n    string queryStream = \"\";\\n    int L = 0;\\npublic:\\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            reverse(begin(w), end(w));\\n            st.insert(w);\\n            L = max(L, (int)size(w));\\n        }\\n    }\\n    \\n    bool query(char c) {\\n        queryStream += c;\\n        string suff = \"\";\\n        for(int i = size(queryStream)-1; i >= max(0, (int)size(queryStream)-L); i--) {\\n            suff += queryStream[i];\\n            if(st.count(suff)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```python\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.st, self.L, self.qs = {w[::-1] for w in words}, len(max(words, key=len)), \"\"\\n\\n    def query(self, c):\\n        self.qs += c\\n        return any(self.qs[i:][::-1] in self.st for i in range(len(self.qs), max(-1, len(self.qs)-1-self.L), -1))\\n```\n```cpp\\nclass Trie {\\n    Trie* chars[26]{};\\n    bool endsHere = false;\\npublic:    \\n    void insert(string& s) {                              // inserts a string in Trie\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {                 // insert in reverse order\\n            if(!cur -> chars[s[i]-\\'a\\'])\\n                cur -> chars[s[i]-\\'a\\'] = new Trie();      // add new node for current character\\n            cur = cur -> chars[s[i]-\\'a\\'];                 // move to that character\\'s node\\n        }\\n        cur -> endsHere = true;                           // mark that a word ends at this node\\n    }\\n    bool search(string& s) {                              // searches for a suffix of string\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {\\n            if(!cur -> chars[s[i]-\\'a\\']) return false;     // no letter-link to next character exists\\n            cur = cur -> chars[s[i]-\\'a\\'];\\n            if(cur -> endsHere) return true;              // found a  word ending at this node => suffix of s found in Trie\\n        }\\n        return false;\\n    }\\n};\\nclass StreamChecker {\\n    Trie *T = new Trie();\\n    string queryStream = \"\";\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& w : words) T -> insert(w);\\n    }\\n    \\n    bool query(char c) {\\n        queryStream += c;                                  // add new character to query stream\\n        return T -> search(queryStream);                   // and search for any suffix in Trie\\n    }\\n};\\n```\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.chars, self.ends_here = defaultdict(Trie), False\\n    def insert(self, s):\\n        cur = self\\n        for c in reversed(s):\\n            cur = cur.chars[c]\\n        cur.ends_here = True\\n    def search(self, s):\\n        cur = self\\n        for c in s:\\n            if c not in cur.chars: return False\\n            cur = cur.chars[c]\\n            if cur.ends_here: return True\\n    \\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.T, self.query_stream = Trie(), deque()\\n        for w in words:\\n            self.T.insert(w)\\n    def query(self, c):\\n        self.query_stream.appendleft(c)\\n        return self.T.search(self.query_stream)\\n```\n```cpp\\nclass Trie {\\n    Trie* chars[26]{};\\n    int endsHere = false;\\npublic:    \\n    void insert(string& s) {\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {\\n            if(!cur -> chars[s[i]-\\'a\\'])\\n                cur -> chars[s[i]-\\'a\\'] = new Trie();\\n            cur = cur -> chars[s[i]-\\'a\\'];\\n        }\\n        cur -> endsHere = true;\\n    }\\n    bool query(deque<char>& dq) {\\n        auto cur = this;\\n        for(auto c : dq) {\\n            if(!cur -> chars[c-\\'a\\']) return false;\\n            cur = cur -> chars[c-\\'a\\'];\\n            if(cur -> endsHere) return true;\\n        }\\n        return false;\\n    }\\n};\\nclass StreamChecker {\\n    Trie *T = new Trie();\\n    deque<char> queryStream;\\n    int L = 0;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& w : words) \\n            T -> insert(w),\\n            L = max(L, int(size(w)));\\n    }\\n    \\n    bool query(char c) {\\n        queryStream.push_front(c);\\n        if(size(dq) > L) queryStream.pop_back();\\n        return T -> query(queryStream);\\n    }\\n};\\n```\n```cpp\\nclass StreamChecker {\\n    unordered_set<int> suffixHash, wordHash;\\n    string queryStream = \"\";\\n\\t// returns rolling hash after adding a new character c\\n    int rollingHash(long& hash, long& p_pow, char c, int mod = 1e9+7) {\\n        p_pow = (p_pow * 31) % mod;\\n        return hash = (hash + (c-\\'a\\'+1) * p_pow) % mod;\\n    }\\npublic:    \\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            long hash = 0, p_pow = 1;\\n            for(int i = size(w)-1; ~i; i--) \\n                suffixHash.insert(rollingHash(hash, p_pow, w[i]));                          // insert all suffix hashes of each word\\n            wordHash.insert(hash);                                                          // complete word hash\\n        }\\n    }\\n    bool query(char c) {\\n        queryStream += c;\\n        for(long i = size(queryStream)-1, hash = 0, p_pow = 1; ~i; i--)             \\n            if(!suffixHash.count(rollingHash(hash, p_pow, queryStream[i]))) return false;   // check if same suffix hash exists in suffixHash set.\\n            else if(wordHash.count(hash)) return true;                                      // check if there\\'s a word with same hash\\n        \\n        return false;\\n    }\\n};\\n```\n```python\\nclass StreamChecker:\\n    def rollingHash(self, Hash, p_pow, c, mod = 1e9+7):\\n        return ((Hash + ord(c) * p_pow) % mod, (p_pow * 31) % mod)\\n\\t\\t\\n    def __init__(self, words):\\n        self.suffix_hash, self.word_hash, self.query_stream = set(), set(), deque()\\n        for w in words:\\n            Hash, p_pow = 0, 1\\n            for c in w[::-1]:\\n                Hash, p_pow = self.rollingHash(Hash, p_pow, c)\\n                self.suffix_hash.add(Hash)\\n            self.word_hash.add(Hash)\\n            \\n    def query(self, c):\\n        self.query_stream.appendleft(c)\\n        Hash, p_pow = 0, 1\\n        for c in self.query_stream:\\n            Hash, p_pow = self.rollingHash(Hash, p_pow, c)\\n            if Hash not in self.suffix_hash: return False\\n            elif Hash in self.word_hash: return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610403,
                "title": "java-simple-solution-trie-detailed-explanation-using-image",
                "content": "**Intution:** We gonna use trie data structure to store the given words for easy searching. So firstly store all the given words in Trie but the catch here is that store every word in **reverse order** because you have to search for prefix every time so u don\\'t have to search full trie from starting to just find last few characters.\\nAfter filling trie now using query function read the next coming letter and append it to your StringBuilder and check for the current String/stream if it is present in trie or not.\\n** One more important thing here is that Don\\'t just keep adding letters in your StringBuilder....find the **maxLength** from given words array and don\\'t let the size of StringBuider increase more than that...otherwise it will give you TLE due to memory out of space problem as StringBuilder will keep growing otherwise.\\n\\n![image](https://assets.leetcode.com/users/images/1a4384df-5692-4ecb-9499-25ad65143da4_1638581642.2779667.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/479a1cef-6bab-4c16-9b9f-5422bc9f9144_1638581652.3289752.jpeg)\\n\\n\\n```\\nclass StreamChecker {\\n\\n    class TrieNode{\\n        boolean isWord;\\n        TrieNode children[] = new TrieNode[26];\\n    }\\n    \\n    TrieNode root = new TrieNode();\\n    int maxSize;\\n    StringBuilder sb = new StringBuilder();\\n    \\n    public StreamChecker(String[] words) {\\n        insert(words);\\n    }\\n    \\n    public boolean query(char letter) {\\n        if(sb.length()>=maxSize){\\n            sb.deleteCharAt(0);\\n        }\\n        sb.append(letter);\\n        TrieNode curr = root;\\n        \\n        for(int i=sb.length()-1;i>=0;i--){\\n            char ch = sb.charAt(i);\\n            \\n            if(curr!=null) curr = curr.children[ch-\\'a\\'];\\n            \\n            if(curr!=null && curr.isWord) return true;\\n        }\\n        return false;\\n    }\\n    \\n    public void insert(String[] words){\\n        \\n        for(String s : words){\\n            maxSize = Math.max(maxSize,s.length());\\n            TrieNode curr = root;\\n            for(int i = s.length()-1;i>=0;i--){\\n                char ch = s.charAt(i);\\n                if(curr.children[ch-\\'a\\']==null){\\n                    curr.children[ch-\\'a\\'] = new TrieNode();\\n                }\\n                curr = curr.children[ch-\\'a\\'];\\n            }\\n            curr.isWord = true;\\n        }\\n    }\\n}\\n```\\n\\nI hope this helped u in uderstanding this question...Thanks!!",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n\\n    class TrieNode{\\n        boolean isWord;\\n        TrieNode children[] = new TrieNode[26];\\n    }\\n    \\n    TrieNode root = new TrieNode();\\n    int maxSize;\\n    StringBuilder sb = new StringBuilder();\\n    \\n    public StreamChecker(String[] words) {\\n        insert(words);\\n    }\\n    \\n    public boolean query(char letter) {\\n        if(sb.length()>=maxSize){\\n            sb.deleteCharAt(0);\\n        }\\n        sb.append(letter);\\n        TrieNode curr = root;\\n        \\n        for(int i=sb.length()-1;i>=0;i--){\\n            char ch = sb.charAt(i);\\n            \\n            if(curr!=null) curr = curr.children[ch-\\'a\\'];\\n            \\n            if(curr!=null && curr.isWord) return true;\\n        }\\n        return false;\\n    }\\n    \\n    public void insert(String[] words){\\n        \\n        for(String s : words){\\n            maxSize = Math.max(maxSize,s.length());\\n            TrieNode curr = root;\\n            for(int i = s.length()-1;i>=0;i--){\\n                char ch = s.charAt(i);\\n                if(curr.children[ch-\\'a\\']==null){\\n                    curr.children[ch-\\'a\\'] = new TrieNode();\\n                }\\n                curr = curr.children[ch-\\'a\\'];\\n            }\\n            curr.isWord = true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278928,
                "title": "screencast-of-leetcode-weekly-contest-133-face-jk",
                "content": "https://www.youtube.com/watch?v=sv028Ula0Ng",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=sv028Ula0Ng",
                "codeTag": "Unknown"
            },
            {
                "id": 807541,
                "title": "python-trie-with-reversed-words-explained",
                "content": "It is pretty straightforward to use Tries for these type of problems, however it is not obvious how. My first solution was as it is given in the hint of this problem: create Trie of all given words and keep also set of all possible nodes in our trie for suffixes of our stream. However it was working very slow, >10000ms initialy and 7000-9000ms after optimizations. \\n\\nSo, alternative idea is to put all our words to Trie in reversed order. Why it can be a good idea? Imagine we have a current stream `abcdefghij` and we have dictionary `[hij, xyz, abc, hijk]` Then what we need to check if some suffix of this word in our dictinonary. It means that `jihgfedcba` should have `jih` as prefix. If we add one letter to strim, so we have `abcdefghijk`, we need to find prefixes in `kjihgfedcba` and so on.\\n\\nSo, what we have in my code?\\n\\n1. `Trie` class with initialization and `insert` function. Each node has children and flag `.end_node`, which says if some word ends with this node.\\n2. Put all reversed words to our Trie\\n3. For each new element of stream, we keep it in `deque`, so we can easily add it to the left of our reversed stream. Then we traverse our `Trie` and look if we reached some end node.\\n\\n**Complexity**: Let `m` be the longest length of word and `n` be number of words. Also let `w` be number of `query(letter)`. Then space complexity is `O(mn + w)` to keep our tree. In fact we can cut our `deque` if it has length more than `m`, because we never reach nodes which are far in our deque. Time complexity is `O(wm)`, because for each of `w` queries we need to  traverse at most `m` letters in our trie.\\n\\nNote that other method complexity I mentioned in the beginning in theory is also `O(wm)`, but in practise it works like `10` times slower. The problem is with tests like `aaaaaa...aaab`.\\n\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children, self.end_node = {}, 0\\n         \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        root = self.root\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n        root.end_node = 1\\n\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.trie = Trie()\\n        self.Stream = deque()\\n        for word in words: self.trie.insert(word[::-1])\\n         \\n    def query(self, letter):\\n        self.Stream.appendleft(letter)\\n        cur = self.trie.root\\n        for c in self.Stream:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                if cur.end_node: return True\\n            else: break\\n        return False\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children, self.end_node = {}, 0\\n         \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        root = self.root\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n        root.end_node = 1\\n\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.trie = Trie()\\n        self.Stream = deque()\\n        for word in words: self.trie.insert(word[::-1])\\n         \\n    def query(self, letter):\\n        self.Stream.appendleft(letter)\\n        cur = self.trie.root\\n        for c in self.Stream:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                if cur.end_node: return True\\n            else: break\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807322,
                "title": "python-by-search-in-trie-w-visualization",
                "content": "Python by search in Trie\\n\\n---\\n\\n**Hint**:\\n\\nBecause [description](https://leetcode.com/problems/stream-of-characters/) asks us to search from tail, the **last k characters** queried, where k >= 1,\\nwe build a trie and search word in **reversed order** to satisfy the requirement.\\n\\n---\\n\\n**Visualization**\\n\\n![image](https://assets.leetcode.com/users/images/59b20265-1fb8-4207-8a1e-6b53b706089c_1598183327.0370915.png)\\n\\n![image](https://assets.leetcode.com/users/images/7ed60434-2301-4828-ac1a-15718fa06152_1598183418.2371585.png)\\n\\n![image](https://assets.leetcode.com/users/images/d5474a12-a01d-46c9-9732-4ec109ae73ce_1598183427.5589814.png)\\n\\n![image](https://assets.leetcode.com/users/images/0689b1dc-f22f-448c-a7c1-7df0110b3a53_1598183437.320374.png)\\n\\n![image](https://assets.leetcode.com/users/images/852bb69c-d2df-4dee-882a-6ba68f6f708b_1598183447.3071404.png)\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    \\n    def __init__(self):\\n        \\n        self.dict = defaultdict(TrieNode)\\n        self.is_word = False\\n\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        \\'\\'\\'\\n        Build a trie for each word in reversed order\\n        \\'\\'\\'\\n\\t\\t\\n        # for user query record, init as empty string\\n        self.prefix = \\'\\'\\n        \\n        # for root node of trie, init as empty Trie\\n        self.trie = TrieNode()\\n        \\n        for word in words:\\n            \\n            cur_node = self.trie\\n            \\n\\t\\t\\t# make word in reverse order\\n            word = word[::-1]\\n            \\n            for char in word:                \\n                cur_node = cur_node.dict[ char ]\\n            \\n\\t\\t\\t# mark this trie path as a valid word\\n            cur_node.is_word = True\\n            \\n            \\n            \\n    def query(self, letter: str) -> bool:\\n        \\'\\'\\'\\n        Search user input in trie with reversed order\\n        \\'\\'\\'\\n\\t\\t\\n        self.prefix += letter\\n        \\n        cur_node = self.trie\\n        for char in reversed(self.prefix):\\n            \\n            if char not in cur_node.dict:\\n                # current char not in Trie, impossible to match words\\n                break\\n            \\n            cur_node = cur_node.dict[char]\\n        \\n            if cur_node.is_word:\\n                # user input match a word in Trie\\n                return True\\n        \\n        # No match\\n        return False\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Trie](https://en.wikipedia.org/wiki/Trie)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Trie"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    \\n    def __init__(self):\\n        \\n        self.dict = defaultdict(TrieNode)\\n        self.is_word = False\\n\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        \\'\\'\\'\\n        Build a trie for each word in reversed order\\n        \\'\\'\\'\\n\\t\\t\\n        # for user query record, init as empty string\\n        self.prefix = \\'\\'\\n        \\n        # for root node of trie, init as empty Trie\\n        self.trie = TrieNode()\\n        \\n        for word in words:\\n            \\n            cur_node = self.trie\\n            \\n\\t\\t\\t# make word in reverse order\\n            word = word[::-1]\\n            \\n            for char in word:                \\n                cur_node = cur_node.dict[ char ]\\n            \\n\\t\\t\\t# mark this trie path as a valid word\\n            cur_node.is_word = True\\n            \\n            \\n            \\n    def query(self, letter: str) -> bool:\\n        \\'\\'\\'\\n        Search user input in trie with reversed order\\n        \\'\\'\\'\\n\\t\\t\\n        self.prefix += letter\\n        \\n        cur_node = self.trie\\n        for char in reversed(self.prefix):\\n            \\n            if char not in cur_node.dict:\\n                # current char not in Trie, impossible to match words\\n                break\\n            \\n            cur_node = cur_node.dict[char]\\n        \\n            if cur_node.is_word:\\n                # user input match a word in Trie\\n                return True\\n        \\n        # No match\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278738,
                "title": "python-ac-concise-straightforward",
                "content": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.s = \\'\\'\\n        self.dic = collections.defaultdict(set)\\n        for w in words:\\n            self.dic[w[-1]].add(w)\\n                \\n\\n    def query(self, letter: str) -> bool:\\n        self.s += letter\\n        return any(self.s.endswith(w) for w in self.dic[letter])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.s = \\'\\'\\n        self.dic = collections.defaultdict(set)\\n        for w in words:\\n            self.dic[w[-1]].add(w)\\n                \\n\\n    def query(self, letter: str) -> bool:\\n        self.s += letter\\n        return any(self.s.endswith(w) for w in self.dic[letter])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278893,
                "title": "trie-reverse-check-and-track-pointers",
                "content": "# Reverse Check Solution\\nWe reverse our strings and populate Trie. Then, we accumulate the query string and search in Trie in the reverse order.\\n```\\nclass Trie {\\npublic:\\n  Trie *arr[26] = {};\\n  bool end = false;\\n  void insert(string &word, int pos = 0) {\\n    if (pos == word.size()) end = true;\\n    else {\\n      auto idx = word[pos] - \\'a\\';\\n      if (arr[idx] == nullptr) arr[idx] = new Trie();\\n      arr[idx]->insert(word, pos + 1);\\n    }\\n  }\\n  bool reverse_check(string &word, int pos) {\\n    if (end || pos == -1) return end;\\n    auto idx = word[pos] - \\'a\\';\\n    if (arr[idx] == nullptr) return false;\\n    else return arr[idx]->reverse_check(word, pos - 1);\\n  }\\n};\\nTrie root;\\nstring word;\\nStreamChecker(vector<string>& words) {\\n  for (auto w : words) {\\n    reverse(begin(w), end(w));\\n    root.insert(w);\\n  }\\n}\\nbool query(char letter) {\\n  word += letter;\\n  return root.reverse_check(word, word.size() - 1);\\n}\\n```\\n# Track Pointers Solution\\nInstead of accumulating the query, we can just track Trie pointers and advance them when we receive a query. This solution is accepted, but the runtime is much higher than for the first one. I think, however, that for some inputs, this solution could be more efficient.\\n```\\nclass Trie {\\npublic:\\n  Trie *arr[26] = {};\\n  bool end = false;\\n  void insert(string &word, int pos = 0) {\\n    if (pos == word.size()) end = true;\\n    else {\\n      auto idx = word[pos] - \\'a\\';\\n      if (arr[idx] == nullptr) arr[idx] = new Trie();\\n      arr[idx]->insert(word, pos + 1);\\n    }\\n  }\\n};\\nTrie root;\\nvector<Trie*> pts = { &root };\\nStreamChecker(vector<string>& words) {\\n  for (auto &w : words) root.insert(w);\\n}\\nbool query(char letter, bool res = false) {\\n  vector<Trie*> next_pts = { &root };\\n  for (auto t : pts) {\\n    auto n_t = t->arr[letter - \\'a\\'];\\n    if (n_t != nullptr) {\\n      if (n_t->end) res = true;\\n      next_pts.push_back(n_t);\\n    }\\n  }\\n  swap(pts, next_pts);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\npublic:\\n  Trie *arr[26] = {};\\n  bool end = false;\\n  void insert(string &word, int pos = 0) {\\n    if (pos == word.size()) end = true;\\n    else {\\n      auto idx = word[pos] - \\'a\\';\\n      if (arr[idx] == nullptr) arr[idx] = new Trie();\\n      arr[idx]->insert(word, pos + 1);\\n    }\\n  }\\n  bool reverse_check(string &word, int pos) {\\n    if (end || pos == -1) return end;\\n    auto idx = word[pos] - \\'a\\';\\n    if (arr[idx] == nullptr) return false;\\n    else return arr[idx]->reverse_check(word, pos - 1);\\n  }\\n};\\nTrie root;\\nstring word;\\nStreamChecker(vector<string>& words) {\\n  for (auto w : words) {\\n    reverse(begin(w), end(w));\\n    root.insert(w);\\n  }\\n}\\nbool query(char letter) {\\n  word += letter;\\n  return root.reverse_check(word, word.size() - 1);\\n}\\n```\n```\\nclass Trie {\\npublic:\\n  Trie *arr[26] = {};\\n  bool end = false;\\n  void insert(string &word, int pos = 0) {\\n    if (pos == word.size()) end = true;\\n    else {\\n      auto idx = word[pos] - \\'a\\';\\n      if (arr[idx] == nullptr) arr[idx] = new Trie();\\n      arr[idx]->insert(word, pos + 1);\\n    }\\n  }\\n};\\nTrie root;\\nvector<Trie*> pts = { &root };\\nStreamChecker(vector<string>& words) {\\n  for (auto &w : words) root.insert(w);\\n}\\nbool query(char letter, bool res = false) {\\n  vector<Trie*> next_pts = { &root };\\n  for (auto t : pts) {\\n    auto n_t = t->arr[letter - \\'a\\'];\\n    if (n_t != nullptr) {\\n      if (n_t->end) res = true;\\n      next_pts.push_back(n_t);\\n    }\\n  }\\n  swap(pts, next_pts);\\n  return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278842,
                "title": "c-ac-automaton-solution-amortized-time-complexity-o-1",
                "content": "https://www.wikiwand.com/en/Aho%E2%80%93Corasick_algorithm\\nThink KMP as a special linear case of AC automaton.\\n\\nAmortized time complexity for each query is O(1)\\n\\n\\n```\\nclass StreamChecker {\\npublic:\\n    vector<unordered_map<char, int>> trie;\\n    vector<bool> term;\\n    vector<int> fail;\\n    int curPos;\\n\\n    StreamChecker(vector<string>& words) {\\n\\t    // Build the Trie\\n        int total = 0;\\n        unordered_map<char, int> root;\\n        this->trie.push_back(root);\\n        this->term.push_back(false);\\n        this->fail.push_back(0);\\n        for (string word : words) {\\n            int cur = 0;\\n            for (char c : word) {\\n                if (this->trie[cur].find(c) != this->trie[cur].end()) {\\n                    cur = this->trie[cur][c];\\n                } else {\\n                    unordered_map<char, int> newNode;\\n                    this->trie.push_back(newNode);\\n                    this->term.push_back(false);\\n                    total++;\\n                    this->trie[cur][c] = total;\\n                    cur = total;\\n                }\\n            }\\n            this->term[cur] = true;\\n        }\\n\\n        // Maintain fail pointer, so each time when an attempting further match fail,\\n\\t\\t// jump to the position where the longest suffix of current path is a prefix in the Trie.\\n        for (int i = 0; i < this->trie.size(); i++) {\\n            this->fail.push_back(0);\\n        }\\n\\t\\t// Need follow BFS order to create failing pointers so that upper level nodes\\n\\t\\t// should  have their correct failing jumping positions when processing a lower node in Trie.\\n        queue<pair<int, unordered_map<char, int>>> nodes;\\n        for (auto kv: this->trie[0]) {\\n            auto o = make_pair(kv.second, this->trie[kv.second]);\\n            nodes.push(o);   \\n        }\\n        while (!nodes.empty()) {\\n            auto p = nodes.front();\\n            nodes.pop();\\n            auto i = p.first;\\n            auto node = p.second;\\n            for (auto kv : node) {\\n                auto pp = make_pair(kv.second, this->trie[kv.second]);\\n                nodes.push(pp);\\n            }\\n            for (auto kv : node) {\\n                char child = kv.first;\\n                int pos = kv.second;\\n                int f = this->fail[i];\\n\\t\\t\\t\\t// Very similar with KMP algorithm to find the failing position, but here the jumping can\\n\\t\\t\\t\\t// be anywhere on the Trie.\\n                while (f != 0 && this->trie[f].find(child) == trie[f].end()) {\\n                    f = this->fail[f];\\n                }\\n                if (this->trie[f].find(child) != trie[f].end()) {\\n                    f = this->trie[f][child];\\n                }\\n                this->fail[pos] = f;\\n\\t\\t\\t\\t// Here we inherit the termination flag from failing position, so that if any node in the failing\\n\\t\\t\\t\\t// chain is a valid word, the current position will yield a true answer.\\n                if (this->term[this->fail[pos]]) {\\n                    this->term[pos] = true;\\n                }\\n            }\\n        }\\n        this->curPos = 0;\\n    }\\n\\n    \\n    bool query(char letter) {\\n\\t    // Find the matching position on Trie.\\n        while (this->curPos > 0 && this->trie[this->curPos].find(letter) == this->trie[this->curPos].end()) {\\n            this->curPos = this->fail[this->curPos];\\n        }\\n        if (this->trie[this->curPos].find(letter) != this->trie[this->curPos].end()) {\\n            this->curPos = this->trie[this->curPos][letter];\\n        }\\n\\t\\t\\n        return this->term[this->curPos];\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n ```\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    vector<unordered_map<char, int>> trie;\\n    vector<bool> term;\\n    vector<int> fail;\\n    int curPos;\\n\\n    StreamChecker(vector<string>& words) {\\n\\t    // Build the Trie\\n        int total = 0;\\n        unordered_map<char, int> root;\\n        this->trie.push_back(root);\\n        this->term.push_back(false);\\n        this->fail.push_back(0);\\n        for (string word : words) {\\n            int cur = 0;\\n            for (char c : word) {\\n                if (this->trie[cur].find(c) != this->trie[cur].end()) {\\n                    cur = this->trie[cur][c];\\n                } else {\\n                    unordered_map<char, int> newNode;\\n                    this->trie.push_back(newNode);\\n                    this->term.push_back(false);\\n                    total++;\\n                    this->trie[cur][c] = total;\\n                    cur = total;\\n                }\\n            }\\n            this->term[cur] = true;\\n        }\\n\\n        // Maintain fail pointer, so each time when an attempting further match fail,\\n\\t\\t// jump to the position where the longest suffix of current path is a prefix in the Trie.\\n        for (int i = 0; i < this->trie.size(); i++) {\\n            this->fail.push_back(0);\\n        }\\n\\t\\t// Need follow BFS order to create failing pointers so that upper level nodes\\n\\t\\t// should  have their correct failing jumping positions when processing a lower node in Trie.\\n        queue<pair<int, unordered_map<char, int>>> nodes;\\n        for (auto kv: this->trie[0]) {\\n            auto o = make_pair(kv.second, this->trie[kv.second]);\\n            nodes.push(o);   \\n        }\\n        while (!nodes.empty()) {\\n            auto p = nodes.front();\\n            nodes.pop();\\n            auto i = p.first;\\n            auto node = p.second;\\n            for (auto kv : node) {\\n                auto pp = make_pair(kv.second, this->trie[kv.second]);\\n                nodes.push(pp);\\n            }\\n            for (auto kv : node) {\\n                char child = kv.first;\\n                int pos = kv.second;\\n                int f = this->fail[i];\\n\\t\\t\\t\\t// Very similar with KMP algorithm to find the failing position, but here the jumping can\\n\\t\\t\\t\\t// be anywhere on the Trie.\\n                while (f != 0 && this->trie[f].find(child) == trie[f].end()) {\\n                    f = this->fail[f];\\n                }\\n                if (this->trie[f].find(child) != trie[f].end()) {\\n                    f = this->trie[f][child];\\n                }\\n                this->fail[pos] = f;\\n\\t\\t\\t\\t// Here we inherit the termination flag from failing position, so that if any node in the failing\\n\\t\\t\\t\\t// chain is a valid word, the current position will yield a true answer.\\n                if (this->term[this->fail[pos]]) {\\n                    this->term[pos] = true;\\n                }\\n            }\\n        }\\n        this->curPos = 0;\\n    }\\n\\n    \\n    bool query(char letter) {\\n\\t    // Find the matching position on Trie.\\n        while (this->curPos > 0 && this->trie[this->curPos].find(letter) == this->trie[this->curPos].end()) {\\n            this->curPos = this->fail[this->curPos];\\n        }\\n        if (this->trie[this->curPos].find(letter) != this->trie[this->curPos].end()) {\\n            this->curPos = this->trie[this->curPos][letter];\\n        }\\n\\t\\t\\n        return this->term[this->curPos];\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 278753,
                "title": "c-using-trie-reverse-dictionary-words-with-pruning-stream-data",
                "content": "\\tclass Trie {\\n\\t\\tunordered_map<char, Trie *> char_map;\\n\\t\\tbool word_ends;\\n\\tpublic:\\n\\t\\tTrie() {\\n\\t\\t\\tword_ends = false;\\n\\t\\t}\\n\\n\\t\\tvoid insert(string word) {\\n\\t\\t\\tif(word.length() == 0)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tTrie *temp = this;\\n\\t\\t\\tfor(auto ch : word) {\\n\\t\\t\\t\\tif(temp->char_map.find(ch) != temp->char_map.end()) {\\n\\t\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttemp->char_map[ch] = new Trie();\\n\\t\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\ttemp->word_ends = true;\\n\\t\\t}\\n\\n\\t\\tbool search(string word) {\\n\\t\\t\\tif(word.length() == 0)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tTrie *temp = this;\\n\\t\\t\\tfor(auto ch : word) {\\n\\t\\t\\t\\tif(temp->char_map.find(ch) == temp->char_map.end())\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\tif(temp->word_ends)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn temp->word_ends;\\n\\t\\t}\\n\\t};\\n\\n\\tclass StreamChecker {\\n\\t\\tTrie my_trie;\\n\\t\\tstring str = \"\";\\n\\t\\tint w_len = 0;\\n\\tpublic:\\n\\t\\tStreamChecker(vector<string>& words) {\\n\\t\\t\\tfor(auto w : words) {\\n\\t\\t\\t\\treverse(w.begin(), w.end());\\n\\t\\t\\t\\tw_len = max(w_len, (int)w.length());\\n\\t\\t\\t\\tmy_trie.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbool query(char letter) {\\n\\t\\t\\tstr = letter + str;\\n\\n\\t\\t\\tif(str.length() > w_len)\\n\\t\\t\\t\\tstr.pop_back();\\n\\n\\t\\t\\treturn my_trie.search(str);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "\\tclass Trie {\\n\\t\\tunordered_map<char, Trie *> char_map;\\n\\t\\tbool word_ends;\\n\\tpublic:\\n\\t\\tTrie() {\\n\\t\\t\\tword_ends = false;\\n\\t\\t}\\n\\n\\t\\tvoid insert(string word) {\\n\\t\\t\\tif(word.length() == 0)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tTrie *temp = this;\\n\\t\\t\\tfor(auto ch : word) {\\n\\t\\t\\t\\tif(temp->char_map.find(ch) != temp->char_map.end()) {\\n\\t\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttemp->char_map[ch] = new Trie();\\n\\t\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\ttemp->word_ends = true;\\n\\t\\t}\\n\\n\\t\\tbool search(string word) {\\n\\t\\t\\tif(word.length() == 0)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tTrie *temp = this;\\n\\t\\t\\tfor(auto ch : word) {\\n\\t\\t\\t\\tif(temp->char_map.find(ch) == temp->char_map.end())\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\tif(temp->word_ends)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn temp->word_ends;\\n\\t\\t}\\n\\t};\\n\\n\\tclass StreamChecker {\\n\\t\\tTrie my_trie;\\n\\t\\tstring str = \"\";\\n\\t\\tint w_len = 0;\\n\\tpublic:\\n\\t\\tStreamChecker(vector<string>& words) {\\n\\t\\t\\tfor(auto w : words) {\\n\\t\\t\\t\\treverse(w.begin(), w.end());\\n\\t\\t\\t\\tw_len = max(w_len, (int)w.length());\\n\\t\\t\\t\\tmy_trie.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbool query(char letter) {\\n\\t\\t\\tstr = letter + str;\\n\\n\\t\\t\\tif(str.length() > w_len)\\n\\t\\t\\t\\tstr.pop_back();\\n\\n\\t\\t\\treturn my_trie.search(str);\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 407851,
                "title": "c-java-python-trie-with-reverse-words-clean-code-easy-to-understand",
                "content": "<iframe src=\"https://leetcode.com/playground/6dJbCPhF/shared\" frameBorder=\"0\" width=\"100%\" height=\"800\"></iframe>\\n\\nComplexity:\\n- Time: `O(N * W + Q * W)`, where `N <= 2000` is number of words, `W <= 200` is length of a word, `Q <= 4*10^4` is number of quies.\\n- Space: `O(N * W)`",
                "solutionTags": [
                    "Trie"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/6dJbCPhF/shared\" frameBorder=\"0\" width=\"100%\" height=\"800\"></iframe>\\n\\nComplexity:\\n- Time: `O(N * W + Q * W)`, where `N <= 2000` is number of words, `W <= 200` is length of a word, `Q <= 4*10^4` is number of quies.\\n- Space: `O(N * W)`",
                "codeTag": "Unknown"
            },
            {
                "id": 1610378,
                "title": "c-simple-solution-trie-approach-faster-than-97-74",
                "content": "Firstly, thanks for refering to my solution, in advance :)\\n\\n* The idea is to store the words in reverse order in the Trie, so that finding suffix from stream of characters will be easy.\\n* We store the characters from the input stream in a string and start seraching the words from the end of the string.\\n* If a character is not found, we return false.\\n* If a character is found we move to the next character.\\n* When we reach the end of a word (We use a bool variable ```flag```, and set it to true if we reach the end of a word) we return true because a suffix of these characters is a string of a given array of strings \"words\".\\n\\n**Time Complexity :**  O(N*x*M + M*x*Q) ; where -> N = no. of words in ```words``` and M = length of each word and Q = no. of queries from cin\\n\\n**Space Complexity :** O(N*x*M)\\n\\n**Code :**\\n```\\nclass Node{\\n    Node *arr[26];\\n    bool flag = false;\\npublic:\\n    \\n    bool contains(char ch){ return arr[ch-\\'a\\'] != NULL; }\\n    \\n    void put(char ch, Node *newNode){ arr[ch - \\'a\\'] = newNode;}\\n    \\n    Node *getNext(char ch){return arr[ch-\\'a\\'];}\\n    \\n    bool getFlag(){ return flag;}\\n    \\n    void setFlag(){ flag = true;} \\n\\t\\n};\\nclass StreamChecker {\\npublic:\\n    string streamString = \"\";\\n    Node *root;\\n    \\n    void insert(string s){\\n        Node *temp = root;\\n        for(int i=s.size()-1;i>=0;i--){  //insert in reverse order\\n            if(!temp->contains(s[i])) temp->put(s[i], new Node());\\n            temp = temp->getNext(s[i]);\\n        }\\n        temp->setFlag();//set flag if you reach end of the string\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new Node();\\n        for(auto word : words) insert(word);\\n        \\n    }\\n    \\n    bool query(char letter) {\\n        streamString += letter;\\n        Node *temp = root;\\n        //search from the end of the string\\n        for(int i=streamString.size()-1;i>=0&&temp;i--){\\n            if(!temp && !temp->contains(streamString[i])) return false;\\n            \\n            temp = temp->getNext(streamString[i]);\\n            if(temp && temp->getFlag()) return true; //return true if you\\'ve reached the end\\n        }\\n        return false;    \\n    }\\n};\\n```\\n\\nIf you like my solution, please upvote!! It keeps me motivated to post solutions everyday!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```flag```\n```words```\n```\\nclass Node{\\n    Node *arr[26];\\n    bool flag = false;\\npublic:\\n    \\n    bool contains(char ch){ return arr[ch-\\'a\\'] != NULL; }\\n    \\n    void put(char ch, Node *newNode){ arr[ch - \\'a\\'] = newNode;}\\n    \\n    Node *getNext(char ch){return arr[ch-\\'a\\'];}\\n    \\n    bool getFlag(){ return flag;}\\n    \\n    void setFlag(){ flag = true;} \\n\\t\\n};\\nclass StreamChecker {\\npublic:\\n    string streamString = \"\";\\n    Node *root;\\n    \\n    void insert(string s){\\n        Node *temp = root;\\n        for(int i=s.size()-1;i>=0;i--){  //insert in reverse order\\n            if(!temp->contains(s[i])) temp->put(s[i], new Node());\\n            temp = temp->getNext(s[i]);\\n        }\\n        temp->setFlag();//set flag if you reach end of the string\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new Node();\\n        for(auto word : words) insert(word);\\n        \\n    }\\n    \\n    bool query(char letter) {\\n        streamString += letter;\\n        Node *temp = root;\\n        //search from the end of the string\\n        for(int i=streamString.size()-1;i>=0&&temp;i--){\\n            if(!temp && !temp->contains(streamString[i])) return false;\\n            \\n            temp = temp->getNext(streamString[i]);\\n            if(temp && temp->getFlag()) return true; //return true if you\\'ve reached the end\\n        }\\n        return false;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513463,
                "title": "c-trie-approach-with-explanation",
                "content": "The idea is to hang all the words up side down (reversely) in a tree, and the smart part is **not to use the char as the key to reference each letter**, instead use the offset value from letter `a` as index so you can nicely use a `TreeNode[26] ` to represent `a-z` and it will be super easy to query each letter later.\\n\\nFor example, for input words [\"hello\", \"my\", \"weird\", \"world\"] we can have a TreeNode as below (of cause the letter will be replaced by integer index). If you ask why up side down? Because this question requires searching from the end of the query string.\\n```\\n                                     root\\n\\t\\t\\t\\t\\t\\t\\t    o     y     d\\n\\t\\t\\t\\t\\t\\t       l      m     r  l\\n\\t\\t\\t\\t\\t\\t      l             i    r\\n\\t\\t\\t\\t\\t\\t\\t e              e      o\\n\\t\\t\\t\\t\\t\\t\\th               w        w\\n```\\n\\nIt is easy to see the effeciency of this structure, consider you have 26 words, each ends by different letter from a to z, then by storing the last char of the words into a array of `TreeNode[26]` when you read the last query letter and convert it to index by using `letter - \\'a\\'` you automatically filtered out all 25 other words that are not end by the letter.  \\n\\n```\\npublic class StreamChecker{\\n    readonly TreeNode root = new TreeNode();\\n    readonly IList<char> _query = new List<char>();\\n\\n    public StreamChecker(string[] words) {\\n        foreach (var s in words) {\\n            TreeNode cur = root;\\n            for (int j = s.Length - 1; j >= 0; j--) {  // save word in reverse by converting each letter a index\\n                int i = s[j] - \\'a\\';                   \\n                if (cur.Children[i] == null) cur.Children[i] = new TreeNode();\\n                cur = cur.Children[i];\\n            }\\n            cur.EndOfWord = true;                      // at the first letter of each word set this flag to true\\n                                                       // and later use it to determine matching a word or not\\n        }\\n    }\\n\\n    public bool Query(char letter) {\\n        _query.Add(letter);\\n        TreeNode cur = root;\\n        for (int i = _query.Count - 1; i >= 0; i--) {\\n            int j = _query[i] - \\'a\\';\\n            if (cur.Children[j] == null) return false;\\n            cur = cur.Children[j];\\n            if (cur.EndOfWord) return true;\\n        }\\n        return false;\\n    }\\n\\n    class TreeNode {\\n        public TreeNode[] Children = new TreeNode[26]; // we will only have letter a to z and we are going to converting\\n                                                       // letter to index by using letter - \\'a\\' \\n        public bool EndOfWord = false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n                                     root\\n\\t\\t\\t\\t\\t\\t\\t    o     y     d\\n\\t\\t\\t\\t\\t\\t       l      m     r  l\\n\\t\\t\\t\\t\\t\\t      l             i    r\\n\\t\\t\\t\\t\\t\\t\\t e              e      o\\n\\t\\t\\t\\t\\t\\t\\th               w        w\\n```\n```\\npublic class StreamChecker{\\n    readonly TreeNode root = new TreeNode();\\n    readonly IList<char> _query = new List<char>();\\n\\n    public StreamChecker(string[] words) {\\n        foreach (var s in words) {\\n            TreeNode cur = root;\\n            for (int j = s.Length - 1; j >= 0; j--) {  // save word in reverse by converting each letter a index\\n                int i = s[j] - \\'a\\';                   \\n                if (cur.Children[i] == null) cur.Children[i] = new TreeNode();\\n                cur = cur.Children[i];\\n            }\\n            cur.EndOfWord = true;                      // at the first letter of each word set this flag to true\\n                                                       // and later use it to determine matching a word or not\\n        }\\n    }\\n\\n    public bool Query(char letter) {\\n        _query.Add(letter);\\n        TreeNode cur = root;\\n        for (int i = _query.Count - 1; i >= 0; i--) {\\n            int j = _query[i] - \\'a\\';\\n            if (cur.Children[j] == null) return false;\\n            cur = cur.Children[j];\\n            if (cur.EndOfWord) return true;\\n        }\\n        return false;\\n    }\\n\\n    class TreeNode {\\n        public TreeNode[] Children = new TreeNode[26]; // we will only have letter a to z and we are going to converting\\n                                                       // letter to index by using letter - \\'a\\' \\n        public bool EndOfWord = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610535,
                "title": "python-trie-tree-data-structure-explanation",
                "content": "We can use build a Trie tree to solve this problem https://en.wikipedia.org/wiki/Trie\\n```python\\n# Implement Trie tree use Hashtable\\nclass TrieTree:\\n    def __init__(self):\\n        self.root = {}\\n    def insert(self, word: str) -> None:\\n        node = self.root\\n        i = 0\\n        while i < len(word):\\n            if word[i] in node:\\n                node = node[word[i]]\\n                i += 1\\n                continue\\n            break        \\n        while i < len(word):\\n            node[word[i]] = {}\\n            node = node[word[i]]\\n            i+=1\\n\\t\\t# mark it as the last character of a word\\n        node[\"$\"]={}\\n        return\\n     # Check whether the stream suffix existed on tree or not\\n\\t # Can reverse suffix, so we check it like prefix\\n    def isPrefix(self, word: str) -> bool:\\n        node = self.root\\n        for c in word:\\n            if c not in node:\\n                return False\\n            if \"$\" in node[c]:\\n                return True\\n            node = node[c]\\n        return False\\n        \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.stream = \"\"\\n        self.trie = TrieTree()\\n        for w in words:\\n\\t\\t\\t# because we need to check suffix, so reversing the word\\n            self.trie.insert(w[::-1])\\n\\n    def query(self, letter: str) -> bool:\\n        self.stream += letter\\n        return self.trie.isPrefix(self.stream[::-1])",
                "solutionTags": [],
                "code": "We can use build a Trie tree to solve this problem https://en.wikipedia.org/wiki/Trie\\n```python\\n# Implement Trie tree use Hashtable\\nclass TrieTree:\\n    def __init__(self):\\n        self.root = {}\\n    def insert(self, word: str) -> None:\\n        node = self.root\\n        i = 0\\n        while i < len(word):\\n            if word[i] in node:\\n                node = node[word[i]]\\n                i += 1\\n                continue\\n            break        \\n        while i < len(word):\\n            node[word[i]] = {}\\n            node = node[word[i]]\\n            i+=1\\n\\t\\t# mark it as the last character of a word\\n        node[\"$\"]={}\\n        return\\n     # Check whether the stream suffix existed on tree or not\\n\\t # Can reverse suffix, so we check it like prefix\\n    def isPrefix(self, word: str) -> bool:\\n        node = self.root\\n        for c in word:\\n            if c not in node:\\n                return False\\n            if \"$\" in node[c]:\\n                return True\\n            node = node[c]\\n        return False\\n        \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.stream = \"\"\\n        self.trie = TrieTree()\\n        for w in words:\\n\\t\\t\\t# because we need to check suffix, so reversing the word\\n            self.trie.insert(w[::-1])\\n\\n    def query(self, letter: str) -> bool:\\n        self.stream += letter\\n        return self.trie.isPrefix(self.stream[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 807643,
                "title": "c-6-solutions-studied-4-variants-of-lc-hint-tle-2-variants-of-reversed-words-pass-dumb",
                "content": "**EDIT: Original post title:** *Leetcode hint misleading? Is there any C++ solution with Trie and set of ptrs that does not TLE?*\\n\\nLeetcode hint says : *Put the words into a trie, and manage a set of pointers within that trie.*\\n\\nok Leetcode, I did that but this TLE because of the dumb test case 17.\\n\\nOn the discussion, the non TLE C++ solutions I have seen are:\\n- trie of reversed words + complete lookup on the word formed by the the stream of chars (capped by max(words size)), not very elegant, this suffer from compete word lookup at each character\\n- Aho - Corasick algorithm, quite complex and with ridiculously long and complex implementations\\n\\nSo my question is : **Is there a solution that uses trie AND manage a set of pointers in the trie that DOES NOT TLE ???**\\n\\n**EDIT: Here is the list of solutions I tried (and the answer to my question seems to be NO)** \\n\\n1 - trie (using unique_ptr for nodes) of words + deque of pointers -> TLE on test 16\\n2 - trie (using raw ptr for nodes) + vector of pointers & additional tmp vector of pointers -> TLE on test  16\\n3 - trie (using raw ptr for nodes) + circular queue (ring buffer) of pointers -> TLE on test 16 or 17\\n4 - trie (using raw ptr for nodes, preallocated in a vector of Trie) + circular queue (ring buffer) of pointers -> TLE on test 17 or all tests pass but TLE on overall execution\\n5 - trie (using raw ptr for nodes) of reversed words + deque<char> as stream buffer -> Accepted ~900ms\\n6 - trie (using raw ptr for nodes, preallocated in a vector of Trie) of reversed words + deque as stream buffer  -> Accepted 496 ms, 80.56% best try\\n\\n**Conclusion:**  \\nThis problem is rubbish, I will downvote it.\\nThe leetcode hint is always TLE.\\nThe solution that uses reversed words is idiotic since it only improves the situations for special cases like:\\n- `word = \"aaaa...repeat until bored...aaaab\"`\\n- `strm = \"aaaa...repeat until bored...aaaac\"`\\n\\nBut reversed word approach would **TLE miserably as well** for test case such as:\\n- `word = \"aaaa...repeat like hell...aaaa\"`\\n- `strm = \"aaaa...repeat like hell...aaa\"`\\n \\n**-> Thank you leetcode** for the **low quality of your test cases** that lead to produce bad solution that work ok for specific corner cases!!\\n\\n**Detailled code of all studied solutions:**\\n\\n**1 - trie (using unique_ptr for nodes) of words + deque of pointers -> TLE on test 16**\\n\\nThis is my original solution:\\n- just implement a Trie made of an array of `unique_ptr<Trie>`\\n- use a deque to manage pointer to Trie nodes\\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<unique_ptr<Trie>, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref)\\n                ptr_ref = make_unique<Trie>();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n        \\n        Trie *find(char c){\\n            return letters[c-\\'a\\'].get();\\n        }\\n    };\\n    \\n    Trie trie_;\\n    deque<Trie *> nodes_;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(const auto& w: words)\\n            trie_.insert(w);\\n        nodes_.emplace_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size = nodes_.size(); i != size; ++i){\\n            auto n = nodes_.front();\\n            nodes_.pop_front();\\n            if(auto node = n->find(letter); node != nullptr){\\n                result |= node->is_word;\\n                if(!node->is_leaf)\\n                    nodes_.emplace_back(node);\\n            }\\n        }\\n        nodes_.emplace_back(&trie_);\\n        return result;\\n    }\\n};\\n```\\n**2 - trie (using raw ptr for nodes) + vector of pointers & additional tmp vector of pointers -> TLE on test  16**\\n\\nOk, here were my thoughts to improve the performances of 1:\\n- let\\'s not use convenient unique_ptr and manage deallocation myself\\n- push and pop in deque result of popping a node when dequeing and possibly reinserting after (for the same char in the stream), so lets use more memory efficient container: vector<Trie*> + a temporary one\\n- reserve the size of temporary vector to minimize the cost of re-allocations (when the vector reaches its internal capacity)\\n- after building the temporary vector, move it to the main one\\n\\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto ptr: letters) if(ptr) delete ptr;}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref) ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n    };\\n    \\n    Trie trie_;\\n    vector<Trie *> nodes_;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(const auto& w: words)\\n            trie_.insert(w);\\n        nodes_.emplace_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        vector<Trie *> new_nodes;\\n        new_nodes.reserve(nodes_.size()+1);\\n        for(int i = 0, size = nodes_.size(); i != size; ++i){\\n            auto n = nodes_[i];\\n            if(auto node = n->letters[letter-\\'a\\']; node != nullptr){\\n                result |= node->is_word;\\n                if(!node->is_leaf) new_nodes.emplace_back(node);\\n            }\\n        }\\n        new_nodes.emplace_back(&trie_);\\n        nodes_ = move(new_nodes);\\n        return result;\\n    }\\n};\\n```\\n**3 - trie (using raw ptr for nodes) + circular queue (ring buffer) of pointers -> TLE on test 16 or 17**\\n\\nI thought that both in 1 & 2, there are a lot of allocations / deallocations happening so:\\n- let\\'s use a circular queue to kill any dynamic allocation when processing the stream\\n- intialise the circular queue to the maximum possible size (max words sizes +1))\\n```\\ntemplate <typename T>\\nclass MyCircularQueue {\\n    int k_;\\n    vector<T> buffer_;\\n    typename vector<T>::iterator front_;\\n    typename vector<T>::iterator back_;\\n    int size_;\\npublic:\\n    MyCircularQueue(int k):\\n        k_(k),buffer_(k_), front_(buffer_.begin()), back_(buffer_.begin()),size_(0){}\\n    MyCircularQueue(){}\\n\\n    void resize(int k){\\n        k_ = k;\\n        buffer_.resize(k_);\\n        front_ = buffer_.begin();\\n        back_ = buffer_.begin();\\n        size_= 0;\\n    }\\n    \\n    void push_back(T value) {\\n        back_ = (size_ && ++back_ == buffer_.end())?buffer_.begin():back_;\\n        *back_ = value;\\n        ++size_;\\n    }\\n    \\n    T pop_front() {\\n        auto tmp = *front_;\\n        front_ = (front_ != back_ && ++front_ == buffer_.end())?buffer_.begin():front_;\\n        --size_;\\n        return tmp;\\n    }\\n    \\n    T& front() {return *front_;}\\n    T& back() {return *back_;}\\n    int size() {return size_;}\\n};\\n\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto ptr: letters) if(ptr) delete ptr;}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref)\\n                ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n    };\\n\\n    Trie trie_;\\n    MyCircularQueue<Trie *> queue_;\\n    size_t maxwordsize_;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0) {\\n        for(const auto& w: words){\\n            trie_.insert(w);\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n        }\\n        queue_.resize(maxwordsize_+1);\\n        queue_.push_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size=queue_.size(); i!= size; ++i){\\n            auto n = queue_.pop_front();\\n            if(auto node = n->letters[letter-\\'a\\']; node){\\n                result |= node->is_word;\\n                if(!node->is_leaf) queue_.push_back(node);\\n            }\\n        }\\n        queue_.push_back(&trie_);\\n        return result;\\n    }\\n};\\n```\\n\\n**4 - trie (using raw ptr for nodes, preallocated in a vector of Trie) + circular queue (ring buffer) of pointers -> TLE on test 17 or all tests pass but TLE on overall execution**\\n\\nOk, I was already pretty pissed with that problem at that stage but I thought that the word sizes in test 16 & 17 were pretty long and then building the Trie woud lead to a good number of allocations for all the Trie nodes. so I did this:\\n- compute the maximum possible number of tries nodes : sum( words sizes +1 )\\n- create a vector of Tries `trie_nodes_pool_` and reserve the necessary space in memory\\n- replace `ptr = new Trie()` per \\'trie_nodes_pool_.emplace(); ptr = &trie_nodes_pool_.back();`\\n```\\ntemplate <typename T>\\nclass MyCircularQueue {\\n    int k_;\\n    vector<T> buffer_;\\n    typename vector<T>::iterator front_;\\n    typename vector<T>::iterator back_;\\n    int size_;\\npublic:\\n    MyCircularQueue(int k):\\n        k_(k),buffer_(k_), front_(buffer_.begin()), back_(buffer_.begin()),size_(0){}\\n    MyCircularQueue(){}\\n\\n    void resize(int k){\\n        k_ = k;\\n        buffer_.resize(k_);\\n        front_ = buffer_.begin();\\n        back_ = buffer_.begin();\\n        size_= 0;\\n    }\\n    \\n    void push_back(T value) {\\n        back_ = (size_ && ++back_ == buffer_.end())?buffer_.begin():back_;\\n        *back_ = value;\\n        ++size_;\\n    }\\n    \\n    T pop_front() {\\n        auto tmp = *front_;\\n        front_ = (front_ != back_ && ++front_ == buffer_.end())?buffer_.begin():front_;\\n        --size_;\\n        return tmp;\\n    }\\n    \\n    T& front() {return *front_;}\\n    T& back() {return *back_;}\\n    int size() {return size_;}\\n};\\n\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        void insert(const string& word, vector<Trie>& pool, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref){\\n                pool.emplace_back();\\n                ptr_ref = &pool.back();\\n            }\\n            ptr_ref->insert(word, pool, pos+1);\\n        }\\n    };\\n\\n    Trie trie_;\\n    vector<Trie> trie_nodes_pool_;\\n    MyCircularQueue<Trie *> queue_;\\npublic:\\n    StreamChecker(vector<string>& words){\\n        size_t total_size = 1;\\n        size_t maxwordsize = 0;\\n        for(const auto& w: words){\\n            maxwordsize = max(maxwordsize, w.size());\\n            total_size += w.size()+1;\\n        }\\n        trie_nodes_pool_.reserve(total_size);\\n        for(const auto& w: words)\\n            trie_.insert(w, trie_nodes_pool_);\\n        queue_.resize(maxwordsize+1);\\n        queue_.push_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size=queue_.size(); i!= size; ++i){\\n            auto n = queue_.pop_front();\\n            if(auto node = n->letters[letter-\\'a\\']; node){\\n                result |= node->is_word;\\n                if(!node->is_leaf) queue_.push_back(node);\\n            }\\n        }\\n        queue_.push_back(&trie_);\\n        return result;\\n    }\\n};\\n```\\n\\n**5 - trie (using raw ptr for nodes) of reversed words + deque as stream buffer -> Accepted ~900ms**\\n\\nOk, at this point I was really thinking this hint from leetcode just made me waste my time as well as the \\nsolution using trie of reversed word was rubbish, but still I wanted to implelented it...\\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto n: letters) if(n) delete(n);}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref) ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n        \\n        template<typename Iterator>\\n        bool lookup(Iterator it, Iterator end){\\n            if(is_word || it == end) return is_word;\\n            if(auto node = letters[*it-\\'a\\']; node)\\n                return node->lookup(++it, end);\\n            return false;\\n        }\\n    };\\n\\n    Trie trie_;\\n    deque<char> stream_buf_;\\n    size_t maxwordsize_ = 0;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0){\\n        for(auto& w: words){\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n            reverse(w.begin(), w.end());\\n            trie_.insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream_buf_.push_front(letter);\\n        if(stream_buf_.size() > maxwordsize_)\\n            stream_buf_.pop_back();\\n        return trie_.lookup(stream_buf_.cbegin(), stream_buf_.cend());\\n    }\\n};\\n```\\n\\n**6 - trie (using raw ptr for nodes, preallocated in a vector of Trie) of reversed words + deque as stream buffer  -> Accepted 496 ms, 80.56% best try**\\n\\nSince I went that, far I decided to see if the preallocation of trie nodes optimisation would have an effect on the performance of this [bad but accepted] solution:\\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        \\n        void insert(const string& word, vector<Trie>& pool, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref){\\n                pool.emplace_back();\\n                ptr_ref = &pool.back();\\n            }\\n            ptr_ref->insert(word, pool, pos+1);\\n        }\\n        \\n        template<typename Iterator>\\n        bool lookup(Iterator it, Iterator end){\\n            if(is_word || it == end) return is_word;\\n            if(auto node = letters[*it-\\'a\\']; node)\\n                return node->lookup(++it, end);\\n            return false;\\n        }\\n    };\\n\\n    Trie trie_;\\n    vector<Trie> trie_nodes_pool_;\\n    deque<char> stream_buf_;\\n    size_t maxwordsize_ = 0;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0){\\n        size_t total_size = 0;\\n        for(auto& w: words){\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n            total_size += w.size()+1;\\n            reverse(w.begin(), w.end());\\n        }\\n        trie_nodes_pool_.reserve(total_size);\\n        for(const auto& w: words)\\n            trie_.insert(w, trie_nodes_pool_);\\n    }\\n    \\n    bool query(char letter) {\\n        stream_buf_.push_front(letter);\\n        if(stream_buf_.size() > maxwordsize_)\\n            stream_buf_.pop_back();\\n        return trie_.lookup(stream_buf_.cbegin(), stream_buf_.cend());\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    struct Trie{\\n        array<unique_ptr<Trie>, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref)\\n                ptr_ref = make_unique<Trie>();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n        \\n        Trie *find(char c){\\n            return letters[c-\\'a\\'].get();\\n        }\\n    };\\n    \\n    Trie trie_;\\n    deque<Trie *> nodes_;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(const auto& w: words)\\n            trie_.insert(w);\\n        nodes_.emplace_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size = nodes_.size(); i != size; ++i){\\n            auto n = nodes_.front();\\n            nodes_.pop_front();\\n            if(auto node = n->find(letter); node != nullptr){\\n                result |= node->is_word;\\n                if(!node->is_leaf)\\n                    nodes_.emplace_back(node);\\n            }\\n        }\\n        nodes_.emplace_back(&trie_);\\n        return result;\\n    }\\n};\\n```\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto ptr: letters) if(ptr) delete ptr;}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref) ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n    };\\n    \\n    Trie trie_;\\n    vector<Trie *> nodes_;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(const auto& w: words)\\n            trie_.insert(w);\\n        nodes_.emplace_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        vector<Trie *> new_nodes;\\n        new_nodes.reserve(nodes_.size()+1);\\n        for(int i = 0, size = nodes_.size(); i != size; ++i){\\n            auto n = nodes_[i];\\n            if(auto node = n->letters[letter-\\'a\\']; node != nullptr){\\n                result |= node->is_word;\\n                if(!node->is_leaf) new_nodes.emplace_back(node);\\n            }\\n        }\\n        new_nodes.emplace_back(&trie_);\\n        nodes_ = move(new_nodes);\\n        return result;\\n    }\\n};\\n```\n```\\ntemplate <typename T>\\nclass MyCircularQueue {\\n    int k_;\\n    vector<T> buffer_;\\n    typename vector<T>::iterator front_;\\n    typename vector<T>::iterator back_;\\n    int size_;\\npublic:\\n    MyCircularQueue(int k):\\n        k_(k),buffer_(k_), front_(buffer_.begin()), back_(buffer_.begin()),size_(0){}\\n    MyCircularQueue(){}\\n\\n    void resize(int k){\\n        k_ = k;\\n        buffer_.resize(k_);\\n        front_ = buffer_.begin();\\n        back_ = buffer_.begin();\\n        size_= 0;\\n    }\\n    \\n    void push_back(T value) {\\n        back_ = (size_ && ++back_ == buffer_.end())?buffer_.begin():back_;\\n        *back_ = value;\\n        ++size_;\\n    }\\n    \\n    T pop_front() {\\n        auto tmp = *front_;\\n        front_ = (front_ != back_ && ++front_ == buffer_.end())?buffer_.begin():front_;\\n        --size_;\\n        return tmp;\\n    }\\n    \\n    T& front() {return *front_;}\\n    T& back() {return *back_;}\\n    int size() {return size_;}\\n};\\n\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto ptr: letters) if(ptr) delete ptr;}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref)\\n                ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n    };\\n\\n    Trie trie_;\\n    MyCircularQueue<Trie *> queue_;\\n    size_t maxwordsize_;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0) {\\n        for(const auto& w: words){\\n            trie_.insert(w);\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n        }\\n        queue_.resize(maxwordsize_+1);\\n        queue_.push_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size=queue_.size(); i!= size; ++i){\\n            auto n = queue_.pop_front();\\n            if(auto node = n->letters[letter-\\'a\\']; node){\\n                result |= node->is_word;\\n                if(!node->is_leaf) queue_.push_back(node);\\n            }\\n        }\\n        queue_.push_back(&trie_);\\n        return result;\\n    }\\n};\\n```\n```\\ntemplate <typename T>\\nclass MyCircularQueue {\\n    int k_;\\n    vector<T> buffer_;\\n    typename vector<T>::iterator front_;\\n    typename vector<T>::iterator back_;\\n    int size_;\\npublic:\\n    MyCircularQueue(int k):\\n        k_(k),buffer_(k_), front_(buffer_.begin()), back_(buffer_.begin()),size_(0){}\\n    MyCircularQueue(){}\\n\\n    void resize(int k){\\n        k_ = k;\\n        buffer_.resize(k_);\\n        front_ = buffer_.begin();\\n        back_ = buffer_.begin();\\n        size_= 0;\\n    }\\n    \\n    void push_back(T value) {\\n        back_ = (size_ && ++back_ == buffer_.end())?buffer_.begin():back_;\\n        *back_ = value;\\n        ++size_;\\n    }\\n    \\n    T pop_front() {\\n        auto tmp = *front_;\\n        front_ = (front_ != back_ && ++front_ == buffer_.end())?buffer_.begin():front_;\\n        --size_;\\n        return tmp;\\n    }\\n    \\n    T& front() {return *front_;}\\n    T& back() {return *back_;}\\n    int size() {return size_;}\\n};\\n\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        void insert(const string& word, vector<Trie>& pool, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref){\\n                pool.emplace_back();\\n                ptr_ref = &pool.back();\\n            }\\n            ptr_ref->insert(word, pool, pos+1);\\n        }\\n    };\\n\\n    Trie trie_;\\n    vector<Trie> trie_nodes_pool_;\\n    MyCircularQueue<Trie *> queue_;\\npublic:\\n    StreamChecker(vector<string>& words){\\n        size_t total_size = 1;\\n        size_t maxwordsize = 0;\\n        for(const auto& w: words){\\n            maxwordsize = max(maxwordsize, w.size());\\n            total_size += w.size()+1;\\n        }\\n        trie_nodes_pool_.reserve(total_size);\\n        for(const auto& w: words)\\n            trie_.insert(w, trie_nodes_pool_);\\n        queue_.resize(maxwordsize+1);\\n        queue_.push_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size=queue_.size(); i!= size; ++i){\\n            auto n = queue_.pop_front();\\n            if(auto node = n->letters[letter-\\'a\\']; node){\\n                result |= node->is_word;\\n                if(!node->is_leaf) queue_.push_back(node);\\n            }\\n        }\\n        queue_.push_back(&trie_);\\n        return result;\\n    }\\n};\\n```\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto n: letters) if(n) delete(n);}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref) ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n        \\n        template<typename Iterator>\\n        bool lookup(Iterator it, Iterator end){\\n            if(is_word || it == end) return is_word;\\n            if(auto node = letters[*it-\\'a\\']; node)\\n                return node->lookup(++it, end);\\n            return false;\\n        }\\n    };\\n\\n    Trie trie_;\\n    deque<char> stream_buf_;\\n    size_t maxwordsize_ = 0;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0){\\n        for(auto& w: words){\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n            reverse(w.begin(), w.end());\\n            trie_.insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream_buf_.push_front(letter);\\n        if(stream_buf_.size() > maxwordsize_)\\n            stream_buf_.pop_back();\\n        return trie_.lookup(stream_buf_.cbegin(), stream_buf_.cend());\\n    }\\n};\\n```\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        \\n        void insert(const string& word, vector<Trie>& pool, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref){\\n                pool.emplace_back();\\n                ptr_ref = &pool.back();\\n            }\\n            ptr_ref->insert(word, pool, pos+1);\\n        }\\n        \\n        template<typename Iterator>\\n        bool lookup(Iterator it, Iterator end){\\n            if(is_word || it == end) return is_word;\\n            if(auto node = letters[*it-\\'a\\']; node)\\n                return node->lookup(++it, end);\\n            return false;\\n        }\\n    };\\n\\n    Trie trie_;\\n    vector<Trie> trie_nodes_pool_;\\n    deque<char> stream_buf_;\\n    size_t maxwordsize_ = 0;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0){\\n        size_t total_size = 0;\\n        for(auto& w: words){\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n            total_size += w.size()+1;\\n            reverse(w.begin(), w.end());\\n        }\\n        trie_nodes_pool_.reserve(total_size);\\n        for(const auto& w: words)\\n            trie_.insert(w, trie_nodes_pool_);\\n    }\\n    \\n    bool query(char letter) {\\n        stream_buf_.push_front(letter);\\n        if(stream_buf_.size() > maxwordsize_)\\n            stream_buf_.pop_back();\\n        return trie_.lookup(stream_buf_.cbegin(), stream_buf_.cend());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279084,
                "title": "simple-implementation-of-aho-corasick-algorithm",
                "content": "This algorithm is called Aho Corasick algorithm, you can search it on Google.\\nThe idea behind this algorithm is totally similar to KMP, it\\'s an extension of KMP to search more than one patterns at the same time. If the automaton is built, that query method will seem very simple.\\nBasic steps of this algorithm:\\n1. build a trie;\\n2. usd a bfs to build our dictionary automaton(in China, we call it AC automaton mostly), here it is almost the same with KMP, isn\\'t it?\\n3. go, just use it.\\n\\n```\\n#include <vector>\\n#include <iostream>\\n#include <string>\\n#include <algorithm>\\n#include <queue>\\n\\nusing namespace std;\\n\\nclass StreamChecker {\\npublic:\\n    StreamChecker(const vector<string>& words) {\\n        initialize_trie(words);\\n        build_dictionary_automaton();\\n\\n    }\\n\\n    bool query(char letter) {\\n        current = nodes[current].next[letter - \\'a\\'];\\n        return nodes[current].terminal;\\n    }\\n\\nprivate:\\n\\n    int current;\\n\\n    void build_dictionary_automaton()\\n    {\\n        queue<pair<int, int>> Q;\\n        for (int i = 0; i < ALPHABET_SIZE; ++i)\\n        {\\n            if (nodes[root].next[i] == -1)\\n            {\\n                nodes[root].next[i] = root;\\n            }\\n            else\\n            {\\n                Q.push(make_pair(root, nodes[root].next[i]));\\n            }\\n        }\\n        while (!Q.empty())\\n        {\\n            auto p = Q.front();\\n            Q.pop();\\n\\n            if (nodes[p.first].terminal)\\n            {\\n                nodes[p.second].terminal = true;\\n            }\\n            for (int i = 0; i < ALPHABET_SIZE; ++i)\\n            {\\n                int x = nodes[p.first].next[i];\\n                int y = nodes[p.second].next[i];\\n                if (y == -1)\\n                {\\n                    nodes[p.second].next[i] = x;\\n                }\\n                else\\n                {\\n                    Q.push(make_pair(x, y));\\n                }\\n            }\\n        }\\n        current = 0;\\n    }\\n\\n    void initialize_trie(const vector<string>& words)\\n    {\\n        root = 0;\\n        nodes.push_back(TrieNode());\\n        for (auto& word : words)\\n        {\\n            auto current = root;\\n            for (char c : word)\\n            {\\n                int offset = c - \\'a\\';\\n                if (nodes[current].next[offset] == -1)\\n                {\\n                    nodes[current].next[offset] = nodes.size();\\n                    nodes.push_back(TrieNode());\\n                }\\n                current = nodes[current].next[offset];\\n            }\\n            nodes[current].terminal = true;\\n        }\\n    }\\n\\n    static const int ALPHABET_SIZE = 26;\\n\\n    struct TrieNode\\n    {\\n        int next[ALPHABET_SIZE];\\n        bool terminal;\\n        TrieNode()\\n        {\\n            fill(next, next + ALPHABET_SIZE, -1);\\n            terminal = false;\\n        }\\n    };\\n\\n    vector<TrieNode> nodes;\\n    int root;\\n\\n};\\n\\nstatic const int accelerate = []() {  \\n  ios::sync_with_stdio(false);\\n  cin.tie(nullptr);\\n  return 0;\\n}();\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <iostream>\\n#include <string>\\n#include <algorithm>\\n#include <queue>\\n\\nusing namespace std;\\n\\nclass StreamChecker {\\npublic:\\n    StreamChecker(const vector<string>& words) {\\n        initialize_trie(words);\\n        build_dictionary_automaton();\\n\\n    }\\n\\n    bool query(char letter) {\\n        current = nodes[current].next[letter - \\'a\\'];\\n        return nodes[current].terminal;\\n    }\\n\\nprivate:\\n\\n    int current;\\n\\n    void build_dictionary_automaton()\\n    {\\n        queue<pair<int, int>> Q;\\n        for (int i = 0; i < ALPHABET_SIZE; ++i)\\n        {\\n            if (nodes[root].next[i] == -1)\\n            {\\n                nodes[root].next[i] = root;\\n            }\\n            else\\n            {\\n                Q.push(make_pair(root, nodes[root].next[i]));\\n            }\\n        }\\n        while (!Q.empty())\\n        {\\n            auto p = Q.front();\\n            Q.pop();\\n\\n            if (nodes[p.first].terminal)\\n            {\\n                nodes[p.second].terminal = true;\\n            }\\n            for (int i = 0; i < ALPHABET_SIZE; ++i)\\n            {\\n                int x = nodes[p.first].next[i];\\n                int y = nodes[p.second].next[i];\\n                if (y == -1)\\n                {\\n                    nodes[p.second].next[i] = x;\\n                }\\n                else\\n                {\\n                    Q.push(make_pair(x, y));\\n                }\\n            }\\n        }\\n        current = 0;\\n    }\\n\\n    void initialize_trie(const vector<string>& words)\\n    {\\n        root = 0;\\n        nodes.push_back(TrieNode());\\n        for (auto& word : words)\\n        {\\n            auto current = root;\\n            for (char c : word)\\n            {\\n                int offset = c - \\'a\\';\\n                if (nodes[current].next[offset] == -1)\\n                {\\n                    nodes[current].next[offset] = nodes.size();\\n                    nodes.push_back(TrieNode());\\n                }\\n                current = nodes[current].next[offset];\\n            }\\n            nodes[current].terminal = true;\\n        }\\n    }\\n\\n    static const int ALPHABET_SIZE = 26;\\n\\n    struct TrieNode\\n    {\\n        int next[ALPHABET_SIZE];\\n        bool terminal;\\n        TrieNode()\\n        {\\n            fill(next, next + ALPHABET_SIZE, -1);\\n            terminal = false;\\n        }\\n    };\\n\\n    vector<TrieNode> nodes;\\n    int root;\\n\\n};\\n\\nstatic const int accelerate = []() {  \\n  ios::sync_with_stdio(false);\\n  cin.tie(nullptr);\\n  return 0;\\n}();\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1611044,
                "title": "get-the-explanation-and-commented-code-here-fastest",
                "content": "**Idea?**\\n* We need to search that if there exists a word in the words[] which is a suffix of the current characters in a stream?\\n* Now, since we\\'ve to work on the suffix, we would insert strings in the Trie in a reversed manner Why? SInce, searching becomes easy.\\n* *Insert All the strings in words[] in Trie in reversed manne*r also, find the maximum length of string present in words[] (this will reduce the searching complexity).\\n* For suppose, we need to find answer for a query so we will search in the trie , the current stream string in a reversed manner(since we have inserted string in reversed way).\\n* Also, while searching, take care that searching strings having length > max length is useless so break after that.\\n* Worst Case Number of Iterations ~ 10^7\\n\\n```\\n// Worst Case Iterations ~ 10^7\\n\\nclass TrieNode{\\npublic:\\n    bool isEnd; // checks whether any words ends at this node?\\n    vector<TrieNode*> child; // child nodes of the current node\\n    TrieNode(){ // assign default values\\n        isEnd = false;\\n        child.assign(26,nullptr);\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    string stream = \"\"; // used to store stream of characters\\n    TrieNode* root; // root of the Trie\\n    int max_len = 0; // stores the maximum length of the word present\\n    \\n    // insert the string in the Trie in reverse manner\\n    void insert(string s){\\n        TrieNode* curr = root;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(!curr->child[s[i]-\\'a\\'])\\n                curr->child[s[i]-\\'a\\'] = new TrieNode();\\n            curr = curr->child[s[i]-\\'a\\'];\\n        }\\n        curr->isEnd = true; // marks true since a word ends here\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode(); // root of Trie initialized\\n        for(auto s:words){\\n            insert(s); // insert the string into trie\\n            if(s.length()>max_len) // finds the maximum length\\n                max_len = s.length();\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_back(letter); // store stream of characters\\n        TrieNode* curr = root;int curr_len = max_len;\\n        // find if there is an end of word for the suffix of the stream of characters using Trie\\n        for(int i=stream.length()-1;i>=0 and curr_len;i--,curr_len--){\\n            if(!curr->child[stream[i]-\\'a\\'])\\n                return false;\\n            curr = curr->child[stream[i]-\\'a\\'];\\n            if(curr->isEnd)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n// Worst Case Iterations ~ 10^7\\n\\nclass TrieNode{\\npublic:\\n    bool isEnd; // checks whether any words ends at this node?\\n    vector<TrieNode*> child; // child nodes of the current node\\n    TrieNode(){ // assign default values\\n        isEnd = false;\\n        child.assign(26,nullptr);\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    string stream = \"\"; // used to store stream of characters\\n    TrieNode* root; // root of the Trie\\n    int max_len = 0; // stores the maximum length of the word present\\n    \\n    // insert the string in the Trie in reverse manner\\n    void insert(string s){\\n        TrieNode* curr = root;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(!curr->child[s[i]-\\'a\\'])\\n                curr->child[s[i]-\\'a\\'] = new TrieNode();\\n            curr = curr->child[s[i]-\\'a\\'];\\n        }\\n        curr->isEnd = true; // marks true since a word ends here\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode(); // root of Trie initialized\\n        for(auto s:words){\\n            insert(s); // insert the string into trie\\n            if(s.length()>max_len) // finds the maximum length\\n                max_len = s.length();\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_back(letter); // store stream of characters\\n        TrieNode* curr = root;int curr_len = max_len;\\n        // find if there is an end of word for the suffix of the stream of characters using Trie\\n        for(int i=stream.length()-1;i>=0 and curr_len;i--,curr_len--){\\n            if(!curr->child[stream[i]-\\'a\\'])\\n                return false;\\n            curr = curr->child[stream[i]-\\'a\\'];\\n            if(curr->isEnd)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807594,
                "title": "python-no-trie",
                "content": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.dic = {}\\n        for word in words:\\n            if word[-1] not in self.dic:\\n                self.dic[word[-1]] = [word[:-1]]\\n            else:\\n                self.dic[word[-1]].append(word[:-1])\\n        \\n        self.string = \"\"\\n\\n    def query(self, letter: str) -> bool:\\n        self.string += letter\\n        if letter in self.dic:\\n            for word in self.dic[letter]:\\n                length = len(word) + 1\\n                complete_word = word + letter\\n                if len(self.string) >= length and complete_word == self.string[- length:]:\\n                    return True\\n            return False\\n        else:\\n            return False\\n```\\n\\nThe idea is set up a dictionary for the last char for all words in words\\nthen add up string and if we see a letter in the dic and the length of string is greater than the word, reverse query the string and see if it matches the words",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.dic = {}\\n        for word in words:\\n            if word[-1] not in self.dic:\\n                self.dic[word[-1]] = [word[:-1]]\\n            else:\\n                self.dic[word[-1]].append(word[:-1])\\n        \\n        self.string = \"\"\\n\\n    def query(self, letter: str) -> bool:\\n        self.string += letter\\n        if letter in self.dic:\\n            for word in self.dic[letter]:\\n                length = len(word) + 1\\n                complete_word = word + letter\\n                if len(self.string) >= length and complete_word == self.string[- length:]:\\n                    return True\\n            return False\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309674,
                "title": "java-trie-solution-using-queue-no-reverse",
                "content": "```\\nclass StreamChecker {\\n    \\n    class Node {\\n        boolean isValid;\\n        char val;\\n        Node[] children = new Node[26];\\n        Node(char c) {\\n            this.val = c;\\n            this.isValid = false;\\n        }\\n    }\\n    \\n    Node root;\\n    Queue<Node> q; // valid query status ending up with Node.\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node(\\'X\\');\\n        for(String word : words) {\\n            Node node = root;\\n            for(int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if(node.children[c - \\'a\\'] == null) {\\n                    node.children[c - \\'a\\'] = new Node(c);\\n                }\\n                node = node.children[c - \\'a\\'];\\n                if(i == word.length() - 1) {\\n                    node.isValid = true;\\n                    System.out.println(node.val);\\n                }\\n            }\\n        }\\n        q = new LinkedList<>();\\n        q.add(root);\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        int n = q.size();\\n        for(int i = 0; i < n; i++) {\\n            Node node = q.poll();\\n            if(node.children[letter - \\'a\\'] != null) {\\n                q.add(node.children[letter - \\'a\\']);\\n                if(node.children[letter - \\'a\\'].isValid) {\\n                    res = true;\\n                }\\n            }\\n            if(node == root) {\\n                q.add(root);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    \\n    class Node {\\n        boolean isValid;\\n        char val;\\n        Node[] children = new Node[26];\\n        Node(char c) {\\n            this.val = c;\\n            this.isValid = false;\\n        }\\n    }\\n    \\n    Node root;\\n    Queue<Node> q; // valid query status ending up with Node.\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node(\\'X\\');\\n        for(String word : words) {\\n            Node node = root;\\n            for(int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if(node.children[c - \\'a\\'] == null) {\\n                    node.children[c - \\'a\\'] = new Node(c);\\n                }\\n                node = node.children[c - \\'a\\'];\\n                if(i == word.length() - 1) {\\n                    node.isValid = true;\\n                    System.out.println(node.val);\\n                }\\n            }\\n        }\\n        q = new LinkedList<>();\\n        q.add(root);\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        int n = q.size();\\n        for(int i = 0; i < n; i++) {\\n            Node node = q.poll();\\n            if(node.children[letter - \\'a\\'] != null) {\\n                q.add(node.children[letter - \\'a\\']);\\n                if(node.children[letter - \\'a\\'].isValid) {\\n                    res = true;\\n                }\\n            }\\n            if(node == root) {\\n                q.add(root);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807449,
                "title": "c-trie-based-solution-explained-75-time-50-space",
                "content": "We have 2 things to implement properly here:\\n* a proper `Trie` struct/class to store all the words provided when we call `StreamChecker` constructor;\\n* an efficient way to return boolean results for our `query` method.\\n\\nSo, for the first point, while se can do it inside `StreamChecker`, I would strongly advise keeping it separate: it will save memory to just expand an object with bare minimum functionalities (basically just a constructor and an `add` function) and, both in interview and production settings, it just shows cleaner, more modular and maintainable code at the cost of a few extra lines.\\n\\nEach instance of our `Trie` class (or struct, as I preferred in this case) will just have an array of `26` `children` - one for each lowercase letter - and a boolean value `eow` to denote the end of a word.\\n\\nIts `add` method will take a string and loop through its characters to build a tree, turning them into values in the `0 - 25` range just subtracting `\\'a\\'` to then, generating new linked `Trie` pointers and linking them in the matching `children` slot and finally assigning the value of `true` to the `eow` flag of the last node/character in the trie.\\n\\nNow, `StreamChecker` time!\\n\\nThe first part is relatively straightforward and built on what we just did with `Trie`: we declare a few class variables, all `Trie`-related: `trie` and `curr`, both pointers to that data structure and `queries`, a vector of pointers to them; in the constructor, we just have to feed `trie` all the strings we were provided and we are good to go for this part.\\n\\n`query` is definitely a bit more of a pickle: first of all, we start initialising our usual `res` variable, set to `false`; then we clean up `tmp` from possible previous runs and normalise again `c` to be in our familiar `0 - 25` range; also, we have to append `trie` to `queries` to be sure to capture new paths starting from this query.\\n\\nAfter that, we start checking for all the \"open\" (more on this later) queries we have, starting from the bottom (I found this approach to be significantly faster and it makes sense, since the bottom tends to have the shortest single-character queries attached): we then check query by query if we have at least one of them matching the final character of a word (ie: `eow == true`), in which case we update `res`.\\n\\nBut we do not stop here: we proceed looping in order to cut out all the unnecessary queries for the next runs and move the still valid ones to `tmp`; we have to do this, otherwise we will keep wasting resources on dead paths.\\n\\nThink for example if you were passed in the constructor `[\"voo\", \"voog\", \"voov\", \"vv\"]` (slight nod to fellow ETF-investors here!): if your queries were `\\'v\\'`, `\\'o\\'`, `\\'v\\'`, `\\'v\\'`, `o\\'`, `\\'o\\'`, `\\'v\\'`, `\\'p\\'`, you would have to discard the previous `\\'v\\'->\\'o\\'` and `\\'v\\'->\\'o\\'->\\'o\\'` paths after the second `\\'v\\'` and the first `\\'p\\'` respectively, since no path leads there, but `\\'v\\'->\\'v\\'` would still be a valid match.\\n\\nI know, it takes a bit of time to visualise and digest it, but try to use my code and print some examples if that helps you :)\\n\\nAfter the loop we update `queries` to match it and finally return `res` :)\\n\\nThe code:\\n\\n```cpp\\nstruct Trie {\\n    Trie *children[26];\\n    bool eow = false;\\n    Trie() {\\n        // initialising all children to NULL\\n        for (Trie *&e: children) e = NULL;\\n    }\\n    void add(string s) {\\n        // adding new paths to the current Trie, char by char\\n\\t\\tTrie *curr = this;\\n        for (char c: s) {\\n            // turning c into a 0 - 25 value\\n\\t\\t\\tc -= \\'a\\';\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n        }\\n\\t\\t// marking the end of a word on the node associated with the last character\\n        curr->eow = true;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    Trie *trie = new Trie(), *curr;\\n    vector<Trie*> queries, tmp;\\n    StreamChecker(vector<string>& words) {\\n        // populating our trie with all the provided words\\n\\t\\tfor (string w: words) trie->add(w);\\n    }\\n    \\n    bool query(char c) {\\n        // mandatory variable initialisation/clean up\\n\\t\\tbool res = false;\\n        tmp.clear();\\n        c -= \\'a\\';\\n\\t\\t// updating queries with to catch also the very last one\\n        queries.push_back(trie);\\n        for (int i = queries.size() - 1; i > -1; i--) {\\n            curr = queries[i];\\n            if (curr && curr->children[c]) {\\n                // marking res as true if we find a matching path\\n\\t\\t\\t\\tres |= curr->children[c]->eow;\\n\\t\\t\\t\\t// updating tmp for the next run\\n                tmp.push_back(curr->children[c]);\\n            }\\n        }\\n\\t\\t// updating queries to remove dead paths\\n        queries = tmp;\\n        return res;\\n    }\\n};\\n```\\n\\nI have an idea on how to refactor `queries` for better performances - might be working on it later!\\n\\nEdit, done; I will not repeat the `Trie` part here, showing only `StreamChecker` with my latest changes; it takes less than half time (now I am down to 550ms), not too shabby. Notice that despite having a nominal upper bound of `40000` queries, you hardly need to store a fraction of them, the current ones, so I experimented a bit and saw that you only need to store like `1500` or so of them to pass a tricky test case; minor saving in memory, but still worth it:\\n\\n```cpp\\nclass StreamChecker {\\npublic:\\n    Trie *trie = new Trie(), *curr;\\n    Trie* queries[20000];\\n    int nextAvailable = 0;\\n    StreamChecker(vector<string>& words) {\\n        // populating our trie with all the provided words\\n\\t\\tfor (string w: words) trie->add(w);\\n    }\\n    \\n    bool query(char c) {\\n        // mandatory variable initialisation/clean up\\n\\t\\tbool res = false;\\n        c -= \\'a\\';\\n\\t\\t// updating queries with to catch also the very last one\\n        queries[nextAvailable++] = trie;\\n        for (int i = nextAvailable - 1; i > -1; i--) {\\n            curr = queries[i];\\n            if (curr->children[c]) {\\n                // marking res as true if we find a matching path\\n\\t\\t\\t\\tres |= curr->children[c]->eow;\\n                // updating queries\\n                queries[i] = curr->children[c];\\n            }\\n            // otherwise moving the last available query here\\n            // and leaving the ith element for overwriting\\n            else swap(queries[--nextAvailable], queries[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```cpp\\nstruct Trie {\\n    Trie *children[26];\\n    bool eow = false;\\n    Trie() {\\n        // initialising all children to NULL\\n        for (Trie *&e: children) e = NULL;\\n    }\\n    void add(string s) {\\n        // adding new paths to the current Trie, char by char\\n\\t\\tTrie *curr = this;\\n        for (char c: s) {\\n            // turning c into a 0 - 25 value\\n\\t\\t\\tc -= \\'a\\';\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n        }\\n\\t\\t// marking the end of a word on the node associated with the last character\\n        curr->eow = true;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    Trie *trie = new Trie(), *curr;\\n    vector<Trie*> queries, tmp;\\n    StreamChecker(vector<string>& words) {\\n        // populating our trie with all the provided words\\n\\t\\tfor (string w: words) trie->add(w);\\n    }\\n    \\n    bool query(char c) {\\n        // mandatory variable initialisation/clean up\\n\\t\\tbool res = false;\\n        tmp.clear();\\n        c -= \\'a\\';\\n\\t\\t// updating queries with to catch also the very last one\\n        queries.push_back(trie);\\n        for (int i = queries.size() - 1; i > -1; i--) {\\n            curr = queries[i];\\n            if (curr && curr->children[c]) {\\n                // marking res as true if we find a matching path\\n\\t\\t\\t\\tres |= curr->children[c]->eow;\\n\\t\\t\\t\\t// updating tmp for the next run\\n                tmp.push_back(curr->children[c]);\\n            }\\n        }\\n\\t\\t// updating queries to remove dead paths\\n        queries = tmp;\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass StreamChecker {\\npublic:\\n    Trie *trie = new Trie(), *curr;\\n    Trie* queries[20000];\\n    int nextAvailable = 0;\\n    StreamChecker(vector<string>& words) {\\n        // populating our trie with all the provided words\\n\\t\\tfor (string w: words) trie->add(w);\\n    }\\n    \\n    bool query(char c) {\\n        // mandatory variable initialisation/clean up\\n\\t\\tbool res = false;\\n        c -= \\'a\\';\\n\\t\\t// updating queries with to catch also the very last one\\n        queries[nextAvailable++] = trie;\\n        for (int i = nextAvailable - 1; i > -1; i--) {\\n            curr = queries[i];\\n            if (curr->children[c]) {\\n                // marking res as true if we find a matching path\\n\\t\\t\\t\\tres |= curr->children[c]->eow;\\n                // updating queries\\n                queries[i] = curr->children[c];\\n            }\\n            // otherwise moving the last available query here\\n            // and leaving the ith element for overwriting\\n            else swap(queries[--nextAvailable], queries[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807732,
                "title": "c-trie-based-solution-using-reversed-words",
                "content": "Insert the words in reverse order, and search the stream in reverse order.\\n```\\nstruct TrieNode {\\n    struct TrieNode* children[26];\\n    bool wordEnd;\\n};\\nstruct TrieNode *getNewNode() { \\n    struct TrieNode *pNode =  new TrieNode; \\n    pNode->wordEnd = false; \\n    for (int i = 0; i < 26; i++) \\n        pNode->children[i] = NULL; \\n    return pNode; \\n} \\nclass StreamChecker {\\npublic:\\n    TrieNode *root = new TrieNode();\\n    string s = \"\";\\n    StreamChecker(vector<string>& words) {\\n        for(string word: words) {\\n            TrieNode* tmp = root;\\n            reverse(word.begin(), word.end());\\n            for(char c : word) {\\n                int ind = c - \\'a\\';\\n                if(!tmp->children[ind]) {\\n                    tmp->children[ind] = getNewNode();\\n                }\\n                tmp = tmp->children[ind];\\n            }\\n            tmp->wordEnd = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        s += letter;\\n        TrieNode *tmp = root; \\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            int index = s[i] - \\'a\\'; \\n            tmp = tmp->children[index]; \\n            if( tmp != NULL && tmp->wordEnd) return true;\\n            if( tmp == NULL) return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct TrieNode {\\n    struct TrieNode* children[26];\\n    bool wordEnd;\\n};\\nstruct TrieNode *getNewNode() { \\n    struct TrieNode *pNode =  new TrieNode; \\n    pNode->wordEnd = false; \\n    for (int i = 0; i < 26; i++) \\n        pNode->children[i] = NULL; \\n    return pNode; \\n} \\nclass StreamChecker {\\npublic:\\n    TrieNode *root = new TrieNode();\\n    string s = \"\";\\n    StreamChecker(vector<string>& words) {\\n        for(string word: words) {\\n            TrieNode* tmp = root;\\n            reverse(word.begin(), word.end());\\n            for(char c : word) {\\n                int ind = c - \\'a\\';\\n                if(!tmp->children[ind]) {\\n                    tmp->children[ind] = getNewNode();\\n                }\\n                tmp = tmp->children[ind];\\n            }\\n            tmp->wordEnd = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        s += letter;\\n        TrieNode *tmp = root; \\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            int index = s[i] - \\'a\\'; \\n            tmp = tmp->children[index]; \\n            if( tmp != NULL && tmp->wordEnd) return true;\\n            if( tmp == NULL) return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807725,
                "title": "javascript-python3-c-trie-solutions",
                "content": "**Synopsis:**\\n\\nCreate a trie populated with words in `A`.  For each query `c`, track candidate trie nodes and return `true` if and only if a candidate has reached the end of a word.\\n\\n**Note:** these solutions are *not* efficient, only the JS solution is AC.  Both Python3 and C++ result in TLE.\\n\\n---\\n\\n*Javascript*\\n```\\nclass TrieNode {\\n    constructor() {\\n        this.children = {};\\n        this.isEnd = false;\\n    }\\n}\\nclass StreamChecker {\\n    constructor(A) {\\n        this.A = A;\\n        this.root = new TrieNode();\\n        this.cand = [];\\n        for (let word of A) {\\n            let cur = this.root;\\n            for (let c of word)\\n                cur = cur.children[c] ? cur.children[c] : cur.children[c] = new TrieNode();\\n            cur.isEnd = true;\\n        }\\n    }\\n    query(c) {\\n        this.cand = this.cand.filter(node => node.children[c]);  // \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n        for (let i = 0; i < this.cand.length; ++i)\\n            this.cand[i] = this.cand[i].children[c];\\n        if (this.root.children[c])\\n            this.cand.push(this.root.children[c]);\\n        return this.cand.some(node => node.isEnd);\\n    }\\n}\\n```\\n\\n*Python3*\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\nclass StreamChecker:\\n    def __init__(self, A: List[str]):\\n        self.A = A\\n        self.root = TrieNode()\\n        self.cand = []\\n        for word in A:\\n            cur = self.root\\n            for c in word:\\n                if c not in cur.children:\\n                    cur.children[c] = TrieNode()\\n                cur = cur.children[c]\\n            cur.isEnd = True\\n    def query(self, c: str) -> bool:\\n        self.cand[:] = [node for node in self.cand if c in node.children]  # \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n        for i in range(len(self.cand)):\\n            self.cand[i] = self.cand[i].children[c]\\n        if c in self.root.children:\\n            self.cand.append(self.root.children[c])\\n        return any(node.isEnd for node in self.cand)\\n```\\n\\n*C++*\\n```\\nclass StreamChecker {\\n    struct TrieNode;\\n    using Map = unordered_map<char, shared_ptr<TrieNode>>;\\n    struct TrieNode {\\n        Map children;\\n        bool isEnd{ false };\\n    };\\n    shared_ptr<TrieNode> root;\\n    vector<shared_ptr<TrieNode>> cand;\\npublic:\\n    using VS = vector<string>;\\n    StreamChecker(VS& A) : root{ make_shared<TrieNode>() } {\\n        for (auto& word: A) {\\n            auto cur{ root };\\n            for (auto c: word)\\n                cur = cur->children.find(c) != cur->children.end() ? cur->children[c] : cur->children[c] = make_shared<TrieNode>();\\n            cur->isEnd = true;\\n        }\\n    }\\n    bool query(char c) {\\n        cand.erase(  // \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n            remove_if(cand.begin(), cand.end(), [=](auto node) {\\n                return node->children.find(c) == node->children.end();\\n            }), cand.end());\\n        for (auto& node: cand)\\n            node = node->children[c];\\n        if (root->children.find(c) != root->children.end())\\n            cand.push_back(root->children[c]);\\n        return any_of(cand.begin(), cand.end(), [](auto node) { return node->isEnd; });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    constructor() {\\n        this.children = {};\\n        this.isEnd = false;\\n    }\\n}\\nclass StreamChecker {\\n    constructor(A) {\\n        this.A = A;\\n        this.root = new TrieNode();\\n        this.cand = [];\\n        for (let word of A) {\\n            let cur = this.root;\\n            for (let c of word)\\n                cur = cur.children[c] ? cur.children[c] : cur.children[c] = new TrieNode();\\n            cur.isEnd = true;\\n        }\\n    }\\n    query(c) {\\n        this.cand = this.cand.filter(node => node.children[c]);  // \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n        for (let i = 0; i < this.cand.length; ++i)\\n            this.cand[i] = this.cand[i].children[c];\\n        if (this.root.children[c])\\n            this.cand.push(this.root.children[c]);\\n        return this.cand.some(node => node.isEnd);\\n    }\\n}\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\nclass StreamChecker:\\n    def __init__(self, A: List[str]):\\n        self.A = A\\n        self.root = TrieNode()\\n        self.cand = []\\n        for word in A:\\n            cur = self.root\\n            for c in word:\\n                if c not in cur.children:\\n                    cur.children[c] = TrieNode()\\n                cur = cur.children[c]\\n            cur.isEnd = True\\n    def query(self, c: str) -> bool:\\n        self.cand[:] = [node for node in self.cand if c in node.children]  # \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n        for i in range(len(self.cand)):\\n            self.cand[i] = self.cand[i].children[c]\\n        if c in self.root.children:\\n            self.cand.append(self.root.children[c])\\n        return any(node.isEnd for node in self.cand)\\n```\n```\\nclass StreamChecker {\\n    struct TrieNode;\\n    using Map = unordered_map<char, shared_ptr<TrieNode>>;\\n    struct TrieNode {\\n        Map children;\\n        bool isEnd{ false };\\n    };\\n    shared_ptr<TrieNode> root;\\n    vector<shared_ptr<TrieNode>> cand;\\npublic:\\n    using VS = vector<string>;\\n    StreamChecker(VS& A) : root{ make_shared<TrieNode>() } {\\n        for (auto& word: A) {\\n            auto cur{ root };\\n            for (auto c: word)\\n                cur = cur->children.find(c) != cur->children.end() ? cur->children[c] : cur->children[c] = make_shared<TrieNode>();\\n            cur->isEnd = true;\\n        }\\n    }\\n    bool query(char c) {\\n        cand.erase(  // \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n            remove_if(cand.begin(), cand.end(), [=](auto node) {\\n                return node->children.find(c) == node->children.end();\\n            }), cand.end());\\n        for (auto& node: cand)\\n            node = node->children[c];\\n        if (root->children.find(c) != root->children.end())\\n            cand.push_back(root->children[c]);\\n        return any_of(cand.begin(), cand.end(), [](auto node) { return node->isEnd; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807590,
                "title": "javascript-super-short-and-simple-trie-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n    this.root = {};\\n    for (let w of words) {\\n      w = w.split(\\'\\').reverse().join(\\'\\');  \\n      let node = this.root;\\n      for (let c of w) {\\n        if (!node[c]) node[c] = {};\\n        node = node[c];\\n      }\\n      node.word = w;\\n    }\\n    this.letters = [];\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n    this.letters.push(letter);\\n    let lookingIn = this.root;\\n    for(let i = this.letters.length-1; i >=0; i--) {\\n        if(lookingIn[this.letters[i]]) {\\n            lookingIn = lookingIn[this.letters[i]];\\n            if(lookingIn.word) return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return false\\n};\\n\\n/** \\n * Your StreamChecker object will be instantiated and called as such:\\n * var obj = new StreamChecker(words)\\n * var param_1 = obj.query(letter)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n    this.root = {};\\n    for (let w of words) {\\n      w = w.split(\\'\\').reverse().join(\\'\\');  \\n      let node = this.root;\\n      for (let c of w) {\\n        if (!node[c]) node[c] = {};\\n        node = node[c];\\n      }\\n      node.word = w;\\n    }\\n    this.letters = [];\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n    this.letters.push(letter);\\n    let lookingIn = this.root;\\n    for(let i = this.letters.length-1; i >=0; i--) {\\n        if(lookingIn[this.letters[i]]) {\\n            lookingIn = lookingIn[this.letters[i]];\\n            if(lookingIn.word) return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return false\\n};\\n\\n/** \\n * Your StreamChecker object will be instantiated and called as such:\\n * var obj = new StreamChecker(words)\\n * var param_1 = obj.query(letter)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 396285,
                "title": "java-solution-with-trie-beats-97-8-easy-to-understand",
                "content": "Approach: first build a Trie but store words in reverse direction\\nsay we have ```words = [ \"abc, ad, fd\"] ```\\nThe Trie will be like this \\n```\\n           a                        d \\n\\t\\t/                        /     \\\\ \\n\\tb                         a(*)    f(*)\\n  / \\nc(*)\\n```\\nwhere the ```* ``` marks the end of the word. \\nThen just do regular trie search. \\n\\n```\\nclass StreamChecker {    \\n \\n    final static int ALPHABET_LENGTH = 26;\\n    TrieNode root;\\n    List<Character> history;\\n        \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next;\\n\\n        TrieNode() {\\n            isWord = false;\\n            next = new TrieNode[ALPHABET_LENGTH];\\n        }\\n    }\\n  \\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        buildTrie(words);\\n        history = new ArrayList<>();\\n    }\\n    \\n    void buildTrie(String[] words) {\\n        for (String s: words) {\\n            insert(s);\\n        }\\n    }\\n    \\n    void insert(String s) {\\n        TrieNode p = root;\\n\\t\\t//build trie but in reversed order for each word  \\n        for (int i=s.length()-1; i>=0; i--) {\\n            char c = s.charAt(i);\\n            if (p.next[c-\\'a\\'] == null) {\\n                p.next[c-\\'a\\'] = new TrieNode();\\n            }\\n            p = p.next[c-\\'a\\'];\\n        }\\n        p.isWord = true;\\n    }\\n\\n    public boolean query(char letter) {\\n        history.add(letter);\\n        TrieNode p = root;\\n        for (int i = history.size()-1; i >=0; i--) {\\n            char c = history.get(i);\\n\\t\\t\\t//return false immediately when we can\\'t find c in Trie\\n            if (p.next[c-\\'a\\'] == null) return false;\\n\\t\\t\\t//find a word  \\n            if (p.next[c-\\'a\\'].isWord) return true;\\n            p = p.next[c-\\'a\\'];\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```words = [ \"abc, ad, fd\"] ```\n```\\n           a                        d \\n\\t\\t/                        /     \\\\ \\n\\tb                         a(*)    f(*)\\n  / \\nc(*)\\n```\n```* ```\n```\\nclass StreamChecker {    \\n \\n    final static int ALPHABET_LENGTH = 26;\\n    TrieNode root;\\n    List<Character> history;\\n        \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next;\\n\\n        TrieNode() {\\n            isWord = false;\\n            next = new TrieNode[ALPHABET_LENGTH];\\n        }\\n    }\\n  \\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        buildTrie(words);\\n        history = new ArrayList<>();\\n    }\\n    \\n    void buildTrie(String[] words) {\\n        for (String s: words) {\\n            insert(s);\\n        }\\n    }\\n    \\n    void insert(String s) {\\n        TrieNode p = root;\\n\\t\\t//build trie but in reversed order for each word  \\n        for (int i=s.length()-1; i>=0; i--) {\\n            char c = s.charAt(i);\\n            if (p.next[c-\\'a\\'] == null) {\\n                p.next[c-\\'a\\'] = new TrieNode();\\n            }\\n            p = p.next[c-\\'a\\'];\\n        }\\n        p.isWord = true;\\n    }\\n\\n    public boolean query(char letter) {\\n        history.add(letter);\\n        TrieNode p = root;\\n        for (int i = history.size()-1; i >=0; i--) {\\n            char c = history.get(i);\\n\\t\\t\\t//return false immediately when we can\\'t find c in Trie\\n            if (p.next[c-\\'a\\'] == null) return false;\\n\\t\\t\\t//find a word  \\n            if (p.next[c-\\'a\\'].isWord) return true;\\n            p = p.next[c-\\'a\\'];\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278820,
                "title": "python-standard-trie-solution",
                "content": "1. Build a trie using the reversed words. \\n2. Keep track of the queried letters.\\n3. Check if the reverse of the queried string is in the trie.\\n```\\nfrom collections import defaultdict\\nclass Trie:\\n    def __init__(self):\\n        self.children = defaultdict(Trie)\\n        self.flag = False\\n    \\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        self.history = []\\n        for word in words:\\n            node = self.trie\\n            for char in word[::-1]:\\n                node = node.children[char]\\n            node.flag = True\\n\\n    def query(self, letter: str) -> bool:\\n        self.history.append(letter)\\n        node = self.trie\\n        for i in reversed(range(len(self.history))):\\n            if self.history[i] in node.children:\\n                node = node.children[self.history[i]]\\n                if node.flag: return True\\n            else: \\n                return False\\n        return False                \\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Trie:\\n    def __init__(self):\\n        self.children = defaultdict(Trie)\\n        self.flag = False\\n    \\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        self.history = []\\n        for word in words:\\n            node = self.trie\\n            for char in word[::-1]:\\n                node = node.children[char]\\n            node.flag = True\\n\\n    def query(self, letter: str) -> bool:\\n        self.history.append(letter)\\n        node = self.trie\\n        for i in reversed(range(len(self.history))):\\n            if self.history[i] in node.children:\\n                node = node.children[self.history[i]]\\n                if node.flag: return True\\n            else: \\n                return False\\n        return False                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610593,
                "title": "java-using-trie-faster-than-90",
                "content": "```\\nclass Node {\\n    Node[] child;\\n    boolean isLeaf;\\n    Node() {\\n        child = new Node[26];\\n        isLeaf = false;\\n    }\\n}\\nclass StreamChecker {\\n\\n    String[] words;\\n    Node root;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        this.words = words;\\n        sb = new StringBuilder();\\n        for(String s : words) {\\n            Node r = root;\\n            for(int i = s.length()-1; i > -1; i--) {\\n                if(r.child[s.charAt(i)-\\'a\\'] == null) r.child[s.charAt(i)-\\'a\\'] = new Node();\\n                r = r.child[s.charAt(i)-\\'a\\'];\\n            }\\n            r.isLeaf = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Node r = root;\\n        for(int i = sb.length()-1; i > -1; i--) {\\n            r = r.child[sb.charAt(i)-\\'a\\'];\\n            if(r == null) break;\\n            if(r.isLeaf) return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    Node[] child;\\n    boolean isLeaf;\\n    Node() {\\n        child = new Node[26];\\n        isLeaf = false;\\n    }\\n}\\nclass StreamChecker {\\n\\n    String[] words;\\n    Node root;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        this.words = words;\\n        sb = new StringBuilder();\\n        for(String s : words) {\\n            Node r = root;\\n            for(int i = s.length()-1; i > -1; i--) {\\n                if(r.child[s.charAt(i)-\\'a\\'] == null) r.child[s.charAt(i)-\\'a\\'] = new Node();\\n                r = r.child[s.charAt(i)-\\'a\\'];\\n            }\\n            r.isLeaf = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Node r = root;\\n        for(int i = sb.length()-1; i > -1; i--) {\\n            r = r.child[sb.charAt(i)-\\'a\\'];\\n            if(r == null) break;\\n            if(r.isLeaf) return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807600,
                "title": "c-simple-trie-87-time-w-explanation",
                "content": "For easily searching a word in O(k), use trie for that. We search for k last queried characters, in order of oldest to newest. So, if we reverse the order of words before inserting, the query order would be from newest to oldest.\\n\\nIf you do it like that, instead of O(k) time when we change k, we can simply have O(1) time for searching the new word, because the newly added character should have a prefix of all characters queried so far, so we only have to look only one level down from where we have searched till now.\\n```\\nclass StreamChecker {\\npublic:\\n    struct trie\\n    {\\n        bool eof;\\n        struct trie *children[26];\\n    };\\n    trie* createNode()\\n    {\\n        trie* ret=(trie*)malloc(sizeof(trie));\\n        ret->eof=false;\\n        for(int i=0;i<26;++i)\\n            ret->children[i]=NULL;\\n        return ret;\\n    }\\n    void insert(trie* root,string key)\\n    {\\n        trie* temp=root;\\n        for(char x:key)\\n        {\\n            if(temp->children[x-\\'a\\']==NULL)\\n                temp->children[x-\\'a\\']=createNode();\\n            temp=temp->children[x-\\'a\\'];\\n        }\\n        temp->eof=true;\\n    }\\n    trie* root;\\n    string temp;\\n    StreamChecker(vector<string>& words) \\n    {\\n        root=createNode();\\n        for(string x:words)\\n        {\\n            reverse(x.begin(),x.end());\\n            insert(root,x);\\n        }\\n    }\\n    \\n    bool query(char letter) \\n    {\\n        temp.push_back(letter);\\n        trie* t=root;\\n        for(int i=temp.size()-1;i>=0;--i)\\n        {\\n            t=t->children[temp[i]-\\'a\\'];\\n            if(t==NULL)\\n                return false;\\n            else if(t->eof)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct trie\\n    {\\n        bool eof;\\n        struct trie *children[26];\\n    };\\n    trie* createNode()\\n    {\\n        trie* ret=(trie*)malloc(sizeof(trie));\\n        ret->eof=false;\\n        for(int i=0;i<26;++i)\\n            ret->children[i]=NULL;\\n        return ret;\\n    }\\n    void insert(trie* root,string key)\\n    {\\n        trie* temp=root;\\n        for(char x:key)\\n        {\\n            if(temp->children[x-\\'a\\']==NULL)\\n                temp->children[x-\\'a\\']=createNode();\\n            temp=temp->children[x-\\'a\\'];\\n        }\\n        temp->eof=true;\\n    }\\n    trie* root;\\n    string temp;\\n    StreamChecker(vector<string>& words) \\n    {\\n        root=createNode();\\n        for(string x:words)\\n        {\\n            reverse(x.begin(),x.end());\\n            insert(root,x);\\n        }\\n    }\\n    \\n    bool query(char letter) \\n    {\\n        temp.push_back(letter);\\n        trie* t=root;\\n        for(int i=temp.size()-1;i>=0;--i)\\n        {\\n            t=t->children[temp[i]-\\'a\\'];\\n            if(t==NULL)\\n                return false;\\n            else if(t->eof)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573172,
                "title": "javascript-with-trie",
                "content": "Implemented a Trie with a hasWord() method that:\\n* Returns true if the word is in the trie\\n* Returs false if the word is not in the trie\\n* Returns lastNode if the word is partially in the trie, so we can keep trying.\\n\\n\\n```JS\\n\\nclass TrieNode {\\n    constructor(value){\\n        this.value = value;\\n        this.children = {};\\n        this.end = false;\\n    }\\n}\\n\\nclass Trie {\\n    constructor(){\\n        this.root = new TrieNode(\"*\");\\n    }\\n\\n    addWord(word){\\n\\n        let lastNode = this.root;\\n\\n        for(let i=0; i < word.length; i++){\\n            let char = word[i];\\n            if(lastNode.children[char] === undefined){\\n                lastNode.children[char] = new TrieNode(char);\\n            }\\n            lastNode = lastNode.children[char];\\n            if(i == word.length - 1) lastNode.end = true;\\n\\n        }\\n    }\\n\\n    hasWord(word){ \\n        let lastNode = this.root;\\n        for(let i = 0; i < word.length; i++){\\n            let char = word[i];\\n            if(lastNode.children[char] === undefined){\\n                return false //returns false if the word is not in the trie\\n            }\\n            else{\\n                lastNode = lastNode.children[char];\\n            }\\n            \\n            if(i == word.length - 1 && lastNode.end){ //true if has the word\\n                return true;\\n            }\\n            else if (i == word.length - 1){ //return lastNode if a word matches partially\\n                return lastNode\\n            }\\n        }\\n        \\n        return false;\\n\\n    }\\n}\\n\\nclass StreamChecker{\\n    constructor(words){\\n        this.trie = new Trie();\\n        this.letters = [];\\n        \\n        for(let word of words){\\n            let reversedWord = word.split(\\'\\').reverse().join(\\'\\')\\n            this.trie.addWord(reversedWord);\\n        }\\n    }\\n    \\n    query(letter){\\n        this.letters.unshift(letter);\\n        let possibleWord = \"\"\\n        for(let letter of this.letters){\\n            possibleWord = possibleWord + letter;\\n            let trieWord = this.trie.hasWord(possibleWord);\\n            if(trieWord === true) return true;\\n            if(trieWord === false) return false;\\n        }\\n\\t\\t\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```JS\\n\\nclass TrieNode {\\n    constructor(value){\\n        this.value = value;\\n        this.children = {};\\n        this.end = false;\\n    }\\n}\\n\\nclass Trie {\\n    constructor(){\\n        this.root = new TrieNode(\"*\");\\n    }\\n\\n    addWord(word){\\n\\n        let lastNode = this.root;\\n\\n        for(let i=0; i < word.length; i++){\\n            let char = word[i];\\n            if(lastNode.children[char] === undefined){\\n                lastNode.children[char] = new TrieNode(char);\\n            }\\n            lastNode = lastNode.children[char];\\n            if(i == word.length - 1) lastNode.end = true;\\n\\n        }\\n    }\\n\\n    hasWord(word){ \\n        let lastNode = this.root;\\n        for(let i = 0; i < word.length; i++){\\n            let char = word[i];\\n            if(lastNode.children[char] === undefined){\\n                return false //returns false if the word is not in the trie\\n            }\\n            else{\\n                lastNode = lastNode.children[char];\\n            }\\n            \\n            if(i == word.length - 1 && lastNode.end){ //true if has the word\\n                return true;\\n            }\\n            else if (i == word.length - 1){ //return lastNode if a word matches partially\\n                return lastNode\\n            }\\n        }\\n        \\n        return false;\\n\\n    }\\n}\\n\\nclass StreamChecker{\\n    constructor(words){\\n        this.trie = new Trie();\\n        this.letters = [];\\n        \\n        for(let word of words){\\n            let reversedWord = word.split(\\'\\').reverse().join(\\'\\')\\n            this.trie.addWord(reversedWord);\\n        }\\n    }\\n    \\n    query(letter){\\n        this.letters.unshift(letter);\\n        let possibleWord = \"\"\\n        for(let letter of this.letters){\\n            possibleWord = possibleWord + letter;\\n            let trieWord = this.trie.hasWord(possibleWord);\\n            if(trieWord === true) return true;\\n            if(trieWord === false) return false;\\n        }\\n\\t\\t\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282698,
                "title": "my-python-trie-solution-reverse-the-word-first-then-insert-into-trie",
                "content": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n        self.buff = []\\n\\n    def query(self, letter: str) -> bool:\\n        self.buff.append(letter)\\n        n = len(self.buff)\\n        s = \"\"\\n        for i in range(n - 1, max(n - 2000, -1), -1):\\n            s += self.buff[i]\\n            if not self.trie.startsWith(s):\\n                return False\\n            if self.trie.contains(s):\\n                return True\\n        return False\\n            \\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(\"\")\\n        \\n    def insert(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                current.child[ord(c) - ord(\\'a\\')] = TrieNode(c)\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        current.isEnd = True\\n        \\n    def contains(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                return False\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        return current.isEnd\\n    \\n    def startsWith(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                return False\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        return True\\n        \\n        \\n        \\n        \\nclass TrieNode:\\n    def __init__(self, char):\\n        self.val = char\\n        self.isEnd = False\\n        self.child = [None for i in range(27)]\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n        self.buff = []\\n\\n    def query(self, letter: str) -> bool:\\n        self.buff.append(letter)\\n        n = len(self.buff)\\n        s = \"\"\\n        for i in range(n - 1, max(n - 2000, -1), -1):\\n            s += self.buff[i]\\n            if not self.trie.startsWith(s):\\n                return False\\n            if self.trie.contains(s):\\n                return True\\n        return False\\n            \\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(\"\")\\n        \\n    def insert(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                current.child[ord(c) - ord(\\'a\\')] = TrieNode(c)\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        current.isEnd = True\\n        \\n    def contains(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                return False\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        return current.isEnd\\n    \\n    def startsWith(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                return False\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        return True\\n        \\n        \\n        \\n        \\nclass TrieNode:\\n    def __init__(self, char):\\n        self.val = char\\n        self.isEnd = False\\n        self.child = [None for i in range(27)]\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610912,
                "title": "c-aho-corasick-algorithm-o-1-queries",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    const static int K = 26;\\n    int node = 0;\\n\\n    struct Vertex {\\n        int next[K];\\n        bool leaf = false;\\n        int p = -1;\\n        char pch;\\n        int link = -1;\\n        int go[K];\\n        bool seen = false;\\n\\n        Vertex(int p=-1, char ch=\\'$\\') : p(p), pch(ch) {\\n            fill(begin(next), end(next), -1);\\n            fill(begin(go), end(go), -1);\\n        }\\n    };\\n\\n    vector<Vertex> t;\\n\\n    void add_string(string const& s) {\\n        int v = 0;\\n        for (char ch : s) {\\n            int c = ch - \\'a\\';\\n            if (t[v].next[c] == -1) {\\n                t[v].next[c] = t.size();\\n                t.emplace_back(v, ch);\\n            }\\n            v = t[v].next[c];\\n        }\\n        t[v].leaf = true;\\n    }\\n\\n    int get_link(int v) {\\n        if (t[v].link == -1) {\\n            if (v == 0 || t[v].p == 0)\\n                t[v].link = 0;\\n            else\\n                t[v].link = go(get_link(t[v].p), t[v].pch);\\n        }\\n        return t[v].link;\\n    }\\n\\n    int go(int v, char ch) {\\n        int c = ch - \\'a\\';\\n        if (t[v].go[c] == -1) {\\n            if (t[v].next[c] != -1)\\n                t[v].go[c] = t[v].next[c];\\n            else\\n                t[v].go[c] = v == 0 ? 0 : go(get_link(v), ch);\\n        }\\n        return t[v].go[c];\\n    }\\n\\n    bool DFS(const int u) {\\n        if (t[u].seen)\\n            return t[u].leaf;\\n        t[u].seen = true;\\n        if (!t[u].leaf)\\n            t[u].leaf = DFS(get_link(u));\\n        for (int i = 0; i < 26; i++) {\\n            if (t[u].next[i] != -1)\\n                DFS(t[u].next[i]);\\n        }\\n        return t[u].leaf;\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        t.push_back(Vertex());\\n        for (auto& w : words)\\n            add_string(w);\\n        DFS(0);\\n    }\\n    \\n    bool query(char letter) {\\n        node = go(node, letter);\\n        return t[node].leaf;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    const static int K = 26;\\n    int node = 0;\\n\\n    struct Vertex {\\n        int next[K];\\n        bool leaf = false;\\n        int p = -1;\\n        char pch;\\n        int link = -1;\\n        int go[K];\\n        bool seen = false;\\n\\n        Vertex(int p=-1, char ch=\\'$\\') : p(p), pch(ch) {\\n            fill(begin(next), end(next), -1);\\n            fill(begin(go), end(go), -1);\\n        }\\n    };\\n\\n    vector<Vertex> t;\\n\\n    void add_string(string const& s) {\\n        int v = 0;\\n        for (char ch : s) {\\n            int c = ch - \\'a\\';\\n            if (t[v].next[c] == -1) {\\n                t[v].next[c] = t.size();\\n                t.emplace_back(v, ch);\\n            }\\n            v = t[v].next[c];\\n        }\\n        t[v].leaf = true;\\n    }\\n\\n    int get_link(int v) {\\n        if (t[v].link == -1) {\\n            if (v == 0 || t[v].p == 0)\\n                t[v].link = 0;\\n            else\\n                t[v].link = go(get_link(t[v].p), t[v].pch);\\n        }\\n        return t[v].link;\\n    }\\n\\n    int go(int v, char ch) {\\n        int c = ch - \\'a\\';\\n        if (t[v].go[c] == -1) {\\n            if (t[v].next[c] != -1)\\n                t[v].go[c] = t[v].next[c];\\n            else\\n                t[v].go[c] = v == 0 ? 0 : go(get_link(v), ch);\\n        }\\n        return t[v].go[c];\\n    }\\n\\n    bool DFS(const int u) {\\n        if (t[u].seen)\\n            return t[u].leaf;\\n        t[u].seen = true;\\n        if (!t[u].leaf)\\n            t[u].leaf = DFS(get_link(u));\\n        for (int i = 0; i < 26; i++) {\\n            if (t[u].next[i] != -1)\\n                DFS(t[u].next[i]);\\n        }\\n        return t[u].leaf;\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        t.push_back(Vertex());\\n        for (auto& w : words)\\n            add_string(w);\\n        DFS(0);\\n    }\\n    \\n    bool query(char letter) {\\n        node = go(node, letter);\\n        return t[node].leaf;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610735,
                "title": "swift-stream-of-characters-24-9-mb-100-test-case",
                "content": "```swift\\nclass StreamChecker {\\n    \\n    private final class TrieNode {\\n        var children: [Character:TrieNode]\\n        var word: Bool\\n        init(children: [Character:TrieNode] = [:], word: Bool = false) {\\n            self.children = children\\n            self.word = word\\n        }\\n    }\\n    \\n    private let trie: TrieNode\\n    private var stream: [Character]\\n    private let longWord: Int\\n    \\n    init(_ words: [String]) {\\n        trie = TrieNode()\\n        stream = [Character]()\\n        var lw = 0\\n        \\n        for word in words {\\n            lw = max(lw, word.count)\\n            \\n            var node = trie\\n            for ch in word.reversed() {\\n                if node.children[ch] == nil {\\n                    node.children[ch] = TrieNode()\\n                }\\n                if let child = node.children[ch] {\\n                    node = child\\n                }\\n            }\\n            node.word = true\\n        }\\n        self.longWord = lw\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        stream.insert(letter, at: 0)\\n        \\n        if stream.count > longWord {\\n            stream.removeLast()\\n        }\\n        \\n        var node = trie\\n        for ch in stream {\\n            guard !node.word else { return true }\\n            if let child = node.children[ch] {\\n                node = child\\n            } else {\\n                return false\\n            }\\n        }\\n        return node.word\\n    }\\n}\\n```\\n\\n```swift\\n// Result: Executed 1 test, with 0 failures (0 unexpected) in 0.041 (0.043) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    func test0() {\\n        let sc = StreamChecker([\"cd\",\"f\",\"kl\"])\\n        XCTAssertFalse(sc.query(\"a\")) // false\\n        XCTAssertFalse(sc.query(\"b\")) // false\\n        XCTAssertFalse(sc.query(\"c\")) // false\\n        XCTAssertTrue(sc.query(\"d\"))  // true, because \\'cd\\' is in the wordlist\\n        XCTAssertFalse(sc.query(\"e\")) // false\\n        XCTAssertTrue(sc.query(\"f\"))  // true, because \\'f\\' is in the wordlist\\n        XCTAssertFalse(sc.query(\"g\")) // false\\n        XCTAssertFalse(sc.query(\"h\")) // false\\n        XCTAssertFalse(sc.query(\"i\")) // false\\n        XCTAssertFalse(sc.query(\"j\")) // false\\n        XCTAssertFalse(sc.query(\"k\")) // false\\n        XCTAssertTrue(sc.query(\"l\"))  // true, because \\'kl\\' is in the wordlist\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass StreamChecker {\\n    \\n    private final class TrieNode {\\n        var children: [Character:TrieNode]\\n        var word: Bool\\n        init(children: [Character:TrieNode] = [:], word: Bool = false) {\\n            self.children = children\\n            self.word = word\\n        }\\n    }\\n    \\n    private let trie: TrieNode\\n    private var stream: [Character]\\n    private let longWord: Int\\n    \\n    init(_ words: [String]) {\\n        trie = TrieNode()\\n        stream = [Character]()\\n        var lw = 0\\n        \\n        for word in words {\\n            lw = max(lw, word.count)\\n            \\n            var node = trie\\n            for ch in word.reversed() {\\n                if node.children[ch] == nil {\\n                    node.children[ch] = TrieNode()\\n                }\\n                if let child = node.children[ch] {\\n                    node = child\\n                }\\n            }\\n            node.word = true\\n        }\\n        self.longWord = lw\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        stream.insert(letter, at: 0)\\n        \\n        if stream.count > longWord {\\n            stream.removeLast()\\n        }\\n        \\n        var node = trie\\n        for ch in stream {\\n            guard !node.word else { return true }\\n            if let child = node.children[ch] {\\n                node = child\\n            } else {\\n                return false\\n            }\\n        }\\n        return node.word\\n    }\\n}\\n```\n```swift\\n// Result: Executed 1 test, with 0 failures (0 unexpected) in 0.041 (0.043) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    func test0() {\\n        let sc = StreamChecker([\"cd\",\"f\",\"kl\"])\\n        XCTAssertFalse(sc.query(\"a\")) // false\\n        XCTAssertFalse(sc.query(\"b\")) // false\\n        XCTAssertFalse(sc.query(\"c\")) // false\\n        XCTAssertTrue(sc.query(\"d\"))  // true, because \\'cd\\' is in the wordlist\\n        XCTAssertFalse(sc.query(\"e\")) // false\\n        XCTAssertTrue(sc.query(\"f\"))  // true, because \\'f\\' is in the wordlist\\n        XCTAssertFalse(sc.query(\"g\")) // false\\n        XCTAssertFalse(sc.query(\"h\")) // false\\n        XCTAssertFalse(sc.query(\"i\")) // false\\n        XCTAssertFalse(sc.query(\"j\")) // false\\n        XCTAssertFalse(sc.query(\"k\")) // false\\n        XCTAssertTrue(sc.query(\"l\"))  // true, because \\'kl\\' is in the wordlist\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610475,
                "title": "c-trie-suffix-search",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    class Trie{\\n        public:\\n        Trie *child[26];\\n        bool isEnd = false;\\n    };\\n    \\n    void insert(string &s, Trie *root){\\n        Trie *cur = root;\\n        int n=s.size();\\n        for(int i=n-1; i>=0; --i){\\n            char ch = s[i];\\n            if(!cur->child[ch-\\'a\\']) cur->child[ch-\\'a\\'] = new Trie();\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string &s, Trie *root){\\n        Trie *cur = root;\\n        int n=s.size();\\n        for(int i=n-1; i>=0; --i){\\n            char ch = s[i];\\n            if(!cur->child[ch-\\'a\\']) return false;\\n            cur=cur->child[ch-\\'a\\'];\\n            if(cur->isEnd) return true;\\n        }\\n        return false;\\n    }\\n    \\n    Trie *root;\\n    string str =\"\";\\n    StreamChecker(vector<string>& words) {\\n        root = new Trie();\\n        for(auto &w : words) insert(w,root);\\n    }\\n    \\n    bool query(char letter) {\\n        str.push_back(letter);\\n        return search(str,root);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    class Trie{\\n        public:\\n        Trie *child[26];\\n        bool isEnd = false;\\n    };\\n    \\n    void insert(string &s, Trie *root){\\n        Trie *cur = root;\\n        int n=s.size();\\n        for(int i=n-1; i>=0; --i){\\n            char ch = s[i];\\n            if(!cur->child[ch-\\'a\\']) cur->child[ch-\\'a\\'] = new Trie();\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string &s, Trie *root){\\n        Trie *cur = root;\\n        int n=s.size();\\n        for(int i=n-1; i>=0; --i){\\n            char ch = s[i];\\n            if(!cur->child[ch-\\'a\\']) return false;\\n            cur=cur->child[ch-\\'a\\'];\\n            if(cur->isEnd) return true;\\n        }\\n        return false;\\n    }\\n    \\n    Trie *root;\\n    string str =\"\";\\n    StreamChecker(vector<string>& words) {\\n        root = new Trie();\\n        for(auto &w : words) insert(w,root);\\n    }\\n    \\n    bool query(char letter) {\\n        str.push_back(letter);\\n        return search(str,root);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501438,
                "title": "intuition-explained-trie-approach-clean-code-in-c",
                "content": "**Intuition:**\\n\\nMain Idea in this problem is to store words in **reverse order** in our Trie, so that to find suffix from *stream of characters* will become easy and efficient. \\n\\n\\tEx : \"xyz\" will be store as \"z -> y -> x (end)\" in Trie\\n\\t\\n* Now, once we build (store words) in Trie, we can easily search suffixes in stream of characters. We store all incoming characters from stream into a string, and start searching for words from end of `streamString`. \\n\\n\\t\\tEx: streamString = \"axyz\" , \\n\\t\\t-> now we need to query so start searching from end i.e character \\'z\\'\\n\\t\\t-> Trie has word \"zyx\" stored \\n\\n\\t\\ti. \"z\" , present so move to next character i.e \\'y\\'\\n\\t\\tii. \"z -> y\" , Present so move to next character i.e \\'x\\'\\n\\t\\tiii. \"z -> y -> x (end)\" , Present so move to next character, but this is end of word. \\n\\n\\t\\tSince we found a suffix word, return True.\\n\\t\\n\\n* Whenever we encounter a character that is not present in the Trie or Trie Node reaches NULL we return false. \\nAnd whenever we each a word end with `flag=True`, return true.\\n\\nRemaining Code is self-explainatory.\\n# Code:\\n\\n```\\nstruct Node {\\n    Node* arr[26];\\n    bool flag = false;\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'] != NULL;\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    bool getFlag() {\\n        return flag;\\n    }\\n    \\n    void setFlag() {\\n        flag = true;\\n    }\\n        \\n};\\n\\nclass StreamChecker {\\n    string streamString = \"\";\\n    Node* root;\\npublic:\\n    \\n\\t// Insert string in reverse order into Trie.\\n    void insert(string s) {\\n        Node* temp = root;\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(!temp->contains(s[i])) {\\n                temp->put(s[i], new Node());\\n            }\\n            temp = temp->getNext(s[i]);\\n        }\\n        temp->setFlag();  // End of string \\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new Node();\\n        \\n        for(auto& word : words) {\\n            insert(word);\\n        }\\n    }\\n    // Seach for string from end of streamString \\n\\t// Character by character \\n    bool query(char letter) {\\n        streamString += letter;\\n        Node* temp = root;\\n        for(int i=streamString.size()-1; i>=0 && temp; i--) {\\n\\t\\t\\t// Return false If char if not present or Trie Node is NULL \\n            if(!temp || !temp->contains(streamString[i])) return false; \\n\\t\\t\\t\\n\\t\\t\\t// Move to next character if present\\n            temp = temp->getNext(streamString[i]);\\n            if(temp->getFlag()) return true;  // Reached the end of a word , so return true\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Time : O(N * W + W * Q) ,**\\n* N -> No. of words \\n* W -> Length of Words\\n* Q -> No. of queries\\n\\n**Space : O(N * W)**\\n\\n***If this solution helped you, please give upvote :)***",
                "solutionTags": [
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n    Node* arr[26];\\n    bool flag = false;\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'] != NULL;\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    bool getFlag() {\\n        return flag;\\n    }\\n    \\n    void setFlag() {\\n        flag = true;\\n    }\\n        \\n};\\n\\nclass StreamChecker {\\n    string streamString = \"\";\\n    Node* root;\\npublic:\\n    \\n\\t// Insert string in reverse order into Trie.\\n    void insert(string s) {\\n        Node* temp = root;\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(!temp->contains(s[i])) {\\n                temp->put(s[i], new Node());\\n            }\\n            temp = temp->getNext(s[i]);\\n        }\\n        temp->setFlag();  // End of string \\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new Node();\\n        \\n        for(auto& word : words) {\\n            insert(word);\\n        }\\n    }\\n    // Seach for string from end of streamString \\n\\t// Character by character \\n    bool query(char letter) {\\n        streamString += letter;\\n        Node* temp = root;\\n        for(int i=streamString.size()-1; i>=0 && temp; i--) {\\n\\t\\t\\t// Return false If char if not present or Trie Node is NULL \\n            if(!temp || !temp->contains(streamString[i])) return false; \\n\\t\\t\\t\\n\\t\\t\\t// Move to next character if present\\n            temp = temp->getNext(streamString[i]);\\n            if(temp->getFlag()) return true;  // Reached the end of a word , so return true\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064819,
                "title": "java-trie-beats-99-56-77ms-query-o-query-length",
                "content": "\\n\\n\\tpublic class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tchar data;\\n\\t\\t\\tNode[] children;\\n\\t\\t\\tboolean isTerminal;\\n\\n\\t\\t\\tpublic Node(char data, boolean isTerminal) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\t\\tthis.children = new Node[26];\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(\\'\\\\0\\', false);\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic void addWord(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = word.length() - 1; i >= 0; i--) {\\n\\t\\t\\t\\tchar ch = word.charAt(i);\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\t\\ttemp = new Node(ch, false);\\n\\t\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\tcurr.isTerminal = true;\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic boolean searchWord(StringBuilder sb) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = sb.length() - 1; i >= 0; i--) {\\n\\t\\t\\t\\tchar ch = sb.charAt(i);\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t\\tif (curr.isTerminal)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass StreamChecker {\\n\\n\\t\\tTrie trie;\\n\\t\\tStringBuilder sb;\\n\\n\\t\\t// O(words.length*words[i].length)\\n\\t\\tpublic StreamChecker(String[] words) {\\n\\t\\t\\ttrie = new Trie();\\n\\t\\t\\tsb = new StringBuilder();\\n\\t\\t\\tfor (String word : words)\\n\\t\\t\\t\\ttrie.addWord(word);\\n\\t\\t}\\n\\n\\t\\t// O(query.length)\\n\\t\\tpublic boolean query(char letter) {\\n\\t\\t\\tsb.append(letter);\\n\\t\\t\\treturn trie.searchWord(sb);\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\n\\tpublic class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tchar data;\\n\\t\\t\\tNode[] children;\\n\\t\\t\\tboolean isTerminal;\\n\\n\\t\\t\\tpublic Node(char data, boolean isTerminal) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\t\\tthis.children = new Node[26];\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(\\'\\\\0\\', false);\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic void addWord(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = word.length() - 1; i >= 0; i--) {\\n\\t\\t\\t\\tchar ch = word.charAt(i);\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\t\\ttemp = new Node(ch, false);\\n\\t\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\tcurr.isTerminal = true;\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic boolean searchWord(StringBuilder sb) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = sb.length() - 1; i >= 0; i--) {\\n\\t\\t\\t\\tchar ch = sb.charAt(i);\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t\\tif (curr.isTerminal)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass StreamChecker {\\n\\n\\t\\tTrie trie;\\n\\t\\tStringBuilder sb;\\n\\n\\t\\t// O(words.length*words[i].length)\\n\\t\\tpublic StreamChecker(String[] words) {\\n\\t\\t\\ttrie = new Trie();\\n\\t\\t\\tsb = new StringBuilder();\\n\\t\\t\\tfor (String word : words)\\n\\t\\t\\t\\ttrie.addWord(word);\\n\\t\\t}\\n\\n\\t\\t// O(query.length)\\n\\t\\tpublic boolean query(char letter) {\\n\\t\\t\\tsb.append(letter);\\n\\t\\t\\treturn trie.searchWord(sb);\\n\\t\\t}\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1059320,
                "title": "fast-and-simple-c-180ms-beats-100",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    struct Trie\\n    {    \\n        Trie *child[26];\\n        bool isEnd;\\n        Trie()\\n        {\\n            isEnd=false;\\n            for(int i=0;i<26;i++)\\n            {\\n                child[i]=NULL;\\n            }\\n        }\\n    };\\n    Trie *root=new Trie();\\n    string s;\\n    void insert(string s)\\n    {\\n        Trie *node=root;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(node->child[s[i]-\\'a\\']==NULL)\\n            {\\n                node->child[s[i]-\\'a\\']=new Trie();;\\n            }\\n            node=node->child[s[i]-\\'a\\'];\\n        }\\n        node->isEnd=true;\\n    }\\n    StreamChecker(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            insert(words[i]);\\n        }\\n    }\\n    bool check()\\n    {\\n        Trie *node=root;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(node->child[s[i]-\\'a\\']==NULL)\\n                return false;\\n            if(node->child[s[i]-\\'a\\']->isEnd==true)\\n                return true;\\n            node=node->child[s[i]-\\'a\\'];\\n        }\\n        return false;\\n    }\\n    bool query(char letter) {\\n        s.push_back(letter);\\n        return check();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct Trie\\n    {    \\n        Trie *child[26];\\n        bool isEnd;\\n        Trie()\\n        {\\n            isEnd=false;\\n            for(int i=0;i<26;i++)\\n            {\\n                child[i]=NULL;\\n            }\\n        }\\n    };\\n    Trie *root=new Trie();\\n    string s;\\n    void insert(string s)\\n    {\\n        Trie *node=root;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(node->child[s[i]-\\'a\\']==NULL)\\n            {\\n                node->child[s[i]-\\'a\\']=new Trie();;\\n            }\\n            node=node->child[s[i]-\\'a\\'];\\n        }\\n        node->isEnd=true;\\n    }\\n    StreamChecker(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            insert(words[i]);\\n        }\\n    }\\n    bool check()\\n    {\\n        Trie *node=root;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(node->child[s[i]-\\'a\\']==NULL)\\n                return false;\\n            if(node->child[s[i]-\\'a\\']->isEnd==true)\\n                return true;\\n            node=node->child[s[i]-\\'a\\'];\\n        }\\n        return false;\\n    }\\n    bool query(char letter) {\\n        s.push_back(letter);\\n        return check();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807514,
                "title": "python-stream-of-characters-simple",
                "content": "Idea is to construct a trie by inserting each word in reverse order. \\nWe can use a non-alpha char \\'#\\' to signify the end of a word.\\n\\nWhen querying, we simply iterate over the history (in reverse order) and traverse the trie at the same time and checking if we see our \\'end word\\' symbol\\n\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.history = \"\"\\n        self.map = {}\\n        \\n        for word in words:\\n            curr_node = self.map\\n            for letter in word[::-1]:\\n                if letter not in curr_node:\\n                    curr_node[letter] = {}\\n                curr_node = curr_node[letter]\\n            curr_node[\\'#\\'] = {}\\n\\n    def query(self, letter: str) -> bool:\\n        self.history += letter\\n\\n        curr_node = self.map\\n        for l in self.history[::-1]:\\n\\n            if l not in curr_node:\\n                return False\\n                    \\n            curr_node = curr_node[l]\\n        \\n            if \\'#\\' in curr_node:\\n                return True\\n        \\n        return False",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "Idea is to construct a trie by inserting each word in reverse order. \\nWe can use a non-alpha char \\'#\\' to signify the end of a word.\\n\\nWhen querying, we simply iterate over the history (in reverse order) and traverse the trie at the same time and checking if we see our \\'end word\\' symbol\\n\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.history = \"\"\\n        self.map = {}\\n        \\n        for word in words:\\n            curr_node = self.map\\n            for letter in word[::-1]:\\n                if letter not in curr_node:\\n                    curr_node[letter] = {}\\n                curr_node = curr_node[letter]\\n            curr_node[\\'#\\'] = {}\\n\\n    def query(self, letter: str) -> bool:\\n        self.history += letter\\n\\n        curr_node = self.map\\n        for l in self.history[::-1]:\\n\\n            if l not in curr_node:\\n                return False\\n                    \\n            curr_node = curr_node[l]\\n        \\n            if \\'#\\' in curr_node:\\n                return True\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 514248,
                "title": "java-99-time-100-memory",
                "content": "Inspired by [link](https://leetcode.com/problems/stream-of-characters/discuss/396285/Java-solution-with-Trie-beats-97.8-easy-to-understand/) that builds the Trie tree backwards. Note that the longest word is 2000, so we can use a rotating array instead of saving the whole history.\\n```\\nclass StreamChecker {\\n\\n    class Trie {\\n        boolean word;\\n        Trie[] next;\\n        \\n        public Trie() {\\n            this.next = new Trie[26];\\n            this.word = false;\\n        }\\n    }\\n    \\n    Trie root = null;\\n    int p = 0;\\n    char[] history;\\n    \\n    public void insert(String word) {\\n        Trie curr = root;\\n        for (int i = word.length() - 1; i >=0; i--) {\\n            if (curr.next[word.charAt(i) - \\'a\\'] == null) {\\n                curr.next[word.charAt(i) - \\'a\\'] = new Trie();\\n            }\\n            curr = curr.next[word.charAt(i) - \\'a\\'];\\n        }\\n        curr.word = true;\\n    }\\n    \\n    public StreamChecker(String[] words) {\\n        this.root = new Trie();\\n        for (String word : words) {\\n            insert(word);\\n        }\\n        this.history = new char[2000];\\n    }\\n    \\n    public boolean query(char letter) {\\n        // System.out.println(\"query \" + letter);\\n        history[p % 2000] = letter;\\n        Trie curr = root;\\n        boolean match = false;\\n        for (int i = 0; i < 2000 && !match; i++) {\\n            char curChar = history[(p - i + 2000) % 2000];\\n            // System.out.println(\"look \" + curChar);\\n            if (curChar == 0) {\\n                break;\\n            }\\n            if (curr.next[curChar - \\'a\\'] != null) {\\n                curr = curr.next[curChar - \\'a\\'];\\n                if (curr.word) {\\n                    match = true;\\n                    // System.out.println(\"match \" + curChar);\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        p++;\\n        return match;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StreamChecker {\\n\\n    class Trie {\\n        boolean word;\\n        Trie[] next;\\n        \\n        public Trie() {\\n            this.next = new Trie[26];\\n            this.word = false;\\n        }\\n    }\\n    \\n    Trie root = null;\\n    int p = 0;\\n    char[] history;\\n    \\n    public void insert(String word) {\\n        Trie curr = root;\\n        for (int i = word.length() - 1; i >=0; i--) {\\n            if (curr.next[word.charAt(i) - \\'a\\'] == null) {\\n                curr.next[word.charAt(i) - \\'a\\'] = new Trie();\\n            }\\n            curr = curr.next[word.charAt(i) - \\'a\\'];\\n        }\\n        curr.word = true;\\n    }\\n    \\n    public StreamChecker(String[] words) {\\n        this.root = new Trie();\\n        for (String word : words) {\\n            insert(word);\\n        }\\n        this.history = new char[2000];\\n    }\\n    \\n    public boolean query(char letter) {\\n        // System.out.println(\"query \" + letter);\\n        history[p % 2000] = letter;\\n        Trie curr = root;\\n        boolean match = false;\\n        for (int i = 0; i < 2000 && !match; i++) {\\n            char curChar = history[(p - i + 2000) % 2000];\\n            // System.out.println(\"look \" + curChar);\\n            if (curChar == 0) {\\n                break;\\n            }\\n            if (curr.next[curChar - \\'a\\'] != null) {\\n                curr = curr.next[curChar - \\'a\\'];\\n                if (curr.word) {\\n                    match = true;\\n                    // System.out.println(\"match \" + curChar);\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        p++;\\n        return match;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513291,
                "title": "javascript-solution-using-hashmap-substring",
                "content": "```\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n    this.dict = {};\\n    for(let i of words){\\n        this.dict[i]=1;\\n    }\\n    this.current = \\'\\';\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n    this.current+=letter;\\n    for(let i in this.dict){\\n        if(this.current.length<i.length){\\n            continue;\\n        }\\n        if(this.current.substring(this.current.length-i.length,this.current.length)===i){\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\n/** \\n * Your StreamChecker object will be instantiated and called as such:\\n * var obj = new StreamChecker(words)\\n * var param_1 = obj.query(letter)\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n    this.dict = {};\\n    for(let i of words){\\n        this.dict[i]=1;\\n    }\\n    this.current = \\'\\';\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n    this.current+=letter;\\n    for(let i in this.dict){\\n        if(this.current.length<i.length){\\n            continue;\\n        }\\n        if(this.current.substring(this.current.length-i.length,this.current.length)===i){\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\n/** \\n * Your StreamChecker object will be instantiated and called as such:\\n * var obj = new StreamChecker(words)\\n * var param_1 = obj.query(letter)\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 512900,
                "title": "c-trie-and-keep-pointers-to-word-candidates",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    class TrieNode {\\n    public:\\n        TrieNode() : children {}, leaf(false) {}\\n        bool leaf;\\n        TrieNode* children[26];\\n    };\\n    \\n    StreamChecker(std::vector<std::string>& words) {\\n        root = new TrieNode();\\n        \\n        for (auto& word : words) {\\n            TrieNode* it = root;        \\n            for (char c : word) {\\n                if (!it->children[c - \\'a\\'])\\n                    it->children[c - \\'a\\'] = new TrieNode();\\n                it = it->children[c - \\'a\\'];\\n            }\\n            it->leaf = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        \\n        std::vector<TrieNode*> newpaths;\\n        paths.push_back(root);\\n        \\n        for (TrieNode* it : paths) {\\n            TrieNode* child = it->children[letter - \\'a\\'];\\n            if (child) {\\n                if (child->leaf)\\n                    result = true;\\n                newpaths.push_back(child);\\n            }\\n        }\\n        paths = std::move(newpaths);\\n        \\n        return result;\\n    }\\n    \\n    std::vector<TrieNode*> paths; // keeps track of all possible words that could occur with the next query() call\\n    TrieNode* root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    class TrieNode {\\n    public:\\n        TrieNode() : children {}, leaf(false) {}\\n        bool leaf;\\n        TrieNode* children[26];\\n    };\\n    \\n    StreamChecker(std::vector<std::string>& words) {\\n        root = new TrieNode();\\n        \\n        for (auto& word : words) {\\n            TrieNode* it = root;        \\n            for (char c : word) {\\n                if (!it->children[c - \\'a\\'])\\n                    it->children[c - \\'a\\'] = new TrieNode();\\n                it = it->children[c - \\'a\\'];\\n            }\\n            it->leaf = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        \\n        std::vector<TrieNode*> newpaths;\\n        paths.push_back(root);\\n        \\n        for (TrieNode* it : paths) {\\n            TrieNode* child = it->children[letter - \\'a\\'];\\n            if (child) {\\n                if (child->leaf)\\n                    result = true;\\n                newpaths.push_back(child);\\n            }\\n        }\\n        paths = std::move(newpaths);\\n        \\n        return result;\\n    }\\n    \\n    std::vector<TrieNode*> paths; // keeps track of all possible words that could occur with the next query() call\\n    TrieNode* root;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372367,
                "title": "java-aho-corasick-implement",
                "content": "```java\\nclass StreamChecker {\\n    TrieNode root = new TrieNode((char) 0);\\n    TrieNode streamNode = root;\\n    public StreamChecker(String[] words) {\\n      buildTrie(words);\\n      buildFail();\\n    }\\n    public boolean query(char letter) {\\n      TrieNode firstNode = streamNode.children[letter - \\'a\\'];\\n      TrieNode parent = streamNode;\\n      // 1. Find the matching node\\n      while (parent.fail != null && firstNode == null) {\\n        parent = parent.fail;\\n        firstNode = parent.children[letter - \\'a\\'];\\n      }\\n      // 2. Reset streamNode to matching node\\n      streamNode = firstNode != null ? firstNode : root;\\n      // 3. Check the matching node isWord attribute and find each fail node the true of isWord attribute\\n      while (firstNode != null && !firstNode.isWord) {\\n        firstNode = firstNode.fail;\\n      }\\n      return firstNode != null && firstNode.isWord;\\n    }\\n    private void buildTrie(String[] words) {\\n      for (String word : words) {\\n        if (word == null || word.length() <= 0) continue;\\n        TrieNode current = root;\\n        for (int i = 0; i < word.length(); i++) {\\n          char c = word.charAt(i);\\n          if (current.children[c - \\'a\\'] == null) {\\n            current.children[c - \\'a\\'] = new TrieNode(c);\\n          }\\n          current = current.children[c - \\'a\\'];\\n        }\\n        current.isWord = true;\\n      }\\n    }\\n    public void buildFail() {\\n      // Using BFS to traverse Trie Tree node for building fail pointer\\n      Queue<TrieNode> queue = new LinkedList<>();\\n      queue.add(root);\\n      while (!queue.isEmpty()) {\\n        TrieNode parent = queue.poll();\\n        for (TrieNode child : parent.children) {\\n          if (child != null) {\\n            TrieNode fail = parent.fail;\\n            while (fail != null) {\\n              TrieNode failChild = fail.children[child.val - \\'a\\'];\\n              if (failChild != null) {\\n                child.fail = failChild;\\n                break;\\n              }\\n              fail = fail.fail;\\n            }\\n            if (child.fail == null) child.fail = root;\\n            queue.add(child);\\n          }\\n        }\\n      }\\n    }\\n    class TrieNode {\\n      TrieNode(char val) {\\n        this.val = val;\\n      }\\n      char val;      // root val is (char) 0\\n      TrieNode fail; // root.fail is null\\n      TrieNode[] children = new TrieNode[26]; // all letters are lower case \\n      boolean isWord;\\n    }\\n}\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass StreamChecker {\\n    TrieNode root = new TrieNode((char) 0);\\n    TrieNode streamNode = root;\\n    public StreamChecker(String[] words) {\\n      buildTrie(words);\\n      buildFail();\\n    }\\n    public boolean query(char letter) {\\n      TrieNode firstNode = streamNode.children[letter - \\'a\\'];\\n      TrieNode parent = streamNode;\\n      // 1. Find the matching node\\n      while (parent.fail != null && firstNode == null) {\\n        parent = parent.fail;\\n        firstNode = parent.children[letter - \\'a\\'];\\n      }\\n      // 2. Reset streamNode to matching node\\n      streamNode = firstNode != null ? firstNode : root;\\n      // 3. Check the matching node isWord attribute and find each fail node the true of isWord attribute\\n      while (firstNode != null && !firstNode.isWord) {\\n        firstNode = firstNode.fail;\\n      }\\n      return firstNode != null && firstNode.isWord;\\n    }\\n    private void buildTrie(String[] words) {\\n      for (String word : words) {\\n        if (word == null || word.length() <= 0) continue;\\n        TrieNode current = root;\\n        for (int i = 0; i < word.length(); i++) {\\n          char c = word.charAt(i);\\n          if (current.children[c - \\'a\\'] == null) {\\n            current.children[c - \\'a\\'] = new TrieNode(c);\\n          }\\n          current = current.children[c - \\'a\\'];\\n        }\\n        current.isWord = true;\\n      }\\n    }\\n    public void buildFail() {\\n      // Using BFS to traverse Trie Tree node for building fail pointer\\n      Queue<TrieNode> queue = new LinkedList<>();\\n      queue.add(root);\\n      while (!queue.isEmpty()) {\\n        TrieNode parent = queue.poll();\\n        for (TrieNode child : parent.children) {\\n          if (child != null) {\\n            TrieNode fail = parent.fail;\\n            while (fail != null) {\\n              TrieNode failChild = fail.children[child.val - \\'a\\'];\\n              if (failChild != null) {\\n                child.fail = failChild;\\n                break;\\n              }\\n              fail = fail.fail;\\n            }\\n            if (child.fail == null) child.fail = root;\\n            queue.add(child);\\n          }\\n        }\\n      }\\n    }\\n    class TrieNode {\\n      TrieNode(char val) {\\n        this.val = val;\\n      }\\n      char val;      // root val is (char) 0\\n      TrieNode fail; // root.fail is null\\n      TrieNode[] children = new TrieNode[26]; // all letters are lower case \\n      boolean isWord;\\n    }\\n}\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361626,
                "title": "python-3-aho-corasick-556ms",
                "content": "This is an implementation of Aho-Corasick.\\nhttps://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm\\n\\nEach Trie node is implemented as a dictionary.\\nThe value at a character is the corresponding child node.\\nThe value at the special key \\'prefix\\' is the target of the prefix pointer,\\nand the value at \\'dictionary\\' is the target of the dictionary pointer.\\nIf the node corresponds to a word in words, the node contains the key-value pair \"word\":True. \\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = {\\'prefix\\': None, \\'dict\\':None}\\n        \\n        #build Trie\\n        for word in words:\\n            node = self.root\\n            for char in word:\\n                if not char in node:\\n                    node[char] = {}\\n                node = node[char]\\n            node[\\'word\\'] = True\\n                    \\n        #set prefix and dictionary pointers by BFS\\n        q = collections.deque([self.root])\\n        while q:\\n            node = q.popleft()\\n            for char in node:\\n                if len(char)==1:\\n                    child = node[char]\\n                    extendNode = node[\\'prefix\\']\\n                    while extendNode and not char in extendNode:\\n                        extendNode = extendNode[\\'prefix\\']\\n                    if extendNode:\\n                        child[\\'prefix\\'] = extendNode[char]\\n                    else:\\n                        child[\\'prefix\\'] = self.root\\n                    if \\'word\\' in child[\\'prefix\\']:\\n                        child[\\'dict\\'] = child[\\'prefix\\']\\n                    else:\\n                        child[\\'dict\\'] = child[\\'prefix\\'][\\'dict\\']\\n                    q.append(child)\\n        \\n        #self.cur will traverse the Trie\\n        #while reading the stream\\n        self.cur = self.root\\n\\n    def query(self, letter: str) -> bool:\\n        extendNode = self.cur\\n        while extendNode and not letter in extendNode:\\n            extendNode = extendNode[\\'prefix\\']\\n        if extendNode:\\n            self.cur = extendNode[letter]\\n\\t\\t\\t#checks if current word is in words\\n\\t\\t\\t#or if the dictionary pointer is non-null\\n            if \\'word\\' in self.cur or self.cur[\\'dict\\']: \\n                return True\\n            else:\\n                return False\\n        else:\\n            self.cur = self.root\\n            return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = {\\'prefix\\': None, \\'dict\\':None}\\n        \\n        #build Trie\\n        for word in words:\\n            node = self.root\\n            for char in word:\\n                if not char in node:\\n                    node[char] = {}\\n                node = node[char]\\n            node[\\'word\\'] = True\\n                    \\n        #set prefix and dictionary pointers by BFS\\n        q = collections.deque([self.root])\\n        while q:\\n            node = q.popleft()\\n            for char in node:\\n                if len(char)==1:\\n                    child = node[char]\\n                    extendNode = node[\\'prefix\\']\\n                    while extendNode and not char in extendNode:\\n                        extendNode = extendNode[\\'prefix\\']\\n                    if extendNode:\\n                        child[\\'prefix\\'] = extendNode[char]\\n                    else:\\n                        child[\\'prefix\\'] = self.root\\n                    if \\'word\\' in child[\\'prefix\\']:\\n                        child[\\'dict\\'] = child[\\'prefix\\']\\n                    else:\\n                        child[\\'dict\\'] = child[\\'prefix\\'][\\'dict\\']\\n                    q.append(child)\\n        \\n        #self.cur will traverse the Trie\\n        #while reading the stream\\n        self.cur = self.root\\n\\n    def query(self, letter: str) -> bool:\\n        extendNode = self.cur\\n        while extendNode and not letter in extendNode:\\n            extendNode = extendNode[\\'prefix\\']\\n        if extendNode:\\n            self.cur = extendNode[letter]\\n\\t\\t\\t#checks if current word is in words\\n\\t\\t\\t#or if the dictionary pointer is non-null\\n            if \\'word\\' in self.cur or self.cur[\\'dict\\']: \\n                return True\\n            else:\\n                return False\\n        else:\\n            self.cur = self.root\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283945,
                "title": "my-python-ac-auto-algorithm",
                "content": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        # build trie\\n        trie = {}\\n        for w in words:\\n            p = trie\\n            for c in w:\\n                if c not in p:\\n                    p[c] = {\\'fail\\':trie}\\n                p = p[c]\\n            p[\\'#\\'] = None\\n        \\n        # rearrange fail pointer, use bfs\\n        import collections\\n        d = collections.deque()\\n        d.append(trie)\\n        while d:\\n            cur = d.popleft()\\n            if cur == trie:\\n                for c in cur:\\n                    d.append(cur[c])\\n            else:\\n                for c in cur:\\n                    if c != \\'fail\\' and c != \\'#\\':\\n                        p = cur[\\'fail\\']\\n                        while p != trie and c not in p:\\n                            p = p[\\'fail\\']\\n                        if c in p:\\n                            cur[c][\\'fail\\'] = p[c]\\n                            if \\'#\\' in p[c]:\\n                                cur[c][\\'#\\'] = None\\n                        d.append(cur[c])\\n        self.trie = trie\\n        self.p = trie\\n\\n    def query(self, letter: str) -> bool:\\n        while True:\\n            if letter in self.p:\\n                self.p = self.p[letter]\\n                break\\n            if \\'fail\\' in self.p:\\n                self.p = self.p[\\'fail\\']\\n            else:\\n                break\\n        return \\'#\\' in self.p\\n```\\n\\nI had a similar question in my interview last year. The only difference was that he asked how many words match instead of whether there is a matched word. The first time I used Trie and maintained a list of previous query letter (the cache length = max length of `words`). Then the interviewer asked me if I can improve query to O(1). I could not get this answer. :(",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        # build trie\\n        trie = {}\\n        for w in words:\\n            p = trie\\n            for c in w:\\n                if c not in p:\\n                    p[c] = {\\'fail\\':trie}\\n                p = p[c]\\n            p[\\'#\\'] = None\\n        \\n        # rearrange fail pointer, use bfs\\n        import collections\\n        d = collections.deque()\\n        d.append(trie)\\n        while d:\\n            cur = d.popleft()\\n            if cur == trie:\\n                for c in cur:\\n                    d.append(cur[c])\\n            else:\\n                for c in cur:\\n                    if c != \\'fail\\' and c != \\'#\\':\\n                        p = cur[\\'fail\\']\\n                        while p != trie and c not in p:\\n                            p = p[\\'fail\\']\\n                        if c in p:\\n                            cur[c][\\'fail\\'] = p[c]\\n                            if \\'#\\' in p[c]:\\n                                cur[c][\\'#\\'] = None\\n                        d.append(cur[c])\\n        self.trie = trie\\n        self.p = trie\\n\\n    def query(self, letter: str) -> bool:\\n        while True:\\n            if letter in self.p:\\n                self.p = self.p[letter]\\n                break\\n            if \\'fail\\' in self.p:\\n                self.p = self.p[\\'fail\\']\\n            else:\\n                break\\n        return \\'#\\' in self.p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278713,
                "title": "javascript-trie-o-nl-runtime-o-ml-space",
                "content": "At most one pointer at each layer in the trie => O(nl) runtime\\n\\nl = length of max word\\nn = items in strem\\nm = number of words\\n\\n```js\\nclass Trie extends Map {\\n  insert(str) {\\n    let curr = this\\n    \\n    for (const c of str) {\\n      if (!curr.has(c)) curr.set(c, new Trie())\\n      curr = curr.get(c)\\n    }\\n    \\n    curr.end = true\\n  }\\n}\\n\\n\\nclass StreamChecker {\\n  constructor(words) {  \\n    this.pointers = []\\n    this.trie = new Trie()\\n    for (const word of words) this.trie.insert(word)\\n  }\\n  \\n  query(letter) {\\n    this.pointers = [...this.pointers, this.trie].map(p => p.get(letter)).filter(Boolean)\\n\\n    for (const pointer of this.pointers)\\n      if (pointer.end) return true\\n\\n    return false\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nclass Trie extends Map {\\n  insert(str) {\\n    let curr = this\\n    \\n    for (const c of str) {\\n      if (!curr.has(c)) curr.set(c, new Trie())\\n      curr = curr.get(c)\\n    }\\n    \\n    curr.end = true\\n  }\\n}\\n\\n\\nclass StreamChecker {\\n  constructor(words) {  \\n    this.pointers = []\\n    this.trie = new Trie()\\n    for (const word of words) this.trie.insert(word)\\n  }\\n  \\n  query(letter) {\\n    this.pointers = [...this.pointers, this.trie].map(p => p.get(letter)).filter(Boolean)\\n\\n    for (const pointer of this.pointers)\\n      if (pointer.end) return true\\n\\n    return false\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618981,
                "title": "aho-corasick-approach-o-mn-q-total-o-1-per-query-time-complexity",
                "content": "The following is a straightforward Aho-Corasick trie implementation. Aho-Corasick basically combines the approaches of a trie and the KMP algorithm. \\n\\nhttps://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm\\n\\nGiven N words of max-length M and Q queries, the total complexity will be O(M * N + Q). The precomputation complexity for building the tree is O(M * N) and the per-query complexity is O(1)\\n\\n```\\nclass ACTrie {\\n    unordered_map<char, ACTrie*> next_map;\\n    bool green = false;\\n\\t// The prev pointer for the Aho-Corasick algorithm.\\n    ACTrie* prev;\\n\\n    friend class StreamChecker;\\n    \\n public:\\n    // Nothing special. Just adding a word to a trie.\\n    void InsertWord(const string& word) {\\n        ACTrie* current_pointer = this;\\n        for (const auto c : word) {\\n            if (current_pointer->next_map.count(c) == 0)\\n                current_pointer->next_map[c] = new ACTrie();\\n            current_pointer = current_pointer->next_map[c];\\n        }\\n        current_pointer->green = true;\\n    }\\n\\n    // Convert the trie into an Aho-Corasick trie by setting prev pointers just like in KMP. \\n    void ConvertToACTrie() {\\n\\t\\t// Use a queue since we want all the prev pointers for previous depth levels to be already calculated \\n\\t\\t// before reaching the next depth level .... i.e. BFS.\\n        queue<ACTrie*> q;\\n        for (auto iter : next_map) {\\n            iter.second->prev = this;\\n            q.push(iter.second);\\n        }\\n        \\n        while (!q.empty()) {\\n            ACTrie* current_node = q.front();\\n            q.pop();\\n            for (auto iter : current_node->next_map) {\\n                auto prev_candidate = current_node->prev;\\n                while (prev_candidate != this && prev_candidate->next_map.count(iter.first) == 0)\\n                    prev_candidate = prev_candidate->prev;\\n                iter.second->prev = prev_candidate->next_map.count(iter.first) == 0 ? prev_candidate : prev_candidate->next_map[iter.first];\\n                // Back-propagate the greens to account for one word being the substring of another.\\n                if (iter.second->prev->green)\\n                    iter.second->green = true;\\n                q.push(iter.second);\\n            }\\n        }\\n    }\\n};\\n\\nclass StreamChecker {\\n    ACTrie* current_pointer;\\n    ACTrie* trie;\\n  public:\\n    StreamChecker(vector<string>& words) {\\n        trie = new ACTrie();\\n        current_pointer = trie;\\n        for (auto& word : words) {\\n            trie->InsertWord(word);\\n        }\\n        trie->ConvertToACTrie();\\n    }\\n    \\n    bool query(char c) {\\n        while(current_pointer != trie && current_pointer->next_map.count(c) == 0)\\n            current_pointer = current_pointer->prev;\\n        if (current_pointer->next_map.count(c) != 0) {\\n            current_pointer = current_pointer->next_map[c];\\n        }\\n        return current_pointer->green;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass ACTrie {\\n    unordered_map<char, ACTrie*> next_map;\\n    bool green = false;\\n\\t// The prev pointer for the Aho-Corasick algorithm.\\n    ACTrie* prev;\\n\\n    friend class StreamChecker;\\n    \\n public:\\n    // Nothing special. Just adding a word to a trie.\\n    void InsertWord(const string& word) {\\n        ACTrie* current_pointer = this;\\n        for (const auto c : word) {\\n            if (current_pointer->next_map.count(c) == 0)\\n                current_pointer->next_map[c] = new ACTrie();\\n            current_pointer = current_pointer->next_map[c];\\n        }\\n        current_pointer->green = true;\\n    }\\n\\n    // Convert the trie into an Aho-Corasick trie by setting prev pointers just like in KMP. \\n    void ConvertToACTrie() {\\n\\t\\t// Use a queue since we want all the prev pointers for previous depth levels to be already calculated \\n\\t\\t// before reaching the next depth level .... i.e. BFS.\\n        queue<ACTrie*> q;\\n        for (auto iter : next_map) {\\n            iter.second->prev = this;\\n            q.push(iter.second);\\n        }\\n        \\n        while (!q.empty()) {\\n            ACTrie* current_node = q.front();\\n            q.pop();\\n            for (auto iter : current_node->next_map) {\\n                auto prev_candidate = current_node->prev;\\n                while (prev_candidate != this && prev_candidate->next_map.count(iter.first) == 0)\\n                    prev_candidate = prev_candidate->prev;\\n                iter.second->prev = prev_candidate->next_map.count(iter.first) == 0 ? prev_candidate : prev_candidate->next_map[iter.first];\\n                // Back-propagate the greens to account for one word being the substring of another.\\n                if (iter.second->prev->green)\\n                    iter.second->green = true;\\n                q.push(iter.second);\\n            }\\n        }\\n    }\\n};\\n\\nclass StreamChecker {\\n    ACTrie* current_pointer;\\n    ACTrie* trie;\\n  public:\\n    StreamChecker(vector<string>& words) {\\n        trie = new ACTrie();\\n        current_pointer = trie;\\n        for (auto& word : words) {\\n            trie->InsertWord(word);\\n        }\\n        trie->ConvertToACTrie();\\n    }\\n    \\n    bool query(char c) {\\n        while(current_pointer != trie && current_pointer->next_map.count(c) == 0)\\n            current_pointer = current_pointer->prev;\\n        if (current_pointer->next_map.count(c) != 0) {\\n            current_pointer = current_pointer->next_map[c];\\n        }\\n        return current_pointer->green;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611824,
                "title": "python-simple-trie-approach-different-from-solution-article-no-reversed-trie-stream",
                "content": "This approach doesn\\'t keep a list of input stream, but instead keep a list of promosing suffixes which is updated with each new letter.\\nTime complexity of `query` is O(min(M, N)), where M is the number of letters seen, and N is the number of nodes in trie.  \\nBased on online judge, this solution is generally slower but consumes much less space.  I think this approach is still better than solution article because it doesn\\'t waste space to store input stream and in reality the number of promising suffixes at any time should be a small number compared to the size of input stream. (can\\'t approve but just an intuition)\\n\\n```python\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.WORD = \\'#\\'\\n        # build a trie of input words\\n        self.trie = {} # nested hashmap (dictionary)\\n        for word in words:\\n            node = self.trie\\n            for c in word:\\n                node = node.setdefault(c, {})\\n            node[self.WORD] = {}\\n         # list of trie nodes to store all promising suffixes seen so far\\n        self.suffixes = [self.trie]\\n\\n    # Time: O(min(N, M)), N: number of letters seen, M: number of nodes in trie\\n    def query(self, letter: str) -> bool:\\n        new_suffixes = [self.trie]\\n        for suffix in self.suffixes:\\n            if letter in suffix:\\n                new_suffixes.append(suffix[letter])\\n        self.suffixes = new_suffixes\\n        for suffix in self.suffixes:\\n            if self.WORD in suffix:\\n                return True\\n        return False\\n    \\n    \\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```python\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.WORD = \\'#\\'\\n        # build a trie of input words\\n        self.trie = {} # nested hashmap (dictionary)\\n        for word in words:\\n            node = self.trie\\n            for c in word:\\n                node = node.setdefault(c, {})\\n            node[self.WORD] = {}\\n         # list of trie nodes to store all promising suffixes seen so far\\n        self.suffixes = [self.trie]\\n\\n    # Time: O(min(N, M)), N: number of letters seen, M: number of nodes in trie\\n    def query(self, letter: str) -> bool:\\n        new_suffixes = [self.trie]\\n        for suffix in self.suffixes:\\n            if letter in suffix:\\n                new_suffixes.append(suffix[letter])\\n        self.suffixes = new_suffixes\\n        for suffix in self.suffixes:\\n            if self.WORD in suffix:\\n                return True\\n        return False\\n    \\n    \\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611687,
                "title": "trie-python",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add_word(self, word):\\n        curr = self.trie\\n        for char in word:\\n            if char not in curr:\\n                curr[char] = {}\\n            curr = curr[char]\\n        curr[\\'$\\'] = True\\n    \\n    def find_query(self, prefix):\\n        curr = self.trie\\n        for char in prefix:\\n            if char not in curr:\\n                return False\\n            curr = curr[char]\\n            if \\'$\\' in curr:\\n                return True\\n        return False        \\n                \\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.prefix = \\'\\'\\n        #construct trie\\n        self.t = TrieNode()\\n        for word in words:\\n            self.t.add_word(word[::-1])\\n            \\n    def query(self, letter: str) -> bool:\\n        self.prefix += letter\\n        return self.t.find_query(self.prefix[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add_word(self, word):\\n        curr = self.trie\\n        for char in word:\\n            if char not in curr:\\n                curr[char] = {}\\n            curr = curr[char]\\n        curr[\\'$\\'] = True\\n    \\n    def find_query(self, prefix):\\n        curr = self.trie\\n        for char in prefix:\\n            if char not in curr:\\n                return False\\n            curr = curr[char]\\n            if \\'$\\' in curr:\\n                return True\\n        return False        \\n                \\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.prefix = \\'\\'\\n        #construct trie\\n        self.t = TrieNode()\\n        for word in words:\\n            self.t.add_word(word[::-1])\\n            \\n    def query(self, letter: str) -> bool:\\n        self.prefix += letter\\n        return self.t.find_query(self.prefix[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610459,
                "title": "c-1032-stream-of-characters",
                "content": "\\n```\\nclass TrieNode {\\npublic: \\n    TrieNode *child[26] = {nullptr}; \\n    bool is_word = false; \\n};\\n\\n\\nclass StreamChecker {\\n    TrieNode *root = nullptr; \\n    vector<char> stream; \\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode(); \\n        for (auto word : words) {\\n            reverse(word.begin(), word.end()); \\n            TrieNode* node = root; \\n            for (auto& ch : word) {\\n                if (!node->child[ch - \\'a\\']) node->child[ch - \\'a\\'] = new TrieNode(); \\n                node = node->child[ch - \\'a\\']; \\n            }\\n            node->is_word = true; \\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_back(letter); \\n        TrieNode* node = root; \\n        for (int i = stream.size()-1; i >= 0; --i) {\\n            if (!node->child[stream[i] - \\'a\\']) break; \\n            node = node->child[stream[i] - \\'a\\']; \\n            if (node->is_word) return true; \\n        }\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass TrieNode {\\npublic: \\n    TrieNode *child[26] = {nullptr}; \\n    bool is_word = false; \\n};\\n\\n\\nclass StreamChecker {\\n    TrieNode *root = nullptr; \\n    vector<char> stream; \\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode(); \\n        for (auto word : words) {\\n            reverse(word.begin(), word.end()); \\n            TrieNode* node = root; \\n            for (auto& ch : word) {\\n                if (!node->child[ch - \\'a\\']) node->child[ch - \\'a\\'] = new TrieNode(); \\n                node = node->child[ch - \\'a\\']; \\n            }\\n            node->is_word = true; \\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_back(letter); \\n        TrieNode* node = root; \\n        for (int i = stream.size()-1; i >= 0; --i) {\\n            if (!node->child[stream[i] - \\'a\\']) break; \\n            node = node->child[stream[i] - \\'a\\']; \\n            if (node->is_word) return true; \\n        }\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522375,
                "title": "c-trie-easy-code-280-ms",
                "content": "```\\n                         X\\n                       / \\\\  \\\\ \\n                      d   f    l\\n                     /           \\\\\\n                     c            k\\n```\\n                      \\nSteps -\\n1. Build the Trie in reverse fashion , ie., in reverse order.\\n2. Now for each query we have a letter (charachter which needs to be added in string let say \"stream\") , but wait do not use string it will cost you TLE , instead use deque of charachter bcz we can push in any of side in O(1) complexity.\\n3.  push each charachter in front of out deque , and search it in our Trie.\\n4.  At every node check whether there is a node which ends means there is a word , if yes then return true.\\n```\\n#define fastio ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\nclass TrieNode\\n{\\n  public:\\n    vector<TrieNode*> next;\\n    bool isWord;\\n    TrieNode()\\n    {\\n        next.resize(26,NULL);\\n        isWord = false;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    deque<char>stream;\\n    TrieNode* root = new TrieNode();\\n    \\n    bool search()\\n    {\\n        TrieNode* p = root;\\n        for(char ch : stream){\\n            if(p->isWord)\\n                return true;\\n            if(p->next[ch-\\'a\\']==NULL)\\n                return false;\\n            p = p->next[ch-\\'a\\'];\\n        }\\n        return p->isWord;\\n    }\\n    \\n    void insert(string &s)\\n    {\\n        TrieNode* p = root;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(p->next[s[i]-\\'a\\']==NULL)\\n                p->next[s[i]-\\'a\\'] = new TrieNode();\\n            p = p->next[s[i]-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        fastio\\n        for(string word : words)\\n        {\\n            insert(word);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_front(letter);\\n        return search();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie",
                    "Queue"
                ],
                "code": "```\\n                         X\\n                       / \\\\  \\\\ \\n                      d   f    l\\n                     /           \\\\\\n                     c            k\\n```\n```\\n#define fastio ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\nclass TrieNode\\n{\\n  public:\\n    vector<TrieNode*> next;\\n    bool isWord;\\n    TrieNode()\\n    {\\n        next.resize(26,NULL);\\n        isWord = false;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    deque<char>stream;\\n    TrieNode* root = new TrieNode();\\n    \\n    bool search()\\n    {\\n        TrieNode* p = root;\\n        for(char ch : stream){\\n            if(p->isWord)\\n                return true;\\n            if(p->next[ch-\\'a\\']==NULL)\\n                return false;\\n            p = p->next[ch-\\'a\\'];\\n        }\\n        return p->isWord;\\n    }\\n    \\n    void insert(string &s)\\n    {\\n        TrieNode* p = root;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(p->next[s[i]-\\'a\\']==NULL)\\n                p->next[s[i]-\\'a\\'] = new TrieNode();\\n            p = p->next[s[i]-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        fastio\\n        for(string word : words)\\n        {\\n            insert(word);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_front(letter);\\n        return search();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1383227,
                "title": "java-trie-faster-than-98",
                "content": "```\\nclass StreamChecker {\\n    class Node{\\n        Node[] children;\\n        boolean isEnd;\\n        Node(){\\n            children = new Node[26];\\n            isEnd = false;\\n        }\\n    }\\n\\n    Node root;\\n    StringBuilder sb;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        sb = new StringBuilder();\\n        for(String word : words){\\n            Node curr = root;\\n            for(int i = word.length() - 1; i >= 0; i--){\\n                int idx = word.charAt(i) - \\'a\\';\\n                if(curr.children[idx] == null)\\n                    curr.children[idx] = new Node();\\n                curr = curr.children[idx];\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Node curr = root;\\n        for(int i = sb.length() - 1; i >= 0; i--){\\n            int idx = sb.charAt(i) - \\'a\\';\\n            if(curr.children[idx] == null)\\n                break;\\n            curr = curr.children[idx];\\n            if(curr.isEnd)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    class Node{\\n        Node[] children;\\n        boolean isEnd;\\n        Node(){\\n            children = new Node[26];\\n            isEnd = false;\\n        }\\n    }\\n\\n    Node root;\\n    StringBuilder sb;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        sb = new StringBuilder();\\n        for(String word : words){\\n            Node curr = root;\\n            for(int i = word.length() - 1; i >= 0; i--){\\n                int idx = word.charAt(i) - \\'a\\';\\n                if(curr.children[idx] == null)\\n                    curr.children[idx] = new Node();\\n                curr = curr.children[idx];\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Node curr = root;\\n        for(int i = sb.length() - 1; i >= 0; i--){\\n            int idx = sb.charAt(i) - \\'a\\';\\n            if(curr.children[idx] == null)\\n                break;\\n            curr = curr.children[idx];\\n            if(curr.isEnd)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1261438,
                "title": "c-wa-soln-using-hash-set",
                "content": "Please note, this solution will result in a TLE on test case 13 out of total 17 test cases on the OJ but I am sharing this soln because it is a valid approach to solve this problem. Tho it is not the most optimal.\\n\\n```\\nclass StreamChecker \\n{\\npublic:\\n    \\n    string checker = \"\";\\n    unordered_set<string> list;\\n    \\n    StreamChecker(vector<string>& words) {\\n        for ( string word : words ) {\\n            list.insert(word);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        checker += letter;\\n        string check;\\n        for ( int i=0; i<checker.size(); i++ ) {\\n            check = checker.substr(i);\\n            if ( list.find(check) != list.end() ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass StreamChecker \\n{\\npublic:\\n    \\n    string checker = \"\";\\n    unordered_set<string> list;\\n    \\n    StreamChecker(vector<string>& words) {\\n        for ( string word : words ) {\\n            list.insert(word);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        checker += letter;\\n        string check;\\n        for ( int i=0; i<checker.size(); i++ ) {\\n            check = checker.substr(i);\\n            if ( list.find(check) != list.end() ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013399,
                "title": "java-trie-reverse-string",
                "content": "```\\nclass StreamChecker {\\n    class TrieNode {\\n\\t    boolean endOfWord;\\n        Map<Character, TrieNode> children;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            endOfWord = false;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        word = new StringBuilder(word).reverse().toString(); //reverse the string\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) {\\n                node = new TrieNode();\\n                curr.children.put(ch, node);\\n            }\\n            curr = node;\\n        }\\n        \\n        curr.endOfWord = true;\\n    }\\n\\n    TrieNode root;\\n    StringBuilder sb;\\n    //Comparator\\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        sb = new StringBuilder();\\n        for(String word: words) {\\n            insert(root, word);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TrieNode curr = root;\\n        \\n        for(int i = sb.length()-1; i >= 0; i--) {\\n            char ch = sb.charAt(i);\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) return false;\\n            if(node.endOfWord) return true;\\n            curr = node;\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n    class TrieNode {\\n\\t    boolean endOfWord;\\n        Map<Character, TrieNode> children;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            endOfWord = false;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        word = new StringBuilder(word).reverse().toString(); //reverse the string\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) {\\n                node = new TrieNode();\\n                curr.children.put(ch, node);\\n            }\\n            curr = node;\\n        }\\n        \\n        curr.endOfWord = true;\\n    }\\n\\n    TrieNode root;\\n    StringBuilder sb;\\n    //Comparator\\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        sb = new StringBuilder();\\n        for(String word: words) {\\n            insert(root, word);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TrieNode curr = root;\\n        \\n        for(int i = sb.length()-1; i >= 0; i--) {\\n            char ch = sb.charAt(i);\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) return false;\\n            if(node.endOfWord) return true;\\n            curr = node;\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854000,
                "title": "java-solution-faster-than-90-using-only-trie-with-explanation",
                "content": "The main idea is to store each of the given words in reverse order in the Trie. \\n\\nWe have kept an additional variable \\'endOfWord\\' to mark the end (beginning of the given word).\\n\\nThis way of storing enables us to make each query in the trie in O(m) time where \\'m\\' is the length of the longest word in the given set of words.\\nWe store the queried characters so far in a list \\'characterList\\' . Everytime we query a character we start at the trie root (since words are stored in the reverse order) with the given character to be queried  and continue till the beginning of \\'characterList\\'. At any point if \\'endOfWord\\' is true for a TrieNode  we return true. \\n\\n\\n```\\n class StreamChecker {\\n        List<Character> characterList;\\n        private TrieNode root;\\n\\n        private class Trie {\\n            private final TrieNode root;\\n\\n            public Trie() {\\n                root = new TrieNode();\\n            }\\n\\n            public TrieNode getRoot() {\\n                return root;\\n            }\\n        }\\n\\n        private class TrieNode {\\n            TrieNode[] children;\\n            boolean endOfWord;\\n\\n            public TrieNode() {\\n                children = new TrieNode[27];\\n                endOfWord = false;\\n            }\\n        }\\n\\n        public StreamChecker(String[] words) {\\n            characterList = new ArrayList<>();\\n            Trie trie = new Trie();\\n            root = trie.getRoot();\\n\\n            for (String s : words) insert(root, s);\\n        }\\n\\n        private void insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            for (int i = word.length()-1; i>=0; i--) {\\n                final char ch = word.charAt(i);\\n                TrieNode node = cur.children[ch - \\'a\\'];\\n                if (node == null) cur.children[ch - \\'a\\'] = new TrieNode();\\n                cur = cur.children[ch - \\'a\\'];\\n            }\\n            cur.endOfWord = true;\\n        }\\n\\n        public boolean query(char letter) {\\n            TrieNode cur = root;\\n            characterList.add(letter);\\n            for (int i = characterList.size() - 1; i >= 0; i--) {\\n                TrieNode node = cur.children[characterList.get(i) - \\'a\\'];\\n                if(node==null) return false;\\n                if(node.endOfWord==true) return true;\\n                cur=node;\\n            }\\n            return cur.endOfWord;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The main idea is to store each of the given words in reverse order in the Trie. \\n\\nWe have kept an additional variable \\'endOfWord\\' to mark the end (beginning of the given word).\\n\\nThis way of storing enables us to make each query in the trie in O(m) time where \\'m\\' is the length of the longest word in the given set of words.\\nWe store the queried characters so far in a list \\'characterList\\' . Everytime we query a character we start at the trie root (since words are stored in the reverse order) with the given character to be queried  and continue till the beginning of \\'characterList\\'. At any point if \\'endOfWord\\' is true for a TrieNode  we return true. \\n\\n\\n```\\n class StreamChecker {\\n        List<Character> characterList;\\n        private TrieNode root;\\n\\n        private class Trie {\\n            private final TrieNode root;\\n\\n            public Trie() {\\n                root = new TrieNode();\\n            }\\n\\n            public TrieNode getRoot() {\\n                return root;\\n            }\\n        }\\n\\n        private class TrieNode {\\n            TrieNode[] children;\\n            boolean endOfWord;\\n\\n            public TrieNode() {\\n                children = new TrieNode[27];\\n                endOfWord = false;\\n            }\\n        }\\n\\n        public StreamChecker(String[] words) {\\n            characterList = new ArrayList<>();\\n            Trie trie = new Trie();\\n            root = trie.getRoot();\\n\\n            for (String s : words) insert(root, s);\\n        }\\n\\n        private void insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            for (int i = word.length()-1; i>=0; i--) {\\n                final char ch = word.charAt(i);\\n                TrieNode node = cur.children[ch - \\'a\\'];\\n                if (node == null) cur.children[ch - \\'a\\'] = new TrieNode();\\n                cur = cur.children[ch - \\'a\\'];\\n            }\\n            cur.endOfWord = true;\\n        }\\n\\n        public boolean query(char letter) {\\n            TrieNode cur = root;\\n            characterList.add(letter);\\n            for (int i = characterList.size() - 1; i >= 0; i--) {\\n                TrieNode node = cur.children[characterList.get(i) - \\'a\\'];\\n                if(node==null) return false;\\n                if(node.endOfWord==true) return true;\\n                cur=node;\\n            }\\n            return cur.endOfWord;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 808764,
                "title": "ruby-trie-with-reversed-words-faster-than-100-submissions",
                "content": "**Runtime**: faster than 100.00% of Ruby online submissions\\n\\n```\\nclass Node \\n    attr_reader :children\\n    attr_accessor :eow\\n    \\n    def initialize()\\n        @children = {}\\n    end\\n    \\n    def add(word)\\n        curr = self\\n        word.each_char do |char|\\n            curr.children[char] ||= Node.new\\n            curr = curr.children[char]\\n        end\\n        curr.eow = true\\n    end\\n    \\nend\\n\\nclass StreamChecker\\n    def initialize(words)\\n        # hash map {\"char\" => Node}\\n        @root = Node.new\\n        words.each {|w| @root.add(w.reverse) }\\n        @letters = []\\n    end\\n\\n\\n=begin\\n    :type letter: Character\\n    :rtype: Boolean\\n=end\\n    def query(letter)        \\n        @letters << letter\\n        curr_node = @root\\n        \\n        (@letters.length - 1).downto(0) do |i|\\n            char = @letters[i]\\n            if curr_node.children[char].nil?\\n                return false\\n            elsif curr_node.children[char].eow\\n                return true\\n            else\\n                curr_node = curr_node.children[@letters[i]]\\n            end\\n        end\\n    \\n        false \\n    end\\n    \\nend\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker.new(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node \\n    attr_reader :children\\n    attr_accessor :eow\\n    \\n    def initialize()\\n        @children = {}\\n    end\\n    \\n    def add(word)\\n        curr = self\\n        word.each_char do |char|\\n            curr.children[char] ||= Node.new\\n            curr = curr.children[char]\\n        end\\n        curr.eow = true\\n    end\\n    \\nend\\n\\nclass StreamChecker\\n    def initialize(words)\\n        # hash map {\"char\" => Node}\\n        @root = Node.new\\n        words.each {|w| @root.add(w.reverse) }\\n        @letters = []\\n    end\\n\\n\\n=begin\\n    :type letter: Character\\n    :rtype: Boolean\\n=end\\n    def query(letter)        \\n        @letters << letter\\n        curr_node = @root\\n        \\n        (@letters.length - 1).downto(0) do |i|\\n            char = @letters[i]\\n            if curr_node.children[char].nil?\\n                return false\\n            elsif curr_node.children[char].eow\\n                return true\\n            else\\n                curr_node = curr_node.children[@letters[i]]\\n            end\\n        end\\n    \\n        false \\n    end\\n    \\nend\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker.new(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808619,
                "title": "java-trie-solution-insert-each-word-in-reverse-order",
                "content": "```\\nclass StreamChecker {\\n    class TreeNode {\\n        public boolean end = false;\\n        public TreeNode[] letters;\\n        public TreeNode () {\\n            this.letters = new TreeNode[26];\\n        }\\n    }\\n    \\n    private TreeNode root;    \\n    private StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new TreeNode();\\n        sb = new StringBuilder();\\n        \\n        for (var word : words) {\\n            insert(word);\\n        }\\n    }\\n    \\n    public void insert(String word) {\\n        TreeNode currNode = root;\\n        word = new StringBuilder(word).reverse().toString(); //insert from the back\\n        \\n        for (char c : word.toCharArray()) {\\n            if (currNode.letters[c - \\'a\\'] == null) {\\n                currNode.letters[c - \\'a\\'] = new TreeNode();\\n            }\\n            currNode = currNode.letters[c - \\'a\\'];\\n        }\\n        currNode.end = true;\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TreeNode currNode = root;\\n        \\n        for (int i = sb.length()-1; i >= 0; i--) {\\n            if (currNode == null)\\n                break;\\n            \\n            char c = sb.charAt(i);\\n            currNode = currNode.letters[c - \\'a\\'];\\n            \\n            if (currNode != null && currNode.end)\\n                return true;\\n        }   \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n    class TreeNode {\\n        public boolean end = false;\\n        public TreeNode[] letters;\\n        public TreeNode () {\\n            this.letters = new TreeNode[26];\\n        }\\n    }\\n    \\n    private TreeNode root;    \\n    private StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new TreeNode();\\n        sb = new StringBuilder();\\n        \\n        for (var word : words) {\\n            insert(word);\\n        }\\n    }\\n    \\n    public void insert(String word) {\\n        TreeNode currNode = root;\\n        word = new StringBuilder(word).reverse().toString(); //insert from the back\\n        \\n        for (char c : word.toCharArray()) {\\n            if (currNode.letters[c - \\'a\\'] == null) {\\n                currNode.letters[c - \\'a\\'] = new TreeNode();\\n            }\\n            currNode = currNode.letters[c - \\'a\\'];\\n        }\\n        currNode.end = true;\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TreeNode currNode = root;\\n        \\n        for (int i = sb.length()-1; i >= 0; i--) {\\n            if (currNode == null)\\n                break;\\n            \\n            char c = sb.charAt(i);\\n            currNode = currNode.letters[c - \\'a\\'];\\n            \\n            if (currNode != null && currNode.end)\\n                return true;\\n        }   \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807833,
                "title": "simple-solution-using-trie-and-a-letters-buffer",
                "content": "```\\npublic class StreamChecker\\n{\\n    private TrieNode trie = new TrieNode();\\n    private LinkedList<char> charBuffer = new LinkedList<char>();\\n    \\n    public StreamChecker(string[] words)\\n    {\\n        foreach(string w in words)\\n        {\\n            TrieNode current = trie;\\n            for(int i = w.Length - 1; i >= 0; i--)\\n            {\\n                char c = w[i];\\n                if(current.children[c-\\'a\\'] is null) current.children[c-\\'a\\'] = new TrieNode();\\n                current = current.children[c-\\'a\\'];       \\n            }\\n            current.isWord = true;\\n        }\\n    }\\n    \\n    public bool Query(char letter)\\n    {\\n        charBuffer.AddLast(letter);\\n        if(charBuffer.Count > 2000) charBuffer.RemoveFirst(); // more than max word length\\n        LinkedListNode<char> llNode = charBuffer.Last;\\n        TrieNode trieNode = trie;\\n        while(llNode != null)\\n        {\\n            trieNode = trieNode.children[llNode.Value-\\'a\\'];\\n            if(trieNode is null) return false;\\n            if(trieNode.isWord) return true;\\n            llNode = llNode.Previous;\\n        }\\n        return false;\\n    }\\n    \\n    private class TrieNode\\n    {\\n        public bool isWord;\\n        public TrieNode[] children = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List",
                    "Trie"
                ],
                "code": "```\\npublic class StreamChecker\\n{\\n    private TrieNode trie = new TrieNode();\\n    private LinkedList<char> charBuffer = new LinkedList<char>();\\n    \\n    public StreamChecker(string[] words)\\n    {\\n        foreach(string w in words)\\n        {\\n            TrieNode current = trie;\\n            for(int i = w.Length - 1; i >= 0; i--)\\n            {\\n                char c = w[i];\\n                if(current.children[c-\\'a\\'] is null) current.children[c-\\'a\\'] = new TrieNode();\\n                current = current.children[c-\\'a\\'];       \\n            }\\n            current.isWord = true;\\n        }\\n    }\\n    \\n    public bool Query(char letter)\\n    {\\n        charBuffer.AddLast(letter);\\n        if(charBuffer.Count > 2000) charBuffer.RemoveFirst(); // more than max word length\\n        LinkedListNode<char> llNode = charBuffer.Last;\\n        TrieNode trieNode = trie;\\n        while(llNode != null)\\n        {\\n            trieNode = trieNode.children[llNode.Value-\\'a\\'];\\n            if(trieNode is null) return false;\\n            if(trieNode.isWord) return true;\\n            llNode = llNode.Previous;\\n        }\\n        return false;\\n    }\\n    \\n    private class TrieNode\\n    {\\n        public bool isWord;\\n        public TrieNode[] children = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807601,
                "title": "go-trie-queue-solution",
                "content": "Time: O(WQ) where W is the max size of word, Q is the query time.\\n\\n```go\\ntype StreamChecker struct {\\n    tire *Tire\\n    maxSize int\\n    q []byte\\n}\\n\\ntype Tire struct {\\n    next map[byte]*Tire\\n    isWord bool\\n}\\n\\nfunc Constructor(words []string) StreamChecker {\\n    maxSize := 0\\n    tire := &Tire{make(map[byte]*Tire), false}\\n    for i := 0; i < len(words); i++ {\\n        word := words[i]\\n        insert_word(word, tire)\\n        if len(word) > maxSize {\\n            maxSize = len(word)\\n        }\\n    }\\n    return StreamChecker{tire, maxSize, make([]byte, 0)}\\n}\\n\\nfunc insert_word(word string, tire *Tire) {\\n    // insert the word reversely into tire\\n    curr := tire\\n    for i := len(word)-1; i >= 0; i-- {\\n        w := word[i]\\n        if _, ok := curr.next[w]; !ok {\\n            curr.next[w] = &Tire{make(map[byte]*Tire), false}\\n        } \\n        curr = curr.next[w]\\n    }\\n    curr.isWord = true\\n}\\n\\nfunc (this *StreamChecker) search() bool {\\n    // check the char stream in the queue\\n    curr := this.tire\\n    for i:= 0; i<len(this.q);i++ {\\n        w := this.q[i]\\n        if _, ok := curr.next[w]; !ok {\\n            break\\n        }\\n        curr = curr.next[w]\\n        if curr.isWord == true {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc (this *StreamChecker) Query(letter byte) bool {\\n    // append letter in the front of the queue\\n    this.q = append([]byte{letter}, this.q...)\\n    // if size larger than max size, pop from right\\n    if len(this.q) > this.maxSize {\\n        this.q = this.q[:len(this.q)-1]\\n    }\\n    return this.search()\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Trie",
                    "Queue"
                ],
                "code": "```go\\ntype StreamChecker struct {\\n    tire *Tire\\n    maxSize int\\n    q []byte\\n}\\n\\ntype Tire struct {\\n    next map[byte]*Tire\\n    isWord bool\\n}\\n\\nfunc Constructor(words []string) StreamChecker {\\n    maxSize := 0\\n    tire := &Tire{make(map[byte]*Tire), false}\\n    for i := 0; i < len(words); i++ {\\n        word := words[i]\\n        insert_word(word, tire)\\n        if len(word) > maxSize {\\n            maxSize = len(word)\\n        }\\n    }\\n    return StreamChecker{tire, maxSize, make([]byte, 0)}\\n}\\n\\nfunc insert_word(word string, tire *Tire) {\\n    // insert the word reversely into tire\\n    curr := tire\\n    for i := len(word)-1; i >= 0; i-- {\\n        w := word[i]\\n        if _, ok := curr.next[w]; !ok {\\n            curr.next[w] = &Tire{make(map[byte]*Tire), false}\\n        } \\n        curr = curr.next[w]\\n    }\\n    curr.isWord = true\\n}\\n\\nfunc (this *StreamChecker) search() bool {\\n    // check the char stream in the queue\\n    curr := this.tire\\n    for i:= 0; i<len(this.q);i++ {\\n        w := this.q[i]\\n        if _, ok := curr.next[w]; !ok {\\n            break\\n        }\\n        curr = curr.next[w]\\n        if curr.isWord == true {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc (this *StreamChecker) Query(letter byte) bool {\\n    // append letter in the front of the queue\\n    this.q = append([]byte{letter}, this.q...)\\n    // if size larger than max size, pop from right\\n    if len(this.q) > this.maxSize {\\n        this.q = this.q[:len(this.q)-1]\\n    }\\n    return this.search()\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807383,
                "title": "rust-92ms-100-38m",
                "content": "Runtime: 92 ms, faster than 100.00% of Rust online submissions for Stream of Characters.\\nMemory Usage: 38 MB, less than 25.00% of Rust online submissions for Stream of Characters.\\n```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Debug, Clone)]\\nstruct Trie {\\n    is_word: bool,\\n    next: Vec<Option<Trie>>,\\n}\\n\\nimpl Trie {\\n    fn new() -> Self {\\n        Trie {\\n            is_word: false,\\n            next: vec![None; 26],\\n        }\\n    }\\n}\\n\\nstruct StreamChecker {\\n    root: Trie,\\n    s: String,\\n    max: usize,\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut root = Trie::new();\\n        let mut max = 0;\\n        for w in words {\\n            if w.len() > max {\\n                max = w.len()\\n            }\\n            let v = w.chars().rev().collect::<String>();\\n            let mut node = &mut root;\\n            for ch in v.chars() {\\n                if node.next[(ch as u8 - b\\'a\\') as usize].is_none() {\\n                    node.next[(ch as u8 - b\\'a\\') as usize] = Some(Trie::new())\\n                }\\n                node = node.next[(ch as u8 - b\\'a\\') as usize].as_mut().unwrap();\\n            }\\n            node.is_word = true;\\n        }\\n        let s = String::new();\\n        StreamChecker { root, s, max }\\n    }\\n\\n    fn query(&mut self, letter: char) -> bool {\\n        self.s.push(letter);\\n        let mut node = &mut self.root;\\n        let mut start = 0;\\n        if self.s.len() > self.max {\\n            start = self.s.len() - self.max;\\n        };\\n        for i in (start..self.s.len()).rev() {\\n            let ch = self.s.as_bytes()[i] as char;\\n            if let Some(n) = &mut node.next[(ch as u8 - b\\'a\\') as usize] {\\n                if n.is_word {\\n                    return true;\\n                }\\n                node = n\\n            } else {\\n                return false;\\n            }\\n        }\\n        false\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_stream_checker() {\\n        let mut sc = StreamChecker::new(vec![\"cd\".to_string(), \"f\".to_string(), \"kl\".to_string()]);\\n        assert!(!sc.query(\\'a\\')); // return false\\n        assert!(!sc.query(\\'b\\')); // return false\\n        assert!(!sc.query(\\'c\\')); // return false\\n        assert!(sc.query(\\'d\\')); // return true, because \\'cd\\' is in the wordlist\\n        assert!(!sc.query(\\'e\\')); // return false\\n        assert!(sc.query(\\'f\\')); // return true, because \\'f\\' is in the wordlist\\n        assert!(!sc.query(\\'g\\')); // return false\\n        assert!(!sc.query(\\'h\\')); // return false\\n        assert!(!sc.query(\\'i\\')); // return false\\n        assert!(!sc.query(\\'j\\')); // return false\\n        assert!(!sc.query(\\'k\\')); // return false\\n        assert!(sc.query(\\'l\\')); // return true, because \\'kl\\' is in the wordlist\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Debug, Clone)]\\nstruct Trie {\\n    is_word: bool,\\n    next: Vec<Option<Trie>>,\\n}\\n\\nimpl Trie {\\n    fn new() -> Self {\\n        Trie {\\n            is_word: false,\\n            next: vec![None; 26],\\n        }\\n    }\\n}\\n\\nstruct StreamChecker {\\n    root: Trie,\\n    s: String,\\n    max: usize,\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut root = Trie::new();\\n        let mut max = 0;\\n        for w in words {\\n            if w.len() > max {\\n                max = w.len()\\n            }\\n            let v = w.chars().rev().collect::<String>();\\n            let mut node = &mut root;\\n            for ch in v.chars() {\\n                if node.next[(ch as u8 - b\\'a\\') as usize].is_none() {\\n                    node.next[(ch as u8 - b\\'a\\') as usize] = Some(Trie::new())\\n                }\\n                node = node.next[(ch as u8 - b\\'a\\') as usize].as_mut().unwrap();\\n            }\\n            node.is_word = true;\\n        }\\n        let s = String::new();\\n        StreamChecker { root, s, max }\\n    }\\n\\n    fn query(&mut self, letter: char) -> bool {\\n        self.s.push(letter);\\n        let mut node = &mut self.root;\\n        let mut start = 0;\\n        if self.s.len() > self.max {\\n            start = self.s.len() - self.max;\\n        };\\n        for i in (start..self.s.len()).rev() {\\n            let ch = self.s.as_bytes()[i] as char;\\n            if let Some(n) = &mut node.next[(ch as u8 - b\\'a\\') as usize] {\\n                if n.is_word {\\n                    return true;\\n                }\\n                node = n\\n            } else {\\n                return false;\\n            }\\n        }\\n        false\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_stream_checker() {\\n        let mut sc = StreamChecker::new(vec![\"cd\".to_string(), \"f\".to_string(), \"kl\".to_string()]);\\n        assert!(!sc.query(\\'a\\')); // return false\\n        assert!(!sc.query(\\'b\\')); // return false\\n        assert!(!sc.query(\\'c\\')); // return false\\n        assert!(sc.query(\\'d\\')); // return true, because \\'cd\\' is in the wordlist\\n        assert!(!sc.query(\\'e\\')); // return false\\n        assert!(sc.query(\\'f\\')); // return true, because \\'f\\' is in the wordlist\\n        assert!(!sc.query(\\'g\\')); // return false\\n        assert!(!sc.query(\\'h\\')); // return false\\n        assert!(!sc.query(\\'i\\')); // return false\\n        assert!(!sc.query(\\'j\\')); // return false\\n        assert!(!sc.query(\\'k\\')); // return false\\n        assert!(sc.query(\\'l\\')); // return true, because \\'kl\\' is in the wordlist\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 761591,
                "title": "java-ac-automation",
                "content": "```\\nclass StreamChecker {\\n    Node root;\\n    Node cur=root;\\n    public StreamChecker(String[] words) {\\n        root=new Node();\\n        for(String w:words){\\n            insert(root,w);\\n        }\\n        cur=root;\\n        //build AC\\n        Queue<Node>q=new LinkedList<>();\\n        q.add(root);\\n        while(q.size()!=0){\\n            Node p=q.poll();\\n            for(int i=0;i<26;i++){\\n                if(p.childs[i]!=null){\\n                    Node next=p.childs[i];\\n                    if(p==root){\\n                        next.fail=root;\\n                    }else{\\n                        Node temp=p.fail;\\n                        while(temp!=null){\\n                            if(temp.childs[i]!=null){\\n                                next.fail=temp.childs[i];\\n                                break;\\n                            }\\n                            temp=temp.fail;\\n                        }\\n                        if(temp==null)next.fail=root;\\n                    }\\n                    q.add(next);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        int index=letter-\\'a\\';\\n        boolean res=false;\\n        \\n        while(cur.childs[index]==null&&cur!=root)cur=cur.fail;\\n        \\n        cur=cur.childs[index];\\n        if(cur==null)cur=root;\\n       \\n        Node temp=cur;\\n        while(temp!=root){\\n            if(temp.is==true)res=true;\\n            temp=temp.fail;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void insert(Node r,String w){\\n        for(int i=0;i<w.length();i++){\\n            int index=w.charAt(i)-\\'a\\';\\n            if(r.childs[index]==null)r.childs[index]=new Node();\\n            r=r.childs[index];\\n        }\\n        r.is=true;\\n        r.len=w.length();\\n    }\\n    \\n    class Node{\\n        Node childs[];\\n        Node fail=null;\\n        boolean is=false;\\n        int len=0;\\n        public Node(){\\n            childs=new Node[26];\\n        }\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    Node root;\\n    Node cur=root;\\n    public StreamChecker(String[] words) {\\n        root=new Node();\\n        for(String w:words){\\n            insert(root,w);\\n        }\\n        cur=root;\\n        //build AC\\n        Queue<Node>q=new LinkedList<>();\\n        q.add(root);\\n        while(q.size()!=0){\\n            Node p=q.poll();\\n            for(int i=0;i<26;i++){\\n                if(p.childs[i]!=null){\\n                    Node next=p.childs[i];\\n                    if(p==root){\\n                        next.fail=root;\\n                    }else{\\n                        Node temp=p.fail;\\n                        while(temp!=null){\\n                            if(temp.childs[i]!=null){\\n                                next.fail=temp.childs[i];\\n                                break;\\n                            }\\n                            temp=temp.fail;\\n                        }\\n                        if(temp==null)next.fail=root;\\n                    }\\n                    q.add(next);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        int index=letter-\\'a\\';\\n        boolean res=false;\\n        \\n        while(cur.childs[index]==null&&cur!=root)cur=cur.fail;\\n        \\n        cur=cur.childs[index];\\n        if(cur==null)cur=root;\\n       \\n        Node temp=cur;\\n        while(temp!=root){\\n            if(temp.is==true)res=true;\\n            temp=temp.fail;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void insert(Node r,String w){\\n        for(int i=0;i<w.length();i++){\\n            int index=w.charAt(i)-\\'a\\';\\n            if(r.childs[index]==null)r.childs[index]=new Node();\\n            r=r.childs[index];\\n        }\\n        r.is=true;\\n        r.len=w.length();\\n    }\\n    \\n    class Node{\\n        Node childs[];\\n        Node fail=null;\\n        boolean is=false;\\n        int len=0;\\n        public Node(){\\n            childs=new Node[26];\\n        }\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659678,
                "title": "java-reverse-trie-296-ms",
                "content": "```\\nclass TrieNode {\\n    HashMap<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    public TrieNode() {\\n        this.children = new HashMap<>();\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode head;\\n    \\n    public Trie() {\\n        this.head = new TrieNode();\\n    }\\n    \\n    public void add(String s) {\\n        TrieNode node = head;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (node.children.containsKey(c)) {\\n                node = node.children.get(c);\\n            } else {\\n                TrieNode newnode = new TrieNode();\\n                node.children.put(c, newnode);\\n                node = newnode;\\n            }\\n        }\\n        node.isWord = true;        \\n    }\\n    \\n    public boolean check(String s) {\\n        TrieNode node = head;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (node.children.containsKey(c)) {\\n                node = node.children.get(c);\\n                if (node.isWord) return true;\\n            } else return false;\\n        }\\n        return false;\\n    }\\n}\\n\\nclass StreamChecker {\\n    Trie trie;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        trie = new Trie();\\n        sb = new StringBuilder();\\n        for (String s : words) trie.add(s);\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        return trie.check(sb.toString());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    HashMap<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    public TrieNode() {\\n        this.children = new HashMap<>();\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode head;\\n    \\n    public Trie() {\\n        this.head = new TrieNode();\\n    }\\n    \\n    public void add(String s) {\\n        TrieNode node = head;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (node.children.containsKey(c)) {\\n                node = node.children.get(c);\\n            } else {\\n                TrieNode newnode = new TrieNode();\\n                node.children.put(c, newnode);\\n                node = newnode;\\n            }\\n        }\\n        node.isWord = true;        \\n    }\\n    \\n    public boolean check(String s) {\\n        TrieNode node = head;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (node.children.containsKey(c)) {\\n                node = node.children.get(c);\\n                if (node.isWord) return true;\\n            } else return false;\\n        }\\n        return false;\\n    }\\n}\\n\\nclass StreamChecker {\\n    Trie trie;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        trie = new Trie();\\n        sb = new StringBuilder();\\n        for (String s : words) trie.add(s);\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        return trie.check(sb.toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589464,
                "title": "py3-deque-and-trie",
                "content": "Basic trie construction and deque to find recent queries.\\nqueue size = max(words)\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.q = deque()\\n        self.maxqsize = 0\\n        for word in words: \\n            self.maxqsize = max(self.maxqsize, len(word))\\n            self.construct(word[::-1])\\n            \\n    def construct(self, word):\\n        trie = self.trie\\n        for ch in word:\\n            if ch not in trie:\\n                trie[ch] = {}\\n            trie = trie[ch]\\n        trie[\\'#\\'] = None\\n    \\n    def findifexist(self, word):\\n        trie = self.trie\\n        for ch in word:\\n            if \\'#\\' in trie: return True\\n            if ch not in trie: break;\\n            trie = trie[ch] \\n        return \\'#\\' in trie\\n\\n    def query(self, letter: str) -> bool:\\n        self.q.append(letter)\\n        if len(self.q) > self.maxqsize: self.q.popleft();\\n        if letter in self.trie:\\n            tocheck = list(self.q)\\n            tocheck.reverse()\\n            return self.findifexist(tocheck)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.q = deque()\\n        self.maxqsize = 0\\n        for word in words: \\n            self.maxqsize = max(self.maxqsize, len(word))\\n            self.construct(word[::-1])\\n            \\n    def construct(self, word):\\n        trie = self.trie\\n        for ch in word:\\n            if ch not in trie:\\n                trie[ch] = {}\\n            trie = trie[ch]\\n        trie[\\'#\\'] = None\\n    \\n    def findifexist(self, word):\\n        trie = self.trie\\n        for ch in word:\\n            if \\'#\\' in trie: return True\\n            if ch not in trie: break;\\n            trie = trie[ch] \\n        return \\'#\\' in trie\\n\\n    def query(self, letter: str) -> bool:\\n        self.q.append(letter)\\n        if len(self.q) > self.maxqsize: self.q.popleft();\\n        if letter in self.trie:\\n            tocheck = list(self.q)\\n            tocheck.reverse()\\n            return self.findifexist(tocheck)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417976,
                "title": "c-aho-corasick-automaton",
                "content": "```cpp\\nclass StreamChecker {\\n    struct TrieNode {\\n        bool isEnd;\\n        TrieNode* children[26];\\n        TrieNode* suffixLink;\\n        TrieNode* outputLink;\\n        TrieNode() {\\n            isEnd = false;\\n            memset(children, 0, sizeof(TrieNode*)*26);\\n            suffixLink = outputLink = NULL;\\n        }\\n    };\\n    \\n\\tTrieNode * root;\\n\\tTrieNode * state;\\n    \\n    void buildTrie(vector<string> & words) {\\n        for (auto & w: words) {\\n            TrieNode * node = root;\\n            for (auto c: w) {\\n                if (!node->children[c-\\'a\\'])\\n                    node->children[c-\\'a\\'] = new TrieNode();\\n                node = node->children[c-\\'a\\'];\\n            }\\n            node->isEnd = true;\\n        }\\n    }\\n    \\n    void buildSuffixLink() {\\n        queue<TrieNode*> bfsQ;\\n        root->suffixLink = root;\\n        bfsQ.push(root);\\n        while (!bfsQ.empty()) {\\n            TrieNode * curr = bfsQ.front(); bfsQ.pop();\\n            for (int i = 0; i < 26; i++) {\\n                if (curr->children[i]) {\\n                    TrieNode * suf = curr->suffixLink;\\n                    while (suf != root && !suf->children[i])\\n                        suf = suf->suffixLink;\\n                    if (suf->children[i] && suf != curr)\\n                        curr->children[i]->suffixLink = suf->children[i];\\n                    else\\n                        curr->children[i]->suffixLink = root;\\n                    bfsQ.push(curr->children[i]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    void buildOutputLink() {\\n        queue<TrieNode*> bfsQ;\\n        root->suffixLink = root;\\n        bfsQ.push(root);\\n        while (!bfsQ.empty()) {\\n            TrieNode * curr = bfsQ.front(); bfsQ.pop();\\n            TrieNode * suf = curr->suffixLink;\\n            while (suf != root && !suf->isEnd)\\n                suf = suf->suffixLink;\\n            if (suf->isEnd && suf != curr)\\n                curr->outputLink = suf;\\n            for (int i = 0; i < 26; i++) {\\n                if (curr->children[i])\\n                    bfsQ.push(curr->children[i]);\\n            }\\n        }\\n    }\\n\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode();\\n        buildTrie(words);\\n        buildSuffixLink();\\n        buildOutputLink();\\n        state = root;\\n    }\\n    \\n    bool query(char letter) {\\n        while (state != root && !state->children[letter-\\'a\\'])\\n            state = state->suffixLink;\\n        if (state->children[letter-\\'a\\'])\\n            state = state->children[letter-\\'a\\'];\\n        return state->isEnd || state->outputLink;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass StreamChecker {\\n    struct TrieNode {\\n        bool isEnd;\\n        TrieNode* children[26];\\n        TrieNode* suffixLink;\\n        TrieNode* outputLink;\\n        TrieNode() {\\n            isEnd = false;\\n            memset(children, 0, sizeof(TrieNode*)*26);\\n            suffixLink = outputLink = NULL;\\n        }\\n    };\\n    \\n\\tTrieNode * root;\\n\\tTrieNode * state;\\n    \\n    void buildTrie(vector<string> & words) {\\n        for (auto & w: words) {\\n            TrieNode * node = root;\\n            for (auto c: w) {\\n                if (!node->children[c-\\'a\\'])\\n                    node->children[c-\\'a\\'] = new TrieNode();\\n                node = node->children[c-\\'a\\'];\\n            }\\n            node->isEnd = true;\\n        }\\n    }\\n    \\n    void buildSuffixLink() {\\n        queue<TrieNode*> bfsQ;\\n        root->suffixLink = root;\\n        bfsQ.push(root);\\n        while (!bfsQ.empty()) {\\n            TrieNode * curr = bfsQ.front(); bfsQ.pop();\\n            for (int i = 0; i < 26; i++) {\\n                if (curr->children[i]) {\\n                    TrieNode * suf = curr->suffixLink;\\n                    while (suf != root && !suf->children[i])\\n                        suf = suf->suffixLink;\\n                    if (suf->children[i] && suf != curr)\\n                        curr->children[i]->suffixLink = suf->children[i];\\n                    else\\n                        curr->children[i]->suffixLink = root;\\n                    bfsQ.push(curr->children[i]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    void buildOutputLink() {\\n        queue<TrieNode*> bfsQ;\\n        root->suffixLink = root;\\n        bfsQ.push(root);\\n        while (!bfsQ.empty()) {\\n            TrieNode * curr = bfsQ.front(); bfsQ.pop();\\n            TrieNode * suf = curr->suffixLink;\\n            while (suf != root && !suf->isEnd)\\n                suf = suf->suffixLink;\\n            if (suf->isEnd && suf != curr)\\n                curr->outputLink = suf;\\n            for (int i = 0; i < 26; i++) {\\n                if (curr->children[i])\\n                    bfsQ.push(curr->children[i]);\\n            }\\n        }\\n    }\\n\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode();\\n        buildTrie(words);\\n        buildSuffixLink();\\n        buildOutputLink();\\n        state = root;\\n    }\\n    \\n    bool query(char letter) {\\n        while (state != root && !state->children[letter-\\'a\\'])\\n            state = state->suffixLink;\\n        if (state->children[letter-\\'a\\'])\\n            state = state->children[letter-\\'a\\'];\\n        return state->isEnd || state->outputLink;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364037,
                "title": "c-lang-trie-solution-beat-100",
                "content": "```\\n#define MAX_SIZE 2000\\n\\ntypedef struct Node {\\n    struct Node *children[26];\\n    bool isWord;\\n} Node;\\n\\ntypedef struct {\\n    Node *root;\\n    char *str;\\n    int count;\\n} StreamChecker;\\n\\nNode *createNode() {\\n    Node *node = malloc(sizeof(Node));\\n    node->isWord = false;\\n    for (int i = 0; i < 26; i++) {\\n        node->children[i] = NULL;\\n    }\\n    return node;\\n}\\n\\nvoid addWord(Node *root, char *word) {\\n    Node *node = root;\\n    for (char *ptr = word; *ptr != \\'\\\\0\\'; ptr++) {\\n        char c = *ptr;\\n        if (!node->children[c - \\'a\\']) {\\n            node->children[c - \\'a\\'] = createNode();\\n        }\\n        node = node->children[c - \\'a\\'];\\n    }\\n    node->isWord = true;\\n}\\n\\nbool findWord(Node *root, const char *word, int start) {\\n    Node *node = root;\\n    while (start >= 0) {\\n        char c = word[start];\\n        if (!node->children[c - \\'a\\']) {\\n            return false;\\n        }\\n        node = node->children[c - \\'a\\'];\\n        if (node->isWord) {\\n            return true;\\n        }\\n        start--;\\n    }\\n    return false;\\n}\\n\\nvoid reverse(char *word) {\\n    int left = 0, right = strlen(word) - 1;\\n    while (left < right) {\\n        char tmp = word[left];\\n        word[left] = word[right];\\n        word[right] = tmp;\\n        left++;\\n        right--;\\n    }\\n}\\n\\nchar *createString() {\\n    char *str = malloc(sizeof(char) * (MAX_SIZE + 2));\\n    memset(str, 0, MAX_SIZE + 2);\\n    return str;\\n}\\n\\nStreamChecker *streamCheckerCreate(char **words, int wordsSize) {\\n    StreamChecker *checker = malloc(sizeof(StreamChecker));\\n    checker->root = createNode();\\n    checker->str = createString();\\n    checker->count = 0;\\n    for (int i = 0; i < wordsSize; i++) {\\n        reverse(words[i]);\\n        addWord(checker->root, words[i]);\\n    }\\n    return checker;\\n\\n}\\n\\nbool streamCheckerQuery(StreamChecker *obj, char letter) {\\n    if (obj->count >= MAX_SIZE) {\\n        free(obj->str);\\n        obj->count = 0;\\n        obj->str = createString();\\n    }\\n    obj->str[obj->count++] = letter;\\n    int count = obj->count;\\n    return findWord(obj->root, obj->str, count - 1);\\n}\\n\\nvoid freeTrie(Node *root) {\\n    if (root == NULL) {\\n        return;\\n    }\\n    for (int i = 0; i < 26; i++) {\\n        if (root->children[i]) {\\n            freeTrie(root->children[i]);\\n        }\\n    }\\n    free(root);\\n}\\n\\nvoid streamCheckerFree(StreamChecker *obj) {\\n    freeTrie(obj->root);\\n    free(obj->str);\\n    free(obj);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define MAX_SIZE 2000\\n\\ntypedef struct Node {\\n    struct Node *children[26];\\n    bool isWord;\\n} Node;\\n\\ntypedef struct {\\n    Node *root;\\n    char *str;\\n    int count;\\n} StreamChecker;\\n\\nNode *createNode() {\\n    Node *node = malloc(sizeof(Node));\\n    node->isWord = false;\\n    for (int i = 0; i < 26; i++) {\\n        node->children[i] = NULL;\\n    }\\n    return node;\\n}\\n\\nvoid addWord(Node *root, char *word) {\\n    Node *node = root;\\n    for (char *ptr = word; *ptr != \\'\\\\0\\'; ptr++) {\\n        char c = *ptr;\\n        if (!node->children[c - \\'a\\']) {\\n            node->children[c - \\'a\\'] = createNode();\\n        }\\n        node = node->children[c - \\'a\\'];\\n    }\\n    node->isWord = true;\\n}\\n\\nbool findWord(Node *root, const char *word, int start) {\\n    Node *node = root;\\n    while (start >= 0) {\\n        char c = word[start];\\n        if (!node->children[c - \\'a\\']) {\\n            return false;\\n        }\\n        node = node->children[c - \\'a\\'];\\n        if (node->isWord) {\\n            return true;\\n        }\\n        start--;\\n    }\\n    return false;\\n}\\n\\nvoid reverse(char *word) {\\n    int left = 0, right = strlen(word) - 1;\\n    while (left < right) {\\n        char tmp = word[left];\\n        word[left] = word[right];\\n        word[right] = tmp;\\n        left++;\\n        right--;\\n    }\\n}\\n\\nchar *createString() {\\n    char *str = malloc(sizeof(char) * (MAX_SIZE + 2));\\n    memset(str, 0, MAX_SIZE + 2);\\n    return str;\\n}\\n\\nStreamChecker *streamCheckerCreate(char **words, int wordsSize) {\\n    StreamChecker *checker = malloc(sizeof(StreamChecker));\\n    checker->root = createNode();\\n    checker->str = createString();\\n    checker->count = 0;\\n    for (int i = 0; i < wordsSize; i++) {\\n        reverse(words[i]);\\n        addWord(checker->root, words[i]);\\n    }\\n    return checker;\\n\\n}\\n\\nbool streamCheckerQuery(StreamChecker *obj, char letter) {\\n    if (obj->count >= MAX_SIZE) {\\n        free(obj->str);\\n        obj->count = 0;\\n        obj->str = createString();\\n    }\\n    obj->str[obj->count++] = letter;\\n    int count = obj->count;\\n    return findWord(obj->root, obj->str, count - 1);\\n}\\n\\nvoid freeTrie(Node *root) {\\n    if (root == NULL) {\\n        return;\\n    }\\n    for (int i = 0; i < 26; i++) {\\n        if (root->children[i]) {\\n            freeTrie(root->children[i]);\\n        }\\n    }\\n    free(root);\\n}\\n\\nvoid streamCheckerFree(StreamChecker *obj) {\\n    freeTrie(obj->root);\\n    free(obj->str);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 363039,
                "title": "java-trie-bfs-782-ms-faster-than-10-42-91-4-mb-less-than-60-00",
                "content": "```\\nclass StreamChecker {\\n    TrieNode root;\\n    Queue<TrieNode> q;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        q = new LinkedList<>();\\n        for (String w : words) {\\n            build(root, w.toCharArray());\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        q.offer(root);\\n        int size = q.size();\\n        boolean res = false;\\n        int idx = letter - \\'a\\';\\n        for (int i = 0; i < size; ++i) {\\n            TrieNode p = q.poll();\\n            if (p.kids[idx] == null) {\\n                continue;\\n            }\\n            p = p.kids[idx];\\n            if (p.isWord) {\\n                res = true;\\n            }\\n            q.offer(p);\\n        }\\n        return res;\\n    }\\n    \\n    private void build(TrieNode root, char[] w) {\\n        for (int i = 0; i < w.length; ++i) {\\n            int idx = w[i] - \\'a\\';\\n            if (root.kids[idx] == null) {\\n                root.kids[idx] = new TrieNode();\\n            }\\n            root = root.kids[idx];\\n        }\\n        root.isWord = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] kids;\\n    boolean isWord;\\n    \\n    TrieNode() {\\n        kids = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    TrieNode root;\\n    Queue<TrieNode> q;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        q = new LinkedList<>();\\n        for (String w : words) {\\n            build(root, w.toCharArray());\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        q.offer(root);\\n        int size = q.size();\\n        boolean res = false;\\n        int idx = letter - \\'a\\';\\n        for (int i = 0; i < size; ++i) {\\n            TrieNode p = q.poll();\\n            if (p.kids[idx] == null) {\\n                continue;\\n            }\\n            p = p.kids[idx];\\n            if (p.isWord) {\\n                res = true;\\n            }\\n            q.offer(p);\\n        }\\n        return res;\\n    }\\n    \\n    private void build(TrieNode root, char[] w) {\\n        for (int i = 0; i < w.length; ++i) {\\n            int idx = w[i] - \\'a\\';\\n            if (root.kids[idx] == null) {\\n                root.kids[idx] = new TrieNode();\\n            }\\n            root = root.kids[idx];\\n        }\\n        root.isWord = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] kids;\\n    boolean isWord;\\n    \\n    TrieNode() {\\n        kids = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 304621,
                "title": "python-aho-corasick-trie",
                "content": "\\n\\n```\\nclass Node:\\n    def __init__(self):\\n        self.next = {}\\n        self.fail = None\\n        self.is_word = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = Node()\\n        \\n    def add(self,word):\\n        cur = self.root\\n        for ch in word:\\n            if ch not in cur.next:\\n                cur.next[ch] = Node()\\n            cur = cur.next[ch]\\n        \\n        cur.is_word = True\\n            \\n    def build_failover(self):\\n        \\n        queue = collections.deque()\\n        for ch in self.root.next:\\n            self.root.next[ch].fail = self.root\\n            queue.append(self.root.next[ch])\\n            \\n        while queue:\\n            node = queue.popleft()\\n            for ch in node.next:\\n                queue.append(node.next[ch])\\n                failover = node.fail\\n                while True:\\n                    if failover==None:\\n                        node.next[ch].fail = self.root\\n                        break\\n                        \\n                    if ch in failover.next:\\n                        node.next[ch].fail = failover.next[ch]\\n                        break\\n                    else:\\n                        failover = failover.fail\\n    \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        self.build_trie(words)\\n        self.cur = self.trie.root\\n        \\n    def build_trie(self,words):\\n        for word in words:\\n            self.trie.add(word)\\n    \\n        self.trie.build_failover()\\n        \\n    def query(self, letter: str) -> bool:\\n        result = False\\n        while True:\\n            if letter in self.cur.next:\\n            \\n                self.cur = self.cur.next[letter]\\n\\n                if self.cur.is_word:\\n                    result = True\\n\\n                if self.cur.fail!=None and self.cur.fail.is_word:\\n                    result = True\\n                break\\n            elif self.cur.fail == None:\\n                self.cur = self.trie.root\\n                break\\n            else:\\n                self.cur = self.cur.fail\\n            \\n        return result\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.next = {}\\n        self.fail = None\\n        self.is_word = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = Node()\\n        \\n    def add(self,word):\\n        cur = self.root\\n        for ch in word:\\n            if ch not in cur.next:\\n                cur.next[ch] = Node()\\n            cur = cur.next[ch]\\n        \\n        cur.is_word = True\\n            \\n    def build_failover(self):\\n        \\n        queue = collections.deque()\\n        for ch in self.root.next:\\n            self.root.next[ch].fail = self.root\\n            queue.append(self.root.next[ch])\\n            \\n        while queue:\\n            node = queue.popleft()\\n            for ch in node.next:\\n                queue.append(node.next[ch])\\n                failover = node.fail\\n                while True:\\n                    if failover==None:\\n                        node.next[ch].fail = self.root\\n                        break\\n                        \\n                    if ch in failover.next:\\n                        node.next[ch].fail = failover.next[ch]\\n                        break\\n                    else:\\n                        failover = failover.fail\\n    \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        self.build_trie(words)\\n        self.cur = self.trie.root\\n        \\n    def build_trie(self,words):\\n        for word in words:\\n            self.trie.add(word)\\n    \\n        self.trie.build_failover()\\n        \\n    def query(self, letter: str) -> bool:\\n        result = False\\n        while True:\\n            if letter in self.cur.next:\\n            \\n                self.cur = self.cur.next[letter]\\n\\n                if self.cur.is_word:\\n                    result = True\\n\\n                if self.cur.fail!=None and self.cur.fail.is_word:\\n                    result = True\\n                break\\n            elif self.cur.fail == None:\\n                self.cur = self.trie.root\\n                break\\n            else:\\n                self.cur = self.cur.fail\\n            \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282225,
                "title": "easy-understanding-python-trie-template-solution-good-for-interview",
                "content": "Build trie by reversely insert letter of each word, record stream with a stack and reversely iterate stack to find whether a initial letter of word appear(\\'#\\' appear in dictionary then return True) or letter not equal to current letter in trie along backward direction of stack(return False).\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.stack = []\\n        \\n        for word in words:\\n            t = self.trie\\n            for c in reversed(word):\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\\'#\\'] = \\'#\\'\\n\\n    def query(self, letter: str) -> bool:\\n        t = self.trie\\n        self.stack.append(letter)\\n        \\n        for i in range(len(self.stack)-1, -1, -1):\\n            char = self.stack[i]\\n            if char not in t:\\n                return False\\n            else:\\n                t = t[char]\\n                if \\'#\\' in t:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.stack = []\\n        \\n        for word in words:\\n            t = self.trie\\n            for c in reversed(word):\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\\'#\\'] = \\'#\\'\\n\\n    def query(self, letter: str) -> bool:\\n        t = self.trie\\n        self.stack.append(letter)\\n        \\n        for i in range(len(self.stack)-1, -1, -1):\\n            char = self.stack[i]\\n            if char not in t:\\n                return False\\n            else:\\n                t = t[char]\\n                if \\'#\\' in t:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281608,
                "title": "easy-java-solution-build-dictionary-tree-and-query-from-tree",
                "content": "Idea is very simple:\\n1. reverse each word and build tree structure\\n2. keep appending letter to stringbuilder\\n3. everytime loop from end of stringbuilder,  search in tree structure.\\n```\\nclass StreamChecker {\\n\\n    private Node root;\\n    private StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        sb = new StringBuilder();\\n        build(words);\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        return findWord();\\n    }\\n    \\n    private boolean findWord() {\\n        Node node = root;\\n        for(int i = sb.length() - 1; i >= 0; i--) {\\n            char ch = sb.charAt(i);\\n            if(node.child[ch - \\'a\\'] == null) {\\n                return false;\\n            }\\n            node = node.child[ch - \\'a\\'];\\n            if(node.end) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void build(String[] words) {\\n        for(String word: words) {\\n            Node node = root;\\n            for(int i = word.length() - 1; i >= 0; i--) {\\n                char ch = word.charAt(i);\\n                if(node.child[ch - \\'a\\'] == null) {\\n                    node.child[ch - \\'a\\'] = new Node();\\n                }\\n                node = node.child[ch - \\'a\\'];\\n            }\\n            node.end = true;\\n        }\\n    }\\n    \\n    private class Node {\\n        Node[] child = new Node[26];\\n        boolean end = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n\\n    private Node root;\\n    private StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        sb = new StringBuilder();\\n        build(words);\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        return findWord();\\n    }\\n    \\n    private boolean findWord() {\\n        Node node = root;\\n        for(int i = sb.length() - 1; i >= 0; i--) {\\n            char ch = sb.charAt(i);\\n            if(node.child[ch - \\'a\\'] == null) {\\n                return false;\\n            }\\n            node = node.child[ch - \\'a\\'];\\n            if(node.end) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void build(String[] words) {\\n        for(String word: words) {\\n            Node node = root;\\n            for(int i = word.length() - 1; i >= 0; i--) {\\n                char ch = word.charAt(i);\\n                if(node.child[ch - \\'a\\'] == null) {\\n                    node.child[ch - \\'a\\'] = new Node();\\n                }\\n                node = node.child[ch - \\'a\\'];\\n            }\\n            node.end = true;\\n        }\\n    }\\n    \\n    private class Node {\\n        Node[] child = new Node[26];\\n        boolean end = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280557,
                "title": "java-solution-with-trienode",
                "content": "normally, we build the trie by scanning from first char to last one. but as it\\'s streaming data and we store build the trie reversely - for each word, start from the last character.\\nAlso, to avoid TLE, get the maximum length of the word and delete the character in stringbuilder if the length is longer than max length\\n```\\nclass StreamChecker {\\n    StringBuilder input;\\n    TrieNode root;\\n    int maxLen;\\n    public StreamChecker(String[] words) {\\n        input = new StringBuilder();\\n        root = new TrieNode();\\n        maxLen = 0;\\n        for (String w : words) {\\n            maxLen = Math.max(maxLen, w.length());\\n            TrieNode cur = root;\\n            for (int i = w.length() - 1; i >= 0; i--) {\\n                char c = w.charAt(i);\\n                if (!cur.children.containsKey(c)) {\\n                    cur.children.put(c, new TrieNode());\\n                }\\n                cur = cur.children.get(c);\\n            }\\n            cur.isWord = true;\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        input.append(letter);\\n        if (input.length() > maxLen) input.deleteCharAt(0);\\n        TrieNode cur = root;\\n        for (int i = input.length() - 1; i >= 0; i--) {\\n            char c = input.charAt(i);\\n            if (!cur.children.containsKey(c)) return false;\\n            cur = cur.children.get(c);\\n            if (cur.isWord) return true;\\n        }\\n        return false;\\n    }\\n\\n    class TrieNode {\\n        Map<Character, TrieNode> children;\\n        boolean isWord;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            isWord = false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    StringBuilder input;\\n    TrieNode root;\\n    int maxLen;\\n    public StreamChecker(String[] words) {\\n        input = new StringBuilder();\\n        root = new TrieNode();\\n        maxLen = 0;\\n        for (String w : words) {\\n            maxLen = Math.max(maxLen, w.length());\\n            TrieNode cur = root;\\n            for (int i = w.length() - 1; i >= 0; i--) {\\n                char c = w.charAt(i);\\n                if (!cur.children.containsKey(c)) {\\n                    cur.children.put(c, new TrieNode());\\n                }\\n                cur = cur.children.get(c);\\n            }\\n            cur.isWord = true;\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        input.append(letter);\\n        if (input.length() > maxLen) input.deleteCharAt(0);\\n        TrieNode cur = root;\\n        for (int i = input.length() - 1; i >= 0; i--) {\\n            char c = input.charAt(i);\\n            if (!cur.children.containsKey(c)) return false;\\n            cur = cur.children.get(c);\\n            if (cur.isWord) return true;\\n        }\\n        return false;\\n    }\\n\\n    class TrieNode {\\n        Map<Character, TrieNode> children;\\n        boolean isWord;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            isWord = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278752,
                "title": "trie-solution-o-max-word-length-with-explanation",
                "content": "Idea is just to search for words from the end. \\n1) At the beginning (in the constructor), add all the words to trie starting from the end.\\n2) Maintain Stream of characters in a list\\n3) When a character arrives to the stream just start search in the trie backwards.\\n\\nTotal time complexity for each search case is O(max(word.length)) where max(word.length) is the maximum length of a word in a dictionary.\\n\\nPlease find code below.\\n```\\nclass StreamChecker {\\n    \\n    class Trie {\\n        boolean isWord;\\n        Trie [] next;\\n        \\n        public Trie () {\\n            next = new Trie[26];\\n        }\\n    \\n        \\n    }\\n    Trie root;\\n    List<Character> chars;\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        for(int i = 0;i<words.length;i++) {\\n           addToTrie(words[i]);\\n        }\\n        chars = new ArrayList<>();\\n    }\\n    \\n    \\n    void addToTrie(String str) {\\n        \\n        Trie node = root;\\n        for(int i = str.length()-1;i>=0;i--) {\\n            int ch = str.charAt(i) - \\'a\\';\\n            if(node.next[ch] == null)  node.next[ch] = new Trie();\\n            node = node.next[ch];\\n        }\\n        \\n        node.isWord = true;\\n        \\n    }\\n    public boolean query(char letter) {\\n        \\n        Trie node = root;\\n        \\n        chars.add(letter);\\n        int i = chars.size()-1;\\n        while(node != null && !node.isWord && i >= 0) {\\n            int ch =  chars.get(i) - \\'a\\';\\n            node = node.next[ch];\\n            --i;\\n        }\\n        \\n        return node != null && node.isWord;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    \\n    class Trie {\\n        boolean isWord;\\n        Trie [] next;\\n        \\n        public Trie () {\\n            next = new Trie[26];\\n        }\\n    \\n        \\n    }\\n    Trie root;\\n    List<Character> chars;\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        for(int i = 0;i<words.length;i++) {\\n           addToTrie(words[i]);\\n        }\\n        chars = new ArrayList<>();\\n    }\\n    \\n    \\n    void addToTrie(String str) {\\n        \\n        Trie node = root;\\n        for(int i = str.length()-1;i>=0;i--) {\\n            int ch = str.charAt(i) - \\'a\\';\\n            if(node.next[ch] == null)  node.next[ch] = new Trie();\\n            node = node.next[ch];\\n        }\\n        \\n        node.isWord = true;\\n        \\n    }\\n    public boolean query(char letter) {\\n        \\n        Trie node = root;\\n        \\n        chars.add(letter);\\n        int i = chars.size()-1;\\n        while(node != null && !node.isWord && i >= 0) {\\n            int ch =  chars.get(i) - \\'a\\';\\n            node = node.next[ch];\\n            --i;\\n        }\\n        \\n        return node != null && node.isWord;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278733,
                "title": "trie-queue-technique-simple-solution",
                "content": "```\\nclass StreamChecker {\\n    private Trie root = null;\\n    private Queue<Trie> queue = null;\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        if(words != null) {\\n           for(String word : words) {\\n               addToTrie(word, root);\\n           } \\n        }\\n        queue = new LinkedList<>();\\n        queue.offer(root);\\n    }\\n    \\n    private void addToTrie(String word, Trie base) {\\n        Trie node = base;\\n        for(char c : word.toCharArray()) {\\n            if(node.children == null)\\n                node.children = new Trie[26];\\n            if(node.children[c - \\'a\\'] == null)\\n                node.children[c - \\'a\\'] = new Trie();\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isWord = true;\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean exists = false;\\n        int size = queue.size();\\n        for(int i=0; i<size; ++i) {\\n            Trie prev = queue.poll();\\n            if(prev.children != null) {\\n                Trie node = prev.children[letter - \\'a\\'];\\n                if(node != null) {\\n                    if(node.isWord) exists = true;\\n                    queue.offer(node);\\n                }\\n            }\\n        }\\n        queue.offer(root);\\n        return exists;\\n    }\\n}\\n\\nclass Trie {\\n    boolean isWord;\\n    Trie[] children;\\n}",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    private Trie root = null;\\n    private Queue<Trie> queue = null;\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        if(words != null) {\\n           for(String word : words) {\\n               addToTrie(word, root);\\n           } \\n        }\\n        queue = new LinkedList<>();\\n        queue.offer(root);\\n    }\\n    \\n    private void addToTrie(String word, Trie base) {\\n        Trie node = base;\\n        for(char c : word.toCharArray()) {\\n            if(node.children == null)\\n                node.children = new Trie[26];\\n            if(node.children[c - \\'a\\'] == null)\\n                node.children[c - \\'a\\'] = new Trie();\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isWord = true;\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean exists = false;\\n        int size = queue.size();\\n        for(int i=0; i<size; ++i) {\\n            Trie prev = queue.poll();\\n            if(prev.children != null) {\\n                Trie node = prev.children[letter - \\'a\\'];\\n                if(node != null) {\\n                    if(node.isWord) exists = true;\\n                    queue.offer(node);\\n                }\\n            }\\n        }\\n        queue.offer(root);\\n        return exists;\\n    }\\n}\\n\\nclass Trie {\\n    boolean isWord;\\n    Trie[] children;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 278730,
                "title": "java-trie",
                "content": "http://www.noteanddata.com/leetcode-1032-Stream-of-Characters-java-solution-note.html\\n\\n```\\nclass StreamChecker {\\n    \\n    static class Node {\\n        Node[] children;\\n        boolean isWordEnd;\\n        public Node() {\\n            this.children = new Node[26];\\n            this.isWordEnd = false;\\n        }\\n    }\\n\\n    private Node root;\\n    private List<Character> queryList;\\n    \\n    public StreamChecker(String[] words) {\\n        this.root = new Node();\\n        this.queryList = new ArrayList<>();\\n        \\n        for(String word: words) {\\n            char[] arr = word.toCharArray();\\n            Node cur = root;\\n            for(int i = arr.length-1; i >= 0; --i) {\\n                char ch = arr[i];\\n                int index = (int)(ch-\\'a\\');\\n                \\n                if(null == cur.children[index]) {\\n                    cur.children[index] = new Node(); \\n                }\\n                cur = cur.children[index];\\n                if(i == 0) {\\n                    cur.isWordEnd = true;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        queryList.add(letter);\\n        Node cur = root;\\n        for(int i = queryList.size()-1; i >= 0; --i) {\\n            int index = (int)(queryList.get(i)-\\'a\\');\\n            if(cur.children[index] == null) {\\n                //System.out.println(\"null\");\\n                return false;\\n            }\\n            cur = cur.children[index];\\n            //System.out.println(\"cur.isWordEnd=\" + cur.isWordEnd);\\n            if(cur.isWordEnd) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    \\n    static class Node {\\n        Node[] children;\\n        boolean isWordEnd;\\n        public Node() {\\n            this.children = new Node[26];\\n            this.isWordEnd = false;\\n        }\\n    }\\n\\n    private Node root;\\n    private List<Character> queryList;\\n    \\n    public StreamChecker(String[] words) {\\n        this.root = new Node();\\n        this.queryList = new ArrayList<>();\\n        \\n        for(String word: words) {\\n            char[] arr = word.toCharArray();\\n            Node cur = root;\\n            for(int i = arr.length-1; i >= 0; --i) {\\n                char ch = arr[i];\\n                int index = (int)(ch-\\'a\\');\\n                \\n                if(null == cur.children[index]) {\\n                    cur.children[index] = new Node(); \\n                }\\n                cur = cur.children[index];\\n                if(i == 0) {\\n                    cur.isWordEnd = true;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        queryList.add(letter);\\n        Node cur = root;\\n        for(int i = queryList.size()-1; i >= 0; --i) {\\n            int index = (int)(queryList.get(i)-\\'a\\');\\n            if(cur.children[index] == null) {\\n                //System.out.println(\"null\");\\n                return false;\\n            }\\n            cur = cur.children[index];\\n            //System.out.println(\"cur.isWordEnd=\" + cur.isWordEnd);\\n            if(cur.isWordEnd) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746379,
                "title": "c-trie-solution-using-deque",
                "content": "In order to minimize the number of characters that we store in our string, I am using a deque of characters which limits the storage to the maximum length of a string from ```words``` since if present, no suffix will have a length greater than this longest string.\\n\\n```\\nclass node {\\n    public:\\n    node *next[26];\\n    bool is_end;\\n    node(bool x=false){\\n        memset(next,0,sizeof(next));\\n        is_end=x;\\n    }\\n};\\nclass Trie {\\npublic:\\n    node *root;\\n    \\n    Trie() { root=new node(); }\\n    \\n    void insert(string &word) {\\n        node *p=root;\\n        for(int i=0; i<word.length(); i++){\\n            if(p->next[word[i]-\\'a\\']==NULL){\\n                p->next[word[i]-\\'a\\']=new node();\\n            }\\n            p=p->next[word[i]-\\'a\\'];\\n        }\\n        p->is_end=true;\\n    }\\n    \\n    bool search(deque<char> &dq) {\\n        node* dummy=root;\\n        for(auto it=dq.rbegin(); it!=dq.rend(); it++){\\n            if(!dummy or !dummy->next[*it-\\'a\\']){ return false; }\\n            dummy=dummy->next[*it-\\'a\\'];\\n            if(dummy and dummy->is_end){ return true; }\\n        }\\n        return false;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    Trie *t=new Trie();\\n    string s=\"\";\\n    deque<char> dq;\\n    int mx=0;\\n    StreamChecker(vector<string>& words) {\\n        for(auto &w:words){\\n            mx=max(mx,(int)w.length());\\n            reverse(w.begin(),w.end());\\n            t->insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        dq.push_back(letter);\\n        if(dq.size()>mx){ dq.pop_front(); }\\n        return t->search(dq);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Trie",
                    "Queue"
                ],
                "code": "```words```\n```\\nclass node {\\n    public:\\n    node *next[26];\\n    bool is_end;\\n    node(bool x=false){\\n        memset(next,0,sizeof(next));\\n        is_end=x;\\n    }\\n};\\nclass Trie {\\npublic:\\n    node *root;\\n    \\n    Trie() { root=new node(); }\\n    \\n    void insert(string &word) {\\n        node *p=root;\\n        for(int i=0; i<word.length(); i++){\\n            if(p->next[word[i]-\\'a\\']==NULL){\\n                p->next[word[i]-\\'a\\']=new node();\\n            }\\n            p=p->next[word[i]-\\'a\\'];\\n        }\\n        p->is_end=true;\\n    }\\n    \\n    bool search(deque<char> &dq) {\\n        node* dummy=root;\\n        for(auto it=dq.rbegin(); it!=dq.rend(); it++){\\n            if(!dummy or !dummy->next[*it-\\'a\\']){ return false; }\\n            dummy=dummy->next[*it-\\'a\\'];\\n            if(dummy and dummy->is_end){ return true; }\\n        }\\n        return false;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    Trie *t=new Trie();\\n    string s=\"\";\\n    deque<char> dq;\\n    int mx=0;\\n    StreamChecker(vector<string>& words) {\\n        for(auto &w:words){\\n            mx=max(mx,(int)w.length());\\n            reverse(w.begin(),w.end());\\n            t->insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        dq.push_back(letter);\\n        if(dq.size()>mx){ dq.pop_front(); }\\n        return t->search(dq);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687241,
                "title": "a-very-different-trie-solution-that-is-o-len-words-beats-93-1-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUnlike the editorial solurion, I don\\'t reverse the strings.\\nInstead, for the query step, I store the list of non-leaf nodes in the trie that can continue search to find a match. Since the stream comes char by char, I only need to iterate over my chached candidates to see if the new char ends up with a matched word. Each search in a candidate is O(1) since there are only 26 English characters, the number of candidates is O(len(words)). My candidates are refreshed at each char.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUnlike the editorial solurion, I don\\'t reverse the strings.\\nInstead, for the query step, I store the list of non-leaf nodes in the trie that can continue search to find a match. Since the stream comes char by char, I only need to iterate over my chached candidates to see if the new char ends up with a matched word. Each search in a candidate is O(1) since there are only 26 English characters, the number of candidates is O(len(words)). My candidates are refreshed at each char.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor query: O(L) where L is the size of corpus, aka, len(words)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFor query: O(L) where L is the size of corpus, aka, len(words)\\n\\n# Code\\n```\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        # build a trie for the words\\n        self.trie_root = {}\\n        # a list of valid nodes that can continue from the previous search\\n        self.candidates = [] \\n\\n        # build the trie\\n        for w in words:\\n            cur = self.trie_root\\n            for c in w:\\n                if c in cur:\\n                    cur = cur[c]\\n                else:\\n                    cur[c] = {}\\n                    cur = cur[c]\\n            # mark end of word\\n            cur[\"#\"] = {}   \\n\\n    def query(self, letter: str) -> bool:\\n        new_candidates = []\\n        found_match = False\\n        # a new candidate\\n        if letter in self.trie_root:\\n            node = self.trie_root[letter]\\n            if \"#\" in node:\\n                found_match = True\\n                # it\\'s possible that the matched word is a prefix \\n                # of another word\\n                if len(node) > 1:\\n                    new_candidates.append(node)\\n            else:\\n                new_candidates.append(node)\\n\\n        # iterate over candidates to check if the candidates are still valid\\n        # or if it matches a word (can be both)\\n        for node in self.candidates:\\n            if letter in node:\\n                next_node = node[letter]\\n                if \"#\" in next_node:\\n                    found_match = True\\n                    if len(next_node) > 1:\\n                        new_candidates.append(next_node)\\n                else:\\n                    new_candidates.append(next_node)\\n        self.candidates = new_candidates\\n\\n        return found_match\\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        # build a trie for the words\\n        self.trie_root = {}\\n        # a list of valid nodes that can continue from the previous search\\n        self.candidates = [] \\n\\n        # build the trie\\n        for w in words:\\n            cur = self.trie_root\\n            for c in w:\\n                if c in cur:\\n                    cur = cur[c]\\n                else:\\n                    cur[c] = {}\\n                    cur = cur[c]\\n            # mark end of word\\n            cur[\"#\"] = {}   \\n\\n    def query(self, letter: str) -> bool:\\n        new_candidates = []\\n        found_match = False\\n        # a new candidate\\n        if letter in self.trie_root:\\n            node = self.trie_root[letter]\\n            if \"#\" in node:\\n                found_match = True\\n                # it\\'s possible that the matched word is a prefix \\n                # of another word\\n                if len(node) > 1:\\n                    new_candidates.append(node)\\n            else:\\n                new_candidates.append(node)\\n\\n        # iterate over candidates to check if the candidates are still valid\\n        # or if it matches a word (can be both)\\n        for node in self.candidates:\\n            if letter in node:\\n                next_node = node[letter]\\n                if \"#\" in next_node:\\n                    found_match = True\\n                    if len(next_node) > 1:\\n                        new_candidates.append(next_node)\\n                else:\\n                    new_candidates.append(next_node)\\n        self.candidates = new_candidates\\n\\n        return found_match\\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472804,
                "title": "easy-c-trie-solution",
                "content": "\\n\\n# Code\\n```\\nclass StreamChecker {\\npublic:\\n    struct Node{\\n        Node* links[26];\\n        bool flag=false;\\n        bool isContains(char ch)\\n        {\\n            return links[ch-\\'a\\']!=NULL;\\n        }\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        void setEnd()\\n        {\\n          flag=true;\\n        }\\n        bool isEnd()\\n        {\\n            return flag;\\n        }\\n    };\\n    class Trie\\n    {\\n        public:\\n        Node* root;\\n        Trie()\\n        {\\n           root=new Node();\\n        }\\n        void insert(string &str)\\n        {\\n         Node* node=root;\\n         for (int i=str.size()-1;i>=0;i--)\\n         {\\n             if (!node->isContains(str[i]))\\n             {\\n                 node->put(str[i],new Node());\\n             }\\n             node=node->get(str[i]);\\n         }\\n         node->setEnd();\\n        }\\n        bool check(string &str)\\n        {\\n            Node* node=root;\\n            for (int i=str.size()-1;i>=0;i--)\\n            {\\n              if (node->isContains(str[i]))\\n              {\\n                  node=node->get(str[i]);\\n                  if (node->isEnd()) return true;\\n              }\\n              else return false;\\n            }\\n            return false;\\n        }\\n    };\\n    Trie * trie;\\n    string str;\\n    StreamChecker(vector<string>& words) \\n    {\\n        trie=new Trie();\\n        for (int i=0;i<words.size();i++)\\n        {\\n            trie->insert(words[i]);\\n        }\\n        str=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        str+=letter;\\n        if(trie->check(str)) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct Node{\\n        Node* links[26];\\n        bool flag=false;\\n        bool isContains(char ch)\\n        {\\n            return links[ch-\\'a\\']!=NULL;\\n        }\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        void setEnd()\\n        {\\n          flag=true;\\n        }\\n        bool isEnd()\\n        {\\n            return flag;\\n        }\\n    };\\n    class Trie\\n    {\\n        public:\\n        Node* root;\\n        Trie()\\n        {\\n           root=new Node();\\n        }\\n        void insert(string &str)\\n        {\\n         Node* node=root;\\n         for (int i=str.size()-1;i>=0;i--)\\n         {\\n             if (!node->isContains(str[i]))\\n             {\\n                 node->put(str[i],new Node());\\n             }\\n             node=node->get(str[i]);\\n         }\\n         node->setEnd();\\n        }\\n        bool check(string &str)\\n        {\\n            Node* node=root;\\n            for (int i=str.size()-1;i>=0;i--)\\n            {\\n              if (node->isContains(str[i]))\\n              {\\n                  node=node->get(str[i]);\\n                  if (node->isEnd()) return true;\\n              }\\n              else return false;\\n            }\\n            return false;\\n        }\\n    };\\n    Trie * trie;\\n    string str;\\n    StreamChecker(vector<string>& words) \\n    {\\n        trie=new Trie();\\n        for (int i=0;i<words.size();i++)\\n        {\\n            trie->insert(words[i]);\\n        }\\n        str=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        str+=letter;\\n        if(trie->check(str)) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769013,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass StreamChecker {\\n    unordered_set<int> suffixHash, wordHash;\\n    string queryStream = \"\";\\n    int rollingHash(long& hash, long& p_pow, char c, int mod = 1e9+7) {\\n        p_pow = (p_pow * 31) % mod;\\n        return hash = (hash + (c-\\'a\\'+1) * p_pow) % mod;\\n    }\\npublic:    \\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            long hash = 0, p_pow = 1;\\n            for(int i = size(w)-1; ~i; i--) \\n                suffixHash.insert(rollingHash(hash, p_pow, w[i]));                         \\n            wordHash.insert(hash);                                                         \\n        }\\n    }\\n    bool query(char c) {\\n        queryStream += c;\\n        for(long i = size(queryStream)-1, hash = 0, p_pow = 1; ~i; i--)             \\n            if(!suffixHash.count(rollingHash(hash, p_pow, queryStream[i]))) return false;   \\n            else if(wordHash.count(hash)) return true;                                    \\n        \\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass StreamChecker {\\n    unordered_set<int> suffixHash, wordHash;\\n    string queryStream = \"\";\\n    int rollingHash(long& hash, long& p_pow, char c, int mod = 1e9+7) {\\n        p_pow = (p_pow * 31) % mod;\\n        return hash = (hash + (c-\\'a\\'+1) * p_pow) % mod;\\n    }\\npublic:    \\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            long hash = 0, p_pow = 1;\\n            for(int i = size(w)-1; ~i; i--) \\n                suffixHash.insert(rollingHash(hash, p_pow, w[i]));                         \\n            wordHash.insert(hash);                                                         \\n        }\\n    }\\n    bool query(char c) {\\n        queryStream += c;\\n        for(long i = size(queryStream)-1, hash = 0, p_pow = 1; ~i; i--)             \\n            if(!suffixHash.count(rollingHash(hash, p_pow, queryStream[i]))) return false;   \\n            else if(wordHash.count(hash)) return true;                                    \\n        \\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300247,
                "title": "java-easy-to-understand",
                "content": "```\\nclass StreamChecker \\n{\\n    class TrieNode\\n    {\\n        TrieNode child[]=new TrieNode[26];\\n        boolean end=false;\\n    }\\n    \\n    class Trie\\n    {\\n        TrieNode root;\\n        \\n        Trie()\\n        {\\n            root=new TrieNode();\\n        }\\n        \\n        public void insert(String s)\\n        {\\n            TrieNode temp=root;\\n            \\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(temp.child[s.charAt(i)-\\'a\\']==null)\\n                temp.child[s.charAt(i)-\\'a\\']=new TrieNode();\\n                \\n                temp=temp.child[s.charAt(i)-\\'a\\'];\\n            }\\n            \\n            temp.end=true;\\n        }\\n        \\n        public boolean search(String s)\\n        {\\n            TrieNode temp=root;\\n            \\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(temp.child[s.charAt(i)-\\'a\\']==null)\\n                return false;\\n                \\n                if(temp.child[s.charAt(i)-\\'a\\'].end)\\n                return true;\\n                \\n                temp=temp.child[s.charAt(i)-\\'a\\'];\\n            }\\n            \\n            return false;\\n        }\\n    }\\n    \\n    Trie obj;\\n    String check;\\n    \\n    public StreamChecker(String[] words) \\n    {\\n        obj=new Trie();\\n        check=\"\";\\n        \\n        for(int i=0;i<words.length;i++)\\n        {\\n            String s=reverse(words[i]);\\n            obj.insert(s);\\n        }\\n    }\\n    \\n    public String reverse(String s)\\n    {\\n        String ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        ans=s.charAt(i)+ans;\\n        \\n        return ans;\\n    }\\n    \\n    public boolean query(char letter) \\n    {\\n        check=letter+check;\\n        \\n        return obj.search(check);\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker \\n{\\n    class TrieNode\\n    {\\n        TrieNode child[]=new TrieNode[26];\\n        boolean end=false;\\n    }\\n    \\n    class Trie\\n    {\\n        TrieNode root;\\n        \\n        Trie()\\n        {\\n            root=new TrieNode();\\n        }\\n        \\n        public void insert(String s)\\n        {\\n            TrieNode temp=root;\\n            \\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(temp.child[s.charAt(i)-\\'a\\']==null)\\n                temp.child[s.charAt(i)-\\'a\\']=new TrieNode();\\n                \\n                temp=temp.child[s.charAt(i)-\\'a\\'];\\n            }\\n            \\n            temp.end=true;\\n        }\\n        \\n        public boolean search(String s)\\n        {\\n            TrieNode temp=root;\\n            \\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(temp.child[s.charAt(i)-\\'a\\']==null)\\n                return false;\\n                \\n                if(temp.child[s.charAt(i)-\\'a\\'].end)\\n                return true;\\n                \\n                temp=temp.child[s.charAt(i)-\\'a\\'];\\n            }\\n            \\n            return false;\\n        }\\n    }\\n    \\n    Trie obj;\\n    String check;\\n    \\n    public StreamChecker(String[] words) \\n    {\\n        obj=new Trie();\\n        check=\"\";\\n        \\n        for(int i=0;i<words.length;i++)\\n        {\\n            String s=reverse(words[i]);\\n            obj.insert(s);\\n        }\\n    }\\n    \\n    public String reverse(String s)\\n    {\\n        String ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        ans=s.charAt(i)+ans;\\n        \\n        return ans;\\n    }\\n    \\n    public boolean query(char letter) \\n    {\\n        check=letter+check;\\n        \\n        return obj.search(check);\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937623,
                "title": "c-trie-solution",
                "content": "Runtime: 326 ms, faster than 85.52% of C++ online submissions for Stream of Characters.\\nMemory Usage: 123.8 MB, less than 83.13% of C++ online submissions for Stream of Characters.\\n\\n```\\n1. Store words in Trie in reverse order\\n2. Calculate Max length among all words\\n3. Build up query string by appending letter at the back\\n4. Search query string in reverse order in Trie up to Max word length and query string length\\n```\\n\\n```\\nclass StreamChecker {\\npublic:\\n    \\n    struct TrieNode\\n    {\\n        TrieNode * child[26];\\n        bool word;\\n    };\\n    \\n    TrieNode * getNode()\\n    {\\n        TrieNode * node = new TrieNode();\\n        for(int i=0;i<26;i++)node->child[i]=NULL;\\n        node->word = false;\\n        \\n        return node;\\n    }\\n    \\n    // add words in reverse order in trie\\n    void addWord(TrieNode *root, string &str)\\n    {\\n        int sl = str.length();\\n        TrieNode * node = root;\\n        int index;\\n        for(int i=sl-1;i>=0;i--)\\n        {\\n            index = str[i]-\\'a\\';\\n            if(node->child[index]==NULL)\\n                node->child[index]=getNode();\\n            \\n            node = node->child[index];\\n        }\\n        \\n        node->word = true;\\n    }\\n    \\n    // search query string in reverse order in trie up to max length words or query string\\n    bool searchWord(TrieNode *root, string &str)\\n    {\\n        int sl = str.length();\\n        TrieNode * node = root;\\n        int index;\\n        for(int i=sl-1,j=0;i>=0 && j<maxWordLength;i--,j++)\\n        {\\n            index = str[i]-\\'a\\';\\n            if(node->child[index]==NULL)return false;\\n            \\n            node = node->child[index];\\n            if(node->word)return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    TrieNode *root;\\n    string qString;\\n    int maxWordLength = INT_MIN;\\n    \\n    StreamChecker(vector<string>& words) {\\n        \\n        // build up trie with given words\\n        root = getNode();\\n        for(string &word : words)\\n        {\\n            addWord(root,word);\\n            maxWordLength = max(maxWordLength,(int)word.length());\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        // append letter in query string and search\\n        qString.push_back(letter);\\n        return searchWord(root,qString);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\n1. Store words in Trie in reverse order\\n2. Calculate Max length among all words\\n3. Build up query string by appending letter at the back\\n4. Search query string in reverse order in Trie up to Max word length and query string length\\n```\n```\\nclass StreamChecker {\\npublic:\\n    \\n    struct TrieNode\\n    {\\n        TrieNode * child[26];\\n        bool word;\\n    };\\n    \\n    TrieNode * getNode()\\n    {\\n        TrieNode * node = new TrieNode();\\n        for(int i=0;i<26;i++)node->child[i]=NULL;\\n        node->word = false;\\n        \\n        return node;\\n    }\\n    \\n    // add words in reverse order in trie\\n    void addWord(TrieNode *root, string &str)\\n    {\\n        int sl = str.length();\\n        TrieNode * node = root;\\n        int index;\\n        for(int i=sl-1;i>=0;i--)\\n        {\\n            index = str[i]-\\'a\\';\\n            if(node->child[index]==NULL)\\n                node->child[index]=getNode();\\n            \\n            node = node->child[index];\\n        }\\n        \\n        node->word = true;\\n    }\\n    \\n    // search query string in reverse order in trie up to max length words or query string\\n    bool searchWord(TrieNode *root, string &str)\\n    {\\n        int sl = str.length();\\n        TrieNode * node = root;\\n        int index;\\n        for(int i=sl-1,j=0;i>=0 && j<maxWordLength;i--,j++)\\n        {\\n            index = str[i]-\\'a\\';\\n            if(node->child[index]==NULL)return false;\\n            \\n            node = node->child[index];\\n            if(node->word)return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    TrieNode *root;\\n    string qString;\\n    int maxWordLength = INT_MIN;\\n    \\n    StreamChecker(vector<string>& words) {\\n        \\n        // build up trie with given words\\n        root = getNode();\\n        for(string &word : words)\\n        {\\n            addWord(root,word);\\n            maxWordLength = max(maxWordLength,(int)word.length());\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        // append letter in query string and search\\n        qString.push_back(letter);\\n        return searchWord(root,qString);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732619,
                "title": "c-trie",
                "content": "```\\nclass TrieNode \\n{\\n    public:\\n    bool is_word;\\n    unordered_map<char, TrieNode*> children;\\n    TrieNode(): is_word(false)\\n    {}\\n};\\n\\nclass Trie\\n{\\n    public:\\n    TrieNode* root;\\n    Trie()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(string str)\\n    {\\n        TrieNode* current = root;\\n        for (int i = str.size() - 1; i > -1; i--)\\n        {\\n            if (current->children.find(str[i]) == current->children.end())\\n            {\\n                current->children[str[i]] = new TrieNode();\\n            }\\n            current = current->children[str[i]];\\n        }\\n        current->is_word = true;\\n    }\\n    bool find(string s)\\n    {\\n        TrieNode* current = root;\\n        for (auto c : s)\\n        {\\n            if (current->children.find(c) == current->children.end())\\n            {\\n                return false;\\n            }\\n            if (current->children[c]->is_word)\\n            {\\n                return true;\\n            }\\n            current = current->children[c];\\n        }\\n        return false;\\n    }\\n    \\n};\\nclass StreamChecker {\\npublic:\\n    \\n    string current;\\n    Trie* tree;\\n    int max_len;\\n    StreamChecker(vector<string>& words) {\\n        \\n        current = \"\";\\n        tree = new Trie();\\n        max_len = 0;\\n        for (auto w : words)\\n        {\\n            if (w.size() > max_len)\\n            {\\n                max_len = w.size();\\n            }\\n            tree->insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        current = letter + current;\\n        if (current.size() > max_len)\\n        {\\n            current = current.substr(0, max_len);\\n        }\\n        if (tree->find(current))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode \\n{\\n    public:\\n    bool is_word;\\n    unordered_map<char, TrieNode*> children;\\n    TrieNode(): is_word(false)\\n    {}\\n};\\n\\nclass Trie\\n{\\n    public:\\n    TrieNode* root;\\n    Trie()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(string str)\\n    {\\n        TrieNode* current = root;\\n        for (int i = str.size() - 1; i > -1; i--)\\n        {\\n            if (current->children.find(str[i]) == current->children.end())\\n            {\\n                current->children[str[i]] = new TrieNode();\\n            }\\n            current = current->children[str[i]];\\n        }\\n        current->is_word = true;\\n    }\\n    bool find(string s)\\n    {\\n        TrieNode* current = root;\\n        for (auto c : s)\\n        {\\n            if (current->children.find(c) == current->children.end())\\n            {\\n                return false;\\n            }\\n            if (current->children[c]->is_word)\\n            {\\n                return true;\\n            }\\n            current = current->children[c];\\n        }\\n        return false;\\n    }\\n    \\n};\\nclass StreamChecker {\\npublic:\\n    \\n    string current;\\n    Trie* tree;\\n    int max_len;\\n    StreamChecker(vector<string>& words) {\\n        \\n        current = \"\";\\n        tree = new Trie();\\n        max_len = 0;\\n        for (auto w : words)\\n        {\\n            if (w.size() > max_len)\\n            {\\n                max_len = w.size();\\n            }\\n            tree->insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        current = letter + current;\\n        if (current.size() > max_len)\\n        {\\n            current = current.substr(0, max_len);\\n        }\\n        if (tree->find(current))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619737,
                "title": "suffix-tree-trie-easy-to-understand",
                "content": "We will keep list of words in suffix tree structure for quick search.\\n\\n```\\nfrom typing import List, Set\\n\\n\\nclass TreeNode:\\n    def __init__(self, value: str = \\'Start\\'):\\n        self.value: str = value\\n        self.children: Set[TreeNode] = set()\\n        self.is_leaf = False\\n\\n    def create_child(self, child_value: str):\\n        \"\"\"Create child with value child_value for this node and return child\\n        node. If child with child_value already exists, return him.\"\"\"\\n        existing_child: TreeNode = self.get_child(child_value)\\n        if existing_child:\\n            return existing_child\\n        new_child: TreeNode = TreeNode(child_value)\\n        self.children.add(new_child)\\n        return new_child\\n\\n    def get_child(self, value: str):\\n        \"\"\"Return child of this node if exists, else return None.\"\"\"\\n        for x in self.children:\\n            if x.value == value:\\n                return x\\n        return None\\n\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.chars = \\'\\'\\n        self.root = TreeNode()\\n        \"\"\"Root of suffix tree for words.\"\"\"\\n\\n        for word in words:\\n            c_node = self.root\\n            for x in word[::-1]:\\n                c_node = c_node.create_child(x)\\n            c_node.is_leaf = True\\n\\n    def query(self, letter: str):\\n        self.chars += letter\\n        c_node = self.root\\n        for char in self.chars[::-1]:\\n            c_node = c_node.get_child(char)\\n            if not c_node:\\n                return False\\n            if c_node.is_leaf:\\n                return True\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List, Set\\n\\n\\nclass TreeNode:\\n    def __init__(self, value: str = \\'Start\\'):\\n        self.value: str = value\\n        self.children: Set[TreeNode] = set()\\n        self.is_leaf = False\\n\\n    def create_child(self, child_value: str):\\n        \"\"\"Create child with value child_value for this node and return child\\n        node. If child with child_value already exists, return him.\"\"\"\\n        existing_child: TreeNode = self.get_child(child_value)\\n        if existing_child:\\n            return existing_child\\n        new_child: TreeNode = TreeNode(child_value)\\n        self.children.add(new_child)\\n        return new_child\\n\\n    def get_child(self, value: str):\\n        \"\"\"Return child of this node if exists, else return None.\"\"\"\\n        for x in self.children:\\n            if x.value == value:\\n                return x\\n        return None\\n\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.chars = \\'\\'\\n        self.root = TreeNode()\\n        \"\"\"Root of suffix tree for words.\"\"\"\\n\\n        for word in words:\\n            c_node = self.root\\n            for x in word[::-1]:\\n                c_node = c_node.create_child(x)\\n            c_node.is_leaf = True\\n\\n    def query(self, letter: str):\\n        self.chars += letter\\n        c_node = self.root\\n        for char in self.chars[::-1]:\\n            c_node = c_node.get_child(char)\\n            if not c_node:\\n                return False\\n            if c_node.is_leaf:\\n                return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612561,
                "title": "python-trie-explained-clean-and-easy-to-understand",
                "content": "```\\n\\nclass StreamChecker(object):\\n    def __init__(self, words):\\n        # By reversing every word in the dictionary, the problem of suffix matching is transformed into prefix matching.\\n        self.trie, self.prefix = collections.defaultdict(collections.defaultdict), []\\n        for word in words:\\n            node = self.trie\\n            for c in word[::-1]:\\n                if c in node:\\n                    node = node[c]\\n                else:\\n                    node[c] = collections.defaultdict()\\n                    node = node[c]\\n            node[\\'$\\'] = None\\n\\n    def query(self, letter):\\n        self.prefix.insert(0, letter)  # Invert the character stream prefix, and then use the trie tree to match.\\n        node = self.trie\\n        for c in self.prefix:\\n            if c in node:\\n                node = node[c]\\n            else:\\n                return False\\n            if \\'$\\' in node:\\n                return True\\n        return False\\n```\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\n\\nclass StreamChecker(object):\\n    def __init__(self, words):\\n        # By reversing every word in the dictionary, the problem of suffix matching is transformed into prefix matching.\\n        self.trie, self.prefix = collections.defaultdict(collections.defaultdict), []\\n        for word in words:\\n            node = self.trie\\n            for c in word[::-1]:\\n                if c in node:\\n                    node = node[c]\\n                else:\\n                    node[c] = collections.defaultdict()\\n                    node = node[c]\\n            node[\\'$\\'] = None\\n\\n    def query(self, letter):\\n        self.prefix.insert(0, letter)  # Invert the character stream prefix, and then use the trie tree to match.\\n        node = self.trie\\n        for c in self.prefix:\\n            if c in node:\\n                node = node[c]\\n            else:\\n                return False\\n            if \\'$\\' in node:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611973,
                "title": "python3-trie",
                "content": "I\\'m using Trie and do not store the whole stream in the memory as in the solution.\\n\\nRuntime: 8976 ms, faster than **5.14%** of Python3 online submissions for Stream of Characters.\\nMemory Usage: 38 MB, less than **86.38%** of Python3 online submissions for Stream of Characters.\\n\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = dict()\\n        self.cur = []\\n        \\n        for w in words:\\n            t = self.root\\n            \\n            for l in w:\\n                if not l in t:\\n                    t[l] = dict()\\n                    \\n                t = t[l]\\n            \\n            t[\"_\"] = True\\n            \\n    def query(self, l: str) -> bool:\\n        self.cur.append(self.root)\\n        \\n        res = False\\n        rem = []\\n        for i, c in enumerate(self.cur):\\n            if l in c:\\n                self.cur[i] = self.cur[i][l]\\n                \\n                if \"_\" in self.cur[i]:\\n                    if len(self.cur[i].keys()) == 1:\\n                        rem.append(i)\\n                    \\n                    res = True\\n            else:\\n                rem.append(i)\\n\\n        for i in reversed(rem):\\n            del self.cur[i]\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = dict()\\n        self.cur = []\\n        \\n        for w in words:\\n            t = self.root\\n            \\n            for l in w:\\n                if not l in t:\\n                    t[l] = dict()\\n                    \\n                t = t[l]\\n            \\n            t[\"_\"] = True\\n            \\n    def query(self, l: str) -> bool:\\n        self.cur.append(self.root)\\n        \\n        res = False\\n        rem = []\\n        for i, c in enumerate(self.cur):\\n            if l in c:\\n                self.cur[i] = self.cur[i][l]\\n                \\n                if \"_\" in self.cur[i]:\\n                    if len(self.cur[i].keys()) == 1:\\n                        rem.append(i)\\n                    \\n                    res = True\\n            else:\\n                rem.append(i)\\n\\n        for i in reversed(rem):\\n            del self.cur[i]\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611814,
                "title": "java-solution-with-recursion-and-trie",
                "content": "Solution with entering every word in Reverse order in the Trie and then checking them if isWord or not.\\n\\nclass StreamChecker {\\n\\n    class TrieNode\\n    {\\n        Map<Character,TrieNode> child;\\n        boolean isWord;\\n            \\n        TrieNode()\\n        {\\n            child=new HashMap<>();\\n            isWord=false;\\n        }\\n    }\\n    \\n    TrieNode root;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root=new TrieNode();\\n        sb=new StringBuilder(\"\");\\n        \\n        TrieNode current=root;\\n        \\n        for(String s:words)\\n        {\\n            add(current,s,s.length()-1);\\n        }\\n    }\\n    \\n    public void add(TrieNode current,String s,int index)\\n    {\\n           if(index<0)\\n           {\\n               current.isWord=true;\\n               return;\\n           }\\n        \\n           if(current.child.containsKey(s.charAt(index)))\\n           {\\n               current=current.child.get(s.charAt(index));\\n               add(current,s,index-1);\\n           }else\\n           {\\n             TrieNode node=new TrieNode();\\n             current.child.put(s.charAt(index),node);\\n             current=current.child.get(s.charAt(index));\\n             add(current,s,index-1);\\n           }\\n    }\\n\\n    public boolean isWord(TrieNode current,StringBuilder s, int i)\\n    {\\n        if(i<0)\\n        {\\n            return false;\\n        }\\n        \\n        char ch=sb.charAt(i);\\n        if(current.child.containsKey(ch))\\n        {\\n            TrieNode n=current.child.get(ch);\\n            if(n.isWord)\\n            {\\n                return true;\\n            }else\\n            {\\n                current=current.child.get(ch);\\n                return isWord(current,s,i-1);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean query(char letter) {\\n        TrieNode current=root;\\n        sb.append(letter);\\n        \\n        boolean found=isWord(current,sb,sb.length()-1);\\n        \\n        return found;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */",
                "solutionTags": [
                    "Trie",
                    "Recursion"
                ],
                "code": "Solution with entering every word in Reverse order in the Trie and then checking them if isWord or not.\\n\\nclass StreamChecker {\\n\\n    class TrieNode\\n    {\\n        Map<Character,TrieNode> child;\\n        boolean isWord;\\n            \\n        TrieNode()\\n        {\\n            child=new HashMap<>();\\n            isWord=false;\\n        }\\n    }\\n    \\n    TrieNode root;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root=new TrieNode();\\n        sb=new StringBuilder(\"\");\\n        \\n        TrieNode current=root;\\n        \\n        for(String s:words)\\n        {\\n            add(current,s,s.length()-1);\\n        }\\n    }\\n    \\n    public void add(TrieNode current,String s,int index)\\n    {\\n           if(index<0)\\n           {\\n               current.isWord=true;\\n               return;\\n           }\\n        \\n           if(current.child.containsKey(s.charAt(index)))\\n           {\\n               current=current.child.get(s.charAt(index));\\n               add(current,s,index-1);\\n           }else\\n           {\\n             TrieNode node=new TrieNode();\\n             current.child.put(s.charAt(index),node);\\n             current=current.child.get(s.charAt(index));\\n             add(current,s,index-1);\\n           }\\n    }\\n\\n    public boolean isWord(TrieNode current,StringBuilder s, int i)\\n    {\\n        if(i<0)\\n        {\\n            return false;\\n        }\\n        \\n        char ch=sb.charAt(i);\\n        if(current.child.containsKey(ch))\\n        {\\n            TrieNode n=current.child.get(ch);\\n            if(n.isWord)\\n            {\\n                return true;\\n            }else\\n            {\\n                current=current.child.get(ch);\\n                return isWord(current,s,i-1);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean query(char letter) {\\n        TrieNode current=root;\\n        sb.append(letter);\\n        \\n        boolean found=isWord(current,sb,sb.length()-1);\\n        \\n        return found;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1611432,
                "title": "typescript-streaming-solution-with-trie-and-set",
                "content": "The LC provided solution holds onto the stream in memory, which is not how you\\'d process streams in real word scenarios for better scale. This solution doesn\\'t build the reversed-trie, hence a bit slower (33% fast, 100% better on memory), but still a good solution worth considering.\\n\\n```\\nclass StreamChecker {\\n  #trie: {[key: string]: boolean | Object} = {};\\n  #pending = new Set();\\n\\n  constructor(words: string[]) {\\n    for (const word of words) this._addWord(word);\\n  }\\n\\n  _addWord(word: string): void {\\n    if (!word.length) return;\\n    let ptr: null | boolean | {[key: string]: boolean | Object} = this.#trie;\\n    for (const char of word) {\\n      if (!ptr[char]) ptr[char] = {};\\n      ptr = ptr[char];\\n    }\\n    ptr[\\'_\\'] = true;\\n  }\\n\\n  query(letter: string): boolean {\\n    // Validate each pending first.\\n    let ret = false;\\n    const newPending = new Set();\\n    for (const ptr of this.#pending) {\\n      const newPtr = ptr[letter];\\n      if (!newPtr) continue;\\n      if (newPtr[\\'_\\']) ret = true;\\n      newPending.add(newPtr);\\n    }\\n    this.#pending = newPending;\\n\\n    // Check for words that start with this letter.\\n    if (this.#trie[letter]) {\\n      this.#pending.add(this.#trie[letter]);\\n\\n      // Single character word corner-case?\\n      if (this.#trie[letter][\\'_\\']) ret = true;\\n    }\\n    \\n    return ret;\\n  }\\n}\\n\\n/**\\n* Your StreamChecker object will be instantiated and called as such:\\n* var obj = new StreamChecker(words)\\n* var param_1 = obj.query(letter)\\n*/\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n  #trie: {[key: string]: boolean | Object} = {};\\n  #pending = new Set();\\n\\n  constructor(words: string[]) {\\n    for (const word of words) this._addWord(word);\\n  }\\n\\n  _addWord(word: string): void {\\n    if (!word.length) return;\\n    let ptr: null | boolean | {[key: string]: boolean | Object} = this.#trie;\\n    for (const char of word) {\\n      if (!ptr[char]) ptr[char] = {};\\n      ptr = ptr[char];\\n    }\\n    ptr[\\'_\\'] = true;\\n  }\\n\\n  query(letter: string): boolean {\\n    // Validate each pending first.\\n    let ret = false;\\n    const newPending = new Set();\\n    for (const ptr of this.#pending) {\\n      const newPtr = ptr[letter];\\n      if (!newPtr) continue;\\n      if (newPtr[\\'_\\']) ret = true;\\n      newPending.add(newPtr);\\n    }\\n    this.#pending = newPending;\\n\\n    // Check for words that start with this letter.\\n    if (this.#trie[letter]) {\\n      this.#pending.add(this.#trie[letter]);\\n\\n      // Single character word corner-case?\\n      if (this.#trie[letter][\\'_\\']) ret = true;\\n    }\\n    \\n    return ret;\\n  }\\n}\\n\\n/**\\n* Your StreamChecker object will be instantiated and called as such:\\n* var obj = new StreamChecker(words)\\n* var param_1 = obj.query(letter)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611223,
                "title": "c-build-trie-with-o-m-n-m-words-i-length-n-the-number-of-queries",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    struct node{\\n        unordered_map<char,node*> m;\\n        bool end;\\n        node(){\\n            end=false;\\n        };\\n    };\\n    void buildTrie(string& s){\\n        node* p=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(p->m.count(s[i])==0){\\n                p->m[s[i]]=new node();\\n            }\\n            p=p->m[s[i]];\\n        }\\n        p->end=true;\\n    }\\n    bool checkTrie(){\\n        node* p=root;\\n        for(int i=t.size()-1;i>=0;i--){\\n            if(p->m.count(t[i])==0){\\n                return false;\\n            }\\n            p=p->m[t[i]];\\n            \\n            if(p->end==true){\\n                return true;\\n            }\\n        }\\n        return p->end==true;\\n    }\\n    node* root;\\n    StreamChecker(vector<string>& words) {\\n        /*\\n        dc\\n        f\\n        lk\\n        dcba\\n        build Trie\\n        */\\n        root=new node();\\n        for(auto& w:words){\\n            buildTrie(w);\\n        }\\n    }\\n    string t;\\n    bool query(char letter) {\\n        t+=letter;\\n        return checkTrie();\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct node{\\n        unordered_map<char,node*> m;\\n        bool end;\\n        node(){\\n            end=false;\\n        };\\n    };\\n    void buildTrie(string& s){\\n        node* p=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(p->m.count(s[i])==0){\\n                p->m[s[i]]=new node();\\n            }\\n            p=p->m[s[i]];\\n        }\\n        p->end=true;\\n    }\\n    bool checkTrie(){\\n        node* p=root;\\n        for(int i=t.size()-1;i>=0;i--){\\n            if(p->m.count(t[i])==0){\\n                return false;\\n            }\\n            p=p->m[t[i]];\\n            \\n            if(p->end==true){\\n                return true;\\n            }\\n        }\\n        return p->end==true;\\n    }\\n    node* root;\\n    StreamChecker(vector<string>& words) {\\n        /*\\n        dc\\n        f\\n        lk\\n        dcba\\n        build Trie\\n        */\\n        root=new node();\\n        for(auto& w:words){\\n            buildTrie(w);\\n        }\\n    }\\n    string t;\\n    bool query(char letter) {\\n        t+=letter;\\n        return checkTrie();\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611094,
                "title": "java-solution-tle-on-last-case-need-help",
                "content": "**Guys pls help me.** I describe my approach for ur better underatanding...   \\n**Approach:**  \\n\\nin construtor: \\nStore the words in a hashmap, \"key = words[i], value: 0(not necessary)\" and store words length in a treemap, \"key = words[i].length, value: 0(not necessary)\". \\n\\nIn qyery :\\n\\ttraverse the treemap \\n\\t\\t\\tget the substring of that length from end.\\n\\t\\t\\tcheck in hashmap if there is any key present. if present return true.\\n\\tafter traverse if there is no such suffix return False.\\n\\n```\\nclass StreamChecker {\\n\\tHashMap <String, Integer> hashmap = new HashMap<> ();\\n\\tTreeMap <Integer, Integer> treemap = new TreeMap<> ();\\n\\n\\tString stream = \"\";\\n\\n\\tint maxLen, minLen;\\n\\tpublic StreamChecker(String[] words) {\\n\\t\\tfor(String S: words) {\\n\\t\\t\\ttreemap.put(S.length(), 0);\\n\\t\\t\\thashmap.put(S, S.length());\\n\\t\\t}\\n\\n\\t\\tmaxLen = treemap.lastKey();\\n\\t\\tminLen = treemap.firstKey();\\n\\t}\\n\\n\\tpublic boolean query(char letter) {\\n\\t\\tstream += String.valueOf(letter);\\n\\n\\t\\tif(stream.length() < minLen) return false;\\n\\n\\t\\tif(stream.length() > maxLen) stream = stream.substring(1);\\n    \\t// System.out.println(\"stream: \"+stream+\"\\\\tletter: \"+letter);\\n\\n\\t\\tfor(Map.Entry len : treemap.entrySet()) {\\n\\t\\t\\tint loc = stream.length() - (int)len.getKey();\\n\\t\\t\\tif(loc >= 0) {\\n\\t\\t\\t\\tString temp = stream.substring(loc);\\n\\n\\t\\t\\t\\tif(hashmap.containsKey(temp)) return true;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StreamChecker {\\n\\tHashMap <String, Integer> hashmap = new HashMap<> ();\\n\\tTreeMap <Integer, Integer> treemap = new TreeMap<> ();\\n\\n\\tString stream = \"\";\\n\\n\\tint maxLen, minLen;\\n\\tpublic StreamChecker(String[] words) {\\n\\t\\tfor(String S: words) {\\n\\t\\t\\ttreemap.put(S.length(), 0);\\n\\t\\t\\thashmap.put(S, S.length());\\n\\t\\t}\\n\\n\\t\\tmaxLen = treemap.lastKey();\\n\\t\\tminLen = treemap.firstKey();\\n\\t}\\n\\n\\tpublic boolean query(char letter) {\\n\\t\\tstream += String.valueOf(letter);\\n\\n\\t\\tif(stream.length() < minLen) return false;\\n\\n\\t\\tif(stream.length() > maxLen) stream = stream.substring(1);\\n    \\t// System.out.println(\"stream: \"+stream+\"\\\\tletter: \"+letter);\\n\\n\\t\\tfor(Map.Entry len : treemap.entrySet()) {\\n\\t\\t\\tint loc = stream.length() - (int)len.getKey();\\n\\t\\t\\tif(loc >= 0) {\\n\\t\\t\\t\\tString temp = stream.substring(loc);\\n\\n\\t\\t\\t\\tif(hashmap.containsKey(temp)) return true;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611052,
                "title": "simple-python-trie-solution",
                "content": "```python\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n\\t\"\"\"\\n\\tIn our init state, we create a trie.\\n\\tSomething like this:\\n\\t[\"tr\", \"tre\", \"q\"] => {t: {r: {\"END\": True, e: {\"END\": True}}}, q: {\"END\": True}}\\n\\t\"\"\"\\n        self.trie = {}\\n        for word in words:\\n            curr = self.trie\\n            for char in word:\\n                curr = curr.setdefault(char, {})\\n            curr[\"END\"] = True\\n        self.pointer_array = []\\n\\n    def query(self, letter: str) -> bool:\\n\\t\\t\"\"\"\\n\\t\\tNext, we just start a pointter at every new letter, venturing deeper into our trie!\\n\\t\\t\"\"\"\\n        found = False\\n        for i, p in enumerate(self.pointer_array):\\n            if letter in p:\\n                self.pointer_array[i] = p[letter]\\n                if p[letter].get(\"END\"):\\n                    found = True\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\"\"\"If we cannot venture deeper, remove this pointer\"\"\"\\n                    if len(p[letter]) == 1:\\n                        self.pointer_array[i] = None\\n            else:\\n\\t\\t\\t\\t\"\"\"If we break the suffix streak, remove this pointer\"\"\"\\n                self.pointer_array[i] = None\\n        if letter in self.trie:\\n            self.pointer_array.append(self.trie[letter])\\n            if self.trie[letter].get(\"END\"):\\n                found = True\\n                if len(self.trie[letter]) == 1:\\n                    self.pointer_array.pop()\\n\\t\\t\"\"\"Remove Nones.\"\"\"\\n        self.pointer_array = [p for p in self.pointer_array if p]\\n        return found\\n```\\n\\nIf you have any questions, please ask!! :)",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```python\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n\\t\"\"\"\\n\\tIn our init state, we create a trie.\\n\\tSomething like this:\\n\\t[\"tr\", \"tre\", \"q\"] => {t: {r: {\"END\": True, e: {\"END\": True}}}, q: {\"END\": True}}\\n\\t\"\"\"\\n        self.trie = {}\\n        for word in words:\\n            curr = self.trie\\n            for char in word:\\n                curr = curr.setdefault(char, {})\\n            curr[\"END\"] = True\\n        self.pointer_array = []\\n\\n    def query(self, letter: str) -> bool:\\n\\t\\t\"\"\"\\n\\t\\tNext, we just start a pointter at every new letter, venturing deeper into our trie!\\n\\t\\t\"\"\"\\n        found = False\\n        for i, p in enumerate(self.pointer_array):\\n            if letter in p:\\n                self.pointer_array[i] = p[letter]\\n                if p[letter].get(\"END\"):\\n                    found = True\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\"\"\"If we cannot venture deeper, remove this pointer\"\"\"\\n                    if len(p[letter]) == 1:\\n                        self.pointer_array[i] = None\\n            else:\\n\\t\\t\\t\\t\"\"\"If we break the suffix streak, remove this pointer\"\"\"\\n                self.pointer_array[i] = None\\n        if letter in self.trie:\\n            self.pointer_array.append(self.trie[letter])\\n            if self.trie[letter].get(\"END\"):\\n                found = True\\n                if len(self.trie[letter]) == 1:\\n                    self.pointer_array.pop()\\n\\t\\t\"\"\"Remove Nones.\"\"\"\\n        self.pointer_array = [p for p in self.pointer_array if p]\\n        return found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610774,
                "title": "c-using-trie-o-height-of-trie-time",
                "content": "```\\n#define pb push_back\\nclass Trie{  //Trie class\\npublic:\\n    bool is_word=false;\\n    Trie* children[26]={NULL};\\n};\\nclass StreamChecker {\\nprivate:\\n    Trie* root=NULL;\\n    vector<char>input_stream;\\n    \\n    void insert(string &word) {  //insert function\\n        Trie* cur = root;\\n        for(int i=word.size()-1;i>=0;i--){\\n            int k = word[i] - \\'a\\';\\n            if(cur->children[k]==NULL)\\n                cur->children[k]=new Trie;\\n            cur=cur->children[k];\\n        }\\n        cur->is_word=true;\\n    }\\n    \\n    bool find(){  //find function\\n        Trie* cur = root;\\n        for(int i=input_stream.size()-1;i>=0;i--){\\n            int k = input_stream[i] - \\'a\\';\\n            cur = cur->children[k];   \\n            if (cur == NULL)\\n                return false;\\n            if(cur->is_word)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root=new Trie;\\n        for(auto i:words)\\n            insert(i);\\n    }\\n    \\n    bool query(char letter) {\\n        input_stream.pb(letter);\\n        return find();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n#define pb push_back\\nclass Trie{  //Trie class\\npublic:\\n    bool is_word=false;\\n    Trie* children[26]={NULL};\\n};\\nclass StreamChecker {\\nprivate:\\n    Trie* root=NULL;\\n    vector<char>input_stream;\\n    \\n    void insert(string &word) {  //insert function\\n        Trie* cur = root;\\n        for(int i=word.size()-1;i>=0;i--){\\n            int k = word[i] - \\'a\\';\\n            if(cur->children[k]==NULL)\\n                cur->children[k]=new Trie;\\n            cur=cur->children[k];\\n        }\\n        cur->is_word=true;\\n    }\\n    \\n    bool find(){  //find function\\n        Trie* cur = root;\\n        for(int i=input_stream.size()-1;i>=0;i--){\\n            int k = input_stream[i] - \\'a\\';\\n            cur = cur->children[k];   \\n            if (cur == NULL)\\n                return false;\\n            if(cur->is_word)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root=new Trie;\\n        for(auto i:words)\\n            insert(i);\\n    }\\n    \\n    bool query(char letter) {\\n        input_stream.pb(letter);\\n        return find();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610755,
                "title": "very-clean-and-easy-to-understand-trie-c",
                "content": "```\\nclass Node{\\n    vector<Node*> links;\\n    bool flag;\\n    public:\\n    Node(){\\n        links.resize(26);\\n        flag=false;\\n    }\\n    bool contains(char c){\\n        return not (links[c-\\'a\\']==NULL);\\n    }\\n    void put(char c){\\n        links[c-\\'a\\']=new Node();\\n    }\\n    Node* get(char c){\\n        return links[c-\\'a\\'];\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n    bool End(){\\n        return flag;\\n    }\\n};\\nclass trie{\\n    Node* root;\\n    public:\\n    trie(){\\n        root=new Node();\\n    }\\n    void insert(string& s){\\n        Node* node=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(not node->contains(s[i])){\\n                node->put(s[i]);\\n            }\\n            node=node->get(s[i]);\\n        }\\n        node->setEnd();\\n    }\\n    bool check(string &s){\\n        Node* node=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(not node->contains(s[i])){\\n                return false;\\n            }\\n            node=node->get(s[i]);\\n            if(node->End())\\n                return true;\\n        }\\n        return node->End();\\n    }\\n};\\nclass StreamChecker {\\n    trie* root;\\n    string temp;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root=new trie();\\n        for(auto &s:words){\\n            root->insert(s);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        temp+=letter;\\n        return root->check(temp);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\n    vector<Node*> links;\\n    bool flag;\\n    public:\\n    Node(){\\n        links.resize(26);\\n        flag=false;\\n    }\\n    bool contains(char c){\\n        return not (links[c-\\'a\\']==NULL);\\n    }\\n    void put(char c){\\n        links[c-\\'a\\']=new Node();\\n    }\\n    Node* get(char c){\\n        return links[c-\\'a\\'];\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n    bool End(){\\n        return flag;\\n    }\\n};\\nclass trie{\\n    Node* root;\\n    public:\\n    trie(){\\n        root=new Node();\\n    }\\n    void insert(string& s){\\n        Node* node=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(not node->contains(s[i])){\\n                node->put(s[i]);\\n            }\\n            node=node->get(s[i]);\\n        }\\n        node->setEnd();\\n    }\\n    bool check(string &s){\\n        Node* node=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(not node->contains(s[i])){\\n                return false;\\n            }\\n            node=node->get(s[i]);\\n            if(node->End())\\n                return true;\\n        }\\n        return node->End();\\n    }\\n};\\nclass StreamChecker {\\n    trie* root;\\n    string temp;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root=new trie();\\n        for(auto &s:words){\\n            root->insert(s);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        temp+=letter;\\n        return root->check(temp);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610712,
                "title": "stream-of-characters-c-no-trie",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    string s;\\n    vector<string> v;\\n    unordered_map<char, vector<int>> m;\\n    \\n    StreamChecker(vector<string>& words) {\\n        v=words;\\n        for(int i=0;i<words.size();i++) m[words[i].back()].push_back(i);\\n    }\\n    \\n    bool query(char letter) {\\n        s+=letter;\\n        for(auto& i:m[letter]){\\n            bool is=true;\\n            for(int j=v[i].size()-1, k=s.size()-1;j>=0;j--, k--) {\\n                if(k<0 || v[i][j]!=s[k]){\\n                    is=false;\\n                    break;\\n                }\\n            }\\n            if(is) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    string s;\\n    vector<string> v;\\n    unordered_map<char, vector<int>> m;\\n    \\n    StreamChecker(vector<string>& words) {\\n        v=words;\\n        for(int i=0;i<words.size();i++) m[words[i].back()].push_back(i);\\n    }\\n    \\n    bool query(char letter) {\\n        s+=letter;\\n        for(auto& i:m[letter]){\\n            bool is=true;\\n            for(int j=v[i].size()-1, k=s.size()-1;j>=0;j--, k--) {\\n                if(k<0 || v[i][j]!=s[k]){\\n                    is=false;\\n                    break;\\n                }\\n            }\\n            if(is) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610603,
                "title": "c-trie-sol-99-9",
                "content": "```\\nclass StreamChecker {\\n  string str=\"\";\\npublic:\\n  \\n  struct TrieNode{\\n    TrieNode* children[26];\\n    int ew;\\n    \\n  };\\n  \\n  struct TrieNode* getNode(){\\n    struct TrieNode* nNode=new TrieNode();\\n    for(int i=0;i<26;i++){\\n      nNode->children[i]=NULL;\\n    }\\n    \\n    nNode->ew=0;\\n    return nNode;\\n  }\\n  \\n  TrieNode* root;\\n  \\n    StreamChecker(vector<string>& words) {\\n      root=getNode();\\n      for(int i=0;i<words.size();i++)\\n      {\\n        insert(words[i]);\\n      }\\n    }\\n  \\n  void  insert(string str){\\n    TrieNode* temp=root;\\n    int l=str.length();\\n    for(int i=l-1;i>=0;i--){\\n      int index=str[i]-\\'a\\';\\n      if(temp->children[index]==NULL){\\n        temp->children[index]=getNode();\\n      }\\n      temp=temp->children[index];\\n    }\\n    temp->ew+=1;\\n  }\\n    \\n    bool query(char c) {\\n      str.push_back(c);\\n      return CheckSuffix();\\n    }\\n\\n  \\n    bool CheckSuffix(){\\n      TrieNode* temp=root;\\n      int l=str.length();\\n      for(int i=l-1;i>=0;i--){\\n        int index=str[i]-\\'a\\';\\n        if(temp->children[index]==NULL)\\n          return false;\\n    \\n\\t  if(temp->ew>=1)\\n\\t  return true;\\n\\t  \\n        temp=temp->children[index];\\n        if(temp->ew>=1)\\n          return true;\\n      }\\n     \\n      return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n  string str=\"\";\\npublic:\\n  \\n  struct TrieNode{\\n    TrieNode* children[26];\\n    int ew;\\n    \\n  };\\n  \\n  struct TrieNode* getNode(){\\n    struct TrieNode* nNode=new TrieNode();\\n    for(int i=0;i<26;i++){\\n      nNode->children[i]=NULL;\\n    }\\n    \\n    nNode->ew=0;\\n    return nNode;\\n  }\\n  \\n  TrieNode* root;\\n  \\n    StreamChecker(vector<string>& words) {\\n      root=getNode();\\n      for(int i=0;i<words.size();i++)\\n      {\\n        insert(words[i]);\\n      }\\n    }\\n  \\n  void  insert(string str){\\n    TrieNode* temp=root;\\n    int l=str.length();\\n    for(int i=l-1;i>=0;i--){\\n      int index=str[i]-\\'a\\';\\n      if(temp->children[index]==NULL){\\n        temp->children[index]=getNode();\\n      }\\n      temp=temp->children[index];\\n    }\\n    temp->ew+=1;\\n  }\\n    \\n    bool query(char c) {\\n      str.push_back(c);\\n      return CheckSuffix();\\n    }\\n\\n  \\n    bool CheckSuffix(){\\n      TrieNode* temp=root;\\n      int l=str.length();\\n      for(int i=l-1;i>=0;i--){\\n        int index=str[i]-\\'a\\';\\n        if(temp->children[index]==NULL)\\n          return false;\\n    \\n\\t  if(temp->ew>=1)\\n\\t  return true;\\n\\t  \\n        temp=temp->children[index];\\n        if(temp->ew>=1)\\n          return true;\\n      }\\n     \\n      return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610590,
                "title": "java-trie-based-simple-solution",
                "content": "```\\nclass StreamChecker {\\n    \\n    //inner trie class\\n    class Trie{\\n        Trie[] tries;\\n        boolean isEnding;\\n         public Trie(){\\n             tries = new Trie[26];\\n             isEnding = false;\\n         }\\n    }\\n    \\n    StringBuilder sb;\\n    Trie parent;\\n    public StreamChecker(String[] words) {\\n        sb = new StringBuilder();\\n        parent = new Trie();\\n        for(String s : words){\\n            Trie root = parent;\\n            for(int i = s.length()-1; i >= 0; i--){\\n                if(root.tries[s.charAt(i)-\\'a\\'] == null){\\n                    root.tries[s.charAt(i)-\\'a\\'] = new Trie();\\n                }\\n                root = root.tries[s.charAt(i)-\\'a\\'];\\n            }\\n            root.isEnding = true;\\n        }\\n        \\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Trie root = parent;\\n        for(int i = sb.length()-1; i >= 0; i--){\\n            if(root.tries[sb.charAt(i)-\\'a\\'] == null) return false;\\n            if(root.tries[sb.charAt(i)-\\'a\\'].isEnding) return true;\\n            root = root.tries[sb.charAt(i)-\\'a\\'];\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n    \\n    //inner trie class\\n    class Trie{\\n        Trie[] tries;\\n        boolean isEnding;\\n         public Trie(){\\n             tries = new Trie[26];\\n             isEnding = false;\\n         }\\n    }\\n    \\n    StringBuilder sb;\\n    Trie parent;\\n    public StreamChecker(String[] words) {\\n        sb = new StringBuilder();\\n        parent = new Trie();\\n        for(String s : words){\\n            Trie root = parent;\\n            for(int i = s.length()-1; i >= 0; i--){\\n                if(root.tries[s.charAt(i)-\\'a\\'] == null){\\n                    root.tries[s.charAt(i)-\\'a\\'] = new Trie();\\n                }\\n                root = root.tries[s.charAt(i)-\\'a\\'];\\n            }\\n            root.isEnding = true;\\n        }\\n        \\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Trie root = parent;\\n        for(int i = sb.length()-1; i >= 0; i--){\\n            if(root.tries[sb.charAt(i)-\\'a\\'] == null) return false;\\n            if(root.tries[sb.charAt(i)-\\'a\\'].isEnding) return true;\\n            root = root.tries[sb.charAt(i)-\\'a\\'];\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610553,
                "title": "rust-solution",
                "content": "```\\nuse std::collections::HashSet;\\n\\nstruct StreamChecker {\\n    data: Vec<String>,\\n    last_char: HashSet<char>,\\n    word_check: String\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut temp: HashSet<char> = HashSet::new();\\n        for word in &words {\\n            temp.insert(word.chars().nth(word.len()-1).unwrap());\\n        }\\n        Self {\\n            data: words,\\n            last_char: temp,\\n            word_check: String::new()\\n        }\\n    }\\n    \\n    fn query(&mut self, letter: char) -> bool {\\n        self.word_check.push(letter);\\n        if self.last_char.contains(&letter) {\\n            let len_word = self.word_check.len();\\n            for word in &self.data {\\n                if word.chars().nth(word.len()-1).unwrap() == letter {\\n                    let len = word.len();\\n                    if len > len_word {\\n                        continue;\\n                    }\\n                    let temp_word: String = self.word_check[(len_word-len)..len_word].to_string();\\n                    if *word == temp_word {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nstruct StreamChecker {\\n    data: Vec<String>,\\n    last_char: HashSet<char>,\\n    word_check: String\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut temp: HashSet<char> = HashSet::new();\\n        for word in &words {\\n            temp.insert(word.chars().nth(word.len()-1).unwrap());\\n        }\\n        Self {\\n            data: words,\\n            last_char: temp,\\n            word_check: String::new()\\n        }\\n    }\\n    \\n    fn query(&mut self, letter: char) -> bool {\\n        self.word_check.push(letter);\\n        if self.last_char.contains(&letter) {\\n            let len_word = self.word_check.len();\\n            for word in &self.data {\\n                if word.chars().nth(word.len()-1).unwrap() == letter {\\n                    let len = word.len();\\n                    if len > len_word {\\n                        continue;\\n                    }\\n                    let temp_word: String = self.word_check[(len_word-len)..len_word].to_string();\\n                    if *word == temp_word {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1610449,
                "title": "c-easy-solution",
                "content": "```\\nclass Node{\\n    public:\\n        char letter;\\n        Node *childs[26];\\n        bool isWordEnd = false; \\n        Node(char letter){\\n            this->letter = letter;\\n            for(int i=0;i<26;i++) childs[i] = NULL;\\n        }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    vector<string> words;\\n    string stream;\\n    Node *root = new Node(\\'0\\');\\n    \\n    StreamChecker(vector<string>& words) {\\n        this->words = words, this->stream=\"\";\\n        root= new Node(\\'0\\');\\n        root->letter=\\'0\\';\\n        for(auto s:words)\\n            insert(s);\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        Node *node = root;\\n        stream += letter;\\n        char c;\\n        for(int i=stream.length()-1;i>=0;i--){\\n            c=stream[i];\\n            \\n            if( node->childs[c-97] == NULL || node->isWordEnd) break;\\n            else node = node->childs[c-97];\\n            \\n        }\\n        return node->isWordEnd; \\n    }\\n    \\n    \\n    void insert(string &s){\\n        Node *node = root;\\n        char c;\\n        for(int i=s.length()-1;i>=0;i--){\\n            c = s[i];\\n            if( node->childs[c-97] == NULL ){\\n                Node *newNode = new Node(c);\\n                node->childs[c-97] = newNode;\\n            }\\n            node = node->childs[c-97];\\n        }\\n        node->isWordEnd = true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "String",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\n    public:\\n        char letter;\\n        Node *childs[26];\\n        bool isWordEnd = false; \\n        Node(char letter){\\n            this->letter = letter;\\n            for(int i=0;i<26;i++) childs[i] = NULL;\\n        }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    vector<string> words;\\n    string stream;\\n    Node *root = new Node(\\'0\\');\\n    \\n    StreamChecker(vector<string>& words) {\\n        this->words = words, this->stream=\"\";\\n        root= new Node(\\'0\\');\\n        root->letter=\\'0\\';\\n        for(auto s:words)\\n            insert(s);\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        Node *node = root;\\n        stream += letter;\\n        char c;\\n        for(int i=stream.length()-1;i>=0;i--){\\n            c=stream[i];\\n            \\n            if( node->childs[c-97] == NULL || node->isWordEnd) break;\\n            else node = node->childs[c-97];\\n            \\n        }\\n        return node->isWordEnd; \\n    }\\n    \\n    \\n    void insert(string &s){\\n        Node *node = root;\\n        char c;\\n        for(int i=s.length()-1;i>=0;i--){\\n            c = s[i];\\n            if( node->childs[c-97] == NULL ){\\n                Node *newNode = new Node(c);\\n                node->childs[c-97] = newNode;\\n            }\\n            node = node->childs[c-97];\\n        }\\n        node->isWordEnd = true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610437,
                "title": "c-trie-dictionary-tree",
                "content": "Approach 1: Trie [1]\\nTime complexity:\\nbuild O(sum(len(w))\\nquery O(max(len(w))\\n\\nSpace complexity: O(sum(len(w))\\n```\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for (const string& word : words) {\\n            TrieNode *node = root;\\n            for (int i = word.size() - 1; i >= 0; --i) { //Reversed storing info in trie\\n                if (!node->next[word[i] - \\'a\\']) {\\n                    node->next[word[i] - \\'a\\'] = new TrieNode();\\n                }\\n                node = node->next[word[i] - \\'a\\'];\\n            }\\n            node->isWord = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        queryStr+=letter;        \\n        TrieNode *node = root;\\n        for (int i = queryStr.size() - 1; i >= 0 && node; --i) { //Reversed searching\\n            node = node->next[queryStr[i] - \\'a\\'];\\n            if (node && node->isWord) return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    struct TrieNode {\\n        bool isWord;\\n        TrieNode *next[26];\\n    };\\n    \\n    TrieNode *root = new TrieNode();\\n    string queryStr;\\n};\\n```\\nReference:\\n[1] https://www.cnblogs.com/grandyang/p/14406525.html",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for (const string& word : words) {\\n            TrieNode *node = root;\\n            for (int i = word.size() - 1; i >= 0; --i) { //Reversed storing info in trie\\n                if (!node->next[word[i] - \\'a\\']) {\\n                    node->next[word[i] - \\'a\\'] = new TrieNode();\\n                }\\n                node = node->next[word[i] - \\'a\\'];\\n            }\\n            node->isWord = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        queryStr+=letter;        \\n        TrieNode *node = root;\\n        for (int i = queryStr.size() - 1; i >= 0 && node; --i) { //Reversed searching\\n            node = node->next[queryStr[i] - \\'a\\'];\\n            if (node && node->isWord) return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    struct TrieNode {\\n        bool isWord;\\n        TrieNode *next[26];\\n    };\\n    \\n    TrieNode *root = new TrieNode();\\n    string queryStr;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569715,
                "title": "2000-2",
                "content": "[\\u0421\\u0441\\u044B\\u043B\\u043A\\u0430 \\u043D\\u0430 \\u0410\\u0445\\u043E \\u041A\\u043E\\u0440\\u0430\\u0441\\u0438\\u043A \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C](https://e-maxx.ru/algo/aho_corasick)\\n\\n\\u041F\\u0430\\u0446\\u0430\\u043D\\u044B \\u0441 \\u043B\\u0438\\u0442\\u043A\\u043E\\u0434\\u0430 \\u043F\\u0440\\u0438\\u0444\\u0438\\u0433\\u0435\\u043B\\u0438 \\u0434\\u0430\\u044E\\u0442 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u0441 Trie \\u043A\\u043E\\u0433\\u0434\\u0430 \\u043E\\u0447\\u0435\\u0432\\u0438\\u0434\\u043D\\u043E \\u043E\\u043D\\u043E \\u0434\\u043E\\u043B\\u0436\\u043D\\u043E \\u0442\\u0430\\u0439\\u043C \\u043B\\u0438\\u043C\\u0438\\u0442\\u0438\\u0442\\u044C. \\u041D\\u0430\\u043F\\u0440\\u0438\\u043C\\u0435\\u0440, \\u0440\\u0430\\u0441\\u043C\\u043E\\u0442\\u0440\\u0438\\u0442\\u0435 \\u0440\\u0430\\u043D\\u0434\\u043E\\u043C\\u043D\\u0443\\u044E \\u0441\\u0442\\u0440\\u043E\\u043A\\u0443 `\\u0441\\u0442\\u04401` \\u0438\\u0437 2000 \\u0431\\u0443\\u043A\\u0432, \\u0441\\u0433\\u0435\\u043D\\u0435\\u0440\\u044C\\u0442\\u0435 \\u0438\\u0437 \\u043D\\u0435\\u0435 2000 \\u0441\\u0434\\u0432\\u0438\\u0433\\u043E\\u0432 \\u0438 \\u0441\\u043E\\u0437\\u0434\\u0430\\u0439\\u0442\\u0435 \\u0441\\u0432\\u043E\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432 words. \\u0422\\u0435\\u043F\\u0435\\u0440\\u044C \\u0438\\u043D\\u0441\\u0435\\u0440\\u0442\\u044F \\u043A\\u0430\\u0436\\u0434\\u0443\\u044E \\u0431\\u0443\\u043A\\u0432\\u0443 \\u0438\\u043D\\u0441\\u0435\\u0440\\u0442\\u044C\\u0442\\u0435 \\u043F\\u043E \\u043A\\u0440\\u0443\\u0433\\u043E\\u0432\\u0443\\u044E \\u0441\\u0432\\u043E\\u044E `\\u0441\\u0442\\u04401` \\u043A\\u0430\\u0436\\u0434\\u044B\\u0435 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u0438\\u0435 2000 \\u0431\\u0443\\u043A\\u0432 \\u0431\\u0443\\u0434\\u0443\\u0442 \\u0441\\u043E\\u0432\\u043F\\u0430\\u0434\\u0430\\u0442\\u044C \\u0441 \\u043A\\u0430\\u043A\\u0438\\u043C \\u0442\\u043E \\u0441\\u043B\\u043E\\u0432\\u043E\\u043C \\u0438\\u0437 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430 words (\\u0442\\u043A \\u043C\\u044B \\u0438\\u0445 \\u0441\\u0433\\u0435\\u043D\\u0435\\u0440\\u0438\\u043B\\u0438 \\u0441\\u0434\\u0432\\u0438\\u0433\\u0430\\u043C\\u0438, \\u0430 \\u0431\\u0443\\u043A\\u0432\\u044B \\u0438\\u043D\\u0441\\u0435\\u0440\\u0442\\u0438\\u043C \\u043F\\u043E \\u043A\\u0440\\u0443\\u0433\\u043E\\u0432\\u0443\\u044E (\\u043F\\u043E \\u043C\\u043E\\u0434\\u0443\\u043B\\u044E 2000) \\u0438\\u0437 `\\u0441\\u0442\\u04401`. \\u0422\\u0430\\u043A\\u0438\\u043C \\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u043C \\u0438\\u043D\\u0441\\u0435\\u0440\\u0442\\u044F \\u043D\\u043E\\u0432\\u0443\\u044E \\u0431\\u0443\\u043A\\u0432\\u0443 \\u043D\\u0430 \\u0441\\u0432\\u043E\\u0435\\u043C Trie \\u043A\\u0430\\u0436\\u0434\\u044B\\u0439 \\u0440\\u0430\\u0437 2000 \\u0438\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u0438 \\u0431\\u0443\\u0434\\u0435\\u043C \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C. \\u0422\\u043E \\u0435\\u0441\\u0442\\u044C \\u043E\\u0447\\u0435\\u0432\\u0438\\u0434\\u043D\\u044B\\u0439 \\u0442\\u0430\\u0439\\u043C \\u043B\\u0438\\u043C\\u0438\\u0442 2000 * 4 * 10 ^ 4. \\n\\n\\u041A\\u043E\\u043D\\u0435\\u0447\\u043D\\u043E, \\u044F \\u044D\\u0442\\u043E \\u043F\\u043E\\u043D\\u044F\\u043B \\u0438 \\u0447\\u0435\\u043A\\u0430\\u043B \\u043D\\u0430 e-maxx \\u0430\\u043B\\u0433\\u043E\\u0441\\u044B \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u0441\\u043F\\u0440\\u0430\\u0432\\u043B\\u044F\\u044E\\u0442\\u0441\\u044F \\u0441 \\u0442\\u0430\\u043A\\u0438\\u043C\\u0438 \\u0437\\u0430\\u043F\\u0440\\u043E\\u0441\\u0430\\u043C\\u0438. \\u041A\\u043E\\u0440\\u043E\\u0447\\u0435 \\u0432 \\u0410\\u0445\\u043E \\u041A\\u043E\\u0440\\u0430\\u0441\\u0438\\u043A\\u0435 \\u043F\\u0440\\u0435\\u043F\\u0440\\u043E\\u0446\\u0435\\u0441\\u0441\\u0438\\u043D\\u0433 \\u0434\\u0435\\u043B\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430 2000 * 2000 \\u043E\\u043F\\u0435\\u0440\\u0430\\u0446\\u0438\\u0439. \\u0414\\u0430\\u043B\\u044C\\u0448\\u0435 \\u043A\\u0430\\u0436\\u0434\\u0430\\u044F \\u043E\\u043F\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F \\u0434\\u043E\\u0431\\u0430\\u0432\\u043B\\u0435\\u043D\\u0438\\u044F \\u0431\\u0443\\u043A\\u0432\\u044B \\u043E\\u0431\\u0440\\u0430\\u0431\\u0430\\u0442\\u044B\\u0432\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430 \\u043A\\u043E\\u043D\\u0441\\u0442\\u0430\\u043D\\u0442\\u0443. \\u0410\\u0445\\u043E \\u041A\\u043E\\u0440\\u0430\\u0441\\u0438\\u043A \\u044D\\u0442\\u043E \\u043A\\u0430\\u043A \\u043E\\u043D\\u043B\\u0430\\u0439\\u043D\\u043E\\u0432\\u044B\\u0439 KMP \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u0447\\u0435\\u043A\\u0430\\u0435\\u0442 \\u0441\\u043E\\u0432\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u043B\\u0438 \\u0441\\u0443\\u0444\\u0444\\u0438\\u043A\\u0441 \\u0441 \\u043F\\u0440\\u0435\\u0444\\u0438\\u043A\\u0441\\u043E\\u043C (\\u0433\\u0434\\u0435 \\u043F\\u0440\\u0435\\u0444\\u0438\\u043A\\u0441 \\u0432\\u0430\\u0448\\u0430 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430 \\u0438\\u0437 \\u0441\\u043B\\u043E\\u0432\\u0430\\u0440\\u044F). \\u0422\\u043E\\u043B\\u044C\\u043A\\u043E \\u0438\\u0437\\u043D\\u0430\\u0447\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043F\\u0440\\u0435\\u0444\\u0438\\u043A\\u0441 \\u044D\\u0442\\u043E \\u0443 \\u0432\\u0430\\u0441 \\u043D\\u0435 \\u043E\\u0434\\u043D\\u0430 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430, \\u0430 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E \\u043F\\u043E\\u0441\\u0442\\u0440\\u043E\\u0435\\u043D\\u043D\\u043E\\u0435 \\u043D\\u0430 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0435 \\u0441\\u0442\\u0440\\u043E\\u043A (\\u0441\\u043B\\u043E\\u0432 \\u0438\\u0437 \\u0441\\u043B\\u043E\\u0432\\u0430\\u0440\\u044F). \\u0412\\u043E\\u0442 \\u0410\\u0445\\u043E \\u041A\\u043E\\u0440\\u0430\\u0441\\u0438\\u043A \\u043F\\u0435\\u0440\\u0435\\u043F\\u0438\\u0441\\u0430\\u043D\\u043D\\u044B\\u0439 \\u043D\\u0430 \\u041F\\u0438\\u0442\\u043E\\u043D.\\n\\n```\\nclass Vertex:\\n    def __init__(self, p = -1, pch = \\'#\\'):\\n        self.next = {}\\n        self.leaf = False\\n        self.p = p\\n        self.pch = pch\\n        self.link = -1\\n        self.go = {}\\n\\n\\nclass Bor:\\n    def __init__(self):\\n        self.t = [Vertex()]\\n        self.memo_leaf = {}\\n\\n    def add_string(self, s):\\n        v = 0\\n        for ch in s:\\n            if ch not in self.t[v].next:\\n                self.t[v].next[ch] = len(self.t)\\n                self.t.append(Vertex(v, ch))\\n            v = self.t[v].next[ch]\\n        self.t[v].leaf = True\\n\\n    def go(self, v, c):\\n        if c not in self.t[v].go:\\n            if c in self.t[v].next:\\n                self.t[v].go[c] = self.t[v].next[c]\\n            else:\\n                self.t[v].go[c] = self.go(self.get_link(v), c) if v != 0 else 0\\n        return self.t[v].go[c]\\n\\n    def get_link(self, v):\\n        if self.t[v].link == -1:\\n            if v == 0 or self.t[v].p == 0:\\n                self.t[v].link = 0\\n            else:\\n                self.t[v].link = self.go(self.get_link(self.t[v].p), self.t[v].pch)\\n        return self.t[v].link\\n\\n    def is_leaf(self, v):\\n        if v not in self.memo_leaf:\\n            self.memo_leaf[v] = v != 0 and (self.t[v].leaf or self.is_leaf(self.get_link(v)))\\n        return self.memo_leaf[v]\\n\\n\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.bor = Bor()\\n        for w in words:\\n            self.bor.add_string(w)\\n        self.v = 0\\n\\n    def query(self, letter):\\n        self.v = self.bor.go(self.v, letter)\\n        return self.bor.is_leaf(self.v)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Vertex:\\n    def __init__(self, p = -1, pch = \\'#\\'):\\n        self.next = {}\\n        self.leaf = False\\n        self.p = p\\n        self.pch = pch\\n        self.link = -1\\n        self.go = {}\\n\\n\\nclass Bor:\\n    def __init__(self):\\n        self.t = [Vertex()]\\n        self.memo_leaf = {}\\n\\n    def add_string(self, s):\\n        v = 0\\n        for ch in s:\\n            if ch not in self.t[v].next:\\n                self.t[v].next[ch] = len(self.t)\\n                self.t.append(Vertex(v, ch))\\n            v = self.t[v].next[ch]\\n        self.t[v].leaf = True\\n\\n    def go(self, v, c):\\n        if c not in self.t[v].go:\\n            if c in self.t[v].next:\\n                self.t[v].go[c] = self.t[v].next[c]\\n            else:\\n                self.t[v].go[c] = self.go(self.get_link(v), c) if v != 0 else 0\\n        return self.t[v].go[c]\\n\\n    def get_link(self, v):\\n        if self.t[v].link == -1:\\n            if v == 0 or self.t[v].p == 0:\\n                self.t[v].link = 0\\n            else:\\n                self.t[v].link = self.go(self.get_link(self.t[v].p), self.t[v].pch)\\n        return self.t[v].link\\n\\n    def is_leaf(self, v):\\n        if v not in self.memo_leaf:\\n            self.memo_leaf[v] = v != 0 and (self.t[v].leaf or self.is_leaf(self.get_link(v)))\\n        return self.memo_leaf[v]\\n\\n\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.bor = Bor()\\n        for w in words:\\n            self.bor.add_string(w)\\n        self.v = 0\\n\\n    def query(self, letter):\\n        self.v = self.bor.go(self.v, letter)\\n        return self.bor.is_leaf(self.v)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552056,
                "title": "python",
                "content": "1) Discard \"inclusive\" `words`, for example from `aaaaabc` and `abc` stay just `abc`.\\n2) Build total resulted phrase and check it each time with `endswith` for each of our words.\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        \\n        self.phrase = \\'\\'\\n        self.words = []\\n        \\n        for word in sorted(words,key = len):\\n            word_founded = False\\n            for _word in self.words:\\n                if word.endswith(_word):\\n                    word_founded = True\\n                    break\\n            if word_founded:\\n                continue\\n            self.words.append(word)\\n        \\n        \\n\\n    def query(self, letter: str) -> bool:\\n        \\n        self.phrase += letter\\n        \\n        return any([self.phrase.endswith(word) for word in self.words])\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        \\n        self.phrase = \\'\\'\\n        self.words = []\\n        \\n        for word in sorted(words,key = len):\\n            word_founded = False\\n            for _word in self.words:\\n                if word.endswith(_word):\\n                    word_founded = True\\n                    break\\n            if word_founded:\\n                continue\\n            self.words.append(word)\\n        \\n        \\n\\n    def query(self, letter: str) -> bool:\\n        \\n        self.phrase += letter\\n        \\n        return any([self.phrase.endswith(word) for word in self.words])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377982,
                "title": "aho-corasick-implementation-with-trie",
                "content": "This problem is a typical application of aho corasick algorithm. Here, I have implemented Aho-corasick with the help of trie. \\n```\\nclass TrieNode{\\n        public:\\n  TrieNode *adj[26];\\n  TrieNode *failure;\\n    bool isEnd;\\n\\n    TrieNode() {\\n        for(int i = 0;i<26;i++){\\n            adj[i]=NULL;\\n            failure = NULL;\\n            isEnd=false;\\n        }\\n    }\\n};\\nvoid insert(TrieNode *root, string s){\\n    TrieNode *tmp = root;\\n    for(char c : s) {\\n        if(tmp->adj[c-\\'a\\']==NULL){\\n            tmp->adj[c-\\'a\\'] = new TrieNode();\\n        }\\n        tmp = tmp->adj[c-\\'a\\'];\\n    }\\n    tmp->isEnd = true;\\n}\\n\\nvoid build(TrieNode *root) {\\n    root->failure = root;\\n    queue<TrieNode*> q;\\n    for(int i = 0;i<26;i++){\\n        if(root->adj[i]!=NULL){\\n            root->adj[i]->failure = root;\\n            q.push(root->adj[i]);\\n        }else{\\n            root->adj[i] = root;\\n        }\\n    }\\n    while(!q.empty()) {\\n        TrieNode* u = q.front();\\n        q.pop();\\n        for(int i = 0;i<26;i++) {\\n            if(u->adj[i]!=NULL) {\\n                TrieNode *failure = u->failure;\\n                while(failure->adj[i]==NULL){\\n                    failure = failure->failure;\\n                }\\n                failure = failure->adj[i];\\n                u->adj[i]->failure = failure;\\n                u->adj[i]->isEnd = u->adj[i]->isEnd || failure->isEnd;\\n                q.push(u->adj[i]);\\n            }\\n        }\\n    }\\n}\\nclass StreamChecker {\\npublic:\\n    TrieNode *root;\\n    TrieNode *curr;\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode();\\n        for(string s:words){\\n            insert(root,s);\\n        }\\n        build(root);\\n        curr = root;\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        while(curr->adj[letter-\\'a\\']==NULL)\\n            curr = curr->failure;\\n        curr = curr->adj[letter-\\'a\\'];\\n        return curr->isEnd;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n        public:\\n  TrieNode *adj[26];\\n  TrieNode *failure;\\n    bool isEnd;\\n\\n    TrieNode() {\\n        for(int i = 0;i<26;i++){\\n            adj[i]=NULL;\\n            failure = NULL;\\n            isEnd=false;\\n        }\\n    }\\n};\\nvoid insert(TrieNode *root, string s){\\n    TrieNode *tmp = root;\\n    for(char c : s) {\\n        if(tmp->adj[c-\\'a\\']==NULL){\\n            tmp->adj[c-\\'a\\'] = new TrieNode();\\n        }\\n        tmp = tmp->adj[c-\\'a\\'];\\n    }\\n    tmp->isEnd = true;\\n}\\n\\nvoid build(TrieNode *root) {\\n    root->failure = root;\\n    queue<TrieNode*> q;\\n    for(int i = 0;i<26;i++){\\n        if(root->adj[i]!=NULL){\\n            root->adj[i]->failure = root;\\n            q.push(root->adj[i]);\\n        }else{\\n            root->adj[i] = root;\\n        }\\n    }\\n    while(!q.empty()) {\\n        TrieNode* u = q.front();\\n        q.pop();\\n        for(int i = 0;i<26;i++) {\\n            if(u->adj[i]!=NULL) {\\n                TrieNode *failure = u->failure;\\n                while(failure->adj[i]==NULL){\\n                    failure = failure->failure;\\n                }\\n                failure = failure->adj[i];\\n                u->adj[i]->failure = failure;\\n                u->adj[i]->isEnd = u->adj[i]->isEnd || failure->isEnd;\\n                q.push(u->adj[i]);\\n            }\\n        }\\n    }\\n}\\nclass StreamChecker {\\npublic:\\n    TrieNode *root;\\n    TrieNode *curr;\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode();\\n        for(string s:words){\\n            insert(root,s);\\n        }\\n        build(root);\\n        curr = root;\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        while(curr->adj[letter-\\'a\\']==NULL)\\n            curr = curr->failure;\\n        curr = curr->adj[letter-\\'a\\'];\\n        return curr->isEnd;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313458,
                "title": "trie-c-clean-code",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    \\n    struct trie{\\n        struct trie *ch[26];\\n        bool isend;\\n        trie()\\n        {\\n            memset(ch,0,sizeof(ch));\\n            isend=false;\\n        }\\n    };\\n    \\n    \\n    struct trie *root=new trie;\\n    string tm;\\n    int mx=0;\\n    \\n    void insert(string s)\\n    {\\n        struct trie *tmp=root;\\n        for(auto x:s)\\n        {\\n            int idx=x-\\'a\\';\\n            if(tmp->ch[idx]==NULL)\\n            {\\n                tmp->ch[idx]=new trie;\\n            }\\n            tmp=tmp->ch[idx];\\n        }\\n        tmp->isend=true;\\n    }\\n    \\n    bool find(string tm)\\n    {\\n        struct trie *tmp=root;\\n        for(auto x:tm)\\n        {\\n            int idx=x-\\'a\\';\\n            if(tmp->isend)\\n            {\\n                return tmp->isend;\\n            }\\n            if(tmp->ch[idx]==NULL)\\n            {\\n                return tmp->isend;\\n            }\\n            tmp=tmp->ch[idx];\\n            \\n        }\\n        return (tmp->isend);\\n    }\\n    \\n    \\n    StreamChecker(vector<string>& words) {\\n        for(auto x:words)\\n        {\\n            string y=x;\\n            reverse(y.begin(),y.end());\\n            mx=max(mx,(int)y.length());\\n            insert(y);\\n        }\\n        tm=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        tm=letter+tm;\\n        if(tm.length()>mx)\\n        {\\n            tm.pop_back();\\n        }\\n        return find(tm);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    \\n    struct trie{\\n        struct trie *ch[26];\\n        bool isend;\\n        trie()\\n        {\\n            memset(ch,0,sizeof(ch));\\n            isend=false;\\n        }\\n    };\\n    \\n    \\n    struct trie *root=new trie;\\n    string tm;\\n    int mx=0;\\n    \\n    void insert(string s)\\n    {\\n        struct trie *tmp=root;\\n        for(auto x:s)\\n        {\\n            int idx=x-\\'a\\';\\n            if(tmp->ch[idx]==NULL)\\n            {\\n                tmp->ch[idx]=new trie;\\n            }\\n            tmp=tmp->ch[idx];\\n        }\\n        tmp->isend=true;\\n    }\\n    \\n    bool find(string tm)\\n    {\\n        struct trie *tmp=root;\\n        for(auto x:tm)\\n        {\\n            int idx=x-\\'a\\';\\n            if(tmp->isend)\\n            {\\n                return tmp->isend;\\n            }\\n            if(tmp->ch[idx]==NULL)\\n            {\\n                return tmp->isend;\\n            }\\n            tmp=tmp->ch[idx];\\n            \\n        }\\n        return (tmp->isend);\\n    }\\n    \\n    \\n    StreamChecker(vector<string>& words) {\\n        for(auto x:words)\\n        {\\n            string y=x;\\n            reverse(y.begin(),y.end());\\n            mx=max(mx,(int)y.length());\\n            insert(y);\\n        }\\n        tm=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        tm=letter+tm;\\n        if(tm.length()>mx)\\n        {\\n            tm.pop_back();\\n        }\\n        return find(tm);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171602,
                "title": "java-my-solution-with-rolling-hash",
                "content": "The gist of this solution is to calculate the rolling hash of each word, and map that hash value to the set of words which share that hash value (for a good hash function, different words having the same hash shouldn\\'t happen often). In addition to this, we\\'ll calculate the rolling hash for *all* of the suffixes in the word (e.g. for `\"abc\"` we would calculate/store the hashes for `\"abc\"`, `\"bc\"`, and `\"c\"`. If we move from the end of the stream backwards, this will allow us to quickly check whether or not each given suffix might actually exist, and if not, prevent unnecessarily checking other \"substrings\" in the stream which can not possibly be contained in our set of valid words.\\n\\nAfter this initialization, whenever we call query, we will add the new character to the end of the character list, then work backwards to calculate a rolling hash while at the same time incrementally building a string. If we find a hash value that exists in our `wordHash` map, we can then check if the currently-constructed string exists in the set of words mapped to by that hash value, and if so, return true. If we reach the first character in the stream (or exceed the length of the longest word in our set) we return false. \\n\\nHere is my code:\\n\\n```\\nclass StreamChecker {\\n    static final int MOD = 100000007;\\n    int maxLen;\\n    Set<Integer> suffixes;\\n    Map<Integer, Set<String>> wordMap;\\n    List<Character> stream;\\n    public StreamChecker(String[] words) {\\n        maxLen = 0;\\n        suffixes = new HashSet<>();\\n        wordMap = new HashMap<>();\\n        for(String w : words) {\\n            addRollingHash(w);\\n            maxLen = Math.max(maxLen, w.length());\\n        }\\n        stream = new LinkedList<>();\\n    }\\n    \\n    public boolean query(char c) {\\n        stream.add(c);\\n        if(stream.size() > maxLen) {\\n            stream.remove(0);\\n        }\\n        String s = \"\";\\n        int hash = 0;\\n        for(int i = stream.size()-1; i >= 0; --i) {\\n            s = stream.get(i) + s;\\n            int v = (int) stream.get(i).charValue()-\\'a\\';\\n            hash = ((hash * 26) + v) % MOD;\\n            if(!suffixes.contains(hash)) {\\n                return false;\\n            } else if(wordMap.containsKey(hash) && wordMap.get(hash).contains(s)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void addRollingHash(String s) {\\n        int hash = 0;\\n        for(int i = s.length()-1; i >= 0; --i) {\\n            int v = s.charAt(i)-\\'a\\';\\n            hash = ((hash * 26) + v) % MOD;\\n            suffixes.add(hash);\\n        }\\n        Set<String> set = wordMap.getOrDefault(hash, new HashSet<String>());\\n        set.add(s);\\n        wordMap.put(hash, set);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    static final int MOD = 100000007;\\n    int maxLen;\\n    Set<Integer> suffixes;\\n    Map<Integer, Set<String>> wordMap;\\n    List<Character> stream;\\n    public StreamChecker(String[] words) {\\n        maxLen = 0;\\n        suffixes = new HashSet<>();\\n        wordMap = new HashMap<>();\\n        for(String w : words) {\\n            addRollingHash(w);\\n            maxLen = Math.max(maxLen, w.length());\\n        }\\n        stream = new LinkedList<>();\\n    }\\n    \\n    public boolean query(char c) {\\n        stream.add(c);\\n        if(stream.size() > maxLen) {\\n            stream.remove(0);\\n        }\\n        String s = \"\";\\n        int hash = 0;\\n        for(int i = stream.size()-1; i >= 0; --i) {\\n            s = stream.get(i) + s;\\n            int v = (int) stream.get(i).charValue()-\\'a\\';\\n            hash = ((hash * 26) + v) % MOD;\\n            if(!suffixes.contains(hash)) {\\n                return false;\\n            } else if(wordMap.containsKey(hash) && wordMap.get(hash).contains(s)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void addRollingHash(String s) {\\n        int hash = 0;\\n        for(int i = s.length()-1; i >= 0; --i) {\\n            int v = s.charAt(i)-\\'a\\';\\n            hash = ((hash * 26) + v) % MOD;\\n            suffixes.add(hash);\\n        }\\n        Set<String> set = wordMap.getOrDefault(hash, new HashSet<String>());\\n        set.add(s);\\n        wordMap.put(hash, set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023918,
                "title": "java-clean-and-simple-trie-stringbuilder-99-23",
                "content": "```\\nclass StreamChecker {\\n    private class Trie {\\n        private Trie[] children;\\n        private boolean isLeaf;\\n        \\n        private Trie() {\\n            children = new Trie[26];\\n        }\\n        \\n        private Trie add(char[] chars) {\\n            Trie root = this;\\n            for(int i = chars.length - 1; i >= 0; i--) {\\n                int index = chars[i] - \\'a\\';\\n                if(root.children[index] == null) {\\n                    root.children[index] = new Trie();\\n                }\\n                \\n                root = root.children[index];\\n            }\\n            \\n            root.isLeaf = true;\\n            \\n            return root;\\n        }\\n    }\\n    \\n    private Trie root;\\n    private StringBuilder query;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        query = new StringBuilder();\\n        \\n        for(String word : words) {\\n            root.add(word.toCharArray());\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        query.append(letter);\\n        \\n        Trie trie = root;\\n        for(int i = query.length() - 1; i >= 0; i--) {\\n            int index = query.charAt(i) - \\'a\\';\\n            if(trie.children[index] == null) {\\n                return false;\\n            }\\n            \\n            trie = trie.children[index];\\n            if(trie.isLeaf) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    private class Trie {\\n        private Trie[] children;\\n        private boolean isLeaf;\\n        \\n        private Trie() {\\n            children = new Trie[26];\\n        }\\n        \\n        private Trie add(char[] chars) {\\n            Trie root = this;\\n            for(int i = chars.length - 1; i >= 0; i--) {\\n                int index = chars[i] - \\'a\\';\\n                if(root.children[index] == null) {\\n                    root.children[index] = new Trie();\\n                }\\n                \\n                root = root.children[index];\\n            }\\n            \\n            root.isLeaf = true;\\n            \\n            return root;\\n        }\\n    }\\n    \\n    private Trie root;\\n    private StringBuilder query;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        query = new StringBuilder();\\n        \\n        for(String word : words) {\\n            root.add(word.toCharArray());\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        query.append(letter);\\n        \\n        Trie trie = root;\\n        for(int i = query.length() - 1; i >= 0; i--) {\\n            int index = query.charAt(i) - \\'a\\';\\n            if(trie.children[index] == null) {\\n                return false;\\n            }\\n            \\n            trie = trie.children[index];\\n            if(trie.isLeaf) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022447,
                "title": "python-reverse-trie-and-queue-pythonic-code",
                "content": "The idea is to use a trie to record the reversed string. During the query operations, just check the streaming queue in reverse order to match the trie nodes. The length of the queue only needs to be the max length of your words in the dictionary. Older chars will be discarded. The idea is simple and the code is straightforward.\\n\\n```python\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.string = \\'\\'\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = TrieNode()\\n        self.queue = deque([])\\n        self.depth = 0\\n        for w in words:\\n            self.build(w[::-1])\\n            self.depth = max(self.depth, len(w))\\n\\n    def query(self, letter: str) -> bool:\\n        self.queue.append(letter)\\n        if len(self.queue)>self.depth:\\n            self.queue.popleft()\\n        return self.find()\\n\\n    def build(self,string):\\n        node = self.root\\n        for i,c in enumerate(string):\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.string = string\\n    \\n    def find(self):\\n        j = len(self.queue)-1\\n        node = self.root\\n        while j>=0 and self.queue[j] in node.children:\\n            node = node.children[self.queue[j]]\\n            if node.string:\\n                return True\\n            j-=1\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.string = \\'\\'\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = TrieNode()\\n        self.queue = deque([])\\n        self.depth = 0\\n        for w in words:\\n            self.build(w[::-1])\\n            self.depth = max(self.depth, len(w))\\n\\n    def query(self, letter: str) -> bool:\\n        self.queue.append(letter)\\n        if len(self.queue)>self.depth:\\n            self.queue.popleft()\\n        return self.find()\\n\\n    def build(self,string):\\n        node = self.root\\n        for i,c in enumerate(string):\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.string = string\\n    \\n    def find(self):\\n        j = len(self.queue)-1\\n        node = self.root\\n        while j>=0 and self.queue[j] in node.children:\\n            node = node.children[self.queue[j]]\\n            if node.string:\\n                return True\\n            j-=1\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821038,
                "title": "python-6-lines",
                "content": "```\\nclass StreamChecker(object):\\n\\n    def __init__(self, words):\\n        self.word_map, self.len_map, self.buffer = defaultdict(set), defaultdict(set), \"\"\\n        for w in words:\\n            self.word_map[w[-1]].add(w[::-1])\\n            self.len_map[w[-1]].add(len(w))\\n        \\n\\n    def query(self, letter):\\n        self.buffer = letter + self.buffer\\n        return any(len(self.buffer) >= l and self.buffer[:l] in self.word_map[letter] for l in self.len_map[letter])\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker(object):\\n\\n    def __init__(self, words):\\n        self.word_map, self.len_map, self.buffer = defaultdict(set), defaultdict(set), \"\"\\n        for w in words:\\n            self.word_map[w[-1]].add(w[::-1])\\n            self.len_map[w[-1]].add(len(w))\\n        \\n\\n    def query(self, letter):\\n        self.buffer = letter + self.buffer\\n        return any(len(self.buffer) >= l and self.buffer[:l] in self.word_map[letter] for l in self.len_map[letter])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809285,
                "title": "java-clean-code-trie-data-structure-with-reverse-words",
                "content": "```\\nclass Trie {\\n\\t\\n\\tTrie[] children;\\n\\tboolean isEnd;\\n\\t\\n\\tpublic Trie () {\\n\\t\\tchildren = new Trie[26];\\n\\t\\tisEnd = false;\\n\\t}\\n}\\n \\nclass StreamChecker {\\n\\t\\n\\tTrie root;\\n\\tList<Character> list;\\n\\t\\n\\tpublic StreamChecker (String[] words) {\\n\\t\\t\\n\\t\\troot = new Trie ();\\n\\t\\tlist = new LinkedList <>();\\n\\t\\t\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tinsertWord (word);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic void insertWord (String word) {\\n\\t\\t\\n\\t\\tTrie node = root;\\n \\n\\t\\tfor (int i = word.length () - 1; i >= 0; i--) {\\n\\t\\t\\tchar letter = word.charAt (i);\\n\\t\\t\\tif (node.children[letter - \\'a\\'] == null) {\\n\\t\\t\\t\\tnode.children[letter - \\'a\\'] = new Trie ();\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[letter - \\'a\\'];\\n\\t\\t}\\n\\t\\t\\n\\t\\tnode.isEnd = true;\\n\\t}\\n\\t\\n\\tpublic boolean query (char letter) {\\n\\t\\t\\n\\t\\tlist.add (letter);\\n\\t\\treturn searchWord ();\\n\\t}\\n\\t\\n\\tpublic boolean searchWord () {\\n\\t\\t\\n\\t\\tTrie node = root;\\n\\t\\tfor (int i = list.size () - 1; i >= 0; i--) {\\n\\t\\t\\tchar letter = list.get (i);\\n\\t\\t\\tif (node.children[letter - \\'a\\'] == null) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[letter - \\'a\\'];\\n\\t\\t\\tif (node.isEnd) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\n\\t\\n\\tTrie[] children;\\n\\tboolean isEnd;\\n\\t\\n\\tpublic Trie () {\\n\\t\\tchildren = new Trie[26];\\n\\t\\tisEnd = false;\\n\\t}\\n}\\n \\nclass StreamChecker {\\n\\t\\n\\tTrie root;\\n\\tList<Character> list;\\n\\t\\n\\tpublic StreamChecker (String[] words) {\\n\\t\\t\\n\\t\\troot = new Trie ();\\n\\t\\tlist = new LinkedList <>();\\n\\t\\t\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tinsertWord (word);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic void insertWord (String word) {\\n\\t\\t\\n\\t\\tTrie node = root;\\n \\n\\t\\tfor (int i = word.length () - 1; i >= 0; i--) {\\n\\t\\t\\tchar letter = word.charAt (i);\\n\\t\\t\\tif (node.children[letter - \\'a\\'] == null) {\\n\\t\\t\\t\\tnode.children[letter - \\'a\\'] = new Trie ();\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[letter - \\'a\\'];\\n\\t\\t}\\n\\t\\t\\n\\t\\tnode.isEnd = true;\\n\\t}\\n\\t\\n\\tpublic boolean query (char letter) {\\n\\t\\t\\n\\t\\tlist.add (letter);\\n\\t\\treturn searchWord ();\\n\\t}\\n\\t\\n\\tpublic boolean searchWord () {\\n\\t\\t\\n\\t\\tTrie node = root;\\n\\t\\tfor (int i = list.size () - 1; i >= 0; i--) {\\n\\t\\t\\tchar letter = list.get (i);\\n\\t\\t\\tif (node.children[letter - \\'a\\'] == null) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[letter - \\'a\\'];\\n\\t\\t\\tif (node.isEnd) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808729,
                "title": "java-trie-using-a-waiting-list-of-potenial-answers",
                "content": "Make a trie and insert all the words in order.\\nMake a waiting list, which will store all the potential answers. As soon as the potenial dissappers (not forming a word), delete that node from the waiting list.\\nAnd always check if from root, we can go to a next node, depending upon the query letter.\\n\\nConsider the trie with the words: ab, ba, aaab, abab, baa\\n\\n<img src=\"https://assets.leetcode.com/users/images/2eedfb3f-e881-49e3-a3fc-ef51a59886ca_1598248043.5687332.png\" width=30%>\\n\\nNote: The \\'X\\' is the root, and the small \\'x\\' marked beside the node, means theres a word ending there\\n\\nLet the queries be: a,a,a,a,a,b,a,b,a,b\\nThe content in the waiting list will be: (The number before the character is its corresponding number in the trie. See the diagram)\\n\\na              ```[2a]``` False\\na              ```[4a. 2a]``` False\\na              ```[7a, 4a, 2a]``` False\\na              ```[7a, 4a, 2a]``` False (the previous 7a got deleted, 4a moved to 7a, 2a moved to 4a and 2a added from the root)\\na              ```[7a, 4a, 2a]``` False (same as above)\\nb              ```[10b, 5b, 3b]``` (7a moved to 10b, 4a was deleted as there\\'s no next b, 2a moved to 5b and 3b was added from root). Answer: True, as 10b and 5b both end on a word. Similarly follow the next steps:\\na              ```[8a, 6a, 2a]``` True, 6a ends on a word\\nb              ```[11b, 5b, 3b]``` True, 11b and 5b end on a word\\na              ```[8a, 6a, 2a]``` True, 6a ends on a word\\nb              ```[11b, 5b, 3b]``` True, 11b and 5b end on a word\\n\\nIn the waiting list, if any node was a word written in it, we set the answer to be true ans return ans.\\nSo final result: F, F, F, F, F, T, T, T, T, T\\n```\\nclass StreamChecker {\\n    TrieNode root;\\n    ArrayList<TrieNode> waiting;\\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        root.word = \"/\";\\n        for(String i:words){\\n            insert(root, i);\\n        }\\n        waiting = new ArrayList<TrieNode>();\\n    }\\n    \\n    public boolean query(char letter) {\\n        TrieNode rootNext = root.links[letter-\\'a\\'], temp = null;\\n        boolean ans = false;\\n        int loop = waiting.size();\\n        for(int i=0;i<loop;i++){\\n            temp = waiting.get(i).links[letter-\\'a\\'];\\n            if(temp==null){\\n                waiting.remove(i);\\n                i-=1;\\n                loop-=1;                \\n            }\\n            else{\\n                if(temp.word!=null){\\n                    ans = true;\\n                }                \\n                waiting.set(i, temp);\\n            }\\n        }\\n        if(rootNext!=null){\\n            waiting.add(rootNext);\\n            if(rootNext.word!=null){\\n                ans = true;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    public void insert(TrieNode root, String word){\\n        int n = word.length();\\n        TrieNode temp = root;\\n        for(char i:word.toCharArray()){\\n            if(temp.links[i-\\'a\\']==null){\\n                temp.links[i-\\'a\\'] = new TrieNode();                \\n            }\\n            temp = temp.links[i-\\'a\\'];\\n        }\\n        temp.word = word;\\n    }\\n}\\nclass TrieNode{\\n    String word;\\n    TrieNode[] links;\\n    TrieNode(){        \\n        links = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```[2a]```\n```[4a. 2a]```\n```[7a, 4a, 2a]```\n```[7a, 4a, 2a]```\n```[7a, 4a, 2a]```\n```[10b, 5b, 3b]```\n```[8a, 6a, 2a]```\n```[11b, 5b, 3b]```\n```[8a, 6a, 2a]```\n```[11b, 5b, 3b]```\n```\\nclass StreamChecker {\\n    TrieNode root;\\n    ArrayList<TrieNode> waiting;\\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        root.word = \"/\";\\n        for(String i:words){\\n            insert(root, i);\\n        }\\n        waiting = new ArrayList<TrieNode>();\\n    }\\n    \\n    public boolean query(char letter) {\\n        TrieNode rootNext = root.links[letter-\\'a\\'], temp = null;\\n        boolean ans = false;\\n        int loop = waiting.size();\\n        for(int i=0;i<loop;i++){\\n            temp = waiting.get(i).links[letter-\\'a\\'];\\n            if(temp==null){\\n                waiting.remove(i);\\n                i-=1;\\n                loop-=1;                \\n            }\\n            else{\\n                if(temp.word!=null){\\n                    ans = true;\\n                }                \\n                waiting.set(i, temp);\\n            }\\n        }\\n        if(rootNext!=null){\\n            waiting.add(rootNext);\\n            if(rootNext.word!=null){\\n                ans = true;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    public void insert(TrieNode root, String word){\\n        int n = word.length();\\n        TrieNode temp = root;\\n        for(char i:word.toCharArray()){\\n            if(temp.links[i-\\'a\\']==null){\\n                temp.links[i-\\'a\\'] = new TrieNode();                \\n            }\\n            temp = temp.links[i-\\'a\\'];\\n        }\\n        temp.word = word;\\n    }\\n}\\nclass TrieNode{\\n    String word;\\n    TrieNode[] links;\\n    TrieNode(){        \\n        links = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808153,
                "title": "swift-solution",
                "content": "Clue: store the character we\\'ve seen so far, iterate the trie from the root everytime we got a character. Check if the sequence of newest character is in the trie and it\\'s a word\\n\\n```\\nclass Node {\\n    var dict = [Character: Node]()\\n    var isEnd = false\\n\\n    init() {}\\n\\n    init(_ val: Character) {\\n        dict[val] = Node()\\n    }\\n\\n    func insert(_ word: [Character], _ i: Int) {\\n        self.isEnd = self.isEnd || i == word.count\\n        if i == word.count { return }\\n\\n        if let node = dict[word[i]] {\\n            return node.insert(word, i+1)\\n        }\\n\\n        let node =  Node()\\n        dict[word[i]] = node\\n        node.insert(word, i+1)\\n    }\\n}\\n\\nclass StreamChecker {\\n    let root = Node()\\n    lazy var cur = self.root\\n    var store = [Character]()\\n\\n    init(_ words: [String]) {\\n        for word in words {\\n            root.insert(Array(word).reversed(), 0)\\n        }\\n    }\\n\\n\\n    func query(_ letter: Character) -> Bool {\\n        store.insert(letter, at: 0)\\n        var cur = root\\n        for char in store {\\n            if let node = cur.dict[char] {\\n                cur = node\\n                if node.isEnd { return true}\\n            } else { break }\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    var dict = [Character: Node]()\\n    var isEnd = false\\n\\n    init() {}\\n\\n    init(_ val: Character) {\\n        dict[val] = Node()\\n    }\\n\\n    func insert(_ word: [Character], _ i: Int) {\\n        self.isEnd = self.isEnd || i == word.count\\n        if i == word.count { return }\\n\\n        if let node = dict[word[i]] {\\n            return node.insert(word, i+1)\\n        }\\n\\n        let node =  Node()\\n        dict[word[i]] = node\\n        node.insert(word, i+1)\\n    }\\n}\\n\\nclass StreamChecker {\\n    let root = Node()\\n    lazy var cur = self.root\\n    var store = [Character]()\\n\\n    init(_ words: [String]) {\\n        for word in words {\\n            root.insert(Array(word).reversed(), 0)\\n        }\\n    }\\n\\n\\n    func query(_ letter: Character) -> Bool {\\n        store.insert(letter, at: 0)\\n        var cur = root\\n        for char in store {\\n            if let node = cur.dict[char] {\\n                cur = node\\n                if node.isEnd { return true}\\n            } else { break }\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808019,
                "title": "c-short-solution-clean-and-simple",
                "content": "```\\nclass StreamChecker {\\n    struct TrieNode\\n    {\\n        bool isWord=false;\\n        vector<TrieNode*>children=vector<TrieNode*>(26);\\n    };\\n    TrieNode* root = new TrieNode;         //root of Trie.\\n    \\n    void insert(string word)               //insert function to insert a word in the Trie in reverse fashion.\\n    {\\n        reverse(begin(word),end(word));\\n        TrieNode* cur=root;\\n        for(int i=0 ; i<word.length() ; i++)\\n        {\\n            if(!cur->children[word[i]-\\'a\\']) cur->children[word[i]-\\'a\\']=new TrieNode;\\n            cur = cur->children[word[i]-\\'a\\'];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\npublic:\\n    vector<char>queries;\\n    StreamChecker(vector<string>& words) {                      //insert all the words in the Trie in reverse fashion.\\n        for(int i=0 ; i<words.size() ; i++) insert(words[i]);\\n    }\\n    \\n    bool query(char letter) {             //chek for a word starting from this character using the previous characters in the stream.\\n        queries.push_back(letter);\\n        TrieNode* cur=root;\\n        for(int i=queries.size()-1 ; i>=0 ; i--)\\n        {\\n            if(cur->isWord) return true;\\n            if(!cur->children[queries[i]-\\'a\\']) return false;\\n            cur=cur->children[queries[i]-\\'a\\'];\\n        }\\n        return cur->isWord;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    struct TrieNode\\n    {\\n        bool isWord=false;\\n        vector<TrieNode*>children=vector<TrieNode*>(26);\\n    };\\n    TrieNode* root = new TrieNode;         //root of Trie.\\n    \\n    void insert(string word)               //insert function to insert a word in the Trie in reverse fashion.\\n    {\\n        reverse(begin(word),end(word));\\n        TrieNode* cur=root;\\n        for(int i=0 ; i<word.length() ; i++)\\n        {\\n            if(!cur->children[word[i]-\\'a\\']) cur->children[word[i]-\\'a\\']=new TrieNode;\\n            cur = cur->children[word[i]-\\'a\\'];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\npublic:\\n    vector<char>queries;\\n    StreamChecker(vector<string>& words) {                      //insert all the words in the Trie in reverse fashion.\\n        for(int i=0 ; i<words.size() ; i++) insert(words[i]);\\n    }\\n    \\n    bool query(char letter) {             //chek for a word starting from this character using the previous characters in the stream.\\n        queries.push_back(letter);\\n        TrieNode* cur=root;\\n        for(int i=queries.size()-1 ; i>=0 ; i--)\\n        {\\n            if(cur->isWord) return true;\\n            if(!cur->children[queries[i]-\\'a\\']) return false;\\n            cur=cur->children[queries[i]-\\'a\\'];\\n        }\\n        return cur->isWord;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807900,
                "title": "python-simple-trie-solution-explained-code-video",
                "content": "https://www.youtube.com/watch?v=Z9J2SEORBug\\n[](https://www.youtube.com/watch?v=Z9J2SEORBug)\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.nodes = []\\n        for word in words:\\n            node = self.trie\\n            for char in word:\\n                if char not in node:\\n                    node[char] = {}\\n                node = node[char]\\n            node[\\'end\\'] = True\\n\\n    def query(self, letter: str) -> bool:\\n        self.nodes.append(self.trie)\\n        temp = False\\n        new_nodes = []\\n        \\n        for node in self.nodes:\\n            if letter in node:\\n                node = node[letter]\\n                if \\'end\\' in node:\\n                    temp = True\\n                new_nodes.append(node)\\n        self.nodes = new_nodes\\n        return temp\\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.nodes = []\\n        for word in words:\\n            node = self.trie\\n            for char in word:\\n                if char not in node:\\n                    node[char] = {}\\n                node = node[char]\\n            node[\\'end\\'] = True\\n\\n    def query(self, letter: str) -> bool:\\n        self.nodes.append(self.trie)\\n        temp = False\\n        new_nodes = []\\n        \\n        for node in self.nodes:\\n            if letter in node:\\n                node = node[letter]\\n                if \\'end\\' in node:\\n                    temp = True\\n                new_nodes.append(node)\\n        self.nodes = new_nodes\\n        return temp\\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807873,
                "title": "stream-of-characters-trie-can-not-find-where-makes-memory-limit-exceeded",
                "content": "Just using C++ to implement Trie and I do not know where could make the Memory Limit Exceeded, could someone help me find it out\\uFF1F\\n```\\nclass StreamChecker {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* child[26];\\n        bool str;\\n        TrieNode():str(false)\\n        {\\n            for(auto &a:child)\\n                a=nullptr;\\n        }\\n    };\\n    struct Trie\\n    {\\n        TrieNode*root;\\n        Trie(){root=new TrieNode();}\\n        void insert(string s)\\n        {\\n            TrieNode* t=root;\\n            for(int i=s.size()-1;i>=0;--i)\\n            {\\n                if(!t->child[s[i]-\\'a\\']) \\n                    t->child[s[i]-\\'a\\']=new TrieNode();\\n                t=t->child[s[i]-\\'a\\'];\\n            }\\n            t->str=true;\\n        }\\n        bool find(string s)\\n        {\\n            TrieNode* t=root;\\n            int i=s.size()-1;\\n            while(i>=0)\\n            {\\n                if(t->child[s[i]-\\'a\\'])\\n                {\\n                    if(t->child[s[i]-\\'a\\']->str)\\n                        return true;\\n                    t=t->child[s[i]-\\'a\\'];\\n                    --i;\\n                }\\n                else\\n                    return false;\\n            }\\n            return false;\\n        }\\n    };\\n    StreamChecker(vector<string>& words) {\\n        trie=new Trie();\\n        for(string word:words)\\n        {\\n            trie->insert(word);\\n        }\\n        st=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        st.push_back(letter);\\n        return trie->find(st);\\n    }\\nprivate:\\n    string st;\\n    Trie* trie;\\n};\\n```\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* child[26];\\n        bool str;\\n        TrieNode():str(false)\\n        {\\n            for(auto &a:child)\\n                a=nullptr;\\n        }\\n    };\\n    struct Trie\\n    {\\n        TrieNode*root;\\n        Trie(){root=new TrieNode();}\\n        void insert(string s)\\n        {\\n            TrieNode* t=root;\\n            for(int i=s.size()-1;i>=0;--i)\\n            {\\n                if(!t->child[s[i]-\\'a\\']) \\n                    t->child[s[i]-\\'a\\']=new TrieNode();\\n                t=t->child[s[i]-\\'a\\'];\\n            }\\n            t->str=true;\\n        }\\n        bool find(string s)\\n        {\\n            TrieNode* t=root;\\n            int i=s.size()-1;\\n            while(i>=0)\\n            {\\n                if(t->child[s[i]-\\'a\\'])\\n                {\\n                    if(t->child[s[i]-\\'a\\']->str)\\n                        return true;\\n                    t=t->child[s[i]-\\'a\\'];\\n                    --i;\\n                }\\n                else\\n                    return false;\\n            }\\n            return false;\\n        }\\n    };\\n    StreamChecker(vector<string>& words) {\\n        trie=new Trie();\\n        for(string word:words)\\n        {\\n            trie->insert(word);\\n        }\\n        st=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        st.push_back(letter);\\n        return trie->find(st);\\n    }\\nprivate:\\n    string st;\\n    Trie* trie;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807856,
                "title": "swift-simple-sweet",
                "content": "```\\nclass TrieNode {\\n    var isWord: Bool = false\\n    var chars = [Character: TrieNode]()\\n}\\n\\nclass StreamChecker {\\n    var queried = \"\"\\n    var root: TrieNode\\n    \\n    init(_ words: [String]) {\\n        root = TrieNode()\\n        \\n        for word in words {\\n            var node = root\\n            for char in word.reversed() {\\n                if node.chars[char] == nil {\\n                    node.chars[char] = TrieNode()\\n                }\\n                node = node.chars[char]!\\n            }\\n            node.isWord = true\\n        }\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        queried += String(letter)\\n        \\n        var node = root\\n        for char in queried.reversed() {\\n            if let next = node.chars[char] {\\n                if next.isWord { return true }\\n                node = next\\n            } else {\\n                break\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    var isWord: Bool = false\\n    var chars = [Character: TrieNode]()\\n}\\n\\nclass StreamChecker {\\n    var queried = \"\"\\n    var root: TrieNode\\n    \\n    init(_ words: [String]) {\\n        root = TrieNode()\\n        \\n        for word in words {\\n            var node = root\\n            for char in word.reversed() {\\n                if node.chars[char] == nil {\\n                    node.chars[char] = TrieNode()\\n                }\\n                node = node.chars[char]!\\n            }\\n            node.isWord = true\\n        }\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        queried += String(letter)\\n        \\n        var node = root\\n        for char in queried.reversed() {\\n            if let next = node.chars[char] {\\n                if next.isWord { return true }\\n                node = next\\n            } else {\\n                break\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807765,
                "title": "java-simple-trie-solution-2-versions",
                "content": "```\\nclass TrieNode {\\n\\t\\tMap<Character, TrieNode> children;\\n\\t\\tboolean isLeaf;\\n\\n\\t\\tTrieNode() {\\n\\t\\t\\tchildren = new HashMap<>();\\n\\t\\t\\tisLeaf = false;\\n\\t\\t}\\n\\n\\t\\tvoid insert(String word) {\\n\\t\\t\\tTrieNode current = this;\\n\\t\\t\\tfor (int i=word.length()-1; i>=0; i--) {\\n\\t\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\t\\tif (!current.children.containsKey(c)) {\\n\\t\\t\\t\\t\\tcurrent.children.put(c, new TrieNode());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrent.isLeaf = true;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass StreamChecker {\\n\\t\\tTrieNode root;\\n\\t\\tStringBuilder sb;\\n\\n\\t\\tpublic StreamChecker(String[] words) {\\n\\t\\t\\troot = new TrieNode();\\n\\t\\t\\tsb = new StringBuilder();\\n\\n\\t\\t\\tfor (String word : words) {\\n\\t\\t\\t\\troot.insert(word);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic boolean query(char letter) {\\n\\t\\t\\tsb.append(letter);\\n\\t\\t\\tTrieNode current = root;\\n\\n\\t\\t\\tfor (int i= sb.length()-1; i>=0; i--) {\\n\\t\\t\\t\\tchar c = sb.charAt(i);\\n\\t\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t\\t\\tif (current==null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tif (current!=null && current.isLeaf)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// NO reverse version\\n\\t\\n\\tclass TrieNode {\\n\\tMap<Character, TrieNode> children;\\n\\tboolean isLeaf;\\n\\n\\tTrieNode() {\\n\\t\\tchildren = new HashMap<>();\\n\\t\\tisLeaf = false;\\n\\t}\\n\\n\\tvoid insert(String word) {\\n\\t\\tTrieNode current = this;\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\tif (!current.children.containsKey(c)) {\\n\\t\\t\\t\\tcurrent.children.put(c, new TrieNode());\\n\\t\\t\\t}\\n\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t}\\n\\n\\t\\tcurrent.isLeaf = true;\\n\\t}\\n\\n}\\n\\npublic class StreamChecker {\\n\\tTrieNode root;\\n\\tQueue<TrieNode> q;\\n\\n\\tpublic StreamChecker(String[] words) {\\n\\t\\troot = new TrieNode();\\n\\t\\tq = new ArrayDeque<>();\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\troot.insert(word);\\n\\t\\t}\\n\\n\\t\\tq.add(root);\\n\\t}\\n\\n\\tpublic boolean query(char letter) {\\n\\t\\tboolean flag = false;\\n\\n\\t\\tint size = q.size();\\n\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tTrieNode n = q.poll();\\n\\n\\t\\t\\tif (n.children.containsKey(letter)) {\\n\\t\\t\\t\\tq.add(n.children.get(letter));\\n\\t\\t\\t\\tif (n.children.get(letter).isLeaf)\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (n == root)\\n\\t\\t\\t\\tq.add(root);\\n\\n\\t\\t}\\n\\n\\t\\treturn flag;\\n\\n\\t}\\n}\\n\\t\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TrieNode {\\n\\t\\tMap<Character, TrieNode> children;\\n\\t\\tboolean isLeaf;\\n\\n\\t\\tTrieNode() {\\n\\t\\t\\tchildren = new HashMap<>();\\n\\t\\t\\tisLeaf = false;\\n\\t\\t}\\n\\n\\t\\tvoid insert(String word) {\\n\\t\\t\\tTrieNode current = this;\\n\\t\\t\\tfor (int i=word.length()-1; i>=0; i--) {\\n\\t\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\t\\tif (!current.children.containsKey(c)) {\\n\\t\\t\\t\\t\\tcurrent.children.put(c, new TrieNode());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrent.isLeaf = true;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass StreamChecker {\\n\\t\\tTrieNode root;\\n\\t\\tStringBuilder sb;\\n\\n\\t\\tpublic StreamChecker(String[] words) {\\n\\t\\t\\troot = new TrieNode();\\n\\t\\t\\tsb = new StringBuilder();\\n\\n\\t\\t\\tfor (String word : words) {\\n\\t\\t\\t\\troot.insert(word);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic boolean query(char letter) {\\n\\t\\t\\tsb.append(letter);\\n\\t\\t\\tTrieNode current = root;\\n\\n\\t\\t\\tfor (int i= sb.length()-1; i>=0; i--) {\\n\\t\\t\\t\\tchar c = sb.charAt(i);\\n\\t\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t\\t\\tif (current==null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tif (current!=null && current.isLeaf)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// NO reverse version\\n\\t\\n\\tclass TrieNode {\\n\\tMap<Character, TrieNode> children;\\n\\tboolean isLeaf;\\n\\n\\tTrieNode() {\\n\\t\\tchildren = new HashMap<>();\\n\\t\\tisLeaf = false;\\n\\t}\\n\\n\\tvoid insert(String word) {\\n\\t\\tTrieNode current = this;\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\tif (!current.children.containsKey(c)) {\\n\\t\\t\\t\\tcurrent.children.put(c, new TrieNode());\\n\\t\\t\\t}\\n\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t}\\n\\n\\t\\tcurrent.isLeaf = true;\\n\\t}\\n\\n}\\n\\npublic class StreamChecker {\\n\\tTrieNode root;\\n\\tQueue<TrieNode> q;\\n\\n\\tpublic StreamChecker(String[] words) {\\n\\t\\troot = new TrieNode();\\n\\t\\tq = new ArrayDeque<>();\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\troot.insert(word);\\n\\t\\t}\\n\\n\\t\\tq.add(root);\\n\\t}\\n\\n\\tpublic boolean query(char letter) {\\n\\t\\tboolean flag = false;\\n\\n\\t\\tint size = q.size();\\n\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tTrieNode n = q.poll();\\n\\n\\t\\t\\tif (n.children.containsKey(letter)) {\\n\\t\\t\\t\\tq.add(n.children.get(letter));\\n\\t\\t\\t\\tif (n.children.get(letter).isLeaf)\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (n == root)\\n\\t\\t\\t\\tq.add(root);\\n\\n\\t\\t}\\n\\n\\t\\treturn flag;\\n\\n\\t}\\n}\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807744,
                "title": "java-solution-trie-accepted-clean-n-concise-commented",
                "content": "* Store the words in the trie data structure in reverse order. This will help to speed up the query function.\\n* Keep appending the  query letter parameter into the global String variable and then search for the string created in the trie.\\n* Whenever we encounter end of the word return true.\\n* **Pleas upvote if helpful!!**\\n```\\npublic class StreamChecker {\\n\\n    TrieDataStructure root = new TrieDataStructure();\\n\\n    String s = \"\";\\n\\n    public StreamChecker(String[] words) {\\n\\n\\n        for (int i = 0; i < words.length; i++) {\\n            \\n            TrieDataStructure current = root;\\n            String word = words[i];\\n\\t\\t\\t\\n            //store the words in trie data structure in REVERSE\\n\\t\\t\\t\\n            for (int j = word.length() - 1; j >= 0; j--) {\\n\\n                Character c = word.charAt(j);\\n                TrieDataStructure node = current.charMap.get(c);\\n\\n                if (node == null) {\\n                    \\n                    node = new TrieDataStructure();\\n                    current.charMap.put(c, node);\\n                    \\n                }\\n\\n                current = node;\\n\\n            }\\n\\n            current.isLastLetter = true;\\n        }\\n\\n    }\\n\\n    \\n    public boolean query(char letter) {\\n\\n        s = letter + s; //keep appending the letter at start of the string. and then search the word till u encounter last letter.\\n\\n        TrieDataStructure current = root;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            \\n            TrieDataStructure node = current.charMap.get(s.charAt(i));\\n            \\n            if (node != null) {\\n                current = node;\\n                if (current.isLastLetter) return true;  //imp to return when u encounter end of word or last letter\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return current.isLastLetter == true;\\n\\n    }\\n\\n//TRIE data structure\\n    class TrieDataStructure {\\n\\n        Map<Character, TrieDataStructure> charMap;\\n        boolean isLastLetter;\\n\\n        TrieDataStructure() {\\n            this.charMap = new HashMap<>();\\n            isLastLetter = false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class StreamChecker {\\n\\n    TrieDataStructure root = new TrieDataStructure();\\n\\n    String s = \"\";\\n\\n    public StreamChecker(String[] words) {\\n\\n\\n        for (int i = 0; i < words.length; i++) {\\n            \\n            TrieDataStructure current = root;\\n            String word = words[i];\\n\\t\\t\\t\\n            //store the words in trie data structure in REVERSE\\n\\t\\t\\t\\n            for (int j = word.length() - 1; j >= 0; j--) {\\n\\n                Character c = word.charAt(j);\\n                TrieDataStructure node = current.charMap.get(c);\\n\\n                if (node == null) {\\n                    \\n                    node = new TrieDataStructure();\\n                    current.charMap.put(c, node);\\n                    \\n                }\\n\\n                current = node;\\n\\n            }\\n\\n            current.isLastLetter = true;\\n        }\\n\\n    }\\n\\n    \\n    public boolean query(char letter) {\\n\\n        s = letter + s; //keep appending the letter at start of the string. and then search the word till u encounter last letter.\\n\\n        TrieDataStructure current = root;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            \\n            TrieDataStructure node = current.charMap.get(s.charAt(i));\\n            \\n            if (node != null) {\\n                current = node;\\n                if (current.isLastLetter) return true;  //imp to return when u encounter end of word or last letter\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return current.isLastLetter == true;\\n\\n    }\\n\\n//TRIE data structure\\n    class TrieDataStructure {\\n\\n        Map<Character, TrieDataStructure> charMap;\\n        boolean isLastLetter;\\n\\n        TrieDataStructure() {\\n            this.charMap = new HashMap<>();\\n            isLastLetter = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807637,
                "title": "python-weird-tle-when-using-trienode-objects-vs-dict",
                "content": "When I define a TrieNode class and use objects, the overhead of using them in Python leads to TLE. Using dicts on the other hand fits within the time limit. In a job interview one would expect the first solution to be slightly better, so I think the time limit could be adjusted to allow for that solution to pass as well. I think adding a couple seconds to TL would do it.\\n```\\nclass TrieNode:\\n    def __init__(self, is_end=False):\\n        self.children = {}  # char to trie node\\n        self.is_end = is_end\\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.root = TrieNode()\\n        for word in words:\\n            curnode = self.root\\n            for ch in word:\\n                if ch not in curnode.children:\\n                    curnode.children[ch] = TrieNode()\\n                curnode = curnode.children[ch]\\n            curnode.is_end = True\\n        self.leads = set([self.root]) # the pointers to the threads we follow right now\\n\\n    def query(self, letter: str) -> bool:\\n        next_leads = set([self.root])\\n        found_word = False\\n        for lead in self.leads:\\n            if letter in lead.children:\\n                next_leads.add(lead.children[letter])\\n                if lead.children[letter].is_end:\\n                    found_word = True\\n        self.leads = next_leads\\n        return found_word\\n```\\n\\nThe solution using dicts:\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = {}\\n        for word in words:\\n            curnode = self.root\\n            for ch in word:\\n                if ch not in curnode:\\n                    curnode[ch] = {}\\n                curnode = curnode[ch]\\n            curnode[\\'is_end\\'] = True\\n        self.leads = [self.root] # the pointers to the threads we follow right now\\n\\n    def query(self, letter: str) -> bool:\\n        next_leads = [self.root]\\n        found_word = False\\n        for lead in self.leads:\\n            if letter in lead:\\n                new_lead = lead[letter]\\n                next_leads.append(new_lead)\\n                if \\'is_end\\' in new_lead:\\n                    found_word = True\\n        self.leads = next_leads\\n        return found_word\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self, is_end=False):\\n        self.children = {}  # char to trie node\\n        self.is_end = is_end\\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.root = TrieNode()\\n        for word in words:\\n            curnode = self.root\\n            for ch in word:\\n                if ch not in curnode.children:\\n                    curnode.children[ch] = TrieNode()\\n                curnode = curnode.children[ch]\\n            curnode.is_end = True\\n        self.leads = set([self.root]) # the pointers to the threads we follow right now\\n\\n    def query(self, letter: str) -> bool:\\n        next_leads = set([self.root])\\n        found_word = False\\n        for lead in self.leads:\\n            if letter in lead.children:\\n                next_leads.add(lead.children[letter])\\n                if lead.children[letter].is_end:\\n                    found_word = True\\n        self.leads = next_leads\\n        return found_word\\n```\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = {}\\n        for word in words:\\n            curnode = self.root\\n            for ch in word:\\n                if ch not in curnode:\\n                    curnode[ch] = {}\\n                curnode = curnode[ch]\\n            curnode[\\'is_end\\'] = True\\n        self.leads = [self.root] # the pointers to the threads we follow right now\\n\\n    def query(self, letter: str) -> bool:\\n        next_leads = [self.root]\\n        found_word = False\\n        for lead in self.leads:\\n            if letter in lead:\\n                new_lead = lead[letter]\\n                next_leads.append(new_lead)\\n                if \\'is_end\\' in new_lead:\\n                    found_word = True\\n        self.leads = next_leads\\n        return found_word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807581,
                "title": "java-trie-easy-to-understand-with-comments",
                "content": "```\\nclass StreamChecker {    \\n    class TrieNode{\\n        final int N=26;\\n        TrieNode []child ;\\n        boolean  isWord; \\n        public TrieNode(){   \\n            child = new TrieNode[N];\\n            isWord = false;\\n        }  \\n    }   \\n    class Trie{\\n        TrieNode root;\\n        public Trie()\\n        {\\n           root = new TrieNode();  \\n        }\\n        // Put the word in reverse in trie \\n        public void insertReverse( String word){    \\n        TrieNode curr = root;\\n        for( int i= word.length()-1 ; i >= 0 ;i--){   \\n           char ch = word.charAt(i);\\n               if(curr.child[ch-\\'a\\'] == null)  \\n               {\\n                 curr.child[ch-\\'a\\'] = new TrieNode();  \\n               }  \\n            curr = curr.child[ch-\\'a\\'];\\n         }    \\n         curr.isWord= true;   \\n       }\\n    \\n       // serach the word in trie \\n       public boolean searchWord( String word){       \\n        TrieNode curr = root;\\n        for( int i= word.length()-1 ; i >= 0 ;i--){   \\n           char ch = word.charAt(i);\\n               if(curr.child[ch-\\'a\\'] == null)  \\n               {\\n                  return(false) ; \\n               }  \\n            curr = curr.child[ch-\\'a\\'];\\n            if(curr.isWord == true)  \\n                return(true);\\n         }    \\n         return(curr.isWord);\\n        }   \\n    }\\n    Trie  my_trie ;\\n    StringBuilder  queryWord ;\\n    public StreamChecker(String[] words) {\\n        my_trie = new Trie();\\n        queryWord = new StringBuilder(\"\");\\n        // Put each word in Trie .\\n        for( String word : words){\\n            my_trie.insertReverse(word);           \\n        }    \\n    }  \\n    public boolean query(char letter) {\\n       queryWord.append(letter) ;    \\n       return (my_trie.searchWord(queryWord.toString()));  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {    \\n    class TrieNode{\\n        final int N=26;\\n        TrieNode []child ;\\n        boolean  isWord; \\n        public TrieNode(){   \\n            child = new TrieNode[N];\\n            isWord = false;\\n        }  \\n    }   \\n    class Trie{\\n        TrieNode root;\\n        public Trie()\\n        {\\n           root = new TrieNode();  \\n        }\\n        // Put the word in reverse in trie \\n        public void insertReverse( String word){    \\n        TrieNode curr = root;\\n        for( int i= word.length()-1 ; i >= 0 ;i--){   \\n           char ch = word.charAt(i);\\n               if(curr.child[ch-\\'a\\'] == null)  \\n               {\\n                 curr.child[ch-\\'a\\'] = new TrieNode();  \\n               }  \\n            curr = curr.child[ch-\\'a\\'];\\n         }    \\n         curr.isWord= true;   \\n       }\\n    \\n       // serach the word in trie \\n       public boolean searchWord( String word){       \\n        TrieNode curr = root;\\n        for( int i= word.length()-1 ; i >= 0 ;i--){   \\n           char ch = word.charAt(i);\\n               if(curr.child[ch-\\'a\\'] == null)  \\n               {\\n                  return(false) ; \\n               }  \\n            curr = curr.child[ch-\\'a\\'];\\n            if(curr.isWord == true)  \\n                return(true);\\n         }    \\n         return(curr.isWord);\\n        }   \\n    }\\n    Trie  my_trie ;\\n    StringBuilder  queryWord ;\\n    public StreamChecker(String[] words) {\\n        my_trie = new Trie();\\n        queryWord = new StringBuilder(\"\");\\n        // Put each word in Trie .\\n        for( String word : words){\\n            my_trie.insertReverse(word);           \\n        }    \\n    }  \\n    public boolean query(char letter) {\\n       queryWord.append(letter) ;    \\n       return (my_trie.searchWord(queryWord.toString()));  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807292,
                "title": "rust-trie-with-reversed-words",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(PartialEq, Eq, Clone, Debug, Default)]\\nstruct Trie {\\n    children: HashMap<char, Trie>,\\n    end: bool,\\n}\\n\\nimpl Trie {\\n    fn new() -> Self {\\n        Self::default()\\n    }\\n\\n    fn insert(&mut self, word: String) {\\n        let mut link = self;\\n        for c in word.chars().rev() {\\n            link = link.children.entry(c).or_default();\\n        }\\n        link.end = true;\\n    }\\n\\n    fn search(&self, stream: &[char]) -> bool {\\n        let mut link = self;\\n        for c in stream.iter().rev() {\\n            if let Some(next) = link.children.get(&c) {\\n                link = next;\\n                if next.end {\\n                    return true;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        false\\n    }\\n}\\n\\nstruct StreamChecker {\\n    trie: Trie,\\n    stream: Vec<char>,\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut trie = Trie::new();\\n        for s in words {\\n            trie.insert(s);\\n        }\\n        let stream = vec![];\\n        StreamChecker { trie, stream }\\n    }\\n\\n    fn query(&mut self, letter: char) -> bool {\\n        self.stream.push(letter);\\n        self.trie.search(&self.stream)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(PartialEq, Eq, Clone, Debug, Default)]\\nstruct Trie {\\n    children: HashMap<char, Trie>,\\n    end: bool,\\n}\\n\\nimpl Trie {\\n    fn new() -> Self {\\n        Self::default()\\n    }\\n\\n    fn insert(&mut self, word: String) {\\n        let mut link = self;\\n        for c in word.chars().rev() {\\n            link = link.children.entry(c).or_default();\\n        }\\n        link.end = true;\\n    }\\n\\n    fn search(&self, stream: &[char]) -> bool {\\n        let mut link = self;\\n        for c in stream.iter().rev() {\\n            if let Some(next) = link.children.get(&c) {\\n                link = next;\\n                if next.end {\\n                    return true;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        false\\n    }\\n}\\n\\nstruct StreamChecker {\\n    trie: Trie,\\n    stream: Vec<char>,\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut trie = Trie::new();\\n        for s in words {\\n            trie.insert(s);\\n        }\\n        let stream = vec![];\\n        StreamChecker { trie, stream }\\n    }\\n\\n    fn query(&mut self, letter: char) -> bool {\\n        self.stream.push(letter);\\n        self.trie.search(&self.stream)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807235,
                "title": "my-c-trie-solution-o-words-length-memory-beats-70-o-word-length-queries-time",
                "content": "```\\nclass Trie_node{\\npublic:\\n    vector<Trie_node *> next;\\n    bool end;\\n    Trie_node()\\n    {\\n        next = std::vector<Trie_node *>(26,NULL);\\n        end = false;\\n    }\\n};\\n\\nclass Trie\\n{\\npublic:\\n    Trie_node *root;\\n    Trie(){\\n        root = new Trie_node();\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    void insert(string &word) {\\n        Trie_node *node = root;\\n        for(char c : word)\\n        {\\n            if(node ->next[c - \\'a\\'] == NULL)\\n                node ->next[c - \\'a\\'] = new Trie_node();\\n            node = node ->next[c - \\'a\\'];\\n        }\\n        node->end = true;\\n    }\\n    \\n    bool check(deque<char> &dq){\\n        Trie_node *node = root;\\n        auto ptr = dq.rbegin();\\n        while(ptr != dq.rend()){\\n            if(node->next[*ptr - \\'a\\'] == NULL)\\n                return false;\\n            node = node->next[*ptr - \\'a\\'];\\n            if(node->end)\\n                return true;\\n            ptr ++;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass StreamChecker {\\nprivate:\\n    Trie *helper;\\n    deque<char> dq;\\n    int max_s;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        max_s = 0;\\n        for(string &s: words){\\n            max_s = max(max_s, (int)s.size()); \\n            reverse(s.begin(), s.end());\\n        }\\n        helper = new Trie();\\n        for(auto &s: words)\\n            helper->insert(s);\\n    }\\n    \\n    bool query(char letter) {\\n        dq.push_back(letter);\\n        if(dq.size() > max_s){\\n            dq.pop_front();\\n        }\\n        return helper->check(dq);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie_node{\\npublic:\\n    vector<Trie_node *> next;\\n    bool end;\\n    Trie_node()\\n    {\\n        next = std::vector<Trie_node *>(26,NULL);\\n        end = false;\\n    }\\n};\\n\\nclass Trie\\n{\\npublic:\\n    Trie_node *root;\\n    Trie(){\\n        root = new Trie_node();\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    void insert(string &word) {\\n        Trie_node *node = root;\\n        for(char c : word)\\n        {\\n            if(node ->next[c - \\'a\\'] == NULL)\\n                node ->next[c - \\'a\\'] = new Trie_node();\\n            node = node ->next[c - \\'a\\'];\\n        }\\n        node->end = true;\\n    }\\n    \\n    bool check(deque<char> &dq){\\n        Trie_node *node = root;\\n        auto ptr = dq.rbegin();\\n        while(ptr != dq.rend()){\\n            if(node->next[*ptr - \\'a\\'] == NULL)\\n                return false;\\n            node = node->next[*ptr - \\'a\\'];\\n            if(node->end)\\n                return true;\\n            ptr ++;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass StreamChecker {\\nprivate:\\n    Trie *helper;\\n    deque<char> dq;\\n    int max_s;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        max_s = 0;\\n        for(string &s: words){\\n            max_s = max(max_s, (int)s.size()); \\n            reverse(s.begin(), s.end());\\n        }\\n        helper = new Trie();\\n        for(auto &s: words)\\n            helper->insert(s);\\n    }\\n    \\n    bool query(char letter) {\\n        dq.push_back(letter);\\n        if(dq.size() > max_s){\\n            dq.pop_front();\\n        }\\n        return helper->check(dq);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807195,
                "title": "c-trie-solution-doesn-t-need-to-store-all-letters-queried-so-far",
                "content": "```\\nclass Trie {\\n    public:\\n    vector<Trie*> next;\\n    bool isWord;\\n    Trie () {\\n        next = vector<Trie*>(26,nullptr);\\n        isWord = false;\\n    }\\n    void insert (string& s) {\\n        Trie* cur = this;\\n        for (char& c: s) {\\n            if (cur->next[c-\\'a\\']==nullptr) {\\n                cur->next[c-\\'a\\'] = new Trie();\\n            }\\n            cur = cur->next[c-\\'a\\'];\\n        }\\n        cur->isWord = true;\\n    }  \\n};\\nclass StreamChecker {\\n    Trie root;\\n    list<char> buffer;\\n    int W_MAX;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        W_MAX = 0;\\n        for (auto& w: words) {\\n            if (w.size() > W_MAX) W_MAX = w.size();\\n            reverse(w.begin(), w.end());\\n            root.insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        buffer.push_back(letter);\\n        if (buffer.size() == W_MAX+1) buffer.pop_front();\\n\\t\\t/*\\n\\t\\t * No point in writing input letters in an unbounded buffer.\\n         * the maximum size of the words from input list is W_MAX. We don\\'t need to store\\n         * more characters than that.\\n\\t\\t */\\n        Trie* cur = &root;\\n        for (auto it = buffer.rbegin(); it != buffer.rend(); ++it) {\\n            if (cur->isWord) return true;\\n            if (cur->next[*it -\\'a\\'] == nullptr) return false;\\n            cur = cur->next[*it-\\'a\\'];\\n        }\\n        return (cur->isWord);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\n    public:\\n    vector<Trie*> next;\\n    bool isWord;\\n    Trie () {\\n        next = vector<Trie*>(26,nullptr);\\n        isWord = false;\\n    }\\n    void insert (string& s) {\\n        Trie* cur = this;\\n        for (char& c: s) {\\n            if (cur->next[c-\\'a\\']==nullptr) {\\n                cur->next[c-\\'a\\'] = new Trie();\\n            }\\n            cur = cur->next[c-\\'a\\'];\\n        }\\n        cur->isWord = true;\\n    }  \\n};\\nclass StreamChecker {\\n    Trie root;\\n    list<char> buffer;\\n    int W_MAX;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        W_MAX = 0;\\n        for (auto& w: words) {\\n            if (w.size() > W_MAX) W_MAX = w.size();\\n            reverse(w.begin(), w.end());\\n            root.insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        buffer.push_back(letter);\\n        if (buffer.size() == W_MAX+1) buffer.pop_front();\\n\\t\\t/*\\n\\t\\t * No point in writing input letters in an unbounded buffer.\\n         * the maximum size of the words from input list is W_MAX. We don\\'t need to store\\n         * more characters than that.\\n\\t\\t */\\n        Trie* cur = &root;\\n        for (auto it = buffer.rbegin(); it != buffer.rend(); ++it) {\\n            if (cur->isWord) return true;\\n            if (cur->next[*it -\\'a\\'] == nullptr) return false;\\n            cur = cur->next[*it-\\'a\\'];\\n        }\\n        return (cur->isWord);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802360,
                "title": "java-trie-solution",
                "content": "```java\\n/*\\n* Problem: https://leetcode.com/problems/stream-of-characters\\n*\\n* Approach: Trie Tree\\n*/\\nclass StreamChecker {\\n    \\n    class TrieNode {\\n        boolean word = false;\\n        Map<Character, TrieNode> children = new HashMap<>();\\n    }\\n\\n    class TrieTree {\\n        TrieNode root = new TrieNode();\\n        public void insert(String s) {\\n            TrieNode current = root;\\n            for (int i = s.length()-1; i >= 0; i--) {\\n                current = current.children.computeIfAbsent(s.charAt(i), x -> new TrieNode());\\n            }\\n            current.word = true;\\n        }\\n\\n        public boolean search(StringBuilder builder) {\\n            TrieNode current = root;\\n            for (int i = builder.length()-1; i >= 0; i--) {\\n                char ch = builder.charAt(i);\\n                current = current.children.get(ch);\\n                if (current == null) return false;\\n                if (current.word) return true;\\n            }\\n            return false;\\n        }\\n    }\\n    \\n    TrieTree trie = new TrieTree();\\n    StringBuilder builder = new StringBuilder();\\n\\n    public StreamChecker(String[] words) {\\n        for (String word: words) {\\n            trie.insert(word);\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        builder.append(letter);\\n        return trie.search(builder);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/*\\n* Problem: https://leetcode.com/problems/stream-of-characters\\n*\\n* Approach: Trie Tree\\n*/\\nclass StreamChecker {\\n    \\n    class TrieNode {\\n        boolean word = false;\\n        Map<Character, TrieNode> children = new HashMap<>();\\n    }\\n\\n    class TrieTree {\\n        TrieNode root = new TrieNode();\\n        public void insert(String s) {\\n            TrieNode current = root;\\n            for (int i = s.length()-1; i >= 0; i--) {\\n                current = current.children.computeIfAbsent(s.charAt(i), x -> new TrieNode());\\n            }\\n            current.word = true;\\n        }\\n\\n        public boolean search(StringBuilder builder) {\\n            TrieNode current = root;\\n            for (int i = builder.length()-1; i >= 0; i--) {\\n                char ch = builder.charAt(i);\\n                current = current.children.get(ch);\\n                if (current == null) return false;\\n                if (current.word) return true;\\n            }\\n            return false;\\n        }\\n    }\\n    \\n    TrieTree trie = new TrieTree();\\n    StringBuilder builder = new StringBuilder();\\n\\n    public StreamChecker(String[] words) {\\n        for (String word: words) {\\n            trie.insert(word);\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        builder.append(letter);\\n        return trie.search(builder);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797400,
                "title": "simple-trie-solution",
                "content": "```\\nclass Node:\\n        def __init__(self,ch):\\n            self.ch=ch\\n            self.childs={}\\n            self.isend=False\\nclass Trie:\\n    def __init__(self):\\n        self.root=Node(\\'/\\')\\n    def insert(self,word):\\n        temp=self.root\\n        for i in word:\\n            if i not in temp.childs:\\n                nn=Node(i)\\n                temp.childs[i]=nn\\n                temp=nn\\n            else:\\n                temp=temp.childs[i]\\n        temp.isend=True\\n    def search(self,word):\\n        temp=self.root\\n        for i in word:\\n            \\n            if temp.isend:\\n                return True\\n            if i not in temp.childs:\\n                return False\\n            temp=temp.childs[i]\\n        return temp.isend\\n\\n    \\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.t=Trie()\\n        for i in words:\\n            self.t.insert(i[::-1])\\n        self.stream=\\'\\'\\n        \\n    def query(self, letter: str) -> bool:\\n        self.stream=letter+self.stream\\n        return self.t.search(self.stream)\\n        \\n        \\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n        def __init__(self,ch):\\n            self.ch=ch\\n            self.childs={}\\n            self.isend=False\\nclass Trie:\\n    def __init__(self):\\n        self.root=Node(\\'/\\')\\n    def insert(self,word):\\n        temp=self.root\\n        for i in word:\\n            if i not in temp.childs:\\n                nn=Node(i)\\n                temp.childs[i]=nn\\n                temp=nn\\n            else:\\n                temp=temp.childs[i]\\n        temp.isend=True\\n    def search(self,word):\\n        temp=self.root\\n        for i in word:\\n            \\n            if temp.isend:\\n                return True\\n            if i not in temp.childs:\\n                return False\\n            temp=temp.childs[i]\\n        return temp.isend\\n\\n    \\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.t=Trie()\\n        for i in words:\\n            self.t.insert(i[::-1])\\n        self.stream=\\'\\'\\n        \\n    def query(self, letter: str) -> bool:\\n        self.stream=letter+self.stream\\n        return self.t.search(self.stream)\\n        \\n        \\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785743,
                "title": "c-solution",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    struct TreeNode{\\n        vector<TreeNode *> nodes;\\n        bool isword;\\n        TreeNode(){\\n            nodes = vector<TreeNode *>(26,NULL);\\n            isword = false;\\n        }\\n    };\\n    \\n    TreeNode *root;\\n    string build;\\n    \\n    void insert(vector<string>& words)\\n    {\\n        for(string &s : words)\\n        {\\n            reverse(s.begin(),s.end());\\n            TreeNode *temp = root;\\n            for(char c : s)\\n            {\\n                if(!temp->nodes[c-\\'a\\']) temp->nodes[c-\\'a\\'] = new TreeNode();\\n                temp = temp->nodes[c-\\'a\\'];\\n            }\\n            temp->isword = true;\\n        }\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new TreeNode();\\n        build = \"\";\\n        insert(words);\\n    }\\n    \\n    bool query(char letter) {\\n        build += letter;\\n        TreeNode *temp = root;\\n        for(int i=build.size()-1; i>=0 && temp; i--)\\n        {\\n            temp = temp->nodes[build[i]-\\'a\\'];\\n            if(temp && temp->isword)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct TreeNode{\\n        vector<TreeNode *> nodes;\\n        bool isword;\\n        TreeNode(){\\n            nodes = vector<TreeNode *>(26,NULL);\\n            isword = false;\\n        }\\n    };\\n    \\n    TreeNode *root;\\n    string build;\\n    \\n    void insert(vector<string>& words)\\n    {\\n        for(string &s : words)\\n        {\\n            reverse(s.begin(),s.end());\\n            TreeNode *temp = root;\\n            for(char c : s)\\n            {\\n                if(!temp->nodes[c-\\'a\\']) temp->nodes[c-\\'a\\'] = new TreeNode();\\n                temp = temp->nodes[c-\\'a\\'];\\n            }\\n            temp->isword = true;\\n        }\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new TreeNode();\\n        build = \"\";\\n        insert(words);\\n    }\\n    \\n    bool query(char letter) {\\n        build += letter;\\n        TreeNode *temp = root;\\n        for(int i=build.size()-1; i>=0 && temp; i--)\\n        {\\n            temp = temp->nodes[build[i]-\\'a\\'];\\n            if(temp && temp->isword)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782467,
                "title": "concise-java-solution-trie-with-reversed-order",
                "content": "A dictionary and a list of letters, which easily makes one to come up with a solution of trie. If you are not familiar with trie, it is better to study this data structure now. Because it is asked frequently in an interview these days. \\nSo, with a trie we can check whether a string is in a dictionary efficiently. But in this question, it tells us to check the last k letters, which means we have to start from the last letter and trace back. To make our work easier, we just construct the trie with a reverse order:\\n```\\n[\"abc\", \"fc\", \"ae\"]\\nNormal order trie:  abc, fc, ae\\n           NA\\n\\t\\t  /  \\\\\\n\\t\\t a    f\\n\\t    /  \\\\  |\\n\\t   b    e c\\n\\t   |\\n\\t   c\\nReversed order trie: cba, cf, ea\\n           NA\\n\\t\\t  /  \\\\\\n\\t\\t c    e\\n\\t    /  \\\\  |\\n\\t   b    f a\\n\\t   |\\n\\t   a\\n```\\nWhenever we want to check a stream like \"abc\", we just start with the order \"c-b-a\" and search the reversed order trie. \\nTime complexity: O(nm) to construct the trie and O(h) for each query, where n is the length of the dictionary, m is the length of words in dictionary, and h is the height of trie. \\nSpace complexity: O(nm + q), where q is the number of characters we maintained in deque. As the max height of trie is h, so we can limit the size of q to be h. \\n```java\\nclass StreamChecker {\\n    Trie trie;\\n    Deque<Character> cur;\\n    int cap;\\n    public StreamChecker(String[] words) {\\n        trie = new Trie(words);\\n        cur = new ArrayDeque();\\n        cap = trie.height;\\n    }\\n    \\n    public boolean query(char letter) {\\n        cur.offerLast(letter);\\n        if(cur.size() > cap) cur.pollFirst();\\n        return trie.search(new ArrayList(cur));\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] next;\\n    boolean term;\\n    public TrieNode() {\\n        next = new TrieNode[26];\\n        term = false;\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode root;\\n    int height;\\n    public Trie(String[] words) {\\n        root = new TrieNode();\\n        height = 0;\\n        for(String word: words) {\\n            TrieNode cur = root;\\n            height = Math.max(height, word.length());\\n            for(int i = word.length() - 1; i >= 0; --i) {\\n                char c = word.charAt(i);\\n                if(cur.next[c-\\'a\\'] == null) cur.next[c-\\'a\\'] = new TrieNode();\\n                cur = cur.next[c-\\'a\\'];\\n            }\\n            cur.term = true;\\n        }\\n    }\\n    public boolean search(List<Character> s) {\\n        TrieNode cur = root;\\n        for(int i = s.size() - 1; i >= 0; --i) {\\n            char c = s.get(i);\\n            if(cur.next[c-\\'a\\'] == null) return false;\\n            cur = cur.next[c-\\'a\\'];\\n            if(cur.term) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[\"abc\", \"fc\", \"ae\"]\\nNormal order trie:  abc, fc, ae\\n           NA\\n\\t\\t  /  \\\\\\n\\t\\t a    f\\n\\t    /  \\\\  |\\n\\t   b    e c\\n\\t   |\\n\\t   c\\nReversed order trie: cba, cf, ea\\n           NA\\n\\t\\t  /  \\\\\\n\\t\\t c    e\\n\\t    /  \\\\  |\\n\\t   b    f a\\n\\t   |\\n\\t   a\\n```\n```java\\nclass StreamChecker {\\n    Trie trie;\\n    Deque<Character> cur;\\n    int cap;\\n    public StreamChecker(String[] words) {\\n        trie = new Trie(words);\\n        cur = new ArrayDeque();\\n        cap = trie.height;\\n    }\\n    \\n    public boolean query(char letter) {\\n        cur.offerLast(letter);\\n        if(cur.size() > cap) cur.pollFirst();\\n        return trie.search(new ArrayList(cur));\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] next;\\n    boolean term;\\n    public TrieNode() {\\n        next = new TrieNode[26];\\n        term = false;\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode root;\\n    int height;\\n    public Trie(String[] words) {\\n        root = new TrieNode();\\n        height = 0;\\n        for(String word: words) {\\n            TrieNode cur = root;\\n            height = Math.max(height, word.length());\\n            for(int i = word.length() - 1; i >= 0; --i) {\\n                char c = word.charAt(i);\\n                if(cur.next[c-\\'a\\'] == null) cur.next[c-\\'a\\'] = new TrieNode();\\n                cur = cur.next[c-\\'a\\'];\\n            }\\n            cur.term = true;\\n        }\\n    }\\n    public boolean search(List<Character> s) {\\n        TrieNode cur = root;\\n        for(int i = s.size() - 1; i >= 0; --i) {\\n            char c = s.get(i);\\n            if(cur.next[c-\\'a\\'] == null) return false;\\n            cur = cur.next[c-\\'a\\'];\\n            if(cur.term) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780343,
                "title": "with-only-stringbuilder-set-tle-16-17-tc-s-passed-help",
                "content": "If someone reads this solution it\\'d be really great if someone can help me improve this solution, without Trie.\\n\\n**Intuition:**\\nUsed hashset to store the words and look for it. We have to maintain a window of size of the word with max length. So once the size of the StringBuilder exceeds that length, we pop a char at the front. So essentially, sb acts as a queue here.\\nSo the time complexity of 1 query is O(maxlength(words))\\n```\\nclass StreamChecker {\\n    HashSet<String> dict = new HashSet<>();\\n    int window = 0;\\n    StringBuilder sb = new StringBuilder();\\n    public StreamChecker(String[] words) {\\n        for(String word :  words) {\\n            dict.add(word);\\n            window = Math.max(window, word.length());\\n        }\\n        \\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        if(sb.length() > window)\\n            sb.deleteCharAt(0);\\n        for(int i=0; i<sb.length();i++){\\n            if(dict.contains(sb.substring(i)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    HashSet<String> dict = new HashSet<>();\\n    int window = 0;\\n    StringBuilder sb = new StringBuilder();\\n    public StreamChecker(String[] words) {\\n        for(String word :  words) {\\n            dict.add(word);\\n            window = Math.max(window, word.length());\\n        }\\n        \\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        if(sb.length() > window)\\n            sb.deleteCharAt(0);\\n        for(int i=0; i<sb.length();i++){\\n            if(dict.contains(sb.substring(i)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722152,
                "title": "trie-solution-with-full-explanation",
                "content": "**Idea:**\\n* Since, the problem involves in searching for a word from dictionary, trie seems a good intuition to think about for useful data structures.\\n* Here, we need to see if the words are present in dictionary from any last `k` queried characters. \\n* Hence, we can create a trie of *reversed* words, and pass the list of character `queries` to search in reverse. \\n\\n```\\nclass StreamChecker {\\n\\n    private class TrieNode {\\n        Map<Character, TrieNode> map;\\n        boolean isEnd;\\n        \\n        TrieNode() {\\n            map = new HashMap<>();\\n            isEnd = false;\\n        }\\n    }\\n    \\n    private class Trie {\\n        TrieNode root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        void addReversedWord(String word) {\\n            TrieNode cur = root;\\n            \\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                char ch = word.charAt(i);\\n                cur.map.putIfAbsent(ch, new TrieNode());\\n                cur = cur.map.get(ch);\\n            }\\n            \\n            cur.isEnd = true;\\n        }\\n        \\n        boolean search(Deque<Character> dq) {\\n            TrieNode cur = root;\\n            for (char ch : dq) {\\n                if (!cur.map.containsKey(ch)) {\\n                    return false;\\n                }\\n                cur = cur.map.get(ch);\\n                if (cur.isEnd) {\\n                    return true;\\n                }\\n            }\\n            \\n            return cur.isEnd;\\n        }\\n    }\\n    \\n    private int maxLen = 0;\\n    private Trie t;\\n    Deque<Character> dq;\\n    \\n    public StreamChecker(String[] words) {\\n        t = new Trie();\\n        for (String word: words) {\\n            maxLen = Math.max(maxLen, word.length());\\n            t.addReversedWord(word);\\n        }\\n        dq = new ArrayDeque<>();\\n    }\\n    \\n    public boolean query(char letter) {\\n        dq.addFirst(letter);\\n        if (dq.size() > maxLen) {\\n            dq.removeLast();\\n        }\\n        \\n        return t.search(dq);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n\\n    private class TrieNode {\\n        Map<Character, TrieNode> map;\\n        boolean isEnd;\\n        \\n        TrieNode() {\\n            map = new HashMap<>();\\n            isEnd = false;\\n        }\\n    }\\n    \\n    private class Trie {\\n        TrieNode root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        void addReversedWord(String word) {\\n            TrieNode cur = root;\\n            \\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                char ch = word.charAt(i);\\n                cur.map.putIfAbsent(ch, new TrieNode());\\n                cur = cur.map.get(ch);\\n            }\\n            \\n            cur.isEnd = true;\\n        }\\n        \\n        boolean search(Deque<Character> dq) {\\n            TrieNode cur = root;\\n            for (char ch : dq) {\\n                if (!cur.map.containsKey(ch)) {\\n                    return false;\\n                }\\n                cur = cur.map.get(ch);\\n                if (cur.isEnd) {\\n                    return true;\\n                }\\n            }\\n            \\n            return cur.isEnd;\\n        }\\n    }\\n    \\n    private int maxLen = 0;\\n    private Trie t;\\n    Deque<Character> dq;\\n    \\n    public StreamChecker(String[] words) {\\n        t = new Trie();\\n        for (String word: words) {\\n            maxLen = Math.max(maxLen, word.length());\\n            t.addReversedWord(word);\\n        }\\n        dq = new ArrayDeque<>();\\n    }\\n    \\n    public boolean query(char letter) {\\n        dq.addFirst(letter);\\n        if (dq.size() > maxLen) {\\n            dq.removeLast();\\n        }\\n        \\n        return t.search(dq);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703255,
                "title": "python-3-652-ms-faster-than-84-39-37-5-mb-less-than-82-30",
                "content": "I initially went for this solution which got TLE:\\n\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.t, self.h = {}, []\\n        for i in words:\\n            ct = self.t\\n            for j in i[::-1]:\\n                if j not in ct: ct[j] = {}\\n                ct = ct[j]\\n            ct[1] = True\\n\\n    def query(self, letter: str) -> bool:\\n        ct = self.t\\n        self.h.append(letter)\\n        for i in self.h[::-1]:\\n            if i not in ct: return False\\n            ct = ct[i]\\n            if 1 in ct: return True\\n        return False\\n```\\n\\nThan I made a small change which I borrowed from one of lee215\\'s solutions posted in the discussion thread:\\n\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.t, self.h = {}, \\'\\'\\n        for i in words:\\n            ct = self.t\\n            for j in i[::-1]:\\n                if j not in ct: ct[j] = {}\\n                ct = ct[j]\\n            ct[1] = True\\n\\n    def query(self, letter: str) -> bool:\\n        ct, self.h = self.t, letter + self.h\\n        for i in self.h:\\n            if i not in ct: return False\\n            ct = ct[i]\\n            if 1 in ct: return True\\n        return False\\n```\\n\\nApparently, this small change makes a big difference.",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.t, self.h = {}, []\\n        for i in words:\\n            ct = self.t\\n            for j in i[::-1]:\\n                if j not in ct: ct[j] = {}\\n                ct = ct[j]\\n            ct[1] = True\\n\\n    def query(self, letter: str) -> bool:\\n        ct = self.t\\n        self.h.append(letter)\\n        for i in self.h[::-1]:\\n            if i not in ct: return False\\n            ct = ct[i]\\n            if 1 in ct: return True\\n        return False\\n```\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.t, self.h = {}, \\'\\'\\n        for i in words:\\n            ct = self.t\\n            for j in i[::-1]:\\n                if j not in ct: ct[j] = {}\\n                ct = ct[j]\\n            ct[1] = True\\n\\n    def query(self, letter: str) -> bool:\\n        ct, self.h = self.t, letter + self.h\\n        for i in self.h:\\n            if i not in ct: return False\\n            ct = ct[i]\\n            if 1 in ct: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653776,
                "title": "c-suffix-tree-540ms",
                "content": "Idea: Use suffix tree instead of prefix tree to allow efficient histroy search, since that works in a backward way.\\n\\n```c++\\nclass TrieNode {\\npublic:\\n    TrieNode() : word_end(false) {\\n        children = vector<TrieNode*>(alphabet_size);\\n    }\\n\\n    ~TrieNode() {\\n        for (auto child : children) {\\n            if (child)\\n                delete child;\\n        }\\n    }\\n\\n    TrieNode* get(char ch) {\\n        int idx = ch - \\'a\\';\\n        return children[idx];\\n    }\\n\\n    void set(char ch) {\\n        int idx = ch - \\'a\\';\\n        children[idx] = new TrieNode();\\n    }\\n\\n    bool isEnd() {\\n        return word_end;\\n    }\\n\\n    void setEnd() {\\n        word_end = true;\\n    }\\n\\nprivate:\\n    static constexpr int alphabet_size = 26;\\n    bool word_end;\\n    vector<TrieNode*> children;\\n};\\n\\nclass Trie {\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    ~Trie() {\\n        delete root;\\n    }\\n\\n    void reverseInsert(const string& word) {\\n        TrieNode* node = root;\\n        for (int i = word.size() - 1; i >= 0; i--) {\\n            char ch = word[i];\\n            if (!node->get(ch)) {\\n                node->set(ch);\\n            }\\n            node = node->get(ch);\\n        }\\n        node->setEnd();\\n    }\\n\\n    bool historySearch(deque<char>& history) {\\n        TrieNode* node = root;\\n        for (int i = history.size() - 1; i >= 0; i--) {\\n            node = node->get(history[i]);\\n            if (!node)\\n                break;\\n            if (node->isEnd())\\n                return true;\\n        }\\n        return false;\\n    }\\n\\nprivate:\\n    TrieNode* root;\\n};\\n\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for (string &word : words)\\n            trie.reverseInsert(word);\\n    }\\n\\n    bool query(char letter) {\\n        history.push_back(letter);\\n        if (history.size() > wordLenLimit)\\n            history.pop_front();\\n\\n        return trie.historySearch(history);\\n    }\\n\\nprivate:\\n    Trie trie;\\n    const int wordLenLimit = 2000;\\n    deque<char> history;\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass TrieNode {\\npublic:\\n    TrieNode() : word_end(false) {\\n        children = vector<TrieNode*>(alphabet_size);\\n    }\\n\\n    ~TrieNode() {\\n        for (auto child : children) {\\n            if (child)\\n                delete child;\\n        }\\n    }\\n\\n    TrieNode* get(char ch) {\\n        int idx = ch - \\'a\\';\\n        return children[idx];\\n    }\\n\\n    void set(char ch) {\\n        int idx = ch - \\'a\\';\\n        children[idx] = new TrieNode();\\n    }\\n\\n    bool isEnd() {\\n        return word_end;\\n    }\\n\\n    void setEnd() {\\n        word_end = true;\\n    }\\n\\nprivate:\\n    static constexpr int alphabet_size = 26;\\n    bool word_end;\\n    vector<TrieNode*> children;\\n};\\n\\nclass Trie {\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    ~Trie() {\\n        delete root;\\n    }\\n\\n    void reverseInsert(const string& word) {\\n        TrieNode* node = root;\\n        for (int i = word.size() - 1; i >= 0; i--) {\\n            char ch = word[i];\\n            if (!node->get(ch)) {\\n                node->set(ch);\\n            }\\n            node = node->get(ch);\\n        }\\n        node->setEnd();\\n    }\\n\\n    bool historySearch(deque<char>& history) {\\n        TrieNode* node = root;\\n        for (int i = history.size() - 1; i >= 0; i--) {\\n            node = node->get(history[i]);\\n            if (!node)\\n                break;\\n            if (node->isEnd())\\n                return true;\\n        }\\n        return false;\\n    }\\n\\nprivate:\\n    TrieNode* root;\\n};\\n\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for (string &word : words)\\n            trie.reverseInsert(word);\\n    }\\n\\n    bool query(char letter) {\\n        history.push_back(letter);\\n        if (history.size() > wordLenLimit)\\n            history.pop_front();\\n\\n        return trie.historySearch(history);\\n    }\\n\\nprivate:\\n    Trie trie;\\n    const int wordLenLimit = 2000;\\n    deque<char> history;\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 620468,
                "title": "python3-trie",
                "content": "a) Create a Trie of reversed strings\\nb) For each letter try to iterate over all inserted letters in query and search them over the trie\\n```\\nfrom collections import defaultdict\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.is_word = False\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = TrieNode()\\n        for word in words:\\n            trie = self.trie\\n            rev = word[::-1]\\n            for char in rev:\\n                trie = trie.children[char]\\n            trie.is_word = True\\n        self.stk = []\\n    \\n    def query(self, letter: str) -> bool:\\n        trie = self.trie\\n        self.stk.append(letter)\\n        for i in range(len(self.stk)-1, -1, -1):\\n            let = self.stk[i]\\n            if trie.is_word:\\n                return True\\n            if let not in trie.children:\\n                return False\\n            trie = trie.children[let]\\n        return trie.is_word\\n            \\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.is_word = False\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = TrieNode()\\n        for word in words:\\n            trie = self.trie\\n            rev = word[::-1]\\n            for char in rev:\\n                trie = trie.children[char]\\n            trie.is_word = True\\n        self.stk = []\\n    \\n    def query(self, letter: str) -> bool:\\n        trie = self.trie\\n        self.stk.append(letter)\\n        for i in range(len(self.stk)-1, -1, -1):\\n            let = self.stk[i]\\n            if trie.is_word:\\n                return True\\n            if let not in trie.children:\\n                return False\\n            trie = trie.children[let]\\n        return trie.is_word\\n            \\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613610,
                "title": "c-14-lines-simple-solution-sorted-set-without-trie",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    \\n    StreamChecker(const vector<string>& words) {\\n        for (const string& w : words) words_.emplace(w.rbegin(), w.rend());\\n    }\\n    \\n    bool query(char letter) {\\n        stream_ += letter;\\n        string pref;\\n        for (int k=0; k < stream_.size(); k++) {\\n            pref += stream_[stream_.size() - 1 - k];\\n            \\n            auto begin = words_.lower_bound(pref);\\n            pref.back()++;\\n            auto end = words_.lower_bound(pref);\\n            pref.back()--;\\n            \\n            if (begin == end) return false;\\n            if (*begin == pref) return true;\\n        }\\n        return false;\\n    }\\n\\n    string stream_;\\n    set<string> words_;\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    \\n    StreamChecker(const vector<string>& words) {\\n        for (const string& w : words) words_.emplace(w.rbegin(), w.rend());\\n    }\\n    \\n    bool query(char letter) {\\n        stream_ += letter;\\n        string pref;\\n        for (int k=0; k < stream_.size(); k++) {\\n            pref += stream_[stream_.size() - 1 - k];\\n            \\n            auto begin = words_.lower_bound(pref);\\n            pref.back()++;\\n            auto end = words_.lower_bound(pref);\\n            pref.back()--;\\n            \\n            if (begin == end) return false;\\n            if (*begin == pref) return true;\\n        }\\n        return false;\\n    }\\n\\n    string stream_;\\n    set<string> words_;\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */```",
                "codeTag": "Java"
            },
            {
                "id": 611580,
                "title": "java-very-easy-a-trie-solution-with-explanation",
                "content": "```\\nclass StreamChecker {\\n    private class Trie {\\n        Map<Character, Trie> map = new HashMap<>();\\n        boolean isLast;\\n    }\\n    \\n    private final Trie trie;\\n    private final FixedRotationList history;\\n\\n    public StreamChecker(String[] words) {\\n        this.trie = new Trie();\\n        this.history = new FixedRotationList();\\n        \\n        \\n        for (String word : words) {\\n            Trie cur = this.trie;\\n            \\n            char[] arr = word.toCharArray();\\n            \\n            /**\\n            * we use a reverse trie so we fill it in reverse order\\n            */\\n            for (int i = arr.length-1; i >= 0; i--) { // insert into the tree\\n                if (!cur.map.containsKey(arr[i])) {\\n                    cur.map.put(arr[i], new Trie());\\n                } \\n                \\n                cur = cur.map.get(arr[i]);            \\n            }\\n            \\n            cur.isLast = true;\\n        }\\n    }\\n    \\n    \\n    \\n    public boolean query(char letter) {\\n        history.add(letter);\\n\\n        Trie cur = this.trie; // get a link in order update it futher\\n        \\n        /**\\n        * insofar we use the reverse trie, so we iterate in reverse order\\n        */\\n        for (int i = history.size()-1; i >= 0; i--) {\\n            Character curLetter = history.get(i); \\n\\n            if (cur == null || !cur.map.containsKey(curLetter)) return false;\\n\\n            if (cur.map.containsKey(curLetter) && cur.map.get(curLetter).isLast) return true;\\n\\n            cur = cur.map.get(curLetter);\\n        }\\n\\n        return false;\\n    }\\n}\\n\\nclass FixedRotationList {\\n    private final int MAX_LENGTH = 2_000;\\n    private List<Character> list = new ArrayList<>(MAX_LENGTH);\\n    private int curLen = 0;\\n    \\n    public int size() {\\n        return list.size();\\n    }\\n    \\n    public Character get(int idx) {\\n        if (list.isEmpty())\\n            return null;\\n\\n        if (list.size() < MAX_LENGTH)\\n            return list.get(idx);\\n\\n\\n        idx = (idx + curLen) % MAX_LENGTH;\\n\\n        return list.get(idx);\\n    }\\n\\n    public void add(char letter) {\\n        if (curLen >= MAX_LENGTH) {\\n            list.set(curLen%MAX_LENGTH, letter);\\n        } else {\\n            list.add(letter);\\n        }\\n\\n\\n        curLen++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n    private class Trie {\\n        Map<Character, Trie> map = new HashMap<>();\\n        boolean isLast;\\n    }\\n    \\n    private final Trie trie;\\n    private final FixedRotationList history;\\n\\n    public StreamChecker(String[] words) {\\n        this.trie = new Trie();\\n        this.history = new FixedRotationList();\\n        \\n        \\n        for (String word : words) {\\n            Trie cur = this.trie;\\n            \\n            char[] arr = word.toCharArray();\\n            \\n            /**\\n            * we use a reverse trie so we fill it in reverse order\\n            */\\n            for (int i = arr.length-1; i >= 0; i--) { // insert into the tree\\n                if (!cur.map.containsKey(arr[i])) {\\n                    cur.map.put(arr[i], new Trie());\\n                } \\n                \\n                cur = cur.map.get(arr[i]);            \\n            }\\n            \\n            cur.isLast = true;\\n        }\\n    }\\n    \\n    \\n    \\n    public boolean query(char letter) {\\n        history.add(letter);\\n\\n        Trie cur = this.trie; // get a link in order update it futher\\n        \\n        /**\\n        * insofar we use the reverse trie, so we iterate in reverse order\\n        */\\n        for (int i = history.size()-1; i >= 0; i--) {\\n            Character curLetter = history.get(i); \\n\\n            if (cur == null || !cur.map.containsKey(curLetter)) return false;\\n\\n            if (cur.map.containsKey(curLetter) && cur.map.get(curLetter).isLast) return true;\\n\\n            cur = cur.map.get(curLetter);\\n        }\\n\\n        return false;\\n    }\\n}\\n\\nclass FixedRotationList {\\n    private final int MAX_LENGTH = 2_000;\\n    private List<Character> list = new ArrayList<>(MAX_LENGTH);\\n    private int curLen = 0;\\n    \\n    public int size() {\\n        return list.size();\\n    }\\n    \\n    public Character get(int idx) {\\n        if (list.isEmpty())\\n            return null;\\n\\n        if (list.size() < MAX_LENGTH)\\n            return list.get(idx);\\n\\n\\n        idx = (idx + curLen) % MAX_LENGTH;\\n\\n        return list.get(idx);\\n    }\\n\\n    public void add(char letter) {\\n        if (curLen >= MAX_LENGTH) {\\n            list.set(curLen%MAX_LENGTH, letter);\\n        } else {\\n            list.add(letter);\\n        }\\n\\n\\n        curLen++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570901,
                "title": "java-simple-code-trie-reverse-words",
                "content": "```\\nclass StreamChecker {\\n\\n    class TrieNode {\\n        boolean isWord = false;\\n        TrieNode[] children = new TrieNode[26];\\n    }\\n    \\n    TrieNode root = new TrieNode();\\n    List<Character> list = new ArrayList<>();\\n    \\n    public StreamChecker(String[] words) {\\n        for (String s : words) {\\n            TrieNode node = root;\\n            for (int i = s.length()-1; i >= 0; i--) {\\n                if (node.children[s.charAt(i)-\\'a\\'] == null) {\\n                    node.children[s.charAt(i)-\\'a\\'] = new TrieNode();    \\n                }                \\n                node = node.children[s.charAt(i)-\\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        list.add(letter);\\n        TrieNode node = root;\\n        for (int i = list.size()-1; i >= 0; i--) {\\n            TrieNode next = node.children[list.get(i)-\\'a\\'];\\n            if (next == null) return false;\\n            if (next.isWord) return true;\\n            node = next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n\\n    class TrieNode {\\n        boolean isWord = false;\\n        TrieNode[] children = new TrieNode[26];\\n    }\\n    \\n    TrieNode root = new TrieNode();\\n    List<Character> list = new ArrayList<>();\\n    \\n    public StreamChecker(String[] words) {\\n        for (String s : words) {\\n            TrieNode node = root;\\n            for (int i = s.length()-1; i >= 0; i--) {\\n                if (node.children[s.charAt(i)-\\'a\\'] == null) {\\n                    node.children[s.charAt(i)-\\'a\\'] = new TrieNode();    \\n                }                \\n                node = node.children[s.charAt(i)-\\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        list.add(letter);\\n        TrieNode node = root;\\n        for (int i = list.size()-1; i >= 0; i--) {\\n            TrieNode next = node.children[list.get(i)-\\'a\\'];\\n            if (next == null) return false;\\n            if (next.isWord) return true;\\n            node = next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555180,
                "title": "short-and-simple-java-trie-solution",
                "content": "```\\nclass StreamChecker {\\n    private List<Character> list;\\n    private TrieNode root;\\n    \\n    public StreamChecker(String[] words) {\\n        list = new ArrayList<>();\\n        root = new TrieNode();\\n        for (String word : words) {\\n            TrieNode curr = root;\\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                char c = word.charAt(i);\\n                if (curr.next[c - \\'a\\'] == null) curr.next[c - \\'a\\'] = new TrieNode();\\n                curr = curr.next[c - \\'a\\'];\\n            }\\n            curr.isWord = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        list.add(letter);\\n        TrieNode curr = root;\\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            char c = list.get(i);\\n            curr = curr.next[c - \\'a\\'];\\n            if (curr == null) return false;\\n            if (curr.isWord) return true;\\n        }\\n        return false;\\n    }\\n\\t\\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.next = new TrieNode[26];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    private List<Character> list;\\n    private TrieNode root;\\n    \\n    public StreamChecker(String[] words) {\\n        list = new ArrayList<>();\\n        root = new TrieNode();\\n        for (String word : words) {\\n            TrieNode curr = root;\\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                char c = word.charAt(i);\\n                if (curr.next[c - \\'a\\'] == null) curr.next[c - \\'a\\'] = new TrieNode();\\n                curr = curr.next[c - \\'a\\'];\\n            }\\n            curr.isWord = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        list.add(letter);\\n        TrieNode curr = root;\\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            char c = list.get(i);\\n            curr = curr.next[c - \\'a\\'];\\n            if (curr == null) return false;\\n            if (curr.isWord) return true;\\n        }\\n        return false;\\n    }\\n\\t\\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.next = new TrieNode[26];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545143,
                "title": "easy-straightforward-solution-using-trie-on-c-language",
                "content": "```\\nint pos;\\ntypedef struct StreamChecker {\\n    int isLeaf;\\n    struct StreamChecker *child[26];\\n} StreamChecker;\\n\\nstruct StreamChecker* create(){\\n    struct StreamChecker* node = (struct StreamChecker*)malloc(sizeof(struct StreamChecker));\\n    int i;\\n    for(i=0;i<26;i++){\\n        node->child[i]=NULL;\\n    }\\n    node->isLeaf = 0;\\n    return node;\\n}\\nvoid insert(struct StreamChecker* root, char word[]){\\n    int i,index;\\n    struct StreamChecker* cur = root;\\n    //printf(\"%s\\\\n\",word);\\n    for(i=0;word[i];i++){\\n        index = word[i]-\\'a\\';\\n        if(!cur->child[index]){\\n            cur->child[index]=create();\\n        }\\n        cur=cur->child[index];\\n    }\\n    cur->isLeaf = 1;\\n}\\nvoid reverse(StreamChecker* root, char w[]){\\n    int i,j=0;\\n    char word[2005];\\n    for(i=0;w[i];i++);\\n    i--;\\n    while(i>=0){\\n        word[j++]=w[i];\\n        i--;\\n    }\\n    word[j]=\\'\\\\0\\';\\n   // printf(\"%s\\\\n\",word);\\n    insert(root, word); \\n}\\nStreamChecker* streamCheckerCreate(char ** words, int wSize) {\\n    struct StreamChecker* root = create();\\n    int i;pos=-1;\\n    for(i=0;i<wSize;i++){\\n        reverse(root,words[i]);\\n    }\\n    return root;\\n}\\nbool check(StreamChecker* obj, char letArr[], int j){\\n    int i,index;\\n    StreamChecker* cur = obj;\\n    while(j>=0){\\n        index = letArr[j]-\\'a\\';\\n        if(!cur->child[index]){\\n            //printf(\"False for %c\\\\n\",(char)(index+\\'a\\'));\\n            return false;\\n        }\\n        cur = cur->child[index];\\n        if(cur->isLeaf)\\n        {//printf(\"True for %c\\\\n\",(char)(index+\\'a\\'));\\n            return true;}\\n        j--;\\n    }\\n    return false;\\n}\\n\\nbool streamCheckerQuery(StreamChecker* obj, char letter) {\\n    char letArr[400005]; // This is a bug;\\n    letArr[++pos] = letter;\\n    return check(obj, letArr, pos);\\n}\\n\\nvoid streamCheckerFree(StreamChecker* obj) {\\n    int i;\\n    for(i=0;i<26;i++){\\n        if(obj->child[i]){\\n            streamCheckerFree(obj->child[i]);\\n        }\\n    }\\n    free(obj);\\n}\\n\\n/**\\n * Your StreamChecker struct will be instantiated and called as such:\\n * StreamChecker* obj = streamCheckerCreate(words, wordsSize);\\n * bool param_1 = streamCheckerQuery(obj, letter);\\n \\n * streamCheckerFree(obj);\\n*/\\n``",
                "solutionTags": [],
                "code": "```\\nint pos;\\ntypedef struct StreamChecker {\\n    int isLeaf;\\n    struct StreamChecker *child[26];\\n} StreamChecker;\\n\\nstruct StreamChecker* create(){\\n    struct StreamChecker* node = (struct StreamChecker*)malloc(sizeof(struct StreamChecker));\\n    int i;\\n    for(i=0;i<26;i++){\\n        node->child[i]=NULL;\\n    }\\n    node->isLeaf = 0;\\n    return node;\\n}\\nvoid insert(struct StreamChecker* root, char word[]){\\n    int i,index;\\n    struct StreamChecker* cur = root;\\n    //printf(\"%s\\\\n\",word);\\n    for(i=0;word[i];i++){\\n        index = word[i]-\\'a\\';\\n        if(!cur->child[index]){\\n            cur->child[index]=create();\\n        }\\n        cur=cur->child[index];\\n    }\\n    cur->isLeaf = 1;\\n}\\nvoid reverse(StreamChecker* root, char w[]){\\n    int i,j=0;\\n    char word[2005];\\n    for(i=0;w[i];i++);\\n    i--;\\n    while(i>=0){\\n        word[j++]=w[i];\\n        i--;\\n    }\\n    word[j]=\\'\\\\0\\';\\n   // printf(\"%s\\\\n\",word);\\n    insert(root, word); \\n}\\nStreamChecker* streamCheckerCreate(char ** words, int wSize) {\\n    struct StreamChecker* root = create();\\n    int i;pos=-1;\\n    for(i=0;i<wSize;i++){\\n        reverse(root,words[i]);\\n    }\\n    return root;\\n}\\nbool check(StreamChecker* obj, char letArr[], int j){\\n    int i,index;\\n    StreamChecker* cur = obj;\\n    while(j>=0){\\n        index = letArr[j]-\\'a\\';\\n        if(!cur->child[index]){\\n            //printf(\"False for %c\\\\n\",(char)(index+\\'a\\'));\\n            return false;\\n        }\\n        cur = cur->child[index];\\n        if(cur->isLeaf)\\n        {//printf(\"True for %c\\\\n\",(char)(index+\\'a\\'));\\n            return true;}\\n        j--;\\n    }\\n    return false;\\n}\\n\\nbool streamCheckerQuery(StreamChecker* obj, char letter) {\\n    char letArr[400005]; // This is a bug;\\n    letArr[++pos] = letter;\\n    return check(obj, letArr, pos);\\n}\\n\\nvoid streamCheckerFree(StreamChecker* obj) {\\n    int i;\\n    for(i=0;i<26;i++){\\n        if(obj->child[i]){\\n            streamCheckerFree(obj->child[i]);\\n        }\\n    }\\n    free(obj);\\n}\\n\\n/**\\n * Your StreamChecker struct will be instantiated and called as such:\\n * StreamChecker* obj = streamCheckerCreate(words, wordsSize);\\n * bool param_1 = streamCheckerQuery(obj, letter);\\n \\n * streamCheckerFree(obj);\\n*/\\n``",
                "codeTag": "Python3"
            },
            {
                "id": 540828,
                "title": "java-ac-and-slow",
                "content": "\\n```\\nclass StreamChecker {\\n    Trie trie = new Trie();\\n    public StreamChecker(String[] words) {\\n        \\n        for(String word : words) {\\n            trie.add(new StringBuilder(word).reverse().toString());\\n        }\\n    }\\n    StringBuilder sb = new StringBuilder();\\n    public boolean query(char letter) {\\n        sb.insert(0, letter);\\n        if(trie.root.chars[letter-\\'a\\'] != null) {\\n             if(trie.findPrefix(sb.toString())){\\n                 return true;\\n             }   \\n        }\\n        return false;\\n    }\\n    \\n    \\n    class TrieNode {\\n        TrieNode [] chars = new TrieNode[26];\\n        boolean isWord = false;            \\n    } \\n    \\n    \\n    class Trie {\\n        \\n        TrieNode root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        public void add(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) {\\n                    cur.chars[c-\\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.chars[c-\\'a\\'];\\n            }\\n            cur.isWord = true;\\n        }\\n        \\n        public boolean find(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) return false;\\n                cur = cur.chars[c-\\'a\\'];\\n            }\\n            return cur.isWord;\\n        }\\n        \\n        \\n        public boolean findPrefix(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) return false;\\n                cur = cur.chars[c-\\'a\\'];\\n                if(cur.isWord) return true;\\n            }\\n            return false;\\n        }\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "\\n```\\nclass StreamChecker {\\n    Trie trie = new Trie();\\n    public StreamChecker(String[] words) {\\n        \\n        for(String word : words) {\\n            trie.add(new StringBuilder(word).reverse().toString());\\n        }\\n    }\\n    StringBuilder sb = new StringBuilder();\\n    public boolean query(char letter) {\\n        sb.insert(0, letter);\\n        if(trie.root.chars[letter-\\'a\\'] != null) {\\n             if(trie.findPrefix(sb.toString())){\\n                 return true;\\n             }   \\n        }\\n        return false;\\n    }\\n    \\n    \\n    class TrieNode {\\n        TrieNode [] chars = new TrieNode[26];\\n        boolean isWord = false;            \\n    } \\n    \\n    \\n    class Trie {\\n        \\n        TrieNode root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        public void add(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) {\\n                    cur.chars[c-\\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.chars[c-\\'a\\'];\\n            }\\n            cur.isWord = true;\\n        }\\n        \\n        public boolean find(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) return false;\\n                cur = cur.chars[c-\\'a\\'];\\n            }\\n            return cur.isWord;\\n        }\\n        \\n        \\n        public boolean findPrefix(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) return false;\\n                cur = cur.chars[c-\\'a\\'];\\n                if(cur.isWord) return true;\\n            }\\n            return false;\\n        }\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 535938,
                "title": "golang-trie",
                "content": "```\\ntype trieNode struct {\\n\\tchildren [26]*trieNode\\n\\tisWord   bool\\n}\\n\\ntype StreamChecker struct {\\n\\tqueryWord    []byte\\n\\ttrieTreeRoot *trieNode\\n}\\n\\nfunc Constructor(words []string) StreamChecker {\\n\\troot := &trieNode{\\n\\t\\tchildren: [26]*trieNode{},\\n\\t\\tisWord:   false,\\n\\t}\\n\\tfor _, word := range words {\\n\\t\\tcur := root\\n\\t\\tfor i := len(word) - 1; i >= 0; i-- {\\n\\t\\t\\tch := int(word[i] - \\'a\\')\\n\\t\\t\\tif cur.children[ch] == nil {\\n\\t\\t\\t\\tcur.children[ch] = &trieNode{\\n\\t\\t\\t\\t\\tchildren: [26]*trieNode{},\\n\\t\\t\\t\\t\\tisWord:   false,\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur.children[ch]\\n\\t\\t}\\n\\t\\tcur.isWord = true\\n\\t}\\n\\treturn StreamChecker{\\n\\t\\ttrieTreeRoot: root,\\n\\t\\tqueryWord:    []byte{},\\n\\t}\\n}\\n\\nfunc (this *StreamChecker) Query(letter byte) bool {\\n\\tthis.queryWord = append(this.queryWord, letter)\\n\\tcur := this.trieTreeRoot\\n\\tfor i := len(this.queryWord) - 1; i >= 0; i-- {\\n\\t\\tch := int(this.queryWord[i] - \\'a\\')\\n\\t\\tif cur.children[ch] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch]\\n\\t\\tif cur.isWord {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype trieNode struct {\\n\\tchildren [26]*trieNode\\n\\tisWord   bool\\n}\\n\\ntype StreamChecker struct {\\n\\tqueryWord    []byte\\n\\ttrieTreeRoot *trieNode\\n}\\n\\nfunc Constructor(words []string) StreamChecker {\\n\\troot := &trieNode{\\n\\t\\tchildren: [26]*trieNode{},\\n\\t\\tisWord:   false,\\n\\t}\\n\\tfor _, word := range words {\\n\\t\\tcur := root\\n\\t\\tfor i := len(word) - 1; i >= 0; i-- {\\n\\t\\t\\tch := int(word[i] - \\'a\\')\\n\\t\\t\\tif cur.children[ch] == nil {\\n\\t\\t\\t\\tcur.children[ch] = &trieNode{\\n\\t\\t\\t\\t\\tchildren: [26]*trieNode{},\\n\\t\\t\\t\\t\\tisWord:   false,\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur.children[ch]\\n\\t\\t}\\n\\t\\tcur.isWord = true\\n\\t}\\n\\treturn StreamChecker{\\n\\t\\ttrieTreeRoot: root,\\n\\t\\tqueryWord:    []byte{},\\n\\t}\\n}\\n\\nfunc (this *StreamChecker) Query(letter byte) bool {\\n\\tthis.queryWord = append(this.queryWord, letter)\\n\\tcur := this.trieTreeRoot\\n\\tfor i := len(this.queryWord) - 1; i >= 0; i-- {\\n\\t\\tch := int(this.queryWord[i] - \\'a\\')\\n\\t\\tif cur.children[ch] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch]\\n\\t\\tif cur.isWord {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 514204,
                "title": "trie-python",
                "content": "1. add the reversed words to a Trie\\n2. every add read the last k characters backwards and traverse the trie at the same time\\n\\n```\\nclass TNode(object):\\n    def __init__(self):\\n        self.d,self.f = {}, False\\nclass StreamChecker(object):\\n    def __init__(self, words):\\n        self.root = TNode()\\n        self.max_ = max(map(len, words))\\n        for w in words:\\n            cur = self.root\\n            for j in range(len(w)-1,-1,-1):\\n                if w[j] not in cur.d: cur.d[w[j]] = TNode()\\n                cur = cur.d[w[j]]\\n            cur.f = True\\n        self.q = collections.deque([])        \\n\\n    def query(self, letter):\\n        self.q.appendleft(letter)\\n        if len(self.q) > self.max_: self.q.pop()\\n        cur= self.root\\n        for l in self.q:\\n            if l not in cur.d: return False\\n            cur = cur.d[l]\\n            if cur.f:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass TNode(object):\\n    def __init__(self):\\n        self.d,self.f = {}, False\\nclass StreamChecker(object):\\n    def __init__(self, words):\\n        self.root = TNode()\\n        self.max_ = max(map(len, words))\\n        for w in words:\\n            cur = self.root\\n            for j in range(len(w)-1,-1,-1):\\n                if w[j] not in cur.d: cur.d[w[j]] = TNode()\\n                cur = cur.d[w[j]]\\n            cur.f = True\\n        self.q = collections.deque([])        \\n\\n    def query(self, letter):\\n        self.q.appendleft(letter)\\n        if len(self.q) > self.max_: self.q.pop()\\n        cur= self.root\\n        for l in self.q:\\n            if l not in cur.d: return False\\n            cur = cur.d[l]\\n            if cur.f:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513592,
                "title": "swift-trie-solution",
                "content": "```\\nclass Trie {\\n    var val: Character\\n    var dict = [Character: Trie]()\\n    var end: Bool = false\\n\\n    init(_ val: Character) {\\n        self.val = val\\n    }\\n}\\n\\nclass Node {\\n    var val: Character\\n    var next: Node?\\n\\n    init(_ val: Character) {\\n        self.val = val\\n    }\\n}\\n\\nclass StreamChecker {\\n    var trie = Trie(\"*\")\\n    var node: Node?\\n    var maxi: Int = 0\\n    init(_ words: [String]) {\\n        for word in words {\\n            populate(&trie, word)\\n        }\\n    }\\n    \\n    func populate(_ trie: inout Trie, _ word: String) {\\n        var temp: Trie? = trie\\n        let array = Array(word)\\n        maxi = max(maxi, array.count)\\n        for letter in Array(word).reversed() {\\n            if temp?.dict[letter] == nil {\\n                temp?.dict[letter] = Trie(letter)\\n            }\\n\\n            temp = temp?.dict[letter]\\n        }\\n\\n        temp?.end = true\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        let newNode = Node(letter)\\n        if node == nil {\\n            node = newNode\\n        } else {\\n            newNode.next = node\\n            node = newNode\\n        }\\n        \\n        return search(trie, node)\\n    }\\n    \\n    func search(_ trie: Trie, _ node: Node?) -> Bool {\\n        var count = 0\\n        var temp: Node? = node\\n        var tempTrie: Trie? = trie\\n        while count <= maxi {\\n            if let current = temp?.val {\\n                count += 1\\n                if tempTrie?.dict[current] != nil {\\n                    tempTrie = tempTrie?.dict[current]\\n                    if tempTrie?.end ?? false {\\n                        return true\\n                    }\\n                } else {\\n                    return false\\n                }\\n                \\n                temp = temp?.next\\n            } else {\\n                return false\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n\\n```\\nTime complexity = O(N)",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\n    var val: Character\\n    var dict = [Character: Trie]()\\n    var end: Bool = false\\n\\n    init(_ val: Character) {\\n        self.val = val\\n    }\\n}\\n\\nclass Node {\\n    var val: Character\\n    var next: Node?\\n\\n    init(_ val: Character) {\\n        self.val = val\\n    }\\n}\\n\\nclass StreamChecker {\\n    var trie = Trie(\"*\")\\n    var node: Node?\\n    var maxi: Int = 0\\n    init(_ words: [String]) {\\n        for word in words {\\n            populate(&trie, word)\\n        }\\n    }\\n    \\n    func populate(_ trie: inout Trie, _ word: String) {\\n        var temp: Trie? = trie\\n        let array = Array(word)\\n        maxi = max(maxi, array.count)\\n        for letter in Array(word).reversed() {\\n            if temp?.dict[letter] == nil {\\n                temp?.dict[letter] = Trie(letter)\\n            }\\n\\n            temp = temp?.dict[letter]\\n        }\\n\\n        temp?.end = true\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        let newNode = Node(letter)\\n        if node == nil {\\n            node = newNode\\n        } else {\\n            newNode.next = node\\n            node = newNode\\n        }\\n        \\n        return search(trie, node)\\n    }\\n    \\n    func search(_ trie: Trie, _ node: Node?) -> Bool {\\n        var count = 0\\n        var temp: Node? = node\\n        var tempTrie: Trie? = trie\\n        while count <= maxi {\\n            if let current = temp?.val {\\n                count += 1\\n                if tempTrie?.dict[current] != nil {\\n                    tempTrie = tempTrie?.dict[current]\\n                    if tempTrie?.end ?? false {\\n                        return true\\n                    }\\n                } else {\\n                    return false\\n                }\\n                \\n                temp = temp?.next\\n            } else {\\n                return false\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505504,
                "title": "javascript-trie-solution",
                "content": "```js\\n\\n/*******************************************\\n * * Helper Items                         *\\n*******************************************/\\n\\n/**\\n * @description A trie node\\n */\\nconst TrieNode = function() {\\n  this.children = {};\\n  this.isEnd = false;\\n};\\n\\n/**\\n * @param {char} ch char == a string with a length of one\\n */\\nTrieNode.prototype.add = function(ch) {\\n  this.children[ch] = new TrieNode();\\n}\\n\\n\\n/**\\n * @param {string} word\\n */\\nTrieNode.prototype.addWord = function(word) {\\n  let curNode = this;\\n  for (let ch = 0; ch < word.length; ch++) {\\n    const char = word[ch];\\n    \\n    if (!curNode.children.hasOwnProperty(char)) {\\n      curNode.add(char);\\n      curNode = curNode.children[char];\\n    } else {\\n      curNode = curNode.children[char];\\n    }\\n  }\\n  curNode.isEnd = true;\\n}\\n\\n\\n\\n\\n/*******************************************\\n * * Given Items                           *\\n*******************************************/\\n\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n  this.trie = new TrieNode(null);\\n  this.searches = [];\\n\\n  for (let i = 0; i < words.length; i++) {\\n    let curNode = this.trie;\\n    const werd = words[i].split(\\'\\').reverse();\\n    curNode.addWord(werd);\\n\\n  }\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n  this.searches.push(letter);\\n\\n  let curNode = this.trie;\\n  for (let i = this.searches.length - 1; i >= 0; i--) {\\n    const curChar = this.searches[i];\\n\\n    if (!curNode.children.hasOwnProperty(curChar)) return false;\\n    else {\\n      curNode = curNode.children[curChar];\\n      if (curNode.isEnd) return true;\\n    } \\n  }\\n  return false\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n\\n/*******************************************\\n * * Helper Items                         *\\n*******************************************/\\n\\n/**\\n * @description A trie node\\n */\\nconst TrieNode = function() {\\n  this.children = {};\\n  this.isEnd = false;\\n};\\n\\n/**\\n * @param {char} ch char == a string with a length of one\\n */\\nTrieNode.prototype.add = function(ch) {\\n  this.children[ch] = new TrieNode();\\n}\\n\\n\\n/**\\n * @param {string} word\\n */\\nTrieNode.prototype.addWord = function(word) {\\n  let curNode = this;\\n  for (let ch = 0; ch < word.length; ch++) {\\n    const char = word[ch];\\n    \\n    if (!curNode.children.hasOwnProperty(char)) {\\n      curNode.add(char);\\n      curNode = curNode.children[char];\\n    } else {\\n      curNode = curNode.children[char];\\n    }\\n  }\\n  curNode.isEnd = true;\\n}\\n\\n\\n\\n\\n/*******************************************\\n * * Given Items                           *\\n*******************************************/\\n\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n  this.trie = new TrieNode(null);\\n  this.searches = [];\\n\\n  for (let i = 0; i < words.length; i++) {\\n    let curNode = this.trie;\\n    const werd = words[i].split(\\'\\').reverse();\\n    curNode.addWord(werd);\\n\\n  }\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n  this.searches.push(letter);\\n\\n  let curNode = this.trie;\\n  for (let i = this.searches.length - 1; i >= 0; i--) {\\n    const curChar = this.searches[i];\\n\\n    if (!curNode.children.hasOwnProperty(curChar)) return false;\\n    else {\\n      curNode = curNode.children[curChar];\\n      if (curNode.isEnd) return true;\\n    } \\n  }\\n  return false\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473500,
                "title": "short-java-beat-95-trienode-solution",
                "content": "Wheneven we want to search a stream for a certain pattern such as this one.\\nAnd such as search a  DNA pattern in a DNS tream this could be a good method.\\nEspecially, when we can only read the stream once and the stream is too big to be read into memory.\\n#1  build up the trieNode tree use the patterns, in reverse order\\nduring the build process, we should keep the max length of the pattern string.\\n2# search, during the search we just keep the max length buffer and do a normal TrieNode prefix search.\\nSpace:  o(m) where m is the sum of all the pattern string length\\nTime:  o(n*(max Length) +m) when m is the above space, and n is the length of the stream\\n```\\nclass StreamChecker {\\n    class TrieNode{\\n        TrieNode[] children= new TrieNode[26];\\n        boolean isWord=false;\\n    }\\n    TrieNode root= new TrieNode();\\n   // int maxLen=0;   if the steam is too big and can\\'t be read into memory, then this limitation is needed\\n    StringBuilder sb= new StringBuilder();\\n    public StreamChecker(String[] words) {\\n        for(String s: words){\\n           // maxLen=Math.max(maxLen, s.length());  if the steam is too big and can\\'t be read into memory, then this is needed\\n            TrieNode cur= root;\\n            for(int j=s.length()-1;j>=0;j--){\\n                int i=s.charAt(j)-\\'a\\';\\n                if(cur.children[i]==null) cur.children[i]= new TrieNode();\\n                cur=cur.children[i];\\n            }\\n            cur.isWord=true;\\n        }\\n    }\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        //if(sb.length()>maxLen) sb.deleteCharAt(0);  if the steam is too big and can\\'t be read into memory, this line is needed\\n        TrieNode cur=root;\\n        for(int i=sb.length()-1;i>=0;i--){\\n            int j=sb.charAt(i)-\\'a\\';\\n            if(cur.children[j]==null) return false;\\n            cur=cur.children[j];\\n            if(cur.isWord) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    class TrieNode{\\n        TrieNode[] children= new TrieNode[26];\\n        boolean isWord=false;\\n    }\\n    TrieNode root= new TrieNode();\\n   // int maxLen=0;   if the steam is too big and can\\'t be read into memory, then this limitation is needed\\n    StringBuilder sb= new StringBuilder();\\n    public StreamChecker(String[] words) {\\n        for(String s: words){\\n           // maxLen=Math.max(maxLen, s.length());  if the steam is too big and can\\'t be read into memory, then this is needed\\n            TrieNode cur= root;\\n            for(int j=s.length()-1;j>=0;j--){\\n                int i=s.charAt(j)-\\'a\\';\\n                if(cur.children[i]==null) cur.children[i]= new TrieNode();\\n                cur=cur.children[i];\\n            }\\n            cur.isWord=true;\\n        }\\n    }\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        //if(sb.length()>maxLen) sb.deleteCharAt(0);  if the steam is too big and can\\'t be read into memory, this line is needed\\n        TrieNode cur=root;\\n        for(int i=sb.length()-1;i>=0;i--){\\n            int j=sb.charAt(i)-\\'a\\';\\n            if(cur.children[j]==null) return false;\\n            cur=cur.children[j];\\n            if(cur.isWord) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465478,
                "title": "java-trie-stringbuilder-solution-with-reverse-insert-and-prefix-search",
                "content": "The idea is to index the dictionary words in trie in reverse order. Maintain a global StringBuilder and with each query, append query character in the global StringBuilder and then check if Trie has a complete word which is a prefix of the StringBuilder in reverse order\\n\\ne.g.\\ndictionary word : \"cd\" in Trie looks like (\\'d\\' -> \\'c\\')\\nquery(\\'a\\') : (builder : \"a\"; return false since nothing in Trie starts with \\'a\\')\\nquery(\\'b\\') : (builder : \"ab\"; return false since nothing in Trie starts with \\'b\\')\\nquery(\\'c\\') : (builder : \"abc\"; return false since nothing in Trie starts with \\'c\\')\\nquery(\\'d\\') : (builder : \"abcd\"; return true since there is a complete word in the trie \"dc\" which is a prefix of reverse of builder (\"**dc**ba\"))\\n\\n```\\nclass StreamChecker {\\n    private static final class TrieNode {\\n        private boolean isEnd;\\n        private final TrieNode[] links;\\n\\n        private TrieNode() {\\n            this.links = new TrieNode[26];\\n        }\\n\\n        private boolean isEnd() {\\n            return isEnd;\\n        }\\n\\n        private void setEnd() {\\n            isEnd = true;\\n        }\\n\\n        private boolean containsCharacter(char c) {\\n            return links[c - \\'a\\'] != null;\\n        }\\n\\n        private TrieNode get(char c) {\\n            return links[c - \\'a\\'];\\n        }\\n\\n        private void put(char c) {\\n            links[c - \\'a\\'] = new TrieNode();\\n        }\\n    }\\n\\n    private static final class Trie {\\n        private final TrieNode root;\\n\\n        private Trie() {\\n            this.root = new TrieNode();\\n        }\\n\\n        private void addWord(String s) {\\n            TrieNode current = root;\\n            for (char c : s.toCharArray()) {\\n                if (!current.containsCharacter(c)) {\\n                    current.put(c);\\n                }\\n                current = current.get(c);\\n            }\\n            current.setEnd();\\n        }\\n\\n        private void addWordInReverse(String s) {\\n            TrieNode current = root;\\n            int n = s.length();\\n            for (int i = n - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (!current.containsCharacter(c)) {\\n                    current.put(c);\\n                }\\n                current = current.get(c);\\n            }\\n            current.setEnd();\\n        }\\n\\n        private boolean checkPrefix(String s) {\\n            TrieNode current = root;\\n            for (char c : s.toCharArray()) {\\n                if (!current.containsCharacter(c)) {\\n                    return false;\\n                }\\n                current = current.get(c);\\n                if (current.isEnd()) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        private boolean checkPrefixInReverse(StringBuilder s) {\\n            TrieNode current = root;\\n            int n = s.length();\\n            for (int i = n - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (!current.containsCharacter(c)) {\\n                    return false;\\n                }\\n                current = current.get(c);\\n                if (current.isEnd()) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n    private final Trie trie;\\n    private final StringBuilder builder;\\n\\n    public StreamChecker(String[] words) {\\n        this.builder = new StringBuilder();\\n        this.trie = new Trie();\\n        for (String word : words) {\\n            //trie.addWord(new StringBuilder(word).reverse().toString());\\n            trie.addWordInReverse(word);\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        //builder.insert(0, letter);\\n        //return trie.checkPrefix(builder.toString());\\n\\n        builder.append(letter);\\n        return trie.checkPrefixInReverse(builder);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n    private static final class TrieNode {\\n        private boolean isEnd;\\n        private final TrieNode[] links;\\n\\n        private TrieNode() {\\n            this.links = new TrieNode[26];\\n        }\\n\\n        private boolean isEnd() {\\n            return isEnd;\\n        }\\n\\n        private void setEnd() {\\n            isEnd = true;\\n        }\\n\\n        private boolean containsCharacter(char c) {\\n            return links[c - \\'a\\'] != null;\\n        }\\n\\n        private TrieNode get(char c) {\\n            return links[c - \\'a\\'];\\n        }\\n\\n        private void put(char c) {\\n            links[c - \\'a\\'] = new TrieNode();\\n        }\\n    }\\n\\n    private static final class Trie {\\n        private final TrieNode root;\\n\\n        private Trie() {\\n            this.root = new TrieNode();\\n        }\\n\\n        private void addWord(String s) {\\n            TrieNode current = root;\\n            for (char c : s.toCharArray()) {\\n                if (!current.containsCharacter(c)) {\\n                    current.put(c);\\n                }\\n                current = current.get(c);\\n            }\\n            current.setEnd();\\n        }\\n\\n        private void addWordInReverse(String s) {\\n            TrieNode current = root;\\n            int n = s.length();\\n            for (int i = n - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (!current.containsCharacter(c)) {\\n                    current.put(c);\\n                }\\n                current = current.get(c);\\n            }\\n            current.setEnd();\\n        }\\n\\n        private boolean checkPrefix(String s) {\\n            TrieNode current = root;\\n            for (char c : s.toCharArray()) {\\n                if (!current.containsCharacter(c)) {\\n                    return false;\\n                }\\n                current = current.get(c);\\n                if (current.isEnd()) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        private boolean checkPrefixInReverse(StringBuilder s) {\\n            TrieNode current = root;\\n            int n = s.length();\\n            for (int i = n - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (!current.containsCharacter(c)) {\\n                    return false;\\n                }\\n                current = current.get(c);\\n                if (current.isEnd()) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n    private final Trie trie;\\n    private final StringBuilder builder;\\n\\n    public StreamChecker(String[] words) {\\n        this.builder = new StringBuilder();\\n        this.trie = new Trie();\\n        for (String word : words) {\\n            //trie.addWord(new StringBuilder(word).reverse().toString());\\n            trie.addWordInReverse(word);\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        //builder.insert(0, letter);\\n        //return trie.checkPrefix(builder.toString());\\n\\n        builder.append(letter);\\n        return trie.checkPrefixInReverse(builder);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459504,
                "title": "python-trie-solution-with-reverse-insert",
                "content": "we insert and search words inversely with using dictionary.\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.root = {}\\n    \\n    def insert(self,word):\\n        cur = self.root\\n        for w in word:\\n            if w not in cur:\\n                cur[w] = {}\\n            cur = cur[w]\\n        cur[\"#\"] = True\\n        \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.sentence = \"\"\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n            \\n    def query(self, letter: str) -> bool:\\n        self.sentence += letter\\n        \\n        def dfs(word,cur):\\n            if not cur: \\n                cur = self.trie.root\\n            if not word:\\n                if \"#\" in cur:\\n                    return True\\n                return False\\n            \\n            if \"#\" in cur:\\n                return True\\n            if word[0] in cur:\\n                return dfs(word[1:],cur[word[0]])\\n            return False \\n                    \\n        return dfs(self.sentence[::-1],None)\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.root = {}\\n    \\n    def insert(self,word):\\n        cur = self.root\\n        for w in word:\\n            if w not in cur:\\n                cur[w] = {}\\n            cur = cur[w]\\n        cur[\"#\"] = True\\n        \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.sentence = \"\"\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n            \\n    def query(self, letter: str) -> bool:\\n        self.sentence += letter\\n        \\n        def dfs(word,cur):\\n            if not cur: \\n                cur = self.trie.root\\n            if not word:\\n                if \"#\" in cur:\\n                    return True\\n                return False\\n            \\n            if \"#\" in cur:\\n                return True\\n            if word[0] in cur:\\n                return dfs(word[1:],cur[word[0]])\\n            return False \\n                    \\n        return dfs(self.sentence[::-1],None)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 431483,
                "title": "my-aho-corasick-solution",
                "content": "As a acmer who was active six years ago, I\\'m surprised that Aho\\u2013Corasick becomes interview questions these days....\\n\\u6211\\u9707\\u60CA\\u4E86\\u3002\\n```\\nclass Trie {\\nprivate:\\n    vector<vector<int>> trie;\\n    vector<bool> isWord;\\n    vector<int> fail;\\n    int curPos;\\npublic:\\n    Trie() {\\n        trie.resize(1, vector<int>(28));\\n        isWord.resize(1);\\n        fail.resize(1, -1);\\n        curPos = 0;\\n    }\\n\\n    int alloc(char ch) {\\n        trie.push_back(vector<int>(28));\\n        trie[trie.size()-1][27] = ch-\\'a\\';\\n        isWord.push_back(0);\\n        fail.push_back(0);\\n        return trie.size()-1;\\n    }\\n    void buildFail() {\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0, -1));\\n        while(!q.empty()) {\\n            auto curNode = q.front(); q.pop();\\n            int cur = curNode.first;\\n            int fa = curNode.second;\\n            if(cur > 0) {\\n                int chIndex = trie[cur][27];\\n                int failFa = fail[fa];\\n                while(failFa != -1) {\\n                    if(!trie[failFa][chIndex]) {\\n                        failFa = fail[failFa];\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if(failFa == -1) {\\n                    fail[cur] = 0;\\n                } else {\\n                    fail[cur] = trie[failFa][chIndex];\\n                }\\n            }\\n            for(int i=0; i<27; i++) {\\n                if(!trie[cur][i]) continue;\\n                q.push(make_pair(trie[cur][i], cur));\\n            }\\n        }\\n        \\n\\n        return;\\n    }\\n    void insert(string& word) {\\n        int cur = 0;\\n        for(char ch : word) {\\n            int index = ch-\\'a\\';\\n            if(!trie[cur][index]) {\\n                trie[cur][index] = alloc(ch);\\n            }\\n            cur = trie[cur][index];\\n        }\\n        isWord[cur] = 1;\\n        return;\\n    }\\n    bool find(char ch) {\\n        int index = ch-\\'a\\';\\n        int failFa = curPos;\\n        while(failFa != -1) {\\n            if(trie[failFa][index]) {\\n                curPos = trie[failFa][index];\\n                int tmp =curPos;\\n                while(tmp != -1) {\\n                    if(isWord[tmp]) return 1;\\n                    tmp = fail[tmp];\\n                }\\n                return 0;\\n            }\\n            failFa = fail[failFa];\\n        }\\n        curPos = 0;\\n        return 0;\\n    }\\n};\\nclass StreamChecker {\\nprivate:\\n    Trie trie;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& str : words) {\\n            trie.insert(str);\\n        }\\n        trie.buildFail();\\n    }\\n    \\n    bool query(char letter) {\\n        return trie.find(letter);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\nprivate:\\n    vector<vector<int>> trie;\\n    vector<bool> isWord;\\n    vector<int> fail;\\n    int curPos;\\npublic:\\n    Trie() {\\n        trie.resize(1, vector<int>(28));\\n        isWord.resize(1);\\n        fail.resize(1, -1);\\n        curPos = 0;\\n    }\\n\\n    int alloc(char ch) {\\n        trie.push_back(vector<int>(28));\\n        trie[trie.size()-1][27] = ch-\\'a\\';\\n        isWord.push_back(0);\\n        fail.push_back(0);\\n        return trie.size()-1;\\n    }\\n    void buildFail() {\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0, -1));\\n        while(!q.empty()) {\\n            auto curNode = q.front(); q.pop();\\n            int cur = curNode.first;\\n            int fa = curNode.second;\\n            if(cur > 0) {\\n                int chIndex = trie[cur][27];\\n                int failFa = fail[fa];\\n                while(failFa != -1) {\\n                    if(!trie[failFa][chIndex]) {\\n                        failFa = fail[failFa];\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if(failFa == -1) {\\n                    fail[cur] = 0;\\n                } else {\\n                    fail[cur] = trie[failFa][chIndex];\\n                }\\n            }\\n            for(int i=0; i<27; i++) {\\n                if(!trie[cur][i]) continue;\\n                q.push(make_pair(trie[cur][i], cur));\\n            }\\n        }\\n        \\n\\n        return;\\n    }\\n    void insert(string& word) {\\n        int cur = 0;\\n        for(char ch : word) {\\n            int index = ch-\\'a\\';\\n            if(!trie[cur][index]) {\\n                trie[cur][index] = alloc(ch);\\n            }\\n            cur = trie[cur][index];\\n        }\\n        isWord[cur] = 1;\\n        return;\\n    }\\n    bool find(char ch) {\\n        int index = ch-\\'a\\';\\n        int failFa = curPos;\\n        while(failFa != -1) {\\n            if(trie[failFa][index]) {\\n                curPos = trie[failFa][index];\\n                int tmp =curPos;\\n                while(tmp != -1) {\\n                    if(isWord[tmp]) return 1;\\n                    tmp = fail[tmp];\\n                }\\n                return 0;\\n            }\\n            failFa = fail[failFa];\\n        }\\n        curPos = 0;\\n        return 0;\\n    }\\n};\\nclass StreamChecker {\\nprivate:\\n    Trie trie;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& str : words) {\\n            trie.insert(str);\\n        }\\n        trie.buildFail();\\n    }\\n    \\n    bool query(char letter) {\\n        return trie.find(letter);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420567,
                "title": "simple-with-python-and-trie-20-lines-fully-commented",
                "content": "```\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        # string that remembers the stream of queris\\n        self.s = \"\"\\n\\n        # my trie has 27 slots, 26 are for letters and the last a bool for termination\\n        self.trie = [[]] * 27\\n        for word in words:\\n            curr = self.trie\\n            # i have to reverse the word\\n            for l in reversed(word):\\n                # get the index: a -> 0, z -> 25\\n                i = ord(l) - ord(\"a\")\\n                # if branch does not exist before i create it\\n                if not curr[i]:\\n                    curr[i] = [[]] * 27\\n                # switch branch and continue iteraiton\\n                curr = curr[i]\\n            # mark this as the end of the word\\n            curr[26] = True\\n\\n    def query(self, letter: str) -> bool:\\n        # add the last query to the string\\n        self.s += letter\\n        curr = self.trie\\n        # parse troguh the reversed stream\\n        for l in reversed(self.s):\\n            # get the index: a -> 0, z -> 25\\n            i = ord(l) - ord(\"a\")\\n            # if end of word, return true!\\n            if curr[26]:\\n                return True\\n            # if this letter exist (and was not end of word before)\\n            # iterate to the next one\\n            if curr[i]:\\n                curr = curr[i]\\n            # if this letter does not exist return\\n            else:\\n                return False\\n        # return if this last letter of the stream existed\\n        return curr[26]\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        # string that remembers the stream of queris\\n        self.s = \"\"\\n\\n        # my trie has 27 slots, 26 are for letters and the last a bool for termination\\n        self.trie = [[]] * 27\\n        for word in words:\\n            curr = self.trie\\n            # i have to reverse the word\\n            for l in reversed(word):\\n                # get the index: a -> 0, z -> 25\\n                i = ord(l) - ord(\"a\")\\n                # if branch does not exist before i create it\\n                if not curr[i]:\\n                    curr[i] = [[]] * 27\\n                # switch branch and continue iteraiton\\n                curr = curr[i]\\n            # mark this as the end of the word\\n            curr[26] = True\\n\\n    def query(self, letter: str) -> bool:\\n        # add the last query to the string\\n        self.s += letter\\n        curr = self.trie\\n        # parse troguh the reversed stream\\n        for l in reversed(self.s):\\n            # get the index: a -> 0, z -> 25\\n            i = ord(l) - ord(\"a\")\\n            # if end of word, return true!\\n            if curr[26]:\\n                return True\\n            # if this letter exist (and was not end of word before)\\n            # iterate to the next one\\n            if curr[i]:\\n                curr = curr[i]\\n            # if this letter does not exist return\\n            else:\\n                return False\\n        # return if this last letter of the stream existed\\n        return curr[26]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400872,
                "title": "python-trie",
                "content": "```\\nfrom collections import defaultdict, deque\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.children = defaultdict(TrieNode)\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for c in word:\\n            node = node.children[c]\\n        node.isWord = True\\n    \\n    def search(self, queries):\\n        node = self.root\\n        for q in queries:\\n            if q in node.children:\\n                node = node.children[q]\\n                if node.isWord:\\n                    return True\\n            else:\\n                return False\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n        self.queries = deque() \\n    \\n    def query(self, letter: str) -> bool:\\n        self.queries.appendleft(letter)\\n        if len(self.queries) > 2000: self.queries.pop()\\n        return self.trie.search(self.queries)",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.children = defaultdict(TrieNode)\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for c in word:\\n            node = node.children[c]\\n        node.isWord = True\\n    \\n    def search(self, queries):\\n        node = self.root\\n        for q in queries:\\n            if q in node.children:\\n                node = node.children[q]\\n                if node.isWord:\\n                    return True\\n            else:\\n                return False\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n        self.queries = deque() \\n    \\n    def query(self, letter: str) -> bool:\\n        self.queries.appendleft(letter)\\n        if len(self.queries) > 2000: self.queries.pop()\\n        return self.trie.search(self.queries)",
                "codeTag": "Java"
            },
            {
                "id": 397278,
                "title": "c-tle-on-first-approach-reverse-trie-on-second-beats-85",
                "content": "First approach I came up with was to track root characters in the trie then try each word from the most recent root to end of stream if it was in the trie or not. This worked fine on simple cases but passed only 13/17 test cases and failed from TLE. Would\\'ve been happy with this approach in an interview, could talk potential issues, etc. and then workout a more optimal answer. I also wrote this before realizing we only need to care about lowercase letters.\\n\\n```\\npublic class StreamChecker \\n{\\n    private class Trie\\n    {\\n        private class TrieNode\\n        {\\n            public char Value { get; }\\n            public bool Terminating { get; set; }\\n            public Dictionary<char, TrieNode> NextNodes { get; }\\n\\n            public TrieNode(char val)\\n            {\\n                Value = val;\\n                NextNodes = new Dictionary<char, TrieNode>();\\n            }        \\n        }\\n        \\n        private readonly Dictionary<char, TrieNode> _roots = new Dictionary<char, TrieNode>();\\n        \\n        public Trie(string[] words)\\n        {\\n            foreach (var word in words)\\n                Add(word);\\n        }\\n        \\n        public void Add(string word)\\n        {\\n            if (word == string.Empty)\\n                return;\\n\\n            if (!_roots.ContainsKey(word[0]))\\n                _roots[word[0]] = new TrieNode(word[0]);\\n            \\n            var current = _roots[word[0]];\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                if (!current.NextNodes.ContainsKey(ch))\\n                {\\n                    var next = new TrieNode(ch);\\n                    current.NextNodes[ch] = next;\\n                    current = next;\\n                }\\n                else\\n                    current = current.NextNodes[ch];\\n            }\\n            \\n            current.Terminating = true;\\n        }\\n        \\n        public bool Check(string word)\\n        {\\n            _roots.TryGetValue(word[0], out var current);\\n            if (current == null)\\n                return false;\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                \\n                current.NextNodes.TryGetValue(ch, out var next);\\n                if (next == null)\\n                    return false;\\n                current = next;\\n            }\\n            \\n            return current.Terminating;\\n        }\\n        \\n        public bool HasRoot(char ch)\\n        {\\n            _roots.TryGetValue(ch, out var node);\\n            \\n            return node != null;\\n        }\\n    }\\n    \\n    private readonly Trie _trie;\\n    private readonly StringBuilder _streamCharacters = new StringBuilder();\\n    private readonly List<int> _rootIndexes = new List<int>();\\n\\n    public StreamChecker(string[] words) \\n    {\\n        _trie = new Trie(words);\\n    }\\n    \\n    public bool Query(char letter) \\n    {\\n        _streamCharacters.Append(letter);\\n        \\n        if (_trie.HasRoot(letter))\\n            _rootIndexes.Add(_streamCharacters.Length - 1);\\n        \\n        for (var i = _rootIndexes.Count - 1; i >= 0; i--)\\n        {\\n            var current = _streamCharacters.ToString(_rootIndexes[i], _streamCharacters.Length - _rootIndexes[i]);\\n            if (_trie.Check(current))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nSecond approach passes using the reverse word approach. Smart idea, not sure if I would\\'ve been able to come up with it in interview but it might be something an interviewer would give a clue on.\\n\\n```\\npublic class StreamChecker \\n{\\n    private class Trie\\n    {\\n        public class TrieNode\\n        {\\n            public bool Terminating { get; set; }\\n            public TrieNode[] NextNodes { get; }\\n\\n            public TrieNode()\\n            {\\n                NextNodes = new TrieNode[26];\\n            }        \\n        }\\n        \\n        public TrieNode Root { get; } = new TrieNode();\\n        \\n        public void Add(char[] word)\\n        {\\n            var current = Root.NextNodes[word[0] - \\'a\\'];\\n            if (current == null)\\n            {\\n                current = new TrieNode();\\n                Root.NextNodes[word[0] - \\'a\\'] = current;\\n            }\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                \\n                var next = current.NextNodes[ch - \\'a\\'];\\n                if (next == null)\\n                {\\n                    next = new TrieNode();\\n                    current.NextNodes[ch - \\'a\\'] = next;\\n                    current = next;\\n                }\\n                else\\n                    current = next;\\n            }\\n            \\n            current.Terminating = true;\\n        }\\n    }\\n    \\n    private readonly Trie _trie = new Trie();\\n    private readonly StringBuilder _streamCharacters = new StringBuilder();\\n\\n    public StreamChecker(string[] words) \\n    {\\n        foreach (var word in words)\\n        {\\n            char[] array = word.ToCharArray();\\n            Array.Reverse(array);\\n            _trie.Add(array);\\n        }\\n    }\\n    \\n    public bool Query(char letter) \\n    {\\n        _streamCharacters.Append(letter);\\n        \\n        var current = _trie.Root;\\n        \\n        for (var i = _streamCharacters.Length - 1; i >= 0; i--)\\n        {\\n            var next = current.NextNodes[_streamCharacters[i] - \\'a\\'];\\n            if (next == null)\\n                return false;\\n            else if (next.Terminating)\\n                return true;\\n \\n            current = next;\\n        }\\n        \\n        return current.Terminating;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class StreamChecker \\n{\\n    private class Trie\\n    {\\n        private class TrieNode\\n        {\\n            public char Value { get; }\\n            public bool Terminating { get; set; }\\n            public Dictionary<char, TrieNode> NextNodes { get; }\\n\\n            public TrieNode(char val)\\n            {\\n                Value = val;\\n                NextNodes = new Dictionary<char, TrieNode>();\\n            }        \\n        }\\n        \\n        private readonly Dictionary<char, TrieNode> _roots = new Dictionary<char, TrieNode>();\\n        \\n        public Trie(string[] words)\\n        {\\n            foreach (var word in words)\\n                Add(word);\\n        }\\n        \\n        public void Add(string word)\\n        {\\n            if (word == string.Empty)\\n                return;\\n\\n            if (!_roots.ContainsKey(word[0]))\\n                _roots[word[0]] = new TrieNode(word[0]);\\n            \\n            var current = _roots[word[0]];\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                if (!current.NextNodes.ContainsKey(ch))\\n                {\\n                    var next = new TrieNode(ch);\\n                    current.NextNodes[ch] = next;\\n                    current = next;\\n                }\\n                else\\n                    current = current.NextNodes[ch];\\n            }\\n            \\n            current.Terminating = true;\\n        }\\n        \\n        public bool Check(string word)\\n        {\\n            _roots.TryGetValue(word[0], out var current);\\n            if (current == null)\\n                return false;\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                \\n                current.NextNodes.TryGetValue(ch, out var next);\\n                if (next == null)\\n                    return false;\\n                current = next;\\n            }\\n            \\n            return current.Terminating;\\n        }\\n        \\n        public bool HasRoot(char ch)\\n        {\\n            _roots.TryGetValue(ch, out var node);\\n            \\n            return node != null;\\n        }\\n    }\\n    \\n    private readonly Trie _trie;\\n    private readonly StringBuilder _streamCharacters = new StringBuilder();\\n    private readonly List<int> _rootIndexes = new List<int>();\\n\\n    public StreamChecker(string[] words) \\n    {\\n        _trie = new Trie(words);\\n    }\\n    \\n    public bool Query(char letter) \\n    {\\n        _streamCharacters.Append(letter);\\n        \\n        if (_trie.HasRoot(letter))\\n            _rootIndexes.Add(_streamCharacters.Length - 1);\\n        \\n        for (var i = _rootIndexes.Count - 1; i >= 0; i--)\\n        {\\n            var current = _streamCharacters.ToString(_rootIndexes[i], _streamCharacters.Length - _rootIndexes[i]);\\n            if (_trie.Check(current))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\npublic class StreamChecker \\n{\\n    private class Trie\\n    {\\n        public class TrieNode\\n        {\\n            public bool Terminating { get; set; }\\n            public TrieNode[] NextNodes { get; }\\n\\n            public TrieNode()\\n            {\\n                NextNodes = new TrieNode[26];\\n            }        \\n        }\\n        \\n        public TrieNode Root { get; } = new TrieNode();\\n        \\n        public void Add(char[] word)\\n        {\\n            var current = Root.NextNodes[word[0] - \\'a\\'];\\n            if (current == null)\\n            {\\n                current = new TrieNode();\\n                Root.NextNodes[word[0] - \\'a\\'] = current;\\n            }\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                \\n                var next = current.NextNodes[ch - \\'a\\'];\\n                if (next == null)\\n                {\\n                    next = new TrieNode();\\n                    current.NextNodes[ch - \\'a\\'] = next;\\n                    current = next;\\n                }\\n                else\\n                    current = next;\\n            }\\n            \\n            current.Terminating = true;\\n        }\\n    }\\n    \\n    private readonly Trie _trie = new Trie();\\n    private readonly StringBuilder _streamCharacters = new StringBuilder();\\n\\n    public StreamChecker(string[] words) \\n    {\\n        foreach (var word in words)\\n        {\\n            char[] array = word.ToCharArray();\\n            Array.Reverse(array);\\n            _trie.Add(array);\\n        }\\n    }\\n    \\n    public bool Query(char letter) \\n    {\\n        _streamCharacters.Append(letter);\\n        \\n        var current = _trie.Root;\\n        \\n        for (var i = _streamCharacters.Length - 1; i >= 0; i--)\\n        {\\n            var next = current.NextNodes[_streamCharacters[i] - \\'a\\'];\\n            if (next == null)\\n                return false;\\n            else if (next.Terminating)\\n                return true;\\n \\n            current = next;\\n        }\\n        \\n        return current.Terminating;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390448,
                "title": "java-clean-trie-solution-easy-to-understand",
                "content": "Use a limited size deque to save the memory because the max depth we want to search will not exceed the max lenght of the word. Also considering the property of deque, I use an iterator here to search backward to save the time complexity.\\n```\\nclass StreamChecker {\\n    Trie trie;\\n    Deque<Character> chars;\\n    int maxLen;\\n    public StreamChecker(String[] words) {\\n        trie = new Trie();\\n        chars = new LinkedList<Character>();\\n        maxLen = 0;\\n        for (String word : words) {\\n            trie.addWord(new StringBuilder(word).reverse().toString());\\n            maxLen = Math.max(maxLen, word.length());\\n        } \\n    }\\n    \\n    public boolean query(char letter) {\\n        chars.addLast(letter);\\n        if (chars.size() > maxLen) { chars.pollFirst(); }\\n        Iterator<Character> iterator = chars.descendingIterator();\\n        return trie.containsWord(iterator);\\n    }\\n    \\n    class Trie {\\n        TreeNode root;\\n        public Trie() {\\n            this.root = new TreeNode();\\n        }\\n        \\n        public void addWord(String word) {\\n            TreeNode node = root;\\n            for (char c : word.toCharArray()) {\\n                if (node.next[c - \\'a\\'] == null) {\\n                    node.next[c - \\'a\\'] = new TreeNode();\\n                }\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n        \\n        public boolean containsWord(Iterator<Character> iterator) {\\n            TreeNode node = root;\\n            while (iterator.hasNext()) {\\n                char c = iterator.next();\\n                if (node.next[c - \\'a\\'] == null) return false;\\n                node = node.next[c - \\'a\\'];\\n                if (node.isWord) return true;\\n            }\\n            return false;\\n        }\\n    }\\n    \\n    class TreeNode {\\n        boolean isWord;\\n        TreeNode[] next;\\n        public TreeNode() {\\n            this.isWord = false;\\n            this.next = new TreeNode[26];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    Trie trie;\\n    Deque<Character> chars;\\n    int maxLen;\\n    public StreamChecker(String[] words) {\\n        trie = new Trie();\\n        chars = new LinkedList<Character>();\\n        maxLen = 0;\\n        for (String word : words) {\\n            trie.addWord(new StringBuilder(word).reverse().toString());\\n            maxLen = Math.max(maxLen, word.length());\\n        } \\n    }\\n    \\n    public boolean query(char letter) {\\n        chars.addLast(letter);\\n        if (chars.size() > maxLen) { chars.pollFirst(); }\\n        Iterator<Character> iterator = chars.descendingIterator();\\n        return trie.containsWord(iterator);\\n    }\\n    \\n    class Trie {\\n        TreeNode root;\\n        public Trie() {\\n            this.root = new TreeNode();\\n        }\\n        \\n        public void addWord(String word) {\\n            TreeNode node = root;\\n            for (char c : word.toCharArray()) {\\n                if (node.next[c - \\'a\\'] == null) {\\n                    node.next[c - \\'a\\'] = new TreeNode();\\n                }\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n        \\n        public boolean containsWord(Iterator<Character> iterator) {\\n            TreeNode node = root;\\n            while (iterator.hasNext()) {\\n                char c = iterator.next();\\n                if (node.next[c - \\'a\\'] == null) return false;\\n                node = node.next[c - \\'a\\'];\\n                if (node.isWord) return true;\\n            }\\n            return false;\\n        }\\n    }\\n    \\n    class TreeNode {\\n        boolean isWord;\\n        TreeNode[] next;\\n        public TreeNode() {\\n            this.isWord = false;\\n            this.next = new TreeNode[26];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379232,
                "title": "python-trie-tree-easy-to-understand",
                "content": "```\\nclass TreeNode:\\n    # tree node of a multi-way tree\\n    def __init__(self, val):\\n        self.val = val\\n        # children\\n        self.next = {}\\n        # mark this node as the end of a path to search a word\\n        self.is_end = False\\n\\n\\nclass StreamChecker:\\n    # search tree data structure\\n    def __init__(self, words):\\n        # root of the search tree\\n        self.root = TreeNode(None)\\n        # a list to store unfinished paths\\n        self.q = []\\n        for word in words:\\n            # add each word into the search tree\\n            head = self.root\\n            for char in word:\\n                if char not in head.next:\\n                    head.next[char] = TreeNode(char)\\n                head = head.next[char]\\n            head.is_end = True\\n\\n    def query(self, letter: str) -> bool:\\n        # add a new path\\n        self.q.append(self.root)\\n        next_q = []\\n        for each in self.q:\\n            if letter in each.next:\\n                next_q.append(each.next[letter])\\n        self.q = next_q\\n        return any([each.is_end for each in self.q])\\n```",
                "solutionTags": [],
                "code": "```\\nclass TreeNode:\\n    # tree node of a multi-way tree\\n    def __init__(self, val):\\n        self.val = val\\n        # children\\n        self.next = {}\\n        # mark this node as the end of a path to search a word\\n        self.is_end = False\\n\\n\\nclass StreamChecker:\\n    # search tree data structure\\n    def __init__(self, words):\\n        # root of the search tree\\n        self.root = TreeNode(None)\\n        # a list to store unfinished paths\\n        self.q = []\\n        for word in words:\\n            # add each word into the search tree\\n            head = self.root\\n            for char in word:\\n                if char not in head.next:\\n                    head.next[char] = TreeNode(char)\\n                head = head.next[char]\\n            head.is_end = True\\n\\n    def query(self, letter: str) -> bool:\\n        # add a new path\\n        self.q.append(self.root)\\n        next_q = []\\n        for each in self.q:\\n            if letter in each.next:\\n                next_q.append(each.next[letter])\\n        self.q = next_q\\n        return any([each.is_end for each in self.q])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362505,
                "title": "straightforward-java-solution-using-hashmap-with-explanation",
                "content": "When we get the input of string array, we creat a table(implemented by 2 layer HashMap) to classfify all the words by the last character and the length of the words. \\nFor example, if we have [\"ab\", \"eb\", \"abb\", \"cdb\", \"cd\"], we get:\\nb:  [2, \"ab, eb\"], [3, \"abb\", \"cdb\"]\\nd:  [1, \"cd\"].\\n\\nWe put all the queried letter in a Stringbuilder sb. For a query, let\\'s say \\'b\\', we try the length of 2 and 3, and see the string comstructed by the last 2 or 3 qurried letter is contains in the correspondin set or not.\\n\\n\\n```\\nclass StreamChecker {\\n    Map<Character, Map<Integer, Set<String>>> map = new HashMap<>();\\n    StringBuilder sb = new StringBuilder();\\n    \\n    public StreamChecker(String[] words) {\\n        if (words == null || words.length == 0) return;\\n        for (String s : words) {\\n            char c = s.charAt(s.length() - 1);\\n            int length = s.length();\\n            Map<Integer, Set<String>> newEntry = map.getOrDefault(c, new HashMap<Integer, Set<String>>());\\n            Set<String> sameLengthSet = newEntry.getOrDefault(length, new HashSet<>());\\n            sameLengthSet.add(s);\\n            newEntry.put(length, sameLengthSet);\\n            map.put(c, newEntry);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Map<Integer, Set<String>> newEntry = map.get(letter);\\n        if (newEntry == null) return false;\\n        for (int length : newEntry.keySet()) {\\n            if (length > sb.length()) continue;\\n            Set<String> setWithSameLength = newEntry.get(length);\\n            String target = sb.substring(sb.length() - length, sb.length());\\n            if (setWithSameLength.contains(target)) return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "When we get the input of string array, we creat a table(implemented by 2 layer HashMap) to classfify all the words by the last character and the length of the words. \\nFor example, if we have [\"ab\", \"eb\", \"abb\", \"cdb\", \"cd\"], we get:\\nb:  [2, \"ab, eb\"], [3, \"abb\", \"cdb\"]\\nd:  [1, \"cd\"].\\n\\nWe put all the queried letter in a Stringbuilder sb. For a query, let\\'s say \\'b\\', we try the length of 2 and 3, and see the string comstructed by the last 2 or 3 qurried letter is contains in the correspondin set or not.\\n\\n\\n```\\nclass StreamChecker {\\n    Map<Character, Map<Integer, Set<String>>> map = new HashMap<>();\\n    StringBuilder sb = new StringBuilder();\\n    \\n    public StreamChecker(String[] words) {\\n        if (words == null || words.length == 0) return;\\n        for (String s : words) {\\n            char c = s.charAt(s.length() - 1);\\n            int length = s.length();\\n            Map<Integer, Set<String>> newEntry = map.getOrDefault(c, new HashMap<Integer, Set<String>>());\\n            Set<String> sameLengthSet = newEntry.getOrDefault(length, new HashSet<>());\\n            sameLengthSet.add(s);\\n            newEntry.put(length, sameLengthSet);\\n            map.put(c, newEntry);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Map<Integer, Set<String>> newEntry = map.get(letter);\\n        if (newEntry == null) return false;\\n        for (int length : newEntry.keySet()) {\\n            if (length > sb.length()) continue;\\n            Set<String> setWithSameLength = newEntry.get(length);\\n            String target = sb.substring(sb.length() - length, sb.length());\\n            if (setWithSameLength.contains(target)) return true;\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 361612,
                "title": "trie-in-java",
                "content": "Query characters from the latest to previous, should match a word from the last character to the first (if any). So it would be more convenient if we reverse the word and perform the matching.\\n\\nIn this way, query characters from the latest to previos seem like a prefix of a reversed word. A prefix tree (trie) is a good storage of these reversed wrods.\\n\\nOnly latest maxLen query characters matter, so we clear the staled characters after each query().\\n```\\n    private Node root;\\n    private int maxLen;\\n    private StringBuilder queries;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        maxLen = Integer.MIN_VALUE;\\n        queries = new StringBuilder();\\n        \\n        for (String word : words) {\\n            // reverse word insert into trie\\n            insert(new StringBuilder(word).reverse().toString());\\n            // update maxLen\\n            maxLen = Math.max(maxLen, word.length());\\n        }\\n    }\\n    \\n    // Clear stale before return\\n    public boolean query(char letter) {\\n        queries.append(letter);\\n        Node node = root;\\n        \\n        for (int i = queries.length() - 1; i >= Math.max(0, queries.length() - maxLen); i--) {\\n            // search queries character by character from end in trie\\n            node = node.children[queries.charAt(i) - \\'a\\'];\\n            if (node == null) {\\n                clearStale();\\n                return false;\\n            } else if (node.isLeaf) {\\n                clearStale();\\n                return true;\\n            }\\n        }\\n        \\n        clearStale();\\n        return false;\\n    }\\n    \\n    private void insert(String s) {\\n        Node ptr = root;\\n        for (char ch : s.toCharArray()) {\\n            if (ptr.children[ch - \\'a\\'] == null) {\\n                ptr.children[ch - \\'a\\'] = new Node();\\n            }\\n            ptr = ptr.children[ch - \\'a\\'];\\n        }\\n        ptr.isLeaf = true;\\n    }\\n    \\n    class Node {\\n        Node[] children;\\n        boolean isLeaf;\\n        \\n        public Node() {\\n            children = new Node[26];\\n            isLeaf = false;\\n        }\\n    }\\n    \\n    // only maxLen query characters need to be maintained\\n    // so we clear the staled characters after each query (adding a new character)\\n    private void clearStale() {\\n        if (queries.length() >= maxLen) {\\n            queries.deleteCharAt(0);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private Node root;\\n    private int maxLen;\\n    private StringBuilder queries;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        maxLen = Integer.MIN_VALUE;\\n        queries = new StringBuilder();\\n        \\n        for (String word : words) {\\n            // reverse word insert into trie\\n            insert(new StringBuilder(word).reverse().toString());\\n            // update maxLen\\n            maxLen = Math.max(maxLen, word.length());\\n        }\\n    }\\n    \\n    // Clear stale before return\\n    public boolean query(char letter) {\\n        queries.append(letter);\\n        Node node = root;\\n        \\n        for (int i = queries.length() - 1; i >= Math.max(0, queries.length() - maxLen); i--) {\\n            // search queries character by character from end in trie\\n            node = node.children[queries.charAt(i) - \\'a\\'];\\n            if (node == null) {\\n                clearStale();\\n                return false;\\n            } else if (node.isLeaf) {\\n                clearStale();\\n                return true;\\n            }\\n        }\\n        \\n        clearStale();\\n        return false;\\n    }\\n    \\n    private void insert(String s) {\\n        Node ptr = root;\\n        for (char ch : s.toCharArray()) {\\n            if (ptr.children[ch - \\'a\\'] == null) {\\n                ptr.children[ch - \\'a\\'] = new Node();\\n            }\\n            ptr = ptr.children[ch - \\'a\\'];\\n        }\\n        ptr.isLeaf = true;\\n    }\\n    \\n    class Node {\\n        Node[] children;\\n        boolean isLeaf;\\n        \\n        public Node() {\\n            children = new Node[26];\\n            isLeaf = false;\\n        }\\n    }\\n    \\n    // only maxLen query characters need to be maintained\\n    // so we clear the staled characters after each query (adding a new character)\\n    private void clearStale() {\\n        if (queries.length() >= maxLen) {\\n            queries.deleteCharAt(0);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338459,
                "title": "java-trie-solutions-for-both-reverse-and-non-reverse",
                "content": "```\\nclass StreamChecker {\\n\\t// reverse\\n    private StringBuilder sb;\\n    \\n    private TrieNode root;\\n    \\n    private int max;\\n    \\n    public StreamChecker(String[] words) {\\n        sb = new StringBuilder();\\n        root = new TrieNode();\\n        max = 0;\\n        for (String word : words) {\\n            insert(word);\\n            max = Math.max(word.length(), max);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        sb.append(letter);\\n        if (sb.length() > max) {\\n            sb.deleteCharAt(0);\\n        }\\n        \\n        TrieNode cur = root;\\n        for (int i = sb.length() - 1; i >= 0; i--) {\\n            int idx = sb.charAt(i) - \\'a\\';\\n            if (cur.children[idx] != null) {\\n                if (cur.children[idx].isEnd) {\\n                    return true;\\n                }\\n                cur = cur.children[idx];\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode cur = root;\\n        for (int i = word.length() - 1; i >= 0; i--) {\\n            int idx = word.charAt(i) - \\'a\\';\\n            if (cur.children[idx] == null) {\\n                cur.children[idx] = new TrieNode();\\n            }\\n            cur = cur.children[idx];\\n        }\\n        cur.isEnd = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isEnd;\\n    \\n    public TrieNode() {\\n        children = new TrieNode[26];\\n        isEnd = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```\\n\\n\\n```\\nclass StreamChecker {\\n    // non-reverse\\n    private Queue<TrieNode> queue;\\n    \\n    private TrieNode root;\\n    \\n    public StreamChecker(String[] words) {\\n        queue = new LinkedList<>();\\n        root = new TrieNode();\\n        queue.offer(root);\\n        queue.offer(null);\\n        \\n        for (String word : words) {\\n            insert(word);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        queue.offer(root);  \\n        \\n        TrieNode cur = queue.poll();\\n        while (cur != null) {\\n            if (cur.children[letter - \\'a\\'] != null) {\\n                queue.offer(cur.children[letter - \\'a\\']);\\n                if (cur.children[letter - \\'a\\'].isEnd) {\\n                    res = true;\\n                }\\n            }\\n            cur = queue.poll();\\n        }\\n        \\n        queue.offer(null);\\n        return res;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode cur = root;\\n        for (char c : word.toCharArray()) {\\n            int idx = c - \\'a\\';\\n            if (cur.children[idx] == null) {\\n                cur.children[idx] = new TrieNode();\\n            }\\n            cur = cur.children[idx];\\n        }\\n        cur.isEnd = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isEnd;\\n    \\n    public TrieNode() {\\n        children = new TrieNode[26];\\n        isEnd = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n\\t// reverse\\n    private StringBuilder sb;\\n    \\n    private TrieNode root;\\n    \\n    private int max;\\n    \\n    public StreamChecker(String[] words) {\\n        sb = new StringBuilder();\\n        root = new TrieNode();\\n        max = 0;\\n        for (String word : words) {\\n            insert(word);\\n            max = Math.max(word.length(), max);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        sb.append(letter);\\n        if (sb.length() > max) {\\n            sb.deleteCharAt(0);\\n        }\\n        \\n        TrieNode cur = root;\\n        for (int i = sb.length() - 1; i >= 0; i--) {\\n            int idx = sb.charAt(i) - \\'a\\';\\n            if (cur.children[idx] != null) {\\n                if (cur.children[idx].isEnd) {\\n                    return true;\\n                }\\n                cur = cur.children[idx];\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode cur = root;\\n        for (int i = word.length() - 1; i >= 0; i--) {\\n            int idx = word.charAt(i) - \\'a\\';\\n            if (cur.children[idx] == null) {\\n                cur.children[idx] = new TrieNode();\\n            }\\n            cur = cur.children[idx];\\n        }\\n        cur.isEnd = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isEnd;\\n    \\n    public TrieNode() {\\n        children = new TrieNode[26];\\n        isEnd = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```\n```\\nclass StreamChecker {\\n    // non-reverse\\n    private Queue<TrieNode> queue;\\n    \\n    private TrieNode root;\\n    \\n    public StreamChecker(String[] words) {\\n        queue = new LinkedList<>();\\n        root = new TrieNode();\\n        queue.offer(root);\\n        queue.offer(null);\\n        \\n        for (String word : words) {\\n            insert(word);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        queue.offer(root);  \\n        \\n        TrieNode cur = queue.poll();\\n        while (cur != null) {\\n            if (cur.children[letter - \\'a\\'] != null) {\\n                queue.offer(cur.children[letter - \\'a\\']);\\n                if (cur.children[letter - \\'a\\'].isEnd) {\\n                    res = true;\\n                }\\n            }\\n            cur = queue.poll();\\n        }\\n        \\n        queue.offer(null);\\n        return res;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode cur = root;\\n        for (char c : word.toCharArray()) {\\n            int idx = c - \\'a\\';\\n            if (cur.children[idx] == null) {\\n                cur.children[idx] = new TrieNode();\\n            }\\n            cur = cur.children[idx];\\n        }\\n        cur.isEnd = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isEnd;\\n    \\n    public TrieNode() {\\n        children = new TrieNode[26];\\n        isEnd = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565720,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1566975,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1568381,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1570129,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1572631,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1569504,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 2066967,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1816944,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            }
        ]
    }
]