[
    {
        "title": "Minimum Cost Tree From Leaf Values",
        "question_content": "Given an array arr of positive integers, consider all binary trees such that:\n\n\tEach node has either 0 or 2 children;\n\tThe values of arr correspond to the values of each leaf in an in-order traversal of the tree.\n\tThe value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\n\nAmong all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.\nA node is a leaf if and only if it has zero children.\n&nbsp;\nExample 1:\n\nInput: arr = [6,2,4]\nOutput: 32\nExplanation: There are two possible trees shown.\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\n\nExample 2:\n\nInput: arr = [4,11]\nOutput: 44\n\n&nbsp;\nConstraints:\n\n\t2 <= arr.length <= 40\n\t1 <= arr[i] <= 15\n\tIt is guaranteed that the answer fits into a 32-bit signed integer (i.e., it is less than 231).",
        "solutions": [
            {
                "id": 339959,
                "title": "one-pass-o-n-time-and-space",
                "content": "# DP Solution\\nFind the cost for the interval `[i,j]`.\\nTo build up the interval `[i,j]`,\\nwe need to split it into left subtree and sub tree,\\n`dp[i, j] = dp[i, k] + dp[k + 1, j] + max(A[i, k]) * max(A[k + 1, j])`\\n\\nIf you don\\'t understand dp solution,\\nI won\\'t explain it more and you won\\'t find the answer here.\\nTake your time,\\nread any other <Easy DP> solutions,\\nand come back at your own will.\\n\\nIf you got it, continue to read.\\n\\n# DP Complexity\\nSecond question after this dp solution,\\n**what\\'s the complexity?**\\n`N^2` states and `O(N)` to find each.\\nSo this solution is `O(N^3)` time and `O(N^2)` space.\\n\\nYou thought it\\'s fine.\\nAfter several nested for loop, you got a happy green accepted.\\nYou smiled and released a sigh as a winner.\\n\\nWhat a great practice for DP skill!\\nThen you noticed it\\'s medium.\\nThat\\'s it, just a standard medium problem of dp.\\nNothing can stop you. Even dp problem.\\n<br>\\n\\n# True story\\nSo you didn\\'t **Read** and **Upvote** this post.\\n(upvote is a good mark of having read)\\nOne day, you meet exactly the same solution during an interview.\\nYour heart welled over with joy,\\nand you bring up your solution with confidence.\\n\\nOne week later, you receive an email.\\nThe second paragraph starts with a key word \"Unfortunately\".\\n\\n**What the heck!?**\\nYou solved the interview problem perfectly,\\nbut the company didn\\'t appreciate your talent.\\nWhat\\'s more on earth did they want?\\n**WHY?**\\n<br>\\n\\n# **Why**\\nHere is the reason.\\nThis is not a dp problem at all.\\n\\nBecause dp solution test all ways to build up the tree,\\nincluding many unnecessay tries.\\nHonestly speaking, it\\'s kinda of brute force.\\nYes, brute force testing, with memorization.\\n<br>\\n\\n# **Intuition**\\nLet\\'s review the problem again.\\n\\nWhen we build a node in the tree, we compared the two numbers `a` and `b`.\\nIn this process,\\nthe smaller one is removed and we won\\'t use it anymore,\\nand the bigger one actually stays.\\n\\nThe problem can translated as following:\\nGiven an array `A`, choose two neighbors in the array `a` and `b`,\\nwe can remove the smaller one `min(a,b)` and the cost is `a * b`.\\nWhat is the minimum cost to remove the whole array until only one left?\\n\\nTo remove a number `a`, it needs a cost `a * b`, where `b >= a`.\\nSo `a` has to be removed by a bigger number.\\nWe want minimize this cost, so we need to minimize `b`.\\n\\n`b` has two candidates, the first bigger number on the left,\\nthe first bigger number on the right.\\n\\nThe cost to remove `a` is `a * min(left, right)`.\\n<br>\\n\\n# **Solution 1**\\nWith the intuition above in mind,\\nthe explanation is short to go.\\n\\nWe remove the element form the smallest to bigger.\\nWe check the `min(left, right)`,\\nFor each element `a`, `cost = min(left, right) * a`\\n\\nTime `O(N^2)`\\nSpace `O(N)`\\n\\n**Python**\\n```py\\n    def mctFromLeafValues(self, A):\\n        res = 0\\n        while len(A) > 1:\\n            i = A.index(min(A))\\n            res += min(A[i - 1:i] + A[i + 1:i + 2]) * A.pop(i)\\n        return res\\n```\\n<br>\\n\\n# **Solution 2: Stack Soluton**\\nwe decompose a hard problem into reasonable easy one:\\nJust find the next greater element in the array, on the left and one right.\\nRefer to the problem [503. Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n<br>\\n\\nTime `O(N)` for one pass\\nSpace `O(N)` for stack in the worst cases\\n<br>\\n\\n**Java:**\\n```java\\n    public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();\\n                res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int mctFromLeafValues(vector<int>& A) {\\n        int res = 0;\\n        vector<int> stack = {INT_MAX};\\n        for (int a : A) {\\n            while (stack.back() <= a) {\\n                int mid = stack.back();\\n                stack.pop_back();\\n                res += mid * min(stack.back(), a);\\n            }\\n            stack.push_back(a);\\n        }\\n        for (int i = 2; i < stack.size(); ++i) {\\n            res += stack[i] * stack[i - 1];\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def mctFromLeafValues(self, A):\\n        res = 0\\n        stack = [float(\\'inf\\')]\\n        for a in A:\\n            while stack[-1] <= a:\\n                mid = stack.pop()\\n                res += mid * min(stack[-1], a)\\n            stack.append(a)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n```\\n<br>\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n- 1130. [Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n- 907. [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n- 901. [Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n- 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n- 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n- 496.  Next Greater Element I\\n- 84. Largest Rectangle in Histogram\\n- 42. Trapping Rain Water\\n",
                "solutionTags": [],
                "code": "```py\\n    def mctFromLeafValues(self, A):\\n        res = 0\\n        while len(A) > 1:\\n            i = A.index(min(A))\\n            res += min(A[i - 1:i] + A[i + 1:i + 2]) * A.pop(i)\\n        return res\\n```\n```java\\n    public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();\\n                res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int mctFromLeafValues(vector<int>& A) {\\n        int res = 0;\\n        vector<int> stack = {INT_MAX};\\n        for (int a : A) {\\n            while (stack.back() <= a) {\\n                int mid = stack.back();\\n                stack.pop_back();\\n                res += mid * min(stack.back(), a);\\n            }\\n            stack.push_back(a);\\n        }\\n        for (int i = 2; i < stack.size(); ++i) {\\n            res += stack[i] * stack[i - 1];\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def mctFromLeafValues(self, A):\\n        res = 0\\n        stack = [float(\\'inf\\')]\\n        for a in A:\\n            while stack[-1] <= a:\\n                mid = stack.pop()\\n                res += mid * min(stack[-1], a)\\n            stack.append(a)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 478708,
                "title": "rz-summary-of-all-the-solutions-i-have-learned-from-discuss-in-python",
                "content": "**1. Dynamic programming approach**\\nWe are given a list of all the leaf nodes values for certain binary trees, but we do not know which leaf nodes belong to left subtree and which leaf nodes belong to right subtree. Since the given leaf nodes are result of inorder traversal, we know there will be pivots that divide arr into left and right, nodes in the left build left subtree and nodes in the right build right subtree. For each subtree, if we know the minimum sum, we can use it to build the result of the parent tree, so the problem can be divided into subproblems, and we have the following general transition equation (res(i, j) means the minimum non-leaf nodes sum with leaf nodes from arr[i] to arr[j]):\\n\\n```\\nfor k from i to j\\n    res(i, j) = min(res(i, k) + res(k + 1, j) + max(arr[i] ... arr[k]) * max(arr[k + 1] ... arr[j]))\\n```\\n\\n**Top down code with memorization ---> O(n ^ 3)**\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        return self.helper(arr, 0, len(arr) - 1, {})\\n        \\n    def helper(self, arr, l, r, cache):\\n        if (l, r) in cache:\\n            return cache[(l, r)]\\n        if l >= r:\\n            return 0\\n        \\n        res = float(\\'inf\\')\\n        for i in range(l, r):\\n            rootVal = max(arr[l:i+1]) * max(arr[i+1:r+1])\\n            res = min(res, rootVal + self.helper(arr, l, i, cache) + self.helper(arr, i + 1, r, cache))\\n        \\n        cache[(l, r)] = res\\n        return res\\n```\\n\\n**Bottom up code ---> O(n ^ 3)**\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = 0\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                j = i + l - 1\\n                for k in range(i, j):\\n                    rootVal = max(arr[i:k+1]) * max(arr[k+1:j+1])\\n                    dp[i][j] = min(dp[i][j], rootVal + dp[i][k] + dp[k + 1][j])\\n        return dp[0][n - 1]\\n```\\n\\n**2. Greedy approach ---> O(n ^ 2)**\\nAbove approach is kind of like brute force since we calculate and compare the results all possible pivots. To achieve a better time complexity, one important observation is that when we build each level of the binary tree, it is the max left leaf node and max right lead node that are being used, so we would like to put big leaf nodes close to the root. Otherwise, taking the leaf node with max value in the array as an example, if its level is deep, for each level above it, its value will be used to calculate the non-leaf node value, which will result in a big total sum.\\n\\nWith above observation, the greedy approach is to find the smallest value in the array, use it and its smaller neighbor to build a non-leaf node, then we can safely delete it from the array since it has a smaller value than its neightbor so it will never be used again. Repeat this process until there is only one node left in the array (which means we cannot build a new level any more)\\n\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            index = arr.index(min(arr))\\n            if 0 < index < len(arr) - 1:\\n                res += arr[index] * min(arr[index - 1], arr[index + 1])\\n            else:\\n                res += arr[index] * (arr[index + 1] if index == 0 else arr[index - 1])\\n            arr.pop(index)\\n        return res\\n```\\n\\n**3. Monotonic stack approach ---> O(n)**\\nIn the greedy approach of 2), every time we delete the current minimum value, we need to start over and find the next smallest value again, so repeated operations are more or less involved. To further accelerate it, one observation is that for each leaf node in the array, when it becomes the minimum value in the remaining array, its left and right neighbors will be the first bigger value in the original array to its left and right. This observation is a clue of a possible monotonic stack solution as follows.\\n\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        stack = [float(\\'inf\\')]\\n        res = 0\\n        for num in arr:\\n            while stack and stack[-1] <= num:\\n                cur = stack.pop()\\n                if stack:\\n                    res += cur * min(stack[-1], num)\\n            stack.append(num)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nfor k from i to j\\n    res(i, j) = min(res(i, k) + res(k + 1, j) + max(arr[i] ... arr[k]) * max(arr[k + 1] ... arr[j]))\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        return self.helper(arr, 0, len(arr) - 1, {})\\n        \\n    def helper(self, arr, l, r, cache):\\n        if (l, r) in cache:\\n            return cache[(l, r)]\\n        if l >= r:\\n            return 0\\n        \\n        res = float(\\'inf\\')\\n        for i in range(l, r):\\n            rootVal = max(arr[l:i+1]) * max(arr[i+1:r+1])\\n            res = min(res, rootVal + self.helper(arr, l, i, cache) + self.helper(arr, i + 1, r, cache))\\n        \\n        cache[(l, r)] = res\\n        return res\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = 0\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                j = i + l - 1\\n                for k in range(i, j):\\n                    rootVal = max(arr[i:k+1]) * max(arr[k+1:j+1])\\n                    dp[i][j] = min(dp[i][j], rootVal + dp[i][k] + dp[k + 1][j])\\n        return dp[0][n - 1]\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            index = arr.index(min(arr))\\n            if 0 < index < len(arr) - 1:\\n                res += arr[index] * min(arr[index - 1], arr[index + 1])\\n            else:\\n                res += arr[index] * (arr[index + 1] if index == 0 else arr[index - 1])\\n            arr.pop(index)\\n        return res\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        stack = [float(\\'inf\\')]\\n        res = 0\\n        for num in arr:\\n            while stack and stack[-1] <= num:\\n                cur = stack.pop()\\n                if stack:\\n                    res += cur * min(stack[-1], num)\\n            stack.append(num)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340014,
                "title": "greedy-python-solution",
                "content": "The thought is quite straight forward.\\n1. Pick up the leaf node with minimum value.\\n2. Combine it with its inorder neighbor which has smaller value between neighbors.\\n3. Once we get the new generated non-leaf node, the node with minimum value is useless (For the new generated subtree will be represented with the largest leaf node value.)\\n4. Repeat it until there is only one node.\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            mini_idx = arr.index(min(arr))\\n            if 0 < mini_idx < len(arr) - 1:\\n                res += min(arr[mini_idx - 1], arr[mini_idx + 1]) * arr[mini_idx]\\n            else:\\n                res += arr[1 if mini_idx == 0 else mini_idx - 1] * arr[mini_idx]\\n            arr.pop(mini_idx)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            mini_idx = arr.index(min(arr))\\n            if 0 < mini_idx < len(arr) - 1:\\n                res += min(arr[mini_idx - 1], arr[mini_idx + 1]) * arr[mini_idx]\\n            else:\\n                res += arr[1 if mini_idx == 0 else mini_idx - 1] * arr[mini_idx]\\n            arr.pop(mini_idx)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340033,
                "title": "c-with-comments",
                "content": "**Intuition and Algorithm**\\nGiven an array <code>arr</code> return the smallest possible sum of the values of each non-leaf node.\\nThe value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.\\n\\nFor example:\\narr= [3, 6, 4, 7, 2, 5]\\n\\n![image](https://assets.leetcode.com/users/hamlet_fiis/image_1563683100.png)\\n\\n\\n\\nThis is one distribution, we are going to solve that from top to bottom with dynammic programming\\n\\n**Approach 1 (DP)**\\nIn the image the root, their left subtree contains indexes [0-3] and their right subtree cointains indexes [4-5]. Then their value will be max(arr[0-3])* max(arr[4-5]).\\n\\nIn general:\\n<code> dp(left, right )=  min(   max(arr[left .. i] ) * max(arr[i+1 .. right]) + dp(left,i) +dp(i+1,right) )</code> where <code>i</code> go from <code>left </code>to <code>right-1</code>\\n\\nIn our previous formula <code>i</code> divide the root in [left .. i] left subtree and [i+1.. right]  right subtree.\\n\\n```\\nclass Solution {\\npublic:\\n    int memo[41][41];\\n    int maxi[41][41];\\n    \\n    int dp(int left,int right){\\n        if(left==right)return 0; //leaf node\\n        if(memo[left][right]!=-1)return memo[left][right];\\n        \\n        int ans = 1<<30;\\n        \\n        for(int i=left;i<right;i++)\\n            ans= min(ans, maxi[left][i] * maxi[i+1][right] + dp(left,i) + dp(i+1,right) );\\n        \\n        memo[left][right]=ans;\\n        return ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(memo,-1,sizeof(memo));\\n        for(int i=0;i<arr.size();i++){\\n            maxi[i][i] = arr[i];\\n            for(int j=i+1;j<arr.size();j++)\\n                maxi[i][j] = max(maxi[i][j-1], arr[j]);\\n        }\\n        \\n        return dp(0,arr.size()-1);\\n    }\\n};\\n```\\n\\n<b>Complexity Analysis </b>\\n* Time Complexity: O(n* n * n) where n is the length of arr\\n* Space Complexity: O(n*n) where n is the length of arr\\n\\n**Approach 2 (Greedy+ Linked list)**\\n<ol>\\n<li>Pick up the minimum element in the array (val1)</li>\\n<li>Check their neighbors (left and right) and choose the minimum value betweem them (val2)</li>\\n<li>Accumulate this product to your answer (ans+=val1*val2) then delete the element (val1) in step 1.\\n<li>Repeat it until there is one element in the array.\\n</ol>\\n\\n**How can I do it efficiently?**\\nIt\\'s possible to do it in O(n* log(n)) sorting the array, but it has small values, arr[i]<=15. (counting sort is enough)\\nI need to know the neighbors of an element, after each delete operation (uses Linked list)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        vector<int>adj[16];\\n        int n= arr.size();\\n        \\n        for(int i=0;i<n;i++)\\n            adj[arr[i]].push_back(i);\\n        \\n        int left[n];\\n        for(int i=0;i<n;i++)left[i]=i-1;\\n        int right[n];\\n        for(int i=0;i<n;i++)right[i]=i+1;\\n        \\n        int ans=0;\\n        \\n        for(int i=1;i<=15;i++){\\n            for(int j=0;j<adj[i].size();j++){\\n                int id= adj[i][j]; // index id in our array arr, global minimum\\n                int next_greater=0; // minimum element between their neighbor (first check if they are valid)\\n                if(left[id]==-1 && right[id]!=n){\\n                    next_greater=arr[right[id]];\\n                }else if(left[id]!=-1 && right[id]==n){\\n                    next_greater=arr[left[id]];\\n                }else if(left[id]!=-1 && right[id]!=n){\\n                    next_greater=min(arr[left[id]],arr[right[id]]);\\n                }\\n                \\n\\t\\t\\t\\t//delete index id in our Linked list\\n                if(right[id]!=n)\\n                    left[right[id]]= left[id];\\n                if(left[id]!=-1)\\n                    right[left[id]]= right[id];\\n\\t\\t\\t\\t\\t\\n                ans+=next_greater*i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Complexity Analysis </b>\\n* Time Complexity: O(n) where n is the length of arr\\n* Space Complexity: O(n) where n is the length of arr\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[41][41];\\n    int maxi[41][41];\\n    \\n    int dp(int left,int right){\\n        if(left==right)return 0; //leaf node\\n        if(memo[left][right]!=-1)return memo[left][right];\\n        \\n        int ans = 1<<30;\\n        \\n        for(int i=left;i<right;i++)\\n            ans= min(ans, maxi[left][i] * maxi[i+1][right] + dp(left,i) + dp(i+1,right) );\\n        \\n        memo[left][right]=ans;\\n        return ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(memo,-1,sizeof(memo));\\n        for(int i=0;i<arr.size();i++){\\n            maxi[i][i] = arr[i];\\n            for(int j=i+1;j<arr.size();j++)\\n                maxi[i][j] = max(maxi[i][j-1], arr[j]);\\n        }\\n        \\n        return dp(0,arr.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        vector<int>adj[16];\\n        int n= arr.size();\\n        \\n        for(int i=0;i<n;i++)\\n            adj[arr[i]].push_back(i);\\n        \\n        int left[n];\\n        for(int i=0;i<n;i++)left[i]=i-1;\\n        int right[n];\\n        for(int i=0;i<n;i++)right[i]=i+1;\\n        \\n        int ans=0;\\n        \\n        for(int i=1;i<=15;i++){\\n            for(int j=0;j<adj[i].size();j++){\\n                int id= adj[i][j]; // index id in our array arr, global minimum\\n                int next_greater=0; // minimum element between their neighbor (first check if they are valid)\\n                if(left[id]==-1 && right[id]!=n){\\n                    next_greater=arr[right[id]];\\n                }else if(left[id]!=-1 && right[id]==n){\\n                    next_greater=arr[left[id]];\\n                }else if(left[id]!=-1 && right[id]!=n){\\n                    next_greater=min(arr[left[id]],arr[right[id]]);\\n                }\\n                \\n\\t\\t\\t\\t//delete index id in our Linked list\\n                if(right[id]!=n)\\n                    left[right[id]]= left[id];\\n                if(left[id]!=-1)\\n                    right[left[id]]= right[id];\\n\\t\\t\\t\\t\\t\\n                ans+=next_greater*i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398420,
                "title": "java-dp-solution-very-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        int[][] dp = new int[n][n];\\n        return dfs(arr, 0, n - 1, dp);\\n    }\\n    \\n    public int dfs(int[] arr, int s, int e, int[][] dp) {\\n        if (s == e) return 0;\\n        if (dp[s][e] > 0) return dp[s][e];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = s; i < e; i++) {\\n            int left = dfs(arr, s, i, dp);\\n            int right = dfs(arr, i + 1, e, dp);\\n            int maxLeft = 0, maxRight = 0;\\n            for (int j = s; j <= i; j++) maxLeft = Math.max(maxLeft, arr[j]);\\n            for (int j = i + 1; j <= e; j++) maxRight = Math.max(maxRight, arr[j]);\\n            ans = Math.min(ans, left + right + maxLeft * maxRight);\\n        }\\n        dp[s][e] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        int[][] dp = new int[n][n];\\n        return dfs(arr, 0, n - 1, dp);\\n    }\\n    \\n    public int dfs(int[] arr, int s, int e, int[][] dp) {\\n        if (s == e) return 0;\\n        if (dp[s][e] > 0) return dp[s][e];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = s; i < e; i++) {\\n            int left = dfs(arr, s, i, dp);\\n            int right = dfs(arr, i + 1, e, dp);\\n            int maxLeft = 0, maxRight = 0;\\n            for (int j = s; j <= i; j++) maxLeft = Math.max(maxLeft, arr[j]);\\n            for (int j = i + 1; j <= e; j++) maxRight = Math.max(maxRight, arr[j]);\\n            ans = Math.min(ans, left + right + maxLeft * maxRight);\\n        }\\n        dp[s][e] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476513,
                "title": "java-mono-stack-98-example-to-explain",
                "content": "```\\nclass Solution {\\n    // Use stack. Similar to trapping the rain water problem and the largest rectangle under histogram\\n    // Use stack to keep a decreasing order by adding smaller values, while there is bigger value \\n    //arr[i] than the peek, pop it and store as mid and calculate the multiplication mid*min(arr[i],  \\n    //stack.peek()).\\n    \\n    // NOTE: if we observe the number array, in order to obtain the smallest sum of all non-leaf\\n    // values, we want to merge those small values first. In order words, the smaller a value\\n    // is, the lower leaf it should stay because this way as we are building the tree up, \\n    // we are building smaller multiplication/parent node first as it is only going to get bigger\\n\\t// as we build the tree up. \\n    \\n    // Ex: 4 3 2 1 5\\n    // There are many ways we can build a tree following the problem\\'s requirement. However, to \\n    // gain smallest sum. We need to merge 2 and 1 first as they are the two smallest ones. To\\n\\t// do that, we use the stack mentioned above as a decreasing order. After\\n    // that we get a parent node with value 2. This node could be a left or right child of its parent\\n    // but what we want is that its parent needs also be as small as possible. We also know that its\\n    // parent has one mutiplier already: 2. Note: this 2 is not from the product of 1 * 2, but from the max  of child\\n    // 1 and 2 as the problem requires. So, we see what values next to the leaf 2 could be a \\n\\t// candidate. Obviously, 3 since it is the smallest one in the stack Then, 3\\n    // becomes the left child and 1*2 = 2 becomes right child. See below: \\n    //  ...\\n    //  / \\\\\\n    // 3   2\\n    //    / \\\\\\n    //   2   1\\n    // \\n    \\n    // If we observe carefully, 3 2 1 is decreasing... So how about every time we see a \"dip\" point\\n    // in the array we calculate its multiplication. To do that, say we are at arr[i] and their \\n    // relations are arr[i-1] <= arr[i] <= arr[i+1]. The min multiplication is a[i] * min(arr[i-1], \\n    // arr[i+1]). Then the example above is arr[i] = 1, arr[i-1] = 2, arr[i+1] = 5\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n          if(arr == null || arr.length < 2){\\n              return 0;\\n          }\\n          \\n          int res = 0;\\n          Stack<Integer> stack = new Stack<>();          \\n          for(int num : arr){\\n              \\n             // while num is bigger than peek(), pop and calculate\\n             while(!stack.isEmpty() && stack.peek() <= num){\\n                 int mid = stack.pop();\\n                 if(stack.isEmpty()) \\n                     res += mid * num;\\n                 else\\n                    res += mid * Math.min(stack.peek(), num);\\n             }\\n             \\n             stack.push(num); // if num is smaller, push into stack\\n         }\\n         \\n         // if there are values left in the stack, they sure will be mutiplied anyway\\n         // and added to the result. \\n         while(stack.size() > 1){ // > 1 because we have a peek() after pop() below\\n             res += stack.pop() * stack.peek();\\n         }\\n         \\n         return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Use stack. Similar to trapping the rain water problem and the largest rectangle under histogram\\n    // Use stack to keep a decreasing order by adding smaller values, while there is bigger value \\n    //arr[i] than the peek, pop it and store as mid and calculate the multiplication mid*min(arr[i],  \\n    //stack.peek()).\\n    \\n    // NOTE: if we observe the number array, in order to obtain the smallest sum of all non-leaf\\n    // values, we want to merge those small values first. In order words, the smaller a value\\n    // is, the lower leaf it should stay because this way as we are building the tree up, \\n    // we are building smaller multiplication/parent node first as it is only going to get bigger\\n\\t// as we build the tree up. \\n    \\n    // Ex: 4 3 2 1 5\\n    // There are many ways we can build a tree following the problem\\'s requirement. However, to \\n    // gain smallest sum. We need to merge 2 and 1 first as they are the two smallest ones. To\\n\\t// do that, we use the stack mentioned above as a decreasing order. After\\n    // that we get a parent node with value 2. This node could be a left or right child of its parent\\n    // but what we want is that its parent needs also be as small as possible. We also know that its\\n    // parent has one mutiplier already: 2. Note: this 2 is not from the product of 1 * 2, but from the max  of child\\n    // 1 and 2 as the problem requires. So, we see what values next to the leaf 2 could be a \\n\\t// candidate. Obviously, 3 since it is the smallest one in the stack Then, 3\\n    // becomes the left child and 1*2 = 2 becomes right child. See below: \\n    //  ...\\n    //  / \\\\\\n    // 3   2\\n    //    / \\\\\\n    //   2   1\\n    // \\n    \\n    // If we observe carefully, 3 2 1 is decreasing... So how about every time we see a \"dip\" point\\n    // in the array we calculate its multiplication. To do that, say we are at arr[i] and their \\n    // relations are arr[i-1] <= arr[i] <= arr[i+1]. The min multiplication is a[i] * min(arr[i-1], \\n    // arr[i+1]). Then the example above is arr[i] = 1, arr[i-1] = 2, arr[i+1] = 5\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n          if(arr == null || arr.length < 2){\\n              return 0;\\n          }\\n          \\n          int res = 0;\\n          Stack<Integer> stack = new Stack<>();          \\n          for(int num : arr){\\n              \\n             // while num is bigger than peek(), pop and calculate\\n             while(!stack.isEmpty() && stack.peek() <= num){\\n                 int mid = stack.pop();\\n                 if(stack.isEmpty()) \\n                     res += mid * num;\\n                 else\\n                    res += mid * Math.min(stack.peek(), num);\\n             }\\n             \\n             stack.push(num); // if num is smaller, push into stack\\n         }\\n         \\n         // if there are values left in the stack, they sure will be mutiplied anyway\\n         // and added to the result. \\n         while(stack.size() > 1){ // > 1 because we have a peek() after pop() below\\n             res += stack.pop() * stack.peek();\\n         }\\n         \\n         return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474188,
                "title": "i-think-i-able-to-explain-it-to-myself-and-to-you-java-dp-complexity-is-in-the-question",
                "content": "I borrow the solution from this user https://leetcode.com/qixu\\nThank you, dear!\\nBut I changed names and added explanations (see the code below, run it, it shows some things on the run, also read my comments in the code):\\n\\n1.\\nThe idea is to slide over the array, looking into the each variant of leaves distribution between the left and the right sub-tree\\nFor example, with the array 6,2,4 \\nwe look at following variants:\\n(a)Left : 6, Right: 2,4\\n(b)Left: 6, 2 Right 4\\n\\nThe variant (a) in its right part is not demanding further subtrees, because we have only 2 leaves 2 and 4,\\nand according to the condition of the task, we can have only 0 or 2 leaves per not leaf node, so those 2 will certainly be children of the 1 non-leaf node. But, if you imagine a larger array and if you have on the right like 3 numbers, for example 3,4,5, in such case you will be required to divide this right sub-tree into the smaller sub-sub-trees, like\\n(a.a) Left : 3, Right 4,5\\n(a.b) Left: 3,4, Right 5\\n\\nYou got the idea?\\n\\nYou sort of slide over the array and take all possible variants of leaves distribution....entering the recursion, if the remaining array could be divided further.\\n\\nExample array:\\n1,2,3,4\\n\\nVariants\\n1  and 2,3,4\\n1,2 and 3,4\\n1,2,3 and 4\\n\\n1-st variant divided further in its right part on 2 variants\\n2 and 3,4\\n2,3 and 4\\n\\n3-d variant divided on 2 in its left part\\n1 and 2,3\\n2,3 and 1\\n\\nYou see? Sub-trees of trees? This is where recursion works...\\n\\n\\n\\n2)\\nYou remember the fact, that non-leaf node value formed from the MAX(of all leaf values left of me) and MAX ( of all leaf values right of me) , put it shorter MAX(left leaves) * MAX (right leaves) , remember that!\\nIf you are the lowest node, but not a leaf, you must have 2 leaves! Thus, your value will be formed by \\nMAX (my left child alone) * MAX (my right child alone)\\n\\n3)\\nIf you are the TOP non leaf node, the highest one, your value is also \\nMAX(left leaves) * MAX (right leaves)\\nAnd if you wish to sum the all NON-LEAF nodes you take yourself: MAX(left leaves) * MAX (right leaves)\\nand add to that all values(of all non leaves) that you recursively got from left and from right, thus:\\n\\nSUM(of all non leaf) = TOP_NON_LEAF + left_non_leaves + right_non_leaves = \\n(in short and as in the code below)\\nvalueOfTheNonLeafNode + left + right\\n\\n4)\\nmemo[][] we use to memorize previously computed values for subtrees\\n\\nif we had only 2 nodes , for example 1 and 2\\nmemo would be 2x2 matrix\\ni=0, j=1 cell is keeping the computation result of the variant , where start=0 and end =1\\nIt is the all results this short array[]{1,2} able to produce\\ni=0, j=0 is also tried in the int left = minSumOfNonLeafNodes(arr, startIndex, i, memo);\\nbut it returns 0 from that call and never gets to insert into memo[][] , the value retuurned here:\\n        \\n\\t\\t```\\n\\t   if (startIndex >= endIndex) {\\n            return 0;\\n        }\\n\\t```\\n\\nbut wider arrays, like that:\\n6,2,4\\nproduce some memo, like:\\nmemo=[1][2]=8\\nmemo=[0][1]=12\\nmemo=[0][2]=32\\nDo we understand why?\\nLet\\'s try;\\nIndexes: 0  1   2\\nValues:    6  2   4\\nmemo[1][2] formed by 2, 4 - here we see that examined 2 and 4, when they are both in the right sub tree\\nmemo[0][1] formed by 6, 2 - here we see that examined 6 and 2, when they are both in the left sub tree        \\nmemo[0][2] formed by 6, 2, 4  - it is the result of 2 aforementioned variants combined:\\n6  and 2,4 (this variant gives 32)\\nand\\n6,2 and 4 (this variant gives 36)\\n32 is selected from both.\\n\\n\\n\\n\\n5.\\nComplexity\\nWith space it is N^2\\n\\nWith time, I\\'m not sure, if you know - tell us\\nI think we have n possible recursive branches\\nAnd the max depth of the branch is N-2\\nThus it looks for me that O( n ^ (n-2)), which is O(N^N)\\nBut this is without memo...\\nWith memo...this is the question...\\nI only able to practically establish that for\\n10 elements 241 memo calculated\\n100 elements 5047 memo  calculated\\n1000 elements 500497 memo  calculated\\nIt looks like N^2 ...But I do not know will that change above 1000, cause I have stack overfolow\\n\\n\\nWhat do you think?\\n\\n\\n\\n```\\npublic int mctFromLeafValues(int[] arr) {\\n\\n        if (arr == null || arr.length == 0) {\\n            return 0;\\n        }\\n\\n        int[][] memo = new int[arr.length][arr.length];\\n\\n        return minSumOfNonLeafNodes(arr, 0, arr.length - 1, memo);\\n\\n    }\\n\\n    private int minSumOfNonLeafNodes(int[] arr, int startIndex, int endIndex, int[][] memo) {\\n\\n        //$$$ - note, here recursion stops, start==end\\n        if (startIndex >= endIndex) {\\n            return 0;\\n        }\\n\\n        if (memo[startIndex][endIndex]  !=  0) {\\n            return memo[startIndex][endIndex];\\n        }\\n\\n\\n        int res = Integer.MAX_VALUE;\\n\\n        for (int i = startIndex; i < endIndex; i++) {\\n            //first time it returns 0, when recursion stops at $$$\\n            int left = minSumOfNonLeafNodes(arr, startIndex, i, memo);\\n            //first time it returns 0, when recursion stops at $$$\\n            int right = minSumOfNonLeafNodes(arr, i + 1, endIndex, memo);\\n\\n            int maxLeft = 0;\\n\\n            int maxRight = 0;\\n\\n            for (int j = startIndex; j <= i; j++) {\\n                maxLeft = Math.max(maxLeft, arr[j]);\\n            }\\n\\n            for (int j = i + 1; j <= endIndex; j++) {\\n                maxRight = Math.max(maxRight, arr[j]);\\n            }\\n\\n            int valueOfTheNonLeafNode = maxLeft * maxRight;\\n\\n            //first time left==0 and right==0, we have only valueOfTheNonLeafNode present - \\n            //it means we are in the lowest NOT LEAF NODE\\n            res = Math.min(res, valueOfTheNonLeafNode + left + right);\\n        }\\n        memo[startIndex][endIndex] = res;\\n        System.out.println(\"memo=[\"+startIndex+\"][\"+endIndex+\"]=\"+res);\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t   if (startIndex >= endIndex) {\\n            return 0;\\n        }\\n\\t```\n```\\npublic int mctFromLeafValues(int[] arr) {\\n\\n        if (arr == null || arr.length == 0) {\\n            return 0;\\n        }\\n\\n        int[][] memo = new int[arr.length][arr.length];\\n\\n        return minSumOfNonLeafNodes(arr, 0, arr.length - 1, memo);\\n\\n    }\\n\\n    private int minSumOfNonLeafNodes(int[] arr, int startIndex, int endIndex, int[][] memo) {\\n\\n        //$$$ - note, here recursion stops, start==end\\n        if (startIndex >= endIndex) {\\n            return 0;\\n        }\\n\\n        if (memo[startIndex][endIndex]  !=  0) {\\n            return memo[startIndex][endIndex];\\n        }\\n\\n\\n        int res = Integer.MAX_VALUE;\\n\\n        for (int i = startIndex; i < endIndex; i++) {\\n            //first time it returns 0, when recursion stops at $$$\\n            int left = minSumOfNonLeafNodes(arr, startIndex, i, memo);\\n            //first time it returns 0, when recursion stops at $$$\\n            int right = minSumOfNonLeafNodes(arr, i + 1, endIndex, memo);\\n\\n            int maxLeft = 0;\\n\\n            int maxRight = 0;\\n\\n            for (int j = startIndex; j <= i; j++) {\\n                maxLeft = Math.max(maxLeft, arr[j]);\\n            }\\n\\n            for (int j = i + 1; j <= endIndex; j++) {\\n                maxRight = Math.max(maxRight, arr[j]);\\n            }\\n\\n            int valueOfTheNonLeafNode = maxLeft * maxRight;\\n\\n            //first time left==0 and right==0, we have only valueOfTheNonLeafNode present - \\n            //it means we are in the lowest NOT LEAF NODE\\n            res = Math.min(res, valueOfTheNonLeafNode + left + right);\\n        }\\n        memo[startIndex][endIndex] = res;\\n        System.out.println(\"memo=[\"+startIndex+\"][\"+endIndex+\"]=\"+res);\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346487,
                "title": "greedy-o-n-2-solution-clean-c-code-with-description",
                "content": "**Description**\\n\\n* Until the size of the array is more than 1;\\n  * Find the least a[i] * a[i+1] product and accumulate it;\\n  * Remove the least element which is min of the multipliers\\n  \\n ```\\n   int mctFromLeafValues(vector<int>& a) \\n    {\\n        int sum = 0;\\n        while(a.size() > 1)\\n        {\\n            int min_product = INT_MAX;   // min(a[0]*a[1], ... a[N-1]*a[N])\\n            int me_index = -1;           // min(a[i], a[i+1])\\n            \\n            for(int i = 1; i < a.size(); ++i)\\n            {\\n                if( min_product > a[i-1]*a[i])\\n                {\\n                    me_index = a[i-1] < a[i] ? i - 1 : i;\\n                    min_product = a[i-1]*a[i];\\n                }\\n            }\\n            sum += min_product;\\n            a.erase(a.begin() + me_index);\\n        }\\n        \\n        return sum;\\n    }\\n```\\n\\t\\nPlease, upvote if you find my post useful.",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n   int mctFromLeafValues(vector<int>& a) \\n    {\\n        int sum = 0;\\n        while(a.size() > 1)\\n        {\\n            int min_product = INT_MAX;   // min(a[0]*a[1], ... a[N-1]*a[N])\\n            int me_index = -1;           // min(a[i], a[i+1])\\n            \\n            for(int i = 1; i < a.size(); ++i)\\n            {\\n                if( min_product > a[i-1]*a[i])\\n                {\\n                    me_index = a[i-1] < a[i] ? i - 1 : i;\\n                    min_product = a[i-1]*a[i];\\n                }\\n            }\\n            sum += min_product;\\n            a.erase(a.begin() + me_index);\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340027,
                "title": "java-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        int[][] max = new int[arr.length][arr.length];\\n        for(int i = 0; i < arr.length; i ++) {\\n            int localMax = 0;\\n            for(int j = i; j < arr.length; j ++) {\\n                if(arr[j] > localMax) {\\n                    localMax = arr[j];\\n                }\\n                max[i][j] = localMax;\\n            }\\n        }\\n        for(int len = 1; len < arr.length; len ++) {\\n            for(int left = 0; left + len < arr.length; left ++) {\\n                int right = left + len;\\n                dp[left][right] = Integer.MAX_VALUE;\\n                if(len == 1) {\\n                    dp[left][right] = arr[left]*arr[right];\\n                } else {\\n                    for(int k = left; k < right; k ++) {\\n                        dp[left][right] = Math.min(dp[left][right], dp[left][k] + dp[k+1][right] + max[left][k]*max[k+1][right]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][arr.length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        int[][] max = new int[arr.length][arr.length];\\n        for(int i = 0; i < arr.length; i ++) {\\n            int localMax = 0;\\n            for(int j = i; j < arr.length; j ++) {\\n                if(arr[j] > localMax) {\\n                    localMax = arr[j];\\n                }\\n                max[i][j] = localMax;\\n            }\\n        }\\n        for(int len = 1; len < arr.length; len ++) {\\n            for(int left = 0; left + len < arr.length; left ++) {\\n                int right = left + len;\\n                dp[left][right] = Integer.MAX_VALUE;\\n                if(len == 1) {\\n                    dp[left][right] = arr[left]*arr[right];\\n                } else {\\n                    for(int k = left; k < right; k ++) {\\n                        dp[left][right] = Math.min(dp[left][right], dp[left][k] + dp[k+1][right] + max[left][k]*max[k+1][right]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][arr.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340004,
                "title": "python-easy-dp",
                "content": "When we check root, we find that the value of root only depends on how we divide the left arr and right arr. Thus dp(i,j) = dp(i,k) + dp(k+1,j) + value of root.\\nUse the relation, and we have this dp solution.\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        self.memo = {}\\n        def dp(i,j):\\n            if j<=i:\\n                return 0\\n            if (i,j) not in self.memo:\\n                res = float(\\'inf\\')\\n                for k in range(i+1,j+1):\\n                    res = min(dp(i,k-1)+dp(k,j)+max(arr[i:k])*max(arr[k:j+1]),res)\\n                self.memo[(i,j)] = res\\n            return self.memo[(i,j)]\\n        return dp(0,len(arr)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        self.memo = {}\\n        def dp(i,j):\\n            if j<=i:\\n                return 0\\n            if (i,j) not in self.memo:\\n                res = float(\\'inf\\')\\n                for k in range(i+1,j+1):\\n                    res = min(dp(i,k-1)+dp(k,j)+max(arr[i:k])*max(arr[k:j+1]),res)\\n                self.memo[(i,j)] = res\\n            return self.memo[(i,j)]\\n        return dp(0,len(arr)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340080,
                "title": "dp-solution-explained-c-priority-queue",
                "content": "**Approach :**\\n* Approach towards the solution is to partition the leaf nodes at all possible places, calculate the cost for each partition and return the minimum sum of both part.\\n\\n* Non-leaf cost from any subarray from i to j (product of two maximum val) is always same. No matter how you partition the subarray.\\n\\n* We split the leaf nodes A<sub>i</sub>, A<sub>i+1</sub>, ..... , A<sub>j-1</sub>, A<sub>j</sub> between A<sub>k</sub> and A<sub>k+1</sub> where i<k<j then compute the sub problem for A<sub>i</sub>, .... , A<sub>k</sub> and A<sub>k+1</sub>, ... , A<sub>j</sub> and add both result plus the cost of multiplying two largest value in A<sub>i</sub>, ... , A<sub>j</sub>.\\n```\\n         leaf nodes :  [3,4,2,5,3,7]\\n         We can partition it in following ways:\\n         [3] | [4,2,5,3,7]\\n         [3,4] | [2,5,3,7]\\n         [3,4,2] | [5,3,7]\\n         [3,4,2,5] | [3,7]\\n         [3,4,2,5,3] | [7]\\n```\\n* Since we can see overlapping subproblems easily.\\n```\\n1. [3,4] | [2,5,3,7] ---> [3,4] || [2] | [5,3,7]\\n2. [3,4,2] | [5,3,7] \\n\\n[5,3,7] is example of overlapping subproblem.\\n```\\n\\n* We can use a 2D array to store minimum non-leaf sum from any index i to j to avoid solving repeatedly.\\n\\n* Question is similar like [MIXTURES on SPOJ](https://www.spoj.com/problems/MIXTURES/), this [explaination](https://www.youtube.com/watch?v=XHjjIJxnAJY) may help.\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return solve(arr,0,n-1,dp);\\n    }\\n    \\n    int solve(vector<int>&arr, int low, int high,vector<vector<int>> &dp){\\n        // if we have a single leaf node, then smallest possible sum\\n        // of non-leaf node is zero.\\n        if(low == high) return 0;\\n        \\n        // dp[i][j] --> smallest possible sum of value of each non-leaf node of\\n        // subarray from i to j both inclusive\\n        if(dp[low][high] != -1) return dp[low][high];\\n        \\n        // priority_queue is being used to find two max values in range [i...j]\\n        priority_queue<int> pq(arr.begin()+low, arr.begin()+high+1);\\n        int a = pq.top();\\n        pq.pop();\\n        int b = pq.top();\\n        pq.pop();\\n\\t\\t\\n        // maxProduct hold product of two maximum values in given range\\n        int maxProduct = a*b;\\n        \\n        int minSum = INT_MAX;\\n        for(int i=low; i<high; i++){\\n            minSum = min(minSum, solve(arr,low,i,dp) + solve(arr,i+1,high,dp));\\n        }\\n        return dp[low][high] = minSum + maxProduct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n         leaf nodes :  [3,4,2,5,3,7]\\n         We can partition it in following ways:\\n         [3] | [4,2,5,3,7]\\n         [3,4] | [2,5,3,7]\\n         [3,4,2] | [5,3,7]\\n         [3,4,2,5] | [3,7]\\n         [3,4,2,5,3] | [7]\\n```\n```\\n1. [3,4] | [2,5,3,7] ---> [3,4] || [2] | [5,3,7]\\n2. [3,4,2] | [5,3,7] \\n\\n[5,3,7] is example of overlapping subproblem.\\n```\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return solve(arr,0,n-1,dp);\\n    }\\n    \\n    int solve(vector<int>&arr, int low, int high,vector<vector<int>> &dp){\\n        // if we have a single leaf node, then smallest possible sum\\n        // of non-leaf node is zero.\\n        if(low == high) return 0;\\n        \\n        // dp[i][j] --> smallest possible sum of value of each non-leaf node of\\n        // subarray from i to j both inclusive\\n        if(dp[low][high] != -1) return dp[low][high];\\n        \\n        // priority_queue is being used to find two max values in range [i...j]\\n        priority_queue<int> pq(arr.begin()+low, arr.begin()+high+1);\\n        int a = pq.top();\\n        pq.pop();\\n        int b = pq.top();\\n        pq.pop();\\n\\t\\t\\n        // maxProduct hold product of two maximum values in given range\\n        int maxProduct = a*b;\\n        \\n        int minSum = INT_MAX;\\n        for(int i=low; i<high; i++){\\n            minSum = min(minSum, solve(arr,low,i,dp) + solve(arr,i+1,high,dp));\\n        }\\n        return dp[low][high] = minSum + maxProduct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510611,
                "title": "greedy-approach-97-faster-well-explained",
                "content": "## IDEA :\\n**The key idea is to choose the minimum value leaf node and combine it with its neighbour which gives minimum product.**\\n\\nExample Taken from https://leetcode.com/swapnilsingh421\\narr = [5,2,3,4]\\n\\'\\'\\'\\n\\n\\t\\t  ( ) p1 \\t\\t \\t\\t\\t\\t\\t         (  ) p1\\n\\t\\t /   \\\\           \\t\\t\\t\\t\\t\\t    /    \\\\\\n\\t\\t5     ( ) p2\\t\\t\\t\\t\\t\\tp2    ( )     ( )  p3\\n\\t\\t\\t  /  \\\\ \\t\\t\\t\\t\\t\\t\\t     /   \\\\\\t  /  \\\\\\n\\t\\t p3 ( )   4 \\t\\t\\t\\t\\t\\t    5     2  3    4\\t\\n\\t\\t   /   \\\\\\n\\t\\t  2     3\\n\\n* Consider node 2 which has minimum value , it has 2 options.\\n\\n* Combine with 3 as in first diagram or combine with 5 as in second diagram. So it will go for that option which gives minimum product that is 2*3 < 2*5.\\n\\n* So it choose 1st diagram and p3 = 6 . Now we remove the node 2 from array as to compute value for node p2 only node 3 is required because 3>2 and we want max of left leaf node and max of right leaf node So only greater node proceeds.\\n* Array becomes [5,3,4] . Again we find minimum and repeat the process.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \\n        arr = [float(\\'inf\\')] + arr + [float(\\'inf\\')]\\n        n, res = len(arr), 0\\n        \\n        while n>3:\\n            mi = min(arr)\\n            ind = arr.index(mi)\\n            \\n            if arr[ind-1]<arr[ind+1]:\\n                res+=arr[ind-1]*arr[ind]\\n            else:\\n                res+=arr[ind+1]*arr[ind]\\n            \\n            arr.remove(mi)\\n            n = len(arr)\\n        \\n        return res\\n\\n**Thanks & Upvote If you like the Idea!!** \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "## IDEA :\\n**The key idea is to choose the minimum value leaf node and combine it with its neighbour which gives minimum product.**\\n\\nExample Taken from https://leetcode.com/swapnilsingh421\\narr = [5,2,3,4]\\n\\'\\'\\'\\n\\n\\t\\t  ( ) p1 \\t\\t \\t\\t\\t\\t\\t         (  ) p1\\n\\t\\t /   \\\\           \\t\\t\\t\\t\\t\\t    /    \\\\\\n\\t\\t5     ( ) p2\\t\\t\\t\\t\\t\\tp2    ( )     ( )  p3\\n\\t\\t\\t  /  \\\\ \\t\\t\\t\\t\\t\\t\\t     /   \\\\\\t  /  \\\\\\n\\t\\t p3 ( )   4 \\t\\t\\t\\t\\t\\t    5     2  3    4\\t\\n\\t\\t   /   \\\\\\n\\t\\t  2     3\\n\\n* Consider node 2 which has minimum value , it has 2 options.\\n\\n* Combine with 3 as in first diagram or combine with 5 as in second diagram. So it will go for that option which gives minimum product that is 2*3 < 2*5.\\n\\n* So it choose 1st diagram and p3 = 6 . Now we remove the node 2 from array as to compute value for node p2 only node 3 is required because 3>2 and we want max of left leaf node and max of right leaf node So only greater node proceeds.\\n* Array becomes [5,3,4] . Again we find minimum and repeat the process.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \\n        arr = [float(\\'inf\\')] + arr + [float(\\'inf\\')]\\n        n, res = len(arr), 0\\n        \\n        while n>3:\\n            mi = min(arr)\\n            ind = arr.index(mi)\\n            \\n            if arr[ind-1]<arr[ind+1]:\\n                res+=arr[ind-1]*arr[ind]\\n            else:\\n                res+=arr[ind+1]*arr[ind]\\n            \\n            arr.remove(mi)\\n            n = len(arr)\\n        \\n        return res\\n\\n**Thanks & Upvote If you like the Idea!!** \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 349098,
                "title": "from-o-n-2-to-o-n-greedy",
                "content": "First thought: \\nEach time we cacluate a value for a non-leaf node, we discard the smaller leave and keep the large leave, because the smaller leave will be \"shadowed\" by the large leave forever. To minimize the cost, we want to save the large leaves to the last, and use the small leaves first. \\n\\nImplementation of above idea : \\nPick a pair with smallest product in remaining leaves, add product to sum and remove small leave until there is only one leave.\\nn <= 40 is small so I just erase the leave.\\n\\nGreedy :\\n```\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        while(arr.size() > 1) {\\n            int to_delete = 0;\\n            int min_product = INT_MAX;\\n            for(int i = 0; i < arr.size()-1; ++i) {\\n                if(arr[i]*arr[i+1] < min_product) {\\n                    to_delete = i;\\n                    min_product = arr[i]*arr[i+1];\\n                }\\n            }\\n            sum += min_product;\\n            if(arr[to_delete] > arr[to_delete+1]) {\\n                to_delete += 1;\\n            }\\n            arr.erase(arr.begin()+to_delete);\\n        }\\n        return sum;\\n    }\\n```\\n\\nThis solution is O(N^2). not bad for N <= 40. \\nWhile searching for the smallest product pair, we do a lot of recompuation for product.  lee215 \\'s solution eliminates the recomputation by maintaining a monotonic decreasing array. \\nI am here to provide some insignt maybe how he reaches this idea. \\n1. Why decreasing ? \\nBecause we use small leave once and discard them, large leave stays. \\n2. When we met a small leave, like ` [..b, a, c..] `with` b > a` and `a < c`, can we remove `a` and get product `a*min(b,c)` ?  \\nIt seems not guaranteed to be the smallest product pair in the remaining leaves at first glance. But yes it\\'s safe to do so.  Let\\'s consider the general case, after some removal the array looks like:   ` [..a, c, d..] `. If d < a , then d will get removed and c stays. if `d > a`, then `a*c < c*d`, `pair(a,c)` will have higher priority in the original greedy solution and thus to be removed first. \\n\\nLet\\'s code it up :\\n```\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        vector<int> st = {INT_MAX};\\n        for(auto& x : arr) {\\n            while(st.back() <= x) {\\n                int small = st.back();\\n                st.pop_back();\\n                sum += small * min(st.back(), x);\\n            }\\n            st.push_back(x);\\n        }\\n        for(int i = st.size()-1; i >= 2; --i) {\\n            sum += st[i] * st[i-1];\\n        }\\n        return sum; \\n    }\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        while(arr.size() > 1) {\\n            int to_delete = 0;\\n            int min_product = INT_MAX;\\n            for(int i = 0; i < arr.size()-1; ++i) {\\n                if(arr[i]*arr[i+1] < min_product) {\\n                    to_delete = i;\\n                    min_product = arr[i]*arr[i+1];\\n                }\\n            }\\n            sum += min_product;\\n            if(arr[to_delete] > arr[to_delete+1]) {\\n                to_delete += 1;\\n            }\\n            arr.erase(arr.begin()+to_delete);\\n        }\\n        return sum;\\n    }\\n```\n```\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        vector<int> st = {INT_MAX};\\n        for(auto& x : arr) {\\n            while(st.back() <= x) {\\n                int small = st.back();\\n                st.pop_back();\\n                sum += small * min(st.back(), x);\\n            }\\n            st.push_back(x);\\n        }\\n        for(int i = st.size()-1; i >= 2; --i) {\\n            sum += st[i] * st[i-1];\\n        }\\n        return sum; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705054,
                "title": "c-code-with-detailed-explantion",
                "content": "Finally..after spending hours trying to understand this..i finally got it :).\\nQuestion comes under the specific type of merging intervals which is a pattern of dp.---\\nhttps://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns\\n\\nGeneral Pattern--\\n```\\nfor(int l = 1; l<n; l++) {\\n   for(int i = 0; i<n-l; i++) {\\n       int j = i+l;\\n       for(int k = i; k<j; k++) {\\n           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);\\n       }\\n   }\\n}\\nreturn dp[0][n-1];\\n```\\n\\nBasically dp value of a subarray depends on how we split it.As a particular value result[k] depends on it.\\n\\nNow in this problem, lets start with the initial array.\\n\\nNOTE---THE GIVEN ARRAY REPRESENT THE ENTIRE TREE, EACH SUBARRAY(i to j) REPRESENTS SUBTREE WITH LEAVES(i to j)\\n\\narr= [3,4,1,2,6,5]\\n\\nThe array itself is its subarray.Now choosing a value of k will split it into 2 subtrees..First will have leaves from 0 to k and other will have leaves from k+1 to n-1.\\n\\nNow we could think greedily and say branch it out into 2 subtrees such that (3,4,1) comes in 1 subtree and (2,6,5) comes under 2nd subtree,so that one subtree has 1 and other subtree has 2. This is so that the quantity we are trying to minimize-*(min(leaves in left subtree)* * *min(leaves in right subtree)* becomes minimum.\\n\\nBut that need not be true since we have to know the value for other non leaf nodes.(think dp, not greedy!)\\n\\ndp[left,right[ is the sum(minimum) of all non leaf nodes from left to right\\ndp[left,right]=dp[left,k]+dp[k+1,right]+(value of the node that splits the subtree \\'left to right\\' into subtrees \\'left to k\\' and \\'k+1 to right\\'=min(max(left,k) * max(k+1,right))\\ndp[left,k] will compute the sum of non leaf nodes of the subarray with leaves from [left,k].similary dp[right,k]\\n\\nSimple!Loop through every subarray and just keep choosing k to minimize dp[i][j].dp[0][n-1] denotes the entire tree.return that!\\n\\nNow we need to keep track of max of each subarray also.\\nNotation used in code--\\nwe will use vector<vector<pair<int,int>>> dp;\\ndp[i][j].first=sum(minimum) of all non leaf nodes from left to right\\ndp[i][j].second=max of subarray \\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{0,0}));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i].second=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                dp[i][j].second=max(dp[i][j-1].second,arr[j]);\\n            }\\n        }\\n        for(int l=2;l<=n;l++)\\n            for(int i=0;i<n-l+1;i++)\\n            {\\n                int j=i+l-1;\\n                dp[i][j].first=INT_MAX;\\n                for(int k=i;k<j;k++)\\n                {\\n                    if(dp[i][j].first>dp[i][k].first+dp[k+1][j].first+dp[i][k].second*dp[k+1][j].second)\\n                    {\\n                        dp[i][j].first=dp[i][k].first+dp[k+1][j].first+dp[i][k].second*dp[k+1][j].second;   \\n                    }\\n            }\\n            }\\n        \\n        return dp[0][n-1].first;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor(int l = 1; l<n; l++) {\\n   for(int i = 0; i<n-l; i++) {\\n       int j = i+l;\\n       for(int k = i; k<j; k++) {\\n           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);\\n       }\\n   }\\n}\\nreturn dp[0][n-1];\\n```\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{0,0}));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i].second=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                dp[i][j].second=max(dp[i][j-1].second,arr[j]);\\n            }\\n        }\\n        for(int l=2;l<=n;l++)\\n            for(int i=0;i<n-l+1;i++)\\n            {\\n                int j=i+l-1;\\n                dp[i][j].first=INT_MAX;\\n                for(int k=i;k<j;k++)\\n                {\\n                    if(dp[i][j].first>dp[i][k].first+dp[k+1][j].first+dp[i][k].second*dp[k+1][j].second)\\n                    {\\n                        dp[i][j].first=dp[i][k].first+dp[k+1][j].first+dp[i][k].second*dp[k+1][j].second;   \\n                    }\\n            }\\n            }\\n        \\n        return dp[0][n-1].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385034,
                "title": "recursive-solutioin-beat-98-c-java",
                "content": "```\\nprivate int m_iSum = 0;\\n\\npublic int MctFromLeafValues(int[] arr) {\\n    helper(arr, 0, arr.Length - 1);\\n    return m_iSum;\\n}\\n\\nprivate int helper(int[] arr, int piStart, int piEnd) {\\n    if ( piEnd < piStart )\\n        return 0;\\n    if ( piStart == piEnd ) {\\n        return arr[piStart];\\n    } else {\\n        int liMax = piStart;\\n        for ( int i = piStart + 1; i <= piEnd; ++i )\\n            if ( arr[i] > arr[liMax] )\\n                liMax = i;\\n\\n        int liLeft = helper(arr, piStart, liMax - 1);\\n        int liRight = helper(arr, liMax + 1, piEnd);\\n\\n        m_iSum += arr[liMax] * ( liLeft + liRight );\\n        return arr[liMax];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nprivate int m_iSum = 0;\\n\\npublic int MctFromLeafValues(int[] arr) {\\n    helper(arr, 0, arr.Length - 1);\\n    return m_iSum;\\n}\\n\\nprivate int helper(int[] arr, int piStart, int piEnd) {\\n    if ( piEnd < piStart )\\n        return 0;\\n    if ( piStart == piEnd ) {\\n        return arr[piStart];\\n    } else {\\n        int liMax = piStart;\\n        for ( int i = piStart + 1; i <= piEnd; ++i )\\n            if ( arr[i] > arr[liMax] )\\n                liMax = i;\\n\\n        int liLeft = helper(arr, piStart, liMax - 1);\\n        int liRight = helper(arr, liMax + 1, piEnd);\\n\\n        m_iSum += arr[liMax] * ( liLeft + liRight );\\n        return arr[liMax];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762413,
                "title": "simple-c-dp-using-memoization-64-ms",
                "content": "```\\nint find_max(int l,int h, vector <int>&ar){\\n        int maxi=0;\\n        for(int i=l;i<=h;i++){\\n            maxi=max(ar[i],maxi);\\n        }\\n        return maxi;\\n    }\\n    int fun(int l,int h, vector <int>&ar,vector <vector <int>> &dp){\\n        if(l==h)\\n            return dp[l][h]=0;\\n        if(h-l==1)\\n            return dp[l][h]=ar[l]*ar[h];\\n        int ans=INT_MAX,a,b,temp;\\n        if(dp[l][h]!=-1)\\n            return dp[l][h];\\n        for(int i=l;i<h;i++){\\n            a=find_max(l,i,ar);\\n            b=find_max(i+1,h,ar);\\n            temp=fun(l,i,ar,dp)+fun(i+1,h,ar,dp);\\n            ans=min(ans,(a*b)+temp);\\n        }\\n        return dp[l][h]=ans;\\n    }\\n    int mctFromLeafValues(vector<int>& ar) {\\n        int n=ar.size();\\n        vector <vector <int>> dp(n+1, vector <int>(n+1,-1));\\n        return fun(0,n-1,ar,dp);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint find_max(int l,int h, vector <int>&ar){\\n        int maxi=0;\\n        for(int i=l;i<=h;i++){\\n            maxi=max(ar[i],maxi);\\n        }\\n        return maxi;\\n    }\\n    int fun(int l,int h, vector <int>&ar,vector <vector <int>> &dp){\\n        if(l==h)\\n            return dp[l][h]=0;\\n        if(h-l==1)\\n            return dp[l][h]=ar[l]*ar[h];\\n        int ans=INT_MAX,a,b,temp;\\n        if(dp[l][h]!=-1)\\n            return dp[l][h];\\n        for(int i=l;i<h;i++){\\n            a=find_max(l,i,ar);\\n            b=find_max(i+1,h,ar);\\n            temp=fun(l,i,ar,dp)+fun(i+1,h,ar,dp);\\n            ans=min(ans,(a*b)+temp);\\n        }\\n        return dp[l][h]=ans;\\n    }\\n    int mctFromLeafValues(vector<int>& ar) {\\n        int n=ar.size();\\n        vector <vector <int>> dp(n+1, vector <int>(n+1,-1));\\n        return fun(0,n-1,ar,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256514,
                "title": "simple-dp-solution-based-on-matrix-chain-multiplication",
                "content": "```\\nclass Solution {\\npublic:\\n    int soln(vector<int> a,int s,int e,vector<vector<int>> &dp)\\n    {\\n        if(s==e)\\n            return dp[s][e]=0;\\n        if(dp[s][e]!=-1)\\n            return dp[s][e];\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=s;i<e;i++)\\n        {\\n            int one=soln(a,s,i,dp);\\n            int two=soln(a,i+1,e,dp);\\n            int tmp=one+two+(*max_element(a.begin()+s,a.begin()+i+1))*(*max_element(a.begin()+i+1,a.begin()+e+1));\\n            \\n            ans=min(ans,tmp);\\n        }\\n        \\n        return dp[s][e]=ans;\\n    }\\n        \\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        vector<vector<int>> dp(50,vector<int>(50,-1));\\n        return soln(arr,0,arr.size()-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int soln(vector<int> a,int s,int e,vector<vector<int>> &dp)\\n    {\\n        if(s==e)\\n            return dp[s][e]=0;\\n        if(dp[s][e]!=-1)\\n            return dp[s][e];\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=s;i<e;i++)\\n        {\\n            int one=soln(a,s,i,dp);\\n            int two=soln(a,i+1,e,dp);\\n            int tmp=one+two+(*max_element(a.begin()+s,a.begin()+i+1))*(*max_element(a.begin()+i+1,a.begin()+e+1));\\n            \\n            ans=min(ans,tmp);\\n        }\\n        \\n        return dp[s][e]=ans;\\n    }\\n        \\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        vector<vector<int>> dp(50,vector<int>(50,-1));\\n        return soln(arr,0,arr.size()-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646785,
                "title": "greedy-approach-optimal-merge-pattern-python",
                "content": "**Procedure**\\n\\t\\t1. \\tFind out minimum value from the list and compare it with its neighbour to get minimum product (**a non-leaf node**).\\n\\t\\t2. \\tRemove both value and insert new value in the list while maintaining the order.\\n\\t\\t3. \\tRepeat step 1 and step 2 till we left with single value in the list and that will be root node of newly constructed Tree.\\n\\t\\t4. \\tReturn list that will contain a single value(**Your Answer**).\\n```\\n def mctFromLeafValues(self, arr):\\n        ans = 0\\n        while len(arr) > 1:\\n            minIndex = arr.index(min(arr))\\n            if 0 < minIndex < len(arr) - 1:\\n                ans += min(arr[minIndex - 1], arr[minIndex + 1]) * arr[minIndex]\\n            else:  #handle corner cases : when minimun value is either first value or last value of the list\\n                ans += arr[1 if minIndex == 0 else minIndex - 1] * arr[minIndex]\\n            arr.pop(minIndex)\\n        return ans # OR return arr[0]\\n```\\n\\n**Application:**   Merge n files into a single large file such that it get merge in minimum number of overhead movement.",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n def mctFromLeafValues(self, arr):\\n        ans = 0\\n        while len(arr) > 1:\\n            minIndex = arr.index(min(arr))\\n            if 0 < minIndex < len(arr) - 1:\\n                ans += min(arr[minIndex - 1], arr[minIndex + 1]) * arr[minIndex]\\n            else:  #handle corner cases : when minimun value is either first value or last value of the list\\n                ans += arr[1 if minIndex == 0 else minIndex - 1] * arr[minIndex]\\n            arr.pop(minIndex)\\n        return ans # OR return arr[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 929961,
                "title": "java-solution-using-stack-time-o-n-space-o-n",
                "content": "```\\nThis solution is easy to understand.\\nTake array [6,2,4,5] as an example.\\nActually what we do is:\\nFor[6,2,4,5], 2 is the smallest, 2 * Math.min(6, 4) = 2 * 4 = 8;\\nFor[6, 4, 5], 4 is the samllest, 4 * Math.min(6, 5) = 4 * 5 = 20;\\nFor[6,5], 6*5 = 30.\\nSo result = 8 + 20 + 30 = 58.\\nThe key is that if one element e is smaller than its two neighbors, result adds e * Math.min(two neighbors).\\n\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        int res = 0;\\n        for(int i = 0; i < arr.length; i++) {\\n            while(stack.peek() <= arr[i]) {\\n                res += stack.pop() * Math.min(arr[i], stack.peek());\\n            }\\n            stack.push(arr[i]);\\n        }\\n        while(stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nThis solution is easy to understand.\\nTake array [6,2,4,5] as an example.\\nActually what we do is:\\nFor[6,2,4,5], 2 is the smallest, 2 * Math.min(6, 4) = 2 * 4 = 8;\\nFor[6, 4, 5], 4 is the samllest, 4 * Math.min(6, 5) = 4 * 5 = 20;\\nFor[6,5], 6*5 = 30.\\nSo result = 8 + 20 + 30 = 58.\\nThe key is that if one element e is smaller than its two neighbors, result adds e * Math.min(two neighbors).\\n\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        int res = 0;\\n        for(int i = 0; i < arr.length; i++) {\\n            while(stack.peek() <= arr[i]) {\\n                res += stack.pop() * Math.min(arr[i], stack.peek());\\n            }\\n            stack.push(arr[i]);\\n        }\\n        while(stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479412,
                "title": "c-dp-variation-of-classical-dp-problem-mcm",
                "content": "Slight Concept of trees and Matrix Chain Multiplication\\n\\n```\\nclass Solution {\\n    \\n    int max(vector<int> &arr, int s ,int e)\\n    {\\n        int mx = 0;\\n        \\n        for(int i=s ;i<=e ;i++)\\n        {\\n            mx = std::max(arr[i] , mx);\\n        }\\n        \\n        return mx;\\n    }\\n    \\n    int dp[50][50];\\n    \\n    int solve(vector<int> &arr, int s, int e)\\n    {\\n        if(s==e)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[s][e]!=-1) return dp[s][e];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=s;i < e; i++)\\n        {\\n            int lsum = max(arr, s , i);\\n            int rsum = max(arr , i+1 , e);\\n                \\n            ans = min( ans, solve(arr, s, i) + solve(arr , i+1 , e) + lsum*rsum);\\n        }\\n        \\n        return dp[s][e] = ans;\\n    }\\n    \\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        memset(dp, -1 , sizeof(dp));\\n        return solve(arr, 0 , arr.size()-1);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int max(vector<int> &arr, int s ,int e)\\n    {\\n        int mx = 0;\\n        \\n        for(int i=s ;i<=e ;i++)\\n        {\\n            mx = std::max(arr[i] , mx);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 803891,
                "title": "c-stack-beats-100",
                "content": "General idea: \\nFor each element in the array, if may belong to either its left side or right side, once an element is multiplied by a number greater than it, it will no longer be used.\\n\\nSolution:\\nMaintain a decreasing stack. \\nFor `int a : arr` :\\nIf `a <= st.top()`, just push it to the stack.\\nIf `a > st.top()`, make a comparison between the new element `a` and the second top element in stack, multiply the smaller one by `st.top()` and add it to the `sum`. The top element is popped out of the stack, which means it  will no longer be used in later calculation. Repeatedly pop and make comparison until we can push `a` into the decreasing stack.\\nAfter iteration through the array, iterate through the remaining stack and add the product of adjacent elements to the sum until the stack becomes empty.\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        stack<int> st;\\n        int sum = 0;\\n        int t;\\n        for (int a : arr) {\\n            while (!st.empty() && a > st.top()) {\\n                t = st.top();\\n                st.pop();\\n                if (st.empty()) sum += t*a;\\n                else sum += t*min(st.top(), a);\\n            }\\n            st.push(a);\\n        }\\n        while (!st.empty()) {\\n            t = st.top();\\n            st.pop();\\n            if (!st.empty()) sum += st.top()*t;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        stack<int> st;\\n        int sum = 0;\\n        int t;\\n        for (int a : arr) {\\n            while (!st.empty() && a > st.top()) {\\n                t = st.top();\\n                st.pop();\\n                if (st.empty()) sum += t*a;\\n                else sum += t*min(st.top(), a);\\n            }\\n            st.push(a);\\n        }\\n        while (!st.empty()) {\\n            t = st.top();\\n            st.pop();\\n            if (!st.empty()) sum += st.top()*t;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410634,
                "title": "javascript-recursion-memo-stack-3-solutions-explained",
                "content": "This post has** 3 solutions**, whose complexity improves gradually.\\n\\nSolution1 and solution 2: (Recursive Partition)\\nEach partion is a simulation of the problem. Each partition is a unique ways to build a tree. Each tree has a cost. The minimum cost is calculated by comparing all the partition possibilites. \\n\\n**Solution 1** TLEs due to dupication in calculation. \\n**Solution 2** passes by using a memo array to record the cost of subtrees and reuse them.\\n**Solution 3** is a O(n) stack solution. \\n\\nSolution 3: How did I think of it? I did not. I had to refer to [Lee\\'s answer](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space). He already explained it very well. \\n\\nLet me explain it again:\\n- Let\\'s visualize this from **bottom up**.\\n- Two neighboring nodes (a, b) can from a mini tree.\\n- The cost of this minitree is the product of the neighbors (a * b). \\n- (Actually, every non-leaf node\\'s cost is the product of 2 elements)\\n- After a mini tree is formed, bigger trees will form. \\n- The bigger tree\\'s cost is the product of it\\'s max left and max right leaf value.\\n- What happens to the smaller nodes? They become invisible. \\n\\nThis problem is an **erase small numbers with minimum cost** problem.\\n\\nA node (a) can form a tree with it\\'s left neighbor (l) or right neighbor(r). \\ncost = a * l OR a * r\\nHow to get the min cost?\\nminCost = a * Math.min(l, r) \\n \\nNow it becomes a stack problem, which can be solved by a descending stack. This is smilar to [42. trapping rain water](https://leetcode.com/problems/trapping-rain-water) problem now. , and also similar to the [503. find next great element II ](https://leetcode.com/problems/next-greater-element-ii/)problem, like Lee said. The code is at the bottom.\\n \\nSolution 1: recursion TLE - O(N^3)\\n\\n```\\nvar mctFromLeafValues = function(arr) {\\n     \\n    return calcMctFromLeafValues(arr, 0, arr.length-1);\\n    \\n    function calcMctFromLeafValues(arr, l, r){\\n        // leaf node, don\\'t add to sum        \\n        if (l===r) {\\n            return 0;\\n        }\\n        // init minSum to be Infinity so that it can be easily overwritten later\\n        let minSum = Infinity;\\n\\n        // p stands for partition, cuts after p, so p needs to be smaller than r\\n        // e.g. in the array [0, 1] and l = 0, r = 1\\n        // p can only be 0, that means cuts in between\\n        for (let p = l; p < r; p++) {\\n            \\n            const leftMaxLeaf = Math.max(...arr.slice(l, p + 1));\\n            const rightMaxLeaf = Math.max(...arr.slice(p + 1, r + 1));\\n\\n            let leftSubtreeSum = calcMctFromLeafValues(arr, l, p);\\n            let rightSubtreeSum = calcMctFromLeafValues(arr, p+1, r);\\n            \\n            //tally the final result\\n            minSum = Math.min(minSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        return minSum;\\n    }\\n}\\n\\n```\\n\\nSolution 2: solution 1 + memo (better)\\n\\n```\\nvar mctFromLeafValues = function(arr) {\\n    const memo = [... new Array(arr.length)].map(() => new Array(arr.length).fill(0))\\n    \\n    return calcMctFromLeafValues(arr, 0, arr.length-1);\\n    \\n    function calcMctFromLeafValues(arr, l, r){\\n        if (memo[l][r] !== 0) {\\n            return memo[l][r];\\n        }\\n        // leaf node, don\\'t add to sum        \\n        if (l===r) {\\n            return 0;\\n        }\\n        \\n        // init minSum to be Infinity so that it can be easily overwritten later\\n        let minSum = Infinity;\\n\\n        // p stands for partition, cuts after p, so p needs to be smaller than r\\n        // e.g. in the array [0, 1] and l = 0, r = 1\\n        // p can only be 0, that means cuts in between\\n        for (let p = l; p < r; p++) {\\n            \\n            const leftMaxLeaf = Math.max(...arr.slice(l, p + 1));\\n            const rightMaxLeaf = Math.max(...arr.slice(p + 1, r + 1));\\n\\n            let leftSubtreeSum = calcMctFromLeafValues(arr, l, p);\\n            let rightSubtreeSum = calcMctFromLeafValues(arr, p+1, r);\\n            \\n            //tally the final result\\n            minSum = Math.min(minSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        memo[l][r] = minSum;\\n        return minSum;\\n    }\\n}\\n```\\n\\nsolution 3: monotonic stack O(N)\\n\\n```\\nvar mctFromLeafValues = function(arr) {\\n    const desStack = [];\\n    let res = 0;\\n    for (let curNode of arr){\\n        while (desStack.length && curNode >= desStack[desStack.length - 1]) {\\n            const smallNode = desStack.pop();\\n            const slighterLargerNode = !desStack.length ? curNode : Math.min(desStack[desStack.length - 1], curNode);\\n            res += smallNode * slighterLargerNode\\n        }\\n        desStack.push(curNode);\\n    }\\n    while(desStack.length >= 2) {   // check size\\n        res += desStack.pop() * desStack[desStack.length - 1];\\n    }\\n    return res;\\n};\\n```\\n \\n",
                "solutionTags": [],
                "code": "```\\nvar mctFromLeafValues = function(arr) {\\n     \\n    return calcMctFromLeafValues(arr, 0, arr.length-1);\\n    \\n    function calcMctFromLeafValues(arr, l, r){\\n        // leaf node, don\\'t add to sum        \\n        if (l===r) {\\n            return 0;\\n        }\\n        // init minSum to be Infinity so that it can be easily overwritten later\\n        let minSum = Infinity;\\n\\n        // p stands for partition, cuts after p, so p needs to be smaller than r\\n        // e.g. in the array [0, 1] and l = 0, r = 1\\n        // p can only be 0, that means cuts in between\\n        for (let p = l; p < r; p++) {\\n            \\n            const leftMaxLeaf = Math.max(...arr.slice(l, p + 1));\\n            const rightMaxLeaf = Math.max(...arr.slice(p + 1, r + 1));\\n\\n            let leftSubtreeSum = calcMctFromLeafValues(arr, l, p);\\n            let rightSubtreeSum = calcMctFromLeafValues(arr, p+1, r);\\n            \\n            //tally the final result\\n            minSum = Math.min(minSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        return minSum;\\n    }\\n}\\n\\n```\n```\\nvar mctFromLeafValues = function(arr) {\\n    const memo = [... new Array(arr.length)].map(() => new Array(arr.length).fill(0))\\n    \\n    return calcMctFromLeafValues(arr, 0, arr.length-1);\\n    \\n    function calcMctFromLeafValues(arr, l, r){\\n        if (memo[l][r] !== 0) {\\n            return memo[l][r];\\n        }\\n        // leaf node, don\\'t add to sum        \\n        if (l===r) {\\n            return 0;\\n        }\\n        \\n        // init minSum to be Infinity so that it can be easily overwritten later\\n        let minSum = Infinity;\\n\\n        // p stands for partition, cuts after p, so p needs to be smaller than r\\n        // e.g. in the array [0, 1] and l = 0, r = 1\\n        // p can only be 0, that means cuts in between\\n        for (let p = l; p < r; p++) {\\n            \\n            const leftMaxLeaf = Math.max(...arr.slice(l, p + 1));\\n            const rightMaxLeaf = Math.max(...arr.slice(p + 1, r + 1));\\n\\n            let leftSubtreeSum = calcMctFromLeafValues(arr, l, p);\\n            let rightSubtreeSum = calcMctFromLeafValues(arr, p+1, r);\\n            \\n            //tally the final result\\n            minSum = Math.min(minSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        memo[l][r] = minSum;\\n        return minSum;\\n    }\\n}\\n```\n```\\nvar mctFromLeafValues = function(arr) {\\n    const desStack = [];\\n    let res = 0;\\n    for (let curNode of arr){\\n        while (desStack.length && curNode >= desStack[desStack.length - 1]) {\\n            const smallNode = desStack.pop();\\n            const slighterLargerNode = !desStack.length ? curNode : Math.min(desStack[desStack.length - 1], curNode);\\n            res += smallNode * slighterLargerNode\\n        }\\n        desStack.push(curNode);\\n    }\\n    while(desStack.length >= 2) {   // check size\\n        res += desStack.pop() * desStack[desStack.length - 1];\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 746404,
                "title": "explanation-of-the-two-o-n-2-greedy-algorithms",
                "content": "**Algorithm1**:  ([https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space])\\nWe remove the element form the smallest to bigger.\\nWe check the min(left, right),\\nFor each element a, cost = min(left, right) * a\\n\\n**explaination**\\nThis algorithm is looking for \"V\" shape in the array and remove value at the bottom of the \"V\".\\n\\nTo better understand it, let\\'s first find out the minium (denoted by M) in the array and split the array into three parts:  ```left_array, [M], right_array```. Let\\'s compare the optimal tree on ```left_array+[M] +right_array ``` with the tree on ```left_array + right_array```.  \\n\\nLet\\'s assume the optimal algorithm on ```left_array+[M] +right_array``` pops out min at step k+1.\\nAfter K step,  we have ```left_array(k) +[M] +right_array(k)``` in the optimal algorithm and we can exactly mimic this process on ```left_array + right_array``` and after k step we have ```left_array(k)+ right_array(k)```. At step K+1, we pop [M], and the array becomes ```left_array(k) +[M] +right_array(k) -> left_array(k) + right_array(k)``` and the cost of this step is ```M * min(left_array(k)[-1], right_array(k)[0])```. \\n\\nNote that the ```min(left_array(k)[-1], right_array(k)[0])``` is **greater or equal** to ```min(left_array[-1], right_array[0])```. Now let\\'s consider the following K+1 step on ```left_array, [M], right_array```:\\nstep 1: remove [M] with cost ```M*min(left_array[-1], right_array[0])``` \\nfor step 2:k+1: we follow the K steps obtained above for ```left_array+ right_array -> left_array(k) + right_array(k)```. We know this process costs smaller or equal to the optimal process. Therefore we could always remove the samllest element with the cost``` M*min(left_array[-1], right_array[0])``` at step 1 and do it iteratively.\\n\\n\\n**Algorithm2**: \\n1 find the pair of adjacent elements with the smallest product  P in the array and add p to the total cost\\n2 remove the smaller one from the array\\n3 repeat step 1 and 2 recusively \\n\\n**Proof**\\nThe proof is based on mathematical induction. I\\'ll show that the greedy algorithm works for arr with length n based on the assumption that the algorihtm works for any arr with length less than n.\\n\\n**First**, we need to check if greedy algirthm holds for the simple cases. iIt\\'s trivial when the len(arr) = 1 or 2. When the len(arr) = 3, there are three cases  [2,1,3] : middle element is the smallest, [1,2,3]: middle element is the second smallest, [1,3,2]: the middle element is the largest. When the middle element is the smallest or the largest, the order of merging leaves doesn\\'t matter. While the second smallest element is in the middle, greedy merging strategy does yield smallest cost.\\n\\n**second**, for a array with length L, let\\'s check and compare the left subtree and right subtree of the root node from the optimal tree structure and the tree structure derived by the greedy algorithm. We know that the leaves from the optimal left subtree are corrsponding to arr[:b_opt] and leaves from the right subtree are from arr[b_opt: ] while the their counterparts from the greedy algorithm are arr[:b_greedy] and arr[b_greedy:].  For the optimal tree, left subtree and right subtree must be optimal as well for arr[:b_opt] and arr[b_opt: ] (since the root value is detemined by b_opt). Since we assume that greedy algorithm works for array with length <= n-1 then we know greedy algorithm works for arr[:b_opt] and arr[:b_opt]. \\n\\nThen let\\'s compare the optimal algorithm with the greedy algorithm. The optimal algorithm will use greedy algorithm within arr[:b_opt] and arr[b_opt: ], which means initially, it will find the smallest product for adjacent pairs except for arr[b_opt-1] and arr[b_opt]. If the smallest product is not from pair (arr[b_opt-1] and arr[b_opt]), then optimal algorithm and greedy algorithm will be the same for this specific step. They will have the same value for the non leaf node and remove the same element in the array. Therefore, without lose of generality, we could safely assume that if greedy algorithm is not the optimal one, then these two algorithms would differ at the first step.\\n\\nLet\\'s denote the first pair from the optimal algorithm as arr[opt-1] and arr[opt]. There are two cases: \\n\\n**case 1**: neither opt-1 nor opt is in posiiton [b_opt-1, b_opt], which means the pair from the optimal algorithm is not overlapped with the pair from the greedy algorithm. After running the algorithm for 1 step\\n\\n**optimal**: [ ...,leaf(opt-1), leaf(opt),..., leaf(b_opt-1), leaf(b_opt),...] -> [...,max(leaf(opt-1), leaf(opt)),..., leaf(b_opt-1), leaf(b_opt)...]\\n\\n**greedy**: [ ...,leaf(opt-1), leaf(opt),..., leaf(b_opt-1), leaf(b_opt),...] -> [..., leaf(opt-1), leaf(opt),..., max(leaf(b_opt-1), leaf(b_opt))...]\\n\\nNote, right now the length of the array is n-1, so we now that greedy algorithm is optimal for the n-1 array. Therefore, the optimal array sequence would be like the following:\\n\\n**optimal**:  [ ...,leaf(opt-1), leaf(opt),..., leaf(b_opt-1), leaf(b_opt),...] -> [...,max(leaf(opt-1), leaf(opt)),..., leaf(b_opt-1), leaf(b_opt)...] ->   [...,max(leaf(opt-1), leaf(opt)),...,  max(leaf(b_opt-1), leaf(b_opt)) ...] \\n\\nNow let\\'s look at the greedy one. It will be the same since leaf(opt-1) * leaf(opt)  < leaf(b_opt)*leaf(b_opt+1) <  max(leaf(b_opt-1), leaf(b_opt))*leaf(b_opt+1)   and leaf(opt-1) * leaf(opt)  < leaf(b_opt-1)*leaf(b_opt) <  max(leaf(b_opt-1), leaf(b_opt))*leaf(b_opt-1), we know that greedy algorithm will merge  leaf(opt-1) and leaf(opt).\\n**greedy**:[ ...,leaf(opt-1), leaf(opt),..., leaf(b_opt-1), leaf(b_opt),...] -> [...,max(leaf(opt-1), leaf(opt)),..., leaf(b_opt-1), leaf(b_opt)...] ->   [...,max(leaf(opt-1), leaf(opt)),...,  max(leaf(b_opt-1), leaf(b_opt)) ...] \\n\\nSo we know for case 1, greedy algorithm is the optimal.\\n\\n**case 2**: opt-1 or opt is overlapped with b_opt-1 or b_opt. Without loss of generality, let\\'s assume  opt = b_op-1\\n\\n**optimal**: [ ...,leaf(opt-1), leaf(opt = b_opt-1), leaf(b_opt),...] -> [ ..., max (leaf(opt-1), leaf(opt)), leaf(b_opt),...]\\n\\n**greedy**: [ ...,leaf(opt-1), leaf(opt = b_opt-1), leaf(b_opt),...] -> [ ..., leaf(opt-1), max(leaf(b_opt-1), leaf(b_opt) ),...]\\n\\nthere are another two situations:\\n\\n**case 2.1** leaf(opt = b_opt-1) < leaf(b_opt). Note that in this case leaf(opt-1) < leaf(opt) since leaf(opt) > leaf(b_opt) otherwise leaf(b_opt)*leaf(opt) won\\'t be the samllest pair.  [  max (leaf(opt-1), leaf(opt)), leaf(b_opt)] = [ leaf(opt-1),leaf(b_opt)] and [ leaf(opt-1), max(leaf(b_opt-1),leaf(b_opt) ))] = [ leaf(opt-1),leaf(b_opt)] . In this case, two algorithms remove the same value but greedy algorithm yield smaller costs, which is contradict with the fact that optimal algorithm has the smallest costs. Therefore we know greedy algorithm is the optimal one for this case.\\n\\n**case 2.2** leaf(opt = b_opt-1) > leaf(b_opt). In this case, apply greedy algorithm on the right hand array with length = n-1 will yield the following sequence:\\n\\n**optimal** [ ...,leaf(opt-1), leaf(opt = b_opt-1), leaf(b_opt),...] -> [ ..., max (leaf(opt-1), leaf(opt)), leaf(b_opt),...] -> [ ..., max (leaf(opt-1), leaf(opt)),...]\\n\\nThe key observation is that max (leaf(opt-1), leaf(opt)) * leaf(b_opt) will be the smallest pair since leaf(opt-1) * leaf(opt) is the second smallest pair and max (leaf(opt-1), leaf(opt)) * leaf(b_opt) < leaf(opt-1) * leaf(opt).\\n\\nSimilarly, greedy algorithm will yeild the exactly the same array for the second step while has smaller cost among these three consecutive elements.\\n**greedy**: [ ...,leaf(opt-1), leaf(opt = b_opt-1), leaf(b_opt),...] -> [ ..., leaf(opt-1), leaf(opt),...] -> [ ..., max (leaf(opt-1), leaf(opt)),...]\\n\\nThis imples greedy algorithm has smaller cost. Combine case 1 and case 2, we know greedy algorithm is the optimal algorithm.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```left_array, [M], right_array```\n```left_array+[M] +right_array ```\n```left_array + right_array```\n```left_array+[M] +right_array```\n```left_array(k) +[M] +right_array(k)```\n```left_array + right_array```\n```left_array(k)+ right_array(k)```\n```left_array(k) +[M] +right_array(k) -> left_array(k) + right_array(k)```\n```M * min(left_array(k)[-1], right_array(k)[0])```\n```min(left_array(k)[-1], right_array(k)[0])```\n```min(left_array[-1], right_array[0])```\n```left_array, [M], right_array```\n```M*min(left_array[-1], right_array[0])```\n```left_array+ right_array -> left_array(k) + right_array(k)```\n``` M*min(left_array[-1], right_array[0])```",
                "codeTag": "Unknown"
            },
            {
                "id": 514108,
                "title": "c-greedy-algorithm-with-comments-explanation-worst-time-o-n-2",
                "content": "The problem asks us to find the **smallest possible sum** of the values of each non-leaf node. We know that each **non-leaf node is a product of two leaf nodes** and we only get to use the biggest value in the left/right subtree. This means we want to start with the smallest number possible and we only get to use it once (since it will be replaced after one iteration)\\n\\nAn easier problem would be if order does not matter:\\n**Ex:** if we have [4,2,3,1]\\nIn this example, we can sort the array to get [1,2,3,4]\\nThen we just need to take the sum of (1 * 2) + (2 * 3) + (3 * 4)  = 20\\n(note: we only used 1 once then since 2 is bigger, we chose 2 as our next smallest number)\\n\\nUltimately, we want to find a way to find the smallest product from the array at each iteration\\nThen, delete the smaller value from the pair after each iteration\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size() > 1){\\n\\t\\t\\t// for each iteration, we want the minimal product\\n            int minPrd = INT_MAX; \\n            int minIdx  = -1;\\n            for(int i = 0; i < arr.size() - 1; i++){\\n                int temp = arr[i] * arr[i + 1];\\n                if(temp < minPrd){\\n                    minPrd = temp;\\n                    minIdx = i;\\n                }\\n            }\\n            res += minPrd;\\n            // leave the bigger number of the two and erase the smaller one\\n\\t\\t\\tarr[minIdx] = max(arr[minIdx], arr[minIdx + 1]);\\n            arr.erase(arr.begin() + (minIdx + 1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size() > 1){\\n\\t\\t\\t// for each iteration, we want the minimal product\\n            int minPrd = INT_MAX; \\n            int minIdx  = -1;\\n            for(int i = 0; i < arr.size() - 1; i++){\\n                int temp = arr[i] * arr[i + 1];\\n                if(temp < minPrd){\\n                    minPrd = temp;\\n                    minIdx = i;\\n                }\\n            }\\n            res += minPrd;\\n            // leave the bigger number of the two and erase the smaller one\\n\\t\\t\\tarr[minIdx] = max(arr[minIdx], arr[minIdx + 1]);\\n            arr.erase(arr.begin() + (minIdx + 1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457914,
                "title": "javascript-solution-dp-greedy",
                "content": "### The idea - DP/DFS/Recursion\\n1. Use divide and conquer methodolgy, the cost of building 1 node can be calculated by the cost of building nodes in the left part + the cost of building nodes in the right part + the cost of the root node (product of the maximun number to its left and right).\\n2. We can try every slice point to split the array in to left and right until there\\'s only 1 element left\\n``` javascript\\nvar mctFromLeafValuesDFS = function(arr) {\\n    let dp = [];\\n    let dfs = function(i, j) {\\n        if (!dp[i]) dp[i] = []; // initialize\\n        if (j<=i) return 0; // only 1 element\\n        if (dp[i][j]) return dp[i][j];\\n        let res = Number.MAX_VALUE;\\n        for (let k=i+1;k<=j;k++) { // try different slicing point\\n            res = Math.min(dfs(i, k-1) + dfs(k, j) + Math.max(...arr.slice(i,k)) * Math.max(...arr.slice(k, j+1)), res);\\n        }\\n        dp[i][j] = res;\\n        return dp[i][j];\\n    }\\n    return dfs(0, arr.length-1);\\n};\\n```\\n### The idea - Merge Intervals DP\\n Can be translated into:\\n Give some piles of nodes, merge them into 1 pile.\\n You can only merge adjacent piles, the cost is the product of the largest nodes in the two piles.\\n```\\nvar mctFromLeafValues = function(arr) {\\n    const N = arr.length;\\n    let dp = new Array(N).fill(0).map(()=>new Array(N).fill(0));\\n    \\n    for (let l=2;l<=N;l++) { // merge l piles to 1 pile\\n        for (let i = 0; i <= N - l;i++) { // start position \\n            let j = i + l - 1; // end position\\n            dp[i][j] = Number.MAX_VALUE; // initialize\\n            for (let k=i;k<j;k++) { // split point\\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j] + Math.max(...arr.slice(i,k+1)) * Math.max(...arr.slice(k+1, j+1)));\\n            }\\n        }\\n    }\\n    return dp[0][arr.length-1];\\n}\\n```\\n### The idea - Greedy\\n1. In order the minimize the final cost, we want to minimize the repetitive calculations for large numbers.\\n2. The idea is to always combine the smallest product pair for the current array, and remove the smaller number from the array since it will never be used again.\\n``` javascript\\nvar mctFromLeafValuesGreedy = function(arr) {\\n    let cost = 0;\\n    while (arr.length>1) {\\n        let minProduct = Number.MAX_VALUE;\\n        let minId = -1;\\n        for (let i=0;i<arr.length-1;i++) {\\n            let curProduct = arr[i] * arr[i+1];\\n            if (curProduct < minProduct) {\\n                minProduct = curProduct;\\n                minId = arr[i]<arr[i+1]?i:i+1;\\n            }\\n        }\\n        cost+=minProduct;\\n        arr.splice(minId, 1);\\n    }\\n    return cost;\\n} \\n```\\n### Version 2\\n``` javascript\\nvar mctFromLeafValues = function(arr) {\\n    let cost = 0;\\n    while (arr.length > 1) {\\n        let minNum = Math.min(...arr);\\n        let minId = arr.indexOf(minNum);\\n        if (minId==0) cost+= arr[minId+1] * arr[minId];\\n        else if (minId==arr.length-1) cost+=arr[minId-1] * arr[minId];\\n        else cost+=arr[minId] * Math.min(arr[minId-1], arr[minId+1]); \\n        arr.splice(minId, 1);\\n    }\\n    return cost;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar mctFromLeafValuesDFS = function(arr) {\\n    let dp = [];\\n    let dfs = function(i, j) {\\n        if (!dp[i]) dp[i] = []; // initialize\\n        if (j<=i) return 0; // only 1 element\\n        if (dp[i][j]) return dp[i][j];\\n        let res = Number.MAX_VALUE;\\n        for (let k=i+1;k<=j;k++) { // try different slicing point\\n            res = Math.min(dfs(i, k-1) + dfs(k, j) + Math.max(...arr.slice(i,k)) * Math.max(...arr.slice(k, j+1)), res);\\n        }\\n        dp[i][j] = res;\\n        return dp[i][j];\\n    }\\n    return dfs(0, arr.length-1);\\n};\\n```\n```\\nvar mctFromLeafValues = function(arr) {\\n    const N = arr.length;\\n    let dp = new Array(N).fill(0).map(()=>new Array(N).fill(0));\\n    \\n    for (let l=2;l<=N;l++) { // merge l piles to 1 pile\\n        for (let i = 0; i <= N - l;i++) { // start position \\n            let j = i + l - 1; // end position\\n            dp[i][j] = Number.MAX_VALUE; // initialize\\n            for (let k=i;k<j;k++) { // split point\\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j] + Math.max(...arr.slice(i,k+1)) * Math.max(...arr.slice(k+1, j+1)));\\n            }\\n        }\\n    }\\n    return dp[0][arr.length-1];\\n}\\n```\n``` javascript\\nvar mctFromLeafValuesGreedy = function(arr) {\\n    let cost = 0;\\n    while (arr.length>1) {\\n        let minProduct = Number.MAX_VALUE;\\n        let minId = -1;\\n        for (let i=0;i<arr.length-1;i++) {\\n            let curProduct = arr[i] * arr[i+1];\\n            if (curProduct < minProduct) {\\n                minProduct = curProduct;\\n                minId = arr[i]<arr[i+1]?i:i+1;\\n            }\\n        }\\n        cost+=minProduct;\\n        arr.splice(minId, 1);\\n    }\\n    return cost;\\n} \\n```\n``` javascript\\nvar mctFromLeafValues = function(arr) {\\n    let cost = 0;\\n    while (arr.length > 1) {\\n        let minNum = Math.min(...arr);\\n        let minId = arr.indexOf(minNum);\\n        if (minId==0) cost+= arr[minId+1] * arr[minId];\\n        else if (minId==arr.length-1) cost+=arr[minId-1] * arr[minId];\\n        else cost+=arr[minId] * Math.min(arr[minId-1], arr[minId+1]); \\n        arr.splice(minId, 1);\\n    }\\n    return cost;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041415,
                "title": "c-short-o-n-time-o-1-space-stack-solution-take-it-or-leave-it",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& a) {\\n        int i = 0, ret = 0;\\n        for (auto &x : a) {\\n            while (i && a[i - 1] < x) \\n                ret += a[--i] * ((i && a[i - 1] < x) ? a[i - 1] : x);\\n            a[i++] = x;\\n        }\\n        while (i > 1)  \\n            ret += a[--i] * a[i - 1];\\n        return ret;\\n    }\\n};\\n```\\n\\n**Edit**\\nI don\\'t know how much you know about this problem, but the solution is the same as any other here, just the code may look ... shorter. It is a greedy approach: find minimum pair and combine them.\\n\\nSome great explanations you can always find in the top upvoted discussion, they do a great job :), that\\'s why they are upvoted lul. Here, I will only provide some ideas that are used for this code.\\n\\n* * Greedy approach, implicit stack implementation.\\n* Implicit stack is the reused input vector. You might find similar ideas elsewhere, the whole point is to use input vector to store stack elements. For that here I just introduce pointer ```i``` to keep track how many elements I have in the stack. ```a[i-1]``` is my last element in the stack and obviously if ```i==0``` means I have no elements.\\n* The whole point of the greedy approach is to combine two close elements. In fact you can freely combine any local minima with next lowest element. E.g. :: [5,4,3,6,2,5]. In this example, 3 and 2 are local minima. Why? Cause elements next to them are larger; 3 has 4 on the left and 6 on the right; 2 has 6 on the left and 5 on the right. The whole idea is that you can combine either of them and remove it form the array. So let\\'s say I combine 3 and 4 (cause 4 < 6, gives me less value), then remove 3 from the array  and we end up with [5,4,6,2,5]. And so on, just proceed with the same greedy approach. \\n* If you do bruteforce greedy, you\\'d do O(N^2): just seach for some local minima, then delete that element. But luckily you can use stack for some quick check if that element is a some local minima. And well remove it from the stack if it turns out to be so in O(1).\\n*   So example: [10,9,8,7,6,5,4,2,11,1]. In this example you can keep all those elements in decreasing order up to 2 and then when you see 11 you\\'ll realize it is bigger than 2 right? and because you\\'re keeping stack in decreasing order you know that 2 is the smallest element and the element before it is bigger too. That must mean that 2 is the local minima! That\\'s it just check if previous element is smaller than currrent, 4 < 11? Sure, 4 is smaller, then do 4 * 2 and add to your return answer. Oh, and update your stack: [10,9,8,7,6,5,4], cur = 11. You can notice that 4 is now the local minima... well just repeat.\\n*   A note about the line ```ret += a[--i] * ((i && a[i - 1] < x) ? a[i - 1] : x)```. As I was trying to tell ```a``` with a pointer ```i``` is my implicit stack. Thus, what it says here is that ```a[--i]``` is just me popping top element from the stack. Then I check whether the current ```a[i-1]``` top element in my stack is smaller or larger than ```x``` current element in the array ```a[i-1] < x ?```. If it is smaller then use it to multiply to the popped element, otherwise use ```x``` to multiply. Do that while ```x``` is bigger than the elements in the stack.\\n*   ```a[i++] = x``` is just adding element into a stack.\\n*   ```while (i > 1) ret += a[--i] * a[i - 1];``` This line is basically there cause could be a day when all numbers left are decreasing in the end, but I still need to combine them. So pop top and multiply by the previous element.\\n*  That\\'s it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& a) {\\n        int i = 0, ret = 0;\\n        for (auto &x : a) {\\n            while (i && a[i - 1] < x) \\n                ret += a[--i] * ((i && a[i - 1] < x) ? a[i - 1] : x);\\n            a[i++] = x;\\n        }\\n        while (i > 1)  \\n            ret += a[--i] * a[i - 1];\\n        return ret;\\n    }\\n};\\n```\n```i```\n```a[i-1]```\n```i==0```\n```ret += a[--i] * ((i && a[i - 1] < x) ? a[i - 1] : x)```\n```a```\n```i```\n```a[--i]```\n```a[i-1]```\n```x```\n```a[i-1] < x ?```\n```x```\n```x```\n```a[i++] = x```\n```while (i > 1) ret += a[--i] * a[i - 1];```",
                "codeTag": "Java"
            },
            {
                "id": 982863,
                "title": "c-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo_on_tree(vector<int>&arr, int sidx,int eidx,vector<vector<int>>&dp)\\n    {\\n        if(sidx == eidx)\\n        {\\n            return 0;\\n        }\\n        int mn = INT_MAX;\\n        if( dp[sidx][eidx]!=0 )\\n        {\\n            return dp[sidx][eidx];\\n        }\\n        for( int j=sidx;j<eidx;j++ )\\n        {\\n        int l = memo_on_tree(arr ,sidx ,j ,dp);\\n        int r = memo_on_tree(arr ,j+1 ,eidx ,dp);\\n        int t = l + r + *max_element(arr.begin()+sidx ,arr.begin()+j+1 ) * *max_element(arr.begin()+j+1 ,arr.begin()+eidx+1);\\n        mn = min(mn ,t);\\n        dp[sidx][eidx] = mn;\\n        }\\n        return mn;\\n        \\n    }\\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n     vector<vector<int>> dp( 40 , vector<int>(40,0));\\n     return memo_on_tree( arr ,0 ,arr.size()-1,dp );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo_on_tree(vector<int>&arr, int sidx,int eidx,vector<vector<int>>&dp)\\n    {\\n        if(sidx == eidx)\\n        {\\n            return 0;\\n        }\\n        int mn = INT_MAX;\\n        if( dp[sidx][eidx]!=0 )\\n        {\\n            return dp[sidx][eidx];\\n        }\\n        for( int j=sidx;j<eidx;j++ )\\n        {\\n        int l = memo_on_tree(arr ,sidx ,j ,dp);\\n        int r = memo_on_tree(arr ,j+1 ,eidx ,dp);\\n        int t = l + r + *max_element(arr.begin()+sidx ,arr.begin()+j+1 ) * *max_element(arr.begin()+j+1 ,arr.begin()+eidx+1);\\n        mn = min(mn ,t);\\n        dp[sidx][eidx] = mn;\\n        }\\n        return mn;\\n        \\n    }\\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n     vector<vector<int>> dp( 40 , vector<int>(40,0));\\n     return memo_on_tree( arr ,0 ,arr.size()-1,dp );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784307,
                "title": "java-recursion-memoization",
                "content": "```\\n- What are we trying to find in each of the recursive call?\\n\\t- We are trying to find the most optimal partition of our current array into \\'left/right\\' subarrays\\n\\t- The most optimal partition will give us the least possible sum of the values of each non-leaf node\\n\\t  and also the value of the largest leaf node\\n```\\n```\\npublic class MinimumCostTreeFromLeafValuesRecursiveApproach {\\n    private static final int MAX_LEAF = 0;\\n    private static final int MIN_SUM = 1;\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        int[] result = mctFromLeafValues(0, arr.length - 1, arr);\\n        return result[MIN_SUM];\\n    }\\n\\n    private int[] mctFromLeafValues(int left, int right, int[] arr) {\\n        if (left == right) return new int[] { arr[left], 0 };\\n\\n        int maxLeaf = Integer.MIN_VALUE, minSum = Integer.MAX_VALUE;\\n\\n        for (int i = left; i < right; i++) {\\n            int[] leftSide = mctFromLeafValues(left, i, arr);\\n            int[] rightSide = mctFromLeafValues(i + 1, right, arr);\\n\\n            minSum = Math.min(minSum, leftSide[MIN_SUM] + rightSide[MIN_SUM] + leftSide[MAX_LEAF] * rightSide[MAX_LEAF]);\\n            maxLeaf = Math.max(maxLeaf, Math.max(leftSide[MAX_LEAF], rightSide[MAX_LEAF]));\\n        }\\n\\n        return new int[] { maxLeaf, minSum };\\n    }\\n}\\n```\\n```\\npublic class MinimumCostTreeFromLeafValuesMemoizationApproach {\\n    private class Node {\\n        public int minSum;\\n        public int maxLeaf;\\n\\n        public Node(int maxLeaf, int minSum) {\\n            this.maxLeaf = maxLeaf;\\n            this.minSum = minSum;\\n        }\\n    }\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        Node result = mctFromLeafValues(0, arr.length - 1, arr, new Node[arr.length][arr.length]);\\n        return result.minSum;\\n    }\\n\\n    private Node mctFromLeafValues(int left, int right, int[] arr, Node[][] memo) {\\n        if (left == right) return new Node(arr[left], 0);\\n        if (memo[left][right] != null) return memo[left][right];\\n\\n        int maxLeaf = Integer.MIN_VALUE, minSum = Integer.MAX_VALUE;\\n\\n        for (int i = left; i < right; i++) {\\n            Node leftSide = mctFromLeafValues(left, i, arr, memo);\\n            Node rightSide = mctFromLeafValues(i + 1, right, arr, memo);\\n\\n            minSum = Math.min(minSum, leftSide.minSum + rightSide.minSum + leftSide.maxLeaf * rightSide.maxLeaf);\\n            maxLeaf = Math.max(maxLeaf, Math.max(leftSide.maxLeaf, rightSide.maxLeaf));\\n        }\\n\\n        memo[left][right] = new Node(maxLeaf, minSum);\\n        return memo[left][right];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- What are we trying to find in each of the recursive call?\\n\\t- We are trying to find the most optimal partition of our current array into \\'left/right\\' subarrays\\n\\t- The most optimal partition will give us the least possible sum of the values of each non-leaf node\\n\\t  and also the value of the largest leaf node\\n```\n```\\npublic class MinimumCostTreeFromLeafValuesRecursiveApproach {\\n    private static final int MAX_LEAF = 0;\\n    private static final int MIN_SUM = 1;\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        int[] result = mctFromLeafValues(0, arr.length - 1, arr);\\n        return result[MIN_SUM];\\n    }\\n\\n    private int[] mctFromLeafValues(int left, int right, int[] arr) {\\n        if (left == right) return new int[] { arr[left], 0 };\\n\\n        int maxLeaf = Integer.MIN_VALUE, minSum = Integer.MAX_VALUE;\\n\\n        for (int i = left; i < right; i++) {\\n            int[] leftSide = mctFromLeafValues(left, i, arr);\\n            int[] rightSide = mctFromLeafValues(i + 1, right, arr);\\n\\n            minSum = Math.min(minSum, leftSide[MIN_SUM] + rightSide[MIN_SUM] + leftSide[MAX_LEAF] * rightSide[MAX_LEAF]);\\n            maxLeaf = Math.max(maxLeaf, Math.max(leftSide[MAX_LEAF], rightSide[MAX_LEAF]));\\n        }\\n\\n        return new int[] { maxLeaf, minSum };\\n    }\\n}\\n```\n```\\npublic class MinimumCostTreeFromLeafValuesMemoizationApproach {\\n    private class Node {\\n        public int minSum;\\n        public int maxLeaf;\\n\\n        public Node(int maxLeaf, int minSum) {\\n            this.maxLeaf = maxLeaf;\\n            this.minSum = minSum;\\n        }\\n    }\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        Node result = mctFromLeafValues(0, arr.length - 1, arr, new Node[arr.length][arr.length]);\\n        return result.minSum;\\n    }\\n\\n    private Node mctFromLeafValues(int left, int right, int[] arr, Node[][] memo) {\\n        if (left == right) return new Node(arr[left], 0);\\n        if (memo[left][right] != null) return memo[left][right];\\n\\n        int maxLeaf = Integer.MIN_VALUE, minSum = Integer.MAX_VALUE;\\n\\n        for (int i = left; i < right; i++) {\\n            Node leftSide = mctFromLeafValues(left, i, arr, memo);\\n            Node rightSide = mctFromLeafValues(i + 1, right, arr, memo);\\n\\n            minSum = Math.min(minSum, leftSide.minSum + rightSide.minSum + leftSide.maxLeaf * rightSide.maxLeaf);\\n            maxLeaf = Math.max(maxLeaf, Math.max(leftSide.maxLeaf, rightSide.maxLeaf));\\n        }\\n\\n        memo[left][right] = new Node(maxLeaf, minSum);\\n        return memo[left][right];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766002,
                "title": "java-dp-without-recursion",
                "content": "```\\nclass Solution {\\n    public int findMax(int l, int h, int[]arr){\\n        int tmp = -1;\\n        for (int i = l; i <= h; i++) tmp = Math.max(tmp, arr[i]);\\n        return tmp;\\n    }\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        if (arr == null || arr.length <= 1) return 0;\\n        \\n        int[][] dp = new int[arr.length][arr.length];\\n        \\n        for (int j = 0; j < arr.length; j++){\\n            for (int i = j; i >= 0; i--){\\n                for (int k = i; k < j; k++){\\n                    int tmp = dp[i][k] + dp[k+1][j] + findMax(i,k,arr) * findMax(k+1,j,arr);\\n                    if (dp[i][j] == 0) \\n                        dp[i][j] = tmp;\\n                    else \\n                        dp[i][j] = Math.min(dp[i][j], tmp);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][arr.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findMax(int l, int h, int[]arr){\\n        int tmp = -1;\\n        for (int i = l; i <= h; i++) tmp = Math.max(tmp, arr[i]);\\n        return tmp;\\n    }\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        if (arr == null || arr.length <= 1) return 0;\\n        \\n        int[][] dp = new int[arr.length][arr.length];\\n        \\n        for (int j = 0; j < arr.length; j++){\\n            for (int i = j; i >= 0; i--){\\n                for (int k = i; k < j; k++){\\n                    int tmp = dp[i][k] + dp[k+1][j] + findMax(i,k,arr) * findMax(k+1,j,arr);\\n                    if (dp[i][j] == 0) \\n                        dp[i][j] = tmp;\\n                    else \\n                        dp[i][j] = Math.min(dp[i][j], tmp);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][arr.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425261,
                "title": "python-heap-solution",
                "content": "There are numerous ways to solve this problem, but I didn\\'t see anyone do it with a heap. The basic premise is to walk through the array using a minheap to track the smallest leaf seen essentially and collapse it with a larger leaf strategically until we end up with just one node. \\n\\n```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n  cost, heap = 0, [float(\\'inf\\')]\\n  for leaf in arr:\\n    while heap[0] < leaf: # join the cheapest possible leaves\\n      cost += heapq.heappop(heap) * min(leaf, heap[0])\\n    heapq.heappush(heap, leaf)\\n  while len(heap) > 2: # no choice but to join the remaining leaves\\n    cost += heapq.heappop(heap) * heap[0]\\n  return cost\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n  cost, heap = 0, [float(\\'inf\\')]\\n  for leaf in arr:\\n    while heap[0] < leaf: # join the cheapest possible leaves\\n      cost += heapq.heappop(heap) * min(leaf, heap[0])\\n    heapq.heappush(heap, leaf)\\n  while len(heap) > 2: # no choice but to join the remaining leaves\\n    cost += heapq.heappop(heap) * heap[0]\\n  return cost\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2146236,
                "title": "c-gap-strategy-dp-complete-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int dp[arr.size()][arr.size()];\\n        int m[arr.size()][arr.size()];\\n        memset(m,0,sizeof(m));\\n        for(int g = 0;g<arr.size();g++){\\n            for(int i=0,j=g;j<arr.size();i++,j++){\\n                if(g==0){\\n                    m[i][j] = arr[i];\\n                }else{\\n                    m[i][j] = max(m[i][j-1],m[i+1][j]);\\n                }\\n            }\\n        }\\n    \\n        \\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int g = 0;g<arr.size();g++){\\n            for(int i=0,j=g;j<arr.size();i++,j++){\\n                if(g==0){\\n                    dp[i][j] = 0;\\n                }else if(g == 1){\\n                    dp[i][j] = arr[i]*arr[j];\\n                }else{\\n                    int ans = INT_MAX;\\n                    for(int k = i;k < j;k++){\\n                         ans = min(ans,dp[i][k] + (m[i][k]*m[k+1][j]) + dp[k+1][j]);\\n                    }\\n                    dp[i][j] = ans;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][arr.size()-1];\\n    }\\n};\\n\\n    ```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int dp[arr.size()][arr.size()];\\n        int m[arr.size()][arr.size()];\\n        memset(m,0,sizeof(m));\\n        for(int g = 0;g<arr.size();g++){\\n            for(int i=0,j=g;j<arr.size();i++,j++){\\n                if(g==0){\\n                    m[i][j] = arr[i];\\n                }else{\\n                    m[i][j] = max(m[i][j-1],m[i+1][j]);\\n                }\\n            }\\n        }\\n    \\n        \\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int g = 0;g<arr.size();g++){\\n            for(int i=0,j=g;j<arr.size();i++,j++){\\n                if(g==0){\\n                    dp[i][j] = 0;\\n                }else if(g == 1){\\n                    dp[i][j] = arr[i]*arr[j];\\n                }else{\\n                    int ans = INT_MAX;\\n                    for(int k = i;k < j;k++){\\n                         ans = min(ans,dp[i][k] + (m[i][k]*m[k+1][j]) + dp[k+1][j]);\\n                    }\\n                    dp[i][j] = ans;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][arr.size()-1];\\n    }\\n};\\n\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 1249592,
                "title": "java-solution-o-n-time-o-n-space",
                "content": "```\\npublic int mctFromLeafValues(int[] arr) {\\n        int result=0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for(int a: arr){\\n            while(stack.peek()<=a){\\n                int mid=stack.pop();\\n                result+=mid*Math.min(stack.peek(),a);\\n            }\\n            stack.push(a);\\n        }\\n        while(stack.size()>2){\\n            result+=stack.pop()*stack.peek();\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int mctFromLeafValues(int[] arr) {\\n        int result=0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for(int a: arr){\\n            while(stack.peek()<=a){\\n                int mid=stack.pop();\\n                result+=mid*Math.min(stack.peek(),a);\\n            }\\n            stack.push(a);\\n        }\\n        while(stack.size()>2){\\n            result+=stack.pop()*stack.peek();\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832100,
                "title": "c-o-n-2-solution-both-greedy-optimized-with-comment-beats-100-runtime",
                "content": "Runtime: 4 ms, faster than 82.56% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\nMemory Usage: 8.3 MB, less than 93.24% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\n\\nIterate through the array and pick the min product of consicuitive elements of array and add it to sum. Remove the minimum element. Do this until array has only one element. \\n\\nTask is to get minimum sum of internal nodes and so we pick minimum products (internal nodes) in each iteration. Also the internal node value depends on large leaf node values and so we remove the small leaf elements from array. \\n\\nSome useful testcases:\\n[6, 2]\\n[6, 2, 4, 1, 7]\\n[6, 2, 4, 1, 7, 9]\\n[6, 2, 4, 1, 7, 4, 1, 9]\\n[6, 2, 4, 1, 7, 10, 1, 9]\\n[11,7,11,11,11,13]\\n[6,15,5,2]\\n\\n**[There is a better explanation](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/349098/From-O(N2)-to-O(n).-Greedy)**\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        int sum = 0;\\n\\t\\t// Loop till array has more than 1 element\\n        while(arr.size()>1)\\n        {\\n            int x;\\n            int min = INT_MAX;\\n            int v;\\n\\t\\t\\t// Find minimum product between any 2 consiquitive element\\n            for(int i=0;i<arr.size()-1;i++)\\n            {\\n\\t\\t\\t   // find product between 2 consiquitive element\\n                v = arr[i] * arr[i+1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// find minimum product\\n                if(min>v)\\n                {\\n                    min = v;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// find the index of minimum product\\'s minimum number\\n                    x = arr[i]<arr[i+1]?i:(i+1);\\n                }\\n            }\\n            \\n\\t\\t\\t// minimum products generates the internal node values\\n            sum += min;\\n\\t\\t\\t\\n\\t\\t\\t// remove index of the minimum element of minimum product\\n            arr.erase(arr.begin() + x);\\n        }\\n        \\n\\t\\t// minimum value of the sum of all internal nodes\\n        return sum;\\n    }\\n};\\n```\\n.\\n.\\n.\\n**Optimized Solution: Still close to O (N ^ 2) but avoided same product re-computation**\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\nMemory Usage: 8.4 MB, less than 86.37% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\n.\\n.\\n`Here we get the minmum product of consecutive elements in a different way. \\n1. If three element [b,a,c] are in array such that  b >= a and a <= c then min product = a * min(b,c) and remove a from list. \\n2. Also if A[0] <= A[1] then min product = A[0] * A[1] and remove A[0] from  list. \\n3. Again if A[n-2] >= A[n-1] then min product = A[n-1] * A[n-2] and remove A[n-1] from list\\n\\nAs we are using Linked List, remove operation takes O(1) time.`\\n.\\n.\\n.\\n```\\nclass Solution {\\npublic:\\n    struct Node{\\n        int val;\\n        Node * next;\\n    };\\n    \\n    Node * createNode(int val)\\n    {\\n        Node * node = new Node();\\n        node->val = val;\\n        node->next = NULL;\\n        \\n        return node;\\n    }\\n        \\n    int mctFromLeafValues(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        int sum = 0;\\n        Node * head = NULL;\\n        Node * tail = NULL;\\n        \\n        // Create LinkedList of the array items\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(head==NULL)\\n            {\\n                head = createNode(arr[i]);\\n                tail = head;\\n            }\\n            else\\n            {\\n                tail->next = createNode(arr[i]);\\n                tail = tail->next;\\n            }\\n        }\\n        \\n\\n        // Loop until linked list has 2 items\\n        while(head->next!=NULL && head->next->next!=NULL)\\n        {\\n            Node * pnode = NULL;\\n            Node * cnode = head;\\n            \\n            // Loop until the end of linked list\\n            while(cnode!=NULL && cnode->next!=NULL)\\n            {\\n                // Get min product A[0] * A[1], if A[0] <= A[1] and remove A[0]\\n                if(pnode==NULL && cnode->val<=cnode->next->val)\\n                {\\n                    sum+= (cnode->val*cnode->next->val);\\n                    head = cnode->next;\\n                    delete(cnode);\\n                    cnode = head;\\n                }\\n                \\n                // Get min product A[n-2] * A[n-1], if A[n-2] >= A[n-1] and remove A[n-1]\\n                else if(pnode!=NULL && cnode->next->next==NULL && cnode->val >= cnode->next->val)\\n                {\\n                    sum += (cnode->val * cnode->next->val);\\n                    delete(cnode->next);\\n                    cnode->next = NULL;\\n                }  \\n                \\n                // Get min product A[i] * min(A[i-1],A[i+1]), if A[i-1] >= A[i] && A[i] <= A[i+1] and remove A[i]\\n                else if(pnode!=NULL && cnode->next!=NULL && pnode->val>=cnode->val && cnode->val <= cnode->next->val)\\n                {\\n                    sum += (cnode->val * min(pnode->val,cnode->next->val));\\n                    pnode->next = cnode->next;\\n                    delete(cnode);\\n                    cnode = pnode->next;\\n                }                \\n                \\n                // Otherwise increment iterator\\n                else\\n                {\\n                    pnode = cnode;\\n                    cnode = cnode->next;\\n                }\\n            }\\n            \\n        }\\n        \\n        //Get product of last 2 items\\n        if(head->next!=NULL)\\n        {\\n            sum+= (head->val * head->next->val);\\n        } \\n        \\n        // Minimum sum of all internal nodes\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        int sum = 0;\\n\\t\\t// Loop till array has more than 1 element\\n        while(arr.size()>1)\\n        {\\n            int x;\\n            int min = INT_MAX;\\n            int v;\\n\\t\\t\\t// Find minimum product between any 2 consiquitive element\\n            for(int i=0;i<arr.size()-1;i++)\\n            {\\n\\t\\t\\t   // find product between 2 consiquitive element\\n                v = arr[i] * arr[i+1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// find minimum product\\n                if(min>v)\\n                {\\n                    min = v;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// find the index of minimum product\\'s minimum number\\n                    x = arr[i]<arr[i+1]?i:(i+1);\\n                }\\n            }\\n            \\n\\t\\t\\t// minimum products generates the internal node values\\n            sum += min;\\n\\t\\t\\t\\n\\t\\t\\t// remove index of the minimum element of minimum product\\n            arr.erase(arr.begin() + x);\\n        }\\n        \\n\\t\\t// minimum value of the sum of all internal nodes\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    struct Node{\\n        int val;\\n        Node * next;\\n    };\\n    \\n    Node * createNode(int val)\\n    {\\n        Node * node = new Node();\\n        node->val = val;\\n        node->next = NULL;\\n        \\n        return node;\\n    }\\n        \\n    int mctFromLeafValues(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        int sum = 0;\\n        Node * head = NULL;\\n        Node * tail = NULL;\\n        \\n        // Create LinkedList of the array items\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(head==NULL)\\n            {\\n                head = createNode(arr[i]);\\n                tail = head;\\n            }\\n            else\\n            {\\n                tail->next = createNode(arr[i]);\\n                tail = tail->next;\\n            }\\n        }\\n        \\n\\n        // Loop until linked list has 2 items\\n        while(head->next!=NULL && head->next->next!=NULL)\\n        {\\n            Node * pnode = NULL;\\n            Node * cnode = head;\\n            \\n            // Loop until the end of linked list\\n            while(cnode!=NULL && cnode->next!=NULL)\\n            {\\n                // Get min product A[0] * A[1], if A[0] <= A[1] and remove A[0]\\n                if(pnode==NULL && cnode->val<=cnode->next->val)\\n                {\\n                    sum+= (cnode->val*cnode->next->val);\\n                    head = cnode->next;\\n                    delete(cnode);\\n                    cnode = head;\\n                }\\n                \\n                // Get min product A[n-2] * A[n-1], if A[n-2] >= A[n-1] and remove A[n-1]\\n                else if(pnode!=NULL && cnode->next->next==NULL && cnode->val >= cnode->next->val)\\n                {\\n                    sum += (cnode->val * cnode->next->val);\\n                    delete(cnode->next);\\n                    cnode->next = NULL;\\n                }  \\n                \\n                // Get min product A[i] * min(A[i-1],A[i+1]), if A[i-1] >= A[i] && A[i] <= A[i+1] and remove A[i]\\n                else if(pnode!=NULL && cnode->next!=NULL && pnode->val>=cnode->val && cnode->val <= cnode->next->val)\\n                {\\n                    sum += (cnode->val * min(pnode->val,cnode->next->val));\\n                    pnode->next = cnode->next;\\n                    delete(cnode);\\n                    cnode = pnode->next;\\n                }                \\n                \\n                // Otherwise increment iterator\\n                else\\n                {\\n                    pnode = cnode;\\n                    cnode = cnode->next;\\n                }\\n            }\\n            \\n        }\\n        \\n        //Get product of last 2 items\\n        if(head->next!=NULL)\\n        {\\n            sum+= (head->val * head->next->val);\\n        } \\n        \\n        // Minimum sum of all internal nodes\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626917,
                "title": "java-0ms-beats-100-with-explanation",
                "content": "Idea is to split the given array in two parts such that the current maximum number is not used for multiplication operation.\\nKeep splitting the array till you are left with two elements. Multiply them and return the max of them.\\n\\nE.g.\\nInput => \\n[2, 8, 10, 3, 2, 12]\\n\\n\\nFirst split (index =5) divides the array in two parts [2, 8, 10, 3, 2] and  [12]\\nAfter second split => [2, 8], [10] and [3, 2]\\n\\n[2, 8] => sum += 2 * 8 and returns max(2, 8)\\n[3, 2] => sum += 3 * 2 and returns max(3, 2)\\n\\n[10] => Got max as 8 from left and 3 from right. At this point sum is already 22\\nsum += 10 * 8\\nsum += 10 * 3\\n\\n[12] => Got max as 10 from left. Sum already 132 at this time\\nsum += 12 * 10\\n\\nTotal min sum = 132 + 120 = 252\\n\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[] sum = new int[1];\\n        \\n        int max = evaluate(arr, 0, arr.length - 1, sum);\\n        \\n        return sum[0];\\n        \\n    }\\n    \\n    private int evaluate(int[] arr, int i, int j, int[] sum) {\\n        if(i > j || i < 0 || j < 0 || i >= arr.length || j >= arr.length) return 0;\\n        \\n        if(i == j - 1) {\\n            sum[0] += arr[i] * arr[j];\\n            return Math.max(arr[i], arr[j]);\\n        }\\n        \\n        int maxIndex = i;\\n        \\n        for(int k = i; k <= j; k++) {\\n            if(arr[k] >= arr[maxIndex]) {\\n                maxIndex = k;\\n            }\\n        }\\n        \\n        int max1 = evaluate(arr, i, maxIndex - 1, sum);\\n        int max2 = evaluate(arr, maxIndex + 1, j, sum);\\n        \\n        if(max1 > 0) sum[0] += arr[maxIndex] * max1;\\n        if(max2 > 0) sum[0] += arr[maxIndex] * max2;\\n        \\n        int max = Math.max(max1, max2);\\n        \\n        return Math.max(arr[maxIndex], max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[] sum = new int[1];\\n        \\n        int max = evaluate(arr, 0, arr.length - 1, sum);\\n        \\n        return sum[0];\\n        \\n    }\\n    \\n    private int evaluate(int[] arr, int i, int j, int[] sum) {\\n        if(i > j || i < 0 || j < 0 || i >= arr.length || j >= arr.length) return 0;\\n        \\n        if(i == j - 1) {\\n            sum[0] += arr[i] * arr[j];\\n            return Math.max(arr[i], arr[j]);\\n        }\\n        \\n        int maxIndex = i;\\n        \\n        for(int k = i; k <= j; k++) {\\n            if(arr[k] >= arr[maxIndex]) {\\n                maxIndex = k;\\n            }\\n        }\\n        \\n        int max1 = evaluate(arr, i, maxIndex - 1, sum);\\n        int max2 = evaluate(arr, maxIndex + 1, j, sum);\\n        \\n        if(max1 > 0) sum[0] += arr[maxIndex] * max1;\\n        if(max2 > 0) sum[0] += arr[maxIndex] * max2;\\n        \\n        int max = Math.max(max1, max2);\\n        \\n        return Math.max(arr[maxIndex], max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493454,
                "title": "from-recursion-to-top-down-dp",
                "content": "**Recursion**\\n```\\nminSumNonLeaf with leaf nodes (l, r) for from index l to index r both inclusive\\n= min(\\n\\tminSumNonLeaf(l, m-1) \\n\\t+ minSumNonLeaf(m, r) \\n\\t+ max(arr[l], ..., arr[m-1]) * max(arr[m], ..., arr[r])\\n)      \\n```\\n\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        return mctFromLeafValues(arr, 0, arr.length - 1);\\n    }\\n    \\n    private int mctFromLeafValues(int[] arr, int l, int r) {\\n        int mct = Integer.MAX_VALUE;\\n        for (int m = l + 1; m <= r; m++) {\\n            mct = Math.min( \\n                mct,\\n                mctFromLeafValues(arr, l, m - 1)\\n                    + mctFromLeafValues(arr, m, r)\\n                    + max(arr, l, m - 1) * max(arr, m, r));\\n        }\\n        return mct == Integer.MAX_VALUE ? 0 : mct;\\n    }\\n    \\n    private int max(int[] arr, int l, int r) {\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int k = l; k <= r; k++) {\\n            maxVal = Math.max(maxVal, arr[k]);\\n        }\\n        return maxVal;\\n    }\\n}\\n```\\n**Top-down DP**\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] memo = new int[arr.length][arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            Arrays.fill(memo[i], Integer.MAX_VALUE);\\n        }\\n        return mctFromLeafValues(arr, 0, arr.length - 1, memo);\\n    }\\n    \\n    private int mctFromLeafValues(int[] arr, int l, int r, int[][] memo) {\\n        if (memo[l][r] != Integer.MAX_VALUE) {\\n            return memo[l][r];\\n        } else {\\n            for (int m = l + 1; m <= r; m++) {\\n                memo[l][r] = Math.min( \\n                    memo[l][r],\\n                    mctFromLeafValues(arr, l, m - 1, memo)\\n                        + mctFromLeafValues(arr, m, r, memo)\\n                        + max(arr, l, m - 1) * max(arr, m, r));\\n            }\\n            memo[l][r] = memo[l][r] == Integer.MAX_VALUE ? 0 : memo[l][r];\\n            return memo[l][r];\\n        }\\n    }\\n    \\n    private int max(int[] arr, int l, int r) {\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int k = l; k <= r; k++) {\\n            maxVal = Math.max(maxVal, arr[k]);\\n        }\\n        return maxVal;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nminSumNonLeaf with leaf nodes (l, r) for from index l to index r both inclusive\\n= min(\\n\\tminSumNonLeaf(l, m-1) \\n\\t+ minSumNonLeaf(m, r) \\n\\t+ max(arr[l], ..., arr[m-1]) * max(arr[m], ..., arr[r])\\n)      \\n```\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        return mctFromLeafValues(arr, 0, arr.length - 1);\\n    }\\n    \\n    private int mctFromLeafValues(int[] arr, int l, int r) {\\n        int mct = Integer.MAX_VALUE;\\n        for (int m = l + 1; m <= r; m++) {\\n            mct = Math.min( \\n                mct,\\n                mctFromLeafValues(arr, l, m - 1)\\n                    + mctFromLeafValues(arr, m, r)\\n                    + max(arr, l, m - 1) * max(arr, m, r));\\n        }\\n        return mct == Integer.MAX_VALUE ? 0 : mct;\\n    }\\n    \\n    private int max(int[] arr, int l, int r) {\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int k = l; k <= r; k++) {\\n            maxVal = Math.max(maxVal, arr[k]);\\n        }\\n        return maxVal;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] memo = new int[arr.length][arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            Arrays.fill(memo[i], Integer.MAX_VALUE);\\n        }\\n        return mctFromLeafValues(arr, 0, arr.length - 1, memo);\\n    }\\n    \\n    private int mctFromLeafValues(int[] arr, int l, int r, int[][] memo) {\\n        if (memo[l][r] != Integer.MAX_VALUE) {\\n            return memo[l][r];\\n        } else {\\n            for (int m = l + 1; m <= r; m++) {\\n                memo[l][r] = Math.min( \\n                    memo[l][r],\\n                    mctFromLeafValues(arr, l, m - 1, memo)\\n                        + mctFromLeafValues(arr, m, r, memo)\\n                        + max(arr, l, m - 1) * max(arr, m, r));\\n            }\\n            memo[l][r] = memo[l][r] == Integer.MAX_VALUE ? 0 : memo[l][r];\\n            return memo[l][r];\\n        }\\n    }\\n    \\n    private int max(int[] arr, int l, int r) {\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int k = l; k <= r; k++) {\\n            maxVal = Math.max(maxVal, arr[k]);\\n        }\\n        return maxVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460743,
                "title": "python-o-n-beat-95-100-with-explanation",
                "content": "```\\n\\'\\'\\'\\nThen to minimize value of each non-leaf node requires find min arr[i]*arr[i+1] for i in range(len(arr)-1).\\nAfter building a node from arr[i] and arr[i+1], the max(arr[i], arr[i+1]) is still useful to build parent nodes.\\nSo we kick off min(arr[i], arr[i+1]) but keep max(arr[i], arr[i+1]).\\nFor example, [6,2,4,7] -> [6,4,7], res += 2*4 -> [6,7], res += 4*6 -> [7], res += 6*7, final res = 74\\nMono-decreasing stack is used. When a larger number comes in, kick off all small numbers before it and update res:\\ncur, stack, res\\n 6    [6]    0\\n 2   [6,2]   0\\n 4   [6,4]   8\\n 7    [7]    8+4*6+6*7\\nWhen a smaller number is kicked off, res is updated by stack[-1] * min(stack[-2], new large number)\\nFinally, pop out each node in stack to calculate final results.\\nTime: O(n)\\nSpace: O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        if not arr or len(arr) < 2:\\n            return 0\\n        arr_len = len(arr)\\n        my_stack = [arr[0]]\\n        res = 0\\n        for i, n in enumerate(arr[1:]):\\n            while my_stack and n > my_stack[-1]:\\n                sm = my_stack.pop()\\n                if my_stack:\\n                    res += sm * min(my_stack[-1], n)\\n                else:\\n                    res += sm * n\\n            my_stack.append(n)\\n        while len(my_stack) >= 2:\\n            sm = my_stack.pop()\\n            res += sm * my_stack[-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nThen to minimize value of each non-leaf node requires find min arr[i]*arr[i+1] for i in range(len(arr)-1).\\nAfter building a node from arr[i] and arr[i+1], the max(arr[i], arr[i+1]) is still useful to build parent nodes.\\nSo we kick off min(arr[i], arr[i+1]) but keep max(arr[i], arr[i+1]).\\nFor example, [6,2,4,7] -> [6,4,7], res += 2*4 -> [6,7], res += 4*6 -> [7], res += 6*7, final res = 74\\nMono-decreasing stack is used. When a larger number comes in, kick off all small numbers before it and update res:\\ncur, stack, res\\n 6    [6]    0\\n 2   [6,2]   0\\n 4   [6,4]   8\\n 7    [7]    8+4*6+6*7\\nWhen a smaller number is kicked off, res is updated by stack[-1] * min(stack[-2], new large number)\\nFinally, pop out each node in stack to calculate final results.\\nTime: O(n)\\nSpace: O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        if not arr or len(arr) < 2:\\n            return 0\\n        arr_len = len(arr)\\n        my_stack = [arr[0]]\\n        res = 0\\n        for i, n in enumerate(arr[1:]):\\n            while my_stack and n > my_stack[-1]:\\n                sm = my_stack.pop()\\n                if my_stack:\\n                    res += sm * min(my_stack[-1], n)\\n                else:\\n                    res += sm * n\\n            my_stack.append(n)\\n        while len(my_stack) >= 2:\\n            sm = my_stack.pop()\\n            res += sm * my_stack[-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353111,
                "title": "o-n-time-solution-explanation",
                "content": "Let\\'s first consider an alternate solution, which recuesively removes the smallest number in the array.\\nAssume ai is the current smallest number in the array,1<= i <= arr.length. It can be proved that the brother of ai must be a_{i-1} or a_{i+1}:\\n1. Suppose aj is the brother of ai. \\n2. If (j > i+1 and aj > a_{i+1}) or (j < i-1 and aj > a_{i-1}), then aj must not be the brother of ai because aj would be dropped out during the tree construction as the given array is in in-order traversal.\\n3. Thus, if we select aj (j < i-1), then the sum value of the subtree (al...aj...ai) = aj * ai + tree(al...aj...ai)  is less than the case when combine ai-1 and ai = ai-1 * ai + tree(al...aj...ai). When j > i+1, the proof is the same.\\n4. Also, we could conclude from the above formula that ai must combine with the smaller treenode between a_{i-1} and a_{i+1}.\\n\\nThen, we will show that the proposed algorithm has the same effect as the above process.\\nSuppose the current picked number is ai. It is obvious that the numbers in the stack are in descending order. Thus, if ai is less than the last number in the stack, we simply push ai into stack. Otherwise, we pop the last number in the stack, e.g., aj. Now, aj could be regarded as the smallest number in the array. Then, the nearest greater number to the right of aj is ai while the nearest greater number to the left is the last number in the stack. Thus, aj is combined with min(ai, last number in the stack), as shown in the proposed code. \\n\\nNote that a great insight in this problem is that ai is better to combine with the nearest and smallest number in the arrary.\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        vector<int> st = {INT_MAX};\\n        for (int i=0; i<arr.size(); i++) {\\n            int tmp = 0;\\n            while (st.back() <= arr[i]) \\n                tmp = st.back(), st.pop_back(), res += min(st.back(), arr[i]) * tmp;\\n            st.push_back(arr[i]);\\n        }\\n        for (int i=1; i<st.size()-1; i++)\\n            res += st[i] * st[i+1];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        vector<int> st = {INT_MAX};\\n        for (int i=0; i<arr.size(); i++) {\\n            int tmp = 0;\\n            while (st.back() <= arr[i]) \\n                tmp = st.back(), st.pop_back(), res += min(st.back(), arr[i]) * tmp;\\n            st.push_back(arr[i]);\\n        }\\n        for (int i=1; i<st.size()-1; i++)\\n            res += st[i] * st[i+1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594574,
                "title": "o-n-java-with-comments",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        \\n        /*\\n        Remove small element i and the cost is arr[i] * Math.min(arr[i-1], arr[i+1]). minimum cost happens between smaller values of i-1 and i+1.\\n\\nRemove until there is only one element and sum of cost is the answer.\\n\\nUse stack to maintain decreasing order, when there is bigger value num, then pop small value arr[i] and acculate the cost arr[i] * Math.min(num, stk.peek()).\\n*/\\n        \\n        if(arr == null || arr.length < 2) return 0;\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int result =0;\\n        \\n        stack.push(Integer.MAX_VALUE);\\n        \\n        for(int num: arr){\\n         \\n            while(stack.peek() <= num){\\n                int smallValue = stack.pop();\\n                result = result + smallValue*Math.min(stack.peek(),num);\\n            }\\n            stack.push(num);\\n        }\\n        \\n        \\n        while(stack.size() > 2){\\n            result = result + stack.pop()*stack.peek();\\n        }\\n        \\n        return result;\\n    }\\n    \\n}\\n```\\n\\nplease upvote my solution",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        \\n        /*\\n        Remove small element i and the cost is arr[i] * Math.min(arr[i-1], arr[i+1]). minimum cost happens between smaller values of i-1 and i+1.\\n\\nRemove until there is only one element and sum of cost is the answer.\\n\\nUse stack to maintain decreasing order, when there is bigger value num, then pop small value arr[i] and acculate the cost arr[i] * Math.min(num, stk.peek()).\\n*/\\n        \\n        if(arr == null || arr.length < 2) return 0;\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int result =0;\\n        \\n        stack.push(Integer.MAX_VALUE);\\n        \\n        for(int num: arr){\\n         \\n            while(stack.peek() <= num){\\n                int smallValue = stack.pop();\\n                result = result + smallValue*Math.min(stack.peek(),num);\\n            }\\n            stack.push(num);\\n        }\\n        \\n        \\n        while(stack.size() > 2){\\n            result = result + stack.pop()*stack.peek();\\n        }\\n        \\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903392,
                "title": "java-simple-dp-with-explanation-2ms-runtime",
                "content": "class pair{\\n    int val;\\n    int max;\\n    \\n    pair(int v, int m)\\n    {\\n        val = v;\\n        max = m;\\n    }\\n    \\n}\\n\\n\\nclass Solution {\\n    \\n    //This problem is a variation of Matrix chain multiplication.\\n    //It is a very famous Dp problem.\\n\\t//Upvote if you like the solution. Thanks!\\n    \\n    int []ar;\\n    pair [][]dp;\\n    \\n    //Here a pair object has 2 attributes, val and max\\n    \\n    //val -> It is the value of the internal node formed by multiplying the \\n    //       maximum values of leaf in the right and left sub trees.\\n    \\n    //max -> If this tree were to be a subtree to a node above it, we need to pass on the\\n    //       max value of the leaf present in this sub tree\\n    \\n    pair solve(int i, int j)\\n    {\\n        //If single node, No internal node is formed.\\n        //Therefore, val = 0, max = ar[i]\\n        if(j - i + 1 == 1)\\n            return new pair(0, ar[i]);\\n        \\n        //If 2 nodes, val of the internal node will be ar[i] * ar[j]\\n        //And the max of them will be passed as the maximum leaf value for a Node above it\\n        if(j - i + 1 == 2)\\n            return new pair(ar[i]*ar[j], Math.max(ar[i], ar[j]));\\n        \\n        //If value is already calculated, return it.\\n        if(dp[i][j] != null)\\n            return dp[i][j];\\n        \\n        //Initialize the current internal node value as Integer Max\\n        int min = Integer.MAX_VALUE;\\n        int max = -1;\\n        \\n        for(int k = i; k < j; k++)\\n        {\\n            int sum = 0;\\n            \\n            //Aftering solving the left part\\n            pair left = solve(i, k);\\n            \\n            //Aftering solving the right part\\n            pair right = solve(k + 1, j);\\n            \\n            //If left.val == 0, then it was a single node\\n            //right.val will be the only internal node that is formed\\n            if(left.val == 0)\\n                sum = right.val + left.max * right.max;\\n    \\n            //If right.val == 0, then it was a single node\\n            //left.val will be the only internal node that is formed\\n            else if(right.val == 0)\\n                sum = left.val + left.max * right.max;\\n\\n            //Otherwise, left.val and right.val are the values of the internal nodes \\n            //Formed by the left and right subtree\\n            else\\n                sum = left.val + right.val + left.max * right.max;\\n            \\n            \\n            //We add left.max * right.max to all the cases because\\n            //the parent node in all the cases will be the product of the \\n            //Max leaf value in the left and right subtree\\n            \\n            //Update sum and max if necessary\\n            if(min > sum)\\n            {\\n                min = sum;\\n                max = Math.max(left.max, right.max);\\n            }\\n            \\n        }\\n        \\n        //Store in dp and return\\n        return dp[i][j] = new pair(min, max);\\n    }\\n    \\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        \\n        if(arr == null || arr.length == 0)\\n            return 0;\\n        \\n        dp = new pair[arr.length][arr.length];\\n        \\n        ar = arr;\\n        \\n        return solve(0, arr.length - 1).val;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    //This problem is a variation of Matrix chain multiplication.\\n    //It is a very famous Dp problem.\\n\\t//Upvote if you like the solution. Thanks!\\n    \\n    int []ar;\\n    pair [][]dp;\\n    \\n    //Here a pair object has 2 attributes, val and max\\n    \\n    //val -> It is the value of the internal node formed by multiplying the \\n    //       maximum values of leaf in the right and left sub trees.\\n    \\n    //max -> If this tree were to be a subtree to a node above it, we need to pass on the\\n    //       max value of the leaf present in this sub tree\\n    \\n    pair solve(int i, int j)\\n    {\\n        //If single node, No internal node is formed.\\n        //Therefore, val = 0, max = ar[i]\\n        if(j - i + 1 == 1)\\n            return new pair(0, ar[i]);\\n        \\n        //If 2 nodes, val of the internal node will be ar[i] * ar[j]\\n        //And the max of them will be passed as the maximum leaf value for a Node above it\\n        if(j - i + 1 == 2)\\n            return new pair(ar[i]*ar[j], Math.max(ar[i], ar[j]));\\n        \\n        //If value is already calculated, return it.\\n        if(dp[i][j] != null)\\n            return dp[i][j];\\n        \\n        //Initialize the current internal node value as Integer Max\\n        int min = Integer.MAX_VALUE;\\n        int max = -1;\\n        \\n        for(int k = i; k < j; k++)\\n        {\\n            int sum = 0;\\n            \\n            //Aftering solving the left part\\n            pair left = solve(i, k);\\n            \\n            //Aftering solving the right part\\n            pair right = solve(k + 1, j);\\n            \\n            //If left.val == 0, then it was a single node\\n            //right.val will be the only internal node that is formed\\n            if(left.val == 0)\\n                sum = right.val + left.max * right.max;\\n    \\n            //If right.val == 0, then it was a single node\\n            //left.val will be the only internal node that is formed\\n            else if(right.val == 0)\\n                sum = left.val + left.max * right.max;\\n\\n            //Otherwise, left.val and right.val are the values of the internal nodes \\n            //Formed by the left and right subtree\\n            else\\n                sum = left.val + right.val + left.max * right.max;\\n            \\n            \\n            //We add left.max * right.max to all the cases because\\n            //the parent node in all the cases will be the product of the \\n            //Max leaf value in the left and right subtree\\n            \\n            //Update sum and max if necessary\\n            if(min > sum)\\n            {\\n                min = sum;\\n                max = Math.max(left.max, right.max);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 723896,
                "title": "cpp-solution-with-comments",
                "content": "Runtime: 48 ms, faster than 15.89% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\nMemory Usage: 9 MB, less than 35.80% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\n```\\nclass Solution {\\n    int getMax(vector<int> &arr, int start, int end){\\n        int max_ = arr[start];\\n        for(int i = start+1; i <= end; i++){\\n            max_ = max(max_,arr[i]);\\n        }\\n        return max_;\\n    }\\n    int helper(vector<int>& arr, int start, int end, vector<vector<int>>& dp){\\n        if(start == end) return 0;\\n        if(end - start  == 1) return arr[start] * arr[end];\\n        if(dp[start][end] != -1) return dp[start][end];\\n        int x ,y = INT_MAX;\\n        for(int i = 0; start + i + 1 <= end; i++){\\n            //start to start+i in left sub tree start+i+1 to end in right\\n            //new node formed will be multiplication or largest leaf node from both sub tree\\n            //plus rest of nodes formed in the left and right subtree\\n            x =  getMax(arr,start,start+i) * getMax(arr,start+i+1,end) +   helper(arr,start,start+i,dp) + helper(arr,start+i+1,end,dp) ;\\n            //minimum of all possible combination\\n            y = min(y,x);\\n        }\\n        dp[start][end] = y;\\n        return dp[start][end];\\n    }\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<int>> dp(n, vector<int> (n,-1));\\n        return helper(arr,0,n-1,dp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int getMax(vector<int> &arr, int start, int end){\\n        int max_ = arr[start];\\n        for(int i = start+1; i <= end; i++){\\n            max_ = max(max_,arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 475182,
                "title": "c-recursive-memoization-tabulation-optimized-tabulation",
                "content": "For DP approach, the most imporant thing is to find the recursive equation. We can observe the overlapping subproblems, but not the optimal substructure. This makes the recursive relation for this problem is a bit special and does not have a nice form like a math formula. In fact, we can only try all possibilities of the tree and find the optimal one. \\n\\nHow to generate all possibilities? (This is the hardest part of this problem, in my opinion.)\\nActually, brute force. Split the array at different positions and get the cost for all the ways of splitting, then choose the way that gives the minimum cost. Now you know how to get the recursive equation.\\n\\n```C++\\nclass Solution {\\nprivate:\\n    int maxInRange(vector<int>& v, int l, int r) {\\n        int res = 0;\\n        for(int i = l; i <= r; ++i) res = max(res, v[i]);\\n        return res;\\n    }\\n    \\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        return opTab(arr);\\n    }\\n    \\n    // TLE\\n    int recursive(vector<int>& arr, int l, int r) {\\n        if (l == r) return 0;\\n        if (l + 1 == r) return arr[l] * arr[r];\\n        \\n        int res = INT_MAX;\\n        for(int leftLast = l; leftLast < r; ++leftLast) {\\n            int sum = recursive(arr, l, leftLast) + recursive(arr, leftLast+1, r);\\n            sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n            res = min(res, sum);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    // memoization\\n    // Time: more than O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int memoization(vector<int>& arr) {\\n        vector<vector<int>> mem(arr.size(), vector<int>(arr.size(), -1));\\n        return solve(arr, mem, 0, arr.size() - 1);\\n    }\\n    \\n    /*\\n    Let m = r - l.\\n    No. of iterations = m - 1.\\n    Two maxInRange calls has similar complexity as maxInRange(arr, i, j): O(m).\\n    Thus, complexity of solve: O(m ^ 2).\\n    */\\n    int solve(vector<int>& arr, vector<vector<int>>& mem, int l, int r) {\\n        if (l == r) return 0;\\n        if (l + 1 == r) return arr[l] * arr[r];\\n        if (mem[l][r] >= 0) return mem[l][r];\\n        \\n        mem[l][r] = INT_MAX;\\n        for(int leftLast = l; leftLast < r; ++leftLast) {\\n            int sum = solve(arr, mem, l, leftLast) + solve(arr, mem, leftLast+1, r);\\n            sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n            mem[l][r] = min(mem[l][r], sum);\\n        }\\n        return mem[l][r];\\n    }\\n    \\n    \\n    // tabulation\\n    // Time: more than O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int tabulation(vector<int>& arr) {\\n        vector<vector<int>> tab(arr.size(), vector<int>(arr.size()));\\n        \\n        for(int l = arr.size() - 1; l >= 0; --l) {\\n            for(int r = l; r <= arr.size() - 1; ++r) {\\n                if (l == r) {\\n                    tab[l][r] = 0;\\n                } else if (l + 1 == r) {\\n                    tab[l][r] = arr[l] * arr[r];\\n                } else {\\n                    tab[l][r] = INT_MAX;\\n                    // O(m ^ 2), where m = r - l.\\n                    for(int leftLast = l; leftLast < r; ++leftLast) {\\n                        int sum = tab[l][leftLast] + tab[leftLast+1][r];\\n                        sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n                        tab[l][r] = min(tab[l][r], sum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return tab[0][arr.size() - 1];\\n    }\\n    \\n    \\n    // The process for finding the max value in range can be cached.\\n    // better tabulation\\n    // Time: O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int opTab(vector<int>& arr) {\\n        vector<vector<int>> tab(arr.size(), vector<int>(arr.size()));\\n        \\n\\t\\t// compute max value for all ranges\\n        vector<vector<int>> maxTab(arr.size(), vector<int>(arr.size()));\\n        for(int i = 0; i < maxTab.size(); ++i) {\\n            maxTab[i][i] = arr[i];\\n            for(int j = i + 1; j < maxTab[0].size(); ++j) {\\n                maxTab[i][j] = max(maxTab[i][j-1], arr[j]);\\n            }\\n        }\\n        \\n        for(int l = arr.size() - 1; l >= 0; --l) {\\n            for(int r = l; r <= arr.size() - 1; ++r) {\\n                if (l == r) {\\n                    tab[l][r] = 0;\\n                } else if (l + 1 == r) {\\n                    tab[l][r] = arr[l] * arr[r];\\n                } else {\\n                    tab[l][r] = INT_MAX;\\n                    for(int leftLast = l; leftLast < r; ++leftLast) {\\n                        int sum = tab[l][leftLast] + tab[leftLast+1][r];\\n                        sum += maxTab[l][leftLast] * maxTab[leftLast+1][r];\\n                        tab[l][r] = min(tab[l][r], sum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return tab[0][arr.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```C++\\nclass Solution {\\nprivate:\\n    int maxInRange(vector<int>& v, int l, int r) {\\n        int res = 0;\\n        for(int i = l; i <= r; ++i) res = max(res, v[i]);\\n        return res;\\n    }\\n    \\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        return opTab(arr);\\n    }\\n    \\n    // TLE\\n    int recursive(vector<int>& arr, int l, int r) {\\n        if (l == r) return 0;\\n        if (l + 1 == r) return arr[l] * arr[r];\\n        \\n        int res = INT_MAX;\\n        for(int leftLast = l; leftLast < r; ++leftLast) {\\n            int sum = recursive(arr, l, leftLast) + recursive(arr, leftLast+1, r);\\n            sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n            res = min(res, sum);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    // memoization\\n    // Time: more than O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int memoization(vector<int>& arr) {\\n        vector<vector<int>> mem(arr.size(), vector<int>(arr.size(), -1));\\n        return solve(arr, mem, 0, arr.size() - 1);\\n    }\\n    \\n    /*\\n    Let m = r - l.\\n    No. of iterations = m - 1.\\n    Two maxInRange calls has similar complexity as maxInRange(arr, i, j): O(m).\\n    Thus, complexity of solve: O(m ^ 2).\\n    */\\n    int solve(vector<int>& arr, vector<vector<int>>& mem, int l, int r) {\\n        if (l == r) return 0;\\n        if (l + 1 == r) return arr[l] * arr[r];\\n        if (mem[l][r] >= 0) return mem[l][r];\\n        \\n        mem[l][r] = INT_MAX;\\n        for(int leftLast = l; leftLast < r; ++leftLast) {\\n            int sum = solve(arr, mem, l, leftLast) + solve(arr, mem, leftLast+1, r);\\n            sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n            mem[l][r] = min(mem[l][r], sum);\\n        }\\n        return mem[l][r];\\n    }\\n    \\n    \\n    // tabulation\\n    // Time: more than O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int tabulation(vector<int>& arr) {\\n        vector<vector<int>> tab(arr.size(), vector<int>(arr.size()));\\n        \\n        for(int l = arr.size() - 1; l >= 0; --l) {\\n            for(int r = l; r <= arr.size() - 1; ++r) {\\n                if (l == r) {\\n                    tab[l][r] = 0;\\n                } else if (l + 1 == r) {\\n                    tab[l][r] = arr[l] * arr[r];\\n                } else {\\n                    tab[l][r] = INT_MAX;\\n                    // O(m ^ 2), where m = r - l.\\n                    for(int leftLast = l; leftLast < r; ++leftLast) {\\n                        int sum = tab[l][leftLast] + tab[leftLast+1][r];\\n                        sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n                        tab[l][r] = min(tab[l][r], sum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return tab[0][arr.size() - 1];\\n    }\\n    \\n    \\n    // The process for finding the max value in range can be cached.\\n    // better tabulation\\n    // Time: O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int opTab(vector<int>& arr) {\\n        vector<vector<int>> tab(arr.size(), vector<int>(arr.size()));\\n        \\n\\t\\t// compute max value for all ranges\\n        vector<vector<int>> maxTab(arr.size(), vector<int>(arr.size()));\\n        for(int i = 0; i < maxTab.size(); ++i) {\\n            maxTab[i][i] = arr[i];\\n            for(int j = i + 1; j < maxTab[0].size(); ++j) {\\n                maxTab[i][j] = max(maxTab[i][j-1], arr[j]);\\n            }\\n        }\\n        \\n        for(int l = arr.size() - 1; l >= 0; --l) {\\n            for(int r = l; r <= arr.size() - 1; ++r) {\\n                if (l == r) {\\n                    tab[l][r] = 0;\\n                } else if (l + 1 == r) {\\n                    tab[l][r] = arr[l] * arr[r];\\n                } else {\\n                    tab[l][r] = INT_MAX;\\n                    for(int leftLast = l; leftLast < r; ++leftLast) {\\n                        int sum = tab[l][leftLast] + tab[leftLast+1][r];\\n                        sum += maxTab[l][leftLast] * maxTab[leftLast+1][r];\\n                        tab[l][r] = min(tab[l][r], sum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return tab[0][arr.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458577,
                "title": "java-readable-top-down-memoization-with-triplets-node-sum-largest-leaf",
                "content": "# Idea\\nBreak the problem into smaller subproblems; what if we can get the product and minimal sums for sub-trees of this product tree?\\n\\nThe intuition here is that since the leaf nodes are ordered, we can consider range-based sub-trees.\\n# Structures\\nThe `Triplet` keeps track of the:\\n- `int node`: this is the product at this point, used to compute the successive cumulative sum\\n- `int sum`: combined with node, this is useful for cacheing the sum to compute the cumulative sum up the subtrees\\n- `int largestLeaf`: for computing the parent node\\'s product, propagated up from the leaf nodes and re-computed at intersections\\n\\nWe want to minimize the `sum`, but require the other two fields to do so.\\n# Memoization\\nWe cache the optimal subtree in range `[left, right]`, where `0 <= left <= right < N`.\\n# Complexity\\nTime: O(N^2) to fill out the memo.\\nSpace: O(N^2) as there are a quadratic number of pairs of `(left, right)`.\\n# Code\\n```\\nclass Solution {\\n    \\n    class Triplet {\\n        public int node;\\n        public int sum;\\n        public int largestLeaf;\\n        public Triplet(int n, int s, int ll) { node = n; sum = s; largestLeaf = ll; }\\n    }\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        Triplet[][] memo = new Triplet[arr.length][arr.length];\\n        return dp(arr, 0, arr.length-1, memo).sum;\\n    }\\n    \\n    private Triplet dp(int[] arr, int left, int right, Triplet[][] memo) {\\n        if (memo[left][right] != null) return memo[left][right];\\n        \\n        Triplet minSum = new Triplet(-1, Integer.MAX_VALUE, -1);\\n        \\n        if (left == right) {\\n\\t\\t    // The solution for the singleton tree is just that node\\n            minSum = new Triplet(arr[left], 0, arr[left]);\\n        }\\n        else {\\n            for (int i = left; i < right; ++i) {\\n                Triplet splitLeft = dp(arr, left, i, memo);\\n                Triplet splitRight = dp(arr, i+1, right, memo);\\n\\t\\t\\t\\t\\n                int product = splitLeft.largestLeaf * splitRight.largestLeaf;\\n                int sum = splitLeft.sum + splitRight.sum + product;\\n\\n                if (sum < minSum.sum) {\\n\\t\\t\\t\\t\\tint largestLeaf = Math.max(splitLeft.largestLeaf, splitRight.largestLeaf);\\n                    minSum = new Triplet(product, sum, largestLeaf);\\n                }\\n            }\\n        }\\n        memo[left][right] = minSum;\\n        \\n        return minSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Triplet {\\n        public int node;\\n        public int sum;\\n        public int largestLeaf;\\n        public Triplet(int n, int s, int ll) { node = n; sum = s; largestLeaf = ll; }\\n    }\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        Triplet[][] memo = new Triplet[arr.length][arr.length];\\n        return dp(arr, 0, arr.length-1, memo).sum;\\n    }\\n    \\n    private Triplet dp(int[] arr, int left, int right, Triplet[][] memo) {\\n        if (memo[left][right] != null) return memo[left][right];\\n        \\n        Triplet minSum = new Triplet(-1, Integer.MAX_VALUE, -1);\\n        \\n        if (left == right) {\\n\\t\\t    // The solution for the singleton tree is just that node\\n            minSum = new Triplet(arr[left], 0, arr[left]);\\n        }\\n        else {\\n            for (int i = left; i < right; ++i) {\\n                Triplet splitLeft = dp(arr, left, i, memo);\\n                Triplet splitRight = dp(arr, i+1, right, memo);\\n\\t\\t\\t\\t\\n                int product = splitLeft.largestLeaf * splitRight.largestLeaf;\\n                int sum = splitLeft.sum + splitRight.sum + product;\\n\\n                if (sum < minSum.sum) {\\n\\t\\t\\t\\t\\tint largestLeaf = Math.max(splitLeft.largestLeaf, splitRight.largestLeaf);\\n                    minSum = new Triplet(product, sum, largestLeaf);\\n                }\\n            }\\n        }\\n        memo[left][right] = minSum;\\n        \\n        return minSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416550,
                "title": "brute-force-solution-and-optimised-soltuion-without-dp",
                "content": "We just need to find the smallest product element in each iteration and replace those two with the max value of the two element\\n```\\npublic int mctFromLeafValues(int[] arr) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            list.add(arr[i]);\\n        }\\n        int res = 0;\\n        while(list.size()>1){\\n            int product = Integer.MAX_VALUE;\\n            int index = 0;\\n            for(int i=0;i<list.size()-1;i++){\\n                if(list.get(i)*list.get(i+1)<product){\\n                    product = list.get(i)*list.get(i+1);\\n                    index = i;\\n                }\\n            }\\n            list.set(index, Integer.max(list.get(index), list.get(index+1)));\\n            list.remove(index+1);\\n            res += product;\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nThere is an optimisation we can do by using stack intead of ArrayList and remove element when we find the next greater because the element either combines with its left element or right element whichever is minimum.\\n```\\npublic int mctFromLeafValues(int[] A) {\\n        int res = 0, n = A.length;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();\\n                res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int mctFromLeafValues(int[] arr) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            list.add(arr[i]);\\n        }\\n        int res = 0;\\n        while(list.size()>1){\\n            int product = Integer.MAX_VALUE;\\n            int index = 0;\\n            for(int i=0;i<list.size()-1;i++){\\n                if(list.get(i)*list.get(i+1)<product){\\n                    product = list.get(i)*list.get(i+1);\\n                    index = i;\\n                }\\n            }\\n            list.set(index, Integer.max(list.get(index), list.get(index+1)));\\n            list.remove(index+1);\\n            res += product;\\n        }\\n        \\n        return res;\\n    }\\n```\n```\\npublic int mctFromLeafValues(int[] A) {\\n        int res = 0, n = A.length;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();\\n                res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340045,
                "title": "python-recursion-with-cache",
                "content": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        cache = {}\\n        def recur(start, end):\\n            if start == end:\\n                return arr[start], 0\\n            \\n            key = f\"{start} {end}\"\\n            if key in cache:\\n                return cache[key]\\n            \\n            local_max, local_sum = 0, math.inf\\n            for i in range(start, end):\\n                left_max, left_sum = recur(start, i)\\n                right_max, right_sum = recur(i + 1, end)\\n                local_max = max(local_max, max(left_max, right_max))\\n                local_sum = min(local_sum, left_sum + right_sum + left_max * right_max)\\n            \\n            cache[key] = local_max, local_sum\\n            \\n            return cache[key]\\n        \\n        return recur(0, len(arr) - 1)[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        cache = {}\\n        def recur(start, end):\\n            if start == end:\\n                return arr[start], 0\\n            \\n            key = f\"{start} {end}\"\\n            if key in cache:\\n                return cache[key]\\n            \\n            local_max, local_sum = 0, math.inf\\n            for i in range(start, end):\\n                left_max, left_sum = recur(start, i)\\n                right_max, right_sum = recur(i + 1, end)\\n                local_max = max(local_max, max(left_max, right_max))\\n                local_sum = min(local_sum, left_sum + right_sum + left_max * right_max)\\n            \\n            cache[key] = local_max, local_sum\\n            \\n            return cache[key]\\n        \\n        return recur(0, len(arr) - 1)[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777595,
                "title": "explained-with-example-c-dp-recursion",
                "content": "**Please Upvote if you find useful.....**\\n\\n**Important Points:**\\n1. The `non-leaf node` is created using **maximum value of left sub-tree and maximum value of right sub-tree.**\\n2. We have to make **partion of the array at all possible point** and Using those partion we have to find non-leaf nodes.\\nLet us take an example  **: [2,8,4,1,3]**\\n![image](https://assets.leetcode.com/users/images/500c80e0-2433-4e98-bd77-4d26343dc163_1645079150.6221445.png)![image](https://assets.leetcode.com/users/images/fd6a230f-5d86-4284-b0b8-6e8edbd79dce_1645079183.5354905.png)\\n\\n\\n\\n\\n**How can you approch this problem:**\\n1. Choose  `two possible point i and j which i is left most and j is right most such that all valid binary tree are created.`ie=>**i=0 and j=n-1.**\\n2. **Using k loops:**: It means you have to **iterate the every possible point b/w  i to j a**nd `find all possible combination.`\\n3. Base case=> As you move further in recursion =>`i and j came closer` . `if i==j ie: one element left so you have to return 0 because no binary tree is created using it.`\\n4. Now you  you have two partions:\\n`left partion---->(i,k)`\\n`right partion--->(k+1,j)`\\nfrom `left partion you have to find maximum value `\\nfrom` right partion you have to find maximum value`\\nans product it,\\n5.These are all `temporary answer so you will have to find minimum of all possible values.`\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<int>&arr,int i,int j)\\n    {\\n\\t//Base case as mention in step 3.\\n        if(i==j)\\n        {\\n            return dp[i][j]= 0;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n\\t\\t//Final answer (5)\\n        int ans=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n\\t\\t//Left partion \\n            int left=solve(arr,i,k);\\n\\t\\t\\t//Right Partion\\n            int right=solve(arr,k+1,j);\\n\\t\\t\\t//maximum value in left partion\\n            int max_left=*max_element(arr.begin()+i,arr.begin()+k+1);\\n\\t\\t\\t//maximum value in right partion.\\n            int max_right=*max_element(arr.begin()+k+1,arr.begin()+j+1);\\n\\t\\t\\t// As we to find temprorary answer.\\n            int temp=left+right+max_left*max_right;\\n\\t\\t\\t//Minum of all answer\\n            ans=min(ans,temp);\\n        }\\n        return dp[i][j]= ans;\\n    }\\n    \\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        \\n        int n=arr.size();\\n        for(int i=0;i<=100;i++)\\n        {\\n            for(int j=0;j<=100;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(arr,0,n-1);\\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<int>&arr,int i,int j)\\n    {\\n\\t//Base case as mention in step 3.\\n        if(i==j)\\n        {\\n            return dp[i][j]= 0;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n\\t\\t//Final answer (5)\\n        int ans=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n\\t\\t//Left partion \\n            int left=solve(arr,i,k);\\n\\t\\t\\t//Right Partion\\n            int right=solve(arr,k+1,j);\\n\\t\\t\\t//maximum value in left partion\\n            int max_left=*max_element(arr.begin()+i,arr.begin()+k+1);\\n\\t\\t\\t//maximum value in right partion.\\n            int max_right=*max_element(arr.begin()+k+1,arr.begin()+j+1);\\n\\t\\t\\t// As we to find temprorary answer.\\n            int temp=left+right+max_left*max_right;\\n\\t\\t\\t//Minum of all answer\\n            ans=min(ans,temp);\\n        }\\n        return dp[i][j]= ans;\\n    }\\n    \\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        \\n        int n=arr.size();\\n        for(int i=0;i<=100;i++)\\n        {\\n            for(int j=0;j<=100;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(arr,0,n-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653541,
                "title": "python-monotonic-stack-o-n-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        # O(n) monotonic stack solution\\n        # The general goal is that we wish to minimize products in the tree.\\n        # To do so, we want the lowest value nodes as low of level as possible in the tree \\n\\t\\t# and conversely the higher value nodes as high as possible.\\n        # This is due to the property of non-leaf nodes in the problem where\\n        # the value of each non-leaf node is equal to the product of the largest leaf value \\n\\t\\t# in its left and right subtree.\\n        # The overall intuition is similar to the O(n^2) greedy solution.\\n        # By doing so, we make sure that the greatest elements in the array\\n        # are only in the product calculations for as \"high\" in the tree as possible.\\n        # The local minima (by node value) will end up being at the lowest levels of the tree.\\n        # From a different point of view, you could see it as delaying using the higher value nodes for \\n\\t\\t# as long as possible in the higher levels.\\n        # A monotonic stack allows us to do this by always providing us information\\n        # on the previous smallest \"unused\" node that we have seen so far\\n        # which allows us to solve the problem in 1 pass.\\n        \\n        res = 0\\n        stack = []\\n        \\n        for num in arr:\\n            while len(stack) != 0 and num >= stack[-1]:\\n                # maintain the monotonic stack property by popping elements\\n                \\n                # the middle element is the local minima\\n                # left is the next item on stack\\n                # right is the current num\\n                mid = stack.pop()\\n                if len(stack) == 0:\\n\\t\\t\\t\\t\\t# no left, so use right in product calculation\\n                    res = res + mid * num\\n                else:\\n\\t\\t\\t\\t\\t# select between left and right to minimize cost\\n                    res = res + mid * min(stack[-1], num)\\n         \\n\\t\\t\\t# current element can be added in its place in stack\\n            stack.append(num)\\n        \\n        # by the end, there can be multiple leftover items in the stack\\n        # include them in the cost by just multiplying adjacent nodes\\n        # it is guaranteed optimal because of the monotonic property\\n        while len(stack) > 1: # > 1 because we need a pair to form a product\\n            res = res + stack.pop() * stack[-1]\\n        \\n        return res\\n```\\n\\nI suggest running through the code and drawing the stack as well as the in progress tree to really understand the algorithm. You will be able to visualize how the tree is created bottom-up with minimal cost.\\n\\nTime complexity: O(n) since we iterate through the array once and we push and pop each element to the stack only once.\\nSpace complexity: O(n) from the monotonic stack.\\n",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        # O(n) monotonic stack solution\\n        # The general goal is that we wish to minimize products in the tree.\\n        # To do so, we want the lowest value nodes as low of level as possible in the tree \\n\\t\\t# and conversely the higher value nodes as high as possible.\\n        # This is due to the property of non-leaf nodes in the problem where\\n        # the value of each non-leaf node is equal to the product of the largest leaf value \\n\\t\\t# in its left and right subtree.\\n        # The overall intuition is similar to the O(n^2) greedy solution.\\n        # By doing so, we make sure that the greatest elements in the array\\n        # are only in the product calculations for as \"high\" in the tree as possible.\\n        # The local minima (by node value) will end up being at the lowest levels of the tree.\\n        # From a different point of view, you could see it as delaying using the higher value nodes for \\n\\t\\t# as long as possible in the higher levels.\\n        # A monotonic stack allows us to do this by always providing us information\\n        # on the previous smallest \"unused\" node that we have seen so far\\n        # which allows us to solve the problem in 1 pass.\\n        \\n        res = 0\\n        stack = []\\n        \\n        for num in arr:\\n            while len(stack) != 0 and num >= stack[-1]:\\n                # maintain the monotonic stack property by popping elements\\n                \\n                # the middle element is the local minima\\n                # left is the next item on stack\\n                # right is the current num\\n                mid = stack.pop()\\n                if len(stack) == 0:\\n\\t\\t\\t\\t\\t# no left, so use right in product calculation\\n                    res = res + mid * num\\n                else:\\n\\t\\t\\t\\t\\t# select between left and right to minimize cost\\n                    res = res + mid * min(stack[-1], num)\\n         \\n\\t\\t\\t# current element can be added in its place in stack\\n            stack.append(num)\\n        \\n        # by the end, there can be multiple leftover items in the stack\\n        # include them in the cost by just multiplying adjacent nodes\\n        # it is guaranteed optimal because of the monotonic property\\n        while len(stack) > 1: # > 1 because we need a pair to form a product\\n            res = res + stack.pop() * stack[-1]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027170,
                "title": "dp-filling-order-graph-visualization",
                "content": "Code:\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = 0\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                j = i + l - 1\\n                for k in range(i, j):\\n                    rootVal = max(arr[i:k+1]) * max(arr[k+1:j+1])\\n                    dp[i][j] = min(dp[i][j], rootVal + dp[i][k] + dp[k + 1][j])\\n        return dp[0][n - 1]\\n```\\n\\nGraph:\\n![image](https://assets.leetcode.com/users/images/d9508a4c-a24d-436a-85b2-8f5104e0b9b7_1611202141.8838825.png)\\n\\nThe code come from this amazing post: https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/478708/RZ-Summary-of-all-the-solutions-I-have-learned-from-Discuss-in-Python\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = 0\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                j = i + l - 1\\n                for k in range(i, j):\\n                    rootVal = max(arr[i:k+1]) * max(arr[k+1:j+1])\\n                    dp[i][j] = min(dp[i][j], rootVal + dp[i][k] + dp[k + 1][j])\\n        return dp[0][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992974,
                "title": "divide-and-conquer-with-explanation-short-fast-o-nlogn",
                "content": "Let say we have an inteval [s, e], and we already knew the max value and its position in this interval. The interval then can be divided into 3 parts:  left subtree, the max value, and the right subtree. To minimize the sum, we hope to reduce the level of the max value (i.e., put the max value close to root as much as possible.), because the higher position the max value is at, the less it will have chance to multiply with other values. And there wil be only two possible case shown in the following figure.\\n![image](https://assets.leetcode.com/users/images/6d37a675-8aa0-42e5-9f32-03c2fe009366_1609282911.2095585.png)\\nHowever, both of the cases have the same results, which is:\\n![image](https://assets.leetcode.com/users/images/94a0e4c7-fde3-4665-b1aa-6711558f3935_1609283107.0855892.png)\\nTherefore, all the steps are:\\n1. Find the max value and its position of the given interval.\\n2. Put left and right parts into recusive function to retrieve their max value and sum.\\n3. Calculate and return the sum using the formula above.\\nThe code:\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n     return divide(arr, 0, arr.length)[1];\\n    }\\n\\n    int[] divide(int[] arr, int s, int e) {\\n        if (s == e)\\n            return new int[]{0, 0};                \\n        if (e - s == 1)\\n            return new int[]{arr[s], 0};\\n        int mx = s;\\n        for (int i = s; i < e; i++)                \\n            mx = (arr[i] > arr[mx])? i: mx;\\n        int [] left = divide(arr, s, mx), right = divide(arr, mx+1, e);             \\n        return new int[]{arr[mx], left[1] + right[1] + arr[mx] * (left[0] + right[0])};\\n    }\\n}\\n```\\nComplexity: time = O(N*logN), space = O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n     return divide(arr, 0, arr.length)[1];\\n    }\\n\\n    int[] divide(int[] arr, int s, int e) {\\n        if (s == e)\\n            return new int[]{0, 0};                \\n        if (e - s == 1)\\n            return new int[]{arr[s], 0};\\n        int mx = s;\\n        for (int i = s; i < e; i++)                \\n            mx = (arr[i] > arr[mx])? i: mx;\\n        int [] left = divide(arr, s, mx), right = divide(arr, mx+1, e);             \\n        return new int[]{arr[mx], left[1] + right[1] + arr[mx] * (left[0] + right[0])};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971171,
                "title": "this-is-not-dp-c-with-time-o-n-and-space-o-n",
                "content": "```\\nint mctFromLeafValues(vector<int>& arr) {\\n\\tif (arr.size() == 2)\\n\\t\\treturn arr[0] * arr[1];\\n\\tint res = 0;\\n\\tvector<int> stack = { INT_MAX };\\n\\tfor (auto a : arr) {\\n\\t\\twhile (a >= stack.back()){\\n\\t\\t\\tint mid = stack.back();\\n\\t\\t\\tstack.pop_back();\\n\\t\\t\\tres += mid * min(a, stack.back());\\n\\t\\t}\\n\\t\\tstack.push_back(a);\\n\\t}\\n\\tfor (int i = 1; i < stack.size() - 1; i++) {\\n\\t\\tres += stack[i] * stack[i + 1];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint mctFromLeafValues(vector<int>& arr) {\\n\\tif (arr.size() == 2)\\n\\t\\treturn arr[0] * arr[1];\\n\\tint res = 0;\\n\\tvector<int> stack = { INT_MAX };\\n\\tfor (auto a : arr) {\\n\\t\\twhile (a >= stack.back()){\\n\\t\\t\\tint mid = stack.back();\\n\\t\\t\\tstack.pop_back();\\n\\t\\t\\tres += mid * min(a, stack.back());\\n\\t\\t}\\n\\t\\tstack.push_back(a);\\n\\t}\\n\\tfor (int i = 1; i < stack.size() - 1; i++) {\\n\\t\\tres += stack[i] * stack[i + 1];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917569,
                "title": "c-all-approaches-stack-greedy-and-dp",
                "content": "### Monotonic Stack solution (beats 100%):\\n```\\nint mono_stack(vector<int>& v) {\\n\\tint c=0;\\n\\tstack<int> st;\\n\\tfor(int i:v) {\\n\\t\\twhile(!st.empty() && st.top() <= i) {\\n\\t\\t\\tint x = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(),i);\\n\\t\\t}\\n\\t\\tst.push(i);\\n\\t}\\n\\tint a = st.top();\\n\\tst.pop();\\n\\twhile(!st.empty()) {\\n\\t\\tint x = st.top();\\n\\t\\tst.pop();\\n\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(), a);\\n\\t\\ta = x;\\n\\t}\\n\\treturn c;\\n}\\n```\\n### Greedy solution (beats ~50%):\\n```\\nint greedy(vector<int>& v) {\\n\\tint t = 0;\\n\\twhile(v.size() > 1) {\\n\\t\\tint in = min_element(v.begin(),v.end()) - v.begin();\\n\\t\\tt += min(in>=1 ? v[in-1] : INT_MAX, in<v.size()-1 ? v[in+1] : INT_MAX) * v[in];\\n\\t\\tv.erase(v.begin()+in);\\n\\t}\\n\\treturn t;\\n}\\n```\\n### Recursive approach (TLE):\\n```\\nint rec(vector<int>& v, int l, int r) {\\n\\tif(l==r) return 0;\\n\\tint mn = INT_MAX;\\n\\tfor(int i=l; i<r; i++) {\\n\\t\\tint x = rec(v,l,i);\\n\\t\\tint y = rec(v,i+1,r);\\n\\t\\tint t = x + y + *max_element(v.begin()+l,v.begin()+i+1) * *max_element(v.begin()+i+1, v.begin()+r+1);\\n\\t\\tmn = min(mn, t);\\n\\t}\\n\\treturn mn;\\n}\\n```\\n### DP solution (based on above approach; beats ~10%):\\n```\\nint dp(vector<int>& v) {\\n\\tint n = v.size();\\n\\tvector<vector<int>> dp(n,vector<int>(n,0));\\n\\tfor(int j=0; j<n; j++) {\\n\\t\\tfor(int i=j; i>-1; i--) {\\n\\t\\t\\tfor(int k=i; k<j; k++) {\\n\\t\\t\\t\\tint x = dp[i][k];\\n\\t\\t\\t\\tint y = dp[k+1][j];\\n\\t\\t\\t\\tint t = x + y + *max_element(v.begin()+i,v.begin()+k+1) * *max_element(v.begin()+k+1,v.begin()+j+1);\\n\\t\\t\\t\\tdp[i][j] = !dp[i][j] ? t : min(dp[i][j],t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n-1];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nint mono_stack(vector<int>& v) {\\n\\tint c=0;\\n\\tstack<int> st;\\n\\tfor(int i:v) {\\n\\t\\twhile(!st.empty() && st.top() <= i) {\\n\\t\\t\\tint x = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(),i);\\n\\t\\t}\\n\\t\\tst.push(i);\\n\\t}\\n\\tint a = st.top();\\n\\tst.pop();\\n\\twhile(!st.empty()) {\\n\\t\\tint x = st.top();\\n\\t\\tst.pop();\\n\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(), a);\\n\\t\\ta = x;\\n\\t}\\n\\treturn c;\\n}\\n```\n```\\nint greedy(vector<int>& v) {\\n\\tint t = 0;\\n\\twhile(v.size() > 1) {\\n\\t\\tint in = min_element(v.begin(),v.end()) - v.begin();\\n\\t\\tt += min(in>=1 ? v[in-1] : INT_MAX, in<v.size()-1 ? v[in+1] : INT_MAX) * v[in];\\n\\t\\tv.erase(v.begin()+in);\\n\\t}\\n\\treturn t;\\n}\\n```\n```\\nint rec(vector<int>& v, int l, int r) {\\n\\tif(l==r) return 0;\\n\\tint mn = INT_MAX;\\n\\tfor(int i=l; i<r; i++) {\\n\\t\\tint x = rec(v,l,i);\\n\\t\\tint y = rec(v,i+1,r);\\n\\t\\tint t = x + y + *max_element(v.begin()+l,v.begin()+i+1) * *max_element(v.begin()+i+1, v.begin()+r+1);\\n\\t\\tmn = min(mn, t);\\n\\t}\\n\\treturn mn;\\n}\\n```\n```\\nint dp(vector<int>& v) {\\n\\tint n = v.size();\\n\\tvector<vector<int>> dp(n,vector<int>(n,0));\\n\\tfor(int j=0; j<n; j++) {\\n\\t\\tfor(int i=j; i>-1; i--) {\\n\\t\\t\\tfor(int k=i; k<j; k++) {\\n\\t\\t\\t\\tint x = dp[i][k];\\n\\t\\t\\t\\tint y = dp[k+1][j];\\n\\t\\t\\t\\tint t = x + y + *max_element(v.begin()+i,v.begin()+k+1) * *max_element(v.begin()+k+1,v.begin()+j+1);\\n\\t\\t\\t\\tdp[i][j] = !dp[i][j] ? t : min(dp[i][j],t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 667294,
                "title": "python-concise-dp-bottom-up-top-down",
                "content": "Find best non-dp approch from @lee215  at [link](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\nTime: `O(N^3)`\\nSpace: `O(N^2)`\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[(0, 0)] * n for _ in range(n)] # (max_val, min_cost)\\n        \\'\\'\\'\\n        # memorization\\n        def helper(l, r):\\n            if dp[l][r][0] != 0: return dp[l][r]\\n            if l == r: return (arr[l], 0)\\n            max_val, min_cost = 0, float(\\'inf\\')\\n            for i in range(l, r):\\n                val_l, val_r = helper(l, i), helper(i+1, r)\\n                max_val = max(val_l[0], val_r[0])\\n                min_cost = min(min_cost, val_l[1] + val_r[1] + val_l[0]*val_r[0])\\n            dp[l][r] = (max_val, min_cost)\\n            return dp[l][r]\\n        return helper(0, n-1)[1]\\n        \\'\\'\\'\\n        # bottom up\\n        for size in range(n):\\n            for i in range(n-size):\\n                # [i, i+size]\\n                if size == 0:\\n                    dp[i][i+size] = (arr[i], 0)\\n                    continue\\n                max_val, min_cost = 0, float(\\'inf\\')\\n                for j in range(i, i+size):\\n                    max_val = max(dp[i][j][0], dp[j+1][i+size][0])\\n                    min_cost = min(min_cost, dp[i][j][1] + dp[j+1][i+size][1] + dp[i][j][0]*dp[j+1][i+size][0])\\n                dp[i][i+size] = (max_val, min_cost)\\n        return dp[0][n-1][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[(0, 0)] * n for _ in range(n)] # (max_val, min_cost)\\n        \\'\\'\\'\\n        # memorization\\n        def helper(l, r):\\n            if dp[l][r][0] != 0: return dp[l][r]\\n            if l == r: return (arr[l], 0)\\n            max_val, min_cost = 0, float(\\'inf\\')\\n            for i in range(l, r):\\n                val_l, val_r = helper(l, i), helper(i+1, r)\\n                max_val = max(val_l[0], val_r[0])\\n                min_cost = min(min_cost, val_l[1] + val_r[1] + val_l[0]*val_r[0])\\n            dp[l][r] = (max_val, min_cost)\\n            return dp[l][r]\\n        return helper(0, n-1)[1]\\n        \\'\\'\\'\\n        # bottom up\\n        for size in range(n):\\n            for i in range(n-size):\\n                # [i, i+size]\\n                if size == 0:\\n                    dp[i][i+size] = (arr[i], 0)\\n                    continue\\n                max_val, min_cost = 0, float(\\'inf\\')\\n                for j in range(i, i+size):\\n                    max_val = max(dp[i][j][0], dp[j+1][i+size][0])\\n                    min_cost = min(min_cost, dp[i][j][1] + dp[j+1][i+size][1] + dp[i][j][0]*dp[j+1][i+size][0])\\n                dp[i][i+size] = (max_val, min_cost)\\n        return dp[0][n-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520825,
                "title": "python3-a-greedy-algo",
                "content": "Algorithm (greedy): \\nPer @jadore801120 in this [thread](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution), recursively locste the minimum element and \"combine\" it with its smaller neighbor. \\n\\nImplementation (20ms, 99.43):\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0\\n        while len(arr) > 1: \\n            i = arr.index(min(arr))\\n            ans += arr.pop(i)*min(arr[max(0,i-1):i+1])\\n        return ans\\n```\\n\\nAnalysis:\\nTime complexity `O(N^2)`\\nSpace complexity `O(1)`\\n\\nIn contrast, dp runs a lot slower than the above greedy algo\\n\\n(260ms, 26.11%): \\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i, j): \\n            \"\"\"Return \"\"\"\\n            if i+1 == j: return 0\\n            return min(max(arr[i:k])*max(arr[k:j]) + dp(i, k) + dp(k, j) for k in range(i+1, j))\\n        \\n        return dp(0, len(arr))\\n```\\n\\nEdited on 4/20/2021\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0 \\n        stack = []\\n        for x in arr: \\n            while stack and stack[-1] <= x: \\n                val = stack.pop()\\n                ans += val * min(stack[-1] if stack else inf, x)\\n            stack.append(x)\\n        return ans + sum(stack[i-1]*stack[i] for i in range(1, len(stack)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0\\n        while len(arr) > 1: \\n            i = arr.index(min(arr))\\n            ans += arr.pop(i)*min(arr[max(0,i-1):i+1])\\n        return ans\\n```\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i, j): \\n            \"\"\"Return \"\"\"\\n            if i+1 == j: return 0\\n            return min(max(arr[i:k])*max(arr[k:j]) + dp(i, k) + dp(k, j) for k in range(i+1, j))\\n        \\n        return dp(0, len(arr))\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0 \\n        stack = []\\n        for x in arr: \\n            while stack and stack[-1] <= x: \\n                val = stack.pop()\\n                ans += val * min(stack[-1] if stack else inf, x)\\n            stack.append(x)\\n        return ans + sum(stack[i-1]*stack[i] for i in range(1, len(stack)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385823,
                "title": "1130-minimum-cost-tree-from-leaf-values-javascript-48ms",
                "content": "```js\\nvar mctFromLeafValues = function(arr) {\\n    let sum = 0;\\n    while(arr.length !== 1){\\n        let min = Number.MAX_SAFE_INTEGER;\\n        let cur = 0;\\n        for(let i = 0; i < arr.length - 1; i++){\\n            let product = arr[i] * arr[i + 1];\\n            if(product < min){\\n                min = product;\\n                cur = i;\\n            }\\n        }\\n        sum += min;\\n        let maxInPair = Math.max(arr[cur], arr[cur + 1]);\\n        arr.splice(cur, 2, maxInPair)\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar mctFromLeafValues = function(arr) {\\n    let sum = 0;\\n    while(arr.length !== 1){\\n        let min = Number.MAX_SAFE_INTEGER;\\n        let cur = 0;\\n        for(let i = 0; i < arr.length - 1; i++){\\n            let product = arr[i] * arr[i + 1];\\n            if(product < min){\\n                min = product;\\n                cur = i;\\n            }\\n        }\\n        sum += min;\\n        let maxInPair = Math.max(arr[cur], arr[cur + 1]);\\n        arr.splice(cur, 2, maxInPair)\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599541,
                "title": "c-simple-dp-clever-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[40][40]={0};\\n    int solve(vector<int> arr,int start,int end)\\n    {\\n        if(start==end)\\n            return 0;\\n        if(dp[start][end]!=0)\\n            return dp[start][end];\\n        int mn=INT_MAX;\\n        for(int i=start;i<=end-1;i++)\\n        {\\n            int left=solve(arr,start,i);\\n            int right=solve(arr,i+1,end);\\n            int temp=left+right+*max_element(arr.begin()+start,arr.begin()+i+1) * *max_element(arr.begin()+i+1,arr.begin()+end+1);\\n            mn=min(mn,temp);\\n            \\n        }\\n        return dp[start][end]=mn;\\n    }\\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        return solve(arr,0,arr.size()-1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[40][40]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2327793,
                "title": "c-memoization-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int fun(int i, int j, vector<int>& arr){\\n        if(i == j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        \\n        int ans = INT_MAX;\\n        for(int k = i; k < j; k++){\\n            \\n            int lm = 0 , rm = 0;\\n            \\n            for(int x = i; x <= k; x++)\\n                lm = max(lm,arr[x]);\\n            \\n            for(int x = k+1; x <= j; x++)\\n                rm = max(rm,arr[x]);\\n            \\n            ans = min(ans, fun(i,k,arr) + fun(k+1,j,arr) + (lm*rm));\\n        }\\n        \\n        return dp[i][j] = ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        dp = vector<vector<int>> (n, vector<int>(n , -1));\\n        return fun(0,n-1,arr);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int fun(int i, int j, vector<int>& arr){\\n        if(i == j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        \\n        int ans = INT_MAX;\\n        for(int k = i; k < j; k++){\\n            \\n            int lm = 0 , rm = 0;\\n            \\n            for(int x = i; x <= k; x++)\\n                lm = max(lm,arr[x]);\\n            \\n            for(int x = k+1; x <= j; x++)\\n                rm = max(rm,arr[x]);\\n            \\n            ans = min(ans, fun(i,k,arr) + fun(k+1,j,arr) + (lm*rm));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2246028,
                "title": "mcm-c-aditya-verma-template-mcm-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[50][50];\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int  n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return mcm(arr, 0, n-1);\\n        \\n    }\\n    \\n    long long mcm(vector<int>& arr, int i, int j){\\n        \\n        if(i>=j)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        long ans = 1e12;\\n        \\n        for(int k = i; k<j ; k++){\\n            \\n            long c = mcm(arr,i,k) + mcm(arr,k+1,j);\\n            \\n            int a = arr[i];\\n            int b = arr[j];\\n            \\n            for(int p = i; p<=k ; p++)a = max(a,arr[p]);\\n            for(int p = k+1; p<=j; p++)b= max(b, arr[p]);\\n                        \\n            ans = min(ans, c + a*b);\\n        }\\n        \\n        return dp[i][j] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[50][50];\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int  n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return mcm(arr, 0, n-1);\\n        \\n    }\\n    \\n    long long mcm(vector<int>& arr, int i, int j){\\n        \\n        if(i>=j)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        long ans = 1e12;\\n        \\n        for(int k = i; k<j ; k++){\\n            \\n            long c = mcm(arr,i,k) + mcm(arr,k+1,j);\\n            \\n            int a = arr[i];\\n            int b = arr[j];\\n            \\n            for(int p = i; p<=k ; p++)a = max(a,arr[p]);\\n            for(int p = k+1; p<=j; p++)b= max(b, arr[p]);\\n                        \\n            ans = min(ans, c + a*b);\\n        }\\n        \\n        return dp[i][j] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113819,
                "title": "c-easy-dp-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tint dp[41][41];\\n\\tint maxi[41][41];\\n\\n\\tint solve(int left, int right) {\\n\\t\\t//leaf node\\n\\t\\tif (left == right) return 0;\\n\\t\\tif (dp[left][right] != -1) return dp[left][right];\\n\\n\\t\\tint ans = INT_MAX;\\n\\n\\t\\t// divide into 2 parts\\n\\t\\tfor (int i = left; i < right; ++i) {\\n\\t\\t\\tans = min(ans, maxi[left][i] * maxi[i + 1][right] + solve(left, i) + solve(i + 1, right));\\n\\t\\t}\\n\\t\\treturn dp[left][right] = ans;\\n\\t}\\npublic:\\n\\tint mctFromLeafValues(vector<int>& a) {\\n\\t\\tint n = a.size();\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\n\\t\\t//calculate max till j maxi[i][j] = max from i to j\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tmaxi[i][i] = a[i];\\n\\t\\t\\tfor (int j = i + 1; j < n; ++j) {\\n\\t\\t\\t\\tmaxi[i][j] = max(maxi[i][j - 1], a[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn solve(0, n - 1);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tint dp[41][41];\\n\\tint maxi[41][41];\\n\\n\\tint solve(int left, int right) {\\n\\t\\t//leaf node\\n\\t\\tif (left == right) return 0;\\n\\t\\tif (dp[left][right] != -1) return dp[left][right];\\n\\n\\t\\tint ans = INT_MAX;\\n\\n\\t\\t// divide into 2 parts\\n\\t\\tfor (int i = left; i < right; ++i) {\\n\\t\\t\\tans = min(ans, maxi[left][i] * maxi[i + 1][right] + solve(left, i) + solve(i + 1, right));\\n\\t\\t}\\n\\t\\treturn dp[left][right] = ans;\\n\\t}\\npublic:\\n\\tint mctFromLeafValues(vector<int>& a) {\\n\\t\\tint n = a.size();\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\n\\t\\t//calculate max till j maxi[i][j] = max from i to j\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tmaxi[i][i] = a[i];\\n\\t\\t\\tfor (int j = i + 1; j < n; ++j) {\\n\\t\\t\\t\\tmaxi[i][j] = max(maxi[i][j - 1], a[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn solve(0, n - 1);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036590,
                "title": "optimized-c-code-single-while-loop-78-time-72-memory",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int ans = 0, i = 0;\\n        int min_val = INT_MAX, idx;\\n        while(i < arr.size()-1 && arr.size() != 2)\\n        {\\n            if(arr[i]*arr[i+1] < min_val)\\n            {\\n                idx = i;\\n                min_val = arr[i]*arr[i+1];\\n            }\\n            if(i == arr.size()-2)\\n            {\\n                ans += min_val;\\n                min_val = INT_MAX;\\n                if(arr[idx] > arr[idx+1])\\n                    arr.erase(arr.begin()+(idx+1));\\n                else\\n                    arr.erase(arr.begin()+idx);\\n                i = -1;\\n            }\\n            i++;\\n        }\\n        ans += arr[0]*arr[1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int ans = 0, i = 0;\\n        int min_val = INT_MAX, idx;\\n        while(i < arr.size()-1 && arr.size() != 2)\\n        {\\n            if(arr[i]*arr[i+1] < min_val)\\n            {\\n                idx = i;\\n                min_val = arr[i]*arr[i+1];\\n            }\\n            if(i == arr.size()-2)\\n            {\\n                ans += min_val;\\n                min_val = INT_MAX;\\n                if(arr[idx] > arr[idx+1])\\n                    arr.erase(arr.begin()+(idx+1));\\n                else\\n                    arr.erase(arr.begin()+idx);\\n                i = -1;\\n            }\\n            i++;\\n        }\\n        ans += arr[0]*arr[1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603827,
                "title": "80-fast",
                "content": "class Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size(),ans=0;\\n        \\n        pair<int,int> dp[n][n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<n-i;j++){\\n                \\n                int r=j,c=j+i;\\n                // cout<<r<<\" \"<<c<<endl;\\n                \\n                if(r==c){\\n                    dp[r][c]={0,arr[r]};\\n                }else{\\n                    dp[r][c]={INT_MAX,0};\\n                    for(int k=r;k<c;k++){\\n                        \\n                        int lm=dp[r][k].second,rm=dp[k+1][c].second;\\n                        int sum=dp[r][k].first+dp[k+1][c].first+lm*rm;\\n                        \\n                        if(sum<dp[r][c].first){\\n                            dp[r][c]={sum,max(lm,rm)};\\n                        }\\n                        \\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n//         for(int i=0;i<n;i++){\\n            \\n//             for(int j=0;j<n-i;j++){\\n                \\n//                 int r=j,c=j+i;\\n                \\n//                 cout<<dp[r][c].first<<\" \"<<dp[r][c].second<<endl;\\n                \\n//             }\\n//         }\\n        \\n        return dp[0][n-1].first;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size(),ans=0;\\n        \\n        pair<int,int> dp[n][n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<n-i;j++){\\n                \\n                int r=j,c=j+i;\\n                // cout<<r<<\" \"<<c<<endl;\\n                \\n                if(r==c){\\n                    dp[r][c]={0,arr[r]}",
                "codeTag": "C++"
            },
            {
                "id": 1430060,
                "title": "c-0-ms-faster-than-100-monostack",
                "content": "Since the non-leaf node value is the product of previous largest leaf and new leaf, the problem can be considered as a monostack problem.\\nIn order to find PGE (Previous Greater Element), the stack should be monotonous decreasing stack.\\n\\nFor the example: [6,2,7,8]\\n\\n|stack | push | pop | ans|\\n|--|--|--|--|\\nnull    | 6       | null | 0\\n6       | 2        | null | 0\\n6, 2     | 7        | 2, 6 | ans += 2 * 6 + 6 * 7\\n7       | 8        | 7     | ans += 7 * 8\\n8       | null     | 8 \\n\\nans = 110\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size(), ans = 0;;\\n        vector<int> st;\\n        for (int i = 0; i < n; ++i) {\\n            int leaf = 0;\\n            while(!st.empty() && st.back() < arr[i]) {\\n                ans += leaf * st.back();\\n                leaf = st.back(); st.pop_back();\\n            }\\n            ans += leaf * arr[i];\\n            st.push_back(arr[i]);\\n        }\\n        for(int i = 0; i < st.size() - 1; ++i) {\\n            ans += st[i] * st[i + 1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size(), ans = 0;;\\n        vector<int> st;\\n        for (int i = 0; i < n; ++i) {\\n            int leaf = 0;\\n            while(!st.empty() && st.back() < arr[i]) {\\n                ans += leaf * st.back();\\n                leaf = st.back(); st.pop_back();\\n            }\\n            ans += leaf * arr[i];\\n            st.push_back(arr[i]);\\n        }\\n        for(int i = 0; i < st.size() - 1; ++i) {\\n            ans += st[i] * st[i + 1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356573,
                "title": "python-dp-solution-using-matrix-chain-multiplication-template",
                "content": "Our formula is that of matrix chain multiplication:\\n\\n```python\\ndp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j]))\\n```\\n\\nNow, in this we go diagonal wise. We move towards top right corner from the center diagonal.\\n\\nWe use `l` to denote the level, `l=0` being the center diagonal. Then `i` would lie in `[0, n-l)` and `j` would be `i+l`.\\n\\n```python\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n    n = len(arr)\\n    \\n    dp = [[0 for j in range(n)] for i in range(n)]\\n    \\n    maxA = [[0 for j in range(n)] for i in range(n)]\\n    \\n    for i in range(n):\\n        maxA[i][i] = arr[i]\\n        \\n    for i in range(n):\\n        for j in range(i+1, n):\\n            maxA[i][j] = max(maxA[i][j-1], arr[j])\\n            \\n\\n    for l in range(1, n):\\n        for i in range(n - l):\\n            j = i + l\\n            for k in range(i, j):\\n                if dp[i][j] == 0:\\n                    dp[i][j] = dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j])\\n                else:\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j]))\\n                                   \\n    return dp[0][n-1]\\n```\\n\\nO(n ^ 3) time and O(n ^ 2) space",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\ndp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j]))\\n```\n```python\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n    n = len(arr)\\n    \\n    dp = [[0 for j in range(n)] for i in range(n)]\\n    \\n    maxA = [[0 for j in range(n)] for i in range(n)]\\n    \\n    for i in range(n):\\n        maxA[i][i] = arr[i]\\n        \\n    for i in range(n):\\n        for j in range(i+1, n):\\n            maxA[i][j] = max(maxA[i][j-1], arr[j])\\n            \\n\\n    for l in range(1, n):\\n        for i in range(n - l):\\n            j = i + l\\n            for k in range(i, j):\\n                if dp[i][j] == 0:\\n                    dp[i][j] = dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j])\\n                else:\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j]))\\n                                   \\n    return dp[0][n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1051912,
                "title": "simple-and-easy-understanding-in-java",
                "content": "```\\nclass Solution {\\n       public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n       \\n        List<Integer> l=new ArrayList<>();\\n        for(int x:A)l.add(x);\\n           \\n        boolean isCleaned=false;\\n        while(!isCleaned){\\n            \\n            int min=Integer.MAX_VALUE;\\n            int minLeg1index=0;\\n            int minLeg2index=0;\\n            \\n            for(int i=1; i<l.size(); i++){\\n               if(min>l.get(i-1)*l.get(i)){\\n                   min=l.get(i-1)*l.get(i);\\n                   minLeg1index=i-1;\\n                   minLeg2index=i;\\n               }\\n             }\\n            \\n            if(l.get(minLeg1index)>l.get(minLeg2index))\\n                l.remove(minLeg2index);\\n            else \\n                l.remove(minLeg1index);\\n            \\n            if(l.size()<2)\\n                isCleaned=true;\\n            \\n         res+=min;\\n        }   \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n       \\n        List<Integer> l=new ArrayList<>();\\n        for(int x:A)l.add(x);\\n           \\n        boolean isCleaned=false;\\n        while(!isCleaned){\\n            \\n            int min=Integer.MAX_VALUE;\\n            int minLeg1index=0;\\n            int minLeg2index=0;\\n            \\n            for(int i=1; i<l.size(); i++){\\n               if(min>l.get(i-1)*l.get(i)){\\n                   min=l.get(i-1)*l.get(i);\\n                   minLeg1index=i-1;\\n                   minLeg2index=i;\\n               }\\n             }\\n            \\n            if(l.get(minLeg1index)>l.get(minLeg2index))\\n                l.remove(minLeg2index);\\n            else \\n                l.remove(minLeg1index);\\n            \\n            if(l.size()<2)\\n                isCleaned=true;\\n            \\n         res+=min;\\n        }   \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050470,
                "title": "one-pass-stack-without-pushing-extra-max-value",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for (int a : A) {\\n            while (!stack.isEmpty() && stack.peek() <= a) {\\n                int mid = stack.pop();\\n                if (stack.isEmpty()) res += mid * a;\\n                else res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 1) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nModify from lee215\\'s solution, I understand the solution most part except the Maximum value part, in the comment section he noted that the reason why we push max value at the beging of the stack is bacause we want make sure the stack is not empty, which I couldn\\'t make sense at the time.\\n\\nAfter did some scruitiny, I realize that since under condition like [6,2,5] (in the code: a = 5, stack [6, 2]), we need chose the smaller one between 6 and 5, this only happens if the stack has at least 2 value, if it\\'s only contains one element, then we need count that as one non-leaf node as well",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for (int a : A) {\\n            while (!stack.isEmpty() && stack.peek() <= a) {\\n                int mid = stack.pop();\\n                if (stack.isEmpty()) res += mid * a;\\n                else res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 1) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945607,
                "title": "c-with-comments",
                "content": "we need to understand what are trying to solve here.\\n\\nthe goal is to understand if we want to take the left sub tree or the right sub tree.\\nit sounds like dp problem. but dp on what... it was hard for me to understand so I started with recurssion.\\n\\nso we take left or right subtree.. so i create a helper function as always for i to j...\\nand compute ... left and right. now we can see that we need to understand do we want to take the maximal leaf or we don\\'t\\nif we take it we will have a big sub tree, so we are not going to take the maximal value and we take the next one.\\n\\n```\\npublic class Solution {\\n    private int _sum = 0;\\n    public int MctFromLeafValues(int[] arr) {\\n       Helper(arr, 0, arr.Length-1);\\n       return _sum;       \\n    }\\n```\\n    \\n    private int Helper(int[] arr, int s, int e)\\n    {\\n       if(s > e)\\n       {\\n          return 0; \\n       }\\n       if(s==e)\\n       {\\n           return arr[s];\\n       }\\n       int max = s;\\n       for(int i = s + 1; i <= e; i++)\\n       {\\n           if(arr[i] > arr[max])\\n           {\\n               max = i;\\n           }\\n       }\\n        int left = Helper(arr, s, max-1);\\n        int right = Helper(arr,max+1, e);\\n        \\n        _sum += arr[max] * (left+right);\\n        return arr[max];\\n     }\\n    }\\n\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    private int _sum = 0;\\n    public int MctFromLeafValues(int[] arr) {\\n       Helper(arr, 0, arr.Length-1);\\n       return _sum;       \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820160,
                "title": "recursive-top-down-memoized-dp-explained",
                "content": "\\n\\n> Approach\\n \\n1. You might have noted that there are possiblly many ways to merge. \\n2. So we try all of them, and memoize them.\\n3. We go `top down` since it is more intuitive .\\n4. While going top down we try to merge all possible.\\n5. We merge `a[st......i]` and `a[i+1.......en-1]`, for all `st <=  i  <= en-1`  and select the maximum of them.\\n\\n\\n> Algorithm\\n\\n\\n```\\n\\n// memoization table\\nvector<vector<pair<int, int>>> dp;\\n    \\n\\t// function returns a pair \\n    // {cost, max-leaf}\\n    pair<int, int> go(int st, int en, vector<int> &a) {\\n        if(st == en) {\\n            // on a leaf node, so cost = 0, max leaf = this node\\'s value\\n\\t\\t\\treturn {0, a[st]};\\n        }\\n        \\n\\t\\t// memoized solution\\n        if(dp[st][en].first != -1) {\\n\\t\\t\\treturn dp[st][en];\\n        }\\n        \\n        int ans = INT_MAX, maxLeaf;\\n        \\n        for(int i=st; i<en; i++) {\\n\\t\\t\\t// left subtree [st....i] \\n            auto p = go(st, i, a);\\n\\t\\t\\t// right subtrees [i+1....en]\\n\\t\\t\\tauto q = go(i+1, en, a);\\n\\t\\t\\t\\n            // we merge to left and right subtrees \\n\\t\\t\\t// left ans + right ans + (max-leaft left * max-leaf right)\\n            int temp = p.first + q.first + p.second * q.second;\\n            \\n            if(temp < ans) {\\n\\t\\t\\t\\t// update the answer \\n                ans = temp;\\n                maxLeaf = max(p.second, q.second);\\n            } else if(temp == ans) {\\n               // if max-leaf can be reduced \\n\\t\\t\\t   maxLeaf = min(maxLeaf, max(p.second, q.second));\\n            }\\n        }\\n        \\n\\t\\t// return, store ans \\n        return dp[st][en] = {ans, maxLeaf};\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& a) {\\n        int n = a.size();\\n        dp.assign(n, vector<pair<int, int>>(n, {-1,-1}));\\n        return go(0, n-1, a).first;\\n    }\\n\\t\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\n// memoization table\\nvector<vector<pair<int, int>>> dp;\\n    \\n\\t// function returns a pair \\n    // {cost, max-leaf}\\n    pair<int, int> go(int st, int en, vector<int> &a) {\\n        if(st == en) {\\n            // on a leaf node, so cost = 0, max leaf = this node\\'s value\\n\\t\\t\\treturn {0, a[st]};\\n        }\\n        \\n\\t\\t// memoized solution\\n        if(dp[st][en].first != -1) {\\n\\t\\t\\treturn dp[st][en];\\n        }\\n        \\n        int ans = INT_MAX, maxLeaf;\\n        \\n        for(int i=st; i<en; i++) {\\n\\t\\t\\t// left subtree [st....i] \\n            auto p = go(st, i, a);\\n\\t\\t\\t// right subtrees [i+1....en]\\n\\t\\t\\tauto q = go(i+1, en, a);\\n\\t\\t\\t\\n            // we merge to left and right subtrees \\n\\t\\t\\t// left ans + right ans + (max-leaft left * max-leaf right)\\n            int temp = p.first + q.first + p.second * q.second;\\n            \\n            if(temp < ans) {\\n\\t\\t\\t\\t// update the answer \\n                ans = temp;\\n                maxLeaf = max(p.second, q.second);\\n            } else if(temp == ans) {\\n               // if max-leaf can be reduced \\n\\t\\t\\t   maxLeaf = min(maxLeaf, max(p.second, q.second));\\n            }\\n        }\\n        \\n\\t\\t// return, store ans \\n        return dp[st][en] = {ans, maxLeaf};\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& a) {\\n        int n = a.size();\\n        dp.assign(n, vector<pair<int, int>>(n, {-1,-1}));\\n        return go(0, n-1, a).first;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 595269,
                "title": "c-0ms-solution-using-stack",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mctFromLeafValues(vector<int>& arr) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tst.push(INT_MAX);\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<arr.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile(arr[i]>st.top())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint temp=st.top();\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tans+=temp*min(arr[i],st.top());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push(arr[i]);\\n\\t\\t\\t}\\n\\t\\t\\twhile(st.size()>=3)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint cur=st.top();\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tans+=cur*st.top();\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint mctFromLeafValues(vector<int>& arr) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tst.push(INT_MAX);\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<arr.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile(arr[i]>st.top())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint temp=st.top();\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tans+=temp*min(arr[i],st.top());\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 510117,
                "title": "python3-sol-stack",
                "content": "```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        stack = [float(\\'inf\\')]\\n        for currNum in arr:\\n            while stack[-1] <= currNum:\\n                drop = stack.pop()\\n                res += min(drop * currNum, drop * stack[-1])\\n            stack.append(currNum)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n\\t\\t\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            minVal = min(arr)\\n            min_index = arr.index(minVal)\\n            if 0 < min_index < len(arr) - 1:\\n                res += min(minVal * arr[min_index - 1], minVal * arr[min_index + 1])\\n            else:\\n                if min_index == 0:\\n                    res += minVal * arr[min_index + 1]\\n                else:\\n                    res += minVal * arr[min_index - 1]\\n            arr.pop(min_index)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        stack = [float(\\'inf\\')]\\n        for currNum in arr:\\n            while stack[-1] <= currNum:\\n                drop = stack.pop()\\n                res += min(drop * currNum, drop * stack[-1])\\n            stack.append(currNum)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n\\t\\t\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            minVal = min(arr)\\n            min_index = arr.index(minVal)\\n            if 0 < min_index < len(arr) - 1:\\n                res += min(minVal * arr[min_index - 1], minVal * arr[min_index + 1])\\n            else:\\n                if min_index == 0:\\n                    res += minVal * arr[min_index + 1]\\n                else:\\n                    res += minVal * arr[min_index - 1]\\n            arr.pop(min_index)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 471276,
                "title": "simple-c-2d-dp-solution",
                "content": "```\\n/*\\n    https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/\\n    \\n    The idea is to keep track of min inner sum of nodes that can be formed by each subarray range.\\n    TC: O(N^3)\\n    SC: O(N^2)\\n    \\n*/\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        const int N = arr.size();\\n        // max_leaf(i, j): max value leaf node in [i:j]\\n        vector<vector<int> > max_leaf(N, vector<int>(N, 0));\\n        // inner_node(i, j): min sum of inner node possible in [i:j]\\n        vector<vector<int> > inner_node(N, vector<int>(N, INT_MAX));\\n        \\n        for(int i = 0; i < N; i++)\\n            max_leaf[i][i] = arr[i];\\n        \\n        for(int l = 0; l < N; l++) {\\n            for(int start_idx = 0; start_idx < N - l; start_idx++) {\\n                int end_idx = start_idx + l;\\n                \\n                for(int k = start_idx; k < end_idx; k++) {\\n                    // update the max leaf node\\n                    max_leaf[start_idx][end_idx] = max(max_leaf[start_idx][k], max_leaf[k+1][end_idx]);\\n                    // find the inner sum for the current k\\n                    int left_subtree = inner_node[start_idx][k] == INT_MAX ? 0 : inner_node[start_idx][k];\\n                    int right_subtree = inner_node[k+1][end_idx] == INT_MAX ? 0 : inner_node[k+1][end_idx];\\n                    int curr_inner_sum =  left_subtree +  right_subtree + \\n                                           max_leaf[start_idx][k] * max_leaf[k+1][end_idx];\\n                    inner_node[start_idx][end_idx] = min(inner_node[start_idx][end_idx], \\n                                        curr_inner_sum);\\n                }\\n            }\\n        }\\n        \\n        //for(auto v:inner_node){for(auto a: v)cout<<a<<\" \";cout<<endl;}\\n        return inner_node[0][N-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/\\n    \\n    The idea is to keep track of min inner sum of nodes that can be formed by each subarray range.\\n    TC: O(N^3)\\n    SC: O(N^2)\\n    \\n*/\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        const int N = arr.size();\\n        // max_leaf(i, j): max value leaf node in [i:j]\\n        vector<vector<int> > max_leaf(N, vector<int>(N, 0));\\n        // inner_node(i, j): min sum of inner node possible in [i:j]\\n        vector<vector<int> > inner_node(N, vector<int>(N, INT_MAX));\\n        \\n        for(int i = 0; i < N; i++)\\n            max_leaf[i][i] = arr[i];\\n        \\n        for(int l = 0; l < N; l++) {\\n            for(int start_idx = 0; start_idx < N - l; start_idx++) {\\n                int end_idx = start_idx + l;\\n                \\n                for(int k = start_idx; k < end_idx; k++) {\\n                    // update the max leaf node\\n                    max_leaf[start_idx][end_idx] = max(max_leaf[start_idx][k], max_leaf[k+1][end_idx]);\\n                    // find the inner sum for the current k\\n                    int left_subtree = inner_node[start_idx][k] == INT_MAX ? 0 : inner_node[start_idx][k];\\n                    int right_subtree = inner_node[k+1][end_idx] == INT_MAX ? 0 : inner_node[k+1][end_idx];\\n                    int curr_inner_sum =  left_subtree +  right_subtree + \\n                                           max_leaf[start_idx][k] * max_leaf[k+1][end_idx];\\n                    inner_node[start_idx][end_idx] = min(inner_node[start_idx][end_idx], \\n                                        curr_inner_sum);\\n                }\\n            }\\n        }\\n        \\n        //for(auto v:inner_node){for(auto a: v)cout<<a<<\" \";cout<<endl;}\\n        return inner_node[0][N-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 452273,
                "title": "c-easy-to-read",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res=0;\\n        stack<int>stack;\\n        stack.push(INT_MAX);       //push a INT_MAX to ensure having a value int the stack\\'s bottom ;\\n\\t\\t\\n\\t\\t/*for example, we have a vector{1,2,3,4,5};\\n\\t\\tint the code below , we have result=1*2+2*3+3*4+4*5, minmum!\\n\\t\\tyou can try to draw that tree like:\\n\\t\\t                              20\\n\\t\\t                 12                      5 \\n\\t\\t          6              4\\n\\t\\t    2          3\\n\\t\\t1     2\\n\\t\\t*/\\n        for(int i: arr){\\n            while(i>=stack.top()){\\n                int temp=stack.top();\\n                stack.pop();\\n                res+=temp*min(stack.top(),i);\\n            }\\n            stack.push(i);\\n            \\n        }\\n        \\n\\t\\t\\n\\t\\t/* but for the case{5,4,3,2,1}?\\n\\t\\twe have every value pushed into the stack :\\n\\t\\t1\\n\\t\\t2\\n\\t\\t3\\n\\t\\t4\\n\\t\\t5\\n\\t\\t*/\\n\\t\\t/* by the code below,\\n\\t\\twe can directly draw the tree;\\n\\t\\t*/\\n        while(stack.size()!=2){\\n            int temp=stack.top();\\n            stack.pop();\\n            res+=temp*stack.top();\\n        }\\n\\t\\t\\n\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res=0;\\n        stack<int>stack;\\n        stack.push(INT_MAX);       //push a INT_MAX to ensure having a value int the stack\\'s bottom ;\\n\\t\\t\\n\\t\\t/*for example, we have a vector{1,2,3,4,5};\\n\\t\\tint the code below , we have result=1*2+2*3+3*4+4*5, minmum!\\n\\t\\tyou can try to draw that tree like:\\n\\t\\t                              20\\n\\t\\t                 12                      5 \\n\\t\\t          6              4\\n\\t\\t    2          3\\n\\t\\t1     2\\n\\t\\t*/\\n        for(int i: arr){\\n            while(i>=stack.top()){\\n                int temp=stack.top();\\n                stack.pop();\\n                res+=temp*min(stack.top(),i);\\n            }\\n            stack.push(i);\\n            \\n        }\\n        \\n\\t\\t\\n\\t\\t/* but for the case{5,4,3,2,1}?\\n\\t\\twe have every value pushed into the stack :\\n\\t\\t1\\n\\t\\t2\\n\\t\\t3\\n\\t\\t4\\n\\t\\t5\\n\\t\\t*/\\n\\t\\t/* by the code below,\\n\\t\\twe can directly draw the tree;\\n\\t\\t*/\\n        while(stack.size()!=2){\\n            int temp=stack.top();\\n            stack.pop();\\n            res+=temp*stack.top();\\n        }\\n\\t\\t\\n\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418518,
                "title": "java-top-down-dp",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        int[][] maxx =  new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            maxx[i][i] = arr[i];\\n            for (int j = i + 1; j < n; j++) {\\n                maxx[i][j] = Math.max(arr[j], maxx[i][j - 1]);\\n            }\\n        }\\n        Integer[][] memo = new Integer[n][n];\\n        return helper(0, n - 1, arr, memo, maxx);\\n    }\\n    int helper(int start, int end, int[] arr, Integer[][] memo, int[][] maxx) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n        if (memo[start][end] != null) {\\n            return memo[start][end];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int i = start; i < end; i++) {\\n            res = Math.min(res, maxx[start][i] * maxx[i + 1][end] + helper(start, i, arr, memo, maxx) + helper(i + 1, end, arr, memo, maxx));\\n        } \\n        memo[start][end] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        int[][] maxx =  new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            maxx[i][i] = arr[i];\\n            for (int j = i + 1; j < n; j++) {\\n                maxx[i][j] = Math.max(arr[j], maxx[i][j - 1]);\\n            }\\n        }\\n        Integer[][] memo = new Integer[n][n];\\n        return helper(0, n - 1, arr, memo, maxx);\\n    }\\n    int helper(int start, int end, int[] arr, Integer[][] memo, int[][] maxx) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n        if (memo[start][end] != null) {\\n            return memo[start][end];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int i = start; i < end; i++) {\\n            res = Math.min(res, maxx[start][i] * maxx[i + 1][end] + helper(start, i, arr, memo, maxx) + helper(i + 1, end, arr, memo, maxx));\\n        } \\n        memo[start][end] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384899,
                "title": "greedy-java",
                "content": "peek the smallest product everytime, and delete the smaller number\\n\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int res = 0;\\n        List<Integer> nums = new ArrayList<>();\\n        for (int a : arr) nums.add(a);\\n        while (nums.size() > 1) { \\n            int min = Integer.MAX_VALUE, l = 0, r = 0;\\n            for (int i = 1; i < nums.size(); i++) {\\n                if (nums.get(i) * nums.get(i - 1) < min) {\\n                    min = nums.get(i) * nums.get(i - 1);\\n                    l = i - 1;\\n                    r = i;\\n                }\\n            }\\n            res += min;\\n            if (nums.get(l) > nums.get(r)) nums.remove(r);\\n            else nums.remove(l);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int res = 0;\\n        List<Integer> nums = new ArrayList<>();\\n        for (int a : arr) nums.add(a);\\n        while (nums.size() > 1) { \\n            int min = Integer.MAX_VALUE, l = 0, r = 0;\\n            for (int i = 1; i < nums.size(); i++) {\\n                if (nums.get(i) * nums.get(i - 1) < min) {\\n                    min = nums.get(i) * nums.get(i - 1);\\n                    l = i - 1;\\n                    r = i;\\n                }\\n            }\\n            res += min;\\n            if (nums.get(l) > nums.get(r)) nums.remove(r);\\n            else nums.remove(l);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799978,
                "title": "c-top-down-dp-solution",
                "content": "\\n# PLS UPVOTE MY SOLUTION IF YOU UNDERSTAND IT\\n# Approach\\nThe main function mctFromLeafValues(arr) takes a vector arr representing the leaf values of a binary search tree as input and returns the minimum cost to construct the binary search tree.\\n\\nThe helper function solve(arr, maxi, dp, left, right) takes several parameters:\\n\\narr: The input vector containing leaf values.\\nmaxi: A map (map<pair<int,int>,int>) that stores the maximum leaf value within each subarray. The key of the map is a pair of indices (left and right) representing the range, and the value is the maximum leaf value within that range.\\ndp: A 2D vector used for memoization. It stores the minimum cost for each range left to right.\\nleft and right: Represent the current range of leaf values to consider.\\nIn the helper function solve, it first checks for the base case:\\n\\nIf left == right, it means the range has only one leaf value, so no cost is needed, and the function returns 0.\\nIf the result for the current range left to right is already calculated and stored in the dp vector (i.e., dp[left][right] != -1), the function directly returns the result from the memoization table to avoid redundant computations.\\n\\nInitialize ans to INT_MAX, which will be used to store the minimum cost for the current range left to right.\\n\\nIterate from i = left to i < right, considering each position i as a candidate root. Calculate the cost for the candidate root and find the maximum cost between the left and right subtrees.\\n\\nCalculate the cost for the candidate root as maxi[{left,i}]*maxi[{i+1,right}] + solve(arr, maxi, dp, left, i) + solve(arr, maxi, dp, i + 1, right):\\n\\nmaxi[{left, i}]: Represents the maximum leaf value within the left subtree (from left to i).\\nmaxi[{i + 1, right}]: Represents the maximum leaf value within the right subtree (from i + 1 to right).\\nsolve(arr, maxi, dp, left, i): Represents the minimum cost of constructing the left subtree.\\nsolve(arr, maxi, dp, i + 1, right): Represents the minimum cost of constructing the right subtree.\\nKeep track of the minimum cost by updating ans with the minimum value between its current value and the cost calculated in step 7.\\n\\nAfter calculating the minimum cost for the current range left to right, store the result ans in the dp vector at index [left][right] for memoization.\\n\\nAfter calculating the minimum cost for all ranges, return the result stored in dp[0][n-1], which represents the minimum cost to construct the binary search tree.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve( vector<int>& arr,map<pair<int,int>,int>&maxi,vector<vector<int>>&dp,int left,int right)\\n{\\n    if(left==right)\\n    {\\n        return 0;\\n    }\\n    if(dp[left][right]!=-1)\\n    {\\n        return dp[left][right];\\n    }\\n    int ans= INT_MAX;\\n    for(int i =left;i<right;i++)\\n    {\\n        ans=min(ans,maxi[{left,i}]*maxi[{i+1,right}]+solve(arr,maxi,dp,left,i)+solve(arr,maxi,dp,i+1,right));\\n    }\\n   return dp[left][right]=ans;\\n}\\n\\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n        int n= arr.size();\\n        map<pair<int,int>, int>maxi;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        for(int i=0; i<n;i++)\\n        {\\n            maxi[{i,i}]=arr[i];\\n            for(int j =i+1;j<n;j++)\\n            {\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        return solve(arr,maxi,dp,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve( vector<int>& arr,map<pair<int,int>,int>&maxi,vector<vector<int>>&dp,int left,int right)\\n{\\n    if(left==right)\\n    {\\n        return 0;\\n    }\\n    if(dp[left][right]!=-1)\\n    {\\n        return dp[left][right];\\n    }\\n    int ans= INT_MAX;\\n    for(int i =left;i<right;i++)\\n    {\\n        ans=min(ans,maxi[{left,i}]*maxi[{i+1,right}]+solve(arr,maxi,dp,left,i)+solve(arr,maxi,dp,i+1,right));\\n    }\\n   return dp[left][right]=ans;\\n}\\n\\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n        int n= arr.size();\\n        map<pair<int,int>, int>maxi;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        for(int i=0; i<n;i++)\\n        {\\n            maxi[{i,i}]=arr[i];\\n            for(int j =i+1;j<n;j++)\\n            {\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        return solve(arr,maxi,dp,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620860,
                "title": "easy-to-understand-c-solution-memoized-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[42][42];\\n    int solve(int i, int j, vector<int>& arr){\\n        if(i==j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int mn = INT_MAX;\\n        for(int k=i; k<j; k++){\\n            int leftMax = 0;\\n            int rightMax= 0;\\n            for(int id=i; id<=k; id++) leftMax = max(leftMax,arr[id]);\\n            for(int id=k+1; id<=j; id++) rightMax = max(rightMax,arr[id]);\\n            mn = min(mn, leftMax*rightMax + solve(i,k,arr) + solve(k+1,j,arr));\\n        }\\n        return dp[i][j] = mn;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,arr.size()-1,arr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[42][42];\\n    int solve(int i, int j, vector<int>& arr){\\n        if(i==j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int mn = INT_MAX;\\n        for(int k=i; k<j; k++){\\n            int leftMax = 0;\\n            int rightMax= 0;\\n            for(int id=i; id<=k; id++) leftMax = max(leftMax,arr[id]);\\n            for(int id=k+1; id<=j; id++) rightMax = max(rightMax,arr[id]);\\n            mn = min(mn, leftMax*rightMax + solve(i,k,arr) + solve(k+1,j,arr));\\n        }\\n        return dp[i][j] = mn;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,arr.size()-1,arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615262,
                "title": "c-new-way-explained-mcm-segment-tree",
                "content": "The approach that I am going to explain here is 100% New and Unique (probably not available in Discuss)\\n\\n**APPROACH:**\\n* This problem can be considered as an MCM problem. If we break array in **2 half** say **[start, k]** and **[k+1, end]**\\n* we can see that these 2 half (or these 2 sub-problem are **independent**), so **we can safely apply MCM**.\\n* ```Sum of non-leaf in [start, end] = Sum of non-leaf in [start, k] + Sum of non-leaf in [k+1, end] + ( MaxLeaf in [start, k] * MaxLeaf in [k+1, end] )```\\n* we will calculate this sum for different values of k from [start, end] as we did in MCM pattern and **choose the minimum sum** (as we are asked to minimse it)\\n* Now, **How can we find maxLeaf in [queryStart, queryEnd] optimally ?** That is where typical **max segement tree** comes into picture.\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    \\n    void build(int si, int ss, int se, vector<int>& arr, vector<int>& seg){\\n        if(ss==se){\\n            seg[si]=arr[ss]; return;\\n        }\\n        int mid= ss + (se-ss)/2;\\n        build(2*si+1, ss, mid, arr, seg);\\n        build(2*si+2, mid+1, se, arr, seg);\\n        seg[si]= max(seg[2*si+1], seg[2*si+2]);\\n        return;\\n    }\\n    \\n    int query(int si, int ss, int se, int qs, int qe, vector<int>& arr, vector<int>& seg){ // find max in [qs,qe]\\n        if(ss>qe || se<qs){ return INT_MIN; }  // complete outside\\n        if(ss>=qs && se<=qe){ return seg[si]; } // complete inside\\n        int mid= ss + (se-ss)/2;\\n        int lft= query(2*si+1, ss, mid, qs, qe, arr, seg);\\n        int rht= query(2*si+2, mid+1, se, qs, qe, arr, seg);\\n        return max(lft, rht);\\n    }\\n    \\n    int helper(int start, int end, vector<int>& arr, vector<int>& seg, vector<vector<int>>& dp){\\n        if(start>=end){ return 0; }\\n        if(dp[start][end]!=-1){ return dp[start][end]; }\\n        \\n        int sum=INT_MAX;\\n        for(int k=start; k<end; k++){\\n            int lft= helper(start, k, arr, seg, dp); // sum of non-leaf node of subtree [start, k]\\n            int rht= helper(k+1, end, arr, seg, dp); // sum of non-leaf node of subtree [k+1, end]\\n            int lftMax= query(0, 0, arr.size()-1, start, k, arr, seg); // max leaf node of subtree [start, k]\\n            int rhtMax= query(0, 0, arr.size()-1, k+1, end, arr, seg); // min leaf node of subtree [k+1, end]\\n            sum= min(sum, lft+rht+(lftMax*rhtMax)); // lftSum + rhtSum + (maxLeafLft*maxLeafRht)\\n        }\\n        return dp[start][end]=sum;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n= arr.size(); vector<int> seg(4*n);\\n        build(0, 0, n-1, arr, seg);\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return helper(0, n-1, arr, seg, dp);\\n    }\\n};\\n```\\nTime Complexity: O(N^2 * logN)\\nThanks !",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```Sum of non-leaf in [start, end] = Sum of non-leaf in [start, k] + Sum of non-leaf in [k+1, end] + ( MaxLeaf in [start, k] * MaxLeaf in [k+1, end] )```\n```\\nclass Solution {\\npublic:\\n    \\n    void build(int si, int ss, int se, vector<int>& arr, vector<int>& seg){\\n        if(ss==se){\\n            seg[si]=arr[ss]; return;\\n        }\\n        int mid= ss + (se-ss)/2;\\n        build(2*si+1, ss, mid, arr, seg);\\n        build(2*si+2, mid+1, se, arr, seg);\\n        seg[si]= max(seg[2*si+1], seg[2*si+2]);\\n        return;\\n    }\\n    \\n    int query(int si, int ss, int se, int qs, int qe, vector<int>& arr, vector<int>& seg){ // find max in [qs,qe]\\n        if(ss>qe || se<qs){ return INT_MIN; }  // complete outside\\n        if(ss>=qs && se<=qe){ return seg[si]; } // complete inside\\n        int mid= ss + (se-ss)/2;\\n        int lft= query(2*si+1, ss, mid, qs, qe, arr, seg);\\n        int rht= query(2*si+2, mid+1, se, qs, qe, arr, seg);\\n        return max(lft, rht);\\n    }\\n    \\n    int helper(int start, int end, vector<int>& arr, vector<int>& seg, vector<vector<int>>& dp){\\n        if(start>=end){ return 0; }\\n        if(dp[start][end]!=-1){ return dp[start][end]; }\\n        \\n        int sum=INT_MAX;\\n        for(int k=start; k<end; k++){\\n            int lft= helper(start, k, arr, seg, dp); // sum of non-leaf node of subtree [start, k]\\n            int rht= helper(k+1, end, arr, seg, dp); // sum of non-leaf node of subtree [k+1, end]\\n            int lftMax= query(0, 0, arr.size()-1, start, k, arr, seg); // max leaf node of subtree [start, k]\\n            int rhtMax= query(0, 0, arr.size()-1, k+1, end, arr, seg); // min leaf node of subtree [k+1, end]\\n            sum= min(sum, lft+rht+(lftMax*rhtMax)); // lftSum + rhtSum + (maxLeafLft*maxLeafRht)\\n        }\\n        return dp[start][end]=sum;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n= arr.size(); vector<int> seg(4*n);\\n        build(0, 0, n-1, arr, seg);\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return helper(0, n-1, arr, seg, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427916,
                "title": "easy-greedy-approach-in-c",
                "content": "# Approach\\n- First it go through minimum to maximum.\\n- Then it will find which leftmost and rightmost is free and take minimum from both.\\n- Finally it will multiply with current value and add to ans. Also marking that current index is done and will not be used again.\\n- For eg- arr = $$[15,13,5,3,15]$$, first it will iterate from 3 then it will select minimum from both leftmost and rightmost and multiply it, in this $$min(5,15)*3$$ will add to ans and mark it as done. Now for 5 it will min(13,15) as 3 is already marked so it will add $$min(13,15)*5$$ and 5 is marked done, then for 13 it will add $$min(15,15)*13$$ as 5 and 3 is mark as done and we will mark 13 as done. Now for 15 there is only one value remaining so adding $$15*15$$ and mark the first pos of 15 done and for last 15 there is no one left. So ans will be = $$3*min(5,15)+5*min(13,15)+13*min(15,15)+15*15$$ = $$500$$.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& a) {\\n        vector<int>adj[16];\\n        int n = a.size();\\n        // Store the positions of every value\\n        for(int i=0; i<n; i++){\\n            adj[a[i]].push_back(i); \\n        }\\n        vector<int>done(n,0);\\n        int ans = 0;\\n        for(int j=1; j<=15; j++){\\n            if(adj[j].size()==0) continue;\\n            vector<int>v=adj[j];\\n            for(int i=0; i<v.size(); i++){\\n                int idx = v[i];\\n                int left = idx-1;\\n                int right = idx+1;\\n                //finding which leftmost and rightmost is free;\\n                while(left>=0 && done[left]) left--; \\n                while(right<n && done[right]) right++; \\n                int mx = 100;\\n                // checking that it exists or not\\n                if(left>=0) mx = min(mx,a[left]); \\n                if(right<n) mx = min(mx,a[right]); \\n                if(mx!=100)ans+=mx*j;\\n                done[v[i]]=1; // marking that this index is done.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& a) {\\n        vector<int>adj[16];\\n        int n = a.size();\\n        // Store the positions of every value\\n        for(int i=0; i<n; i++){\\n            adj[a[i]].push_back(i); \\n        }\\n        vector<int>done(n,0);\\n        int ans = 0;\\n        for(int j=1; j<=15; j++){\\n            if(adj[j].size()==0) continue;\\n            vector<int>v=adj[j];\\n            for(int i=0; i<v.size(); i++){\\n                int idx = v[i];\\n                int left = idx-1;\\n                int right = idx+1;\\n                //finding which leftmost and rightmost is free;\\n                while(left>=0 && done[left]) left--; \\n                while(right<n && done[right]) right++; \\n                int mx = 100;\\n                // checking that it exists or not\\n                if(left>=0) mx = min(mx,a[left]); \\n                if(right<n) mx = min(mx,a[right]); \\n                if(mx!=100)ans+=mx*j;\\n                done[v[i]]=1; // marking that this index is done.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078405,
                "title": "fast-python-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to use a greedy approach to solve this problem. We can start by keeping track of the minimum value of the current subarray and multiply it with the next minimum value. We can also use a stack to keep track of the values in the current subarray and pop the values that are greater than the next value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable \"ans\" to keep track of the minimum cost of the tree.\\n2. Create a stack and initialize it with a value of infinity.\\n3.Iterate through the array \"arr\" and for each value \"a\":\\na. While the last value in the stack is less than or equal to \"a\", pop the value from the stack and add the product of the popped value and the minimum of the last value in the stack and \"a\" to the \"ans\" variable.\\nb. Append \"a\" to the stack.\\n4. While the stack has more than 2 values, pop the last value and add the product of the popped value and the last value in the stack to the \"ans\" variable.\\n5. Return the \"ans\" variable.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0\\n        stack = [float(\\'inf\\')]\\n        for a in arr:\\n            while stack[-1] <= a:\\n                mid = stack.pop()\\n                ans += mid * min(stack[-1], a)\\n            stack.append(a)\\n        while len(stack) > 2:\\n            ans += stack.pop() * stack[-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0\\n        stack = [float(\\'inf\\')]\\n        for a in arr:\\n            while stack[-1] <= a:\\n                mid = stack.pop()\\n                ans += mid * min(stack[-1], a)\\n            stack.append(a)\\n        while len(stack) > 2:\\n            ans += stack.pop() * stack[-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897536,
                "title": "2-solutions-o-n-time-best-time-complexity",
                "content": "# GREEDY APPROACH\\n# Intuition\\nAll u need to do is that:\\nWe need to keep the max node at the top most level\\nSo for that we need to pick min node val and keep it at the depth\\nWe did that.\\nAs it is in inorder sequence. we need to take idx -1 or idx+1 node\\nTake the min one again\\nDelete the min node, do this till only 1 node.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n- See finding min takes O(N) and we do it for every ith call.\\n- So N *N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size() > 1){\\n            int N = arr.size();\\n            auto it = min_element(arr.begin(), arr.end());\\n            int idx =  it - arr.begin();\\n            if(idx > 0 && idx < N-1 ){\\n                res+= arr[idx] * min(arr[idx-1], arr[idx+1]);\\n            }\\n            else{\\n                // now we dont have options on both sides\\n                // either its on left or right thats it\\n                if(idx==0)\\n                    res+= arr[idx] * arr[idx+1];\\n                else\\n                    res+= arr[idx] * arr[idx-1];\\n            }\\n\\n            arr.erase(it);\\n\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# TIME OPTIMIZED using MONOTONIC Stacks\\n \\n# Intuition\\nThe bottle neck is finding min guy. So we can try to make it in O(1)\\nSo that overall O(N) time and extra we may take O(N) Space\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n\\n        stack<int> stk;\\n        stk.push(INT_MAX); // to make sure we push 1st element\\n\\n        for(int a : arr){\\n            //monotonically decreasing stack.\\n            // big .... small at topmost\\n\\n            // big small big - pop the smaller guys\\n            while(stk.top() <= a){\\n                int tmp = stk.top();\\n                stk.pop(); // tmp is the min most guy. idx\\n                res+= tmp * min(stk.top(), a); // this is idx * min( idx-1, idx+1).\\n                //stk top is new one\\n            }\\n            stk.push(a);\\n        }\\n        // as in monotonic stack, once we pop that\\'s it \\n        while(stk.size() > 2){\\n            int tmp = stk.top();\\n            stk.pop(); // popped min most guy as it is mono dec stk\\n            res += tmp * stk.top(); // 2 min most guys mul\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size() > 1){\\n            int N = arr.size();\\n            auto it = min_element(arr.begin(), arr.end());\\n            int idx =  it - arr.begin();\\n            if(idx > 0 && idx < N-1 ){\\n                res+= arr[idx] * min(arr[idx-1], arr[idx+1]);\\n            }\\n            else{\\n                // now we dont have options on both sides\\n                // either its on left or right thats it\\n                if(idx==0)\\n                    res+= arr[idx] * arr[idx+1];\\n                else\\n                    res+= arr[idx] * arr[idx-1];\\n            }\\n\\n            arr.erase(it);\\n\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n\\n        stack<int> stk;\\n        stk.push(INT_MAX); // to make sure we push 1st element\\n\\n        for(int a : arr){\\n            //monotonically decreasing stack.\\n            // big .... small at topmost\\n\\n            // big small big - pop the smaller guys\\n            while(stk.top() <= a){\\n                int tmp = stk.top();\\n                stk.pop(); // tmp is the min most guy. idx\\n                res+= tmp * min(stk.top(), a); // this is idx * min( idx-1, idx+1).\\n                //stk top is new one\\n            }\\n            stk.push(a);\\n        }\\n        // as in monotonic stack, once we pop that\\'s it \\n        while(stk.size() > 2){\\n            int tmp = stk.top();\\n            stk.pop(); // popped min most guy as it is mono dec stk\\n            res += tmp * stk.top(); // 2 min most guys mul\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496135,
                "title": "easy-java-solution-with-memorization",
                "content": "```\\nclass Solution {\\n    \\n    int[][] tempResult;\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length-1;\\n        tempResult= new int[n+1][n+1];\\n        return getMin(arr, 0, n);\\n    }\\n    \\n    public int getMin(int[] arr, int start, int end){\\n        \\n        if(start== end){\\n            return 0;\\n        }\\n        \\n        if( tempResult[start][end] != 0 ){\\n            return tempResult[start][end];\\n        }\\n        \\n        int smallestAns= Integer.MAX_VALUE;\\n        \\n        for(int i= start; i<end; i++){\\n            \\n            //  Getting the max & min from the left & right sub-arrays respectively\\n            int maxLeft= 0, maxRight= 0;\\n            \\n            for(int j=start; j<=i; j++){\\n                maxLeft= Math.max( maxLeft, arr[j] );\\n            }\\n            \\n            for(int j = i+1; j<= end; j++){\\n                maxRight= Math.max(maxRight, arr[j]);\\n            }\\n            smallestAns= Math.min( smallestAns, maxLeft*maxRight + getMin(arr, start, i) + getMin(arr, i+1, end) );\\n            tempResult[start][end]= smallestAns;\\n        }\\n        \\n        return smallestAns;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[][] tempResult;\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length-1;\\n        tempResult= new int[n+1][n+1];\\n        return getMin(arr, 0, n);\\n    }\\n    \\n    public int getMin(int[] arr, int start, int end){\\n        \\n        if(start== end){\\n            return 0;\\n        }\\n        \\n        if( tempResult[start][end] != 0 ){\\n            return tempResult[start][end];\\n        }\\n        \\n        int smallestAns= Integer.MAX_VALUE;\\n        \\n        for(int i= start; i<end; i++){\\n            \\n            //  Getting the max & min from the left & right sub-arrays respectively\\n            int maxLeft= 0, maxRight= 0;\\n            \\n            for(int j=start; j<=i; j++){\\n                maxLeft= Math.max( maxLeft, arr[j] );\\n            }\\n            \\n            for(int j = i+1; j<= end; j++){\\n                maxRight= Math.max(maxRight, arr[j]);\\n            }\\n            smallestAns= Math.min( smallestAns, maxLeft*maxRight + getMin(arr, start, i) + getMin(arr, i+1, end) );\\n            tempResult[start][end]= smallestAns;\\n        }\\n        \\n        return smallestAns;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441040,
                "title": "c-mcm-variation-tabulation-dp",
                "content": "TC:O(N  * N * N * N) ---> ~=O(N^4)\\nSC:O(N^2)\\n```\\nclass Solution {\\npublic:\\n    int maxi(int i, int j,vector<int>&arr){\\n        int maxx=0;\\n        for(int k=i;k<=j;k++)\\n            maxx=max(maxx,arr[k]);\\n        return maxx;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        int total_sum=0;\\n        for(int i=0;i<n;i++)\\n            total_sum+=arr[i];\\n        vector<vector<int>>dp(n,vector<int>(n,1e9));\\n        for(int i=0;i<n;i++)\\n            dp[i][i]=arr[i]; \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i+1;j<n;j++){\\n               int mini_sum=INT_MAX;\\n                for(int k=i;k<j;k++){\\n                    int left  =  dp[i][k];\\n                    int right =  dp[k+1][j];\\n                    int curr_sum= maxi(i,k,arr)*maxi(k+1,j,arr) + left+right;\\n                    mini_sum=min(mini_sum,curr_sum);\\n                }\\n                dp[i][j]=mini_sum;  \\n            }\\n        }\\n        return dp[0][n-1]-total_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi(int i, int j,vector<int>&arr){\\n        int maxx=0;\\n        for(int k=i;k<=j;k++)\\n            maxx=max(maxx,arr[k]);\\n        return maxx;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        int total_sum=0;\\n        for(int i=0;i<n;i++)\\n            total_sum+=arr[i];\\n        vector<vector<int>>dp(n,vector<int>(n,1e9));\\n        for(int i=0;i<n;i++)\\n            dp[i][i]=arr[i]; \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i+1;j<n;j++){\\n               int mini_sum=INT_MAX;\\n                for(int k=i;k<j;k++){\\n                    int left  =  dp[i][k];\\n                    int right =  dp[k+1][j];\\n                    int curr_sum= maxi(i,k,arr)*maxi(k+1,j,arr) + left+right;\\n                    mini_sum=min(mini_sum,curr_sum);\\n                }\\n                dp[i][j]=mini_sum;  \\n            }\\n        }\\n        return dp[0][n-1]-total_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416400,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    //memoization\\n    int dp[41][41];\\n    //finding  maximum value from index i to index j in an array\\n    int maxi(vector<int> &arr,int i,int j)\\n    {\\n        int m=INT_MIN;\\n        for(int k=i;k<=j;k++) m=max(m,arr[k]);\\n        return m;\\n    }\\n    \\n    int func(vector<int> &arr,int i,int j)\\n    {\\n        //if already computed return the value in dp array\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        //base case\\n        if(i==j) return 0;\\n        if(i+1==j) return arr[i]*arr[j];\\n        \\n        //dividing the array into two sub arrays at every index \\n        //then finding solution by treating them as left and right subtrees and take minimum value among them\\n        \\n        int m=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n            m=min(m,maxi(arr,i,k)*maxi(arr,k+1,j)+func(arr,i,k)+func(arr,k+1,j));\\n        }\\n        \\n        dp[i][j]=m;\\n        return m;\\n        \\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //initialising memoization array\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=0;j<arr.size();j++)\\n            {\\n                dp[i][j]=-1;\\n                if(i+1==j) dp[i][j]=arr[i]*arr[j];\\n                if(i==j) dp[i][j]=0;\\n            }\\n        }\\n        \\n        return func(arr,0,arr.size()-1);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //memoization\\n    int dp[41][41];\\n    //finding  maximum value from index i to index j in an array\\n    int maxi(vector<int> &arr,int i,int j)\\n    {\\n        int m=INT_MIN;\\n        for(int k=i;k<=j;k++) m=max(m,arr[k]);\\n        return m;\\n    }\\n    \\n    int func(vector<int> &arr,int i,int j)\\n    {\\n        //if already computed return the value in dp array\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        //base case\\n        if(i==j) return 0;\\n        if(i+1==j) return arr[i]*arr[j];\\n        \\n        //dividing the array into two sub arrays at every index \\n        //then finding solution by treating them as left and right subtrees and take minimum value among them\\n        \\n        int m=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n            m=min(m,maxi(arr,i,k)*maxi(arr,k+1,j)+func(arr,i,k)+func(arr,k+1,j));\\n        }\\n        \\n        dp[i][j]=m;\\n        return m;\\n        \\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //initialising memoization array\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=0;j<arr.size();j++)\\n            {\\n                dp[i][j]=-1;\\n                if(i+1==j) dp[i][j]=arr[i]*arr[j];\\n                if(i==j) dp[i][j]=0;\\n            }\\n        }\\n        \\n        return func(arr,0,arr.size()-1);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386853,
                "title": "c-dp-memoization-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[40][40]={0};\\n    int solve(vector<int> arr,int start,int end)\\n    {\\n        if(start==end)\\n            return 0;\\n        if(dp[start][end]!=0)\\n            return dp[start][end];\\n        int mn=INT_MAX;\\n        for(int i=start;i<=end-1;i++)\\n        {\\n            int left=solve(arr,start,i);\\n            int right=solve(arr,i+1,end);\\n            int temp=left+right+*max_element(arr.begin()+start,arr.begin()+i+1) * *max_element(arr.begin()+i+1,arr.begin()+end+1);\\n            mn=min(mn,temp);\\n            \\n        }\\n        return dp[start][end]=mn;\\n    }\\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        return solve(arr,0,arr.size()-1);\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[40][40]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2331503,
                "title": "c-memoization-commented-solution-dp-clean-code",
                "content": "```\\n // Intuition -> there are various combinations of trees possible \\n    \\n    // We have to take every possible  combination of trees \\n    \\n    // Now creating binary tree is very hectic\\n    \\n    // What we will do is , we will recursively do the calculations \\n    \\n    // start from  l=0 , e=n-1\\n    \\n    // for each i=l;i<e;i++ -> l , i to i+1 ,e \\n    \\n    // store the max_ele of the that leaf part & also sum till that node \\n    \\n    // I will comment on each part of code\\n    \\n    // We need 2 things max_leaf_value , sum_till_node\\n    \\n    vector<vector<pp>> dp;\\n    \\n      pp func(vector<int> &arr , int l , int r)\\n      {\\n          if(l==r)\\n          {\\n              // that means it is a leaf node \\n              \\n              // return max_leaf_value , max_product_sum_till_this_node\\n              \\n              return {arr[l] , 0};\\n          }\\n          \\n          pp temp={-1 , -1};\\n          \\n          if(dp[l][r]!=temp)\\n          {\\n              return dp[l][r];\\n          }\\n          \\n          int max_leaf=INT_MIN;\\n          int min_product_sum=INT_MAX;\\n          \\n          for(int i=l;i<r;i++)\\n          {\\n              auto left_subtree=func(arr , l , i);\\n              auto right_subtree=func(arr , i+1 , r);\\n              \\n              int max_leaf_subtree=max(left_subtree.first , right_subtree.first);\\n              \\n              max_leaf=max(max_leaf , max_leaf_subtree);\\n                  \\n               min_product_sum=min(min_product_sum , left_subtree.second +\\n                right_subtree.second + left_subtree.first*right_subtree.first);\\n          }\\n          \\n          return dp[l][r]= {max_leaf , min_product_sum};\\n      }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        \\n        int l=0 , r=n-1;\\n        \\n        pp temp={-1 , -1};\\n        \\n       dp.resize(45 , vector<pp>(45 , {-1 , -1}));\\n          \\n       pp ans = func(arr , l , r);\\n        \\n        return ans.second;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n // Intuition -> there are various combinations of trees possible \\n    \\n    // We have to take every possible  combination of trees \\n    \\n    // Now creating binary tree is very hectic\\n    \\n    // What we will do is , we will recursively do the calculations \\n    \\n    // start from  l=0 , e=n-1\\n    \\n    // for each i=l;i<e;i++ -> l , i to i+1 ,e \\n    \\n    // store the max_ele of the that leaf part & also sum till that node \\n    \\n    // I will comment on each part of code\\n    \\n    // We need 2 things max_leaf_value , sum_till_node\\n    \\n    vector<vector<pp>> dp;\\n    \\n      pp func(vector<int> &arr , int l , int r)\\n      {\\n          if(l==r)\\n          {\\n              // that means it is a leaf node \\n              \\n              // return max_leaf_value , max_product_sum_till_this_node\\n              \\n              return {arr[l] , 0};\\n          }\\n          \\n          pp temp={-1 , -1};\\n          \\n          if(dp[l][r]!=temp)\\n          {\\n              return dp[l][r];\\n          }\\n          \\n          int max_leaf=INT_MIN;\\n          int min_product_sum=INT_MAX;\\n          \\n          for(int i=l;i<r;i++)\\n          {\\n              auto left_subtree=func(arr , l , i);\\n              auto right_subtree=func(arr , i+1 , r);\\n              \\n              int max_leaf_subtree=max(left_subtree.first , right_subtree.first);\\n              \\n              max_leaf=max(max_leaf , max_leaf_subtree);\\n                  \\n               min_product_sum=min(min_product_sum , left_subtree.second +\\n                right_subtree.second + left_subtree.first*right_subtree.first);\\n          }\\n          \\n          return dp[l][r]= {max_leaf , min_product_sum};\\n      }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        \\n        int l=0 , r=n-1;\\n        \\n        pp temp={-1 , -1};\\n        \\n       dp.resize(45 , vector<pp>(45 , {-1 , -1}));\\n          \\n       pp ans = func(arr , l , r);\\n        \\n        return ans.second;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249287,
                "title": "c-o-n-time-and-o-n-space",
                "content": "```\\nint mctFromLeafValues(vector<int>& arr) {\\n        stack<int> stack;\\n        int n = arr.size();\\n        int res = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int num = arr[i];\\n            while(!stack.empty() and stack.top()<=num)\\n            {\\n                int curr = stack.top();\\n                stack.pop();\\n                if(!stack.empty())\\n                    res = res + curr*min(stack.top(), num);\\n                else\\n                    res = res + curr*num;\\n            }\\n            stack.push(num);\\n        }\\n        while(stack.size()>=2)\\n        {\\n            int val = stack.top();\\n            stack.pop();\\n            res = res + stack.top()*val;\\n        }\\n        return res;\\n            \\n    }\\n```\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nint mctFromLeafValues(vector<int>& arr) {\\n        stack<int> stack;\\n        int n = arr.size();\\n        int res = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int num = arr[i];\\n            while(!stack.empty() and stack.top()<=num)\\n            {\\n                int curr = stack.top();\\n                stack.pop();\\n                if(!stack.empty())\\n                    res = res + curr*min(stack.top(), num);\\n                else\\n                    res = res + curr*num;\\n            }\\n            stack.push(num);\\n        }\\n        while(stack.size()>=2)\\n        {\\n            int val = stack.top();\\n            stack.pop();\\n            res = res + stack.top()*val;\\n        }\\n        return res;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248610,
                "title": "c-simplest-solutions-w-explanation",
                "content": "We need to return the minimum sum of the non-leaf nodes which are formed by the product of maximum leaf nodes of the leaft and right subtrees.\\n\\n* This is a Merging Intervals Problem. How?\\n\\n* The given array is the inorder traversal of the leaf nodes. But we do not know which all leaves can be placed in the left subtree and which all can be placed in the right subtree and which arrangement like this gives the minimum most sum.\\n\\n* So we try out every possibility. \\n\\n* Take for eg: ```[2, 6, 4, 1, 3]```. We try out every possible tree. \\n\\n* That is, we can place ```[2]``` in the left subtree and ```[6, 4, 1, 3]``` in the right subtree or ```[2, 6]``` in the left subtree and ```[4, 1, 3]``` in the right subtree.\\n\\n* So we use a value ```k``` a place it at every index from ```[0, n-1]``` (```n = arr.size()```) such that it divides the array into leafs belonging to left and right subtrees.\\n\\n* The subtrees can be solved recursively with the same formula,.\\n\\n**ALGORITHM:**\\n\\n* We need to return the minimum possible sum of the non-leaf nodes using leaves fro  ```[0, n-1]``` ~ ```[i, j]```. We traverse from leaf to root while solving using recursion.\\n\\n* We return a pair in each recursive call. The pair is ```{maxLeafNodeValue, minSum}```.\\n\\n* So when there\\'s only ```1``` node in the tree, that must be the leaf node. So we return ```{leafNodeValue, 0}``` as we do not need the sum of leaf node values.\\n\\n* We run a loop from ```i``` to ```j```. Array values from ```[i, k]``` belong to left subtree and ```[k+1, j]``` belong to right subtree.\\n\\n* Finally we take the maxLeafs product and add the minimumSum until there to get the minimum sum upto the current node.\\n\\n**RECURSION:**\\n\\n**Code:**\\n```\\nclass Solution {\\n    int n;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        return solve(arr, 0, n-1).second;\\n    }\\n    \\n    pair<int, int> solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return {arr[i], 0};\\n        \\n        int maxLeaf = INT_MIN, minSum = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            pair<int, int> left = solve(arr, i, k);\\n            pair<int, int> right = solve(arr, k+1, j);\\n            maxLeaf = max({maxLeaf, left.first, right.first});\\n            minSum = min(minSum, left.first * right.first + left.second + right.second);\\n        }\\n        return {maxLeaf, minSum};\\n    }\\n};\\n```\\n\\n**(OR)**\\n\\n```\\nclass Solution {\\n    int n;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        return solve(arr, 0, n-1);\\n    }\\n    \\n    int solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return 0;\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            int left = solve(arr, i, k);\\n            int right = solve(arr, k+1, j);\\n            ans = min(ans,  (*max_element(arr.begin()+i, arr.begin()+k+1)) * (*max_element(arr.begin()+k+1, arr.begin()+j+1)) + left + right);  //instead of returning a pair, we can directly get the max leaf node value from the array itself.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**DP (MEMORIZATION):**\\n\\n* We can memorize the solution  of subtrees to avoid repeated computations. So, ```dp[i][j]``` stores the minimum sum of the non-leaf nodes considering nodes from ```i``` to ```j``` in the array ```arr``` as leaves.\\n\\n**Code:**\\n```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> dp;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        dp.resize(n+1, vector<int>(n+1, -1));\\n        return solve(arr, 0, n-1);\\n    }\\n    \\n    int solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            int left = solve(arr, i, k);\\n            int right = solve(arr, k+1, j);\\n            ans = min(ans, (*max_element(arr.begin()+i, arr.begin()+k+1)) * (*max_element(arr.begin()+k+1, arr.begin()+j+1)) + left + right);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```[2, 6, 4, 1, 3]```\n```[2]```\n```[6, 4, 1, 3]```\n```[2, 6]```\n```[4, 1, 3]```\n```k```\n```[0, n-1]```\n```n = arr.size()```\n```[0, n-1]```\n```[i, j]```\n```{maxLeafNodeValue, minSum}```\n```1```\n```{leafNodeValue, 0}```\n```i```\n```j```\n```[i, k]```\n```[k+1, j]```\n```\\nclass Solution {\\n    int n;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        return solve(arr, 0, n-1).second;\\n    }\\n    \\n    pair<int, int> solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return {arr[i], 0};\\n        \\n        int maxLeaf = INT_MIN, minSum = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            pair<int, int> left = solve(arr, i, k);\\n            pair<int, int> right = solve(arr, k+1, j);\\n            maxLeaf = max({maxLeaf, left.first, right.first});\\n            minSum = min(minSum, left.first * right.first + left.second + right.second);\\n        }\\n        return {maxLeaf, minSum};\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int n;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        return solve(arr, 0, n-1);\\n    }\\n    \\n    int solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return 0;\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            int left = solve(arr, i, k);\\n            int right = solve(arr, k+1, j);\\n            ans = min(ans,  (*max_element(arr.begin()+i, arr.begin()+k+1)) * (*max_element(arr.begin()+k+1, arr.begin()+j+1)) + left + right);  //instead of returning a pair, we can directly get the max leaf node value from the array itself.\\n        }\\n        return ans;\\n    }\\n};\\n```\n```dp[i][j]```\n```i```\n```j```\n```arr```\n```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> dp;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        dp.resize(n+1, vector<int>(n+1, -1));\\n        return solve(arr, 0, n-1);\\n    }\\n    \\n    int solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            int left = solve(arr, i, k);\\n            int right = solve(arr, k+1, j);\\n            ans = min(ans, (*max_element(arr.begin()+i, arr.begin()+k+1)) * (*max_element(arr.begin()+k+1, arr.begin()+j+1)) + left + right);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214041,
                "title": "python-explained-with-pictures-dp-tabulation-intuitive",
                "content": "# EXPLANATION\\n![image](https://assets.leetcode.com/users/images/537bdd3a-16c1-4bee-8a42-b79e5945709c_1656511289.7734911.png)\\n\\nThe idea is very simple:\\n\\nGiven an array : We can break the array into two subarrays :\\nexample arr is (2,3,4,5) \\nwhich can be broken as:\\n1. (2) (3,4,5)\\n2. (2,3) (4,5)\\n3. (2,3,4) (5)\\n\\nNow we recursively find the answer for the subarray until we reach the base case\\n\\nwhen arr.size = 1: we return 0\\n\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        d = {}\\n        def findMax(start,end):\\n            if (start,end) in d: return d[(start,end)]\\n            maxx = start\\n            for i in range(start+1,end+1):\\n                if arr[maxx] < arr[i] : maxx = i\\n            d[(start,end)] = arr[maxx]\\n            return arr[maxx]\\n        \\n        dp = [[float(\\'inf\\') for i in range(n)] for j in range(n)]\\n        for gap in range(n):\\n            for row in range(n - gap):\\n                col = row + gap\\n                if gap == 0:\\n                    dp[row][col] = 0\\n                elif gap == 1:\\n                    dp[row][col] = arr[row] * arr[col]\\n                else:\\n                    for k in range(row,col):\\n                        val = dp[row][k] + findMax(row,k) * findMax(k+1,col) + dp[k+1][col]\\n                        if val < dp[row][col]: dp[row][col] = val\\n                \\n\\n        return dp[0][-1]\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        d = {}\\n        def findMax(start,end):\\n            if (start,end) in d: return d[(start,end)]\\n            maxx = start\\n            for i in range(start+1,end+1):\\n                if arr[maxx] < arr[i] : maxx = i\\n            d[(start,end)] = arr[maxx]\\n            return arr[maxx]\\n        \\n        dp = [[float(\\'inf\\') for i in range(n)] for j in range(n)]\\n        for gap in range(n):\\n            for row in range(n - gap):\\n                col = row + gap\\n                if gap == 0:\\n                    dp[row][col] = 0\\n                elif gap == 1:\\n                    dp[row][col] = arr[row] * arr[col]\\n                else:\\n                    for k in range(row,col):\\n                        val = dp[row][k] + findMax(row,k) * findMax(k+1,col) + dp[k+1][col]\\n                        if val < dp[row][col]: dp[row][col] = val\\n                \\n\\n        return dp[0][-1]\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863540,
                "title": "c-dp-recursion-all-possible-bt-easy-to-understand",
                "content": "**Solution:**\\n```\\npublic class Solution {\\n    Dictionary<KeyValuePair<int, int>, KeyValuePair<int, int>> dict = new Dictionary<KeyValuePair<int, int>, KeyValuePair<int, int>>();\\n    private KeyValuePair<int, int> DFS(int start, int end, int[] arr) {\\n        if(start == end) return new KeyValuePair<int, int>(arr[start], 0);\\n        if(dict.ContainsKey(new KeyValuePair<int, int>(start, end))) return dict[new KeyValuePair<int, int>(start, end)];\\n        int currSum = Int32.MaxValue;\\n        int currMax = 50;\\n        for(int i = start; i < end; ++i) {\\n            KeyValuePair<int, int> l = DFS(start, i, arr);\\n            KeyValuePair<int, int> r = DFS(i + 1, end, arr);\\n            currSum = Math.Min(currSum, l.Value + r.Value + l.Key * r.Key);\\n            currMax = Math.Max(l.Key, r.Key);\\n        }\\n        KeyValuePair<int, int> currRes = new KeyValuePair<int, int>(currMax, currSum);\\n        dict.Add(new KeyValuePair<int, int>(start, end), currRes);\\n        return currRes;\\n    }\\n    public int MctFromLeafValues(int[] arr) {\\n        return DFS(0, arr.Length - 1, arr).Value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    Dictionary<KeyValuePair<int, int>, KeyValuePair<int, int>> dict = new Dictionary<KeyValuePair<int, int>, KeyValuePair<int, int>>();\\n    private KeyValuePair<int, int> DFS(int start, int end, int[] arr) {\\n        if(start == end) return new KeyValuePair<int, int>(arr[start], 0);\\n        if(dict.ContainsKey(new KeyValuePair<int, int>(start, end))) return dict[new KeyValuePair<int, int>(start, end)];\\n        int currSum = Int32.MaxValue;\\n        int currMax = 50;\\n        for(int i = start; i < end; ++i) {\\n            KeyValuePair<int, int> l = DFS(start, i, arr);\\n            KeyValuePair<int, int> r = DFS(i + 1, end, arr);\\n            currSum = Math.Min(currSum, l.Value + r.Value + l.Key * r.Key);\\n            currMax = Math.Max(l.Key, r.Key);\\n        }\\n        KeyValuePair<int, int> currRes = new KeyValuePair<int, int>(currMax, currSum);\\n        dict.Add(new KeyValuePair<int, int>(start, end), currRes);\\n        return currRes;\\n    }\\n    public int MctFromLeafValues(int[] arr) {\\n        return DFS(0, arr.Length - 1, arr).Value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739194,
                "title": "simple-python-dp-3-solutions-time-o-n-3-o-nlogn-o-n",
                "content": "```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n        \\n        mem = {}\\n        def dp(i,j):\\n            \\n            if i==j: return 0, nums[i]# leafs result into 0\\n            \\n            if i>j: return 0, float(\"-inf\") #dont consider this\\n            \\n            if (i,j) in mem: return mem[(i,j)]\\n            ans = float(\"inf\")\\n            max_val = 0\\n            \\n            #does consider i,j to be leafs\\n            for k in range(i,j):\\n                \\n                left,max_l = dp(i,k)\\n                right,max_r  = dp(k+1,j)\\n                \\n                prod = max_l* max_r\\n                max_val = max(max_val, max_l, max_r)\\n                \\n                temp_ans = left+right+prod\\n                \\n                ans = min(ans, temp_ans)\\n        \\n            mem[(i,j)] = ans, max_val\\n            return mem[(i,j)]\\n        \\n        return dp(0,n-1)[0]\\n```\\n\\n```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n\\t\\t\\n\\t\\tq= []\\n        heapq.heapify(q)\\n        result = 0\\n        \\n        for num in nums:\\n            \\n            while q and q[0]<=num:\\n                prev_small_num = heapq.heappop(q)\\n                if q:\\n                    result += prev_small_num *(min(num, q[0]))\\n                \\n                else:\\n                    result += prev_small_num * num\\n                    \\n            heapq.heappush(q, num)\\n                    \\n        while len(q)>1:\\n            prev_small_num = heapq.heappop(q)\\n            result += q[0] *prev_small_num\\n            \\n        return result\\n```\\n```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n\\t\\tstack =[] #we need access to larger number so decrease q\\n        \\n        n = len(nums)\\n        \\n        ans = 0\\n        for j in range(n):\\n            num = nums[j]\\n            \\n            #update the stack such that we need to pop as as many small numbers as possible\\n            while stack and stack[-1]<num:\\n                small_num = stack.pop()\\n                \\n                ans += small_num* (min(stack[-1] if stack else float(\"inf\"),num)) #we dont know, wehter we should assign it to the left side or right side\\n                #we are forming non leaf nodes here and at the same time, we are forgetting small nodes\\n                \\n            stack.append(num)\\n                \\n       \\n        #left overs\\n        while stack and len(stack)>=2:\\n            prev_num = stack.pop()\\n            ans+= stack[-1]*prev_num\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n        \\n        mem = {}\\n        def dp(i,j):\\n            \\n            if i==j: return 0, nums[i]# leafs result into 0\\n            \\n            if i>j: return 0, float(\"-inf\") #dont consider this\\n            \\n            if (i,j) in mem: return mem[(i,j)]\\n            ans = float(\"inf\")\\n            max_val = 0\\n            \\n            #does consider i,j to be leafs\\n            for k in range(i,j):\\n                \\n                left,max_l = dp(i,k)\\n                right,max_r  = dp(k+1,j)\\n                \\n                prod = max_l* max_r\\n                max_val = max(max_val, max_l, max_r)\\n                \\n                temp_ans = left+right+prod\\n                \\n                ans = min(ans, temp_ans)\\n        \\n            mem[(i,j)] = ans, max_val\\n            return mem[(i,j)]\\n        \\n        return dp(0,n-1)[0]\\n```\n```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n\\t\\t\\n\\t\\tq= []\\n        heapq.heapify(q)\\n        result = 0\\n        \\n        for num in nums:\\n            \\n            while q and q[0]<=num:\\n                prev_small_num = heapq.heappop(q)\\n                if q:\\n                    result += prev_small_num *(min(num, q[0]))\\n                \\n                else:\\n                    result += prev_small_num * num\\n                    \\n            heapq.heappush(q, num)\\n                    \\n        while len(q)>1:\\n            prev_small_num = heapq.heappop(q)\\n            result += q[0] *prev_small_num\\n            \\n        return result\\n```\n```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n\\t\\tstack =[] #we need access to larger number so decrease q\\n        \\n        n = len(nums)\\n        \\n        ans = 0\\n        for j in range(n):\\n            num = nums[j]\\n            \\n            #update the stack such that we need to pop as as many small numbers as possible\\n            while stack and stack[-1]<num:\\n                small_num = stack.pop()\\n                \\n                ans += small_num* (min(stack[-1] if stack else float(\"inf\"),num)) #we dont know, wehter we should assign it to the left side or right side\\n                #we are forming non leaf nodes here and at the same time, we are forgetting small nodes\\n                \\n            stack.append(num)\\n                \\n       \\n        #left overs\\n        while stack and len(stack)>=2:\\n            prev_num = stack.pop()\\n            ans+= stack[-1]*prev_num\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1716174,
                "title": "98-faster-with-hints-java",
                "content": "Monotonic stacks are a good option when a problem involves comparing the size of numeric elements, with their order being relevant.\\n```\\n\\t\\t/*\\n        T: O(n)\\n        S: O(n)\\n        */\\n        if(arr == null && arr.length <2)    return 0;\\n        int ans = 0;\\n        Stack<Integer> s = new Stack<>();\\n        \\n        s.push(arr[0]);\\n        \\n        for(int i=1; i< arr.length; i++){\\n            while(s.size()!= 0 && s.peek() <= arr[i]){\\n                int sv = s.pop();\\n                int prev = (s.size()==0) ? Integer.MAX_VALUE : s.peek();\\n                \\n                ans+= sv*Math.min(arr[i], prev);\\n            }\\n            s.push(arr[i]);\\n        }\\n        \\n        while(s.size()>1){\\n            ans+= s.pop()*s.peek();\\n        }\\n        return ans;",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "Monotonic stacks are a good option when a problem involves comparing the size of numeric elements, with their order being relevant.\\n```\\n\\t\\t/*\\n        T: O(n)\\n        S: O(n)\\n        */\\n        if(arr == null && arr.length <2)    return 0;\\n        int ans = 0;\\n        Stack<Integer> s = new Stack<>();\\n        \\n        s.push(arr[0]);\\n        \\n        for(int i=1; i< arr.length; i++){\\n            while(s.size()!= 0 && s.peek() <= arr[i]){\\n                int sv = s.pop();\\n                int prev = (s.size()==0) ? Integer.MAX_VALUE : s.peek();\\n                \\n                ans+= sv*Math.min(arr[i], prev);\\n            }\\n            s.push(arr[i]);\\n        }\\n        \\n        while(s.size()>1){\\n            ans+= s.pop()*s.peek();\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1583668,
                "title": "java-dfs-with-memo-explained",
                "content": "We\\'re given an array of the leaf-nodes obtained from in-order traversal of a complete binary tree. The problem is:\\n\\n1) partition this array in such a way, that elements to the left of the partition make up nodes in the left subtree of the whole tree.\\n2) elements to the right of the partition make up nodes in the right subtree of the whole tree.\\n\\nThere are *many such possible* partitionings. We want the partitioning such that, the perfect tree yielded by that partitioning, has the minimum possible sum of non-leaf nodes.\\n\\nWe can try all possible partitionings of the tree; note that, a non-leaf node is the product of the LARGEST leaf node in its left and right subtree; that\\'s where this line comes from:\\n\\n**maximumInRange(arr,start,partition)\\\\*maximumInRange(arr,partition+1,end)**\\n\\nWe want to add that value, to the BEST value (smallest sum) we gain, from further partitioning the left and right subtrees, at the selected partition. That\\'s where this line comes in:\\n\\n**dfs(arr,start,partition)+dfs(arr,partition+1,end)**\\n\\nAfter each calculation, we update our current \\'best\\' (minimum) result.\\n\\nAfter considering all such partitionings, we have found the best result. Use a memo array to cache intermediate results.\\n\\n```\\nclass Solution {\\n    int[][] memo;\\n    public int mctFromLeafValues(int[] arr) {\\n        memo= new int[arr.length+1][arr.length+1];\\n        return dfs(arr,0,arr.length-1);\\n    }\\n    \\n    private int dfs(int[] arr, int start, int end){\\n        if(end-start==0) return 0;\\n        if(end-start==1) return arr[start]*arr[end];\\n        if(memo[start][end]!=0) return memo[start][end];\\n        \\n        int res=Integer.MAX_VALUE;\\n        for (int partition=start; partition<end; partition++){\\n            res= Math.min(res, \\n                          dfs(arr,start,partition)+dfs(arr,partition+1,end)\\n                          + (maximumInRange(arr,start,partition)*maximumInRange(arr,partition+1,end)));\\n        }\\n        memo[start][end]=res;\\n        return res;\\n    }\\n    \\n    private int maximumInRange(int[] arr, int start, int end){\\n        int res=0;\\n        for (int i=start; i<=end; i++) res=Math.max(res,arr[i]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] memo;\\n    public int mctFromLeafValues(int[] arr) {\\n        memo= new int[arr.length+1][arr.length+1];\\n        return dfs(arr,0,arr.length-1);\\n    }\\n    \\n    private int dfs(int[] arr, int start, int end){\\n        if(end-start==0) return 0;\\n        if(end-start==1) return arr[start]*arr[end];\\n        if(memo[start][end]!=0) return memo[start][end];\\n        \\n        int res=Integer.MAX_VALUE;\\n        for (int partition=start; partition<end; partition++){\\n            res= Math.min(res, \\n                          dfs(arr,start,partition)+dfs(arr,partition+1,end)\\n                          + (maximumInRange(arr,start,partition)*maximumInRange(arr,partition+1,end)));\\n        }\\n        memo[start][end]=res;\\n        return res;\\n    }\\n    \\n    private int maximumInRange(int[] arr, int start, int end){\\n        int res=0;\\n        for (int i=start; i<=end; i++) res=Math.max(res,arr[i]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487776,
                "title": "java-simple-stack-solution-100",
                "content": "```java\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        Stack<Integer> stack = new Stack();\\n        int result = 0;\\n        \\n        for(int i = 0; i < arr.length; ++i) {\\n            while(!stack.empty() && stack.peek() <= arr[i])\\n                result += stack.pop() * (stack.empty() ? arr[i] : Math.min(stack.peek(), arr[i]));\\n            \\n            stack.push(arr[i]);\\n        }\\n        \\n        while(stack.size() > 1)\\n            result += stack.pop() * stack.peek();\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        Stack<Integer> stack = new Stack();\\n        int result = 0;\\n        \\n        for(int i = 0; i < arr.length; ++i) {\\n            while(!stack.empty() && stack.peek() <= arr[i])\\n                result += stack.pop() * (stack.empty() ? arr[i] : Math.min(stack.peek(), arr[i]));\\n            \\n            stack.push(arr[i]);\\n        }\\n        \\n        while(stack.size() > 1)\\n            result += stack.pop() * stack.peek();\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414705,
                "title": "c-dp-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int sz=0;\\n    vector<int> arr;\\n    int mxdp[41][41]={};\\n    int fundp[41][41]={};\\n    int mx(int l,int r)\\n    {\\n        if(l==r) return arr[l];\\n        if(l>r) return 0;\\n        if(mxdp[l][r]) return mxdp[l][r];\\n        return mxdp[l][r]=max(mx(l+1,r),arr[l]);\\n    }\\n    int fun(int l,int r)\\n    {\\n        if(r-l<1) return 0;\\n        if(fundp[l][r]) return fundp[l][r];\\n        int ans=INT_MAX;\\n        for(int i=l;i<r;i++)\\n            ans=min(ans,fun(l,i)+fun(i+1,r)+mx(l,i)*mx(i+1,r));\\n        return fundp[l][r]=ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n       sz=arr.size();\\n        this->arr=arr;\\n        return fun(0,sz-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sz=0;\\n    vector<int> arr;\\n    int mxdp[41][41]={};\\n    int fundp[41][41]={};\\n    int mx(int l,int r)\\n    {\\n        if(l==r) return arr[l];\\n        if(l>r) return 0;\\n        if(mxdp[l][r]) return mxdp[l][r];\\n        return mxdp[l][r]=max(mx(l+1,r),arr[l]);\\n    }\\n    int fun(int l,int r)\\n    {\\n        if(r-l<1) return 0;\\n        if(fundp[l][r]) return fundp[l][r];\\n        int ans=INT_MAX;\\n        for(int i=l;i<r;i++)\\n            ans=min(ans,fun(l,i)+fun(i+1,r)+mx(l,i)*mx(i+1,r));\\n        return fundp[l][r]=ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n       sz=arr.size();\\n        this->arr=arr;\\n        return fun(0,sz-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403495,
                "title": "c-iterative-dp-mcm",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& v) {\\n    int n = v.size();\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    for (int j = 0; j < n; j++)\\n    {\\n        for (int i = j; i > -1; i--)\\n        {\\n            for (int k = i; k < j; k++)\\n            {\\n                int x = dp[i][k];\\n                int y = dp[k + 1][j];\\n                int temp = x + y + *max_element(v.begin() + i, v.begin() + k + 1) * *max_element(v.begin() + k + 1, v.begin() + j + 1);\\n                dp[i][j] = !dp[i][j] ? temp : min(dp[i][j], temp);\\n            }\\n        }\\n    }\\n    return dp[0][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& v) {\\n    int n = v.size();\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    for (int j = 0; j < n; j++)\\n    {\\n        for (int i = j; i > -1; i--)\\n        {\\n            for (int k = i; k < j; k++)\\n            {\\n                int x = dp[i][k];\\n                int y = dp[k + 1][j];\\n                int temp = x + y + *max_element(v.begin() + i, v.begin() + k + 1) * *max_element(v.begin() + k + 1, v.begin() + j + 1);\\n                dp[i][j] = !dp[i][j] ? temp : min(dp[i][j], temp);\\n            }\\n        }\\n    }\\n    return dp[0][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333938,
                "title": "monotone-stack-n-in-depth-explanation-python",
                "content": "```\\n#Basically for the minimum cost tree from Leaf Values, you want the smallest values farthest down \\n#the root, as you go up the tree, the leaf values should stay the same or increase. \\n#The tree should  look like a flatten binarty tree except each node needs 0 or two leafs.  IE given [8,4,2,3] \\n#\\n#        32\\n#       /  \\\\\\n#      12   8\\n#     / \\\\\\n#    6   4\\n#   / \\\\\\n#  2  3\\n# \\n# Result = 50\\n#have a monotone stack that keeps a decreasing order of values\\n#if we get a bigger number or equal then what is on top of the stack\\n#then we pop it off. And add whatever the value we popped off is  times the  min\\n#of ether whhats  on top of the stack or the number itself. \\n#Keep doing this process til we can add num to the stack and it will still be in decreasing order\\n#After iterating through arr, if the stack still has more than 2 values in it \\n#then pop off what is on top of the stack and\\n#times it by the next thing on the stack until there or two or less values.\\n\\n#IE if given [6,4,2] res would be 0 after iterating through arr, but stack would be [\\'INF\\',6,4,2] so it would be\\n# (6*4) + (2*4) = 32\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr):\\n        stack =  [float(\\'inf\\')]\\n        res = 0\\n        \\n        for num in arr:\\n            while stack and stack[-1] <= num:\\n                cur = stack.pop()\\n                #stack will always have atleast one thing in it after pop because inf is in there\\n                res += cur * min(num, stack[-1])\\n                \\n            stack.append(num)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        \\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n#Basically for the minimum cost tree from Leaf Values, you want the smallest values farthest down \\n#the root, as you go up the tree, the leaf values should stay the same or increase. \\n#The tree should  look like a flatten binarty tree except each node needs 0 or two leafs.  IE given [8,4,2,3] \\n#\\n#        32\\n#       /  \\\\\\n#      12   8\\n#     / \\\\\\n#    6   4\\n#   / \\\\\\n#  2  3\\n# \\n# Result = 50\\n#have a monotone stack that keeps a decreasing order of values\\n#if we get a bigger number or equal then what is on top of the stack\\n#then we pop it off. And add whatever the value we popped off is  times the  min\\n#of ether whhats  on top of the stack or the number itself. \\n#Keep doing this process til we can add num to the stack and it will still be in decreasing order\\n#After iterating through arr, if the stack still has more than 2 values in it \\n#then pop off what is on top of the stack and\\n#times it by the next thing on the stack until there or two or less values.\\n\\n#IE if given [6,4,2] res would be 0 after iterating through arr, but stack would be [\\'INF\\',6,4,2] so it would be\\n# (6*4) + (2*4) = 32\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr):\\n        stack =  [float(\\'inf\\')]\\n        res = 0\\n        \\n        for num in arr:\\n            while stack and stack[-1] <= num:\\n                cur = stack.pop()\\n                #stack will always have atleast one thing in it after pop because inf is in there\\n                res += cur * min(num, stack[-1])\\n                \\n            stack.append(num)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1262849,
                "title": "python-solution-dp-based-o-n-3",
                "content": "```\\nclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        N = len(arr)\\n        dp = [[0 for _ in range(N)] for _ in range(N)]\\n        max_dp = [[0 for _ in range(N)] for _ in range(N)]\\n        \\n        for i in range(N):\\n            max_val = arr[i]\\n            for j in range(i, N):\\n                max_val = max(max_val, arr[j])\\n                max_dp[i][j] = max_val\\n                \\n        for gap in range(1, N):\\n            for i in range(N-gap):\\n                j = i + gap\\n                dp[i][j] = float(\"inf\")\\n                for k in range(i, j):\\n                    dp[i][j] = min(dp[i][j], \\\\\\n                                (dp[i][k]+dp[k+1][j])+max_dp[i][k]*max_dp[k+1][j])\\n                    \\n        \\n        return dp[0][N-1]\\n                    \\n                    \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        N = len(arr)\\n        dp = [[0 for _ in range(N)] for _ in range(N)]\\n        max_dp = [[0 for _ in range(N)] for _ in range(N)]\\n        \\n        for i in range(N):\\n            max_val = arr[i]\\n            for j in range(i, N):\\n                max_val = max(max_val, arr[j])\\n                max_dp[i][j] = max_val\\n                \\n        for gap in range(1, N):\\n            for i in range(N-gap):\\n                j = i + gap\\n                dp[i][j] = float(\"inf\")\\n                for k in range(i, j):\\n                    dp[i][j] = min(dp[i][j], \\\\\\n                                (dp[i][k]+dp[k+1][j])+max_dp[i][k]*max_dp[k+1][j])\\n                    \\n        \\n        return dp[0][N-1]\\n                    \\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1243620,
                "title": "java-o-n-time-and-space-detailed-explanation",
                "content": "```\\n   /*\\n    \"2 <= arr.length <= 40\"\\n    \"1 <= arr[i] <= 15 \"\\n  means each leaf value is positive.\\n    \"It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31).\"\\n\\n  Idea:\\n  - Question name is \"Minimum Cost Tree From Leaf Values\"\\n  - Related Topics: stack\\n  - Similar question: Next Great Element I, Next Great Element  III\\n  - Hints are about DP which is O(N^3) time and O(N^2) space\\n\\n  Observation: for a smaller element A[i] once it is\\n   used to calculated the value of no-leaf node, the product, with another\\n   element whose value >=A[i], A[i] then will never be used anymore to\\n   calculated the value of any no-leaf node. Here the value of no-leaf node,\\n   the product, can be took as the `cost` of `removing` A[i].\\n\\n  For achieving the Minimum Cost Tree From Leaf Values\\n  - compared with the smaller element, the bigger element should be used\\n   later to avoid being used more times to calculate the cost of `removing`\\n   smaller ones. The biggest one will be used at most twice to calculate the\\n   cost of removing the second(the value of root) and the third biggest one\\n   if both of them are not on the same side of the biggest one.\\n  - when it is time to remove A[i], use the smaller one of 2 nearest bigger neighbor\\n    on both sides to make the cost of removing A[i] as small as possible,\\n    If there are smaller ones between A[i] and its 2 nearest bigger neighbor, then\\n    they should be removed firstly before removing A[i]. Monotonic descending stack\\n    is used in this kind of scenario. if there are A[x], A[i], A[y] with the same\\n    value, left one always be remove by the right one.\\n\\n  - The order of removing of each element does not affect the result\\n  - with Integer.MAX_VAL as the first element in Monotonic descending stack\\n    -- need not checking empty\\n    -- make code of calculating the cost of A[i] concise when remove A[i]\\n       in scenario where the stack status is (MAX_VAL,A[i]) and\\n       current element `cur` is bigger one. cost = A[i]*cur\\n  O(N) time and space, N is length of A[]\\n   */\\n  public int mctFromLeafValues(int[] A) {\\n    int r = 0;\\n    Stack<Integer> s = new Stack<>();\\n    s.push(Integer.MAX_VALUE); // dummy one\\n    for (int cur : A) {\\n      while (s.peek() <= cur) r += s.pop() * Math.min(s.peek(), cur); // pre > it <= cur\\n      s.push(cur);\\n    }\\n    while (s.size() > 2) r += s.pop() * s.peek();\\n    return r;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n   /*\\n    \"2 <= arr.length <= 40\"\\n    \"1 <= arr[i] <= 15 \"\\n  means each leaf value is positive.\\n    \"It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31).\"\\n\\n  Idea:\\n  - Question name is \"Minimum Cost Tree From Leaf Values\"\\n  - Related Topics: stack\\n  - Similar question: Next Great Element I, Next Great Element  III\\n  - Hints are about DP which is O(N^3) time and O(N^2) space\\n\\n  Observation: for a smaller element A[i] once it is\\n   used to calculated the value of no-leaf node, the product, with another\\n   element whose value >=A[i], A[i] then will never be used anymore to\\n   calculated the value of any no-leaf node. Here the value of no-leaf node,\\n   the product, can be took as the `cost` of `removing` A[i].\\n\\n  For achieving the Minimum Cost Tree From Leaf Values\\n  - compared with the smaller element, the bigger element should be used\\n   later to avoid being used more times to calculate the cost of `removing`\\n   smaller ones. The biggest one will be used at most twice to calculate the\\n   cost of removing the second(the value of root) and the third biggest one\\n   if both of them are not on the same side of the biggest one.\\n  - when it is time to remove A[i], use the smaller one of 2 nearest bigger neighbor\\n    on both sides to make the cost of removing A[i] as small as possible,\\n    If there are smaller ones between A[i] and its 2 nearest bigger neighbor, then\\n    they should be removed firstly before removing A[i]. Monotonic descending stack\\n    is used in this kind of scenario. if there are A[x], A[i], A[y] with the same\\n    value, left one always be remove by the right one.\\n\\n  - The order of removing of each element does not affect the result\\n  - with Integer.MAX_VAL as the first element in Monotonic descending stack\\n    -- need not checking empty\\n    -- make code of calculating the cost of A[i] concise when remove A[i]\\n       in scenario where the stack status is (MAX_VAL,A[i]) and\\n       current element `cur` is bigger one. cost = A[i]*cur\\n  O(N) time and space, N is length of A[]\\n   */\\n  public int mctFromLeafValues(int[] A) {\\n    int r = 0;\\n    Stack<Integer> s = new Stack<>();\\n    s.push(Integer.MAX_VALUE); // dummy one\\n    for (int cur : A) {\\n      while (s.peek() <= cur) r += s.pop() * Math.min(s.peek(), cur); // pre > it <= cur\\n      s.push(cur);\\n    }\\n    while (s.size() > 2) r += s.pop() * s.peek();\\n    return r;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1231263,
                "title": "java-recursive-solution-with-memoization-top-down-dp-approach",
                "content": "```\\nclass Solution {\\n    int[][] memory;\\n    public int mctFromLeafValues(int[] arr) {\\n        memory = new int[arr.length][arr.length];\\n        //initializing memory array with invalid value -1\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=0; j<arr.length; j++){\\n                memory[i][j]=-1;\\n            }\\n        }\\n        \\n        //Top level call to recursive function\\n        return MCTSubree(arr, 0, arr.length-1);\\n    }\\n    \\n    public int MCTSubree(int[]arr, int l, int r){\\n        //if memory has already the valid value \\n        if(memory[l][r] != -1)\\n            return memory[l][r];\\n        \\n        //if subtree is just a leaf node\\n        if(l==r){\\n            memory[l][r] = 0;\\n            return 0;\\n        }\\n        \\n        int leftMaxLeaf = -1;\\n        int rightMaxLeaf = -1;\\n        int smallestSum = Integer.MAX_VALUE;\\n        \\n        //we will partition the arr between l and r index\\n        for(int p=l; p<r; p++){\\n            //determine the max leaf node in left partion\\n            leftMaxLeaf = Integer.max(leftMaxLeaf, arr[p]);\\n            \\n            //determine the max leaf node in right partion\\n            for(int i=p+1; i<=r; i++)\\n                rightMaxLeaf = Integer.max(rightMaxLeaf, arr[i]);\\n            \\n            //recursive call on left partition to get sum of non leaf nodes\\n            int leftSubtreeSum = MCTSubree(arr, l, p);\\n            //recursive call on right partition to get sum of non leaf nodes\\n            int rightSubtreeSum = MCTSubree(arr, p+1, r);\\n            \\n            //check if the current partion produces the smallest sum of non leaf nodes\\n            smallestSum = Math.min(smallestSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        \\n        //save the result to memory\\n        memory[l][r] = smallestSum;\\n        return smallestSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] memory;\\n    public int mctFromLeafValues(int[] arr) {\\n        memory = new int[arr.length][arr.length];\\n        //initializing memory array with invalid value -1\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=0; j<arr.length; j++){\\n                memory[i][j]=-1;\\n            }\\n        }\\n        \\n        //Top level call to recursive function\\n        return MCTSubree(arr, 0, arr.length-1);\\n    }\\n    \\n    public int MCTSubree(int[]arr, int l, int r){\\n        //if memory has already the valid value \\n        if(memory[l][r] != -1)\\n            return memory[l][r];\\n        \\n        //if subtree is just a leaf node\\n        if(l==r){\\n            memory[l][r] = 0;\\n            return 0;\\n        }\\n        \\n        int leftMaxLeaf = -1;\\n        int rightMaxLeaf = -1;\\n        int smallestSum = Integer.MAX_VALUE;\\n        \\n        //we will partition the arr between l and r index\\n        for(int p=l; p<r; p++){\\n            //determine the max leaf node in left partion\\n            leftMaxLeaf = Integer.max(leftMaxLeaf, arr[p]);\\n            \\n            //determine the max leaf node in right partion\\n            for(int i=p+1; i<=r; i++)\\n                rightMaxLeaf = Integer.max(rightMaxLeaf, arr[i]);\\n            \\n            //recursive call on left partition to get sum of non leaf nodes\\n            int leftSubtreeSum = MCTSubree(arr, l, p);\\n            //recursive call on right partition to get sum of non leaf nodes\\n            int rightSubtreeSum = MCTSubree(arr, p+1, r);\\n            \\n            //check if the current partion produces the smallest sum of non leaf nodes\\n            smallestSum = Math.min(smallestSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        \\n        //save the result to memory\\n        memory[l][r] = smallestSum;\\n        return smallestSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206375,
                "title": "c-dp-mcm-recursive-memoized-faster-than-100",
                "content": "\\n       \\n     class Solution{\\n\\t public:\\n        int dp[50][50];                    \\n        int leftmax[50][50];            //i,j storing maximum sum from i to j\\n        int rightmax[50][50];          // i,j storing maximum from j to i\\n        int solve(vector<int>&arr,int i,int j){\\n\\t\\t      if(i>=j){                    // base condition\\n                 return 0;\\n              }\\n\\t           if(dp[i][j]!=-1){\\n                 return dp[i][j];\\n              }\\n       \\n\\t          int ans=INT_MAX;\\n              for(int k=i;k<j;k++){\\n                  int left,right;\\n                  if(dp[i][k]!=-1){  // checking if we already have answer from i to k\\n                     left=dp[i][k];\\n                   }\\n                 else{\\n                    dp[i][k]=solve(arr,i,k);       // if not then call and find that answer\\n                    left=dp[i][k];\\n                 }\\n            \\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];     //checking if we already have answer from k+1 to j\\n                }\\n                else{\\n                   dp[k+1][j]=solve(arr,k+1,j);   // if not then call and find \\n                   right=dp[k+1][j];\\n                 }\\n                 int temp=left+right+(leftmax[i][k]*rightmax[k+1][j]);   //add  product of maximum value from i to j and maximum value from k+1 to j \\n                 ans=min(ans,temp);    \\n           }\\n            return dp[i][j]=ans;      //find minimum and store it into dp matrix\\n       }\\n        int mctFromLeafValues(vector<int>& arr) {\\n            int n=arr.size();\\n            memset(dp,-1,sizeof(dp));\\n        \\n             for(int i=0;i<n;i++){\\n                int val=arr[i];\\n                for(int j=i;j<n;j++){\\n                val=max(val,arr[j]);\\n                leftmax[i][j]=val;\\n            }\\n        }\\n            for(int i=n-1;i>=0;i--){\\n                int val=arr[i];\\n                for(int j=i;j>=0;j--){\\n                val=max(val,arr[j]);\\n                rightmax[j][i]=val;\\n               }\\n           }\\n            return solve(arr,0,n-1);\\n         }\\n    };",
                "solutionTags": [],
                "code": "class Solution{\\n\\t public:\\n        int dp[50][50];                    \\n        int leftmax[50][50];            //i,j storing maximum sum from i to j\\n        int rightmax[50][50];          // i,j storing maximum from j to i\\n        int solve(vector<int>&arr,int i,int j){\\n\\t\\t      if(i>=j){                    // base condition\\n                 return 0;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1204319,
                "title": "java-simple-solution-3-ms-faster-than-50-56-dp",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr)\\n    {\\n        int n=arr.length-1;\\n        return fun(arr, 0, n, new Pair[n+1][n+1]).sum;\\n    }\\n    \\n    public Pair fun(int[] arr, int l, int r, Pair[][] dp)\\n    {\\n        if(l>r) return new Pair(0,1000000);\\n        if(l==r)return new Pair(arr[l], 0);\\n        if(dp[l][r]!=null) return dp[l][r];\\n        Pair ans=new Pair(0, 1000000);\\n        for(int i=l;i<r;i++)\\n        {\\n           Pair Pair_left= fun(arr, l, i, dp);\\n           Pair  Pair_right=fun(arr, i+1, r, dp);\\n            \\n            int total= Pair_left.sum + Pair_right.sum +(Pair_left.max * Pair_right.max);\\n            \\n            if(total< ans.sum)\\n            {\\n                ans.max= Math.max(Pair_left.max, Pair_right.max);\\n                ans.sum= total;\\n            }\\n        }\\n        dp[l][r]= new Pair(ans.max, ans.sum);\\n        return ans;\\n    }\\n}\\n\\nclass Pair\\n{\\n    int max, sum;\\n    Pair(int max, int sum)\\n    {\\n        this.max=max;\\n        this.sum=sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int mctFromLeafValues(int[] arr)\\n    {\\n        int n=arr.length-1;\\n        return fun(arr, 0, n, new Pair[n+1][n+1]).sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1102713,
                "title": "c-top-down-dp-simple-sol",
                "content": "class Solution {\\npublic:\\n    \\n    int dp[42][42];\\n    \\n    int fin(vector<int>&v , int l , int r){\\n        int ans = 0 ;\\n        for(int i=l; i<=r ; i++){\\n            ans = max(ans , v[i]);\\n        }\\n        return ans ;\\n    }\\n    \\n    int fun(vector<int>& v , int l , int r){\\n        if(l>=r){\\n            return 0;\\n        }\\n        if(dp[l][r]!= -1){\\n            return dp[l][r];\\n        }\\n        int ans = INT_MAX ;\\n        for(int i=l ; i<r ; i++){\\n            ans = min(ans , fin(v,l,i)*fin(v,i+1,r) + fun(v , l, i) + fun(v , i+1 , r));\\n        }\\n        \\n        return dp[l][r] = ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(dp , -1 , sizeof(dp));\\n        int ans = fun(arr , 0 , arr.size()-1);\\n        return ans ;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int dp[42][42];\\n    \\n    int fin(vector<int>&v , int l , int r){\\n        int ans = 0 ;\\n        for(int i=l; i<=r ; i++){\\n            ans = max(ans , v[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1054145,
                "title": "java-short-iterative-dp-solution",
                "content": "```\\npublic int mctFromLeafValues(int[] arr) {\\n\\tint res = Integer.MAX_VALUE, n = arr.length;\\n\\tint[][] dp = new int[n][n], max = new int[n][n];\\n\\tfor(int len = 0; len < n; len++) {\\n\\t\\tfor(int i = 0; i + len < n; i++) {\\n\\t\\t\\tint j = i + len;\\n\\t\\t\\tif(i == j) {\\n\\t\\t\\t\\tmax[i][j] = arr[i];\\n\\t\\t\\t} else if(i + 1 == j){\\n\\t\\t\\t\\tdp[i][j] = arr[i] * arr[j];\\n\\t\\t\\t\\tmax[i][j] = Math.max(arr[i], arr[j]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[i][j] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int k = i; k < j; k++) {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i][k] + dp[k + 1][j] + max[i][k] * max[k + 1][j], dp[i][j]);\\n\\t\\t\\t\\t\\tmax[i][j] = Math.max(max[i][k], max[k + 1][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int mctFromLeafValues(int[] arr) {\\n\\tint res = Integer.MAX_VALUE, n = arr.length;\\n\\tint[][] dp = new int[n][n], max = new int[n][n];\\n\\tfor(int len = 0; len < n; len++) {\\n\\t\\tfor(int i = 0; i + len < n; i++) {\\n\\t\\t\\tint j = i + len;\\n\\t\\t\\tif(i == j) {\\n\\t\\t\\t\\tmax[i][j] = arr[i];\\n\\t\\t\\t} else if(i + 1 == j){\\n\\t\\t\\t\\tdp[i][j] = arr[i] * arr[j];\\n\\t\\t\\t\\tmax[i][j] = Math.max(arr[i], arr[j]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[i][j] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int k = i; k < j; k++) {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i][k] + dp[k + 1][j] + max[i][k] * max[k + 1][j], dp[i][j]);\\n\\t\\t\\t\\t\\tmax[i][j] = Math.max(max[i][k], max[k + 1][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1007611,
                "title": "simple-python3-code",
                "content": "Pretty simple to understand:\\n\\n![image](https://assets.leetcode.com/users/images/71c435b6-5e4d-4b7a-b2c2-6e55a7c44c4e_1610117879.4392443.png)\\n\\n\\n```\\n# By Varsha Verma\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        if not arr:\\n            return 0\\n        if len(arr)<2:\\n            return 0\\n        if len(arr)==2:\\n            return arr[0]*arr[-1]\\n        res = 0\\n        while(len(arr)>1):\\n            max = arr[0]*arr[1]\\n            l = 0\\n            r = 1\\n            for i in range(len(arr)-1):\\n                if arr[i]*arr[i+1]<max:\\n                    max = arr[i]*arr[i+1]\\n                    l = i\\n                    r = i+1\\n            res+=max\\n            #print(l,r,max)\\n            if arr[l]>arr[r]:\\n                del arr[r]\\n            else:\\n                del arr[l]\\n        return res\\n\\t\\t\\n\\t```\\n\\t\\n\\t```\\n\\tclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        ans = 0\\n        while len(arr) > 1:\\n            minIndex = arr.index(min(arr))\\n            if 0 < minIndex < len(arr) - 1:\\n                ans += min(arr[minIndex - 1], arr[minIndex + 1]) * arr[minIndex]\\n            else:  \\n           #handle corner cases:when minimum value is either first value or last value of the list ex:[2,6,4]/[6,4,2]     \\n                ans += arr[1 if minIndex == 0 else minIndex - 1] * arr[minIndex]\\n            arr.pop(minIndex)\\n        return ans \\n        \\n\\t\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# By Varsha Verma\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        if not arr:\\n            return 0\\n        if len(arr)<2:\\n            return 0\\n        if len(arr)==2:\\n            return arr[0]*arr[-1]\\n        res = 0\\n        while(len(arr)>1):\\n            max = arr[0]*arr[1]\\n            l = 0\\n            r = 1\\n            for i in range(len(arr)-1):\\n                if arr[i]*arr[i+1]<max:\\n                    max = arr[i]*arr[i+1]\\n                    l = i\\n                    r = i+1\\n            res+=max\\n            #print(l,r,max)\\n            if arr[l]>arr[r]:\\n                del arr[r]\\n            else:\\n                del arr[l]\\n        return res\\n\\t\\t\\n\\t```\n```\\n\\tclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        ans = 0\\n        while len(arr) > 1:\\n            minIndex = arr.index(min(arr))\\n            if 0 < minIndex < len(arr) - 1:\\n                ans += min(arr[minIndex - 1], arr[minIndex + 1]) * arr[minIndex]\\n            else:  \\n           #handle corner cases:when minimum value is either first value or last value of the list ex:[2,6,4]/[6,4,2]     \\n                ans += arr[1 if minIndex == 0 else minIndex - 1] * arr[minIndex]\\n            arr.pop(minIndex)\\n        return ans \\n        \\n\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1006966,
                "title": "java-bottom-up-dp",
                "content": "All thanks to this type of DP pattern which i learnt from this post : https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns#Merging-Intervals\\n\\nTo optmisie further , could have use segement tree to Range max queries \\n```\\nclass Solution {\\n  private int infi = Integer.MAX_VALUE/2;\\n    public int mctFromLeafValues(int[] arr) {\\n       if(arr == null || arr.length <= 1)\\n           return 0;\\n       int n = arr.length;\\n       int[][] dp = new int[n][n];\\n\\n       //len = 1\\n       for (int i = 0; i < n ; i++)\\n           dp[i][i] = 0;\\n\\n       //len = 2\\n       for (int i = 0; i < n-1; i++)\\n           dp[i][i+1] = arr[i]*arr[i+1];\\n\\n       //len 3 and above\\n       for (int len = 3; len  <= n; len++){\\n           for (int i = 0; i+len-1 <= n-1; i++){\\n               int j = i+len-1;\\n               dp[i][j] = infi;\\n               for (int k = i; k <j ; k++){\\n                   dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j]+ maxVal(arr, i,k) * maxVal(arr, k+1, j));\\n               }\\n           }\\n       }\\n       return dp[0][n-1];\\n    }\\n\\n    private int maxVal(int[] arr, int low, int high){\\n        int max = Integer.MIN_VALUE;\\n        for (int i = low; i <= high; i++)\\n            max = Math.max(max, arr[i]);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  private int infi = Integer.MAX_VALUE/2;\\n    public int mctFromLeafValues(int[] arr) {\\n       if(arr == null || arr.length <= 1)\\n           return 0;\\n       int n = arr.length;\\n       int[][] dp = new int[n][n];\\n\\n       //len = 1\\n       for (int i = 0; i < n ; i++)\\n           dp[i][i] = 0;\\n\\n       //len = 2\\n       for (int i = 0; i < n-1; i++)\\n           dp[i][i+1] = arr[i]*arr[i+1];\\n\\n       //len 3 and above\\n       for (int len = 3; len  <= n; len++){\\n           for (int i = 0; i+len-1 <= n-1; i++){\\n               int j = i+len-1;\\n               dp[i][j] = infi;\\n               for (int k = i; k <j ; k++){\\n                   dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j]+ maxVal(arr, i,k) * maxVal(arr, k+1, j));\\n               }\\n           }\\n       }\\n       return dp[0][n-1];\\n    }\\n\\n    private int maxVal(int[] arr, int low, int high){\\n        int max = Integer.MIN_VALUE;\\n        for (int i = low; i <= high; i++)\\n            max = Math.max(max, arr[i]);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006641,
                "title": "java-o-n-square-easily-understandable-solution-with-explanation",
                "content": "Imagine you are the organizer of a tournament for n players. The price you pay for a match is depends on the 2 players. One reasonable price for a match is price[player1]*price[player2], another price model price[player1] + price[player2] could also be reasonable, how we model it doesn\\'t matter, both price model go to the same direction. Now you want to arrange the matches until we have a champion. The goal is to minimize your cost.\\n\\nAs the organizer, you can do this. You find the weakest player that is still in the game, and will be eliminated in the next match. In order to pay less for that match, you want to choose the weakest opponent possible. With the constraint that \"Given an array of n positive integers, the values in the array map to the leaves of a binary search tree from left to right.\", you can only choose the opponent next to the weakest player (left or right). So, in order to remove a[i] from the game array a, you need to pick min(a[i-1], a[i+1]), the cost for this match will be a[i] * min(a[i-1], a[i+1]). Keep doing this, we can find the matching arrangement with minimum cost. As a bonus you probably get the highest watching rates because this arrangement favors close matches!\\n\\n![image](https://assets.leetcode.com/users/images/5d4c243f-6012-41de-80c4-6b48a850e0c5_1610048318.016361.png)\\n\\n\\n```\\nclass Solution {\\n  public int mctFromLeafValues(int[] A) {\\n    int cost = 0;\\n    int N = A.length;\\n    while(N > 1) {\\n      int ko = findMin(A, N);\\n      cost += A[ko] * minNeighbor(A, ko, N);\\n      removeElement(A, ko, N);\\n      N--;\\n    }\\n    return cost;\\n  }\\n\\n  private static int minNeighbor(int[] a, int ko, int N) {\\n    if(ko - 1 >= 0 && ko + 1 < N) {\\n      return Math.min(a[ko-1], a[ko+1]);\\n    } else {\\n      if(ko - 1 < 0) return a[ko+1];\\n      else return a[ko-1];\\n    }\\n  }\\n\\n  private static void removeElement(int[] a, int ko, int N) {\\n    for(int i = ko; i < N-1; i++) {\\n      a[i] = a[i+1];\\n    }\\n  }\\n\\n  private static int findMin(int[] a, int N) {\\n    int min = Integer.MAX_VALUE;\\n    int index = 0;\\n    for(int i = 0; i < N; i++) {\\n      if(min > a[i]) {\\n        min = a[i];\\n        index = i;\\n      }\\n    }\\n    return index;\\n  }\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int mctFromLeafValues(int[] A) {\\n    int cost = 0;\\n    int N = A.length;\\n    while(N > 1) {\\n      int ko = findMin(A, N);\\n      cost += A[ko] * minNeighbor(A, ko, N);\\n      removeElement(A, ko, N);\\n      N--;\\n    }\\n    return cost;\\n  }\\n\\n  private static int minNeighbor(int[] a, int ko, int N) {\\n    if(ko - 1 >= 0 && ko + 1 < N) {\\n      return Math.min(a[ko-1], a[ko+1]);\\n    } else {\\n      if(ko - 1 < 0) return a[ko+1];\\n      else return a[ko-1];\\n    }\\n  }\\n\\n  private static void removeElement(int[] a, int ko, int N) {\\n    for(int i = ko; i < N-1; i++) {\\n      a[i] = a[i+1];\\n    }\\n  }\\n\\n  private static int findMin(int[] a, int N) {\\n    int min = Integer.MAX_VALUE;\\n    int index = 0;\\n    for(int i = 0; i < N; i++) {\\n      if(min > a[i]) {\\n        min = a[i];\\n        index = i;\\n      }\\n    }\\n    return index;\\n  }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947301,
                "title": "java-greedy-based-on-huffman-coding-beats-100",
                "content": "Unlike optimal huffman coding, we cannot choose any 2 values as leaf nodes and start \"merging\" them. But still, after drawing out some examples, it becomes clear that choosing the minimum first makes more sense in a greedy method. Thus we repeat below steps till a single node remains (which is our root). I use a Doubly Linked List in order to represent an array for O(1) removal.\\n\\n1. Pick up the leaf node with minimum value.\\n2. Combine it with its inorder neighbor which has smaller value between neighbors.\\n3. Once we get the new generated non-leaf node, the node with minimum value is useless (For the new generated subtree will be represented with the largest leaf node value.)\\n4. Repeat it until there is only one node.\\n\\n```\\nclass ListNode{\\n    Integer val;\\n    ListNode next;\\n    ListNode prev;\\n    public ListNode(int value){\\n        this.val = value;\\n    }\\n    public ListNode(){}\\n    public String toString(){ return this.val+\"\"; }\\n}\\n\\nclass Solution {\\n    ListNode head;\\n    ListNode tail;\\n    public int mctFromLeafValues(int[] arr) {\\n        head = new ListNode();\\n        tail = new ListNode();\\n        convertToDoublyLinkedList(arr); //O(n) time and O(n) space\\n        \\n        int sum = 0;\\n        int left = arr.length;\\n        while(left-- != 1){ // O(n) time\\n            // find minimum of the LinkedList\\n            ListNode min = findMin(); // O(n) time\\n            \\n            // find min left and right neighbour\\n            int minRightVal = min.next == tail ? Integer.MAX_VALUE: min.next.val;\\n            int minLeftVal = min.prev == head ? Integer.MAX_VALUE: min.prev.val;\\n            sum += Math.min(minLeftVal, minRightVal) * min.val;\\n            \\n            remove(min); // O(1) time\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private void remove(ListNode node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    private ListNode findMin(){\\n        ListNode curr = head.next;\\n        ListNode min = null;\\n        int minVal = Integer.MAX_VALUE;\\n        \\n        while(curr != tail){\\n            if(curr.val < minVal){\\n                minVal = curr.val;\\n                min = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return min;\\n    }\\n    \\n    private void convertToDoublyLinkedList(int[] arr){\\n        ListNode prev = head;\\n        for(int num: arr){\\n            ListNode curr = new ListNode(num);\\n            prev.next = curr;\\n            curr.prev = prev;\\n            prev = curr;\\n        }\\n        \\n        prev.next = tail;\\n        tail.prev = prev;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass ListNode{\\n    Integer val;\\n    ListNode next;\\n    ListNode prev;\\n    public ListNode(int value){\\n        this.val = value;\\n    }\\n    public ListNode(){}\\n    public String toString(){ return this.val+\"\"; }\\n}\\n\\nclass Solution {\\n    ListNode head;\\n    ListNode tail;\\n    public int mctFromLeafValues(int[] arr) {\\n        head = new ListNode();\\n        tail = new ListNode();\\n        convertToDoublyLinkedList(arr); //O(n) time and O(n) space\\n        \\n        int sum = 0;\\n        int left = arr.length;\\n        while(left-- != 1){ // O(n) time\\n            // find minimum of the LinkedList\\n            ListNode min = findMin(); // O(n) time\\n            \\n            // find min left and right neighbour\\n            int minRightVal = min.next == tail ? Integer.MAX_VALUE: min.next.val;\\n            int minLeftVal = min.prev == head ? Integer.MAX_VALUE: min.prev.val;\\n            sum += Math.min(minLeftVal, minRightVal) * min.val;\\n            \\n            remove(min); // O(1) time\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private void remove(ListNode node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    private ListNode findMin(){\\n        ListNode curr = head.next;\\n        ListNode min = null;\\n        int minVal = Integer.MAX_VALUE;\\n        \\n        while(curr != tail){\\n            if(curr.val < minVal){\\n                minVal = curr.val;\\n                min = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return min;\\n    }\\n    \\n    private void convertToDoublyLinkedList(int[] arr){\\n        ListNode prev = head;\\n        for(int num: arr){\\n            ListNode curr = new ListNode(num);\\n            prev.next = curr;\\n            curr.prev = prev;\\n            prev = curr;\\n        }\\n        \\n        prev.next = tail;\\n        tail.prev = prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895046,
                "title": "java-greedy-using-array-beat-100",
                "content": "Amazing and interesting question. My first response is backtracking + stack, but actually using Greedy can easily solve this. Have no idea how DP would work for this.\\n\\nSay for arr [5, 2, 3, 4]\\nMy first response would be just like adding parenthesis for different combination, like\\n(((5, 2), 3), 4), so collapse 5 and 2, the result will collapse with 3\\nAnother possibility (5,(2,(3,4))).\\nPay attention the number should be in order.\\n\\nBecause the biggest number of subtree will be calculated multiple time for product, so we should always try to pair with the smallest bigger number.\\nSo it\\'ll be (5,2), (2, 3), (3, 4); and we\\'ll choose (2, 3), plus product 2 * 3 = 6 into sum, then collalpse (2, 3) into 3, then array becomes [5, 3, 4], actually [5, 0, 3, 4], where we\\'ll skip zero. Then we can do this until there\\'s only one number > 0 left in array.\\n\\nBecause it\\'s only manipulating one single array, so beat 100%\\n\\n```\\nclass Solution {\\n    int sum = 0;\\n    public int mctFromLeafValues(int[] arr) {\\n        while (!oneZero(arr)) {\\n            findMin(arr);\\n        }\\n        return sum;\\n    }\\n    \\n    // For each traverse, find the two-num pair with smallest bigger num.\\n    private void findMin(int[] arr) {\\n        int firIdx = 0, secIdx = 0;\\n        int r1 = 0, r2 = 0; // result\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] != 0) {\\n                firIdx = i;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = firIdx + 1; i < arr.length; i++) {\\n            if (arr[i] == 0) continue;\\n            // The next neighbor.\\n            secIdx = i;\\n            int bigger = Math.max(arr[firIdx], arr[secIdx]);\\n            if (bigger < min) { // Find the two-num pair with smallest bigger num\\n                min = bigger;\\n                r1 = firIdx;\\n                r2 = secIdx;\\n            }\\n            firIdx = secIdx;\\n        }\\n        \\n        // non-leaf node val equals to product\\n        sum += arr[r1] * arr[r2];\\n        // Reset whichever smaller to zero so next step we\\'ll skip.\\n        if (arr[r1] < arr[r2]) arr[r1] = 0;\\n        else arr[r2] = 0;\\n    }\\n    \\n    // Find until there\\'s only one int left in array.\\n    private boolean oneZero(int[] arr) {\\n        int count = 0;\\n        for (int num : arr) {\\n            if (num > 0) count++;\\n        }\\n        return count == 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int mctFromLeafValues(int[] arr) {\\n        while (!oneZero(arr)) {\\n            findMin(arr);\\n        }\\n        return sum;\\n    }\\n    \\n    // For each traverse, find the two-num pair with smallest bigger num.\\n    private void findMin(int[] arr) {\\n        int firIdx = 0, secIdx = 0;\\n        int r1 = 0, r2 = 0; // result\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] != 0) {\\n                firIdx = i;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = firIdx + 1; i < arr.length; i++) {\\n            if (arr[i] == 0) continue;\\n            // The next neighbor.\\n            secIdx = i;\\n            int bigger = Math.max(arr[firIdx], arr[secIdx]);\\n            if (bigger < min) { // Find the two-num pair with smallest bigger num\\n                min = bigger;\\n                r1 = firIdx;\\n                r2 = secIdx;\\n            }\\n            firIdx = secIdx;\\n        }\\n        \\n        // non-leaf node val equals to product\\n        sum += arr[r1] * arr[r2];\\n        // Reset whichever smaller to zero so next step we\\'ll skip.\\n        if (arr[r1] < arr[r2]) arr[r1] = 0;\\n        else arr[r2] = 0;\\n    }\\n    \\n    // Find until there\\'s only one int left in array.\\n    private boolean oneZero(int[] arr) {\\n        int count = 0;\\n        for (int num : arr) {\\n            if (num > 0) count++;\\n        }\\n        return count == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888406,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int MctFromLeafValues(int[] arr) {\\n        int len = arr.Length;\\n        int[,] max = new int[len, len];\\n        for (int i = 0; i < len; i++) \\n            max[i, i] = arr[i];\\n        \\n        for (int i = 0; i < len; i++)\\n        {\\n            for (int j = i + 1; j < len; j++)\\n            {\\n                max[i,j] = Math.Max(max[i, j - 1], arr[j]);\\n            }\\n        }\\n        \\n        int[,] dp = new int[len, len];\\n        for (int i = 0; i + 1 < len; i++)\\n            dp[i, i + 1] = arr[i] * arr[i + 1];\\n        \\n         for (int l = 2; l <= len; l++)\\n            {\\n                for (int i = 0; i < len - l; i++)\\n                {\\n                    int minCost = int.MaxValue;\\n                    int j = i + l;\\n                    for (int k = i; k < j; k++)\\n                    {\\n                        int temp = dp[i,k] + dp[k + 1, j] + (max[i,k] * max[k + 1, j]);\\n                        minCost = Math.Min(minCost, temp);\\n                    }\\n                    dp[i, j] = minCost;\\n                }\\n            }\\n        return dp[0, len - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int MctFromLeafValues(int[] arr) {\\n        int len = arr.Length;\\n        int[,] max = new int[len, len];\\n        for (int i = 0; i < len; i++) \\n            max[i, i] = arr[i];\\n        \\n        for (int i = 0; i < len; i++)\\n        {\\n            for (int j = i + 1; j < len; j++)\\n            {\\n                max[i,j] = Math.Max(max[i, j - 1], arr[j]);\\n            }\\n        }\\n        \\n        int[,] dp = new int[len, len];\\n        for (int i = 0; i + 1 < len; i++)\\n            dp[i, i + 1] = arr[i] * arr[i + 1];\\n        \\n         for (int l = 2; l <= len; l++)\\n            {\\n                for (int i = 0; i < len - l; i++)\\n                {\\n                    int minCost = int.MaxValue;\\n                    int j = i + l;\\n                    for (int k = i; k < j; k++)\\n                    {\\n                        int temp = dp[i,k] + dp[k + 1, j] + (max[i,k] * max[k + 1, j]);\\n                        minCost = Math.Min(minCost, temp);\\n                    }\\n                    dp[i, j] = minCost;\\n                }\\n            }\\n        return dp[0, len - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864430,
                "title": "dynamic-programming-method-explanation-video",
                "content": "I found a nice video that explain with great details how to resolve an algorithms like this (Yeah, its long. But it\\'s woth if you want to understand DP).\\n\\nhttps://www.youtube.com/watch?v=_WncuhSJZyA\\n\\nI also put my code, if you understand the video the code will result actually not that hard. \\nHope it helps somebody. \\nPlease comment if see any error, improvement or if you dont understand something :)\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        //Creating and filling DP table with the initial values (all value-pair multiplication)\\n        vector<vector<int>> dp(arr.size(), vector<int>(arr.size()));\\n        for(size_t i{ 0 }, j{ 1 }; j < arr.size(); ++i, ++j) dp[i][j] = arr[i] * arr[j];\\n        \\n        //Creation of auxiliar array with max elements (for example for array {2,3,4,5} max_elem[0][0] means max element from posiion 0\\n        // to position 0 and is the value 2. And max_elem[0][3] means max element from position 0 to position 3 and its the value 5)\\n        vector<vector<int>> max_el(arr.size(), vector<int>(arr.size()));\\n        for(size_t i{ 0 }; i < arr.size(); ++i) max_el[i][i] = arr[i];\\n        for(size_t i{ 0 }; i < arr.size(); ++i)\\n            for(size_t j{ i + 1}; j < arr.size(); ++j)\\n                max_el[i][j] = *max_element(arr.begin() + i, arr.begin() + j + 1);\\n        \\n        //The dynamic programming logic (which is explained in the video) You should understand it clearly if you watch the video\\n        for(size_t i{ 2 }; i < arr.size(); ++i)\\n            for(size_t j{ 0 }, k{ i }; k < arr.size(); ++j, ++k)\\n            {\\n                int min_val{ numeric_limits<int>::max() };\\n                for(size_t m{ j }; m < k; ++m)\\n                {\\n                    int val{ max_el[j][m] * max_el[m + 1][k] + ((j == m) ? 0 : dp[j][m]) + ((m + 1 == k) ? 0 : dp[m + 1][k]) };\\n                    if(min_val > val) min_val = val;\\n                }\\n                dp[j][k] = min_val;\\n            }\\n        return dp[0][arr.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        //Creating and filling DP table with the initial values (all value-pair multiplication)\\n        vector<vector<int>> dp(arr.size(), vector<int>(arr.size()));\\n        for(size_t i{ 0 }, j{ 1 }; j < arr.size(); ++i, ++j) dp[i][j] = arr[i] * arr[j];\\n        \\n        //Creation of auxiliar array with max elements (for example for array {2,3,4,5} max_elem[0][0] means max element from posiion 0\\n        // to position 0 and is the value 2. And max_elem[0][3] means max element from position 0 to position 3 and its the value 5)\\n        vector<vector<int>> max_el(arr.size(), vector<int>(arr.size()));\\n        for(size_t i{ 0 }; i < arr.size(); ++i) max_el[i][i] = arr[i];\\n        for(size_t i{ 0 }; i < arr.size(); ++i)\\n            for(size_t j{ i + 1}; j < arr.size(); ++j)\\n                max_el[i][j] = *max_element(arr.begin() + i, arr.begin() + j + 1);\\n        \\n        //The dynamic programming logic (which is explained in the video) You should understand it clearly if you watch the video\\n        for(size_t i{ 2 }; i < arr.size(); ++i)\\n            for(size_t j{ 0 }, k{ i }; k < arr.size(); ++j, ++k)\\n            {\\n                int min_val{ numeric_limits<int>::max() };\\n                for(size_t m{ j }; m < k; ++m)\\n                {\\n                    int val{ max_el[j][m] * max_el[m + 1][k] + ((j == m) ? 0 : dp[j][m]) + ((m + 1 == k) ? 0 : dp[m + 1][k]) };\\n                    if(min_val > val) min_val = val;\\n                }\\n                dp[j][k] = min_val;\\n            }\\n        return dp[0][arr.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853691,
                "title": "c-two-methods-tabulation-dp-and-top-down-memoization-recursion",
                "content": "Tabulation\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxi[n][n];\\n        memset(maxi,0,sizeof(maxi));\\n        for(int i=0;i<n;i++)maxi[i][i]=arr[i];\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                maxi[i][j]=max(maxi[i][j-1],maxi[i+1][j]);\\n            }\\n        }\\n        \\n        int dp[n+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                dp[i][j]=INT_MAX;\\n                for(int k=i;k<j;k++)\\n                {\\n                    dp[i][j]=min(dp[i][j],maxi[i][k]*maxi[k+1][j]+dp[i][k]+dp[k+1][j]);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```\\nMemoization\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> maxi;\\n    vector<vector<int>> dp;\\n    int solve(int i,int j)\\n    {\\n        if(i==j)\\n            return dp[i][i]=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        dp[i][j]=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n            dp[i][j]=min(dp[i][j] ,\\n                         solve(i,k) + solve(k+1,j) + maxi[i][k]*maxi[k+1][j] );\\n        }\\n        return dp[i][j];\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        maxi.resize(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++)maxi[i][i]=arr[i];\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                maxi[i][j]=max(maxi[i][j-1],maxi[i+1][j]);\\n            }\\n        }\\n        \\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        return solve(0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxi[n][n];\\n        memset(maxi,0,sizeof(maxi));\\n        for(int i=0;i<n;i++)maxi[i][i]=arr[i];\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                maxi[i][j]=max(maxi[i][j-1],maxi[i+1][j]);\\n            }\\n        }\\n        \\n        int dp[n+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                dp[i][j]=INT_MAX;\\n                for(int k=i;k<j;k++)\\n                {\\n                    dp[i][j]=min(dp[i][j],maxi[i][k]*maxi[k+1][j]+dp[i][k]+dp[k+1][j]);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> maxi;\\n    vector<vector<int>> dp;\\n    int solve(int i,int j)\\n    {\\n        if(i==j)\\n            return dp[i][i]=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        dp[i][j]=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n            dp[i][j]=min(dp[i][j] ,\\n                         solve(i,k) + solve(k+1,j) + maxi[i][k]*maxi[k+1][j] );\\n        }\\n        return dp[i][j];\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        maxi.resize(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++)maxi[i][i]=arr[i];\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                maxi[i][j]=max(maxi[i][j-1],maxi[i+1][j]);\\n            }\\n        }\\n        \\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        return solve(0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847807,
                "title": "bottom-up-dp-c-solution-n-3-time-and-n-2-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        vector<vector<int>> maxi(n,vector<int>(n,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            maxi[i][i]=arr[i];\\n        }\\n        \\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                \\n                maxi[i][j]=max(maxi[i][j-1],maxi[i+1][j]);\\n            }\\n        }\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        \\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                dp[i][j]=INT_MAX;\\n                for(int k=i;k<j;k++)\\n                {\\n                    dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+maxi[i][k]*maxi[k+1][j]);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        vector<vector<int>> maxi(n,vector<int>(n,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            maxi[i][i]=arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 760467,
                "title": "java-o-n-time-and-o-n-space",
                "content": "This is first time I am posting something\\nIt took O(n) space and O(n) time\\n\\nThe idea is:\\n1. mid guy has an option to choose if it\\'s right is smaller or it\\'s left is biggest among three\\n2. Check this first and if mid guy has no option just multiply this with it\\'s left\\n3. Now if this is not the case then store all three\\n4. now check the next element with the last two stored value and do the same operation\\n5. Don\\'t stop after the single operation, keep on doing it until you can.\\n\\nExample:\\n\\n15 13 3 5 15\\n\\nnow pick first 3 : 15, (13), 3  ===> mid guy can choose\\n\\nso move on to next i.e. 5\\n\\nnow you have: 13, (3), 5 ===> mid guy again can choose\\n\\nso move on to next i.e. 15\\n\\nnow you have: 3, (5), 15 ===> Finally! mid guy has no option\\n\\nmultiply 3 and 5 => 15\\ntotal  = 15\\n\\n\\npick max = 5\\n\\nrearrange the list (use stack)\\n\\n15 13 5 15\\n\\nnot check again the last three and dont move forward for now\\n\\nnow you have: 13 (5) 15 ===> mid guy has no option\\n\\nmultiply 13 and 5 => 65 + total\\ntotal 80\\n\\npick max = 13\\n\\nrearrange the list\\n\\n15 13  15\\n\\nnot check again the last three and dont move forward for now\\n\\nnow you have: 15 (13) 15 ===> mid guy has no option\\n\\nmultiply 15 and 13 => 195 + total\\ntotal 275\\n\\npick max = 15\\n\\n15 15\\nnow you can not do this as stack has less than 3 size\\n\\nmove forward and array is empty\\n\\n15 15\\npop out from stack and save it as max\\nmax = 15\\nwhile you stack is not empty\\nvalue  = stack pop (15)\\ntotal += value*max (300)\\nmax = max(value, max) (15)\\n\\nI hope its a bit clear this way\\n\\n\\n\\n```\\n// Code\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {        \\n        Stack<Integer> st = new Stack();\\n        int result = 0;\\n        \\n        for(int i=0; i<arr.length; i++) {\\n            st.push(arr[i]);\\n            while(!st.isEmpty() && st.size()>2) {\\n                int n3 = st.pop();\\n                int n2 = st.pop();\\n                int n1 = st.pop();\\n                if((n1<=n3 || n1<=n2) && n2<=n3) {\\n                    result += n1*n2;\\n                    n1 = Math.max(n1,n2);\\n                    st.push(n1);\\n                    st.push(n3);\\n                }else{\\n                    st.push(n1);\\n                    st.push(n2);\\n                    st.push(n3);\\n                    break;\\n                }\\n            }\\n        }\\n                \\n        int max = st.pop();\\n        while(!st.isEmpty()) {\\n            int current = st.pop();\\n            result += max*current;\\n            max = Math.max(max,current);\\n        }\\n        return result;\\n     }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Code\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {        \\n        Stack<Integer> st = new Stack();\\n        int result = 0;\\n        \\n        for(int i=0; i<arr.length; i++) {\\n            st.push(arr[i]);\\n            while(!st.isEmpty() && st.size()>2) {\\n                int n3 = st.pop();\\n                int n2 = st.pop();\\n                int n1 = st.pop();\\n                if((n1<=n3 || n1<=n2) && n2<=n3) {\\n                    result += n1*n2;\\n                    n1 = Math.max(n1,n2);\\n                    st.push(n1);\\n                    st.push(n3);\\n                }else{\\n                    st.push(n1);\\n                    st.push(n2);\\n                    st.push(n3);\\n                    break;\\n                }\\n            }\\n        }\\n                \\n        int max = st.pop();\\n        while(!st.isEmpty()) {\\n            int current = st.pop();\\n            result += max*current;\\n            max = Math.max(max,current);\\n        }\\n        return result;\\n     }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758560,
                "title": "simple-c-solution-without-dp-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //if(arr.size() == 2) return arr[0]*arr[1];\\n        int sum = 0;\\n        while(arr.size() != 1){\\n            int i = 1,j = 0;\\n            \\n            for(i;i < arr.size()-1;i++)      // find minimum product of two consecutive number\\n                if(arr[i]*arr[i + 1] < arr[j]*arr[j + 1]) \\n                    j = i;\\n            \\n            sum += arr[j]*arr[j+1];\\n            \\n            // remove minimum one from that two consecutive number\\n            if(arr[j] > arr[j+1]) arr.erase(arr.begin() + j + 1);\\n            else arr.erase(arr.begin() + j);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //if(arr.size() == 2) return arr[0]*arr[1];\\n        int sum = 0;\\n        while(arr.size() != 1){\\n            int i = 1,j = 0;\\n            \\n            for(i;i < arr.size()-1;i++)      // find minimum product of two consecutive number\\n                if(arr[i]*arr[i + 1] < arr[j]*arr[j + 1]) \\n                    j = i;\\n            \\n            sum += arr[j]*arr[j+1];\\n            \\n            // remove minimum one from that two consecutive number\\n            if(arr[j] > arr[j+1]) arr.erase(arr.begin() + j + 1);\\n            else arr.erase(arr.begin() + j);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753817,
                "title": "simple-easy-to-understand",
                "content": "```\\nans = 0\\nwhile len(arr) > 1:\\n\\t# Find the consecutive pair of leaves j and j+1 with the smallest product\\n\\tj = 0\\n\\tfor i in range(1, len(arr)-1):\\n\\t\\tif arr[i]*arr[i+1] < arr[j]*arr[j+1]:\\n\\t\\t\\tj = i\\n\\tans += arr[j]*arr[j+1]\\n\\n\\t# Remove the largest of j and j+1 from arr\\n\\tarr = arr[:j] + [max(arr[j], arr[j+1])] + arr[j+2:]\\n\\nreturn ans\\n```",
                "solutionTags": [],
                "code": "```\\nans = 0\\nwhile len(arr) > 1:\\n\\t# Find the consecutive pair of leaves j and j+1 with the smallest product\\n\\tj = 0\\n\\tfor i in range(1, len(arr)-1):\\n\\t\\tif arr[i]*arr[i+1] < arr[j]*arr[j+1]:\\n\\t\\t\\tj = i\\n\\tans += arr[j]*arr[j+1]\\n\\n\\t# Remove the largest of j and j+1 from arr\\n\\tarr = arr[:j] + [max(arr[j], arr[j+1])] + arr[j+2:]\\n\\nreturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 679197,
                "title": "summary-of-the-3-main-solutions-concise-yet-clear-python",
                "content": "Code and commentary adapted from [Summary of all the solutions I have learned from Discuss in Python](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/478708/RZ-Summary-of-all-the-solutions-I-have-learned-from-Discuss-in-Python). Please refer to that or [Summary and reasoning of different solutions](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340489/Summary-and-reasoning-of-different-solutions) for full explanation.\\n\\nConcise overview written mainly for my future review\\n\\n```\\nclass Solution:\\n    def mctFromLeafValues_DP(self, arr: List[int]) -> int:\\n        \"\"\"\\n        We split subtrees by splitting the list, since it\\'s given as in-order traversal\\n        DP, O(N^3) time, O(N^2) space\\n        \"\"\"\\n        @lru_cache(None)\\n        def dp(l, r):\\n            if l + 1 >= r:  # base case: only one value = leaf\\n                return 0    # leaf only contribs value to rootVal\\n            ans = float(\\'inf\\')\\n            for j in range(l+1, r): # for each split (start of second array)\\n                rootVal = max(arr[l:j]) * max(arr[j:r])\\n                ans = min(ans, rootVal + dp(l,j) + dp(j, r))\\n            return ans\\t# solution for the arr[l:r] subtree\\n        return dp(0, len(arr))\\n\\n    def mctFromLeafValues_Greedy(self, arr: List[int]) -> int:\\n        \"\"\"\\n        We want the smallest values to be deepest in the tree (so they are used most, as they led to smaller parent values).\\n        Greedy, O(N^2)\\n        \"\"\"\\n        res = 0\\n        # While pairs are left, use the smallest-val index & smallest neighbor\\n        while len(arr) > 1:\\n            ind = arr.index(min(arr))\\n            if ind == 0:\\n\\t\\t\\t\\tres += arr[ind] * arr[ind+1]\\t# edge case\\n            elif ind == len(arr)-1:\\n\\t\\t\\t\\tres += arr[ind] * arr[ind-1]\\t# edge case\\n            else:\\n\\t\\t\\t\\tres += arr[ind] * min(arr[ind+1], arr[ind-1])\\n            arr.pop(ind) \\n        return res\\n      \\n    def mctFromLeafValues_MonotonicStack(self, arr: List[int]) -> int:\\n        \"\"\"\\n        Instead of repeatedly finding the smallest element index, we can use a stack -- time: O(N), space: O(N)\\n        \"\"\"\\n        res = 0\\n        st = [float(\\'inf\\')]\\n        # While pairs are left, use the smallest-val index & smallest neighbor\\n        for num in arr:\\n            while st and num >= st[-1]: # remove all local minimums\\n                res += st.pop() * min(st[-1], num)\\n            st.append(num)\\n        while len(st) > 2:\\n            res += st.pop() * st[-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues_DP(self, arr: List[int]) -> int:\\n        \"\"\"\\n        We split subtrees by splitting the list, since it\\'s given as in-order traversal\\n        DP, O(N^3) time, O(N^2) space\\n        \"\"\"\\n        @lru_cache(None)\\n        def dp(l, r):\\n            if l + 1 >= r:  # base case: only one value = leaf\\n                return 0    # leaf only contribs value to rootVal\\n            ans = float(\\'inf\\')\\n            for j in range(l+1, r): # for each split (start of second array)\\n                rootVal = max(arr[l:j]) * max(arr[j:r])\\n                ans = min(ans, rootVal + dp(l,j) + dp(j, r))\\n            return ans\\t# solution for the arr[l:r] subtree\\n        return dp(0, len(arr))\\n\\n    def mctFromLeafValues_Greedy(self, arr: List[int]) -> int:\\n        \"\"\"\\n        We want the smallest values to be deepest in the tree (so they are used most, as they led to smaller parent values).\\n        Greedy, O(N^2)\\n        \"\"\"\\n        res = 0\\n        # While pairs are left, use the smallest-val index & smallest neighbor\\n        while len(arr) > 1:\\n            ind = arr.index(min(arr))\\n            if ind == 0:\\n\\t\\t\\t\\tres += arr[ind] * arr[ind+1]\\t# edge case\\n            elif ind == len(arr)-1:\\n\\t\\t\\t\\tres += arr[ind] * arr[ind-1]\\t# edge case\\n            else:\\n\\t\\t\\t\\tres += arr[ind] * min(arr[ind+1], arr[ind-1])\\n            arr.pop(ind) \\n        return res\\n      \\n    def mctFromLeafValues_MonotonicStack(self, arr: List[int]) -> int:\\n        \"\"\"\\n        Instead of repeatedly finding the smallest element index, we can use a stack -- time: O(N), space: O(N)\\n        \"\"\"\\n        res = 0\\n        st = [float(\\'inf\\')]\\n        # While pairs are left, use the smallest-val index & smallest neighbor\\n        for num in arr:\\n            while st and num >= st[-1]: # remove all local minimums\\n                res += st.pop() * min(st[-1], num)\\n            st.append(num)\\n        while len(st) > 2:\\n            res += st.pop() * st[-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654858,
                "title": "c-concise-greedy-approach",
                "content": "Greedy approach- Always choose those 2 leaf nodes that forms the smallest parent node.\\nThe smaller node of the two chosen leaf nodes is erased  \\n\\nclass Solution {\\npublic:\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n      int sum=0;\\n      while(arr.size()>=2)\\n      {\\n          int minproduct=INT_MAX;int pos;\\n          for(int i=0;i<arr.size()-1;i++)\\n          {\\n              if(arr[i]*arr[i+1]<minproduct)\\n              {\\n                  pos=i;\\n                  minproduct=arr[i]*arr[i+1];\\n              }\\n          }\\n          sum+=minproduct;\\n          if(arr[pos]<arr[pos+1]) arr.erase(arr.begin()+pos);\\n          else arr.erase(arr.begin()+(pos+1));\\n      }\\n    return sum;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n      int sum=0;\\n      while(arr.size()>=2)\\n      {\\n          int minproduct=INT_MAX;int pos;\\n          for(int i=0;i<arr.size()-1;i++)\\n          {\\n              if(arr[i]*arr[i+1]<minproduct)\\n              {\\n                  pos=i;\\n                  minproduct=arr[i]*arr[i+1];\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 640213,
                "title": "c-dp-solution-similar-to-matrix-chain-multiplication",
                "content": "```\\nclass Solution {\\n    vector<vector<int>>maxi;\\n    vector<vector<int>>dp;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) { \\n        int n = arr.size();\\n        maxi.resize(n, vector<int>(n));\\n        dp.resize(n, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            maxi[i][i] = arr[i];\\n            for (int j = i+1; j < n; j++) {\\n                maxi[i][j] = max(maxi[i][j-1], arr[j]);\\n            }\\n        }\\n        \\n        for (int L = 1; L < n; L++) {\\n            for (int i = 0; i+L < n; i++) {\\n                int j = i+L;\\n                if (L == 1) {\\n                    dp[i][j] = arr[i]*arr[j];\\n                } else {\\n                    dp[i][j] = INT_MAX;\\n                    for (int k = i; k < j; k++) {\\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxi[i][k]*maxi[k+1][j]);    \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>>maxi;\\n    vector<vector<int>>dp;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) { \\n        int n = arr.size();\\n        maxi.resize(n, vector<int>(n));\\n        dp.resize(n, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            maxi[i][i] = arr[i];\\n            for (int j = i+1; j < n; j++) {\\n                maxi[i][j] = max(maxi[i][j-1], arr[j]);\\n            }\\n        }\\n        \\n        for (int L = 1; L < n; L++) {\\n            for (int i = 0; i+L < n; i++) {\\n                int j = i+L;\\n                if (L == 1) {\\n                    dp[i][j] = arr[i]*arr[j];\\n                } else {\\n                    dp[i][j] = INT_MAX;\\n                    for (int k = i; k < j; k++) {\\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxi[i][k]*maxi[k+1][j]);    \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631202,
                "title": "python-dynamic-programming-matrix-chain-multiplication-easy-to-understand",
                "content": "```py\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        # Using matrix-chain-multiplication technique\\n        \\'\\'\\'\\n        Looking at the problem, Matrix-Chain-Multiplication was the first thing that came to my mind\\n        Here, I\\'ve tried a bottom-up approach of matrix-chain-multiplication, so follow along\\n        (Not the best structured explanation though)\\n        \\n        So, the sub-problem can be stated as:\\n        \\n          D(i: j) = minimum of { D(i: k) + D(k+1: j) + maximum_value(i: k) * maximum_value(k+1: j) for k in [i, j-1] }\\n          \\n          where D(i: j) is the optimal (minimum) sum of products of maximum leaf values (:\\\\) between i and j.\\n          \\n          and maximum_valud(i: j) = maximum of { maximum_value(i:j-1), arr[j]}\\n          \\n        If it went over your head, I don\\'t know an easier way to explain.\\n        \\n        I\\'ve build a 2D matrix, such that each cell stores the value\\n          \\n             dp[i][j] = (D(i:j), maximum_value(i:j))\\n        \\n        Now, code follows\\n        \\'\\'\\'\\n        \\n        dp = [[0 for i in range(len(arr))] for j in range(len(arr))]\\n        \\n        for i in range(len(arr)):\\n            dp[i][i] = (0, arr[i])\\n        \\n        # Refer to matrix-chain-multiplication (common structure)\\n        for v in range(1,len(arr)):\\n            for j in range(v, len(arr)):\\n                i = j - v\\n                D_i_j = min(dp[i][k][0] + dp[k+1][j][0] + dp[i][k][1] * dp[k+1][j][1] for k in range(i, j))\\n                M_i_j = max(dp[i][j-1][1], arr[j])\\n                \\n                dp[i][j] = (D_i_j, M_i_j)\\n        \\n        return dp[0][len(arr)-1][0]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```py\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        # Using matrix-chain-multiplication technique\\n        \\'\\'\\'\\n        Looking at the problem, Matrix-Chain-Multiplication was the first thing that came to my mind\\n        Here, I\\'ve tried a bottom-up approach of matrix-chain-multiplication, so follow along\\n        (Not the best structured explanation though)\\n        \\n        So, the sub-problem can be stated as:\\n        \\n          D(i: j) = minimum of { D(i: k) + D(k+1: j) + maximum_value(i: k) * maximum_value(k+1: j) for k in [i, j-1] }\\n          \\n          where D(i: j) is the optimal (minimum) sum of products of maximum leaf values (:\\\\) between i and j.\\n          \\n          and maximum_valud(i: j) = maximum of { maximum_value(i:j-1), arr[j]}\\n          \\n        If it went over your head, I don\\'t know an easier way to explain.\\n        \\n        I\\'ve build a 2D matrix, such that each cell stores the value\\n          \\n             dp[i][j] = (D(i:j), maximum_value(i:j))\\n        \\n        Now, code follows\\n        \\'\\'\\'\\n        \\n        dp = [[0 for i in range(len(arr))] for j in range(len(arr))]\\n        \\n        for i in range(len(arr)):\\n            dp[i][i] = (0, arr[i])\\n        \\n        # Refer to matrix-chain-multiplication (common structure)\\n        for v in range(1,len(arr)):\\n            for j in range(v, len(arr)):\\n                i = j - v\\n                D_i_j = min(dp[i][k][0] + dp[k+1][j][0] + dp[i][k][1] * dp[k+1][j][1] for k in range(i, j))\\n                M_i_j = max(dp[i][j-1][1], arr[j])\\n                \\n                dp[i][j] = (D_i_j, M_i_j)\\n        \\n        return dp[0][len(arr)-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631105,
                "title": "javascript-solution",
                "content": "```\\nvar mctFromLeafValues = function(arr) {\\n  const dp = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    dp[i] = [];\\n  }\\n  \\n  return treeBuilder(0, arr.length - 1);\\n  \\n  function treeBuilder(start, end) {\\n    \\n    if (start == end) {\\n      return 0;\\n    }\\n  \\n    if (dp[start][end]) {\\n      return dp[start][end];\\n    }\\n    \\n    let min = Number.MAX_VALUE;\\n    \\n    for (let i = start; i < end; i++) {\\n      const left = treeBuilder(start, i);\\n      const right = treeBuilder(i + 1, end);\\n      \\n      const maxLeft = Math.max(...arr.slice(start, i + 1));\\n      const maxRight = Math.max(...arr.slice(i + 1, end + 1));\\n       \\n      const rootVal = maxLeft * maxRight;\\n      \\n      min = Math.min(min, rootVal + left + right);\\n\\n    }\\n    \\n    dp[start][end] = min;\\n    return min;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar mctFromLeafValues = function(arr) {\\n  const dp = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    dp[i] = [];\\n  }\\n  \\n  return treeBuilder(0, arr.length - 1);\\n  \\n  function treeBuilder(start, end) {\\n    \\n    if (start == end) {\\n      return 0;\\n    }\\n  \\n    if (dp[start][end]) {\\n      return dp[start][end];\\n    }\\n    \\n    let min = Number.MAX_VALUE;\\n    \\n    for (let i = start; i < end; i++) {\\n      const left = treeBuilder(start, i);\\n      const right = treeBuilder(i + 1, end);\\n      \\n      const maxLeft = Math.max(...arr.slice(start, i + 1));\\n      const maxRight = Math.max(...arr.slice(i + 1, end + 1));\\n       \\n      const rootVal = maxLeft * maxRight;\\n      \\n      min = Math.min(min, rootVal + left + right);\\n\\n    }\\n    \\n    dp[start][end] = min;\\n    return min;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 628771,
                "title": "interview-dynamic-programming-or-greedy-algorithm-o-n-3-o-n-2-o-n-explanation",
                "content": "Approach - 1\\nUsing Dynamic Programming and Considering all possiblites.\\nTime Complexity = O(Len ^ 3)         Space Complexity = O(Len ^ 2)\\n```\\npublic int mctFromLeafValues(int[] arr) {\\n                if(arr==null || arr.length==0)return Integer.MIN_VALUE; // This is not possible as mentioned in constraints\\n                int[][] Maximum_Matrix=new int[arr.length][arr.length];// This will store the maximum value in array range from i-->j (both included)\\n                int[][] DP=new int[arr.length][arr.length];// This will store the answer to sub-problem (Remember if we are trying to partition the arr with a single leaf node on one side then its contribution would be 0)\\n                //Populating the Maximum_Matrix from arr\\n                for(int i=0;i<arr.length;i++){\\n                    int max=arr[i];\\n                    for(int j=i;j<arr.length;j++){\\n                        if(max<arr[j])\\n                            max=arr[j];\\n                        Maximum_Matrix[i][j]=max;\\n                    }\\n                }\\n                if(DEBUG){\\n                    for(int i=0;i<arr.length;i++){\\n                        for(int j=0;j<arr.length;j++){\\n                            System.out.print(Maximum_Matrix[i][j]+ \" \");\\n                        }\\n                        System.out.println();\\n                    }\\n                }\\n                // Populating the DP matrix from smaller sub-problems already evaluated and stored in dp arr\\n                // I am populating the DP matrix from principal diagonal towards the right top edge of the matrix\\n                // The principal value of DP matrix is 0 because I can\\'t make internal node out of it\\n                int i,j,Row=0,Col=1;    // Minimum 2 elements are present in the arr is ensured\\n                int iterations=(arr.length-1);  // populating all the diagonals just after principal diagonal\\n\\n                while(iterations!=0){\\n                    i=Row;j=Col;    // Starting diagnol type traversal from Row , Col\\n                    while ( (i!=arr.length) && (j!=arr.length) ){\\n                        int min_sum=Integer.MAX_VALUE;  // This is minimum possible sum of internal nodes\\n                        for(int partition=i;partition<j;partition++){   // This loop considers all partitions possible without making one side as null\\n                            // This is computing the so formed root node using maximum from left and right sub-trees respective maximum\\n                            // I already know the internal nodes in left subtree is DP[i][partition] and right subtree is DP[partition+1][j]\\n                            // justing adding the root node to left sub tree internal sum and right sub tree internal sum would give me sum for this sub-problem\\n                            int curr_sum=Maximum_Matrix[i][partition]*Maximum_Matrix[partition+1][j] + DP[i][partition] + DP[partition+1][j];\\n                            if(min_sum>curr_sum)\\n                                min_sum=curr_sum;\\n                        }\\n                        DP[i][j]=min_sum;\\n\\n                        i++;\\n                        j++;\\n                    }\\n                    Col++;\\n                    iterations--;\\n                }\\n\\n\\n                return DP[0][arr.length-1];\\n    }\\n```\\n\\n Approach-2\\nUsing Greedy Technique of picking pair with smallest possible product and deleting the smaller element amoung that and using bigger one for further product.\\n\\n```\\n// TC is O(N^2)  SC is O(1)\\n    // The innermost while loops will run atmost 40 times in the worst case and could be ignored in this case **Better Alternative could be -->** You can use doubly linkedlist where you can delete smaller element in O(1) time and no need of skipping values\\n    public int mctFromLeafValues_Optimized(int[] arr) {\\n        if(arr==null || arr.length==0)return Integer.MAX_VALUE; // This is not possible as mentioned in constraints\\n        if(arr.length==1)return Integer.MAX_VALUE;\\n        int num_of_elements=arr.length;\\n        int cost=0;\\n        while(num_of_elements>1){\\n            int i=0,j=0;\\n            int min_index=0;\\n            int min_prod=Integer.MAX_VALUE;\\n            for(int k=0;k<num_of_elements-1;k++){\\n                if(i==j){\\n                    j++;\\n                }\\n                while(arr[i]==Integer.MAX_VALUE)            // This while loop is for skipping already deleted nodes    (These would not be there if you are using linkedlist implementation)\\n                    i++;\\n                while(arr[j]==Integer.MAX_VALUE || (i==j))  // This while loop is for skipping already deleted nodes.\\n                    j++;\\n                if(min_prod>(arr[i]*arr[j]) ){\\n                    min_prod=(arr[i]*arr[j]);\\n                    min_index=((arr[i]<arr[j])?i:j);\\n                }\\n                i=i+1;\\n                j=i+1;\\n            }\\n            cost+=min_prod;\\n            arr[min_index]=Integer.MAX_VALUE;\\n            num_of_elements--;\\n        }\\n        return cost;\\n    }\\n```\\nApproach-3\\nUsing stack\\n\\n This solution is very tricky\\n    *   References\\n    *   https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n    *   I am just trying to give an explanation for better understanding of the above code.\\n \\n```\\npublic int mctFromLeafValues_Most_Optimized(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);  // This is just a sentinal value to avoid keep checking the stack emptiness condition (Using this he is ensuring himself that no matter what stack would never be empty)\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();// This is just like picking the smallest element\\n                res += mid * Math.min(stack.peek(), a);// since current element is >=top implies the second min element could either be the element present in the top of the stack or incoming array element.\\n            }\\n            stack.push(a);// Doing similer to next greater element problem in which stack with descending values is maintained.\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();//Just doing last pass in case some elements are still no processed i:e we have delayed their processing by putting them into stack\\n        }\\n        return res;\\n    }\\n```\\nThank you and have a nice day :)",
                "solutionTags": [],
                "code": "```\\npublic int mctFromLeafValues(int[] arr) {\\n                if(arr==null || arr.length==0)return Integer.MIN_VALUE; // This is not possible as mentioned in constraints\\n                int[][] Maximum_Matrix=new int[arr.length][arr.length];// This will store the maximum value in array range from i-->j (both included)\\n                int[][] DP=new int[arr.length][arr.length];// This will store the answer to sub-problem (Remember if we are trying to partition the arr with a single leaf node on one side then its contribution would be 0)\\n                //Populating the Maximum_Matrix from arr\\n                for(int i=0;i<arr.length;i++){\\n                    int max=arr[i];\\n                    for(int j=i;j<arr.length;j++){\\n                        if(max<arr[j])\\n                            max=arr[j];\\n                        Maximum_Matrix[i][j]=max;\\n                    }\\n                }\\n                if(DEBUG){\\n                    for(int i=0;i<arr.length;i++){\\n                        for(int j=0;j<arr.length;j++){\\n                            System.out.print(Maximum_Matrix[i][j]+ \" \");\\n                        }\\n                        System.out.println();\\n                    }\\n                }\\n                // Populating the DP matrix from smaller sub-problems already evaluated and stored in dp arr\\n                // I am populating the DP matrix from principal diagonal towards the right top edge of the matrix\\n                // The principal value of DP matrix is 0 because I can\\'t make internal node out of it\\n                int i,j,Row=0,Col=1;    // Minimum 2 elements are present in the arr is ensured\\n                int iterations=(arr.length-1);  // populating all the diagonals just after principal diagonal\\n\\n                while(iterations!=0){\\n                    i=Row;j=Col;    // Starting diagnol type traversal from Row , Col\\n                    while ( (i!=arr.length) && (j!=arr.length) ){\\n                        int min_sum=Integer.MAX_VALUE;  // This is minimum possible sum of internal nodes\\n                        for(int partition=i;partition<j;partition++){   // This loop considers all partitions possible without making one side as null\\n                            // This is computing the so formed root node using maximum from left and right sub-trees respective maximum\\n                            // I already know the internal nodes in left subtree is DP[i][partition] and right subtree is DP[partition+1][j]\\n                            // justing adding the root node to left sub tree internal sum and right sub tree internal sum would give me sum for this sub-problem\\n                            int curr_sum=Maximum_Matrix[i][partition]*Maximum_Matrix[partition+1][j] + DP[i][partition] + DP[partition+1][j];\\n                            if(min_sum>curr_sum)\\n                                min_sum=curr_sum;\\n                        }\\n                        DP[i][j]=min_sum;\\n\\n                        i++;\\n                        j++;\\n                    }\\n                    Col++;\\n                    iterations--;\\n                }\\n\\n\\n                return DP[0][arr.length-1];\\n    }\\n```\n```\\n// TC is O(N^2)  SC is O(1)\\n    // The innermost while loops will run atmost 40 times in the worst case and could be ignored in this case **Better Alternative could be -->** You can use doubly linkedlist where you can delete smaller element in O(1) time and no need of skipping values\\n    public int mctFromLeafValues_Optimized(int[] arr) {\\n        if(arr==null || arr.length==0)return Integer.MAX_VALUE; // This is not possible as mentioned in constraints\\n        if(arr.length==1)return Integer.MAX_VALUE;\\n        int num_of_elements=arr.length;\\n        int cost=0;\\n        while(num_of_elements>1){\\n            int i=0,j=0;\\n            int min_index=0;\\n            int min_prod=Integer.MAX_VALUE;\\n            for(int k=0;k<num_of_elements-1;k++){\\n                if(i==j){\\n                    j++;\\n                }\\n                while(arr[i]==Integer.MAX_VALUE)            // This while loop is for skipping already deleted nodes    (These would not be there if you are using linkedlist implementation)\\n                    i++;\\n                while(arr[j]==Integer.MAX_VALUE || (i==j))  // This while loop is for skipping already deleted nodes.\\n                    j++;\\n                if(min_prod>(arr[i]*arr[j]) ){\\n                    min_prod=(arr[i]*arr[j]);\\n                    min_index=((arr[i]<arr[j])?i:j);\\n                }\\n                i=i+1;\\n                j=i+1;\\n            }\\n            cost+=min_prod;\\n            arr[min_index]=Integer.MAX_VALUE;\\n            num_of_elements--;\\n        }\\n        return cost;\\n    }\\n```\n```\\npublic int mctFromLeafValues_Most_Optimized(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);  // This is just a sentinal value to avoid keep checking the stack emptiness condition (Using this he is ensuring himself that no matter what stack would never be empty)\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();// This is just like picking the smallest element\\n                res += mid * Math.min(stack.peek(), a);// since current element is >=top implies the second min element could either be the element present in the top of the stack or incoming array element.\\n            }\\n            stack.push(a);// Doing similer to next greater element problem in which stack with descending values is maintained.\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();//Just doing last pass in case some elements are still no processed i:e we have delayed their processing by putting them into stack\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 569818,
                "title": "c-simple-greedy-solution-with-100-run-time",
                "content": "\\n```\\nint mctFromLeafValues(vector<int>& A) {\\n  int ans = 0;\\n  while(A.size() > 1) {\\n\\tint best_leaves_to_connect = INT_MAX, to_be_removed = -1;\\n\\tfor(int i = 1; i < A.size(); i++) {\\n\\t\\tint cost_of_two_leaves = A[i] * A[i-1];\\n\\t\\tif(cost_of_two_leaves < best_leaves_to_connect) {\\n\\t\\t\\tbest_leaves_to_connect = cost_of_two_leaves;\\n\\t\\t\\tto_be_removed = A[i] < A[i-1] ? i : i-1;\\n\\t\\t}\\n\\t}\\n\\tA.erase(A.begin() + to_be_removed);\\n\\tans = ans + best_leaves_to_connect;\\n  }\\n return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint mctFromLeafValues(vector<int>& A) {\\n  int ans = 0;\\n  while(A.size() > 1) {\\n\\tint best_leaves_to_connect = INT_MAX, to_be_removed = -1;\\n\\tfor(int i = 1; i < A.size(); i++) {\\n\\t\\tint cost_of_two_leaves = A[i] * A[i-1];\\n\\t\\tif(cost_of_two_leaves < best_leaves_to_connect) {\\n\\t\\t\\tbest_leaves_to_connect = cost_of_two_leaves;\\n\\t\\t\\tto_be_removed = A[i] < A[i-1] ? i : i-1;\\n\\t\\t}\\n\\t}\\n\\tA.erase(A.begin() + to_be_removed);\\n\\tans = ans + best_leaves_to_connect;\\n  }\\n return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 565541,
                "title": "bottom-up-python-dp-solution",
                "content": "Since I couldn\\'t find it anywhere, here is my bottom up DP solution:\\nN^2 time, N^2 space \\n\\nI worked backwards from this solution: https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340033/C%2B%2B-with-comments. Starting from the end of the array and building the tree up by increasing the interval size by decrementing L. Then start R at L + 1 to build references of that side of the subtree, that will be used later as R approaches N - 1.\\n\\n\\n\\tdef mctFromLeafValues(self, A):\\n\\n\\t\\t# bottom up dp solution\\n\\n\\t\\tN = len(A)\\n\\t\\tmaxi = [[0 for _ in range(N)] for __ in range(N)]\\n\\t\\tdp = [[0 for _ in range(N)] for __ in range(N)]\\n\\n\\t\\t# get the max in each interval\\n\\t\\tfor i in range(N):\\n\\t\\t\\tmaxi[i][i] = A[i]\\n\\t\\t\\tfor j in range(i + 1, N):\\n\\t\\t\\t\\tmaxi[i][j] = max(maxi[i][j-1], A[j])\\n\\n\\t\\tfor left in range(N - 2, -1, -1):\\n\\t\\t\\tfor right in range(left + 1, N):\\n\\t\\t\\t\\tdp[left][right] = float(\\'inf\\')\\n\\t\\t\\t\\tfor i in range(left, right):   # i represents the current interval subproblem\\n\\t\\t\\t\\t\\tdp[left][right] = min(dp[left][right], maxi[left][i] * maxi[i + 1][right] + dp[left][i] + dp[i + 1][right])\\n\\n\\t\\treturn dp[0][N-1]\\n\\t\\t\\nI\\'ll throw in my top-down as well to show where I started from. \\n\\n\\tdef mctFromLeafValues(self, A):\\n\\t\\n\\t\\tN = len(A)\\n\\t\\tmaxi = [[0 for _ in range(N)] for __ in range(N)]\\n        memo = {}\\n        return self.dp(0, N - 1, maxi, memo)\\n        \\n    def dp(self, left, right, maxi, memo):\\n        if (left, right) in memo: return memo[(left, right)]\\n        if left == right: return 0\\n        \\n        ans = float(\\'inf\\')\\n        \\n        for i in range(left, right):\\n            ans = min(ans, maxi[left][i] * maxi[i + 1][right] + self.dp(left, i, maxi, memo) + self.dp(i + 1, right, maxi, memo))\\n        \\n        memo[(left, right)] = ans\\n        return ans\\n\\t\\t\\nI was actually first trying to follow the example dynamic programming pattern from this post:\\nhttps://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns/439810#Merging-Intervals\\nBut the solution didn\\'t make sense to me. If anyone can explain that one I would greatly appreciate it. Not sure how he gets the answer by starting left at 1, rather than at the end like I have.",
                "solutionTags": [],
                "code": "Since I couldn\\'t find it anywhere, here is my bottom up DP solution:\\nN^2 time, N^2 space \\n\\nI worked backwards from this solution: https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340033/C%2B%2B-with-comments. Starting from the end of the array and building the tree up by increasing the interval size by decrementing L. Then start R at L + 1 to build references of that side of the subtree, that will be used later as R approaches N - 1.\\n\\n\\n\\tdef mctFromLeafValues(self, A):\\n\\n\\t\\t# bottom up dp solution\\n\\n\\t\\tN = len(A)\\n\\t\\tmaxi = [[0 for _ in range(N)] for __ in range(N)]\\n\\t\\tdp = [[0 for _ in range(N)] for __ in range(N)]\\n\\n\\t\\t# get the max in each interval\\n\\t\\tfor i in range(N):\\n\\t\\t\\tmaxi[i][i] = A[i]\\n\\t\\t\\tfor j in range(i + 1, N):\\n\\t\\t\\t\\tmaxi[i][j] = max(maxi[i][j-1], A[j])\\n\\n\\t\\tfor left in range(N - 2, -1, -1):\\n\\t\\t\\tfor right in range(left + 1, N):\\n\\t\\t\\t\\tdp[left][right] = float(\\'inf\\')\\n\\t\\t\\t\\tfor i in range(left, right):   # i represents the current interval subproblem\\n\\t\\t\\t\\t\\tdp[left][right] = min(dp[left][right], maxi[left][i] * maxi[i + 1][right] + dp[left][i] + dp[i + 1][right])\\n\\n\\t\\treturn dp[0][N-1]\\n\\t\\t\\nI\\'ll throw in my top-down as well to show where I started from. \\n\\n\\tdef mctFromLeafValues(self, A):\\n\\t\\n\\t\\tN = len(A)\\n\\t\\tmaxi = [[0 for _ in range(N)] for __ in range(N)]\\n        memo = {}\\n        return self.dp(0, N - 1, maxi, memo)\\n        \\n    def dp(self, left, right, maxi, memo):\\n        if (left, right) in memo: return memo[(left, right)]\\n        if left == right: return 0\\n        \\n        ans = float(\\'inf\\')\\n        \\n        for i in range(left, right):\\n            ans = min(ans, maxi[left][i] * maxi[i + 1][right] + self.dp(left, i, maxi, memo) + self.dp(i + 1, right, maxi, memo))\\n        \\n        memo[(left, right)] = ans\\n        return ans\\n\\t\\t\\nI was actually first trying to follow the example dynamic programming pattern from this post:\\nhttps://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns/439810#Merging-Intervals\\nBut the solution didn\\'t make sense to me. If anyone can explain that one I would greatly appreciate it. Not sure how he gets the answer by starting left at 1, rather than at the end like I have.",
                "codeTag": "Python3"
            },
            {
                "id": 517398,
                "title": "c-100-100",
                "content": "Premise: Want the biggest leaves to be connected as close to the root as possible to mitigate propagation of their values through multiplication into subsequent sums above them in the tree. Use a vector to keep track of available connection points (at the beginning, just the leaves) and iteratively connect the points (leaf and leaf, leaf and node, reducing size of vector) until the root is reached. At each iteration, connect the two adjacent connecting points that produce the smallest value to minimize propagation--add the product of the two values and replace them with the value of the greatest leaf.\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        while (arr.size() > 1){\\n            int p1 = 0, p2 = 1;\\n            int minprod = arr[p1]*arr[p2];\\n            for (int i = 2; i < arr.size(); i++){\\n                if (arr[i]*arr[i-1] < minprod){\\n                    minprod = arr[i]*arr[i-1];\\n                    p1 = i-1;\\n                    p2 = i;\\n                }\\n            }\\n            sum += minprod;\\n            int bigleaf = max(arr[p1],arr[p2]);\\n            if (bigleaf == arr[p1]){\\n                arr.erase(arr.begin()+p2);\\n            } else {\\n                arr.erase(arr.begin()+p1);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        while (arr.size() > 1){\\n            int p1 = 0, p2 = 1;\\n            int minprod = arr[p1]*arr[p2];\\n            for (int i = 2; i < arr.size(); i++){\\n                if (arr[i]*arr[i-1] < minprod){\\n                    minprod = arr[i]*arr[i-1];\\n                    p1 = i-1;\\n                    p2 = i;\\n                }\\n            }\\n            sum += minprod;\\n            int bigleaf = max(arr[p1],arr[p2]);\\n            if (bigleaf == arr[p1]){\\n                arr.erase(arr.begin()+p2);\\n            } else {\\n                arr.erase(arr.begin()+p1);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515512,
                "title": "java-easy-understand-dp-and-recursive-solution",
                "content": "Recursion approach (Time limit ):\\n```\\n\\t\\tpublic int mctFromLeafValues(int[] arr) {\\n\\t\\t\\treturn helper(arr, 0, arr.length - 1);\\n\\t\\t}\\n    \\n\\t    public int helper(int[] arr, int start, int end) {\\n\\t\\t\\tif (start == end) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint interval = end - start;\\n\\t\\t\\tint count = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int i = 0; i < interval; i++) {\\n\\t\\t\\t\\tint countLeft = helper(arr, start, start + i);\\n\\t\\t\\t\\tint countRight = helper(arr, start + i + 1, end);\\n\\t\\t\\t\\tint curMax = getMax(arr, start, start + i) * getMax(arr, start + i + 1, end);\\n\\n\\t\\t\\t\\tcount = Math.min(countLeft + countRight + curMax, count);\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n   \\n    public int getMax(int[] arr, int start, int end) {\\n        if (start == end) {\\n            return arr[start];\\n        }\\n        \\n        int maxV = Integer.MIN_VALUE;\\n        for (int i = start; i <= end; i++) {\\n            maxV = Math.max(maxV, arr[i]);\\n        }\\n        \\n        return maxV;\\n    }\\n```\\n\\nDP Solution:\\n\\n```\\npublic int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        \\n        return dpHelper(arr, 0, arr.length - 1, dp);\\n    }\\n    \\n    public int dpHelper(int[] arr, int start, int end, int[][] dp) {\\n        if (start == end) {\\n            return 0;\\n        }\\n        if (dp[start][end] != 0) {\\n            return dp[start][end];\\n        }\\n        \\n        int interval = end - start;\\n        int count = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < interval; i++) {\\n            int countLeft = dpHelper(arr, start, start + i, dp);\\n            int countRight = dpHelper(arr, start + i + 1, end, dp);\\n            int curMax = getMax(arr, start, start + i) * getMax(arr, start + i + 1, end);\\n            \\n            count = Math.min(countLeft + countRight + curMax, count);\\n        }\\n        \\n        dp[start][end] = count;\\n        return count;\\n    }\\n    \\n    public int getMax(int[] arr, int start, int end) {\\n        if (start == end) {\\n            return arr[start];\\n        }\\n        \\n        int maxV = Integer.MIN_VALUE;\\n        for (int i = start; i <= end; i++) {\\n            maxV = Math.max(maxV, arr[i]);\\n        }\\n        \\n        return maxV;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic int mctFromLeafValues(int[] arr) {\\n\\t\\t\\treturn helper(arr, 0, arr.length - 1);\\n\\t\\t}\\n    \\n\\t    public int helper(int[] arr, int start, int end) {\\n\\t\\t\\tif (start == end) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint interval = end - start;\\n\\t\\t\\tint count = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int i = 0; i < interval; i++) {\\n\\t\\t\\t\\tint countLeft = helper(arr, start, start + i);\\n\\t\\t\\t\\tint countRight = helper(arr, start + i + 1, end);\\n\\t\\t\\t\\tint curMax = getMax(arr, start, start + i) * getMax(arr, start + i + 1, end);\\n\\n\\t\\t\\t\\tcount = Math.min(countLeft + countRight + curMax, count);\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n   \\n    public int getMax(int[] arr, int start, int end) {\\n        if (start == end) {\\n            return arr[start];\\n        }\\n        \\n        int maxV = Integer.MIN_VALUE;\\n        for (int i = start; i <= end; i++) {\\n            maxV = Math.max(maxV, arr[i]);\\n        }\\n        \\n        return maxV;\\n    }\\n```\n```\\npublic int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        \\n        return dpHelper(arr, 0, arr.length - 1, dp);\\n    }\\n    \\n    public int dpHelper(int[] arr, int start, int end, int[][] dp) {\\n        if (start == end) {\\n            return 0;\\n        }\\n        if (dp[start][end] != 0) {\\n            return dp[start][end];\\n        }\\n        \\n        int interval = end - start;\\n        int count = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < interval; i++) {\\n            int countLeft = dpHelper(arr, start, start + i, dp);\\n            int countRight = dpHelper(arr, start + i + 1, end, dp);\\n            int curMax = getMax(arr, start, start + i) * getMax(arr, start + i + 1, end);\\n            \\n            count = Math.min(countLeft + countRight + curMax, count);\\n        }\\n        \\n        dp[start][end] = count;\\n        return count;\\n    }\\n    \\n    public int getMax(int[] arr, int start, int end) {\\n        if (start == end) {\\n            return arr[start];\\n        }\\n        \\n        int maxV = Integer.MIN_VALUE;\\n        for (int i = start; i <= end; i++) {\\n            maxV = Math.max(maxV, arr[i]);\\n        }\\n        \\n        return maxV;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466913,
                "title": "java-comments-to-make-who-still-struggle-with-this-problems-could-understand-the-idea",
                "content": "\\n```\\n1. call dp[i][j] is minimum cost tree from i..j\\n2. our result is dp[0][arr.length - 1]\\n3. i..j have multiple way to build the tree, k: i -> j to devide into left subtree and right subtree: [0,k1] and [k1 + 1][j] or [0,k2] and [k2 + 1][j]\\n4. to find dp[i][j] we need to find all of subtree have smaller range. Ex [6,2,4] we need to find minimum cost: dp[0][0], dp[1][1], dp[2][2],\\ndp[0,1], dp[1,2]\\n5. dp[0][0], dp[1][1], dp[2][2].. dp[i][i] is leaf node so minimum cost tree to build leaf node is zero.\\n\\n\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        int[] leftMaxLeaf = new int[arr.length], rightMaxLeaf = new int[arr.length];\\n        int max = 0;\\n        for(int range = 1; range < arr.length; range++) {\\n            // smaller range between i and j start from 1 to n - 1\\n            \\n            for(int i = 0; i < arr.length - range; i++) {\\n                int j = i + range;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                \\n                // find max leaf in left subtree\\n                max = 0;\\n                for(int k = i; k < j; k++) {\\n                    max = Math.max(max, arr[k]);\\n                    leftMaxLeaf[k] = max;\\n                }\\n                \\n                // find max leaf in right subtree\\n                max = 0;\\n                for(int k = j; k >= 0; k--) {\\n                    max = Math.max(max, arr[k]);\\n                    rightMaxLeaf[k] = max;\\n                }\\n                \\n                // minimum cost i->j which compared from multiple way to build minimum cost of left subtree and right subtree and multiply \\n                // of max leaf in left and max leaf in right\\n                for(int k = i; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + leftMaxLeaf[k] * rightMaxLeaf[k + 1]);\\n                }\\n            }\\n        } \\n        \\n        return dp[0][arr.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1. call dp[i][j] is minimum cost tree from i..j\\n2. our result is dp[0][arr.length - 1]\\n3. i..j have multiple way to build the tree, k: i -> j to devide into left subtree and right subtree: [0,k1] and [k1 + 1][j] or [0,k2] and [k2 + 1][j]\\n4. to find dp[i][j] we need to find all of subtree have smaller range. Ex [6,2,4] we need to find minimum cost: dp[0][0], dp[1][1], dp[2][2],\\ndp[0,1], dp[1,2]\\n5. dp[0][0], dp[1][1], dp[2][2].. dp[i][i] is leaf node so minimum cost tree to build leaf node is zero.\\n\\n\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        int[] leftMaxLeaf = new int[arr.length], rightMaxLeaf = new int[arr.length];\\n        int max = 0;\\n        for(int range = 1; range < arr.length; range++) {\\n            // smaller range between i and j start from 1 to n - 1\\n            \\n            for(int i = 0; i < arr.length - range; i++) {\\n                int j = i + range;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                \\n                // find max leaf in left subtree\\n                max = 0;\\n                for(int k = i; k < j; k++) {\\n                    max = Math.max(max, arr[k]);\\n                    leftMaxLeaf[k] = max;\\n                }\\n                \\n                // find max leaf in right subtree\\n                max = 0;\\n                for(int k = j; k >= 0; k--) {\\n                    max = Math.max(max, arr[k]);\\n                    rightMaxLeaf[k] = max;\\n                }\\n                \\n                // minimum cost i->j which compared from multiple way to build minimum cost of left subtree and right subtree and multiply \\n                // of max leaf in left and max leaf in right\\n                for(int k = i; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + leftMaxLeaf[k] * rightMaxLeaf[k + 1]);\\n                }\\n            }\\n        } \\n        \\n        return dp[0][arr.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444707,
                "title": "time-n-2-space-o-1-100",
                "content": "My solution without extra space and N^2 time complexity. The result is 100%\\nSteps:\\n1. Find a pair with min value(as a goal is to find minimum sum) as this is the in-order format and so we are taking an adjacent element from an array and finding the value.\\n2. Once we get the new generated non-leaf node, the node with minimum value is useless (For the newly generated subtree will be represented with the largest leaf node value.)\\n3. Repeat it until there is only one node.\\n\\n```\\n int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        int index = 0;\\n        while(1)\\n        {\\n            int min = INT_MAX;\\n            for(int i = 1;i < arr.size(); ++i)\\n            {\\n                if(arr[i-1] * arr[i] < min)\\n                {\\n                    min = arr[i-1] * arr[i];\\n                    index = i;\\n                }\\n            }\\n            sum += min;\\n            if(arr[index-1] > arr[index])\\n                arr.erase(arr.begin()+index);\\n            else\\n                arr.erase(arr.begin()+index-1);\\n            if(arr.size() < 2) break;\\n        }\\n        return sum;\\n    }\\n```\\n\\nexample: [3, 4, 6, 8, 9]\\noutput tree:\\n![image](https://assets.leetcode.com/users/bharsaklemukesh975/image_1588633538.png)\\n",
                "solutionTags": [],
                "code": "```\\n int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        int index = 0;\\n        while(1)\\n        {\\n            int min = INT_MAX;\\n            for(int i = 1;i < arr.size(); ++i)\\n            {\\n                if(arr[i-1] * arr[i] < min)\\n                {\\n                    min = arr[i-1] * arr[i];\\n                    index = i;\\n                }\\n            }\\n            sum += min;\\n            if(arr[index-1] > arr[index])\\n                arr.erase(arr.begin()+index);\\n            else\\n                arr.erase(arr.begin()+index-1);\\n            if(arr.size() < 2) break;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436593,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        while(len(arr)>1):\\n            mx = arr[0]*arr[1]\\n            l = 0\\n            r = 1\\n            for i in range(len(arr)-1):\\n                if arr[i]*arr[i+1]<mx:\\n                    mx = arr[i]*arr[i+1]\\n                    l = i\\n                    r = i+1\\n            ans+=mx\\n            #print(l,r,mx)\\n            if arr[l]>arr[r]:\\n                del arr[r]\\n            else:\\n                del arr[l]\\n        return ans\\n\\t\\t```\\n\\t\\t\\n\\t\\tThe solution basicallly checks all pairs of adjacent values in arr to find the pair with the lowest product and adds it to the ans. Then, it removes the minimum of the 2 numbers in the selected pair from the list. Repeat till no pairs left.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        while(len(arr)>1):\\n            mx = arr[0]*arr[1]\\n            l = 0\\n            r = 1\\n            for i in range(len(arr)-1):\\n                if arr[i]*arr[i+1]<mx:\\n                    mx = arr[i]*arr[i+1]\\n                    l = i\\n                    r = i+1\\n            ans+=mx\\n            #print(l,r,mx)\\n            if arr[l]>arr[r]:\\n                del arr[r]\\n            else:\\n                del arr[l]\\n        return ans\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 430828,
                "title": "optimized-java-solution-based-on-arraylist-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n\\t\\n        List<Integer> l=new ArrayList<>();\\n        for(int x:arr)l.add(x);\\n        int sum=0;\\n\\t\\t\\n        while(l.size()!=1){\\n            int index=l.indexOf(Collections.min(l)); //index of minimum element \\n            if(index==0 ||(index-1>=0&&index+1<l.size()&&l.get(index-1)>l.get(index+1))){ //pick left value\\n                sum+=l.get(index+1)*l.get(index);\\n                l.set(index,l.get(index+1)>l.get(index)?l.get(index+1):l.get(index));\\n                l.remove(index+1);\\n            }\\n            else{ //pick right value\\n                sum+=l.get(index-1)*l.get(index);\\n                l.set(index-1,l.get(index-1)>l.get(index)?l.get(index-1):l.get(index));\\n                l.remove(index);\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n\\t\\n        List<Integer> l=new ArrayList<>();\\n        for(int x:arr)l.add(x);\\n        int sum=0;\\n\\t\\t\\n        while(l.size()!=1){\\n            int index=l.indexOf(Collections.min(l)); //index of minimum element \\n            if(index==0 ||(index-1>=0&&index+1<l.size()&&l.get(index-1)>l.get(index+1))){ //pick left value\\n                sum+=l.get(index+1)*l.get(index);\\n                l.set(index,l.get(index+1)>l.get(index)?l.get(index+1):l.get(index));\\n                l.remove(index+1);\\n            }\\n            else{ //pick right value\\n                sum+=l.get(index-1)*l.get(index);\\n                l.set(index-1,l.get(index-1)>l.get(index)?l.get(index-1):l.get(index));\\n                l.remove(index);\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400971,
                "title": "python-divide-and-conquer-iterative-easy-to-understand",
                "content": "```\\n######################################################################\\n# Explanation\\n######################################################################\\n# starting concepts:\\n# [6,2,4,3,7,6]\\n# [6,2] [4] [3,7] [6]\\n# can have multiple single-child nodes\\n\\n# [6,2,4,3,7,6]\\n# [6,2] [4] [3] [7,6]\\n# can have adjacent single-child nodes\\n######################################################################\\n# Non-leaf value is product of biggest leaf in left and right subtrees\\n# to minimize, split up nodes so we form smallest product\\n# for root this is predetermined by product of two biggest\\n# i.e.\\n# [6,2,4,3,7], the root val must be 6*7=42\\n\\n# Remaining items are now up for grabs\\n# big number  * small number = big number \\n# bigger number * small number = even bigger number \\n# following this logic, we want the up for grab elements\\n# in subtree with smaller value. If tie then either subtree works\\n# since it will be a mirror tree of the opposite chosen subtree\\n# [6,2,4,3,7] ===> [6] [2,4,3,7] record: 42\\n\\n# Recursively repeat on all sub trees with size > 1:\\n\\n# Iteration 2:\\n# [6] [2,4,3,7] ===> [6] [2,4,3] [7]  record:28\\n# biggest = 4 and 7, 3 up for grabs goes into smaller subtree\\n\\n# Iteration 3:\\n# [6] [2,4,3] [7] ===> [6] [2,4] [3] [7] record: 12\\n\\n# Iteration 4:\\n# [6] [2,4,3] [7] ===> [6] [2] [4] [3] [7] record: 8\\n# the sum of the recorded values == 90\\n######################################################################\\n# Algorithm:\\n#   set answer = 0\\n#   Make subtree stack\\n#   startingSubtree is entire list\\n#   push startingSubtree onto stack\\n#   Repeat on all subtrees with size > 1:\\n#       Scan through the subtree for max and second max and record idxes O(n)\\n#       leftmax = idx of leftmost max\\n#       rightmax = idx of rightmost max\\n#       Make two subtrees doing the following:\\n#           leftmax and all items left of it go in leftsubtree\\n#           rightmax and all items right of it go in rightsubtree\\n#           if any middle items, they go to the side of smaller subtree\\n#           This division is a non-leaf node, so answer += leftmax  rightmax\\n#   return answer\\n######################################################################\\n\\nclass Solution:\\n    def get_lm_rm(self, arr):\\n        # arr - list of integers size>1\\n        # return: leftmax, rightmax\\n        big1, idx1, big2, idx2 = -1, -1, -1, -1\\n        for i, num in enumerate(arr):\\n            if num >= big1:\\n                big2, idx2 = big1, idx1\\n                big1, idx1 = num, i\\n            elif num >= big2:\\n                big2, idx2 = num, i\\n        return min(idx1, idx2), max(idx1, idx2)\\n        \\n    def mctFromLeafValues(self, arr: List[int]) -> int:   \\n        if len(arr) == 1:\\n            return 0\\n        answer = 0\\n        stack = [arr]\\n        while stack:\\n            subtree = stack.pop()\\n            leftmax, rightmax = self.get_lm_rm(subtree)\\n            left_subtree = subtree[:leftmax+1]\\n            right_subtree = subtree[rightmax:]\\n            middle = subtree[leftmax+1:rightmax]\\n            if subtree[leftmax] < subtree[rightmax]:\\n                left_subtree += middle\\n            else:\\n                right_subtree = middle + right_subtree\\n            answer += subtree[leftmax] * subtree[rightmax]\\n            if len(left_subtree) > 1:\\n                stack.append(left_subtree)\\n            if len(right_subtree) > 1:\\n                stack.append(right_subtree)\\n            print(\\'left:\\', left_subtree)\\n            print(\\'right:\\', right_subtree)\\n            print(subtree[leftmax] * subtree[rightmax])\\n        return answer\\n            \\n        \\n        \\n        \\n```\\n",
                "solutionTags": [],
                "code": "```\\n######################################################################\\n# Explanation\\n######################################################################\\n# starting concepts:\\n# [6,2,4,3,7,6]\\n# [6,2] [4] [3,7] [6]\\n# can have multiple single-child nodes\\n\\n# [6,2,4,3,7,6]\\n# [6,2] [4] [3] [7,6]\\n# can have adjacent single-child nodes\\n######################################################################\\n# Non-leaf value is product of biggest leaf in left and right subtrees\\n# to minimize, split up nodes so we form smallest product\\n# for root this is predetermined by product of two biggest\\n# i.e.\\n# [6,2,4,3,7], the root val must be 6*7=42\\n\\n# Remaining items are now up for grabs\\n# big number  * small number = big number \\n# bigger number * small number = even bigger number \\n# following this logic, we want the up for grab elements\\n# in subtree with smaller value. If tie then either subtree works\\n# since it will be a mirror tree of the opposite chosen subtree\\n# [6,2,4,3,7] ===> [6] [2,4,3,7] record: 42\\n\\n# Recursively repeat on all sub trees with size > 1:\\n\\n# Iteration 2:\\n# [6] [2,4,3,7] ===> [6] [2,4,3] [7]  record:28\\n# biggest = 4 and 7, 3 up for grabs goes into smaller subtree\\n\\n# Iteration 3:\\n# [6] [2,4,3] [7] ===> [6] [2,4] [3] [7] record: 12\\n\\n# Iteration 4:\\n# [6] [2,4,3] [7] ===> [6] [2] [4] [3] [7] record: 8\\n# the sum of the recorded values == 90\\n######################################################################\\n# Algorithm:\\n#   set answer = 0\\n#   Make subtree stack\\n#   startingSubtree is entire list\\n#   push startingSubtree onto stack\\n#   Repeat on all subtrees with size > 1:\\n#       Scan through the subtree for max and second max and record idxes O(n)\\n#       leftmax = idx of leftmost max\\n#       rightmax = idx of rightmost max\\n#       Make two subtrees doing the following:\\n#           leftmax and all items left of it go in leftsubtree\\n#           rightmax and all items right of it go in rightsubtree\\n#           if any middle items, they go to the side of smaller subtree\\n#           This division is a non-leaf node, so answer += leftmax  rightmax\\n#   return answer\\n######################################################################\\n\\nclass Solution:\\n    def get_lm_rm(self, arr):\\n        # arr - list of integers size>1\\n        # return: leftmax, rightmax\\n        big1, idx1, big2, idx2 = -1, -1, -1, -1\\n        for i, num in enumerate(arr):\\n            if num >= big1:\\n                big2, idx2 = big1, idx1\\n                big1, idx1 = num, i\\n            elif num >= big2:\\n                big2, idx2 = num, i\\n        return min(idx1, idx2), max(idx1, idx2)\\n        \\n    def mctFromLeafValues(self, arr: List[int]) -> int:   \\n        if len(arr) == 1:\\n            return 0\\n        answer = 0\\n        stack = [arr]\\n        while stack:\\n            subtree = stack.pop()\\n            leftmax, rightmax = self.get_lm_rm(subtree)\\n            left_subtree = subtree[:leftmax+1]\\n            right_subtree = subtree[rightmax:]\\n            middle = subtree[leftmax+1:rightmax]\\n            if subtree[leftmax] < subtree[rightmax]:\\n                left_subtree += middle\\n            else:\\n                right_subtree = middle + right_subtree\\n            answer += subtree[leftmax] * subtree[rightmax]\\n            if len(left_subtree) > 1:\\n                stack.append(left_subtree)\\n            if len(right_subtree) > 1:\\n                stack.append(right_subtree)\\n            print(\\'left:\\', left_subtree)\\n            print(\\'right:\\', right_subtree)\\n            print(subtree[leftmax] * subtree[rightmax])\\n        return answer\\n            \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 371314,
                "title": "java-easy-dp-using-hashmap",
                "content": "```\\n    private Map<String,Integer> resultMap; // Stores result of minimum value for a given index range\\n    private Map<String,Integer> highestValMap;// Store highest leaf node for a given index range.\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        if(arr == null || arr.length ==0) {\\n            return 0;\\n        }\\n\\n        int start = 0;\\n        int end = arr.length-1;\\n        resultMap = new HashMap<>();\\n        highestValMap = new HashMap<>();\\n\\n        return util(start,end,arr);\\n    }\\n\\n    private int util(int start,int end,int[] arr) {\\n\\n        String key = start+\"_\"+end; // Key of the map : Comprising of start & end index.\\n        if(resultMap.containsKey(key)) {\\n            return resultMap.get(key);\\n        } else if(start == end) {\\n            int value = 0;\\n            resultMap.put(key,value);\\n            highestValMap.put(key, arr[start]);\\n            return value;\\n        } else if(start+1 == end) {\\n            int value = arr[start]*arr[end];\\n            resultMap.put(key, value);\\n            highestValMap.put(key, Math.max(arr[start],arr[end]));\\n            return value;\\n        }\\n        int minValue = Integer.MAX_VALUE;\\n        int i=0;\\n        /**\\n         * Lets say the size of the array is 5[0,4]: To find minimum result , Group array as\\n         * (0,0) (1,4)\\n         * (0,1) (2,4)\\n         * (0,2) (3,4)\\n         * (0,3) (4,4)\\n         */\\n        while (i<end-start) {\\n            int left = util(start,start+i, arr);\\n            int leftHighest = highestValMap.get(start+\"_\"+(start+i));\\n            int right = util(start+i+1,end, arr);\\n            int rightHighest = highestValMap.get(((start+i+1)+\"_\"+end));\\n            int val =  (left+right) + (leftHighest*rightHighest);\\n            if(val<minValue) {\\n                minValue = val;\\n                resultMap.put(key, minValue);\\n                highestValMap.put(key, Math.max(rightHighest,leftHighest));\\n            }\\n            i++;\\n        }\\n\\n        return minValue;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private Map<String,Integer> resultMap; // Stores result of minimum value for a given index range\\n    private Map<String,Integer> highestValMap;// Store highest leaf node for a given index range.\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        if(arr == null || arr.length ==0) {\\n            return 0;\\n        }\\n\\n        int start = 0;\\n        int end = arr.length-1;\\n        resultMap = new HashMap<>();\\n        highestValMap = new HashMap<>();\\n\\n        return util(start,end,arr);\\n    }\\n\\n    private int util(int start,int end,int[] arr) {\\n\\n        String key = start+\"_\"+end; // Key of the map : Comprising of start & end index.\\n        if(resultMap.containsKey(key)) {\\n            return resultMap.get(key);\\n        } else if(start == end) {\\n            int value = 0;\\n            resultMap.put(key,value);\\n            highestValMap.put(key, arr[start]);\\n            return value;\\n        } else if(start+1 == end) {\\n            int value = arr[start]*arr[end];\\n            resultMap.put(key, value);\\n            highestValMap.put(key, Math.max(arr[start],arr[end]));\\n            return value;\\n        }\\n        int minValue = Integer.MAX_VALUE;\\n        int i=0;\\n        /**\\n         * Lets say the size of the array is 5[0,4]: To find minimum result , Group array as\\n         * (0,0) (1,4)\\n         * (0,1) (2,4)\\n         * (0,2) (3,4)\\n         * (0,3) (4,4)\\n         */\\n        while (i<end-start) {\\n            int left = util(start,start+i, arr);\\n            int leftHighest = highestValMap.get(start+\"_\"+(start+i));\\n            int right = util(start+i+1,end, arr);\\n            int rightHighest = highestValMap.get(((start+i+1)+\"_\"+end));\\n            int val =  (left+right) + (leftHighest*rightHighest);\\n            if(val<minValue) {\\n                minValue = val;\\n                resultMap.put(key, minValue);\\n                highestValMap.put(key, Math.max(rightHighest,leftHighest));\\n            }\\n            i++;\\n        }\\n\\n        return minValue;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358341,
                "title": "c-beat100-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size()>2){\\n            auto x = min_element(arr.begin(), arr.end());       \\n            int temp = x == arr.begin()? INT_MAX : *x * (*(x-1));        \\n            int temp2 = x > arr.end() - 2? INT_MAX : *x * (*(x+1));\\n            int ml = min(temp, temp2);\\n            res += ml;\\n            arr.erase(x);\\n        }\\n        res += arr[0] * arr[1];\\n        return res;\\n    }\\n};\\n```\\ntime O(n2)\\nspace O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size()>2){\\n            auto x = min_element(arr.begin(), arr.end());       \\n            int temp = x == arr.begin()? INT_MAX : *x * (*(x-1));        \\n            int temp2 = x > arr.end() - 2? INT_MAX : *x * (*(x+1));\\n            int ml = min(temp, temp2);\\n            res += ml;\\n            arr.erase(x);\\n        }\\n        res += arr[0] * arr[1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340433,
                "title": "c-bottom-up-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<pair<int,int> > > dp(n, vector<pair<int,int>>(n));\\n        for (int len = 0; len < n; ++len) {\\n            for (int i = 0; i < n-len; ++i) {\\n                int j = i + len;\\n                if (i == j) {\\n                    dp[i][j].first = 0;\\n                    dp[i][j].second = arr[i];\\n                    continue;\\n                }\\n                dp[i][j].first = INT_MAX;\\n                dp[i][j].second = 0;\\n                for (int k = i; k < j; ++k) {\\n                    dp[i][j].second = max(dp[i][k].second, dp[k+1][j].second);\\n                    int sum = dp[i][k].second * dp[k+1][j].second;\\n                    sum += dp[i][k].first + dp[k+1][j].first;\\n                    if (dp[i][j].first > sum) { dp[i][j].first = sum; }                    \\n                }\\n                \\n            }\\n        }\\n        return dp[0][n-1].first;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<pair<int,int> > > dp(n, vector<pair<int,int>>(n));\\n        for (int len = 0; len < n; ++len) {\\n            for (int i = 0; i < n-len; ++i) {\\n                int j = i + len;\\n                if (i == j) {\\n                    dp[i][j].first = 0;\\n                    dp[i][j].second = arr[i];\\n                    continue;\\n                }\\n                dp[i][j].first = INT_MAX;\\n                dp[i][j].second = 0;\\n                for (int k = i; k < j; ++k) {\\n                    dp[i][j].second = max(dp[i][k].second, dp[k+1][j].second);\\n                    int sum = dp[i][k].second * dp[k+1][j].second;\\n                    sum += dp[i][k].first + dp[k+1][j].first;\\n                    if (dp[i][j].first > sum) { dp[i][j].first = sum; }                    \\n                }\\n                \\n            }\\n        }\\n        return dp[0][n-1].first;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947050,
                "title": "minimum-cost-tree-from-leaf-values-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is the question that describe:-\\nGiven an array arr of positive integers, consider all binary trees such that:\\n\\nEach node has either 0 or 2 children;\\nThe values of arr correspond to the values of each leaf in an in-order traversal of the tree.\\nThe value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\\nAmong all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.\\n\\nA node is a leaf if and only if it has zero children.\\n\\n \\n\\n# Example 1:\\n\\n\\nInput: arr = [6,2,4]\\nOutput: 32\\nExplanation: There are two possible trees shown.\\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\\n# Example 2:\\n\\n\\nInput: arr = [4,11]\\nOutput: 44\\n \\n\\n# Constraints:\\n\\n2 <= arr.length <= 40\\n1 <= arr[i] <= 15\\nIt is guaranteed that the answer fits into a 32-bit signed integer (i.e., it is less than 231).\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, map<pair<int,int> ,int >& maxi, int left, int right, vector<vector<int>> &dp){\\n        // base case:-\\n        if(left == right){\\n            return 0;\\n        }\\n        if(dp[left][right] != -1){\\n            return dp[left][right];\\n        }\\n\\n        int ans = INT_MAX;\\n\\n        for(int i = left; i<right; i++){\\n            ans = min(ans,\\n            maxi[{left,i}] * maxi[{i+1, right}]\\n            + solve(arr, maxi, left, i,dp)\\n            + solve(arr, maxi, i+1, right,dp));\\n        }\\n        dp[left][right] = ans;\\n        return dp[left][right];\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        // solving this question using map:-\\n        map<pair<int, int> ,int> maxi;\\n\\n        // store the data into the map:-\\n        for(int i = 0;i<arr.size();i++){\\n            maxi[{i,i}] = arr[i];\\n            for(int j = i+1;j<arr.size();j++){\\n                maxi[{i,j}] = max(arr[j], maxi[{i,j-1}]);\\n            }\\n        }\\n        int n = arr.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1,-1));\\n        int ans = solve(arr, maxi, 0, arr.size()-1,dp);\\n        return ans;\\n    }\\n// By ~ Shubham Verma\\n};\\n```\\n![fe5d77d5-39f2-4839-9fcf-41c50106b04f_1676347139.1033723.gif](https://assets.leetcode.com/users/images/5e4950cf-b060-43e6-bc6e-24e08c0df667_1692729285.3549821.gif)\\n![f9e51783-3660-4252-933c-ec2c42b2d57d_1677809905.0379472.jpeg](https://assets.leetcode.com/users/images/5f50214c-f58a-4c4f-9715-ba0eecb1e676_1692729287.343367.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, map<pair<int,int> ,int >& maxi, int left, int right, vector<vector<int>> &dp){\\n        // base case:-\\n        if(left == right){\\n            return 0;\\n        }\\n        if(dp[left][right] != -1){\\n            return dp[left][right];\\n        }\\n\\n        int ans = INT_MAX;\\n\\n        for(int i = left; i<right; i++){\\n            ans = min(ans,\\n            maxi[{left,i}] * maxi[{i+1, right}]\\n            + solve(arr, maxi, left, i,dp)\\n            + solve(arr, maxi, i+1, right,dp));\\n        }\\n        dp[left][right] = ans;\\n        return dp[left][right];\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        // solving this question using map:-\\n        map<pair<int, int> ,int> maxi;\\n\\n        // store the data into the map:-\\n        for(int i = 0;i<arr.size();i++){\\n            maxi[{i,i}] = arr[i];\\n            for(int j = i+1;j<arr.size();j++){\\n                maxi[{i,j}] = max(arr[j], maxi[{i,j-1}]);\\n            }\\n        }\\n        int n = arr.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1,-1));\\n        int ans = solve(arr, maxi, 0, arr.size()-1,dp);\\n        return ans;\\n    }\\n// By ~ Shubham Verma\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892311,
                "title": "max-l-to-i-max-i-1-to-r-solve-a-l-i-mp-dp-solve-a-i-1-r-mp-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& a , int l ,int r, map<pair<int, int>, int> &mp, vector<vector<int>> &dp)\\n    {\\n        if(l==r)\\n            return 0;\\n        \\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        int ans = INT_MAX;\\n        for(int i=l;i<r;i++)\\n        {\\n            ans = min({long(ans) , (long)mp[{l,i}]*mp[{i+1,r}]+solve(a,l,i,mp,dp) + solve(a,i+1,r,mp,dp)});\\n        }\\n        \\n        \\n        \\n        return dp[l][r] = ans;\\n    }\\n    \\n    \\n    int mctFromLeafValues(vector<int>& a) {\\n        map<pair<int, int>, int> mp;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[{i,i}] = a[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                mp[{i,j}] = max(mp[{i,j-1}],a[j]);\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        \\n        return solve(a,0,n-1,mp,dp);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& a , int l ,int r, map<pair<int, int>, int> &mp, vector<vector<int>> &dp)\\n    {\\n        if(l==r)\\n            return 0;\\n        \\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        int ans = INT_MAX;\\n        for(int i=l;i<r;i++)\\n        {\\n            ans = min({long(ans) , (long)mp[{l,i}]*mp[{i+1,r}]+solve(a,l,i,mp,dp) + solve(a,i+1,r,mp,dp)});\\n        }\\n        \\n        \\n        \\n        return dp[l][r] = ans;\\n    }\\n    \\n    \\n    int mctFromLeafValues(vector<int>& a) {\\n        map<pair<int, int>, int> mp;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[{i,i}] = a[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                mp[{i,j}] = max(mp[{i,j-1}],a[j]);\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        \\n        return solve(a,0,n-1,mp,dp);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803152,
                "title": "easy-c-solution-bottom-up-tabulation-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bottomUp(vector<int>& arr,map<pair<int,int>, int> &maxi,int n){\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int left=n-1;left>=0;left--){\\n            for(int right=0;right<n;right++){\\n                if(left>=right)\\n                    continue;\\n                else{\\n                    int ans=INT_MAX;\\n                    for(int i=left;i<right;i++){\\n                        ans=min(ans,\\n                        (maxi[{left,i}]*maxi[{i+1,right}]+\\n                        dp[left][i]\\n                        +dp[i+1][right]));\\n                    }\\n                    dp[left][right]=ans;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>, int> maxi;\\n        for(int i=0;i<arr.size();i++){\\n            maxi[{i,i}]=arr[i];\\n             //this is basically \\n                // pair<int,int> p;\\n                // p.first=i;\\n                // p.second=i;\\n                // maxi[p]=arr[i];\\n            for(int j=i+1;j<arr.size();j++){\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        int n=arr.size();\\n        return bottomUp(arr,maxi,n);\\n      }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bottomUp(vector<int>& arr,map<pair<int,int>, int> &maxi,int n){\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int left=n-1;left>=0;left--){\\n            for(int right=0;right<n;right++){\\n                if(left>=right)\\n                    continue;\\n                else{\\n                    int ans=INT_MAX;\\n                    for(int i=left;i<right;i++){\\n                        ans=min(ans,\\n                        (maxi[{left,i}]*maxi[{i+1,right}]+\\n                        dp[left][i]\\n                        +dp[i+1][right]));\\n                    }\\n                    dp[left][right]=ans;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>, int> maxi;\\n        for(int i=0;i<arr.size();i++){\\n            maxi[{i,i}]=arr[i];\\n             //this is basically \\n                // pair<int,int> p;\\n                // p.first=i;\\n                // p.second=i;\\n                // maxi[p]=arr[i];\\n            for(int j=i+1;j<arr.size();j++){\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        int n=arr.size();\\n        return bottomUp(arr,maxi,n);\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803146,
                "title": "easy-c-solution-top-down-memonization-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int topDown(vector<int>& arr,map<pair<int,int>,int>& maxi,int left,int right,vector<vector<int>> &dp){\\n        if(left==right)\\n            return 0;\\n        if(dp[left][right]!=-1)\\n            return dp[left][right];\\n\\n        int ans=INT_MAX;\\n        for(int i=left;i<right;i++){\\n            ans=min(ans,\\n            (maxi[{left,i}]*maxi[{i+1,right}]+\\n            topDown(arr,maxi,left,i,dp)\\n            +topDown(arr,maxi,i+1,right,dp)));\\n        }\\n        dp[left][right]=ans;\\n        return dp[left][right];\\n    }\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>, int> maxi;\\n        for(int i=0;i<arr.size();i++){\\n            maxi[{i,i}]=arr[i];\\n             //this is basically \\n                // pair<int,int> p;\\n                // p.first=i;\\n                // p.second=i;\\n                // maxi[p]=arr[i];\\n            for(int j=i+1;j<arr.size();j++){\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        int n=arr.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        int ans=topDown(arr,maxi,0,n-1,dp);\\n        return ans;\\n      }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int topDown(vector<int>& arr,map<pair<int,int>,int>& maxi,int left,int right,vector<vector<int>> &dp){\\n        if(left==right)\\n            return 0;\\n        if(dp[left][right]!=-1)\\n            return dp[left][right];\\n\\n        int ans=INT_MAX;\\n        for(int i=left;i<right;i++){\\n            ans=min(ans,\\n            (maxi[{left,i}]*maxi[{i+1,right}]+\\n            topDown(arr,maxi,left,i,dp)\\n            +topDown(arr,maxi,i+1,right,dp)));\\n        }\\n        dp[left][right]=ans;\\n        return dp[left][right];\\n    }\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>, int> maxi;\\n        for(int i=0;i<arr.size();i++){\\n            maxi[{i,i}]=arr[i];\\n             //this is basically \\n                // pair<int,int> p;\\n                // p.first=i;\\n                // p.second=i;\\n                // maxi[p]=arr[i];\\n            for(int j=i+1;j<arr.size();j++){\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        int n=arr.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        int ans=topDown(arr,maxi,0,n-1,dp);\\n        return ans;\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722507,
                "title": "java-recursive-memoization-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        // To Store maximum value between the range\\n        Map<Pair<Integer, Integer>, Integer> max = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            max.put(new Pair(i,i), arr[i]);\\n            for(int j = i + 1; j < n; j++){\\n                max.put(new Pair(i, j), Math.max(arr[j], max.get(new Pair(i, j - 1))));\\n            }\\n        }\\n\\n        // return helper(arr, max, 0, n - 1);\\n        \\n        int[][] dp = new int[n + 1][n + 1];\\n        for(int[] row : dp) Arrays.fill(row, -1);\\n        return helperMem(arr, max, 0, n - 1, dp);\\n    }\\n\\n    public int helper(int[] arr, Map<Pair<Integer, Integer>, Integer> max, int left, int right){\\n        if(left == right) return 0;\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i = left; i < right; i++){\\n            ans = Math.min(ans, \\n                max.get(new Pair(left, i)) * max.get(new Pair(i + 1, right)) \\n                + helper(arr, max, left, i) + helper(arr, max, i + 1, right)\\n                );\\n        }\\n        return ans;\\n    }\\n\\n    public int helperMem(int[] arr, Map<Pair<Integer, Integer>, Integer> max, int left, int right, int[][] dp){\\n        if(left == right) return 0;\\n        if(dp[left][right] != -1) return dp[left][right];\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i = left; i < right; i++){\\n            ans = Math.min(ans, \\n                max.get(new Pair(left, i)) * max.get(new Pair(i + 1, right)) \\n                + helperMem(arr, max, left, i, dp) + helperMem(arr, max, i + 1, right, dp)\\n                );\\n        }\\n        return dp[left][right] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        // To Store maximum value between the range\\n        Map<Pair<Integer, Integer>, Integer> max = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            max.put(new Pair(i,i), arr[i]);\\n            for(int j = i + 1; j < n; j++){\\n                max.put(new Pair(i, j), Math.max(arr[j], max.get(new Pair(i, j - 1))));\\n            }\\n        }\\n\\n        // return helper(arr, max, 0, n - 1);\\n        \\n        int[][] dp = new int[n + 1][n + 1];\\n        for(int[] row : dp) Arrays.fill(row, -1);\\n        return helperMem(arr, max, 0, n - 1, dp);\\n    }\\n\\n    public int helper(int[] arr, Map<Pair<Integer, Integer>, Integer> max, int left, int right){\\n        if(left == right) return 0;\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i = left; i < right; i++){\\n            ans = Math.min(ans, \\n                max.get(new Pair(left, i)) * max.get(new Pair(i + 1, right)) \\n                + helper(arr, max, left, i) + helper(arr, max, i + 1, right)\\n                );\\n        }\\n        return ans;\\n    }\\n\\n    public int helperMem(int[] arr, Map<Pair<Integer, Integer>, Integer> max, int left, int right, int[][] dp){\\n        if(left == right) return 0;\\n        if(dp[left][right] != -1) return dp[left][right];\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i = left; i < right; i++){\\n            ans = Math.min(ans, \\n                max.get(new Pair(left, i)) * max.get(new Pair(i + 1, right)) \\n                + helperMem(arr, max, left, i, dp) + helperMem(arr, max, i + 1, right, dp)\\n                );\\n        }\\n        return dp[left][right] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689527,
                "title": "python-made-easy-2-approaches-brute-force-o-n-2-monotonic-stack-o-n-explained",
                "content": "**Upvote if you understood the solutions :)**\\n\\nApproach 1: We select 2 minimum value neighbours from the array and pop the least value everytime. Why? We greedily only multiply the minimum possible combo and keep the bigger element each time.\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        i = j = None\\n        res = 0\\n\\n        while len(arr) > 1:\\n            for x in range(1, len(arr)):\\n                if i is None or arr[x] * arr[x - 1] < arr[j] * arr[i]:\\n                    if arr[x] > arr[x - 1]:\\n                        j = x\\n                        i = x - 1\\n                    else:\\n                        i = x\\n                        j = x - 1\\n\\n            res += arr[i] * arr[j]\\n            arr.pop(i)\\n            i = j = None\\n\\n        return res\\n```\\n\\nApproach 2: If we are given 3 elements, we iterate from left to right and multiply the least item to the second least one and keep the second least item and the largest one in a monotonic descending stack. We can only multiply the neighbouring items at any given moment. Note: in these 3 elements, the smallest element can only be used once.\\n\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        stack = []\\n        \\n        for x in arr:\\n            while len(stack) and stack[-1] <= x:\\n                mini = stack.pop() # minimum element of the 3 elements stack[-1], stack[-2] and x\\n                \\n                if stack: # if stack has any item left\\n                    res +=  mini * min(x, stack[-1])\\n                else:\\n                    res += mini * x\\n            \\n            stack.append(x)\\n        \\n        # process the remaining items\\n        y = stack.pop()\\n        \\n        while len(stack):\\n            z = stack.pop()\\n            res += y * z\\n            y = z\\n        \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        i = j = None\\n        res = 0\\n\\n        while len(arr) > 1:\\n            for x in range(1, len(arr)):\\n                if i is None or arr[x] * arr[x - 1] < arr[j] * arr[i]:\\n                    if arr[x] > arr[x - 1]:\\n                        j = x\\n                        i = x - 1\\n                    else:\\n                        i = x\\n                        j = x - 1\\n\\n            res += arr[i] * arr[j]\\n            arr.pop(i)\\n            i = j = None\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        stack = []\\n        \\n        for x in arr:\\n            while len(stack) and stack[-1] <= x:\\n                mini = stack.pop() # minimum element of the 3 elements stack[-1], stack[-2] and x\\n                \\n                if stack: # if stack has any item left\\n                    res +=  mini * min(x, stack[-1])\\n                else:\\n                    res += mini * x\\n            \\n            stack.append(x)\\n        \\n        # process the remaining items\\n        y = stack.pop()\\n        \\n        while len(stack):\\n            z = stack.pop()\\n            res += y * z\\n            y = z\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587298,
                "title": "c-simple-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(map<pair<int,int>,int>& mp,int l,int r,vector<vector<int>> &v){\\n        if(l==r)return 0;\\n        int ans = INT_MAX;\\n        if(v[l][r] != -1)return v[l][r];\\n        for(int i = l; i < r; i++){\\n            ans = min(ans,mp[{l,i}]*mp[{i+1,r}]+solve(mp,l,i,v)+solve(mp,i+1,r,v));\\n        }\\n        return v[l][r] = ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>,int> mp;\\n        int i,j,n = arr.size();\\n        for(i = 0; i < n; i++){\\n            mp[{i,i}] = arr[i];\\n            for(j = i+1; j < n; j++){\\n                mp[{i,j}] = max(mp[{i,j-1}],arr[j]);\\n            }\\n        }\\n        vector<vector<int>> v (n,vector<int>(n,-1));\\n        // for(auto &i: mp)cout<<i.first.first<<\" \"<<i.first.second<<\" \"<<i.second<<endl;\\n        return solve(mp,0,n-1,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(map<pair<int,int>,int>& mp,int l,int r,vector<vector<int>> &v){\\n        if(l==r)return 0;\\n        int ans = INT_MAX;\\n        if(v[l][r] != -1)return v[l][r];\\n        for(int i = l; i < r; i++){\\n            ans = min(ans,mp[{l,i}]*mp[{i+1,r}]+solve(mp,l,i,v)+solve(mp,i+1,r,v));\\n        }\\n        return v[l][r] = ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>,int> mp;\\n        int i,j,n = arr.size();\\n        for(i = 0; i < n; i++){\\n            mp[{i,i}] = arr[i];\\n            for(j = i+1; j < n; j++){\\n                mp[{i,j}] = max(mp[{i,j-1}],arr[j]);\\n            }\\n        }\\n        vector<vector<int>> v (n,vector<int>(n,-1));\\n        // for(auto &i: mp)cout<<i.first.first<<\" \"<<i.first.second<<\" \"<<i.second<<endl;\\n        return solve(mp,0,n-1,v);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2558285,
                "title": "python3-o-n-2-dp-commented-code",
                "content": "```\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \"\"\"\\n        we need to find dp(left,right), left -> start index, right -> end index\\n        suppose p is the partition point for the arr \\n        dp(left,right) = max(arr[left:p+1]) * max(arr[p+1:right+1]) + dp(left,p) + dp(p+1,right)\\n        we need to find dp(left,right) for all p in the range of (left,right)\\n        \\n        \"\"\"\\n        dp = {}\\n        \\n        def helper(left,right):\\n            if left == right:\\n                return 0 \\n            if (left,right) in dp:\\n                return dp[(left,right)]\\n            if left + 1 == right:\\n                return arr[left] * arr[right]\\n            \\n            min_cost = float(\\'inf\\')\\n            for p in range(left,right):\\n                cost = (max(arr[left:p+1]) * max(arr[p+1:right+1])) + helper(left,p) + helper(p+1,right)\\n                min_cost = min(min_cost,cost)\\n            \\n            dp[(left,right)] = min_cost\\n            return min_cost\\n        \\n        \\n        return helper(0,len(arr)-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \"\"\"\\n        we need to find dp(left,right), left -> start index, right -> end index\\n        suppose p is the partition point for the arr \\n        dp(left,right) = max(arr[left:p+1]) * max(arr[p+1:right+1]) + dp(left,p) + dp(p+1,right)\\n        we need to find dp(left,right) for all p in the range of (left,right)\\n        \\n        \"\"\"\\n        dp = {}\\n        \\n        def helper(left,right):\\n            if left == right:\\n                return 0 \\n            if (left,right) in dp:\\n                return dp[(left,right)]\\n            if left + 1 == right:\\n                return arr[left] * arr[right]\\n            \\n            min_cost = float(\\'inf\\')\\n            for p in range(left,right):\\n                cost = (max(arr[left:p+1]) * max(arr[p+1:right+1])) + helper(left,p) + helper(p+1,right)\\n                min_cost = min(min_cost,cost)\\n            \\n            dp[(left,right)] = min_cost\\n            return min_cost\\n        \\n        \\n        return helper(0,len(arr)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464461,
                "title": "java-faster-less-memory-than-98-documented-and-explained",
                "content": "Idea is to minimize the multiplicative impact at each step, so choose the smallest pair of numbers possible at each step:\\n\\n[6,2,4] -> Choose 2,4 as they have lesser multiplicative sum than 6,2. We need not keep the \\'node\\' this makes, only it\\'s sum, so add 8 to a running total. The maximum leaf value in this subtree is now 4, so we remove the 2 from the array:\\n[6, 4], Sum: 8\\nNow, the 4 here represents the maximum leaf value of the value(s) that have been taken out on either side of it.\\nRepeat:\\n[ ], Sum 8+24 = 32\\nArray is empty, so return.\\n\\nAgain:\\n6,2,1,3,4:0\\n6,2,3,4:2\\n6,3,4:2+6\\n6,4:2+6+12\\n:2+6+12+24 = 44\\n\\nCode:\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        \\n        int sum = 0;\\n        while(arr.length > 2)\\n        {\\n            //Get the starting index of the minimum pair:\\n            int next = findMinSumStartingIndex(arr);\\n            \\n            //Add the product of the two values:\\n            sum += arr[next]*arr[next+1];\\n            \\n            //Find the smaller number:\\n            int removalIndex;\\n            if(arr[next]<=arr[next+1])\\n            {\\n                removalIndex = next;\\n            } else {\\n                removalIndex = next + 1;\\n            }\\n            \\n            //Use a new array and replace the old.\\n            int[] newArr = new int[arr.length-1];\\n            \\n            //Copy up to the removal index.\\n            System.arraycopy(arr,0,newArr,0,removalIndex);\\n            //Copy after the removal index.\\n            System.arraycopy(arr,removalIndex+1,newArr,removalIndex,arr.length-removalIndex-1);\\n            //Replace.\\n            arr = newArr;\\n        }\\n        //Return the sum plus the product of the final two array values.\\n        return sum + arr[0]*arr[1];\\n    }    \\n\\n    /**\\n    Checks pairwise values for the least sum of two numbers possible and returns the starting index\\n    of that pair.\\n    */\\n    private int findMinSumStartingIndex(int[] arr)\\n    {\\n        int minSum = Integer.MAX_VALUE;\\n        int msi=0;\\n        for(int x=0; x<arr.length-1; x++)\\n        {\\n            int sum = arr[x]+arr[x+1];\\n            if(sum < minSum){\\n                minSum = sum;\\n                msi = x;\\n            }\\n        }\\n        return msi;\\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        \\n        int sum = 0;\\n        while(arr.length > 2)\\n        {\\n            //Get the starting index of the minimum pair:\\n            int next = findMinSumStartingIndex(arr);\\n            \\n            //Add the product of the two values:\\n            sum += arr[next]*arr[next+1];\\n            \\n            //Find the smaller number:\\n            int removalIndex;\\n            if(arr[next]<=arr[next+1])\\n            {\\n                removalIndex = next;\\n            } else {\\n                removalIndex = next + 1;\\n            }\\n            \\n            //Use a new array and replace the old.\\n            int[] newArr = new int[arr.length-1];\\n            \\n            //Copy up to the removal index.\\n            System.arraycopy(arr,0,newArr,0,removalIndex);\\n            //Copy after the removal index.\\n            System.arraycopy(arr,removalIndex+1,newArr,removalIndex,arr.length-removalIndex-1);\\n            //Replace.\\n            arr = newArr;\\n        }\\n        //Return the sum plus the product of the final two array values.\\n        return sum + arr[0]*arr[1];\\n    }    \\n\\n    /**\\n    Checks pairwise values for the least sum of two numbers possible and returns the starting index\\n    of that pair.\\n    */\\n    private int findMinSumStartingIndex(int[] arr)\\n    {\\n        int minSum = Integer.MAX_VALUE;\\n        int msi=0;\\n        for(int x=0; x<arr.length-1; x++)\\n        {\\n            int sum = arr[x]+arr[x+1];\\n            if(sum < minSum){\\n                minSum = sum;\\n                msi = x;\\n            }\\n        }\\n        return msi;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451926,
                "title": "c-solution-using-stack-beats-80-short-and-clean",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& v) {\\n\\tint c=0;\\n\\tstack<int> st;\\n\\tfor(int i:v) {\\n\\t\\twhile(!st.empty() && st.top() <= i) {\\n\\t\\t\\tint x = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(),i);\\n\\t\\t}\\n\\t\\tst.push(i);\\n\\t}\\n\\tint a = st.top();\\n\\tst.pop();\\n\\twhile(!st.empty()) {\\n\\t\\tint x = st.top();\\n\\t\\tst.pop();\\n\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(), a);\\n\\t\\ta = x;\\n\\t}\\n\\treturn c;\\n}\\n};\\n\\n\\n\\'\\'\\'\\n\\n**Upvote if it helped!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& v) {\\n\\tint c=0;\\n\\tstack<int> st;\\n\\tfor(int i:v) {\\n\\t\\twhile(!st.empty() && st.top() <= i) {\\n\\t\\t\\tint x = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(),i);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2451792,
                "title": "simplest-c-solution-dp",
                "content": "```\\nint solve(vector<int>& arr, map<pair<int, int>, int> &maxi, int left, int right, vector<vector<int>> &dp){\\n        if(left == right)\\n            return 0;\\n        if(dp[left][right] != -1)\\n            return dp[left][right];\\n        int ans = INT_MAX;\\n        for(int k = left; k < right; k++){\\n            ans = min(ans, maxi[{left, k}] * maxi[{k+1, right}] + solve(arr, maxi, left, k, dp) + solve(arr, maxi, k+1, right, dp));\\n        }\\n        return dp[left][right] = ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        map<pair<int, int>, int> maxi;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        for(int i = 0; i < n; i++){\\n            maxi[{i, i}] = arr[i];\\n            for(int j = i+1; j < n; j++){\\n                maxi[{i, j}] = max(arr[j], maxi[{i, j-1}]);\\n            }\\n        }\\n        return solve(arr, maxi, 0, n - 1, dp);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint solve(vector<int>& arr, map<pair<int, int>, int> &maxi, int left, int right, vector<vector<int>> &dp){\\n        if(left == right)\\n            return 0;\\n        if(dp[left][right] != -1)\\n            return dp[left][right];\\n        int ans = INT_MAX;\\n        for(int k = left; k < right; k++){\\n            ans = min(ans, maxi[{left, k}] * maxi[{k+1, right}] + solve(arr, maxi, left, k, dp) + solve(arr, maxi, k+1, right, dp));\\n        }\\n        return dp[left][right] = ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        map<pair<int, int>, int> maxi;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        for(int i = 0; i < n; i++){\\n            maxi[{i, i}] = arr[i];\\n            for(int j = i+1; j < n; j++){\\n                maxi[{i, j}] = max(arr[j], maxi[{i, j-1}]);\\n            }\\n        }\\n        return solve(arr, maxi, 0, n - 1, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307503,
                "title": "a-mcm-variation",
                "content": "The logic is about MCM variation but the only thing added here is the third condition given.\\nThat we want the product of maximum leaf value in left and right.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int give_max(int start ,int end,vector<int>& arr)\\n    {\\n        int ans = INT_MIN;\\n        \\n        for(int i = start ; i<= end; i++)\\n        {\\n            ans = max(ans,arr[i]);\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    int solve(int start , int end, vector<int>& arr)\\n    {\\n        if(start >= end) // we have only one element \\n            return 0;  // as we want sum of non-leaf (one element is always leaf)\\n        \\n        \\n        if(dp[start][end] != -1)\\n            return dp[start][end];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = start ; i < end ; i++)\\n        {\\n            int left_part = solve(start,i,arr);\\n            \\n            int right_part = solve(i+1,end,arr);\\n            \\n            int sum = left_part + right_part +  give_max(start,i,arr) * give_max(i+1,end,arr);\\n                                                //the 3rd condition product of max_element \\n                                                //of left and right subtree.\\n            \\n            ans = min(ans,sum);\\n        }\\n        \\n        return dp[start][end] = ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,n-1,arr);\\n    }\\n};\\n```\\nFor time i can\\'t say much 21% faster \\uD83D\\uDE02\\n![image](https://assets.leetcode.com/users/images/e59c3c08-1370-4845-a2a5-57c418c28b96_1658301160.369154.png)\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int give_max(int start ,int end,vector<int>& arr)\\n    {\\n        int ans = INT_MIN;\\n        \\n        for(int i = start ; i<= end; i++)\\n        {\\n            ans = max(ans,arr[i]);\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    int solve(int start , int end, vector<int>& arr)\\n    {\\n        if(start >= end) // we have only one element \\n            return 0;  // as we want sum of non-leaf (one element is always leaf)\\n        \\n        \\n        if(dp[start][end] != -1)\\n            return dp[start][end];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = start ; i < end ; i++)\\n        {\\n            int left_part = solve(start,i,arr);\\n            \\n            int right_part = solve(i+1,end,arr);\\n            \\n            int sum = left_part + right_part +  give_max(start,i,arr) * give_max(i+1,end,arr);\\n                                                //the 3rd condition product of max_element \\n                                                //of left and right subtree.\\n            \\n            ans = min(ans,sum);\\n        }\\n        \\n        return dp[start][end] = ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,n-1,arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302116,
                "title": "mcm-dp-c-easy-solution",
                "content": "MCM approach\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int mx(vector<int> &arr,int s,int e){\\n        int res = INT_MIN;\\n        for(int i=s;i<=e;i++){\\n            res = max(arr[i],res);\\n        }\\n        return res;\\n    }\\n    int solve(vector<int> &arr,int s,int e){\\n        if(s>=e){\\n            return 0;\\n        }\\n        if(dp[s][e]!=-1){\\n            return dp[s][e];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=s;i<e;i++){\\n            int cost = solve(arr,s,i) + solve(arr,i+1,e) + mx(arr,s,i)*mx(arr,i+1,e);\\n            ans = min(ans,cost);\\n        }\\n        return dp[s][e] =  ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(arr,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int mx(vector<int> &arr,int s,int e){\\n        int res = INT_MIN;\\n        for(int i=s;i<=e;i++){\\n            res = max(arr[i],res);\\n        }\\n        return res;\\n    }\\n    int solve(vector<int> &arr,int s,int e){\\n        if(s>=e){\\n            return 0;\\n        }\\n        if(dp[s][e]!=-1){\\n            return dp[s][e];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=s;i<e;i++){\\n            int cost = solve(arr,s,i) + solve(arr,i+1,e) + mx(arr,s,i)*mx(arr,i+1,e);\\n            ans = min(ans,cost);\\n        }\\n        return dp[s][e] =  ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(arr,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284694,
                "title": "python-solution",
                "content": "```\\n**DP will take O(N3) time So avoid it**\\n\\nFind \\'minIdx\\' till length of array > 1\\nminSum += min(array[idx-1],array[idx+1])*array[idx]\\n\\nExample : array = [8,2,9,4,1]\\n\\narray = [8,2,9,4,1]\\nminIdx = 4  \\nminSum += min([4]+[])*array.pop(minIdx) --> 4*1\\n\\narray = [8,2,9,4]\\nminIdx = 1  \\nminSum += min([8]+[9])*array.pop(minIdx) -- >8*2\\n\\narray = [8,9,4]\\nminIdx = 2  \\nminSum += min([9]+[])*array.pop(minIdx) -- >9*4\\n\\narray = [8,9]\\nminIdx = 0\\nminSum += min([9]+[])*array.pop(minIdx) -- >9*8    \\n\\nminSum = 9*8+9*4+8*2+4*1\\n\\ndef mctFromLeafValues(self, array):\\n    def getMinIdx(array):\\n        minIdx = 0\\n        for idx in range(len(array)):\\n            if array[idx] < array[minIdx]:\\n                minIdx = idx\\n        return minIdx\\n    minSum = 0\\n    while len(array) >1:\\n        idx = getMinIdx(array)\\n        minSum += min(array[idx-1:idx]+array[idx+1:idx+2])*array.pop(idx)\\n    return minSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n**DP will take O(N3) time So avoid it**\\n\\nFind \\'minIdx\\' till length of array > 1\\nminSum += min(array[idx-1],array[idx+1])*array[idx]\\n\\nExample : array = [8,2,9,4,1]\\n\\narray = [8,2,9,4,1]\\nminIdx = 4  \\nminSum += min([4]+[])*array.pop(minIdx) --> 4*1\\n\\narray = [8,2,9,4]\\nminIdx = 1  \\nminSum += min([8]+[9])*array.pop(minIdx) -- >8*2\\n\\narray = [8,9,4]\\nminIdx = 2  \\nminSum += min([9]+[])*array.pop(minIdx) -- >9*4\\n\\narray = [8,9]\\nminIdx = 0\\nminSum += min([9]+[])*array.pop(minIdx) -- >9*8    \\n\\nminSum = 9*8+9*4+8*2+4*1\\n\\ndef mctFromLeafValues(self, array):\\n    def getMinIdx(array):\\n        minIdx = 0\\n        for idx in range(len(array)):\\n            if array[idx] < array[minIdx]:\\n                minIdx = idx\\n        return minIdx\\n    minSum = 0\\n    while len(array) >1:\\n        idx = getMinIdx(array)\\n        minSum += min(array[idx-1:idx]+array[idx+1:idx+2])*array.pop(idx)\\n    return minSum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2279472,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 :- Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N ^ 3)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[45][45];\\n    \\n    int helper(vector<int>& arr, int start, int end)\\n    {\\n        // base case, if there is only one leaf node then sum of non-leaf node will be zero\\n        \\n        if(start == end)\\n            return 0;\\n        \\n        // if already calculated\\n        \\n        if(dp[start][end] != -1)\\n            return dp[start][end];\\n        \\n        // find minimum sum, by trying all possible case\\n        \\n        int min_sum = INT_MAX;\\n        \\n        for(int idx = start; idx < end; idx++)\\n        {\\n            // sum of non-leaf nodes on left side\\n            \\n            int left_sum = helper(arr, start, idx);\\n            \\n            // sum of non-leaf nodes on right side\\n            \\n            int right_sum = helper(arr, idx + 1, end);\\n            \\n            // find maximum value of leaf node on left side\\n            \\n            int left_max = *max_element(arr.begin() + start, arr.begin() + idx + 1);\\n            \\n            // find maximum value of leaf node on right side\\n            \\n            int right_max = *max_element(arr.begin() + idx + 1, arr.begin() + end + 1);\\n            \\n            // find total sum\\n            \\n            int total_sum = left_sum + right_sum + left_max * right_max;\\n            \\n            // update min_sum\\n            \\n            min_sum = min(min_sum, total_sum);\\n        }\\n        \\n        // store the result in dp and return result\\n        \\n        return dp[start][end] = min_sum;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // call helper function\\n        \\n        return helper(arr, 0, n - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[45][45];\\n    \\n    int helper(vector<int>& arr, int start, int end)\\n    {\\n        // base case, if there is only one leaf node then sum of non-leaf node will be zero\\n        \\n        if(start == end)\\n            return 0;\\n        \\n        // if already calculated\\n        \\n        if(dp[start][end] != -1)\\n            return dp[start][end];\\n        \\n        // find minimum sum, by trying all possible case\\n        \\n        int min_sum = INT_MAX;\\n        \\n        for(int idx = start; idx < end; idx++)\\n        {\\n            // sum of non-leaf nodes on left side\\n            \\n            int left_sum = helper(arr, start, idx);\\n            \\n            // sum of non-leaf nodes on right side\\n            \\n            int right_sum = helper(arr, idx + 1, end);\\n            \\n            // find maximum value of leaf node on left side\\n            \\n            int left_max = *max_element(arr.begin() + start, arr.begin() + idx + 1);\\n            \\n            // find maximum value of leaf node on right side\\n            \\n            int right_max = *max_element(arr.begin() + idx + 1, arr.begin() + end + 1);\\n            \\n            // find total sum\\n            \\n            int total_sum = left_sum + right_sum + left_max * right_max;\\n            \\n            // update min_sum\\n            \\n            min_sum = min(min_sum, total_sum);\\n        }\\n        \\n        // store the result in dp and return result\\n        \\n        return dp[start][end] = min_sum;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // call helper function\\n        \\n        return helper(arr, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278082,
                "title": "50-tc-and-87-sc-easy-python-solution",
                "content": "```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n\\tn = len(arr)\\n\\tdef dp(i, j):\\n\\t\\tif(i == j):\\n\\t\\t\\treturn 0\\n\\t\\tif(i+1 == j):\\n\\t\\t\\treturn arr[i] * arr[j]\\n\\t\\tif((i, j) in d):\\n\\t\\t\\treturn d[(i, j)]\\n\\t\\ttemp = float(\\'inf\\')\\n\\t\\tfor k in range(i, j):\\n\\t\\t\\ttemp =  min(temp, (max(arr[i:k+1]) * max(arr[k+1:j+1])) + dp(i, k) + dp(k+1, j))\\n\\t\\td[(i, j)] = temp\\n\\t\\treturn temp\\n\\td = dict()\\n\\treturn dp(0, n-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n\\tn = len(arr)\\n\\tdef dp(i, j):\\n\\t\\tif(i == j):\\n\\t\\t\\treturn 0\\n\\t\\tif(i+1 == j):\\n\\t\\t\\treturn arr[i] * arr[j]\\n\\t\\tif((i, j) in d):\\n\\t\\t\\treturn d[(i, j)]\\n\\t\\ttemp = float(\\'inf\\')\\n\\t\\tfor k in range(i, j):\\n\\t\\t\\ttemp =  min(temp, (max(arr[i:k+1]) * max(arr[k+1:j+1])) + dp(i, k) + dp(k+1, j))\\n\\t\\td[(i, j)] = temp\\n\\t\\treturn temp\\n\\td = dict()\\n\\treturn dp(0, n-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2245481,
                "title": "c-faster-than-85-mcm-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int maxelement[41][41];\\n    \\n    int helper(vector<int> &arr , int start, int end){\\n        if(end - start == 0){\\n            return 0;\\n        }\\n        if( end - start == 1){\\n            return arr[start]*arr[end];\\n        }\\n        if(dp[start][end] != -1){\\n            return dp[start][end];\\n        }\\n        \\n        int cost = INT_MAX;\\n\\n        for(int i = start ; i < end ; i++){\\n            cost = min(cost,helper(arr,start,i)+helper(arr,i+1,end)+(maxelement[start][i]*maxelement[i+1][end]));\\n        }\\n        return dp[start][end]=cost;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0 ; i < arr.size() ; i++){\\n            int maxi = 0;\\n            for(int j = i ; j< arr.size() ; j++){\\n                maxi = max(arr[j],maxi);\\n                maxelement[i][j] = maxi;\\n            }\\n        }\\n        \\n        return helper(arr,0,arr.size()-1);\\n        \\n    }\\n    \\n};\\n```\\n\\nTime complexity = O(n^2)\\nSpace complexity = O(n^2)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int maxelement[41][41];\\n    \\n    int helper(vector<int> &arr , int start, int end){\\n        if(end - start == 0){\\n            return 0;\\n        }\\n        if( end - start == 1){\\n            return arr[start]*arr[end];\\n        }\\n        if(dp[start][end] != -1){\\n            return dp[start][end];\\n        }\\n        \\n        int cost = INT_MAX;\\n\\n        for(int i = start ; i < end ; i++){\\n            cost = min(cost,helper(arr,start,i)+helper(arr,i+1,end)+(maxelement[start][i]*maxelement[i+1][end]));\\n        }\\n        return dp[start][end]=cost;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0 ; i < arr.size() ; i++){\\n            int maxi = 0;\\n            for(int j = i ; j< arr.size() ; j++){\\n                maxi = max(arr[j],maxi);\\n                maxelement[i][j] = maxi;\\n            }\\n        }\\n        \\n        return helper(arr,0,arr.size()-1);\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154751,
                "title": "cpp-recursion-memoization-well-commented",
                "content": "# 1] Recursion \\n\\n\\t`\\n\\t/*\\n\\tReturn the pair of integers\\n\\tThe first one will be the max value of the leaf node in that subtree\\n\\tThe second one will be the minimum value of the sum of non-leaf nodes from left to right subtrees.\\n*/\\n\\n```\\npair<int, int> treeSum(vector<int>& arr, int st, int end) {\\n\\t// Base case when there is a leaf node.\\n\\tif (st == end) {\\n\\t\\treturn {arr[st], 0};\\n\\t}\\n\\n\\t/*\\n\\t   Create a two variables minSum to store the minimum sum of non-leaf nodes\\n\\t   and maxLeaf to store the maximum of leaf node\\n\\t*/\\n\\tint minSum = INT_MAX, maxLeaf = INT_MIN;\\n\\n\\t// Split the array at the every ith position.\\n\\tfor (int i = st; i < end; i++) {\\n\\t\\t// Calling on the left subarary.\\n\\t\\tpair<int, int> left = treeSum(arr, st, i);\\n\\n\\t\\t// Calling on the right subarray.\\n\\t\\tpair<int, int> right = treeSum(arr, i + 1, end);\\n\\n\\t\\tminSum = min(minSum, left.second + right.second + (left.first * right.first));\\n\\t\\tmaxLeaf = max(left.first, right.first);\\n\\t}\\n\\treturn {maxLeaf, minSum};\\n}`\\n```\\n```\\n int mctFromLeafValues(vector<int>& arr) {\\n        // Return the minimum sum as the answer.\\n\\t\\treturn treeSum(arr, 0, arr.size() - 1).second;\\n    }\\n```\\n\\n\\n# 2] Dynamic Programming (Top - Down)\\n\\n```\\npair<int, int> treeSum(vector<int>& arr, int st, int end , vector<vector<pair<int, int>>>& dp) {\\n\\t// Base case to check for leaf node.\\n\\tif (st == end) {\\n\\t\\treturn {arr[st], 0};\\n\\t}\\n\\n\\t// To check whether we have already calculated the solution of the subproblem.\\n\\tif (dp[st][end].second != -1) {\\n\\t\\treturn dp[st][end];\\n\\t}\\n\\n\\t/*\\n\\t   Create a two variables minSum to store the minimum sum of non-leaf nodes\\n\\t   and maxLeaf to store the maximum of leaf node\\n\\t*/\\n\\tint minSum = INT_MAX, maxLeaf = INT_MIN;\\n\\n\\t// Split the array at the every ith position.\\n\\tfor (int i = st; i < end; i++) {\\n\\t\\t// Calling on the left subarary.\\n\\t\\tpair<int, int> left = treeSum(arr, st, i , dp);\\n\\n\\t\\t// Calling on the right subarray.\\n\\t\\tpair<int, int> right = treeSum(arr, i + 1, end , dp);\\n\\t\\tminSum = min(minSum, left.second + right.second + (left.first * right.first));\\n\\t\\tmaxLeaf = max(left.first, right.first);\\n\\t}\\n\\n\\t// Storing the answer in the dp table before retuning the answer.\\n\\tdp[st][end] = {maxLeaf, minSum};\\n\\treturn dp[st][end];\\n}\\nint mctFromLeafValues(vector<int>& arr) {\\n\\t/*\\n\\t   Create a 2d Array of pairs \\'DP\\' intialise with zero. The first one will be the\\n\\t   max value of the leaf node in that subtree The second one will be the minimum\\n\\t   value of the sum of non-leaf nodes from left to right subtrees.\\n\\t*/\\n\\tvector<vector<pair<int, int>>> dp = vector<vector<pair<int, int>>>(arr.size(), vector<pair<int, int>>(arr.size(), {INT_MIN, -1}));\\n\\n\\treturn treeSum(arr, 0, arr.size() - 1 , dp).second;\\n}\\n```\\n*   Time complexity: O(N ^ 3)\\n    Space Complexity: O(N ^ 2)*\\n\\n\\n*hope this will help\\uD83D\\uDE01*\\n*Upvote ?*\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\npair<int, int> treeSum(vector<int>& arr, int st, int end) {\\n\\t// Base case when there is a leaf node.\\n\\tif (st == end) {\\n\\t\\treturn {arr[st], 0};\\n\\t}\\n\\n\\t/*\\n\\t   Create a two variables minSum to store the minimum sum of non-leaf nodes\\n\\t   and maxLeaf to store the maximum of leaf node\\n\\t*/\\n\\tint minSum = INT_MAX, maxLeaf = INT_MIN;\\n\\n\\t// Split the array at the every ith position.\\n\\tfor (int i = st; i < end; i++) {\\n\\t\\t// Calling on the left subarary.\\n\\t\\tpair<int, int> left = treeSum(arr, st, i);\\n\\n\\t\\t// Calling on the right subarray.\\n\\t\\tpair<int, int> right = treeSum(arr, i + 1, end);\\n\\n\\t\\tminSum = min(minSum, left.second + right.second + (left.first * right.first));\\n\\t\\tmaxLeaf = max(left.first, right.first);\\n\\t}\\n\\treturn {maxLeaf, minSum};\\n}`\\n```\n```\\n int mctFromLeafValues(vector<int>& arr) {\\n        // Return the minimum sum as the answer.\\n\\t\\treturn treeSum(arr, 0, arr.size() - 1).second;\\n    }\\n```\n```\\npair<int, int> treeSum(vector<int>& arr, int st, int end , vector<vector<pair<int, int>>>& dp) {\\n\\t// Base case to check for leaf node.\\n\\tif (st == end) {\\n\\t\\treturn {arr[st], 0};\\n\\t}\\n\\n\\t// To check whether we have already calculated the solution of the subproblem.\\n\\tif (dp[st][end].second != -1) {\\n\\t\\treturn dp[st][end];\\n\\t}\\n\\n\\t/*\\n\\t   Create a two variables minSum to store the minimum sum of non-leaf nodes\\n\\t   and maxLeaf to store the maximum of leaf node\\n\\t*/\\n\\tint minSum = INT_MAX, maxLeaf = INT_MIN;\\n\\n\\t// Split the array at the every ith position.\\n\\tfor (int i = st; i < end; i++) {\\n\\t\\t// Calling on the left subarary.\\n\\t\\tpair<int, int> left = treeSum(arr, st, i , dp);\\n\\n\\t\\t// Calling on the right subarray.\\n\\t\\tpair<int, int> right = treeSum(arr, i + 1, end , dp);\\n\\t\\tminSum = min(minSum, left.second + right.second + (left.first * right.first));\\n\\t\\tmaxLeaf = max(left.first, right.first);\\n\\t}\\n\\n\\t// Storing the answer in the dp table before retuning the answer.\\n\\tdp[st][end] = {maxLeaf, minSum};\\n\\treturn dp[st][end];\\n}\\nint mctFromLeafValues(vector<int>& arr) {\\n\\t/*\\n\\t   Create a 2d Array of pairs \\'DP\\' intialise with zero. The first one will be the\\n\\t   max value of the leaf node in that subtree The second one will be the minimum\\n\\t   value of the sum of non-leaf nodes from left to right subtrees.\\n\\t*/\\n\\tvector<vector<pair<int, int>>> dp = vector<vector<pair<int, int>>>(arr.size(), vector<pair<int, int>>(arr.size(), {INT_MIN, -1}));\\n\\n\\treturn treeSum(arr, 0, arr.size() - 1 , dp).second;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150827,
                "title": "c-solution-using-optimal-merge",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //started merging from picking up minimum element\\n        int ans=0;\\n        while(arr.size()>1){\\n            int idx= min_element(arr.begin(),arr.end())- arr.begin();//minimum element\\'s idx\\n            if(idx== arr.size()-1){\\n                ans+= arr[idx]*arr[idx-1];\\n            }\\n            else if(idx==0){\\n                ans+= arr[idx]*arr[idx+1];\\n            }\\n            else{\\n                ans+= arr[idx]*min(arr[idx-1], arr[idx+1]);\\n            }\\n            arr.erase(arr.begin()+idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //started merging from picking up minimum element\\n        int ans=0;\\n        while(arr.size()>1){\\n            int idx= min_element(arr.begin(),arr.end())- arr.begin();//minimum element\\'s idx\\n            if(idx== arr.size()-1){\\n                ans+= arr[idx]*arr[idx-1];\\n            }\\n            else if(idx==0){\\n                ans+= arr[idx]*arr[idx+1];\\n            }\\n            else{\\n                ans+= arr[idx]*min(arr[idx-1], arr[idx+1]);\\n            }\\n            arr.erase(arr.begin()+idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148359,
                "title": "c-array-partition-with-recursion-memoization",
                "content": "```class Solution {\\npublic:\\n    map<pair<int,int>,int> mp;\\n    \\n    int maxx(int i,int j,vector<int>&vec){\\n        return *max_element(vec.begin()+i,vec.begin()+j+1);\\n    }\\n    \\n    int rec(vector<int>& vec,int i,int j){\\n        if(i == j){\\n            return 0;\\n        }\\n        if(mp[{i,j}] != 0) return mp[{i,j}];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k = i;k<j;k++){\\n            ans = min(ans,maxx(i,k,vec)*maxx(k+1,j,vec) + rec(vec,i,k) + rec(vec,k+1,j));\\n        }\\n        \\n        return mp[{i,j}] = ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        return rec(arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```class Solution {\\npublic:\\n    map<pair<int,int>,int> mp;\\n    \\n    int maxx(int i,int j,vector<int>&vec){\\n        return *max_element(vec.begin()+i,vec.begin()+j+1);\\n    }\\n    \\n    int rec(vector<int>& vec,int i,int j){\\n        if(i == j){\\n            return 0;\\n        }\\n        if(mp[{i,j}] != 0) return mp[{i,j}];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k = i;k<j;k++){\\n            ans = min(ans,maxx(i,k,vec)*maxx(k+1,j,vec) + rec(vec,i,k) + rec(vec,k+1,j));\\n        }\\n        \\n        return mp[{i,j}] = ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        return rec(arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564613,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1564666,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1564918,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1676338,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1566176,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1574481,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1573293,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1569629,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1857578,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1576266,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1564613,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1564666,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1564918,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1676338,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1566176,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1574481,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1573293,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1569629,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1857578,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1576266,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            }
        ]
    },
    {
        "title": "Special Array With X Elements Greater Than or Equal X",
        "question_content": "<p>You are given an array <code>nums</code> of non-negative integers. <code>nums</code> is considered <strong>special</strong> if there exists a number <code>x</code> such that there are <strong>exactly</strong> <code>x</code> numbers in <code>nums</code> that are <strong>greater than or equal to</strong> <code>x</code>.</p>\n\n<p>Notice that <code>x</code> <strong>does not</strong> have to be an element in <code>nums</code>.</p>\n\n<p>Return <code>x</code> <em>if the array is <strong>special</strong>, otherwise, return </em><code>-1</code>. It can be proven that if <code>nums</code> is special, the value for <code>x</code> is <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,5]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are 2 values (3 and 5) that are greater than or equal to 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> No numbers fit the criteria for x.\nIf x = 0, there should be 0 numbers &gt;= x, but there are 2.\nIf x = 1, there should be 1 number &gt;= x, but there are 0.\nIf x = 2, there should be 2 numbers &gt;= x, but there are 0.\nx cannot be greater since there are only 2 numbers in nums.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,4,3,0,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are 3 values that are greater than or equal to 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 877722,
                "title": "clean-python-3-o-sort",
                "content": "Concept is similar to H-index\\nAfter `while` loop, we can get `i` which indicates there are already `i` items larger or equal to `i`.\\nMeanwhile, if we found `i == nums[i]`, there will be `i + 1` items larger or equal to `i`, which makes array not special.\\nTime: `O(sort)`, can achieve `O(N)` if we use counting sort\\nSpace: `O(sort)`\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        i = 0\\n        while i < len(nums) and nums[i] > i:\\n            i += 1\\n        return -1 if i < len(nums) and i == nums[i] else i\\n```\\n\\nit can be faster by using binary search if list is already sorted.\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if mid < nums[mid]:\\n                left = mid + 1\\n            else:\\n                right = mid       \\n        return -1 if left < len(nums) and left == nums[left] else left\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        i = 0\\n        while i < len(nums) and nums[i] > i:\\n            i += 1\\n        return -1 if i < len(nums) and i == nums[i] else i\\n```\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if mid < nums[mid]:\\n                left = mid + 1\\n            else:\\n                right = mid       \\n        return -1 if left < len(nums) and left == nums[left] else left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877939,
                "title": "simple-java-efficient-solution-beats-100-time-and-100-memory",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int x = nums.length;\\n        int[] counts = new int[x+1];\\n        \\n        for(int elem : nums)\\n            if(elem >= x)\\n                counts[x]++;\\n            else\\n                counts[elem]++;\\n        \\n        int res = 0;\\n        for(int i = counts.length-1; i > 0; i--) {\\n            res += counts[i];\\n            if(res == i)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int x = nums.length;\\n        int[] counts = new int[x+1];\\n        \\n        for(int elem : nums)\\n            if(elem >= x)\\n                counts[x]++;\\n            else\\n                counts[elem]++;\\n        \\n        int res = 0;\\n        for(int i = counts.length-1; i > 0; i--) {\\n            res += counts[i];\\n            if(res == i)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879513,
                "title": "c-6-different-solutions-with-analysis",
                "content": "just for fun\\n```\\n// naive brute force O(N^2)\\nbool check(int num, vector<int> &nums) { \\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] >= num) \\n            return (nums.size() - i) == num;                \\n    }\\n    return false;\\n}\\nint specialArray(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    for (int i = 0; i <= nums.size() ; i++) { // O(N)\\n        if (check(i, nums)) return i; // O(N)\\n    }\\n    return -1;\\n}\\n\\n// just for fun short version  O(N^2)  O(NlogN + O(N) * (O(LogN) + O(N)))\\nint specialArray(vector<int>& nums) {\\n    multiset<int> s(nums.begin(), nums.end()); // O(NlogN)\\n    for (int i = 1; i <= nums.size(); i++) { // O(N)\\n        auto itr = s.lower_bound(i); // O(LogN) it\\'s sorted \\n        if (distance(itr, s.end()) == i) return i // O(N)\\n        // well multiset seems to be a rb tree which makes itr not a random-access iterator and therefore the time complexity for distance is linear \\n    }\\n    return -1;\\n}\\n \\n// improved version, O(NlogN) (O(NLogN) + O(NLogN))\\nint specialArray(vector<int>& nums) {\\n    sort(nums.begin(), nums.end()); // O(NlogN)\\n    for (int i = 1; i <= nums.size(); i++) { // O(N)\\n        auto itr = lower_bound(nums.begin(), nums.end(), i); // O(LogN)\\n        if (distance(itr, nums.end()) == i) return i; // O(1)\\n    }\\n    return -1;\\n}\\n\\n// improved version pro max O(NlogN)  (O(NLogN) + (O(LogN) * O(LogN)) )\\nint specialArray(vector<int>& nums) {\\n    sort(nums.begin(), nums.end()); // O(NlogN)\\n    int l = 1, r = nums.size();\\n    while (l <= r) {\\n        int m = l + (r - l) / 2;\\n        auto itr = lower_bound(nums.begin(), nums.end(), m); // O(logN)\\n        int c = distance(itr, nums.end()); // O(1)\\n        if (c == m) return m;\\n        else if (c > m) l = m + 1;\\n        else r = m - 1;\\n    }\\n    return -1;\\n}\\n\\n// my friend\\'s solution @jmfer52 O(NLogN) (NlogN + OLogN)\\nint specialArray(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());  // O(NlogN)\\n    const int N = nums.size();\\n    if (nums[0] >= N) return N;\\n    int l = 1, r = N - 1;\\n    while (l <= r) { // O(LogN) * O(1)\\n        int m = l + (r - l) / 2;\\n        if (nums[m] >= (N - m) && nums[m - 1] < (N - m)) return (N - m);\\n        else if (nums[m] >= (N - m)) r = m - 1;\\n        else l = m + 1;\\n    }\\n    return -1;\\n\\n// counting sort, O(N) 2 pass\\nint specialArray(vector<int>& nums) {\\n    int count[102] = { 0 }, N = nums.size();\\n    for (int n : nums) count[min(n, N)]++;\\n    for (int i = N; i >= 0; i--) {\\n        count[i] = count[i + 1] + count[i];\\n        if (count[i] == i) return i;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// naive brute force O(N^2)\\nbool check(int num, vector<int> &nums) { \\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] >= num) \\n            return (nums.size() - i) == num;                \\n    }\\n    return false;\\n}\\nint specialArray(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    for (int i = 0; i <= nums.size() ; i++) { // O(N)\\n        if (check(i, nums)) return i; // O(N)\\n    }\\n    return -1;\\n}\\n\\n// just for fun short version  O(N^2)  O(NlogN + O(N) * (O(LogN) + O(N)))\\nint specialArray(vector<int>& nums) {\\n    multiset<int> s(nums.begin(), nums.end()); // O(NlogN)\\n    for (int i = 1; i <= nums.size(); i++) { // O(N)\\n        auto itr = s.lower_bound(i); // O(LogN) it\\'s sorted \\n        if (distance(itr, s.end()) == i) return i // O(N)\\n        // well multiset seems to be a rb tree which makes itr not a random-access iterator and therefore the time complexity for distance is linear \\n    }\\n    return -1;\\n}\\n \\n// improved version, O(NlogN) (O(NLogN) + O(NLogN))\\nint specialArray(vector<int>& nums) {\\n    sort(nums.begin(), nums.end()); // O(NlogN)\\n    for (int i = 1; i <= nums.size(); i++) { // O(N)\\n        auto itr = lower_bound(nums.begin(), nums.end(), i); // O(LogN)\\n        if (distance(itr, nums.end()) == i) return i; // O(1)\\n    }\\n    return -1;\\n}\\n\\n// improved version pro max O(NlogN)  (O(NLogN) + (O(LogN) * O(LogN)) )\\nint specialArray(vector<int>& nums) {\\n    sort(nums.begin(), nums.end()); // O(NlogN)\\n    int l = 1, r = nums.size();\\n    while (l <= r) {\\n        int m = l + (r - l) / 2;\\n        auto itr = lower_bound(nums.begin(), nums.end(), m); // O(logN)\\n        int c = distance(itr, nums.end()); // O(1)\\n        if (c == m) return m;\\n        else if (c > m) l = m + 1;\\n        else r = m - 1;\\n    }\\n    return -1;\\n}\\n\\n// my friend\\'s solution @jmfer52 O(NLogN) (NlogN + OLogN)\\nint specialArray(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());  // O(NlogN)\\n    const int N = nums.size();\\n    if (nums[0] >= N) return N;\\n    int l = 1, r = N - 1;\\n    while (l <= r) { // O(LogN) * O(1)\\n        int m = l + (r - l) / 2;\\n        if (nums[m] >= (N - m) && nums[m - 1] < (N - m)) return (N - m);\\n        else if (nums[m] >= (N - m)) r = m - 1;\\n        else l = m + 1;\\n    }\\n    return -1;\\n\\n// counting sort, O(N) 2 pass\\nint specialArray(vector<int>& nums) {\\n    int count[102] = { 0 }, N = nums.size();\\n    for (int n : nums) count[min(n, N)]++;\\n    for (int i = N; i >= 0; i--) {\\n        count[i] = count[i + 1] + count[i];\\n        if (count[i] == i) return i;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877736,
                "title": "c-use-counting-sort-0ms",
                "content": "1. count the amount of numbers\\n2. add the amount backward so we can know how many numbers are no less than the current index.\\n\\nExample:\\n```\\ninput [0, 4, 3, 0, 4]\\n\\nindex  0  1  2  3  4  0  ... 1000 // the range defined in the question\\nv     [2, 0, 0, 1, 2, 0, ..., 0]\\n# after accumulation\\nv     [5, 3, 3, 3, 2, 0, ..., 0]\\n                ^ // 3 numbers are no less than 3\\n```\\n\\n\\nImplementation:\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int v[102];\\n        memset(v, 0, sizeof v);\\n        for (const auto &n : nums) {\\n            ++v[n > 100 ? 100 : n];\\n        }\\n        for (int i = 100; i > 0; --i) {\\n            v[i] = v[i + 1] + v[i];\\n            if (v[i] == i)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n[Update 1004]: change size of vector from ~1000 to ~100 based on the constraint that `1 <= nums.length <= 100`.\\n[Update 1017]: Thanks to @aleksey12345 to let me know this is counting sort, a kind of sorting tech.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ninput [0, 4, 3, 0, 4]\\n\\nindex  0  1  2  3  4  0  ... 1000 // the range defined in the question\\nv     [2, 0, 0, 1, 2, 0, ..., 0]\\n# after accumulation\\nv     [5, 3, 3, 3, 2, 0, ..., 0]\\n                ^ // 3 numbers are no less than 3\\n```\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int v[102];\\n        memset(v, 0, sizeof v);\\n        for (const auto &n : nums) {\\n            ++v[n > 100 ? 100 : n];\\n        }\\n        for (int i = 100; i > 0; --i) {\\n            v[i] = v[i + 1] + v[i];\\n            if (v[i] == i)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877869,
                "title": "java-o-nlogn-with-easy-explanation",
                "content": "**Explanation**: The number we are searching for is any number from `zero` to `length of array`. If we sort the array in ascending order, we can iterate through it from left to right checking if the number of elements until the end and the current value meet the conditions of success. Those are:\\n1. The number of elements from the current index until the end is less than or equal the current value in the array\\n2. The number of elements from the current index until the end is greater than the previous value in the array (if it exists)\\n\\nWe are, essentially, cleverly checking if the current number of elements until the end is the answer.\\n\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++) {\\n            int n = nums.length-i;\\n            boolean cond1 =  n<=nums[i];\\n            boolean cond2 = (i-1<0) || (n>nums[i-1]);\\n            if (cond1 && cond2) return n;\\n        }\\n        return -1;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++) {\\n            int n = nums.length-i;\\n            boolean cond1 =  n<=nums[i];\\n            boolean cond2 = (i-1<0) || (n>nums[i-1]);\\n            if (cond1 && cond2) return n;\\n        }\\n        return -1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295326,
                "title": "c-solution-using-binary-search-o-n-log1000-time-and-o-1-space",
                "content": "**Time Complexity: O(n*log1000)**\\n**Space Complexity:O(1)**\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums,int val){\\n        int count=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]>=val){\\n                ++count;\\n            }\\n        }\\n        return count;\\n    }\\n    int specialArray(vector<int>& nums) {\\n       int low=0,high=1000;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            int comp=solve(nums,mid);\\n            if(comp==mid){\\n                return comp;\\n            }\\n            if(comp>mid){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums,int val){\\n        int count=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]>=val){\\n                ++count;\\n            }\\n        }\\n        return count;\\n    }\\n    int specialArray(vector<int>& nums) {\\n       int low=0,high=1000;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            int comp=solve(nums,mid);\\n            if(comp==mid){\\n                return comp;\\n            }\\n            if(comp>mid){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922402,
                "title": "python-sort-binary-search",
                "content": "**Please upvote if it helps. Thank you!**\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            m = l + (r - l) // 2\\n            x = len(nums) - m\\n            if nums[m] >= x:\\n                if m == 0 or nums[m - 1] < x:\\n                    return x\\n                else:\\n                    r = m - 1\\n            else:\\n                l = m + 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            m = l + (r - l) // 2\\n            x = len(nums) - m\\n            if nums[m] >= x:\\n                if m == 0 or nums[m - 1] < x:\\n                    return x\\n                else:\\n                    r = m - 1\\n            else:\\n                l = m + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877791,
                "title": "java-counting-sort-two-pass-simple-code",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int[] count = new int[1001];\\n        for (int num : nums) {\\n            count[num]++;\\n        }\\n        int number = nums.length;\\n\\t\\t// the size of nums array is 100 at most\\n        for (int i = 0; i <= 100; i++) {\\n            if (number == i) {\\n                return i;\\n            }\\n            number -= count[i];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int[] count = new int[1001];\\n        for (int num : nums) {\\n            count[num]++;\\n        }\\n        int number = nums.length;\\n\\t\\t// the size of nums array is 100 at most\\n        for (int i = 0; i <= 100; i++) {\\n            if (number == i) {\\n                return i;\\n            }\\n            number -= count[i];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478649,
                "title": "java-binary-search-easy-solution-100-faster",
                "content": "[IMP]: In this approach sorting is optional.  Dosn\\'t affect the time complexity.\\nThe least/smallest value can be \"0\" , eg: [] empty and count==0.\\nThe highest/maximum can be the \"arr.length\" ,e.g:[6,7,8,9] length=4 and >=4 count is also 4.\\nElse the values lies in middle.\\n\\nUpvote if useful.\\n\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n\\t\\t//Optional: sorting:\\n\\t\\t//Arrays.sort(nums);\\n        //The least value can be 0 as the numbers are all 0 \\n        int start=0;\\n        //The maximum value can be the length as all numbers are greater than the \\n        //Length of the array and the value is inclusive\\n        int end=nums.length;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            int curr=count(nums,mid);\\n            //The count of ele >=mid and the mid are equal thus;\\n            if(curr==mid)\\n            {\\n                return mid;\\n            }\\n            //If the count of >=mid is less than the mid\\n            else if(curr<mid)\\n            {\\n                //decrease it;\\n                end=mid-1;\\n            }\\n            else if(curr>mid)\\n            {\\n                //Increase it;as the value count>mid and we need to reduce the count of values \">=\" the mid\\n                start=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static int count(int[]arr,int t)\\n    {\\n        int c=0;\\n        for(int i:arr)\\n        {\\n            if(i>=t)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n\\t\\t//Optional: sorting:\\n\\t\\t//Arrays.sort(nums);\\n        //The least value can be 0 as the numbers are all 0 \\n        int start=0;\\n        //The maximum value can be the length as all numbers are greater than the \\n        //Length of the array and the value is inclusive\\n        int end=nums.length;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            int curr=count(nums,mid);\\n            //The count of ele >=mid and the mid are equal thus;\\n            if(curr==mid)\\n            {\\n                return mid;\\n            }\\n            //If the count of >=mid is less than the mid\\n            else if(curr<mid)\\n            {\\n                //decrease it;\\n                end=mid-1;\\n            }\\n            else if(curr>mid)\\n            {\\n                //Increase it;as the value count>mid and we need to reduce the count of values \">=\" the mid\\n                start=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static int count(int[]arr,int t)\\n    {\\n        int c=0;\\n        for(int i:arr)\\n        {\\n            if(i>=t)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882910,
                "title": "java-beats-100-two-binary-search-methods-and-detailed-explanation",
                "content": "First, we can think out if we sort the array, that will be easier for us to find the X. If the array is sorted, for `nums[i]` there will be `len - i` numbers that are greater or equal to `nums[i]`.\\nSo one idea by intution is to enumerate each `X` and find the first position that `nums[i] >= X` . Then check `len - i = X` to see whether it is the correct `X` to return.\\n## 1. Binary Search to find the first position `>= nums[i]`\\nSince the array is already sorted, we can use binary search instead of for loop.\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        // enumerate all possible number i\\n        for (int x = 0; x <= nums[len - 1]; x++) {\\n            // find the first index that nums[idx] >= i\\n            int idx = findFirstGreaterOrEqual(x, nums);\\n            if (len - idx == x) {\\n                return x;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int findFirstGreaterOrEqual(int target, int[] nums) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left + 1 < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] >= target) {\\n                right = mid;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n\\n        if (nums[left] >= target) {\\n            return left;\\n        }\\n        return right; // whether right >= target or right > target\\n    }\\n}\\n```\\nBeats 89.04% time and 93.46% space.\\n- Time Complexity: O((N+L)logN) where N is array length, L is data range.\\n\\t- Sort will take O(NlogN)\\n\\t- enumerate will have L iterations and O(logN) for each iteration.\\n- Space Complexity: O(N)\\n\\t- Space complexity depending the sorting algorithm. Usually O(n).\\n\\n## 2. Binary Search to find the first position `nums[i] >= len - i`\\nFor the first method we spend a lot of time to enumerate all possible `X` . However, we don\\'t need to repeat binary search so many times. We can use another way to solve this problem.\\nWe can direactly to find the `nums[i]` not the `X` . In method 1, we try to find the first position that **`nums[i] >= X` and `X = len - i`** . Thus here we can directly find first position `i` that **`nums[i] >= len - i`** .\\nSimilar to classical binary search, but we need ensure **first index** by check whether `nums[i - 1] < len - i` when we find the number that `nums[i] >= len - i`.\\nExample:\\n```txt\\nnums = {0, 0, 3, 3, 4}\\n              i\\n\\nWe should match this two condition at the same time:\\n1. nums[i] >= len - i \\u2705\\n2. nums[i - 1] < len - i \\u2705\\n\\nOtherwise:\\nnums = {3, 3, 3, 4}\\n\\t\\t   i\\n1. nums[i] >= len - i \\u2705\\n2. nums[i - 1] >= len - i \\u274C\\n\\nNot first index.\\n```\\nJava Code:\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        int left = 0;\\n        int right = len - 1;\\n        // binary search to find the first position that\\n        // nums[i] >= len - i and nums[i - 1] < len - i\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] >= len - mid) {\\n                // treat index 0 to avoid IndexOutOfBoundError\\n                if (mid == 0 || nums[mid - 1] < len - mid) { // correct index\\n                    return len - mid;\\n                } else { // not the first position, shrink right bound\\n                    right = mid - 1;\\n                }\\n            } else { // otherwisem, shrink the left bound to increase nums[mid]\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nBeats 100% time and 99.63% space.\\n- Time Complexity: O(NlogN) where N is array length.\\n\\t- O(NlogN) for sort\\n\\t- O(logN) for one binary search.\\n- Space Complexity: O(N)\\n\\t- Space complexity depending the sorting algorithm. Usually O(n).\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        // enumerate all possible number i\\n        for (int x = 0; x <= nums[len - 1]; x++) {\\n            // find the first index that nums[idx] >= i\\n            int idx = findFirstGreaterOrEqual(x, nums);\\n            if (len - idx == x) {\\n                return x;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int findFirstGreaterOrEqual(int target, int[] nums) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left + 1 < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] >= target) {\\n                right = mid;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n\\n        if (nums[left] >= target) {\\n            return left;\\n        }\\n        return right; // whether right >= target or right > target\\n    }\\n}\\n```\n```txt\\nnums = {0, 0, 3, 3, 4}\\n              i\\n\\nWe should match this two condition at the same time:\\n1. nums[i] >= len - i \\u2705\\n2. nums[i - 1] < len - i \\u2705\\n\\nOtherwise:\\nnums = {3, 3, 3, 4}\\n\\t\\t   i\\n1. nums[i] >= len - i \\u2705\\n2. nums[i - 1] >= len - i \\u274C\\n\\nNot first index.\\n```\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        int left = 0;\\n        int right = len - 1;\\n        // binary search to find the first position that\\n        // nums[i] >= len - i and nums[i - 1] < len - i\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] >= len - mid) {\\n                // treat index 0 to avoid IndexOutOfBoundError\\n                if (mid == 0 || nums[mid - 1] < len - mid) { // correct index\\n                    return len - mid;\\n                } else { // not the first position, shrink right bound\\n                    right = mid - 1;\\n                }\\n            } else { // otherwisem, shrink the left bound to increase nums[mid]\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904005,
                "title": "c-faster-than100-brute-force-easy-understanding",
                "content": "**TC: O(n^2) [Brute force]**\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        for(int i=1;i<1000;i++){\\n            int cnt=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]>=i) cnt++;\\n            }\\n            if(cnt==i) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**TC: O(n) [faster than 100.00%]**\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int arr[1001]={0};\\n        for(int num: nums) arr[num]++;\\n        int total=nums.size();\\n        for(int i=0;i<1001;i++){\\n            if(i==total) \\n                return i;\\n            total-=arr[i];\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        for(int i=1;i<1000;i++){\\n            int cnt=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]>=i) cnt++;\\n            }\\n            if(cnt==i) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int arr[1001]={0};\\n        for(int num: nums) arr[num]++;\\n        int total=nums.size();\\n        for(int i=0;i<1001;i++){\\n            if(i==total) \\n                return i;\\n            total-=arr[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043929,
                "title": "cpp-beats-100-binary-search",
                "content": "\\n# Approach\\nUse of binary search\\n\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m; \\n    int bin(int i, int j, int n, vector<int>&a)\\n    {\\n        if(i > j)\\n        return -1;\\n\\n        m = (i+j)/2;\\n\\n        if(a[m] >= n-m)\\n        {\\n            if(m == 0)\\n            return n;\\n            \\n            if(a[m-1] < n-m)\\n            return n-m;\\n        }\\n\\n        if(a[m] > n-m)\\n        return bin(i,m-1,n,a);\\n        else\\n        return bin(m+1,j,n,a);\\n    }\\n\\n    int specialArray(vector<int>& a) {\\n        int n = a.size();\\n        sort(a.begin(),a.end());\\n        return bin(0,n-1,n,a);\\n        // 0 0 1 4 6 9\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m; \\n    int bin(int i, int j, int n, vector<int>&a)\\n    {\\n        if(i > j)\\n        return -1;\\n\\n        m = (i+j)/2;\\n\\n        if(a[m] >= n-m)\\n        {\\n            if(m == 0)\\n            return n;\\n            \\n            if(a[m-1] < n-m)\\n            return n-m;\\n        }\\n\\n        if(a[m] > n-m)\\n        return bin(i,m-1,n,a);\\n        else\\n        return bin(m+1,j,n,a);\\n    }\\n\\n    int specialArray(vector<int>& a) {\\n        int n = a.size();\\n        sort(a.begin(),a.end());\\n        return bin(0,n-1,n,a);\\n        // 0 0 1 4 6 9\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023612,
                "title": "100-c-binary-search-o-nlog-n",
                "content": "Upvote if it helps...\\uD83D\\uDE43\\t\\n\\t\\n\\tint specialArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n         for(int i = 0; i <= n; i++)\\n        {\\n            int temp = n;\\n            int l=0;\\n             int h=n-1;\\n             while(h>=l){\\n                 int mid=l+(h-l)/2;\\n                 if(nums[mid]>=i){\\n                     temp=mid;\\n                     h=mid-1;\\n                 }\\n                 else l=mid+1;\\n             }\\n             cout<<temp;\\n             if((n-temp)==i)return i;\\n        }\\n        return -1;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/f2598647-0067-4951-8df3-c6f70f7d0dc2_1652123673.4332793.png)\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "Upvote if it helps...\\uD83D\\uDE43\\t\\n\\t\\n\\tint specialArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n         for(int i = 0; i <= n; i++)\\n        {\\n            int temp = n;\\n            int l=0;\\n             int h=n-1;\\n             while(h>=l){\\n                 int mid=l+(h-l)/2;\\n                 if(nums[mid]>=i){\\n                     temp=mid;\\n                     h=mid-1;\\n                 }\\n                 else l=mid+1;\\n             }\\n             cout<<temp;\\n             if((n-temp)==i)return i;\\n        }\\n        return -1;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/f2598647-0067-4951-8df3-c6f70f7d0dc2_1652123673.4332793.png)\\n\\n",
                "codeTag": "C++"
            },
            {
                "id": 2185835,
                "title": "binary-search-without-sorting-the-array",
                "content": "**Shorting the array is unnecessary**, as its complexity is **nLog(n)**.\\nwe can use binary search to point to a number and use linear search to find how many elements are greater or equal to the current element\\n#### Time Complexity:  \\n- O(nlog(n) ) where n is array length,   \\n- O(logN) for binary search.   \\n- O(n) for one linear Search.\\n   \\nBeats 100% time\\n\\n\\n  \\n      public static int specialArray(int[] nums) {\\n            if (nums.length == 1 && nums[0] > 0) {\\n                return 1;\\n            }\\n            int start = 0, end = nums.length;\\n            while (start <= end) {\\n                int mid = (start + end) / 2;\\n                int countG = 0;\\n                //count how many elements are greater or equal to the current element\\n                for (int i : nums) {\\n                    if (i >= mid) {\\n                        countG++;\\n                    }\\n                }\\n                if (countG > mid) {\\n                    start = mid + 1;\\n                } else if (countG < mid) {\\n                    end = mid - 1;\\n                } else {\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n        }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "**Shorting the array is unnecessary**, as its complexity is **nLog(n)**.\\nwe can use binary search to point to a number and use linear search to find how many elements are greater or equal to the current element\\n#### Time Complexity:  \\n- O(nlog(n) ) where n is array length,   \\n- O(logN) for binary search.   \\n- O(n) for one linear Search.\\n   \\nBeats 100% time\\n\\n\\n  \\n      public static int specialArray(int[] nums) {\\n            if (nums.length == 1 && nums[0] > 0) {\\n                return 1;\\n            }\\n            int start = 0, end = nums.length;\\n            while (start <= end) {\\n                int mid = (start + end) / 2;\\n                int countG = 0;\\n                //count how many elements are greater or equal to the current element\\n                for (int i : nums) {\\n                    if (i >= mid) {\\n                        countG++;\\n                    }\\n                }\\n                if (countG > mid) {\\n                    start = mid + 1;\\n                } else if (countG < mid) {\\n                    end = mid - 1;\\n                } else {\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3011887,
                "title": "binary-search-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint specialArray(vector<int>& nums) {\\n\\t\\tint i = 1, j = nums.size();\\n\\t\\twhile(i <= j)\\n        {\\n\\t\\t\\tint mid = i + (j - i)/2, count=0;\\n\\t\\t\\tfor(int k = 0; k < nums.size(); k++)\\n            {\\n\\t\\t\\t\\tif(nums[k] >= mid)\\n                count++;\\t\\t\\n            }\\t\\n\\t\\t\\tif(count==mid)\\n            return mid;\\n\\t\\t\\telse if(count<mid)\\n            j = mid - 1;\\n\\t\\t\\telse\\n            i = mid + 1;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint specialArray(vector<int>& nums) {\\n\\t\\tint i = 1, j = nums.size();\\n\\t\\twhile(i <= j)\\n        {\\n\\t\\t\\tint mid = i + (j - i)/2, count=0;\\n\\t\\t\\tfor(int k = 0; k < nums.size(); k++)\\n            {\\n\\t\\t\\t\\tif(nums[k] >= mid)\\n                count++;\\t\\t\\n            }\\t\\n\\t\\t\\tif(count==mid)\\n            return mid;\\n\\t\\t\\telse if(count<mid)\\n            j = mid - 1;\\n\\t\\t\\telse\\n            i = mid + 1;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671880,
                "title": "o-n-solution-easy-to-understand-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> count(1001,0);  // initialize an array we know there can maximum 1000 elements\\n        for(int i = 0;i<n;i++){\\n            count[arr[i]]++;   // store which element comes how many times into count at its index like--> if 4 comes 3 times then at the index 4 we store 3 in count array\\n        }\\n        int total = n;   // total size of array\\n        for(int i = 0;i<1001;i++){  // traversing the array count which we have created uper (frequency of every number in original array)\\n            if(i == total) return i;  // if we found ok this numberFrequency is equal to total(initially size of original array) of original array else we decrease total by one  (because we have to check for smaller element)\\n            total -= count[i];\\n        }\\n        \\n        // if there are no such number such that number of element greater that is equal to that number then we return -1\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> count(1001,0);  // initialize an array we know there can maximum 1000 elements\\n        for(int i = 0;i<n;i++){\\n            count[arr[i]]++;   // store which element comes how many times into count at its index like--> if 4 comes 3 times then at the index 4 we store 3 in count array\\n        }\\n        int total = n;   // total size of array\\n        for(int i = 0;i<1001;i++){  // traversing the array count which we have created uper (frequency of every number in original array)\\n            if(i == total) return i;  // if we found ok this numberFrequency is equal to total(initially size of original array) of original array else we decrease total by one  (because we have to check for smaller element)\\n            total -= count[i];\\n        }\\n        \\n        // if there are no such number such that number of element greater that is equal to that number then we return -1\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890802,
                "title": "python-count-and-binary-search",
                "content": "```python\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        left, mid, right = 0, 0, len(nums)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            loc = bisect_left(nums, mid)\\n            if len(nums) - loc == mid: return mid\\n            elif len(nums) - loc > mid: left = mid + 1\\n            else: right = mid - 1\\n        return -1\\n\\t\\n````",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        left, mid, right = 0, 0, len(nums)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            loc = bisect_left(nums, mid)\\n            if len(nums) - loc == mid: return mid\\n            elif len(nums) - loc > mid: left = mid + 1\\n            else: right = mid - 1\\n        return -1\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527669,
                "title": "python-faster-than-94-2-methods-o-nlogn",
                "content": "Method 1 : Without Binary Search 29ms, Using Linear Search. No nested for loop\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n\\n        if n<=nums[0]:\\n            return n\\n        \\n        for i in range(1,n):\\n            count = n-i       #counts number of elements in nums greater than equal i\\n            if nums[i]>=(count) and (count)>nums[i-1]:\\n                return count \\n        return -1\\n\\n```\\nMethod 2: With using Binary Search 40ms.\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n\\n        if n<=nums[0]:\\n            return n\\n        \\n        #binary search\\n        start,end = 0,n\\n                \\n        while(start<=end):\\n            mid = (start+end)//2\\n            #index of middle element\\n            count = 0\\n            for i in range(0,n):\\n                if nums[i]>=mid:\\n                    count = n-i\\n                    #count+=1 could use this but will take more iterations then.\\n                    break\\n        \\n            if count==mid:\\n                return count\\n            elif count<mid:\\n                end = mid-1\\n            else:\\n                start=mid+1            \\n        \\n        return -1\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n\\n        if n<=nums[0]:\\n            return n\\n        \\n        for i in range(1,n):\\n            count = n-i       #counts number of elements in nums greater than equal i\\n            if nums[i]>=(count) and (count)>nums[i-1]:\\n                return count \\n        return -1\\n\\n```\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n\\n        if n<=nums[0]:\\n            return n\\n        \\n        #binary search\\n        start,end = 0,n\\n                \\n        while(start<=end):\\n            mid = (start+end)//2\\n            #index of middle element\\n            count = 0\\n            for i in range(0,n):\\n                if nums[i]>=mid:\\n                    count = n-i\\n                    #count+=1 could use this but will take more iterations then.\\n                    break\\n        \\n            if count==mid:\\n                return count\\n            elif count<mid:\\n                end = mid-1\\n            else:\\n                start=mid+1            \\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339223,
                "title": "simple-and-easy-using-binary-search-in-c",
                "content": "```\\n int specialArray(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<=nums.size();i++){\\n            \\n            int index=lower_bound(nums.begin(),nums.end(),i) - nums.begin();\\n            \\n            int count= (nums.size() - index);\\n            \\n            if(count==i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n int specialArray(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<=nums.size();i++){\\n            \\n            int index=lower_bound(nums.begin(),nums.end(),i) - nums.begin();\\n            \\n            int count= (nums.size() - index);\\n            \\n            if(count==i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 889384,
                "title": "javascript-3-solutions-from-o-n-2-to-o-n",
                "content": "## SOLUTION 1\\n\\nStraight forward O(n^2) solution:\\n\\n```js\\nconst specialArray = (nums) => {\\n  for (let i = 0; i <= nums.length; ++i) {\\n    let c = 0;\\n    for (const num of nums) {\\n      num >= i && ++c;\\n    }\\n    if (c === i) return i;\\n  }\\n  return -1;\\n};\\n```\\n\\n## SOLUTION 2\\n\\nWe sort the `nums` first and add an edge at the end.\\nThen, we traversal the array and try to find out the total count for every number.\\nIf the count is smaller or equal to the number and bigger than the next number, then that\\'s the answer.\\n\\n```js\\nconst specialArray = (nums) => {\\n  nums.sort((a, b) => b - a);\\n  nums.push(-1);\\n  for (let i = 0, prev = 0; i <= nums.length; ++i) {\\n    if (nums[i] === nums[prev]) continue;\\n    if (i <= nums[prev] && i > nums[i]) return i;\\n    prev = i;\\n  }\\n  return -1;\\n};\\n```\\n\\n## SOLUTION 3\\n\\nWe use a fixed-length array to save the counting result.\\nThen, check every possible number, sum and save the counts from large to small, and if the sum is equal to the number, that\\'s the answer.\\n\\n```js\\nconst specialArray = (nums) => {\\n  const len = nums.length;\\n  const count = new Uint8Array(len + 1);\\n  for (const num of nums) {\\n    ++count[num > len ? len : num];\\n  }\\n  for (let i = len, sum = 0; i >= 0; --i) {\\n    sum += count[i];\\n    if (sum === i) return i;\\n  }\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst specialArray = (nums) => {\\n  for (let i = 0; i <= nums.length; ++i) {\\n    let c = 0;\\n    for (const num of nums) {\\n      num >= i && ++c;\\n    }\\n    if (c === i) return i;\\n  }\\n  return -1;\\n};\\n```\n```js\\nconst specialArray = (nums) => {\\n  nums.sort((a, b) => b - a);\\n  nums.push(-1);\\n  for (let i = 0, prev = 0; i <= nums.length; ++i) {\\n    if (nums[i] === nums[prev]) continue;\\n    if (i <= nums[prev] && i > nums[i]) return i;\\n    prev = i;\\n  }\\n  return -1;\\n};\\n```\n```js\\nconst specialArray = (nums) => {\\n  const len = nums.length;\\n  const count = new Uint8Array(len + 1);\\n  for (const num of nums) {\\n    ++count[num > len ? len : num];\\n  }\\n  for (let i = len, sum = 0; i >= 0; --i) {\\n    sum += count[i];\\n    if (sum === i) return i;\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877936,
                "title": "javascript-c-o-n-no-sort",
                "content": "```\\nvar specialArray = function(nums) {\\n    const freq = new Array(1001).fill(0);\\n    for(let n of nums)\\n        freq[n]++;\\n    \\n    for(let i=1000, cnt=0; i>=0; i--){\\n        cnt += freq[i];\\n        if(i==cnt) return i;\\n    }\\n    \\n    return -1;\\n};\\n```\\n\\n```\\nint specialArray(vector<int>& nums) {\\n\\tvector<int> freq(1001, 0);\\n\\tfor(auto n: nums)\\n\\t\\tfreq[n]++;\\n\\n\\tfor(int i=1000, cnt=0; i>=0; i--){\\n\\t\\tcnt+=freq[i];\\n\\t\\tif(i==cnt) return i;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nvar specialArray = function(nums) {\\n    const freq = new Array(1001).fill(0);\\n    for(let n of nums)\\n        freq[n]++;\\n    \\n    for(let i=1000, cnt=0; i>=0; i--){\\n        cnt += freq[i];\\n        if(i==cnt) return i;\\n    }\\n    \\n    return -1;\\n};\\n```\n```\\nint specialArray(vector<int>& nums) {\\n\\tvector<int> freq(1001, 0);\\n\\tfor(auto n: nums)\\n\\t\\tfreq[n]++;\\n\\n\\tfor(int i=1000, cnt=0; i>=0; i--){\\n\\t\\tcnt+=freq[i];\\n\\t\\tif(i==cnt) return i;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2521376,
                "title": "js-o-1-space-binary-search-explained",
                "content": "## TL-DR: **Plain Solution** \\n\\n```\\nvar specialArray = function(nums) {\\n    const N = nums.length; let l = 0, r = N-1; \\n    \\n    nums.sort((a,b) => a - b);\\n    \\n    while(l < r - 1){\\n        let mid = l + ((r - l) >> 1);\\n        let x = N - mid;\\n        \\n        if(nums[mid] >= x && x > nums[mid-1]) return x;\\n        \\n        nums[mid] < x ? l = mid : r = mid;\\n    }\\n    \\n    let x = N - l;\\n\\treturn nums[l] >= x ?  x : -1;\\n};\\n```\\n\\n---\\n\\n## **Explanation**\\n\\nInstead of counting the amount of *\"numbers in nums that are greater than or equal to x\"*, once we sort `nums`, we can understand `x` as being the *relative distance* of the **current index** to the end of `nums`, ie `x` equals to `N - index`, where `N` is the length of `nums`.\\n\\nThen we will assume that if `nums[index]` is greater or equal to `x`, so we have a ***potential solution***, as we can only know that we have **at least** `x` numbers that are greater or equal to `x` until this point; than the next step is to verify if the previous number in `nums` gives us the condition to be sure that `x` is our desired solution.\\n\\nLet\\'s see some edge cases, starting from the **Example 3** of question statement:\\n\\n```\\n[0,4,3,0,4]  === sorts to ==>  [0,0,3,4,4]\\n```\\n\\nSuppose our algorithm reaches the state where our `index` is equal to `2`; then, as our `N` is `5`, so we have to verify if `3` is a possible solution for `x`;  as `nums[2]` equals to `3`, so the value `3` is a *potential solution*; as the previous value `nums[1]` (`0`) is lower than `3`, so now we can say that there is **exaclty 3** numbers in `nums`  that is **greater or equal to 3**. So the answer is `3`.\\n\\nNow, lets try a case where we can not find a solution. Suppose we have the sorted array below:\\n\\n```\\n[0,3,6,7,7]\\n```\\n\\nHere our `N` is also `5`, and the binary search reached the index `2` again. So, we have `3` as being a *potential solution* for `x`, as `nums[2]` (`6`) is greater than `3`. But  when we look to the previous number, we have that `nums[1]` is also `3`; therefore, in place of having ***exactly 3 numbers greater or equal to 3***, we have **4 numbers** instead, so `3` is **not** the solution we were looking for!\\n\\nAnd now, as `3` is at position `1` and would not attend the requirements because it is lower than a `x` with value `4`, we can garantee that any previous number will also not be a potential solution; at same time, we know that for any number after index `2` there\\'s always at least one more number that would be greater or equal to any *potential* `x`. So, the answer should be `-1`.\\n\\nBellow, the solution with comments to elucidate how to build the binary search properly for this problem.\\n\\n```\\nvar specialArray = function(nums) {\\n    const N = nums.length;\\n    \\n    nums.sort((a,b) => a - b);\\n    \\n    // `r` should always correspond a valid `nums` index\\n    let l = 0, r = N-1; \\n    \\n    // as we depend of the previous element of the array\\n    // to take the correct decision, we want to garantee\\n    // that the search will end with `l` strictly lower\\n    // than `r`.\\n    while(l < r - 1){\\n        let mid = l + ((r - l) >> 1);\\n        let x = N - mid;\\n        \\n        // when we find a number at sorted array that is\\n        // greater or equal to `x` and `x` is greater than\\n        // previous value, than we found our answer.\\n        if(nums[mid] >= x && x > nums[mid-1]) return x;\\n        \\n        nums[mid] < x ? l = mid : r = mid;\\n    }\\n    \\n    // at the end of binary search, if the lower value\\n    // atends to the statement requirements, than we\\n    // found the `x` we were looking for.\\n    let x = N - l;\\n    if(nums[l] >= x) return x;\\n    \\n    return -1;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar specialArray = function(nums) {\\n    const N = nums.length; let l = 0, r = N-1; \\n    \\n    nums.sort((a,b) => a - b);\\n    \\n    while(l < r - 1){\\n        let mid = l + ((r - l) >> 1);\\n        let x = N - mid;\\n        \\n        if(nums[mid] >= x && x > nums[mid-1]) return x;\\n        \\n        nums[mid] < x ? l = mid : r = mid;\\n    }\\n    \\n    let x = N - l;\\n\\treturn nums[l] >= x ?  x : -1;\\n};\\n```\n```\\n[0,4,3,0,4]  === sorts to ==>  [0,0,3,4,4]\\n```\n```\\n[0,3,6,7,7]\\n```\n```\\nvar specialArray = function(nums) {\\n    const N = nums.length;\\n    \\n    nums.sort((a,b) => a - b);\\n    \\n    // `r` should always correspond a valid `nums` index\\n    let l = 0, r = N-1; \\n    \\n    // as we depend of the previous element of the array\\n    // to take the correct decision, we want to garantee\\n    // that the search will end with `l` strictly lower\\n    // than `r`.\\n    while(l < r - 1){\\n        let mid = l + ((r - l) >> 1);\\n        let x = N - mid;\\n        \\n        // when we find a number at sorted array that is\\n        // greater or equal to `x` and `x` is greater than\\n        // previous value, than we found our answer.\\n        if(nums[mid] >= x && x > nums[mid-1]) return x;\\n        \\n        nums[mid] < x ? l = mid : r = mid;\\n    }\\n    \\n    // at the end of binary search, if the lower value\\n    // atends to the statement requirements, than we\\n    // found the `x` we were looking for.\\n    let x = N - l;\\n    if(nums[l] >= x) return x;\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330480,
                "title": "python-simple-python-solution-using-two-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n\\t\\n# Approach 1 : Using Binary Search\\n# Runtime: 52 ms, faster than 62.06% of Python3 online submissions for Special Array With X Elements Greater Than or Equal X.\\n# Memory Usage: 13.8 MB, less than 62.52% of Python3 online submissions for Special Array With X Elements Greater Than or Equal X.\\n\\tclass Solution:\\n\\t\\tdef specialArray(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tlow  = 0\\n\\t\\t\\thigh = 1000\\n\\n\\t\\t\\twhile low <= high:\\n\\n\\t\\t\\t\\tmid = ( low + high ) //2\\n\\n\\t\\t\\t\\tcount = 0\\n\\n\\t\\t\\t\\tfor current_number in nums:\\n\\n\\t\\t\\t\\t\\tif current_number >= mid:\\n\\n\\t\\t\\t\\t\\t\\tcount = count + 1\\n\\n\\t\\t\\t\\tif mid == count:\\n\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\telif mid < count:\\n\\t\\t\\t\\t\\tlow = mid + 1\\n\\n\\t\\t\\t\\telif mid > count:\\n\\t\\t\\t\\t\\thigh = mid - 1\\n\\n\\t\\t\\treturn -1\\n\\n# Approach 2 : Using Simple Loop\\n# Runtime: 44 ms, faster than 50.57% of Python3 online submissions for Special Array With X Elements Greater Than or Equal X.\\n# Memory Usage: 13.8 MB, less than 62.52% of Python3 online submissions for Special Array With X Elements Greater Than or Equal X.\\n\\n\\tclass Solution:\\n\\t\\tdef specialArray(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tnums = sorted(nums)[::-1]\\n\\n\\t\\t\\tfor num in range(len(nums) + 1):\\n\\n\\t\\t\\t\\tcount = 0\\n\\n\\t\\t\\t\\tfor current_number in nums:\\n\\n\\t\\t\\t\\t\\tif current_number >= num:\\n\\n\\t\\t\\t\\t\\t\\tcount = count + 1\\n\\n\\t\\t\\t\\tif count == num:\\n\\t\\t\\t\\t\\treturn num\\n\\n\\t\\t\\treturn -1\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n\\t\\n# Approach 1 : Using Binary Search\\n# Runtime: 52 ms, faster than 62.06% of Python3 online submissions for Special Array With X Elements Greater Than or Equal X.\\n# Memory Usage: 13.8 MB, less than 62.52% of Python3 online submissions for Special Array With X Elements Greater Than or Equal X.\\n\\tclass Solution:\\n\\t\\tdef specialArray(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tlow  = 0\\n\\t\\t\\thigh = 1000\\n\\n\\t\\t\\twhile low <= high:\\n\\n\\t\\t\\t\\tmid = ( low + high ) //2\\n\\n\\t\\t\\t\\tcount = 0\\n\\n\\t\\t\\t\\tfor current_number in nums:\\n\\n\\t\\t\\t\\t\\tif current_number >= mid:\\n\\n\\t\\t\\t\\t\\t\\tcount = count + 1\\n\\n\\t\\t\\t\\tif mid == count:\\n\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\telif mid < count:\\n\\t\\t\\t\\t\\tlow = mid + 1\\n\\n\\t\\t\\t\\telif mid > count:\\n\\t\\t\\t\\t\\thigh = mid - 1\\n\\n\\t\\t\\treturn -1\\n\\n# Approach 2 : Using Simple Loop\\n# Runtime: 44 ms, faster than 50.57% of Python3 online submissions for Special Array With X Elements Greater Than or Equal X.\\n# Memory Usage: 13.8 MB, less than 62.52% of Python3 online submissions for Special Array With X Elements Greater Than or Equal X.\\n\\n\\tclass Solution:\\n\\t\\tdef specialArray(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tnums = sorted(nums)[::-1]\\n\\n\\t\\t\\tfor num in range(len(nums) + 1):\\n\\n\\t\\t\\t\\tcount = 0\\n\\n\\t\\t\\t\\tfor current_number in nums:\\n\\n\\t\\t\\t\\t\\tif current_number >= num:\\n\\n\\t\\t\\t\\t\\t\\tcount = count + 1\\n\\n\\t\\t\\t\\tif count == num:\\n\\t\\t\\t\\t\\treturn num\\n\\n\\t\\t\\treturn -1\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 1603563,
                "title": "java-brute-force-binary-search-approach",
                "content": "**IF U DO LIKE SOLUTION PLEASE UPVOTE IT**\\nHere we can solve this problem using two approaches\\n1. brute force approach\\n2. binary search\\n\\nbrute force approach : \\n\\nHere we point two pointers at start of the array and iterate through the loop for the solution\\ntime complexity - O(n2)\\n\\nBinary search approach\\nHere we get left most index of the every number from 1 to 100 with in the array so that we get the optimal solution\\nTime complexity - O(nlogn)\\n\\nBrute force solution \\n```\\nclass Solution {\\n\\n    public int specialArray(int[] nums) {\\n   \\n        int count=0 ; // Intializing count to zero\\n        for(int i = 0 ; i<= 100 ; i++){\\n            for(int j = 0 ; j < nums.length ; j++){\\n                if(i <= nums[j]){   //updating the count\\n                    count++;\\n                }\\n            }\\n            if(count == i) { //check for the condition\\n                return i;\\n            }\\n            count = 0 ;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nBinary search solution :\\n\\n```\\nclass Solution {\\n\\n    public int specialArray(int[] nums) {\\n      \\n       Arrays.sort(nums);\\n        for(int i = 0 ; i < 101 ; i++){\\n            if(i == nums.length-leftMostIndex(nums,i)) return i ;\\n        }\\n        return -1;\\n    }\\n\\t// function to get left most value\\n   private  int leftMostIndex(int[] nums ,int target){\\n       int left = 0 , right = nums.length-1;\\n        while(left<=right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid]>=target){\\n                right = mid-1;\\n            }else if(nums[mid]<target){\\n                left = mid+1;\\n            }\\n        }\\n        return left ;  //we can return either left or mid as both pointers point same index\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int specialArray(int[] nums) {\\n   \\n        int count=0 ; // Intializing count to zero\\n        for(int i = 0 ; i<= 100 ; i++){\\n            for(int j = 0 ; j < nums.length ; j++){\\n                if(i <= nums[j]){   //updating the count\\n                    count++;\\n                }\\n            }\\n            if(count == i) { //check for the condition\\n                return i;\\n            }\\n            count = 0 ;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public int specialArray(int[] nums) {\\n      \\n       Arrays.sort(nums);\\n        for(int i = 0 ; i < 101 ; i++){\\n            if(i == nums.length-leftMostIndex(nums,i)) return i ;\\n        }\\n        return -1;\\n    }\\n\\t// function to get left most value\\n   private  int leftMostIndex(int[] nums ,int target){\\n       int left = 0 , right = nums.length-1;\\n        while(left<=right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid]>=target){\\n                right = mid-1;\\n            }else if(nums[mid]<target){\\n                left = mid+1;\\n            }\\n        }\\n        return left ;  //we can return either left or mid as both pointers point same index\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880677,
                "title": "java-o-nlogn-step-by-step-easy-explain-and-intuition-of-hint",
                "content": "```\\nclass Solution {\\n    private static int binSrc(int [] nums , int target){\\n        int low = 0 ; \\n        int high = nums.length - 1;\\n        //  when target < min number in array\\n        if(target < nums[low])\\n            return low ;\\n        //  when target > max number in array\\n        if(target > nums[high])\\n            return high + 1;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\n        }\\n        return low ;\\n    }\\n    // pls consdier HINT 1 : very helpful and expand idea , the 1st hint really helped me to solve this .\\n    \\n    // this is hint comes from the idea that the min number of elt in the array can be 0 and max \\n    // number of elts in array can be n , so lets say when x == 0 , we need 0 elts >= x \\n    // OR when x == n , we need n elts >= x , so just think aboutt it for a minute\\n    \\n    // in any case x MUST lie in the range (0 , n) and when x >= n + 1 , we dont need to continue anymore \\n    // because it is evident we cannot satisfy the requiredd condition anymore\\n    \\n    \\n    // STEPS -> \\n    // 1 . sort nums \\n    // 2 . search for every x in range[0 , nums.length] number of  elts strictly < x , we can do this by finding the \\n    //     first occurence of x (if it exists) OR by finding the insert position of X (if it does not exist)\\n    // 3 . get the insert postion and calculate how many elts greater >= x , if condition satisfies return x \\n    //     else return -1 \\n    \\n    public int specialArray(int[] nums) {\\n        // O(nlogn)\\n        Arrays.sort(nums);\\n        int n = nums.length ;\\n        // O(nlogn)\\n        for(int x = 0 ; x <= n ; x++){\\n            int elements_Smaller_thanX = binSrc(nums, x);\\n            if(n - elements_Smaller_thanX == x)\\n                return x ;\\n        }\\n        \\n        return -1 ;\\n    }\\n}\\n```\\nhope this helps tysm",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static int binSrc(int [] nums , int target){\\n        int low = 0 ; \\n        int high = nums.length - 1;\\n        //  when target < min number in array\\n        if(target < nums[low])\\n            return low ;\\n        //  when target > max number in array\\n        if(target > nums[high])\\n            return high + 1;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\n        }\\n        return low ;\\n    }\\n    // pls consdier HINT 1 : very helpful and expand idea , the 1st hint really helped me to solve this .\\n    \\n    // this is hint comes from the idea that the min number of elt in the array can be 0 and max \\n    // number of elts in array can be n , so lets say when x == 0 , we need 0 elts >= x \\n    // OR when x == n , we need n elts >= x , so just think aboutt it for a minute\\n    \\n    // in any case x MUST lie in the range (0 , n) and when x >= n + 1 , we dont need to continue anymore \\n    // because it is evident we cannot satisfy the requiredd condition anymore\\n    \\n    \\n    // STEPS -> \\n    // 1 . sort nums \\n    // 2 . search for every x in range[0 , nums.length] number of  elts strictly < x , we can do this by finding the \\n    //     first occurence of x (if it exists) OR by finding the insert position of X (if it does not exist)\\n    // 3 . get the insert postion and calculate how many elts greater >= x , if condition satisfies return x \\n    //     else return -1 \\n    \\n    public int specialArray(int[] nums) {\\n        // O(nlogn)\\n        Arrays.sort(nums);\\n        int n = nums.length ;\\n        // O(nlogn)\\n        for(int x = 0 ; x <= n ; x++){\\n            int elements_Smaller_thanX = binSrc(nums, x);\\n            if(n - elements_Smaller_thanX == x)\\n                return x ;\\n        }\\n        \\n        return -1 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877745,
                "title": "java-sort-loop",
                "content": "```\\n    public int specialArray(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = -1; i < n - 1; i++) \\n            if (nums[i + 1] >= n - i - 1) { //possible solution\\n                if (i == -1 || nums[i] < n - i - 1) return n - i - 1;  // n - i - 1 is the number after num[i], match condtion\\n                return -1; // impossible now. \\n            } \\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int specialArray(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = -1; i < n - 1; i++) \\n            if (nums[i + 1] >= n - i - 1) { //possible solution\\n                if (i == -1 || nums[i] < n - i - 1) return n - i - 1;  // n - i - 1 is the number after num[i], match condtion\\n                return -1; // impossible now. \\n            } \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877714,
                "title": "java-sort",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i = n - 1; i >= 0; i--) {\\n            while(i > 0 && nums[i] == nums[i - 1]) i--;\\n            if(i > 0) {\\n                if(n - i > nums[i - 1] && n - i <= nums[i]) return n - i;\\n            }\\n        }\\n        if(n == nums[0] || nums[0] > 0 && nums[0] - 1 == n) return n; \\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i = n - 1; i >= 0; i--) {\\n            while(i > 0 && nums[i] == nums[i - 1]) i--;\\n            if(i > 0) {\\n                if(n - i > nums[i - 1] && n - i <= nums[i]) return n - i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4008248,
                "title": "easy-to-understand-solution-binary-search-99-74",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nfunction bs(arr, target){\\n    let left = 0;\\n    let right = arr.length - 1;\\n\\n    while(left < right){\\n        let mid = Math.floor((left + right) / 2);\\n\\n        if(arr[mid] >= target){\\n            right = mid;\\n        }else{\\n            left = mid+1;\\n        }\\n    }\\n    return left \\n}\\n\\nvar specialArray = function(nums) {\\n    nums.sort((a,b) => a - b);\\n\\n    for(let i = 0; i <= nums[nums.length-1]; i++){\\n        let res = bs(nums, i)\\n        if((nums.length - res) === i) return i\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nfunction bs(arr, target){\\n    let left = 0;\\n    let right = arr.length - 1;\\n\\n    while(left < right){\\n        let mid = Math.floor((left + right) / 2);\\n\\n        if(arr[mid] >= target){\\n            right = mid;\\n        }else{\\n            left = mid+1;\\n        }\\n    }\\n    return left \\n}\\n\\nvar specialArray = function(nums) {\\n    nums.sort((a,b) => a - b);\\n\\n    for(let i = 0; i <= nums[nums.length-1]; i++){\\n        let res = bs(nums, i)\\n        if((nums.length - res) === i) return i\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515519,
                "title": "well-explained-2-approaches-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can iterate over all possible values of x and check if there are exactly x numbers in nums that are greater than or equal to x. If we find such a value of x, we can return it as the answer. If we have checked all possible values of x and none of them satisfy the condition, we can return -1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the array in descending order.\\n- Iterate over all possible values of x from 1 to n (the length of the array).\\n- For each value of x, count the number of elements in the array that are greater than or equal to x. If the count is exactly x, return x as the answer.\\n- If we have checked all possible values of x and none of them satisfy the condition, return -1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Brute force Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=1;i<=n;i++){\\n            int cnt=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]>=i){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt==i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful\\u2B06\\uFE0F\\n# Optimized Approach (Using Binary Search)\\n# Intuition\\n\\nwe can optimize the time complexity of the solution from O(n^2) to O(n log n) by using binary search instead of iterating over all possible values of x.\\n# Approach\\n- Sort the array in non-increasing order.\\n- Set the left pointer to 1 and the right pointer to n (the length of the array).\\n- While the left pointer is less than or equal to the right pointer:\\n  - Set the mid pointer to the average of the left and right pointers.\\n  -  Count the number of elements in the array that are greater than or equal to mid. If the count is less than mid, set the right pointer to mid-1. If the count is greater than or equal to mid, set the left pointer to mid+1.\\n- If we have checked all possible values of x and none of them satisfy the condition, return -1. Otherwise, return the value of mid.\\n\\n\\nThe key idea behind this algorithm is that the number of elements in the array that are greater than or equal to x is a monotonic function of x. Therefore, we can use binary search to find the smallest value of x such that there are exactly x elements in the array that are greater than or equal to x.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int left=1,right=n;\\n        \\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]>=mid){\\n                    cnt++;\\n                }else{\\n                    break;\\n                }\\n            }\\n            if(cnt<mid){\\n                right=mid-1;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        if(right<1 || nums[right-1]<right){\\n            return -1;\\n        }\\n        int cal=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=right){\\n                cal++;\\n            }\\n        }\\n        if(cal==right){\\n            return right;\\n        }else{\\n            return -1;\\n        }\\n        return right;\\n    }\\n};\\n```\\n# Time Complexity \\n$$O(nlogn)$$\\n# Space Complexity\\n$$O(1)$$\\n\\n# One Upvote can be really encouraging\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=1;i<=n;i++){\\n            int cnt=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]>=i){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt==i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int left=1,right=n;\\n        \\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]>=mid){\\n                    cnt++;\\n                }else{\\n                    break;\\n                }\\n            }\\n            if(cnt<mid){\\n                right=mid-1;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        if(right<1 || nums[right-1]<right){\\n            return -1;\\n        }\\n        int cal=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=right){\\n                cal++;\\n            }\\n        }\\n        if(cal==right){\\n            return right;\\n        }else{\\n            return -1;\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399864,
                "title": "c-beats-100-0-ms-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int insert_pos(int x,vector<int>& nums){\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low<= high){\\n            int mid = low +(high-low)/2;\\n            if(nums[mid]>=x){\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return nums.size()-low; \\n      }\\n    int specialArray(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n      int low = 0;\\n      \\n      int high = nums.size();\\n      while(low <= high){\\n          int mid = low +(high-low)/2;\\n          int b = insert_pos(mid,nums);\\n          if(b == mid ){\\n              return mid; \\n          }\\n          if(b > mid){\\n              low = mid+1;\\n          }else{\\n              high = mid-1;\\n          }\\n      }\\n    return -1;}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int insert_pos(int x,vector<int>& nums){\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low<= high){\\n            int mid = low +(high-low)/2;\\n            if(nums[mid]>=x){\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return nums.size()-low; \\n      }\\n    int specialArray(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n      int low = 0;\\n      \\n      int high = nums.size();\\n      while(low <= high){\\n          int mid = low +(high-low)/2;\\n          int b = insert_pos(mid,nums);\\n          if(b == mid ){\\n              return mid; \\n          }\\n          if(b > mid){\\n              low = mid+1;\\n          }else{\\n              high = mid-1;\\n          }\\n      }\\n    return -1;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392400,
                "title": "beats-100-easy-cpp-sol",
                "content": "# **PLEASE UPVOTE ME\\uD83E\\uDD79**\\n# Complexity\\n- Time complexity: NLog(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    // function for find element \\n    int findElement(vector<int>&nums, int no){\\n        int ans = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] >= no){\\n                ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int specialArray(vector<int>& nums) {\\n        int si = 0;\\n        int ei = *max_element(nums.begin(), nums.end());\\n\\n        while(si <= ei){\\n            int mid = si + (ei-si)/2;\\n\\n            if(findElement(nums, mid) == mid){\\n                return mid;\\n            }\\n\\n            else if(findElement(nums, mid) > mid){\\n                si = mid+1;\\n            }\\n\\n            else{\\n                ei = mid-1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n\\n**BEATS 100%**\\n**PLEASE UPVOTE ME\\uD83E\\uDD79**\\n![Picture 1.png](https://assets.leetcode.com/users/images/0faa3454-32cf-4fc7-a252-045d9f35a381_1680929641.012999.png)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    // function for find element \\n    int findElement(vector<int>&nums, int no){\\n        int ans = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] >= no){\\n                ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int specialArray(vector<int>& nums) {\\n        int si = 0;\\n        int ei = *max_element(nums.begin(), nums.end());\\n\\n        while(si <= ei){\\n            int mid = si + (ei-si)/2;\\n\\n            if(findElement(nums, mid) == mid){\\n                return mid;\\n            }\\n\\n            else if(findElement(nums, mid) > mid){\\n                si = mid+1;\\n            }\\n\\n            else{\\n                ei = mid-1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119893,
                "title": "java-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int end=nums.length;\\n        int start=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int count=0;\\n            for(int i=0;i<nums.length;i++){\\n                if(nums[i]>=mid) count++;\\n            }\\n            if(count==mid) \\n            return mid;\\n            if(count>mid)\\n            start=mid+1;\\n            else\\n            end=mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int end=nums.length;\\n        int start=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int count=0;\\n            for(int i=0;i<nums.length;i++){\\n                if(nums[i]>=mid) count++;\\n            }\\n            if(count==mid) \\n            return mid;\\n            if(count>mid)\\n            start=mid+1;\\n            else\\n            end=mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725988,
                "title": "two-java-solutions-with-explanation-easy-to-understand",
                "content": "In this post I shall share two solutions in Java language but can be easily understood by any language user.\\n1. **Linear search of number of elements greater than x**\\n\\tTime Complexity: O(n * log(max(nums)))\\n\\tSpace Complexity: O(1)\\n\\tRuntime: 1ms\\n\\tBeats: 92.31%\\n\\tIn this method we binary search over the answer for getting x and then checking if the mid element satisfies the problem constraint.\\n\\t```\\n\\tclass Solution {\\n\\t\\tpublic int specialArray(int[] nums) {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = nums.length;\\n\\t\\t\\tint ans = -1;\\n\\t\\t\\t while(left <= right) {\\n\\t\\t\\t\\tint mid = left + (right - left)/2;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int i: nums) {\\n\\t\\t\\t\\t\\tif(i >= mid) {\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(count == mid) {\\n\\t\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}else if(count > mid) {\\n\\t\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\t```\\n\\t2.**Using prefix array**\\n\\t Time Complexity: O(n + max(nums))\\n\\t Space Complexity: O(max(nums))\\n\\t Runtime: 3ms\\n\\t Beats: 40.44%\\n\\t In this method we get the number of elements greater than particular element using prefix array and retreiving the count in constant time.\\n\\t ```\\n\\t class Solution {\\n\\t\\tpublic int specialArray(int[] nums) {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = nums.length;\\n\\t\\t\\tint ans = -1;\\n\\t\\t\\tint max = nums[0];\\n\\t\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\t\\tif(nums[i] > max)\\n\\t\\t\\t\\t\\tmax = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tint[] prefix = new int[max + 1];\\n\\t\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\t\\tprefix[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=max - 1;i>=0;i--) {\\n\\t\\t\\t\\tprefix[i] = prefix[i + 1] + prefix[i];\\n\\t\\t\\t}\\n\\t\\t\\twhile(left <= right) {\\n\\t\\t\\t\\tint mid = left + (right - left)/2;\\n\\n\\t\\t\\t\\tint count = mid > max? 0: prefix[mid];\\n\\t\\t\\t\\tif(count == mid) {\\n\\t\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}else if(count > mid) {\\n\\t\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n\\tclass Solution {\\n\\t\\tpublic int specialArray(int[] nums) {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = nums.length;\\n\\t\\t\\tint ans = -1;\\n\\t\\t\\t while(left <= right) {\\n\\t\\t\\t\\tint mid = left + (right - left)/2;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int i: nums) {\\n\\t\\t\\t\\t\\tif(i >= mid) {\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(count == mid) {\\n\\t\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}else if(count > mid) {\\n\\t\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\t class Solution {\\n\\t\\tpublic int specialArray(int[] nums) {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = nums.length;\\n\\t\\t\\tint ans = -1;\\n\\t\\t\\tint max = nums[0];\\n\\t\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\t\\tif(nums[i] > max)\\n\\t\\t\\t\\t\\tmax = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tint[] prefix = new int[max + 1];\\n\\t\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\t\\tprefix[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=max - 1;i>=0;i--) {\\n\\t\\t\\t\\tprefix[i] = prefix[i + 1] + prefix[i];\\n\\t\\t\\t}\\n\\t\\t\\twhile(left <= right) {\\n\\t\\t\\t\\tint mid = left + (right - left)/2;\\n\\n\\t\\t\\t\\tint count = mid > max? 0: prefix[mid];\\n\\t\\t\\t\\tif(count == mid) {\\n\\t\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}else if(count > mid) {\\n\\t\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707193,
                "title": "java-solution-in-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int high=nums.length;\\n        int low=0;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            int count=0;\\n            for(int i=0;i<nums.length;i++){\\n                if(nums[i]>=mid) count++;\\n            }\\n            if(count==mid) \\n            return mid;\\n            if(count>mid)\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int high=nums.length;\\n        int low=0;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            int count=0;\\n            for(int i=0;i<nums.length;i++){\\n                if(nums[i]>=mid) count++;\\n            }\\n            if(count==mid) \\n            return mid;\\n            if(count>mid)\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678324,
                "title": "java-binary-search-easy-100-faster",
                "content": "**Just take the search space of 0 to length of array!**\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int high=nums.length;\\n        int low=0;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            int count=0;\\n            for(int i=0;i<nums.length;i++){\\n                if(nums[i]>=mid) count++;\\n            }\\n            if(count==mid) return mid;\\n            if(count>mid)low=mid+1;\\n            else high=mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int high=nums.length;\\n        int low=0;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            int count=0;\\n            for(int i=0;i<nums.length;i++){\\n                if(nums[i]>=mid) count++;\\n            }\\n            if(count==mid) return mid;\\n            if(count>mid)low=mid+1;\\n            else high=mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646407,
                "title": "java-solution-with-detailed-explanation-binary-search",
                "content": "### Please upvote if this helps you! :)\\n\\nAs per the description we need to find a value x which may/may not exist in the array that has exactly x numbers in the array greater than or equal to it.\\n\\n\\n*Code Breakdown:*\\n\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n\\n1.\\tInititalise start and end variables.\\n\\t``` \\t int start = 0, end =Integer.MIN_VALUE;```\\n\\t\\n2. We set the value of end equal to the maximum value in the nums array.\\n\\t\\t##### Reason for this?\\n\\t\\tT*o find a value of x that may have values greater than or equal to it we start with the value of x = 0. Now, for the nums array, the maximum value existing will have no number that is greater than it in the array*.\\n\\t\\t\\n\\t```nums = [0,2,4,1,5];```\\n\\t\\tmax value is 5.\\n\\t\\t\\n\\tThere is no number greater than it, therefore if we set x = 5, we can never find exactly 5 values in the array that are greater than or equal to it.\\n\\tThis implies that x can at max have a value of 5 according to this array (i.e the max value of array)\\n\\t\\t\\n\\t\\tfor(int num:nums){\\n            end = Math.max(num,end);\\n        }\\n\\t\\t\\n\\n3.  Start of while loop\\n\\t``` while(start<=end){```\\n\\n4.  Initialising a mid value (this formula to avoid integer overflow)\\n\\t```int mid = start + (end-start)/2;```\\n           \\n\\n5.  Count variable is used to keep a track of the values exisiting in the array that are greater than or equal to a certain x value in the range between start and end of x.\\n\\n```\\n\\tint count = 0;\\n\\tfor(int num:nums){\\n\\t\\t\\t\\t\\tif(num>=mid){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n```\\n\\n\\t\\t\\t\\t\\n6. If there are exactly x values in the array (count) which are greater than or equal to a certain value of x (mid) we return this value.\\n \\n            if(count==mid){\\n                return mid;\\n            }\\n\\n7. If count is greater than the current value of x (defined by mid here), we look for a greater value in the range of x which may provide us with the solution.\\n```\\n\\telse if(count>mid){\\n\\t\\t\\t\\t\\tstart = mid+1;\\n\\t\\t\\t\\t}\\n```\\n           \\n8. If count is less than the current value of x (defined by mid here), we look for a smaller value in the range of x which may provide us with the solution.\\n ```\\n\\t\\t\\telse{\\n                end = mid-1;\\n            }\\n        }   //while loop ends here\\n```\\n\\n8. Return default value of -1 if ans not found.\\n\\t  ```\\n\\treturn -1;\\n\\t\\t  } //specialArray method ends here\\n\\t\\t  } //Solution class ends here\\n\\t```\\n\\n\\n-------------------------------------------------------------------------------------------\\n  *Entire Java Code*\\n\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int start = 0, end =Integer.MIN_VALUE;\\n        \\n        for(int num:nums){\\n            end = Math.max(num,end);\\n        }\\n        \\n        \\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int count = 0;\\n            \\n            for(int num:nums){\\n                if(num>=mid){\\n                    count++;\\n                }\\n            }\\n            \\n            if(count==mid){\\n                return mid;\\n            }\\n            else if(count>mid){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }    \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "``` \\t int start = 0, end =Integer.MIN_VALUE;```\n```nums = [0,2,4,1,5];```\n``` while(start<=end){```\n```int mid = start + (end-start)/2;```\n```\\n\\tint count = 0;\\n\\tfor(int num:nums){\\n\\t\\t\\t\\t\\tif(num>=mid){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n```\n```\\n\\telse if(count>mid){\\n\\t\\t\\t\\t\\tstart = mid+1;\\n\\t\\t\\t\\t}\\n```\n```\\n\\t\\t\\telse{\\n                end = mid-1;\\n            }\\n        }   //while loop ends here\\n```\n```\\n\\treturn -1;\\n\\t\\t  } //specialArray method ends here\\n\\t\\t  } //Solution class ends here\\n\\t```\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int start = 0, end =Integer.MIN_VALUE;\\n        \\n        for(int num:nums){\\n            end = Math.max(num,end);\\n        }\\n        \\n        \\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int count = 0;\\n            \\n            for(int num:nums){\\n                if(num>=mid){\\n                    count++;\\n                }\\n            }\\n            \\n            if(count==mid){\\n                return mid;\\n            }\\n            else if(count>mid){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }    \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316606,
                "title": "c-simple-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int count(int x,vector<int> nums){\\n        int index=lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n        return nums.size()-index;\\n    }\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int max=nums[nums.size()-1],min=0,mid;\\n        while(min<=max){\\n            mid=min+(max-min)/2;\\n            if(mid==count(mid,nums)){\\n                return mid;\\n            }else if(mid<count(mid,nums)){\\n                min=mid+1;\\n            }else {\\n                max=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(int x,vector<int> nums){\\n        int index=lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n        return nums.size()-index;\\n    }\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int max=nums[nums.size()-1],min=0,mid;\\n        while(min<=max){\\n            mid=min+(max-min)/2;\\n            if(mid==count(mid,nums)){\\n                return mid;\\n            }else if(mid<count(mid,nums)){\\n                min=mid+1;\\n            }else {\\n                max=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923826,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n;i++){\\n            int len = n - i;                      // len gives the number of elements greater than\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // or equal to nums[i]...i.e the number of elements on its right\\n            if(\\n                len <= nums[i] &&                \\n                (i == 0 || len > nums[i-1])\\n            ){\\n                return len;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n;i++){\\n            int len = n - i;                      // len gives the number of elements greater than\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // or equal to nums[i]...i.e the number of elements on its right\\n            if(\\n                len <= nums[i] &&                \\n                (i == 0 || len > nums[i-1])\\n            ){\\n                return len;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610971,
                "title": "runtime-1-ms-easiest-solution",
                "content": "```\\npublic int specialArray(int[] nums) {\\n        int high=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(high<nums[i]){\\n                high=nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<=high;i++){\\n             int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(i<=nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count==i){\\n                return i;\\n         }\\n        }\\n        \\n        return -1;\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int specialArray(int[] nums) {\\n        int high=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(high<nums[i]){\\n                high=nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<=high;i++){\\n             int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(i<=nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count==i){\\n                return i;\\n         }\\n        }\\n        \\n        return -1;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350984,
                "title": "python-binary-search-o-nlogn-faster-than-95-with-explanation",
                "content": "Our goal is to find if there exists a number `x` such that there are exactly x numbers in `nums` that are greater than or equal to `x`. Lets say the special number is two, which means there are exactly two numbers greater than or equal to 2. The  value of x can be between `0` and `max(nums)`. So we sort the array and use binary search to check if any such number exists. \\n\\n`bisect.bisect_left(nums,mid)`\\nGives us the left most position for the number `mid` (Since we have the condition as greater than or equal to). If the number of elements to right of `mid` is equal to `mid`, it is the required number. Else, there are two possibilities,\\n* If the number of elements to the right is less than `mid`, it means the value of `mid` must be higher. So we start the binary search from mid+1. \\n* If the number of elements to the right is greater than `mid`, it means the value of `mid` must be lower. So we start the binary search up to  mid-1. \\nWe do this repeatedly until we find a suitable number that fits our condition, else we return -1. \\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        low , high = 0 , max(nums)\\n        nums.sort()\\n        while low <= high:\\n            mid = (low+high)//2\\n            pos = bisect.bisect_left(nums,mid)\\n            if len(nums) - pos == mid:\\n                return mid\\n            elif len(nums) - pos< mid:\\n                high = mid-1\\n            else:\\n                low  = mid+1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        low , high = 0 , max(nums)\\n        nums.sort()\\n        while low <= high:\\n            mid = (low+high)//2\\n            pos = bisect.bisect_left(nums,mid)\\n            if len(nums) - pos == mid:\\n                return mid\\n            elif len(nums) - pos< mid:\\n                high = mid-1\\n            else:\\n                low  = mid+1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877706,
                "title": "a-few-solutions",
                "content": "Let `N` be the cardinality of `A`, then consider all possible values from `0..N` inclusive as the `i`<sup>th</sup> special value.  Return `i` if and only if the lower bound of `i` in the sorted array `A` equals `N - i`, otherwise return `-1`.\\n    \\n**Note:** Javascript does *not* have built-in language support for binary search, so [we can use this gist](https://gist.github.com/claytonjwong/53bd1c1489b12eccad176addb8afd8e0) from which I copy/pasted the `lowerBound` function.\\n\\n---\\n\\n*Javascript*\\n```\\nlet lowerBound = (A, T) => {\\n    let N = A.length,\\n        i = 0,\\n        j = N;\\n    while (i < j) {\\n        let k = Math.floor((i + j) / 2);\\n        if (A[k] < T)\\n            i = k + 1;\\n        else\\n            j = k;\\n    }\\n    return i;\\n};\\nlet specialArray = A => {\\n    let N = A.length;\\n    A.sort((a, b) => a - b);\\n    for (let i = 0; i <= N; ++i)\\n        if (lowerBound(A, i) == N - i)\\n            return i;\\n    return -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def specialArray(self, A: List[int]) -> int:\\n        N = len(A)\\n        A.sort()\\n        for i in range(N + 1):\\n            if bisect_left(A, i) == N - i:\\n                return i\\n        return -1\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int specialArray(VI& A) {\\n        int N = A.size();\\n        sort(A.begin(), A.end());\\n        for (auto i{ 0 }; i <= N; ++i)\\n            if (distance(A.begin(), lower_bound(A.begin(), A.end(), i)) == N - i)\\n                return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet lowerBound = (A, T) => {\\n    let N = A.length,\\n        i = 0,\\n        j = N;\\n    while (i < j) {\\n        let k = Math.floor((i + j) / 2);\\n        if (A[k] < T)\\n            i = k + 1;\\n        else\\n            j = k;\\n    }\\n    return i;\\n};\\nlet specialArray = A => {\\n    let N = A.length;\\n    A.sort((a, b) => a - b);\\n    for (let i = 0; i <= N; ++i)\\n        if (lowerBound(A, i) == N - i)\\n            return i;\\n    return -1;\\n};\\n```\n```\\nclass Solution:\\n    def specialArray(self, A: List[int]) -> int:\\n        N = len(A)\\n        A.sort()\\n        for i in range(N + 1):\\n            if bisect_left(A, i) == N - i:\\n                return i\\n        return -1\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int specialArray(VI& A) {\\n        int N = A.size();\\n        sort(A.begin(), A.end());\\n        for (auto i{ 0 }; i <= N; ++i)\\n            if (distance(A.begin(), lower_bound(A.begin(), A.end(), i)) == N - i)\\n                return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879009,
                "title": "java-detailed-binary-search-solution",
                "content": "# Intuition\\n  First of all we will discuss Why Binary Search, even if the array is not sorted . Look here the array is not sorted but lemme tell you if we have some range so we can definitely apply binary search on range because range is something which will always be in a sorted fashion for example suppose we have the range [5,20] so here 5 to 20 means 5,6,7,8,9,10...till 20 which is sorted in itself. So remember we can apply Binary Search on **range** too.\\n\\nNow, here the array is not sorted so what left? Can we figure out some range? Yes we definitely can !! Just observe this atleast we will be having 1 such element which will be greater than other elements , right? so our range will definitely start from 1 now what will be the ending point ? It will definitely be the maximum element of an array. Now we have the range [1,max_element] on which we can apply Binary Search.\\n\\nNow we can apply standard binary search algorithm here which consist of 4 steps :\\nStep 1 : Calculate the mid point.\\nStep 2 : If the mid meets the desire result we will simply returns it.\\nStep 3 : a) If the mid has more greater number than obviously the numbers which are present before to mid will also has the greater numbers so in this situation it would be like a time waste to search in the left half , rather we can reduce our search space and will eliminate the left half and can jump to the right half.\\nStep 4 : b) Otherwise we will simply jump to left part instead of searching in right half.\\n\\n# Approach\\n  Binary Search Algorithm.\\n\\n# Complexity\\n- Time complexity:\\n  O(max)*logn\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPossibility(int []nums,int x){\\n        int cnt=0;\\n        for(int n:nums) if(n>=x) cnt++;\\n        return cnt;\\n    }\\n    public int specialArray(int[] nums) {\\n        int maxi=Integer.MIN_VALUE,start=1,mid=0;\\n        for(int x:nums) maxi=Math.max(maxi,x);\\n        int end = maxi;\\n        while(start<=end){\\n            mid = (start+end)/2;\\n            int check = countPossibility(nums,mid);\\n            if(check==mid) return mid;\\n            if(mid<check) start=mid+1;\\n            else end=mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countPossibility(int []nums,int x){\\n        int cnt=0;\\n        for(int n:nums) if(n>=x) cnt++;\\n        return cnt;\\n    }\\n    public int specialArray(int[] nums) {\\n        int maxi=Integer.MIN_VALUE,start=1,mid=0;\\n        for(int x:nums) maxi=Math.max(maxi,x);\\n        int end = maxi;\\n        while(start<=end){\\n            mid = (start+end)/2;\\n            int check = countPossibility(nums,mid);\\n            if(check==mid) return mid;\\n            if(mid<check) start=mid+1;\\n            else end=mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813614,
                "title": "easiest-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved using **Binary Search + Linear Search.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn Binary search we do search on a range of values. So first think that the answer will always lies between [0-array_size].Suppose array size is 5 then answer cant be 6 because there is only 5 elements and it will not satisfy the condition.\\n\\nDo a Binary Search on [0-array_size].\\nFor each iteration see that how many elements are there in array and is it satisfying the solution.\\n\\nYou can use the lower_bound concept for that.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt would be O(array_size*nlogn).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIt would be O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        //optimized solution \\n        //answer ranges between 0 and array length.\\n        //sort the array to use Binary Search. --> O(nlogn);\\n        sort(nums.begin(),nums.end());\\n        int low= 0;\\n        int high = nums.size(); \\n\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n        int lb=lower_bound(nums.begin(),nums.end(),mid)-nums.begin();\\n            int count = nums.size()-lb;\\n            if(count == mid) //satisfying the condition\\n                return mid;\\n            else if(count>mid)  low=mid+1;  \\n            else high = mid-1;\\n            \\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        //optimized solution \\n        //answer ranges between 0 and array length.\\n        //sort the array to use Binary Search. --> O(nlogn);\\n        sort(nums.begin(),nums.end());\\n        int low= 0;\\n        int high = nums.size(); \\n\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n        int lb=lower_bound(nums.begin(),nums.end(),mid)-nums.begin();\\n            int count = nums.size()-lb;\\n            if(count == mid) //satisfying the condition\\n                return mid;\\n            else if(count>mid)  low=mid+1;  \\n            else high = mid-1;\\n            \\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389042,
                "title": "java-simple-solution-sorting-binarysearch",
                "content": "# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for (int num = 0; num <= nums[n - 1]; num++) {\\n            int index = findFirstGreaterOrEqual(nums, num);\\n            if (n - index == num) {\\n                return num;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private int findFirstGreaterOrEqual(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] >= target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for (int num = 0; num <= nums[n - 1]; num++) {\\n            int index = findFirstGreaterOrEqual(nums, num);\\n            if (n - index == num) {\\n                return num;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private int findFirstGreaterOrEqual(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] >= target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346392,
                "title": "easy-java-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int start=0;\\n        int end=nums.length;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int count=0;\\n            for(int i=0;i<nums.length;i++){\\n                if(nums[i]>=mid){\\n                    count++;\\n                }\\n            }\\n            if(count==mid) return mid;\\n            if(count>mid) start=mid+1;\\n            else end=mid-1; \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int start=0;\\n        int end=nums.length;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int count=0;\\n            for(int i=0;i<nums.length;i++){\\n                if(nums[i]>=mid){\\n                    count++;\\n                }\\n            }\\n            if(count==mid) return mid;\\n            if(count>mid) start=mid+1;\\n            else end=mid-1; \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283655,
                "title": "0ms-faster-easy-c",
                "content": "# Intuition\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int specialArray(vector<int>& nums) {\\n        int max = INT_MIN;\\n        for(auto x: nums){\\n            if(x>max){\\n                max=x;\\n            }\\n        }\\n        int l = 0;\\n        int h = max;\\n\\n        sort(nums.begin(),nums.end());\\n     \\n        int ctr=0;\\n        while(l<=h){\\n            ctr=0;\\n            int mid = l+(h-l)/2;\\n        \\n            for(int i=0; i<nums.size(); i++){\\n                if(nums[i]>=mid){\\n                    ctr++;\\n                }\\n            }\\n            if(ctr==mid){\\n                return mid;\\n            }\\n            if(ctr<mid){\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int specialArray(vector<int>& nums) {\\n        int max = INT_MIN;\\n        for(auto x: nums){\\n            if(x>max){\\n                max=x;\\n            }\\n        }\\n        int l = 0;\\n        int h = max;\\n\\n        sort(nums.begin(),nums.end());\\n     \\n        int ctr=0;\\n        while(l<=h){\\n            ctr=0;\\n            int mid = l+(h-l)/2;\\n        \\n            for(int i=0; i<nums.size(); i++){\\n                if(nums[i]>=mid){\\n                    ctr++;\\n                }\\n            }\\n            if(ctr==mid){\\n                return mid;\\n            }\\n            if(ctr<mid){\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723725,
                "title": "python-bucket-sort-o-n",
                "content": "Since the possible value are less than 1000, we shoud consider bucket sort instead of quick sort or merge sort.  Bucket sort nake the solution has time O(n) and space O(1). Hope the code is self explanatory.\\n\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        \\n        N, MAX_SIZE  = len(nums), 1001\\n        \\n        temp_sum, counts = 0, [0] * MAX_SIZE\\n        \\n        for num in nums:\\n            counts[num] += 1\\n        \\n        for i, cnt  in enumerate(counts):\\n            \\n            if N - temp_sum == i:\\n                return i\\n            \\n            temp_sum += cnt\\n        \\n        return -1\\n```\\n\\nAfter posted this, found another O(n) solution :) https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/discuss/2709600/Python-O(n)-Solution\\n",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        \\n        N, MAX_SIZE  = len(nums), 1001\\n        \\n        temp_sum, counts = 0, [0] * MAX_SIZE\\n        \\n        for num in nums:\\n            counts[num] += 1\\n        \\n        for i, cnt  in enumerate(counts):\\n            \\n            if N - temp_sum == i:\\n                return i\\n            \\n            temp_sum += cnt\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709600,
                "title": "python-o-n-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef specialArray(self, nums: List[int]) -> int:\\n\\t\\t\\tfreq=[0 for _ in range(max(nums)+1)]\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tfreq[i]+=1\\n\\t\\t\\tsuff=[freq[-1]]\\n\\t\\t\\tfor i in freq[::-1][1:]:\\n\\t\\t\\t\\tsuff.append(suff[-1]+i)\\n\\t\\t\\tsuff=suff[::-1]\\n\\t\\t\\tfor i in range(max(nums)+1):\\n\\t\\t\\t\\tif suff[i]==i:\\n\\t\\t\\t\\t\\treturn i\\n\\t\\t\\treturn -1\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef specialArray(self, nums: List[int]) -> int:\\n\\t\\t\\tfreq=[0 for _ in range(max(nums)+1)]\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tfreq[i]+=1\\n\\t\\t\\tsuff=[freq[-1]]\\n\\t\\t\\tfor i in freq[::-1][1:]:\\n\\t\\t\\t\\tsuff.append(suff[-1]+i)\\n\\t\\t\\tsuff=suff[::-1]\\n\\t\\t\\tfor i in range(max(nums)+1):\\n\\t\\t\\t\\tif suff[i]==i:\\n\\t\\t\\t\\t\\treturn i\\n\\t\\t\\treturn -1\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2154484,
                "title": "simple-binary-search-inbuilt-sorting",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\t//Count the number of elements greater than or equal to x for each x in the range [0, nums.length].\\n        int start = 0 , end = nums.length;\\n        while (start<=end){\\n            int mid = start + (end - start)/2;\\n            if (mid == greaterOrEqualTo(nums,mid)) return mid; //If for any x, the condition satisfies, return that x. \\n            else if (mid<greaterOrEqualTo(nums,mid)) start = mid+1;\\n            else end = mid-1;\\n        }\\n        return -1;//Otherwise, there is no answer.\\n    }\\n    public int greaterOrEqualTo(int[] nums, int mid){\\n\\t//Method to check the count of numbers greater than or equal to x\\n        int count = 0;\\n        for (int i = 0; i < nums.length ; i++) {\\n            if (nums[i]>=mid) count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\t//Count the number of elements greater than or equal to x for each x in the range [0, nums.length].\\n        int start = 0 , end = nums.length;\\n        while (start<=end){\\n            int mid = start + (end - start)/2;\\n            if (mid == greaterOrEqualTo(nums,mid)) return mid; //If for any x, the condition satisfies, return that x. \\n            else if (mid<greaterOrEqualTo(nums,mid)) start = mid+1;\\n            else end = mid-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1942915,
                "title": "python-o-n-soln-short-and-fast",
                "content": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        count, nums = 0, Counter(nums)\\n        for i in range(max(nums), -1, -1):\\n            count += nums[i]\\n            if count == i: \\n                return count\\n        return -1    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        count, nums = 0, Counter(nums)\\n        for i in range(max(nums), -1, -1):\\n            count += nums[i]\\n            if count == i: \\n                return count\\n        return -1    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698966,
                "title": "java-2-methods-explained",
                "content": "**Method 1:** Sort and Binary Search\\n>**T/S:** O(n lg n)/O(n), where n = size(nums)\\n```\\npublic int specialArray(int[] nums) {\\n\\treverseSort(nums);\\n\\treturn binarySearch(nums);\\n}\\n\\n// O(n lg n)/O(n)\\nprivate void reverseSort(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tfor (int i = 0, n = nums.length; i < n / 2; i++)\\n\\t\\tswap(n - i - 1, i, nums);\\n}\\n\\nprivate void swap(int i, int j, int[] nums) {\\n\\tvar temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n\\n// O(lg n)/O(1)\\nprivate int binarySearch(int[] nums) {\\n\\tvar low = 0;\\n\\n\\tfor (var high = nums.length; low < high;) {\\n\\t\\tvar mid = low + (high - low) / 2;\\n\\t\\t\\n\\t\\tif (mid < nums[mid])\\n\\t\\t\\tlow = mid + 1;\\n\\t\\telse\\n\\t\\t\\thigh = mid;\\n\\t}\\n\\t\\n\\treturn low < nums.length && low == nums[low] ? - 1 : low;\\n}\\n```\\n**Method 2:** Count and Search\\n* Utilize the constraint that nums[i] \\u2208 [0, 1000]\\n* Count the frequency of each nums[i] in an array (`numCounts`). Store this count in an array, with frequency of i stored in `numCounts[i]`\\n* Now iterate down `numCounts` and reduce total elements (n) by frequency of numbers till this point\\n* When n becomes equal to i, you\\'ve found the required x\\n* If no such x is found, return -1\\n\\nE.g.\\n```\\nnums = [0, 4, 3, 0, 4], n = 5\\nnumCounts = [2, 0, 0, 1, 2] represents frequency of 0 = 2, 1 = 0, 2 = 0, 3 = 1, 4 = 2\\n\\nIterate down numCounts\\n\\n5 elements \\u2265 0\\n(5 - 2) elements \\u2265 1\\n(5 - 2 - 0) elements \\u2265 2\\n(5 - 2 - 0 - 0) elements \\u2265 3\\n=> 3 elements \\u2265 3 \\n=> x = 3 [Ans]\\n```\\n>**T/S:** O(n)/O(1)\\n```\\nprivate static final int NUM_MAX = 1001;\\n\\npublic int specialArray(int[] nums) {\\n\\tvar numCounts = new int[NUM_MAX];\\n\\tfor (var num : nums)\\n\\t\\tnumCounts[num]++;\\n\\n\\tvar n = nums.length;\\n\\tfor (var i = 0; i < NUM_MAX; i++) {\\n\\t\\tif (n == i)\\n\\t\\t\\treturn i;\\n\\t\\tn -= numCounts[i];\\n\\t}\\n\\treturn -1;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\npublic int specialArray(int[] nums) {\\n\\treverseSort(nums);\\n\\treturn binarySearch(nums);\\n}\\n\\n// O(n lg n)/O(n)\\nprivate void reverseSort(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tfor (int i = 0, n = nums.length; i < n / 2; i++)\\n\\t\\tswap(n - i - 1, i, nums);\\n}\\n\\nprivate void swap(int i, int j, int[] nums) {\\n\\tvar temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n\\n// O(lg n)/O(1)\\nprivate int binarySearch(int[] nums) {\\n\\tvar low = 0;\\n\\n\\tfor (var high = nums.length; low < high;) {\\n\\t\\tvar mid = low + (high - low) / 2;\\n\\t\\t\\n\\t\\tif (mid < nums[mid])\\n\\t\\t\\tlow = mid + 1;\\n\\t\\telse\\n\\t\\t\\thigh = mid;\\n\\t}\\n\\t\\n\\treturn low < nums.length && low == nums[low] ? - 1 : low;\\n}\\n```\n```\\nnums = [0, 4, 3, 0, 4], n = 5\\nnumCounts = [2, 0, 0, 1, 2] represents frequency of 0 = 2, 1 = 0, 2 = 0, 3 = 1, 4 = 2\\n\\nIterate down numCounts\\n\\n5 elements \\u2265 0\\n(5 - 2) elements \\u2265 1\\n(5 - 2 - 0) elements \\u2265 2\\n(5 - 2 - 0 - 0) elements \\u2265 3\\n=> 3 elements \\u2265 3 \\n=> x = 3 [Ans]\\n```\n```\\nprivate static final int NUM_MAX = 1001;\\n\\npublic int specialArray(int[] nums) {\\n\\tvar numCounts = new int[NUM_MAX];\\n\\tfor (var num : nums)\\n\\t\\tnumCounts[num]++;\\n\\n\\tvar n = nums.length;\\n\\tfor (var i = 0; i < NUM_MAX; i++) {\\n\\t\\tif (n == i)\\n\\t\\t\\treturn i;\\n\\t\\tn -= numCounts[i];\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490901,
                "title": "intuitive-java-solution-binary-search-on-size-array-100-faster",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int l = nums.length;\\n        int lo = 0, hi = l - 1;\\n        while(lo <= hi)\\n        {\\n            int mid = (lo + hi) / 2;\\n            int diff = special(nums, mid + 1);\\n            if(diff < 0)\\n            {\\n                hi = mid - 1;\\n            }\\n            else if(diff > 0)\\n            {\\n                lo = mid + 1;\\n            }\\n            else\\n                return mid + 1;\\n        }\\n        return -1;\\n    }\\n    int special(int[] nums, int x)\\n    {\\n        int c = 0;\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(nums[i] >= x)\\n                c++;\\n        }\\n        return c - x;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int specialArray(int[] nums) {\\n        int l = nums.length;\\n        int lo = 0, hi = l - 1;\\n        while(lo <= hi)\\n        {\\n            int mid = (lo + hi) / 2;\\n            int diff = special(nums, mid + 1);\\n            if(diff < 0)\\n            {\\n                hi = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1317653,
                "title": "java-sorting-binary-search-counting-0ms-beats-100-t-c-o-n-s-c-o-n",
                "content": "\\n\\t// Linear Search + Sorting\\n\\t// O(n^2) O(1)\\n\\tpublic int specialArray1(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\n\\t\\tfor (int i = 1; i <= len; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = len - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif (nums[j] >= i)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tif (count == i)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t// Binary Search + Sorting\\n\\t// O(nlogn) O(1)\\n\\tpublic int specialArray2(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tArrays.sort(nums);\\n\\n\\t\\tfor (int i = 1; i <= len; i++) {\\n\\t\\t\\tint idx = binarySearch(nums, i) - 1;\\n\\t\\t\\tif (idx != -2 && len - idx - 1 == i)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t// Binary Search\\n\\t// O(nlogn) O(1)\\n\\tpublic int binarySearch(int[] nums, int target) {\\n\\n\\t\\tint lo = 0, hi = nums.length - 1, ans = -1;\\n\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\tif (nums[mid] >= target) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Counting\\n\\t// O(n) O(n)\\n\\tpublic int specialArray3(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tint[] count = new int[1001];\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tcount[nums[i]]++;\\n\\n\\t\\tint right = nums.length;\\n\\t\\tfor (int i = 0; i <= len; i++) {\\n\\n\\t\\t\\tif (i == right)\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\n\\t\\t\\tright -= count[i];\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// Linear Search + Sorting\\n\\t// O(n^2) O(1)\\n\\tpublic int specialArray1(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\n\\t\\tfor (int i = 1; i <= len; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = len - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif (nums[j] >= i)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tif (count == i)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t// Binary Search + Sorting\\n\\t// O(nlogn) O(1)\\n\\tpublic int specialArray2(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tArrays.sort(nums);\\n\\n\\t\\tfor (int i = 1; i <= len; i++) {\\n\\t\\t\\tint idx = binarySearch(nums, i) - 1;\\n\\t\\t\\tif (idx != -2 && len - idx - 1 == i)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t// Binary Search\\n\\t// O(nlogn) O(1)\\n\\tpublic int binarySearch(int[] nums, int target) {\\n\\n\\t\\tint lo = 0, hi = nums.length - 1, ans = -1;\\n\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\tif (nums[mid] >= target) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Counting\\n\\t// O(n) O(n)\\n\\tpublic int specialArray3(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tint[] count = new int[1001];\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tcount[nums[i]]++;\\n\\n\\t\\tint right = nums.length;\\n\\t\\tfor (int i = 0; i <= len; i++) {\\n\\n\\t\\t\\tif (i == right)\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\n\\t\\t\\tright -= count[i];\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1220029,
                "title": "98-python-binary-search-very-similar-to-h-index",
                "content": "```\\nimport bisect\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(1, len(nums) + 1):\\n            startIndex = bisect.bisect_left(nums, i)\\n            if len(nums) - startIndex == i:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(1, len(nums) + 1):\\n            startIndex = bisect.bisect_left(nums, i)\\n            if len(nums) - startIndex == i:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063763,
                "title": "very-simple-intuitive-python-solution",
                "content": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        \\n        for i in range(len(nums), -1, -1):\\n            if [j >= i for j in nums].count(True) == i:\\n                return i\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        \\n        for i in range(len(nums), -1, -1):\\n            if [j >= i for j in nums].count(True) == i:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927382,
                "title": "python-sort-time-o-n-log-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)):\\n            x = len(nums) - i \\n            if  (i == 0 or nums[i-1] < x) and x <= nums[i]:\\n                return x\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)):\\n            x = len(nums) - i \\n            if  (i == 0 or nums[i-1] < x) and x <= nums[i]:\\n                return x\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879326,
                "title": "sort-explained-with-pictures",
                "content": "**Idea and pictures**\\n\\nNote that that possible outcomes of the algorithm are `0...size(n)` (and `-1`). \\nThus we should check these numbers only.\\nIf we sort the array in the ascending order we aim to find an index `i` from interval `[0, size(n)]` such that `n[i-1] >= i and n[i] < i`.\\nThus we traverse the array from left to right and check for this condition. \\n\\n\\nTake a look at the picture (your program should return `2`)\\n\\n![image](https://assets.leetcode.com/users/images/516c30c8-d046-4a5d-af0c-eb15e9b17042_1601926093.2152107.png)\\n\\nNote you could also encounter following corner testcases.\\nHere your program should return `0`.\\n\\n![image](https://assets.leetcode.com/users/images/682970df-7273-44ca-a4c2-a8f35eda5916_1601929870.447907.png)\\n\\n\\n\\nHere your program should return `6`.\\n\\n![image](https://assets.leetcode.com/users/images/e811bb84-bbb8-4f15-8f39-0d17815d180f_1601929929.1613688.png)\\n\\nHere is the testcase where the algo sould return `-1`.\\nNote that it\\'s possible if `n[i-1]` **<** `i and n[i] < i`. \\nThis is possible only if `n[i-1]==i-1` because if we traverse the array from left to right we\\'ve already checked that `n[i-1]>=i-1` at the previous iteration.\\nThis is important cause it enables early return.\\n\\n![image](https://assets.leetcode.com/users/images/cd7c5bad-9b8d-481c-8053-d551aeb67a45_1601932357.1546328.png)\\n\\n\\n**Code**\\n\\n```\\nint specialArray(vector<int>& n) \\n{\\n\\tsort(begin(n), end(n), greater{});\\n\\n\\tif(n.front() < 0) return 0;\\n\\tif(n.back() >= size(n)) return size(n);\\n\\n\\tfor(auto i{1}; i<size(n); ++i)\\n\\t\\t if(n[i] < i) return (n[i-1] == i-1) ? -1 : i;\\n\\n\\treturn -2; //impossible\\n}\\n```\\nor introducing `INT_MAX` and `INT_MIN` values to deal with corner cases\\n\\n![image](https://assets.leetcode.com/users/images/b7c8098a-8736-49e6-9279-56644ba7cc6c_1601933946.7347076.png)\\n\\n\\n```\\nint specialArray(vector<int>& n) \\n{\\n\\tsort(begin(n), end(n), greater{});\\n\\n\\tfor(auto i{0}, prev{INT_MAX}; i<size(n); prev = n[i++])\\n\\t\\tif(n[i] < i) return (prev == i-1) ? -1 : i;\\n\\n\\treturn n.back() >= size(n) ? size(n) : -1;\\n}\\n```\\nor\\n```\\nint specialArray(vector<int>& n) \\n{\\n\\tsort(begin(n), end(n), greater{});\\n\\n\\tn.push_back(INT_MIN);\\n\\n\\tfor(auto i{0}, prev{INT_MAX}; i<size(n); prev = n[i++])\\n\\t\\t if(n[i] < i) return (prev == i-1) ? -1 : i;\\n\\n\\treturn -2; //impossible\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint specialArray(vector<int>& n) \\n{\\n\\tsort(begin(n), end(n), greater{});\\n\\n\\tif(n.front() < 0) return 0;\\n\\tif(n.back() >= size(n)) return size(n);\\n\\n\\tfor(auto i{1}; i<size(n); ++i)\\n\\t\\t if(n[i] < i) return (n[i-1] == i-1) ? -1 : i;\\n\\n\\treturn -2; //impossible\\n}\\n```\n```\\nint specialArray(vector<int>& n) \\n{\\n\\tsort(begin(n), end(n), greater{});\\n\\n\\tfor(auto i{0}, prev{INT_MAX}; i<size(n); prev = n[i++])\\n\\t\\tif(n[i] < i) return (prev == i-1) ? -1 : i;\\n\\n\\treturn n.back() >= size(n) ? size(n) : -1;\\n}\\n```\n```\\nint specialArray(vector<int>& n) \\n{\\n\\tsort(begin(n), end(n), greater{});\\n\\n\\tn.push_back(INT_MIN);\\n\\n\\tfor(auto i{0}, prev{INT_MAX}; i<size(n); prev = n[i++])\\n\\t\\t if(n[i] < i) return (prev == i-1) ? -1 : i;\\n\\n\\treturn -2; //impossible\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3390564,
                "title": "easy-two-for-loops-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        for(int i =0; i<=1000; i++){\\n            int count = 0;\\n            for(int num : nums){\\n                if(num>= i)count++;\\n            }\\n            if(i==count) return i;\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        for(int i =0; i<=1000; i++){\\n            int count = 0;\\n            for(int num : nums){\\n                if(num>= i)count++;\\n            }\\n            if(i==count) return i;\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285628,
                "title": "easiest-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(max(nums)+1):\\n            y=len(nums)-bisect.bisect_left(nums,i)\\n            if y==i:\\n                return i\\n        return -1\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(max(nums)+1):\\n            y=len(nums)-bisect.bisect_left(nums,i)\\n            if y==i:\\n                return i\\n        return -1\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283883,
                "title": "js-easy-o-n-log-n-solution-binary-search",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar specialArray = function(nums) {\\n    // step 1: sort\\n    nums = nums.sort((a,b) => a-b);\\n    // step 2: search\\n    for(let i=nums.length; i>=0; i--) {\\n        // found:\\n        if(bs(nums, i)) return i;\\n    }\\n    // not found:\\n    return -1;\\n};\\n\\nfunction bs(array, target) {\\n    let left = 0;\\n    let right = array.length - 1;\\n\\n    while(left <= right){\\n        const mid = Math.floor((left+right)/2);\\n        if(array[mid] < target) left = mid + 1;\\n        else right = mid - 1;\\n    }\\n\\n    const greaterThanTarget = array.length - left;\\n\\n    return greaterThanTarget === target;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar specialArray = function(nums) {\\n    // step 1: sort\\n    nums = nums.sort((a,b) => a-b);\\n    // step 2: search\\n    for(let i=nums.length; i>=0; i--) {\\n        // found:\\n        if(bs(nums, i)) return i;\\n    }\\n    // not found:\\n    return -1;\\n};\\n\\nfunction bs(array, target) {\\n    let left = 0;\\n    let right = array.length - 1;\\n\\n    while(left <= right){\\n        const mid = Math.floor((left+right)/2);\\n        if(array[mid] < target) left = mid + 1;\\n        else right = mid - 1;\\n    }\\n\\n    const greaterThanTarget = array.length - left;\\n\\n    return greaterThanTarget === target;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3264706,
                "title": "cpp-binary-search-0-n-log-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n\\n// the ans will always lie in the range of\\n// 0 th the largest element in the array\\n        int left = 0,right =*max_element(nums.begin(),nums.end());\\nint n = nums.size();\\nint cnt = 0;\\n        while(left <= right){\\n\\nint mid = (right - left)/2 + left;\\n\\n\\n// finddng the  cnt of elemnts greater than or equal to mid.\\nfor(auto x:nums){\\n    if(mid <= x) cnt++;\\n}\\n\\nif(cnt ==mid) return mid;\\n\\n// lots of smaller elements present\\n// so we need to increment the possible ans.\\nif(cnt > mid) left = mid  + 1;\\n\\n// less no of smaller elements present\\n// so we need to decrement the possible ans \\n\\nelse right = mid - 1;\\n\\n\\ncnt = 0;\\n\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n\\n// the ans will always lie in the range of\\n// 0 th the largest element in the array\\n        int left = 0,right =*max_element(nums.begin(),nums.end());\\nint n = nums.size();\\nint cnt = 0;\\n        while(left <= right){\\n\\nint mid = (right - left)/2 + left;\\n\\n\\n// finddng the  cnt of elemnts greater than or equal to mid.\\nfor(auto x:nums){\\n    if(mid <= x) cnt++;\\n}\\n\\nif(cnt ==mid) return mid;\\n\\n// lots of smaller elements present\\n// so we need to increment the possible ans.\\nif(cnt > mid) left = mid  + 1;\\n\\n// less no of smaller elements present\\n// so we need to decrement the possible ans \\n\\nelse right = mid - 1;\\n\\n\\ncnt = 0;\\n\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230766,
                "title": "a-simple-solution-in-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can see the result is in the range [1,n]\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI try to traverse variable i from index 1 to n of the sorted array and compare whether i can be placed at index (n-i) or not\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for (int i = 1; i < n; i++){\\n            if (nums[n-1-i] < i && i <= nums[n-i]){\\n                return i;\\n            }\\n        }\\n        if (n <= nums[0]) return n;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for (int i = 1; i < n; i++){\\n            if (nums[n-1-i] < i && i <= nums[n-i]){\\n                return i;\\n            }\\n        }\\n        if (n <= nums[0]) return n;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085261,
                "title": "approach-explained-all-possible-simplest-c-solution",
                "content": "# #Solution 1/o(n^2)/Brute force\\n# approach\\nWe can check for every integer in the range [1, N] if the number of elements in the array that are greater than or equal to any integer in the range is equal to that integer itself.\\n For example, consider Array = {1 , 3 , 4 , 5}. Now, 1 and 2 have 4 and 3 elements greater than or equal to them in the array respectively. Number of elements greater than/equal to 3 = 3. So, 3 is the only solution. \\nSince we traverse the whole tree to find the number of elements greater than for every integer in the range: [1, N], this approach is slow.\\n# code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) \\n    {\\n        for(int i=0;i<1001;i++)\\n        {\\n            int count=0;\\n            for(int num:nums)\\n            {\\n                if(num>=i)\\n                count++;\\n            }\\n            if(i==count)\\n            return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# #Solution 2/o(nlogn)/using lower_bound\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<=n;i++)\\n        {\\n        auto p=lower_bound(nums.begin(),nums.end(),i);\\n        if(nums.end()-p==i)\\n        return i;\\n        }\\n        return -1;  \\n    }\\n};\\n```\\n# #Solution 3/optimal/o(n)/using frequency array \\nspace complexity:O(N). Linear memory space is used for storing frequencies. So this soln for large size array is not efficient.\\n\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) \\n    {\\n        int total=nums.size();\\n        int arr[1001]={0};\\n        for(int num:nums)\\n        arr[num]++;\\n        for(int i=0;i<1001;i++)\\n        {\\n            if(total==i)\\n            return i;\\n            total-=arr[i];\\n        }\\n        return -1;   \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) \\n    {\\n        for(int i=0;i<1001;i++)\\n        {\\n            int count=0;\\n            for(int num:nums)\\n            {\\n                if(num>=i)\\n                count++;\\n            }\\n            if(i==count)\\n            return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<=n;i++)\\n        {\\n        auto p=lower_bound(nums.begin(),nums.end(),i);\\n        if(nums.end()-p==i)\\n        return i;\\n        }\\n        return -1;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) \\n    {\\n        int total=nums.size();\\n        int arr[1001]={0};\\n        for(int num:nums)\\n        arr[num]++;\\n        for(int i=0;i<1001;i++)\\n        {\\n            if(total==i)\\n            return i;\\n            total-=arr[i];\\n        }\\n        return -1;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059296,
                "title": "c-clear-explanation-o-nlogn-4-lines-only-faster-100",
                "content": "**Intuition:**\\n- Traverse through the array to look for the result `x`\\n- Return result if `current` item is greater than or equal to `x` and previous item (if any) is less than `x`.\\n\\n**Code:**\\n```c++\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end()); \\n        auto x = nums.size();\\n        for (auto i = 0; i < nums.size(); i++, x--) \\n            if (x <= nums[i]) \\n                if (i == 0 || x > nums[i - 1] ) return x;\\n        return x ? x: -1;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end()); \\n        auto x = nums.size();\\n        for (auto i = 0; i < nums.size(); i++, x--) \\n            if (x <= nums[i]) \\n                if (i == 0 || x > nums[i - 1] ) return x;\\n        return x ? x: -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897078,
                "title": "java-brute-force-57-faster",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int count=0;\\n        for(int i=1;i<=1000;i++){\\n            count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(i<=nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count==i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int count=0;\\n        for(int i=1;i<=1000;i++){\\n            count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(i<=nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count==i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889824,
                "title": "java-solution-using-binary-search-runtime-1ms",
                "content": "# Intuition\\nlet\\'s start with brute force so,you need to check for each value and count the element which is greater than equal to your x value.\\nso you start with 0 to max value of the array.\\nhere\\'s come the intutation you have the sorted search space(0-max value).\\n\\n# Approach\\nSo, we start with basic binary search approach i.e: start, mid ,end\\nstart would be 0 and end would be max of the array.\\nNow start checking for each mid value and count the occurrence if it\\'s\\nequal to mid value simply return it.\\nIf the count is greater than mid value it means you have to increase the start value to mid + 1.\\nIf the count is less than mid value then decrease the end to mid - 1.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int start = 0;\\n        int count = 0;\\n        int end = findMax(nums);\\n        int mid = 0;\\n        while(start <= end){\\n          mid = start + (end - start)/2;\\n          count = findCount(nums, mid);\\n          if(mid == count){\\n              return mid;\\n          }  \\n          else if(mid < count){\\n              start = mid + 1;\\n          }\\n          else{\\n              end = mid - 1;\\n          }\\n\\n        }\\n        return -1;\\n    }\\n    public int findMax(int nums[]){\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n        }\\n        return max;\\n    }\\n    public int findCount(int nums[], int find){\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] >= find){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int start = 0;\\n        int count = 0;\\n        int end = findMax(nums);\\n        int mid = 0;\\n        while(start <= end){\\n          mid = start + (end - start)/2;\\n          count = findCount(nums, mid);\\n          if(mid == count){\\n              return mid;\\n          }  \\n          else if(mid < count){\\n              start = mid + 1;\\n          }\\n          else{\\n              end = mid - 1;\\n          }\\n\\n        }\\n        return -1;\\n    }\\n    public int findMax(int nums[]){\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n        }\\n        return max;\\n    }\\n    public int findCount(int nums[], int find){\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] >= find){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810898,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint specialArray(vector<int>& nums) {\\n\\t\\t\\tint i=1, j=nums.size();\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2, cnt=0;\\n\\t\\t\\t\\tfor(int k=0; k<nums.size(); k++){\\n\\t\\t\\t\\t\\tif(nums[k]>=mid){cnt++;}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(cnt==mid){return mid;}\\n\\t\\t\\t\\telse if(cnt<mid){j=mid-1;}\\n\\t\\t\\t\\telse{i=mid+1;}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint specialArray(vector<int>& nums) {\\n\\t\\t\\tint i=1, j=nums.size();\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2, cnt=0;\\n\\t\\t\\t\\tfor(int k=0; k<nums.size(); k++){\\n\\t\\t\\t\\t\\tif(nums[k]>=mid){cnt++;}",
                "codeTag": "Java"
            },
            {
                "id": 2810583,
                "title": "easy-c-solution-binary-search",
                "content": "Here is my C++ Solution :-\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int low=1; int high= nums.size();\\n        \\n        while (low<=high){\\n            //count no. of elements >=mid; if equal to mid\\n            int mid= low+(high-low)/2;\\n            int x=0;\\n            for (int i=0; i<nums.size(); i++){\\n                if (nums[i]>=mid)x++;\\n            }\\n            if (mid==x)return mid;\\n            if (x<mid)high= mid-1;\\n            else low= mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int low=1; int high= nums.size();\\n        \\n        while (low<=high){\\n            //count no. of elements >=mid; if equal to mid\\n            int mid= low+(high-low)/2;\\n            int x=0;\\n            for (int i=0; i<nums.size(); i++){\\n                if (nums[i]>=mid)x++;\\n            }\\n            if (mid==x)return mid;\\n            if (x<mid)high= mid-1;\\n            else low= mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657194,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n\\t\\n        sort(nums.begin(),nums.end());\\n        int i=nums.size();\\n\\t\\t\\n        while(i>0){\\n            int start=0,end=nums.size()-1;\\n            int count=0;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]>=i){\\n                   count+=end-mid+1;    // no. of element greater than nums[mid] \\n                    end=mid-1;\\n                }\\n                else{\\n                    start=mid+1;\\n                }\\n            }\\n            if(count==i){\\n                return i;\\n            }\\n            i--; \\n        }\\n        return -1;\\n\\t\\t\\n    }\\n};\\n```\\nAnother same approach\\n\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end()); // sorting so that we can use binary search\\n        int i=0;\\n        while(i<=nums.size()){ // to find number of element greater than i\\n            int start=0,end=nums.size()-1;\\n            int count=0;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]>=i){ // no. of element greater than nums[mid]\\n                   count+=end-mid+1;   // storing the numbers  \\n                    end=mid-1;\\n                }\\n                else{\\n                    start=mid+1;\\n                }\\n            }\\n            if(count==i){ // after storing if its == i return i\\n                return i;\\n            }\\n            i++; \\n        }\\n        return -1;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n\\t\\n        sort(nums.begin(),nums.end());\\n        int i=nums.size();\\n\\t\\t\\n        while(i>0){\\n            int start=0,end=nums.size()-1;\\n            int count=0;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]>=i){\\n                   count+=end-mid+1;    // no. of element greater than nums[mid] \\n                    end=mid-1;\\n                }\\n                else{\\n                    start=mid+1;\\n                }\\n            }\\n            if(count==i){\\n                return i;\\n            }\\n            i--; \\n        }\\n        return -1;\\n\\t\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497050,
                "title": "java-3-ms-simple-solution-without-binary-search",
                "content": "```\\nint n = nums.length ;//we take an integer n of value length of array ;\\n        \\n        //x cannot be greater then the size of nums read last line of example 2;\\n        \\n        int count = 0 ;//we use count to check existence of X;\\n        \\n        //we use a while loop till n is greater than 0;\\n        while(n >0){\\n            count = 0 ;//we make count everytime 0 ;\\n            \\n            //we used a for loop for checking if there exist a no X;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] >= n){\\n                count ++;\\n            }\\n         }\\n        if(count == n){\\n         return n ;//if found we return the value of n ;\\n          }\\n       n--;//if not then we keep decrementing it till we fing our answer ;\\n    }\\n        //if not then we return -1;\\n        return -1;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint n = nums.length ;//we take an integer n of value length of array ;\\n        \\n        //x cannot be greater then the size of nums read last line of example 2;\\n        \\n        int count = 0 ;//we use count to check existence of X;\\n        \\n        //we use a while loop till n is greater than 0;\\n        while(n >0){\\n            count = 0 ;//we make count everytime 0 ;\\n            \\n            //we used a for loop for checking if there exist a no X;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] >= n){\\n                count ++;\\n            }\\n         }\\n        if(count == n){\\n         return n ;//if found we return the value of n ;\\n          }\\n       n--;//if not then we keep decrementing it till we fing our answer ;\\n    }\\n        //if not then we return -1;\\n        return -1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2318743,
                "title": "javascript-easy-to-read",
                "content": "We sort the array for binary search so, time is bound by O(n* logn).\\n\\nGoal is to find position in list such that\\nthere are exactly x numbers to the right of said position.\\nand the number at such position should be >= this value x\\n\\nfor eg,\\n```\\n[0,0,3,4,4]\\nthere are 3 elements in list from position of 3 (index 2)\\nand (index 2) = 3  is  >= 3.\\n```\\n\\nIf we try to look for such position by binary search,\\nwe can evaluate  x =  n - mid           ...[ (n-1) - mid + 1]\\n\\nand the target state of binary search can be stated as,\\nvalue must >= x  &&\\nleft of value (if present ) must be smaller than x  \\n\\nif check for left neighbor fails that means there are more than x\\nelements >= x.\\n\\nFirst time writing an explaination, \\nplease, feel free to suggest any improvements & corrections\\nUpvote if you found this helpful !!  \\n\\n\\n ```\\n /* \\n @param {number[]} nums\\n @return {number}\\n */\\nvar specialArray = function(nums) {\\n  \\n    nums = nums.sort((a,b)=>a-b)\\n    const n = nums.length\\n    \\n    let l = 0\\n    let r = n-1\\n    while(l<=r){\\n        let mid = l + ((r-l)>>1)\\n        let x = n-mid\\n        if(nums[mid]>=x && (mid===0 || nums[mid-1] < x))\\n            return x\\n        else if(nums[mid]>x)\\n            r = mid - 1\\n        else\\n            l = mid + 1\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n[0,0,3,4,4]\\nthere are 3 elements in list from position of 3 (index 2)\\nand (index 2) = 3  is  >= 3.\\n```\n```\\n /* \\n @param {number[]} nums\\n @return {number}\\n */\\nvar specialArray = function(nums) {\\n  \\n    nums = nums.sort((a,b)=>a-b)\\n    const n = nums.length\\n    \\n    let l = 0\\n    let r = n-1\\n    while(l<=r){\\n        let mid = l + ((r-l)>>1)\\n        let x = n-mid\\n        if(nums[mid]>=x && (mid===0 || nums[mid-1] < x))\\n            return x\\n        else if(nums[mid]>x)\\n            r = mid - 1\\n        else\\n            l = mid + 1\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2253038,
                "title": "easy-c-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size(),max=arr[n-1];\\n        for(int i=1;i<=n;i++){\\n            int idx=lower_bound(arr.begin(),arr.end(),i)-arr.begin();\\n            if(n-idx==i){\\n                return i;\\n            }\\n        }return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size(),max=arr[n-1];\\n        for(int i=1;i<=n;i++){\\n            int idx=lower_bound(arr.begin(),arr.end(),i)-arr.begin();\\n            if(n-idx==i){\\n                return i;\\n            }\\n        }return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132582,
                "title": "python-sort-binary-search",
                "content": "```\\nclass Solution(object):\\n    def specialArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        def binarySearch(target):\\n            l, r = 0, len(nums)-1\\n            while l < r:\\n                mid = l + (r-l)/2\\n                if nums[mid] < target:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n                    \\n            if nums[r] >= target:\\n                return len(nums) - r\\n            else:\\n                return -1\\n            \\n        for num in range(len(nums)+1):\\n            if num == binarySearch(num):\\n                return num\\n        return -1          \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def specialArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        def binarySearch(target):\\n            l, r = 0, len(nums)-1\\n            while l < r:\\n                mid = l + (r-l)/2\\n                if nums[mid] < target:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n                    \\n            if nums[r] >= target:\\n                return len(nums) - r\\n            else:\\n                return -1\\n            \\n        for num in range(len(nums)+1):\\n            if num == binarySearch(num):\\n                return num\\n        return -1          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125685,
                "title": "java-easy-o-n-100",
                "content": "```\\n public int specialArray(int[] nums) {\\n        for(int i=0;i<=nums.length;i++){\\n            if(i==count(i,nums)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    int count(int a,int[] b){\\n        int c=0;\\n        for(int i:b){\\n            if(i>=a){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int specialArray(int[] nums) {\\n        for(int i=0;i<=nums.length;i++){\\n            if(i==count(i,nums)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    int count(int a,int[] b){\\n        int c=0;\\n        for(int i:b){\\n            if(i>=a){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062832,
                "title": "easy-binary-search-solution-faster-than-80",
                "content": "\\t\\tl = 0\\n        r = len(nums)\\n        \\n        while l <= r:\\n            mid = (l+r)//2\\n            count = 0\\n            for n in nums:\\n                if n >= mid:\\n                    count += 1\\n            if count == mid:\\n                return mid\\n            elif count < mid:\\n                r = mid-1\\n            else:\\n                l = mid+1\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "\\t\\tl = 0\\n        r = len(nums)\\n        \\n        while l <= r:\\n            mid = (l+r)//2\\n            count = 0\\n            for n in nums:\\n                if n >= mid:\\n                    count += 1\\n            if count == mid:\\n                return mid\\n            elif count < mid:\\n                r = mid-1\\n            else:\\n                l = mid+1\\n        return -1",
                "codeTag": "Unknown"
            },
            {
                "id": 2045574,
                "title": "c-brute-force-with-lower-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i <= nums.back(); i++) {\\n            if (distance(lower_bound(nums.begin(), nums.end(), i), nums.end()) == i)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i <= nums.back(); i++) {\\n            if (distance(lower_bound(nums.begin(), nums.end(), i), nums.end()) == i)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003830,
                "title": "java-pure-binary-search-solution-with-sorting",
                "content": "1. Count the number of elements greater than or equal to x for each x in the range [0, nums.length].\\n2. If for any x, the condition satisfies, return that x. Otherwise, there is no answer.\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int x = -1;\\n        for(int i = 0; i <= n; i++){\\n            int low = 0, high = n-1;\\n            x = i;\\n            int ans = -1;\\n            while(low <= high){\\n                int mid = low + (high - low) / 2;\\n                if(nums[mid] < x){\\n                    low = mid+1;\\n                }else{\\n                    ans = mid;\\n                    high = mid-1;\\n                }\\n            }\\n            if(x == n - ans)\\n                return x;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int x = -1;\\n        for(int i = 0; i <= n; i++){\\n            int low = 0, high = n-1;\\n            x = i;\\n            int ans = -1;\\n            while(low <= high){\\n                int mid = low + (high - low) / 2;\\n                if(nums[mid] < x){\\n                    low = mid+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1974238,
                "title": "3-approach-easy-to-understand-c",
                "content": "**Method 1:**\\n```\\n    int specialArray(vector<int>& nums) {\\n\\t\\t// Brute force\\n        for(int i=1;i<1001;i++){\\n            int cnt=0;\\n            for(auto num: nums){\\n                if(i<=num)\\n                    cnt++;\\n            }\\n            if(i == cnt)\\n                return i;\\n        }\\n        return -1;\\n\\t}\\n```\\n\\n**Method 2:**\\n```\\n    int specialArray(vector<int>& nums) {\\n\\t\\tint tot = nums.size();\\n        vector<int> bucket(1001);\\n        for(auto num:nums){\\n            bucket[num]++;\\n        }\\n        for(int i=0;i<1001;++i){\\n            if(i==tot)\\n                return i;\\n            tot-=bucket[i];\\n        }\\n        return -1;\\n\\t}\\n```\\n**Method 3:**\\n```\\n\\tint specialArray(vector<int>& nums) {\\n\\t\\tsort(nums.begin(),nums.end());\\n        for(int i=1;i<=nums.size();++i){\\n            auto ptr = lower_bound(nums.begin(),nums.end(),i);\\n            int tot = nums.end()-ptr;\\n            if(i==tot)\\n                 return i;\\n        }\\n        return -1;\\n\\t}\\n```\\n\\n**\"Upvote if  u liked the solution\"**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n    int specialArray(vector<int>& nums) {\\n\\t\\t// Brute force\\n        for(int i=1;i<1001;i++){\\n            int cnt=0;\\n            for(auto num: nums){\\n                if(i<=num)\\n                    cnt++;\\n            }\\n            if(i == cnt)\\n                return i;\\n        }\\n        return -1;\\n\\t}\\n```\n```\\n    int specialArray(vector<int>& nums) {\\n\\t\\tint tot = nums.size();\\n        vector<int> bucket(1001);\\n        for(auto num:nums){\\n            bucket[num]++;\\n        }\\n        for(int i=0;i<1001;++i){\\n            if(i==tot)\\n                return i;\\n            tot-=bucket[i];\\n        }\\n        return -1;\\n\\t}\\n```\n```\\n\\tint specialArray(vector<int>& nums) {\\n\\t\\tsort(nums.begin(),nums.end());\\n        for(int i=1;i<=nums.size();++i){\\n            auto ptr = lower_bound(nums.begin(),nums.end(),i);\\n            int tot = nums.end()-ptr;\\n            if(i==tot)\\n                 return i;\\n        }\\n        return -1;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1926736,
                "title": "simple-c-o-nlogn",
                "content": "\\n\\n**This problem can be easily solved using Binary-Search on Answer concept because we have upper and lower limit i.e the special number can be between 1 to length of the array.**\\n\\nwe can simpally itterate from 1 to length of the array and for every iteration check whether it can be or not if it is than simpally return that value,but it will O(n^2) approch ,it can be solved using O(nlog(n)) time complexity using binary search on answer approch \\n\\n**for any \"Mid\" value we will check what is the count of the number which are greater than equal to this \"MId\" if the count is same mean we will return this \"Mid\" value otherwise if count is greater than \"Mid\" value mean we need to increase the \"Mid\" value i.e start=\"Mid\" +1 else end=\"Mid\"-1**\\n\\n\\n\\n```\\nclass Solution {\\nprivate :\\n    int solve(vector<int> &nums,int mid)\\n    {\\n        int count=0;\\n        for(auto x:nums)\\n        {\\n            if(x>=mid)\\n            {\\n                count++;\\n            }\\n        }\\n        if(count==mid)\\n            return 0;\\n       return count>mid?1:-1;\\n    }\\npublic:\\n    int specialArray(vector<int>& nums) \\n    {\\n        int start=0,end=nums.size();\\n        while(start<=end)\\n        {\\n            int mid=start + (end-start)/2;\\n            int val=solve(nums,mid);\\n            if(val==0)\\n            {\\n                return mid;\\n            }\\n            else if(val>0)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**if found helpful please upvote.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate :\\n    int solve(vector<int> &nums,int mid)\\n    {\\n        int count=0;\\n        for(auto x:nums)\\n        {\\n            if(x>=mid)\\n            {\\n                count++;\\n            }\\n        }\\n        if(count==mid)\\n            return 0;\\n       return count>mid?1:-1;\\n    }\\npublic:\\n    int specialArray(vector<int>& nums) \\n    {\\n        int start=0,end=nums.size();\\n        while(start<=end)\\n        {\\n            int mid=start + (end-start)/2;\\n            int val=solve(nums,mid);\\n            if(val==0)\\n            {\\n                return mid;\\n            }\\n            else if(val>0)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921801,
                "title": "c-simple-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& arr,int mid){\\n        int cnt = 0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] >= mid)    cnt++;\\n            if(cnt > mid)   return cnt;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    int specialArray(vector<int>& arr) {\\n        int lo = 0, hi = *max_element(arr.begin(),arr.end());\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            int p = check(arr,mid);\\n            if(p == mid)    return mid;\\n            else if(p < mid){\\n                hi = mid -1 ;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nTime Complexity = O(log(max(arr))*n)\\nSpace Complexity = O(1)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& arr,int mid){\\n        int cnt = 0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] >= mid)    cnt++;\\n            if(cnt > mid)   return cnt;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    int specialArray(vector<int>& arr) {\\n        int lo = 0, hi = *max_element(arr.begin(),arr.end());\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            int p = check(arr,mid);\\n            if(p == mid)    return mid;\\n            else if(p < mid){\\n                hi = mid -1 ;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863057,
                "title": "kotlin",
                "content": "```\\nfun specialArray(a: IntArray): Int {\\n    for (i in 1..a.size) if (a.count { it >= i } == i) return i\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun specialArray(a: IntArray): Int {\\n    for (i in 1..a.size) if (a.count { it >= i } == i) return i\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816069,
                "title": "java-100-faster-solution-based-on-binary-search",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int start = 0;\\n        int end = nums.length;\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            int count = countEle(nums, mid);\\n            if(mid == count){\\n                return mid;\\n            }\\n            else if(mid < count){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public int countEle(int[] arr, int ele){\\n        int count = 0;\\n        for(int i = 0; i < arr.length; ++i){\\n            if(arr[i] >= ele){\\n                ++count;\\n            }\\n            if(count > ele){\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int start = 0;\\n        int end = nums.length;\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            int count = countEle(nums, mid);\\n            if(mid == count){\\n                return mid;\\n            }\\n            else if(mid < count){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public int countEle(int[] arr, int ele){\\n        int count = 0;\\n        for(int i = 0; i < arr.length; ++i){\\n            if(arr[i] >= ele){\\n                ++count;\\n            }\\n            if(count > ele){\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553871,
                "title": "clean-java-o-nlogn-with-intuitive-solution",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<=nums.length; i++) {\\n            if(i == numberOfElementsGreaterThan(i, nums)) // Question basically asks a special number which has the same number of elements that are greater than or equal To that special number\\n                return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private int numberOfElementsGreaterThan(int n, int[] nums) { \\n        \\n        // If we know LEFT MOST INDEX where we can insert \\'n\\' in the nums, then number of elements to its right is the number of elements greater than \\'n\\'\\n        \\n        /* \\n        array   = [1, 2, 4, 4, 7, 9] \\n                         |\\n        indexes =  0  1  2  3  4  5\\n        \\n        leftMostIndex of 4 is 2, we can subtract length of array with it, to get number Of greater than or equal to elements. 6 - 2 = 4 elements \\n        \\n        */\\n        \\n        return nums.length - leftMostIndex(n, nums); \\n    }\\n    \\n    private int leftMostIndex(int n, int[] nums) {  // Binary Search\\n        \\n        int l = 0, r = nums.length-1;\\n        int m;\\n        \\n        while(l <= r) {\\n            m = l + (r-l)/2;\\n            \\n            if(n <= nums[m]) r = m-1;\\n            else l = m+1;\\n            \\n        }\\n        \\n        return l;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<=nums.length; i++) {\\n            if(i == numberOfElementsGreaterThan(i, nums)) // Question basically asks a special number which has the same number of elements that are greater than or equal To that special number\\n                return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private int numberOfElementsGreaterThan(int n, int[] nums) { \\n        \\n        // If we know LEFT MOST INDEX where we can insert \\'n\\' in the nums, then number of elements to its right is the number of elements greater than \\'n\\'\\n        \\n        /* \\n        array   = [1, 2, 4, 4, 7, 9] \\n                         |\\n        indexes =  0  1  2  3  4  5\\n        \\n        leftMostIndex of 4 is 2, we can subtract length of array with it, to get number Of greater than or equal to elements. 6 - 2 = 4 elements \\n        \\n        */\\n        \\n        return nums.length - leftMostIndex(n, nums); \\n    }\\n    \\n    private int leftMostIndex(int n, int[] nums) {  // Binary Search\\n        \\n        int l = 0, r = nums.length-1;\\n        int m;\\n        \\n        while(l <= r) {\\n            m = l + (r-l)/2;\\n            \\n            if(n <= nums[m]) r = m-1;\\n            else l = m+1;\\n            \\n        }\\n        \\n        return l;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396779,
                "title": "java-solution-easy-to-understand",
                "content": "```\\n//Runtime: 1 ms, faster than 79.46% of Java online submissions for Special Array With X Elements Greater Than or Equal X.\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums); // first sort the array\\n        for (int i = 0; i <= nums[nums.length - 1]; i++) { // start from 0 to the last element maximum element in nums\\n            int count = 0; //count all elements greater then 0 to the last element \\n            int j = 0;\\n            while (j < nums.length) {  \\n                if (i <= nums[j]) { //if the number less than the remaning of the elements increase the count\\n                    count++;\\n                }\\n                j++;\\n            }\\n            if (count == i) //when the number is equal to the count then return the number\\n                return i;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Runtime: 1 ms, faster than 79.46% of Java online submissions for Special Array With X Elements Greater Than or Equal X.\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums); // first sort the array\\n        for (int i = 0; i <= nums[nums.length - 1]; i++) { // start from 0 to the last element maximum element in nums\\n            int count = 0; //count all elements greater then 0 to the last element \\n            int j = 0;\\n            while (j < nums.length) {  \\n                if (i <= nums[j]) { //if the number less than the remaning of the elements increase the count\\n                    count++;\\n                }\\n                j++;\\n            }\\n            if (count == i) //when the number is equal to the count then return the number\\n                return i;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1221830,
                "title": "c-brute-force-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint specialArray(vector<int>& nums) {\\n\\t\\t\\tfor(int i = 0; i <= nums.size(); i++){\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < nums.size(); j++){\\n\\t\\t\\t\\t\\tif(nums[j] >= i){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(count == i){\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint specialArray(vector<int>& nums) {\\n\\t\\t\\tfor(int i = 0; i <= nums.size(); i++){\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < nums.size(); j++){\\n\\t\\t\\t\\t\\tif(nums[j] >= i){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1178508,
                "title": "very-easy-java-solution-runtime-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution \\n{\\n    int arr[];\\n    int len;\\n    public int specialArray(int[] nums) \\n    {\\n        arr=nums;\\n        len = nums.length;\\n        for(int i=0; i<=len; i++)\\n        {\\n            if(isTrue(i))\\n                return i;\\n        }\\n        return -1;\\n    }\\n    \\n    public boolean isTrue(int x)\\n    {\\n        int c=0;\\n        for(int i : arr)\\n        {\\n            if(i>=x)\\n                c++;\\n        }\\n        return c==x;\\n    }\\n}\\n//By Arindam Ghosh\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    int arr[];\\n    int len;\\n    public int specialArray(int[] nums) \\n    {\\n        arr=nums;\\n        len = nums.length;\\n        for(int i=0; i<=len; i++)\\n        {\\n            if(isTrue(i))\\n                return i;\\n        }\\n        return -1;\\n    }\\n    \\n    public boolean isTrue(int x)\\n    {\\n        int c=0;\\n        for(int i : arr)\\n        {\\n            if(i>=x)\\n                c++;\\n        }\\n        return c==x;\\n    }\\n}\\n//By Arindam Ghosh\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147673,
                "title": "go-o-n",
                "content": "```\\nfunc specialArray(nums []int) int {\\n\\tvar mp [1001]int\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tmp[nums[i]]++\\n\\t}\\n\\tvar cnt int\\n\\tfor i := 1000; i > 0; i-- {\\n\\t\\tcnt += mp[i]\\n\\t\\tif cnt == i {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc specialArray(nums []int) int {\\n\\tvar mp [1001]int\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tmp[nums[i]]++\\n\\t}\\n\\tvar cnt int\\n\\tfor i := 1000; i > 0; i-- {\\n\\t\\tcnt += mp[i]\\n\\t\\tif cnt == i {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084572,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        k = -1\\n        while k <= len(nums):\\n            count = 0\\n            for i in nums:\\n                if i >= k:\\n                    count += 1\\n            if k == count:\\n                return k\\n            k += 1\\n        return -1\\n```\\n**If you like the solution, please vote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        k = -1\\n        while k <= len(nums):\\n            count = 0\\n            for i in nums:\\n                if i >= k:\\n                    count += 1\\n            if k == count:\\n                return k\\n            k += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051365,
                "title": "java-solution-beat-100-with-90-18-less-memory",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int k = 0;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(nums[i] > k){\\n                k++;\\n            }\\n            else if( nums[i] == k){\\n                return -1;\\n            }else{\\n                return k;\\n            }\\n        }\\n        return k;\\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int k = 0;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(nums[i] > k){\\n                k++;\\n            }\\n            else if( nums[i] == k){\\n                return -1;\\n            }else{\\n                return k;\\n            }\\n        }\\n        return k;\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 889195,
                "title": "java-solution-easy-understanding-solution-o-n-2",
                "content": "```\\n public int specialArray(int[] nums) {\\n\\n        for (int i = 0; i <= nums.length; i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.length; j++)\\n                if (nums[j] >= i) count++;\\n            if (count == i) return i;\\n        }\\n        return -1;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int specialArray(int[] nums) {\\n\\n        for (int i = 0; i <= nums.length; i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.length; j++)\\n                if (nums[j] >= i) count++;\\n            if (count == i) return i;\\n        }\\n        return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 884973,
                "title": "simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n       for(int i=0;i<=nums.size();i++)\\n       {   int p=i;\\n           int k=0;\\n           for(int j=0;j<nums.size();j++)\\n               if(nums[j]>=p) k++;\\n           if(k==p)  return p;\\n       }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n       for(int i=0;i<=nums.size();i++)\\n       {   int p=i;\\n           int k=0;\\n           for(int j=0;j<nums.size();j++)\\n               if(nums[j]>=p) k++;\\n           if(k==p)  return p;\\n       }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883097,
                "title": "java-o-n-log-n-very-simple",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - (i > 0 ? nums[i - 1] : 0); ++i) {\\n            if (nums[i] >= nums.length - i) {\\n                return nums.length - i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - (i > 0 ? nums[i - 1] : 0); ++i) {\\n            if (nums[i] >= nums.length - i) {\\n                return nums.length - i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879242,
                "title": "c-without-sort-time-o-n-space-o-n",
                "content": "More explanation in comments\\n```\\nint specialArray(vector<int>& nums) {\\n\\t\\t/*\\n\\t\\tExample\\n\\t\\t[0,4,3,0,4]\\n\\n\\t\\t*/\\n        int n = nums.size(), curMax = 0;\\n        int counter[101]; // counter for counting 1 to 100 (constraint based)\\n        memset(counter, 0, sizeof(counter));\\n        \\n        for(auto n : nums) {\\n            curMax = max(curMax, n);\\n            counter[n > 100 ? 100 : n]++; // count all numbers more than 100 in index position\\n        }\\n\\t\\t/*\\n\\t\\tNow looks like this for counter array:\\n\\t\\t0 2\\n\\t\\t3 1\\n\\t\\t4 2\\n\\t\\t*/\\n        int cur = 0;\\n        curMax = (curMax > 100 ? 100 : curMax); //compute the max of the array and start from that number instead of 100\\n\\t\\t// curMax is now 4! instead of 100 \\n        for(int i = curMax; i >= 1; --i) {\\n            if(counter[i] != 0) cur += counter[i]; // keep a variable and update the current culmulative number\\n            if(cur == i) return cur;\\n        }   \\n\\t\\t/*\\n\\t\\tComplete snapshot of variable cur\\n\\t\\ti  | cur\\n\\t\\t--------\\n\\t\\t0 |   5\\n\\t\\t1 |   3\\n\\t\\t2 |   3    \\n\\t\\t3 |   3 -- found answer!! return 3\\n\\t\\t4 |   2\\n\\t\\t5 |   0\\n\\t\\t*/\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint specialArray(vector<int>& nums) {\\n\\t\\t/*\\n\\t\\tExample\\n\\t\\t[0,4,3,0,4]\\n\\n\\t\\t*/\\n        int n = nums.size(), curMax = 0;\\n        int counter[101]; // counter for counting 1 to 100 (constraint based)\\n        memset(counter, 0, sizeof(counter));\\n        \\n        for(auto n : nums) {\\n            curMax = max(curMax, n);\\n            counter[n > 100 ? 100 : n]++; // count all numbers more than 100 in index position\\n        }\\n\\t\\t/*\\n\\t\\tNow looks like this for counter array:\\n\\t\\t0 2\\n\\t\\t3 1\\n\\t\\t4 2\\n\\t\\t*/\\n        int cur = 0;\\n        curMax = (curMax > 100 ? 100 : curMax); //compute the max of the array and start from that number instead of 100\\n\\t\\t// curMax is now 4! instead of 100 \\n        for(int i = curMax; i >= 1; --i) {\\n            if(counter[i] != 0) cur += counter[i]; // keep a variable and update the current culmulative number\\n            if(cur == i) return cur;\\n        }   \\n\\t\\t/*\\n\\t\\tComplete snapshot of variable cur\\n\\t\\ti  | cur\\n\\t\\t--------\\n\\t\\t0 |   5\\n\\t\\t1 |   3\\n\\t\\t2 |   3    \\n\\t\\t3 |   3 -- found answer!! return 3\\n\\t\\t4 |   2\\n\\t\\t5 |   0\\n\\t\\t*/\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878578,
                "title": "c-0ms-faster-than-100",
                "content": "We setup an array to have an histogram which covers all potential x (which are the indexes) and also provide sorting (and counts).\\n\\nStarting from end of the histogram, we keep a cumulative sum which represent the count of numbers  . These numbers   are therefore equal or larger than the current index.\\n\\nThe algo has found a solution is the cumulative sum is equal to the current histogram index.\\n\\n```\\nint specialArray(vector<int>& nums) {\\n     \\n        array<unsigned, 1001> histo;\\n        histo.fill(0);\\n        for (const auto n : nums)\\n            histo[n]++;\\n        \\n        unsigned cumulative {0};\\n        \\n        for (int idx = histo.size() - 1; idx >= 0; --idx) {\\n            cumulative += histo[idx];\\n            if (cumulative && cumulative == idx)          \\n                return idx;                        \\n        }\\n        \\n        return -1;\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "We setup an array to have an histogram which covers all potential x (which are the indexes) and also provide sorting (and counts).\\n\\nStarting from end of the histogram, we keep a cumulative sum which represent the count of numbers  . These numbers   are therefore equal or larger than the current index.\\n\\nThe algo has found a solution is the cumulative sum is equal to the current histogram index.\\n\\n```\\nint specialArray(vector<int>& nums) {\\n     \\n        array<unsigned, 1001> histo;\\n        histo.fill(0);\\n        for (const auto n : nums)\\n            histo[n]++;\\n        \\n        unsigned cumulative {0};\\n        \\n        for (int idx = histo.size() - 1; idx >= 0; --idx) {\\n            cumulative += histo[idx];\\n            if (cumulative && cumulative == idx)          \\n                return idx;                        \\n        }\\n        \\n        return -1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 877749,
                "title": "java-nlogn-binary-search",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int left = 0;\\n        int right = nums.length;\\n        while(right - left > 1) {\\n            int mid = left + (right - left) / 2;\\n            int elements = findElements(nums, mid);\\n            if (elements == mid) {\\n                return mid;\\n            } else if (elements < mid) {\\n                right = mid;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n        if (left == findElements(nums, left))\\n            return left;\\n        else if (right == findElements(nums, right))\\n            return right;\\n        return -1;\\n    }\\n    \\n    public int findElements(int[] nums, int target) {\\n        int res = 0;\\n        for (int num : nums) {\\n            if (num >= target)\\n                res += 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int left = 0;\\n        int right = nums.length;\\n        while(right - left > 1) {\\n            int mid = left + (right - left) / 2;\\n            int elements = findElements(nums, mid);\\n            if (elements == mid) {\\n                return mid;\\n            } else if (elements < mid) {\\n                right = mid;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n        if (left == findElements(nums, left))\\n            return left;\\n        else if (right == findElements(nums, right))\\n            return right;\\n        return -1;\\n    }\\n    \\n    public int findElements(int[] nums, int target) {\\n        int res = 0;\\n        for (int num : nums) {\\n            if (num >= target)\\n                res += 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912710,
                "title": "solution-in-o-n-log-n-using-lower-bound-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse lower bound to calculate elements greater than or equal to x.\\nIf the no. of elements greater than or equal to x is equal to x then return ans=x else return -1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        int x,lb,ans=-1;\\n        for(x=0;x<=nums.size();x++)\\n        {\\n            int lb=lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n            if(nums.size()-lb==x){\\n               ans= x;\\n               break;\\n            }\\n            \\n            else \\n            ans= -1;\\n           \\n\\n        }\\n        return ans;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        int x,lb,ans=-1;\\n        for(x=0;x<=nums.size();x++)\\n        {\\n            int lb=lower_bound(nums.begin(),nums.end(),x)-nums.begin();\\n            if(nums.size()-lb==x){\\n               ans= x;\\n               break;\\n            }\\n            \\n            else \\n            ans= -1;\\n           \\n\\n        }\\n        return ans;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707214,
                "title": "super-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n            for(int i=1;i<=nums.length;i++){\\n                int count=0;\\n                for(int num:nums){\\n                    if(num>=i){\\n                        count++;\\n                    }\\n                }\\n                if(count==i){\\n                    return i;\\n                }\\n            }\\n            return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n            for(int i=1;i<=nums.length;i++){\\n                int count=0;\\n                for(int num:nums){\\n                    if(num>=i){\\n                        count++;\\n                    }\\n                }\\n                if(count==i){\\n                    return i;\\n                }\\n            }\\n            return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645015,
                "title": "80-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n     int n = nums.length;\\n     int a=0,b=0,c=n;\\n     while(c!=0 && a!=c){\\n     for(int i=0;i<n;i++){\\n         if(c<=nums[i]){\\n             a++;\\n         }\\n     }\\n         if(a==c){\\n        return c;\\n     }\\n         else {\\n             c--;\\n             a=0;\\n         }\\n     }\\n     return -1;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n     int n = nums.length;\\n     int a=0,b=0,c=n;\\n     while(c!=0 && a!=c){\\n     for(int i=0;i<n;i++){\\n         if(c<=nums[i]){\\n             a++;\\n         }\\n     }\\n         if(a==c){\\n        return c;\\n     }\\n         else {\\n             c--;\\n             a=0;\\n         }\\n     }\\n     return -1;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495611,
                "title": "0ms-java-solution-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe answer lie between 1 and the length of the given array. Hence we\\'ll apply binary search on our probable answer range.\\n\\n# Code\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int count = 0;\\n        int start = 1;\\n        int end = nums.length;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            for(int i : nums){\\n                if( i >= mid){\\n                    count++;\\n                }\\n            }\\n            if(count == mid){\\n                return mid;\\n            }\\n            else if(count > mid){\\n                start = mid + 1;\\n                count = 0;\\n            }else{\\n                end  = mid-1;\\n                count = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int count = 0;\\n        int start = 1;\\n        int end = nums.length;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            for(int i : nums){\\n                if( i >= mid){\\n                    count++;\\n                }\\n            }\\n            if(count == mid){\\n                return mid;\\n            }\\n            else if(count > mid){\\n                start = mid + 1;\\n                count = 0;\\n            }else{\\n                end  = mid-1;\\n                count = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481988,
                "title": "100-beats-time-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n               int left = 0,right =*max_element(nums.begin(),nums.end());\\nint n = nums.size();\\nint cnt = 0;\\n    while(left <= right){\\n\\n        int mid = (right - left)/2 + left;\\n        for(auto x:nums){\\n            if(mid <= x) cnt++;\\n        }\\n\\n        if(cnt ==mid) return mid;\\n         if(cnt > mid) left = mid  + 1; \\n\\n        else right = mid - 1;\\n\\n\\n        cnt = 0;\\n\\n    }\\n\\n    return -1;\\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n               int left = 0,right =*max_element(nums.begin(),nums.end());\\nint n = nums.size();\\nint cnt = 0;\\n    while(left <= right){\\n\\n        int mid = (right - left)/2 + left;\\n        for(auto x:nums){\\n            if(mid <= x) cnt++;\\n        }\\n\\n        if(cnt ==mid) return mid;\\n         if(cnt > mid) left = mid  + 1; \\n\\n        else right = mid - 1;\\n\\n\\n        cnt = 0;\\n\\n    }\\n\\n    return -1;\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389256,
                "title": "solution-without-binary-search",
                "content": "# Intuition\\nI don\\'t know how to apply here binary search, so i selected another way. If we sort initial array, then solution becames pretty clear. When you come through array you need to check if the rest quantity of elements in array is less or equal current element.\\n\\n# Approach\\nFor example you have [5, 3]. Sorted version is [3,5].\\nFor index 0 we have element `3` and 2 elements rest - `3` and `5`.\\n2 is less then `3` (call it - the main condition) - so this is an answer.\\n\\nAnother case - [3,6,7,7,0]. Sorted version is [0,3,6,7,7]\\nFor index 0 we have element `0` and 5 elms in advance. 5 > 0 so go to next.\\nFor index 1 we have element `3` and 4 elms in advance. 4 > 3 so go to next.\\nOn index 2 we have element `6` and 3 elms in advance. 3 <= 6 but we cant\\'t use it as an answer because we had less or equal number previously - `3` at index 1 (this is an additional condition).\\nNext steps also don\\'t have sense because the tail length will always less then previous element of array. So return -1.\\n\\n# Complexity\\n- Time complexity:\\nWe have only one loop from 1...n, so we could say $$O(n)$$, but we used function sort, that is why it wouldn\\'t be true.\\n\\n# Code\\n```\\nfunction specialArray(nums: number[]): number {\\n  nums.sort((a, b) => a - b);\\n\\n  for (let i = 0; i < nums.length; i ++) {\\n    // tail length\\n    const rest = nums.length - i\\n    // main condition\\n    if (rest <= nums[i]) {\\n      if (i == 0) return rest;\\n      else {\\n        // additional condition\\n        if (nums[i - 1] < rest) return rest;\\n        // further search doesn\\'t have a sense\\n        else return -1;\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction specialArray(nums: number[]): number {\\n  nums.sort((a, b) => a - b);\\n\\n  for (let i = 0; i < nums.length; i ++) {\\n    // tail length\\n    const rest = nums.length - i\\n    // main condition\\n    if (rest <= nums[i]) {\\n      if (i == 0) return rest;\\n      else {\\n        // additional condition\\n        if (nums[i - 1] < rest) return rest;\\n        // further search doesn\\'t have a sense\\n        else return -1;\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3351494,
                "title": "easy-c-sort-upper-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) +O(nlogn) ~ O(nlogn)\\n \\none for sorting and another for finding out the upper bound\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int upperBound(vector<int>&arr,int i){\\n        int lo=0;\\n        int hi=arr.size()-1;\\n        int ans=-1;\\n        while(lo<=hi){\\n            int mid= lo + (hi-lo)/2;\\n            if(arr[mid]<i){\\n                lo=mid+1;\\n            }\\n            else {\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n        }\\n    return ans;\\n    }\\n\\n\\n    int specialArray(vector<int>& nums) {\\n    sort(nums.begin(),nums.end());\\n\\n    for(int i=0;i<=nums.size();i++){\\n\\n        int ubIndex=upperBound(nums,i);\\n        if(ubIndex==-1)return -1;\\n        int elementsGreaterThani=nums.size()-ubIndex;\\n        if(i==elementsGreaterThani)return i;\\n    }\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int upperBound(vector<int>&arr,int i){\\n        int lo=0;\\n        int hi=arr.size()-1;\\n        int ans=-1;\\n        while(lo<=hi){\\n            int mid= lo + (hi-lo)/2;\\n            if(arr[mid]<i){\\n                lo=mid+1;\\n            }\\n            else {\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n        }\\n    return ans;\\n    }\\n\\n\\n    int specialArray(vector<int>& nums) {\\n    sort(nums.begin(),nums.end());\\n\\n    for(int i=0;i<=nums.size();i++){\\n\\n        int ubIndex=upperBound(nums,i);\\n        if(ubIndex==-1)return -1;\\n        int elementsGreaterThani=nums.size()-ubIndex;\\n        if(i==elementsGreaterThani)return i;\\n    }\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265979,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n          int x = nums.length;\\n        int[] counts = new int[x+1];\\n        \\n        for(int elem : nums)\\n            if(elem >= x)\\n                counts[x]++;\\n            else\\n                counts[elem]++;\\n        \\n        int res = 0;\\n        for(int i = counts.length-1; i > 0; i--) {\\n            res += counts[i];\\n            if(res == i)\\n                return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n          int x = nums.length;\\n        int[] counts = new int[x+1];\\n        \\n        for(int elem : nums)\\n            if(elem >= x)\\n                counts[x]++;\\n            else\\n                counts[elem]++;\\n        \\n        int res = 0;\\n        for(int i = counts.length-1; i > 0; i--) {\\n            res += counts[i];\\n            if(res == i)\\n                return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265008,
                "title": "js-binary-search-clear-code-with-explanation",
                "content": "# Intuition\\nSearch for the number in the list *(or where you\\'d insert the number in the list if not there)*, check if it\\'s a magic number based on the fact that the list is ordered.\\n\\n# Approach\\n1. for each number until I reach the length of the array\\n2. we search for where the potential special number is; or should be in the array.\\n3. we check if it\\'s a special number by checking how many numbers are greater or equal to it.\\n4. return the nr if found, -1 if we\\'ve gone through all the numbers and did not find a special number.\\n\\nGotchas:\\n1. nr can be max nums.length, because it has to be smaller or equal than SOME element, so it needs elements. I.e. [4,5,5] number can\\'t be bigger than 3, because there\\'s only 3 numbers against which we can test the condition.\\n2. don\\'t forget that we could have duplicate numbers in the nums array i.e.: [7,7,7,7]\\n3. Because the list is ordered, we can consistently determine how many  numbers our current number is smaller or equal to; so this formula `(i === nums.length - pos)`.\\ni.e.: [2,3,5,9,9,10,11] if we take 5, at index = 2, we can see there are  5 numbers >= to 5, from the total of 7 numbers, so we can ignore everything up to 5, aka: `7 (nums length) - 2 (nrs before 5, also index) = 5 (numbers >= 2)`\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) to iterate through all nums, where n is the length of the nums array *\\nO(log n) as we do a binary search for each number.\\nresulting time complexity: O(n log n)\\n\\n\\n- Space complexity:\\nO(1) - as we do not use any extra data structure.\\n\\n# Code\\n```\\n\\nconst searchInsertPosition = (arr, target) => {\\n    let low = 0;\\n    let high = arr.length - 1;\\n\\n    while(low <= high) {\\n        mid = low + Math.floor((high - low) / 2);\\n\\n        if(arr[mid] < target) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    return low;\\n}\\n\\nvar specialArray = function(nums) {\\n    nums.sort((a,b) => a - b);\\n\\n    for(let i = 1; i <= nums.length; i++) {\\n        let pos = searchInsertPosition(nums, i);\\n        if(i === nums.length - pos) return i;\\n    }\\n\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n\\nconst searchInsertPosition = (arr, target) => {\\n    let low = 0;\\n    let high = arr.length - 1;\\n\\n    while(low <= high) {\\n        mid = low + Math.floor((high - low) / 2);\\n\\n        if(arr[mid] < target) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    return low;\\n}\\n\\nvar specialArray = function(nums) {\\n    nums.sort((a,b) => a - b);\\n\\n    for(let i = 1; i <= nums.length; i++) {\\n        let pos = searchInsertPosition(nums, i);\\n        if(i === nums.length - pos) return i;\\n    }\\n\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3219289,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int SpecialArray(int[] nums) {\\n        Array.Sort(nums);\\n        // iterate from arr length to 1\\n        int i=nums.Length;\\n        int numsGreaterOrEqual;\\n        while(i>0){\\n            numsGreaterOrEqual=0;\\n            foreach(var n in nums){\\n                if(n>=i)\\n                    numsGreaterOrEqual++;\\n            }\\n            if(numsGreaterOrEqual==i)\\n                return i;\\n            i--;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SpecialArray(int[] nums) {\\n        Array.Sort(nums);\\n        // iterate from arr length to 1\\n        int i=nums.Length;\\n        int numsGreaterOrEqual;\\n        while(i>0){\\n            numsGreaterOrEqual=0;\\n            foreach(var n in nums){\\n                if(n>=i)\\n                    numsGreaterOrEqual++;\\n            }\\n            if(numsGreaterOrEqual==i)\\n                return i;\\n            i--;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152969,
                "title": "easy-solution-using-binary-search-in-c-beats-100-and-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We use binary search in this problem.\\nhere is my c++ and python solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int low=1; \\n        int high= nums.size();\\n        while (low<=high){\\n            int mid= low+(high-low)/2;\\n            int x=0;\\n            for (int i=0; i<nums.size(); i++)\\n                if (nums[i]>=mid)x++;\\n            if (mid==x)\\n            return mid;\\n            if (x<mid)\\n            high= mid-1;\\n            else \\n            low= mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n\\n//python solution\\n\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = 0, n\\n        while(l<=r):\\n            mid=(l+r)//2\\n            count=0 \\n            for i in nums:\\n                if(i>=mid):\\n                    count +=1\\n            if (count==mid): \\n                return mid\\n            elif count > mid:\\n                l = mid + 1\\n            else : \\n                r = mid - 1\\n        return -1        \\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int low=1; \\n        int high= nums.size();\\n        while (low<=high){\\n            int mid= low+(high-low)/2;\\n            int x=0;\\n            for (int i=0; i<nums.size(); i++)\\n                if (nums[i]>=mid)x++;\\n            if (mid==x)\\n            return mid;\\n            if (x<mid)\\n            high= mid-1;\\n            else \\n            low= mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n\\n//python solution\\n\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = 0, n\\n        while(l<=r):\\n            mid=(l+r)//2\\n            count=0 \\n            for i in nums:\\n                if(i>=mid):\\n                    count +=1\\n            if (count==mid): \\n                return mid\\n            elif count > mid:\\n                l = mid + 1\\n            else : \\n                r = mid - 1\\n        return -1        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145718,
                "title": "easy-to-understand-beginner-friendly-solution-using-binary-search",
                "content": "# Intuition\\nNotice that we can look for answers between number 0, nums.size().\\nthere is no posibility to find more numbers greater to sth in an arrey than elements of that array. We sort vector to perform binary search on it. For every number between 0->nums.size(). We perform binary search to find how many elements in an arrey are greater or equal. When conditions are followed the answer is found.\\n\\n# Approach\\nIt\\'s important to sort vector to perform binary search on it.\\nFor every nuber between 0 nad size of given vector we search using binary search for number of numbers greater or equal to it. Once we find the answer we stop searching and return the answer. If there is no answer we simply return -1 at the end of the solution.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1) No addcional space is needed for this solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& A, int target){\\n        int l = 0;\\n        int p = A.size()-1;\\n        int s;\\n        while(l<p){\\n            s=(l+p)/2;\\n            if(A[s] < target){\\n                l = s+1;\\n            }else{\\n                p = s;\\n            }\\n        }\\n        return l;\\n    }\\n    int specialArray(vector<int>& nums) {\\n\\n        int res;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i <= nums.size(); i++){\\n            int index = bs(nums, i);\\n            if(nums[index] < i){\\n                res = 0;\\n            }else{\\n                res = (nums.size()-index);\\n            }\\n            if(res == i){\\n                return res;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& A, int target){\\n        int l = 0;\\n        int p = A.size()-1;\\n        int s;\\n        while(l<p){\\n            s=(l+p)/2;\\n            if(A[s] < target){\\n                l = s+1;\\n            }else{\\n                p = s;\\n            }\\n        }\\n        return l;\\n    }\\n    int specialArray(vector<int>& nums) {\\n\\n        int res;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i <= nums.size(); i++){\\n            int index = bs(nums, i);\\n            if(nums[index] < i){\\n                res = 0;\\n            }else{\\n                res = (nums.size()-index);\\n            }\\n            if(res == i){\\n                return res;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046307,
                "title": "simple-js-soltution-almost-same-as-h-index-tc-o-nlogn-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar specialArray = function(nums) {\\n    let sorted = nums.sort((a, b) => b - a);\\n    // 7,7, 6, 3, 0\\n    let hIndex = -1;\\n    for (let i = 1; i <= nums.length; i++) {\\n        if (sorted[i - 1] >= i) {\\n            hIndex = i;\\n        } else {\\n            if (sorted[i - 1] >= hIndex) {\\n                hIndex = -1;\\n            }\\n            break;\\n        }\\n    }\\n    return hIndex;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar specialArray = function(nums) {\\n    let sorted = nums.sort((a, b) => b - a);\\n    // 7,7, 6, 3, 0\\n    let hIndex = -1;\\n    for (let i = 1; i <= nums.length; i++) {\\n        if (sorted[i - 1] >= i) {\\n            hIndex = i;\\n        } else {\\n            if (sorted[i - 1] >= hIndex) {\\n                hIndex = -1;\\n            }\\n            break;\\n        }\\n    }\\n    return hIndex;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3035199,
                "title": "basic-binary-search-with-two-pointers",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = 0, n\\n        while(l<=r):\\n            mid = (l+r)//2\\n            count = 0 \\n            for i in nums:\\n                if(i>=mid):\\n                    count +=1\\n\\n            if (count == mid): return mid\\n            elif count > mid:\\n                l = mid + 1\\n            else : \\n                r = mid - 1\\n\\n        return -1            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = 0, n\\n        while(l<=r):\\n            mid = (l+r)//2\\n            count = 0 \\n            for i in nums:\\n                if(i>=mid):\\n                    count +=1\\n\\n            if (count == mid): return mid\\n            elif count > mid:\\n                l = mid + 1\\n            else : \\n                r = mid - 1\\n\\n        return -1            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020064,
                "title": "easy-to-understand-c-solution-beats-100-submissions-binary-search-makes-it-easy",
                "content": "# Approach\\n1. If the $nums$ array is empty, clearly the answer is 0.\\n\\n2. We will be creating a vector which would be holding all the possbile answers, which lies in the range $1-size$.\\n\\n3. For example, if our array is $[2,4,0,0,1]$ then our ans would be in the range $1-5$. As there cannot be ***more than 5*** numbers in $nums$ which will be greater than or equal to 5.\\n\\n4. Now with binary search we will be searching for our possible answer, lets say its ***x***.\\n5. And in every iteration for that value ***x***, we will find numbers in $nums$ greater than or equal to ***x*** and we will match it with  ***x***, if there are exactly ***x*** numbers which are greater than or equal to ***x*** we will return it, or update our search space and iterate accordingly.\\n\\n    ***I hope after reading the approach and code, you\\'d get the solution.***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int size = nums.size();\\n\\n        //we have created an vector for which holds all possible answer, from 1 to size.\\n        vector<int>v;\\n\\n        //if size of the array is 0, then no ans can be there\\n        if(size == 0){\\n            return 0;\\n        }\\n\\n        //storing all possible answers in the vector\\n        for(int i = 1; i <= size; i++){\\n            v.push_back(i);\\n        }\\n\\n        //binary serach for getting number, which possibly maybe our answer\\n        int start = 0;\\n        int end = size-1;\\n        while(start <= end){\\n            int count = 0;\\n            int mid = start + (end - start)/2;\\n            int x = v[mid];\\n\\n            //counting numbers equal to or greater than x\\n            for(int i = 0; i < size; i++){\\n                if(nums[i] >= x){\\n                    count++;\\n                }\\n            }\\n\\n            //comparing and updating our search-space\\n            if(count == x){\\n                return x;\\n            }\\n            \\n\\n            else if(count > x){\\n                start = mid+1;\\n            }\\n\\n            else if(count < x){\\n                end = mid-1;\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int size = nums.size();\\n\\n        //we have created an vector for which holds all possible answer, from 1 to size.\\n        vector<int>v;\\n\\n        //if size of the array is 0, then no ans can be there\\n        if(size == 0){\\n            return 0;\\n        }\\n\\n        //storing all possible answers in the vector\\n        for(int i = 1; i <= size; i++){\\n            v.push_back(i);\\n        }\\n\\n        //binary serach for getting number, which possibly maybe our answer\\n        int start = 0;\\n        int end = size-1;\\n        while(start <= end){\\n            int count = 0;\\n            int mid = start + (end - start)/2;\\n            int x = v[mid];\\n\\n            //counting numbers equal to or greater than x\\n            for(int i = 0; i < size; i++){\\n                if(nums[i] >= x){\\n                    count++;\\n                }\\n            }\\n\\n            //comparing and updating our search-space\\n            if(count == x){\\n                return x;\\n            }\\n            \\n\\n            else if(count > x){\\n                start = mid+1;\\n            }\\n\\n            else if(count < x){\\n                end = mid-1;\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943504,
                "title": "no-complication-simple-3-line-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar specialArray = function(nums) {\\n    let x = nums.length;\\n    while(x>=0){\\n        let arr = [...nums].filter(ele => ele>=x);\\n        let count = arr.length;\\n        if(count==x) return count;\\n        x--;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar specialArray = function(nums) {\\n    let x = nums.length;\\n    while(x>=0){\\n        let arr = [...nums].filter(ele => ele>=x);\\n        let count = arr.length;\\n        if(count==x) return count;\\n        x--;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2897085,
                "title": "python-brute-force-62-06-faster",
                "content": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(1,1001):\\n            c=0\\n            for j in nums:\\n                if i<=j:\\n                    c+=1\\n            if i==c:\\n                return i\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(1,1001):\\n            c=0\\n            for j in nums:\\n                if i<=j:\\n                    c+=1\\n            if i==c:\\n                return i\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877941,
                "title": "full-solution-in-cpp-with-both-approaches-o-n-2-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int specialArray(vector<int> &nums)\\n    {\\n        // Brute force solution :-\\n        //  for(int i = 1; i< 1001; i++)\\n        //  {\\n        //      int count = 0;\\n        //      for(int num:nums)\\n        //      {\\n        //          if(num>=i)\\n        //          {\\n        //              count++;\\n        //          }\\n        //      }\\n        //      if(i==count)\\n        //      {\\n        //          return i;\\n        //      }\\n        //  }\\n        //  return -1;\\n\\n        // DP Solution\\n        vector<int> dp(1001, 0);\\n        for (auto x : nums)\\n        {\\n            dp[x]++;\\n        }\\n        int total = nums.size();\\n        for (int i = 0; i < 1001; i++)\\n        {\\n            if(i==total)\\n            {\\n                return i;\\n            }\\n            total -= dp[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int specialArray(vector<int> &nums)\\n    {\\n        // Brute force solution :-\\n        //  for(int i = 1; i< 1001; i++)\\n        //  {\\n        //      int count = 0;\\n        //      for(int num:nums)\\n        //      {\\n        //          if(num>=i)\\n        //          {\\n        //              count++;\\n        //          }\\n        //      }\\n        //      if(i==count)\\n        //      {\\n        //          return i;\\n        //      }\\n        //  }\\n        //  return -1;\\n\\n        // DP Solution\\n        vector<int> dp(1001, 0);\\n        for (auto x : nums)\\n        {\\n            dp[x]++;\\n        }\\n        int total = nums.size();\\n        for (int i = 0; i < 1001; i++)\\n        {\\n            if(i==total)\\n            {\\n                return i;\\n            }\\n            total -= dp[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717983,
                "title": "python-basic-solution",
                "content": "Python solution written under test conditions in 5mins:\\n\\n```python\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        \"\"\"\\n        This solution collects the maximal value of nums, then sets the outcome to\\n        -1. For each value in range 0 -> maximal_value inclusive, we calculate the\\n        length of the values as array length of (x for x in nums where x is\\n        greater than or equal to i). If the length of values is exactly equal to\\n        i, the outcome is updated as the max of outcome and values. The outcome\\n        is finally returned pon completion of the loop.\\n        \\n        :param nums: the array of numbers to be considered. (List[int])\\n        :return outcome: the number which meets the logic requirement. (int)\\n        \"\"\"\\n        maximal_value = max(nums)\\n        outcome = -1\\n        \\n        for i in range(maximal_value+1):\\n            values = len([x for x in nums if x >= i])\\n            if values == i:\\n                outcome = max(outcome, values)\\n        return outcome",
                "solutionTags": [
                    "Python"
                ],
                "code": "Python solution written under test conditions in 5mins:\\n\\n```python\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        \"\"\"\\n        This solution collects the maximal value of nums, then sets the outcome to\\n        -1. For each value in range 0 -> maximal_value inclusive, we calculate the\\n        length of the values as array length of (x for x in nums where x is\\n        greater than or equal to i). If the length of values is exactly equal to\\n        i, the outcome is updated as the max of outcome and values. The outcome\\n        is finally returned pon completion of the loop.\\n        \\n        :param nums: the array of numbers to be considered. (List[int])\\n        :return outcome: the number which meets the logic requirement. (int)\\n        \"\"\"\\n        maximal_value = max(nums)\\n        outcome = -1\\n        \\n        for i in range(maximal_value+1):\\n            values = len([x for x in nums if x >= i])\\n            if values == i:\\n                outcome = max(outcome, values)\\n        return outcome",
                "codeTag": "Java"
            },
            {
                "id": 2649622,
                "title": "python-o-n-2-o-nlogn-o-n",
                "content": "## **1. BRUTE FORCE APPROACH - O(N^2)**\\n\\nIn Brute Force Approach, we have two nested loops and for each valid value of x, we have to go through the whole list and count how many numbers are >= x. If the count is == x, that means this is a special array and we can return x.\\n\\nBut again, we have to loop through the whole array for each x. So not an efficient approach.\\n\\n```\\ndef specialArray(self, nums: List[int]) -> int:\\n\\n\\t# x can be in the range 0 to length of the list (inclusive)\\n\\t# We need to go through the whole array for each value of x\\n\\tfor x in range(len(nums) + 1):\\n\\t\\tcount = 0\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num >= x: count += 1\\n\\t\\t# If count of elements >= x is equal to x\\n\\t\\t# That means, this is a special array so we can return x\\n\\t\\tif count == x: return x\\n\\n\\t# If not a special array\\n\\treturn -1\\n```\\n\\n## **2. BINARY SEARCH APPROACH - O(NLogN)**\\n\\nWe can sort this array in increasing order and now, all we need to find is the index of the smallest number that is >= x. If we find that index, we know that all elements after that index are also >= x since array is sorted. So we are not traversing the whole list for each value of x. In Binary Search, we will either move to right of mid or left of mid so this is a much better approach than the Brute Force approach.\\n\\n```\\ndef specialArray(self, nums: List[int]) -> int:\\n        \\n        # Sort the given array\\n        nums.sort()\\n        \\n        n = len(nums)\\n        \\n        # Now, for each value of x, we just need to find the smallest number that is >= x\\n        # Once we find that, all numbers after that number are already >= x as array is sorted\\n        \\n        for x in range(n + 1):\\n            \\n            # Binary Search\\n            start = 0\\n            end = n - 1\\n            result = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                if nums[mid] >= x:\\n                    result = mid\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n                    \\n            if result >= 0 and n - result == x: return x\\n            \\n\\n        # If not a special array\\n        return -1\\n```\\n\\n## **3. COUNTING SORT - O(N)**\\nThe most efficient solution for this problem is using counting sort.\\n\\nBasically, we will store the count of each element in the given array in a new array.\\n\\nAnd use that count to calculate how many elements are >= any x value. \\n\\n\\t\\t\\tnums = [0,4,3,0,4]\\n\\t\\t\\tcount = [2,0,0,1,2]\\n\\nEach index value specifies what is the count of number = index in the given array. e.g. count of 0 is 2, count of 1 is 0 and so on...\\n\\nNow that we got this array, how to find how many elements are >= any x value? \\n\\nAs we know, the range of x is from 0 to length of the given array (inclusive). Because obviously it cannot be more than length as we know there can be an x that is <= to all the numbers of given array so for that case, length of array will be the result.\\n\\nSo, for each value of x from 0 to n, we need to check what is the count of x in the count array. Just think about it. Each value in count array shows how many times a particular number appears in the array. So that means, each value in count array means how many elements are == any x.\\n\\n\\tTake 0 for example in above array.\\n\\t\\n\\tCount of 0 = 2\\n\\tSo, there are 2 elements that are equal to 0\\n\\t\\t\\n\\tAnd Because 0 is the smallest possible value in the array. So obviously all elements of array are >= 0\\n\\t\\n\\tBut then when x becomes 1. Then we see count of 1 = 0.\\n\\t\\n\\tBut wait. We know that if x == 1, we only need to count numbers >= 1. So we don\\'t need the count of 0s now.\\n\\t\\n\\tIn other words -> Count of numbers >= 1  ->\\n\\t\\n\\t\\t\\t(Length of array - count of 0 in array)\\n\\t  \\n\\t And for this reason, after each iteration, we have to remove the count of current x from n.\\n\\t\\t\\t\\t\\n\\t\\t\\n\\n```\\ndef specialArray(self, nums: List[int]) -> int:\\n        \\n        # Since the max value of any element in the array can be 1000\\n        count = [0] * 1001\\n        \\n        # Store the count of each element\\n        for num in nums: count[num] += 1\\n            \\n        # n is initially equal to total number of elements in the array\\n        # n = how many elements are equal to any x value in range 0 to n\\n\\t\\t# Since lowest value of x is 0, we know the number of elements\\n\\t\\t# >= 0 can be n\\n        n = len(nums)\\n        \\n        # x can be in range 0 to n (inclusive)\\n        for x in range(0, n + 1):\\n            if x == n: return x\\n            # Before moving to next x, substract the count of current x from n\\n\\t\\t\\t# Because we only need to consider numbers >= x\\n\\t\\t\\t# So for next value of x, current x\\'s count is no longer needed\\n            n -= count[x]\\n\\n        # If not a special array\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef specialArray(self, nums: List[int]) -> int:\\n\\n\\t# x can be in the range 0 to length of the list (inclusive)\\n\\t# We need to go through the whole array for each value of x\\n\\tfor x in range(len(nums) + 1):\\n\\t\\tcount = 0\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num >= x: count += 1\\n\\t\\t# If count of elements >= x is equal to x\\n\\t\\t# That means, this is a special array so we can return x\\n\\t\\tif count == x: return x\\n\\n\\t# If not a special array\\n\\treturn -1\\n```\n```\\ndef specialArray(self, nums: List[int]) -> int:\\n        \\n        # Sort the given array\\n        nums.sort()\\n        \\n        n = len(nums)\\n        \\n        # Now, for each value of x, we just need to find the smallest number that is >= x\\n        # Once we find that, all numbers after that number are already >= x as array is sorted\\n        \\n        for x in range(n + 1):\\n            \\n            # Binary Search\\n            start = 0\\n            end = n - 1\\n            result = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                if nums[mid] >= x:\\n                    result = mid\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n                    \\n            if result >= 0 and n - result == x: return x\\n            \\n\\n        # If not a special array\\n        return -1\\n```\n```\\ndef specialArray(self, nums: List[int]) -> int:\\n        \\n        # Since the max value of any element in the array can be 1000\\n        count = [0] * 1001\\n        \\n        # Store the count of each element\\n        for num in nums: count[num] += 1\\n            \\n        # n is initially equal to total number of elements in the array\\n        # n = how many elements are equal to any x value in range 0 to n\\n\\t\\t# Since lowest value of x is 0, we know the number of elements\\n\\t\\t# >= 0 can be n\\n        n = len(nums)\\n        \\n        # x can be in range 0 to n (inclusive)\\n        for x in range(0, n + 1):\\n            if x == n: return x\\n            # Before moving to next x, substract the count of current x from n\\n\\t\\t\\t# Because we only need to consider numbers >= x\\n\\t\\t\\t# So for next value of x, current x\\'s count is no longer needed\\n            n -= count[x]\\n\\n        # If not a special array\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2641508,
                "title": "count-and-select-35ms",
                "content": "For test case one, the elements `[3, 5]` could have an answer of `3` or `1`, but chose `2` and was returned, and after going through the problem statement again, got to know that 2 is the element  `x` and the number of elements are equal to `x`.\\n\\n_Hence implemented a hashmap for this reason._\\n\\n\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        hashlist = [0 for i in range(l+1)]\\n        for i in nums:\\n            if i >= l:\\n                hashlist[l] +=1\\n            else:\\n                hashlist[i] +=1\\n        print(hashlist)\\n        out = 0\\n        for i in range(l, 0, -1):\\n            out += hashlist[i]\\n            if out == i:\\n                return i\\n        return -1\\n```\\n_but seems fast enough_\\n![image](https://assets.leetcode.com/users/images/86201ae8-7645-48a1-8fd3-f663b5681f62_1664522543.3199315.png)\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        hashlist = [0 for i in range(l+1)]\\n        for i in nums:\\n            if i >= l:\\n                hashlist[l] +=1\\n            else:\\n                hashlist[i] +=1\\n        print(hashlist)\\n        out = 0\\n        for i in range(l, 0, -1):\\n            out += hashlist[i]\\n            if out == i:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639380,
                "title": "c-simple-counting-and-comparing-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int c=1;\\n        int mx=0;\\n        sort(nums.begin(),nums.end());\\n        while(c<=nums.size())\\n        {\\n            int count=0;\\n            for(auto i:nums)\\n            {\\n                if(i>=c)count++;\\n            }\\n            if(count == c)\\n                mx=max(mx,count);\\n            c++;\\n        }\\n        if(mx==0)return -1;\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int c=1;\\n        int mx=0;\\n        sort(nums.begin(),nums.end());\\n        while(c<=nums.size())\\n        {\\n            int count=0;\\n            for(auto i:nums)\\n            {\\n                if(i>=c)count++;\\n            }\\n            if(count == c)\\n                mx=max(mx,count);\\n            c++;\\n        }\\n        if(mx==0)return -1;\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624442,
                "title": "binary-search-time-complexity-nlogn",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int func(vector<int>& nums,int n,int m){\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n            if(nums[i]>=m)\\n                c++;\\n        return c;\\n    }\\n    int specialArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int end=*max_element(nums.begin(),nums.end());\\n        int start=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(mid==func(nums,n,mid))\\n                return mid;\\n            else if(mid<func(nums,n,mid))\\n                start=start+1;\\n            else if(mid>func(nums,n,mid))\\n                end=end-1;  \\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int func(vector<int>& nums,int n,int m){\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n            if(nums[i]>=m)\\n                c++;\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2614502,
                "title": "solution-in-binary-search-beats-90-java",
                "content": "Understandable have a great day ! \\n```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n       int start = 1 , end = nums.length , count=0;\\n        while (start<=end){\\n            int mid = start + (end - start) /2;\\n            count = numbers(nums , mid);\\n            if(count<mid) end = mid-1;\\n            else if(count == mid) return mid;\\n            else start = mid+1;\\n        }\\n        return -1;\\n    }\\n    public int numbers(int [] nums , int target){\\n        int count = 0;\\n        for (int ele : nums){\\n            if(ele >= target) count++;\\n        }\\n        return count ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n       int start = 1 , end = nums.length , count=0;\\n        while (start<=end){\\n            int mid = start + (end - start) /2;\\n            count = numbers(nums , mid);\\n            if(count<mid) end = mid-1;\\n            else if(count == mid) return mid;\\n            else start = mid+1;\\n        }\\n        return -1;\\n    }\\n    public int numbers(int [] nums , int target){\\n        int count = 0;\\n        for (int ele : nums){\\n            if(ele >= target) count++;\\n        }\\n        return count ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608345,
                "title": "java-o-n-time-complexity",
                "content": "```\\npublic int specialArray(int[] nums) {\\n      \\n        int x=0;\\n        for(int i:nums){\\n            if(i>0)  x+=1; }\\n        \\n        if(x==0) return -1;\\n        while(x>0){\\n        int count=0;\\n        for(int i:nums){\\n            if(i>=x ){\\n               count+=1; \\n            }\\n        }\\n        if(x==count) return x;\\n          \\n            x-=1;\\n        }return -1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int specialArray(int[] nums) {\\n      \\n        int x=0;\\n        for(int i:nums){\\n            if(i>0)  x+=1; }\\n        \\n        if(x==0) return -1;\\n        while(x>0){\\n        int count=0;\\n        for(int i:nums){\\n            if(i>=x ){\\n               count+=1; \\n            }\\n        }\\n        if(x==count) return x;\\n          \\n            x-=1;\\n        }return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2586501,
                "title": "pyhton-solution",
                "content": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        for x in range(len(nums)+1):\\n            count = 0\\n            for elem in nums:\\n                if elem >= x:\\n                    count+=1\\n            print(count)\\n            if count == x:\\n                return x\\n        return -1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        for x in range(len(nums)+1):\\n            count = 0\\n            for elem in nums:\\n                if elem >= x:\\n                    count+=1\\n            print(count)\\n            if count == x:\\n                return x\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2582916,
                "title": "c-if-else-approach-o-n-log-n-easy-2ms",
                "content": "```\\nint k = 0;\\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(i == 0) {\\n                k = n - i;\\n                \\n                if(nums[i] >= k){\\n                    return k;\\n                }\\n            }\\n            \\n            else {\\n                \\n                if(nums[i] == nums[i-1]) {\\n                    continue;\\n                }\\n                \\n                else {\\n                    k = n - i;\\n                    if(nums[i] >= k && nums[i-1] < k) {\\n                        return k;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint k = 0;\\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(i == 0) {\\n                k = n - i;\\n                \\n                if(nums[i] >= k){\\n                    return k;\\n                }\\n            }\\n            \\n            else {\\n                \\n                if(nums[i] == nums[i-1]) {\\n                    continue;\\n                }\\n                \\n                else {\\n                    k = n - i;\\n                    if(nums[i] >= k && nums[i-1] < k) {\\n                        return k;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2553379,
                "title": "java-binary-search-solution-easy-to-understand",
                "content": "\\tNo need to apply sorting here because we are applying the search in range of x that is 0 to nums.length.\\n\\t//if this help please upvote\\n\\t\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic int specialArray(int[] nums) {\\n\\t\\t\\tint start=0;\\n\\t\\t\\tint end=nums.length;\\n\\t\\t\\twhile(start<=end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid=start+(end-start)/2;\\n\\t\\t\\t\\tint midcount=count(nums,mid);\\n\\t\\t\\t\\tif(mid==midcount)\\n\\t\\t\\t\\t{return mid;}\\n\\t\\t\\t\\telse if(mid<midcount)\\n\\t\\t\\t\\t\\tstart=mid+1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\n\\t\\t}\\n\\t\\tpublic int count(int arr[],int numbertocount)\\n\\t\\t{\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor (int ele:arr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ele>=numbertocount)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int specialArray(int[] nums) {\\n\\t\\t\\tint start=0;\\n\\t\\t\\tint end=nums.length;\\n\\t\\t\\twhile(start<=end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid=start+(end-start)/2;\\n\\t\\t\\t\\tint midcount=count(nums,mid);\\n\\t\\t\\t\\tif(mid==midcount)\\n\\t\\t\\t\\t{return mid;}",
                "codeTag": "Java"
            },
            {
                "id": 2516217,
                "title": "java-linear-solution-using-sorting",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int lastIndex = nums.length-1; \\n        int i = 0; \\n        while (i <= lastIndex) {\\n            int current = nums[i]; \\n            int x = (lastIndex - i) + 1; \\n            if (current >= x && (i == 0 || nums[i-1] < x)) return x;\\n            i++; \\n        }\\n        \\n        return -1; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int lastIndex = nums.length-1; \\n        int i = 0; \\n        while (i <= lastIndex) {\\n            int current = nums[i]; \\n            int x = (lastIndex - i) + 1; \\n            if (current >= x && (i == 0 || nums[i-1] < x)) return x;\\n            i++; \\n        }\\n        \\n        return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514615,
                "title": "faster-than-100-java-binary-search-special-array-with-x-elements-greater-than-or-equal-x",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int n = nums.length;\\n        \\n        int start = 1, end = n;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            int greater = greaterThanX(nums, mid);\\n            \\n            if(mid == greater) {\\n                return mid;\\n            }\\n            else if(mid < greater) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int greaterThanX(int[] nums, int x) {\\n        int count = 0;\\n        \\n        for(int i : nums) {\\n            if(i >= x)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int n = nums.length;\\n        \\n        int start = 1, end = n;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            int greater = greaterThanX(nums, mid);\\n            \\n            if(mid == greater) {\\n                return mid;\\n            }\\n            else if(mid < greater) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int greaterThanX(int[] nums, int x) {\\n        int count = 0;\\n        \\n        for(int i : nums) {\\n            if(i >= x)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501852,
                "title": "c-binary-search-lower-bound-100-faster",
                "content": "Observation:\\nn-it = number of elements >= mid so if v = {3, 5}, n=2=v.size() and mid = 2\\nit = 0 as 3 and 5 are greater than 2 so n-it = 2-0 = 2 = mid so we found an element satisfying the condition\\n\\nnow if n-it < mid imagine the same array but mid = 4 => if we have only one element greater than 4 so we\\'re sure that if we increase mid to 5 or 6, the number of elements greater than mid will decrease and that\\'s why there is no sens to increase mid and the inverse is right\\nimagine we have 5 elements greater than our mid = 2, we need to decrease this number so we increase mid to get lesser elements greater than the new mid\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int n=v.size();\\n        int i=0;\\n        int j=n;\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            int it = lower_bound(v.begin(), v.end(), mid) - v.begin();\\n            int g = n-it;\\n            \\n            if (g==mid)\\n                return g;\\n            else if (g<mid)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int n=v.size();\\n        int i=0;\\n        int j=n;\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            int it = lower_bound(v.begin(), v.end(), mid) - v.begin();\\n            int g = n-it;\\n            \\n            if (g==mid)\\n                return g;\\n            else if (g<mid)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474458,
                "title": "python-brute-force-to-binary-search-intuition",
                "content": "**Brute force:**\\n\\nFor each x in [1, len(nums)], check if it satisifies the property. Since length of number is 100, its an accepted solution\\n\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        def special(x):\\n            return sum([1 for num in nums if num >= x])\\n        \\n        for i in range(1, len(nums) + 1):\\n            if special(i):\\n                return i\\n        return -1\\n```\\n\\nWhenever we need to find out a possible solution from range [x, y], think of Binary-Search\\nIt will help to reduce the search time to O(logn)\\n\\n```\\n\\t\\tleft, right = 0, len(nums)\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            res = special(mid)\\n            if res == mid:\\n                return mid\\n            elif res > mid:\\n                left += 1\\n            else:\\n                right -= 1\\n        return -1\\n```\\n\\nMore easy problems where we can apply same property (list is not exhaustive)\\n35. Search Insert Position [Easy]\\n278. First Bad Version [Easy]\\n\\nA very good read for advance problem:\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/769698/Python-Clear-explanation-Powerful-Ultimate-Binary-Search-Template.-Solved-many-problems.\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        def special(x):\\n            return sum([1 for num in nums if num >= x])\\n        \\n        for i in range(1, len(nums) + 1):\\n            if special(i):\\n                return i\\n        return -1\\n```\n```\\n\\t\\tleft, right = 0, len(nums)\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            res = special(mid)\\n            if res == mid:\\n                return mid\\n            elif res > mid:\\n                left += 1\\n            else:\\n                right -= 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456323,
                "title": "runtime-0-ms-faster-than-100-00-java",
                "content": "```\\nclass Solution {\\n    int find(int[]nums,int x){ // to find numbers greater than or equal to x\\n        int count = 0;\\n        for(int i:nums)\\n        {\\n            if(i>=x)\\n                count++;\\n        }\\n      return count;\\n    }\\n\\t\\n    public int specialArray(int[] nums) {\\n        int start = 1,end = nums.length;\\n        \\n        while(start<=end){\\n            int x = start + (end-start)/2;\\n\\t\\t\\t\\n             if(x == find(nums,x)) \\n                 return x;\\n            \\n             if(find(nums,x) > x)\\n                 start  = x+1;\\n              else\\n                  end = x-1;\\n        }\\n        \\n    return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int find(int[]nums,int x){ // to find numbers greater than or equal to x\\n        int count = 0;\\n        for(int i:nums)\\n        {\\n            if(i>=x)\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2449851,
                "title": "java-nlog-n",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        for(int i=n; i>0; i--){\\n            if(nums[n-i]>=i){\\n                if(n-i-1<0 || nums[n-i-1]<i) return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        for(int i=n; i>0; i--){\\n            if(nums[n-i]>=i){\\n                if(n-i-1<0 || nums[n-i-1]<i) return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443555,
                "title": "java-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n     int x = nums.length;\\n        int[] counts = new int[x + 1];\\n        \\n        for(int elem : nums)\\n            if(elem >= x)\\n                counts[x] ++;\\n            else\\n                counts[elem] ++;\\n        \\n        int res = 0;\\n        for(int i = x; i > 0; i --) {\\n            res += counts[i];\\n            if(res == i)\\n                return i;\\n        }\\n        \\n        return - 1;   \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n     int x = nums.length;\\n        int[] counts = new int[x + 1];\\n        \\n        for(int elem : nums)\\n            if(elem >= x)\\n                counts[x] ++;\\n            else\\n                counts[elem] ++;\\n        \\n        int res = 0;\\n        for(int i = x; i > 0; i --) {\\n            res += counts[i];\\n            if(res == i)\\n                return i;\\n        }\\n        \\n        return - 1;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427199,
                "title": "c-binary-search-6-line-code",
                "content": "*Please **upvote** if you find it helpful :)*\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=1;i<=nums.size();i++) {\\n            int d = lower_bound(nums.begin(), nums.end(), i)-nums.begin();\\n            if(nums.size()-d == i)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=1;i<=nums.size();i++) {\\n            int d = lower_bound(nums.begin(), nums.end(), i)-nums.begin();\\n            if(nums.size()-d == i)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392444,
                "title": "python-faster-than-97-27-sort-and-binary-search",
                "content": "**Please upvote if it helps. Thank you!**\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        \\n        #Sorting nums array\\n        nums.sort()\\n        \\n        for i in range(len(nums), 0, -1):\\n            #Binary Search for i\\n            low, high = 0, len(nums) - 1\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] < i:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            #Got index of i in sorted list nums in variable low\\n            #Numbers after index i are greater than equal to i = len(nums) - low\\n            if len(nums) - low == i:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        \\n        #Sorting nums array\\n        nums.sort()\\n        \\n        for i in range(len(nums), 0, -1):\\n            #Binary Search for i\\n            low, high = 0, len(nums) - 1\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] < i:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            #Got index of i in sorted list nums in variable low\\n            #Numbers after index i are greater than equal to i = len(nums) - low\\n            if len(nums) - low == i:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368445,
                "title": "java-0ms-binary-search",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int size=nums.length;\\n        int count=0;\\n        int start=1;\\n        int end=nums.length;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            count=0;\\n            for(int i=0;i<size;i++){\\n                if(mid<=nums[i]){\\n                    count++;\\n                }else{\\n                    continue;\\n                }\\n            }\\n            if(mid==count){\\n                return mid;\\n            }else if(mid<count){\\n                start=mid+1;\\n            }else if(mid>count){\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int size=nums.length;\\n        int count=0;\\n        int start=1;\\n        int end=nums.length;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            count=0;\\n            for(int i=0;i<size;i++){\\n                if(mid<=nums[i]){\\n                    count++;\\n                }else{\\n                    continue;\\n                }\\n            }\\n            if(mid==count){\\n                return mid;\\n            }else if(mid<count){\\n                start=mid+1;\\n            }else if(mid>count){\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349993,
                "title": "java-most-intuitive-solution-with-time-and-space-complexity",
                "content": "```\\nclass Solution {\\n    /*\\n    - TC --> O(N * log(Range))\\n    - Search space --> [0, max elem of nums]\\n    - For every mid, count the number of elements >= mid --> count\\n    - if count == mid --> we got the answer\\n    - count > mid --> we have to discard left half as we need lesser element than curr count\\n    - count < mid --> we have to discard right half as we need more element than curr count\\n    */\\n    \\n    //This funtion will return the max element in the array\\n    private int getMax(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int e : nums) {\\n            max = Math.max(e, max);\\n        }\\n        return max;\\n    }\\n    \\n    // This function will return the count of element in nums >= mid element\\n    private int getGreaterThanOrEqualToMid(int[] nums, int mid) {\\n        int count = 0;\\n        for(int e : nums) {\\n            if(e >= mid) count++;\\n        }\\n        return count;\\n    }\\n    \\n    public int specialArray(int[] nums) { //TC --> O(N * log(Range))\\n        int low = 0;\\n        int high = getMax(nums); //O(N)\\n        \\n        while(low <= high) { // O(log(Range)) || Range --> [0, max ele of nums]\\n            int mid = low + (high - low)/2;\\n            \\n            int count = getGreaterThanOrEqualToMid(nums, mid); //O(N)\\n            \\n            if(mid == count) {\\n                return count;\\n            }\\n            else if(mid < count) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```\\n***Please upvote if you find it helpful. Happy Coding :)***",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    - TC --> O(N * log(Range))\\n    - Search space --> [0, max elem of nums]\\n    - For every mid, count the number of elements >= mid --> count\\n    - if count == mid --> we got the answer\\n    - count > mid --> we have to discard left half as we need lesser element than curr count\\n    - count < mid --> we have to discard right half as we need more element than curr count\\n    */\\n    \\n    //This funtion will return the max element in the array\\n    private int getMax(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int e : nums) {\\n            max = Math.max(e, max);\\n        }\\n        return max;\\n    }\\n    \\n    // This function will return the count of element in nums >= mid element\\n    private int getGreaterThanOrEqualToMid(int[] nums, int mid) {\\n        int count = 0;\\n        for(int e : nums) {\\n            if(e >= mid) count++;\\n        }\\n        return count;\\n    }\\n    \\n    public int specialArray(int[] nums) { //TC --> O(N * log(Range))\\n        int low = 0;\\n        int high = getMax(nums); //O(N)\\n        \\n        while(low <= high) { // O(log(Range)) || Range --> [0, max ele of nums]\\n            int mid = low + (high - low)/2;\\n            \\n            int count = getGreaterThanOrEqualToMid(nums, mid); //O(N)\\n            \\n            if(mid == count) {\\n                return count;\\n            }\\n            else if(mid < count) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325676,
                "title": "100-binary-search-easy-solution",
                "content": "```\\nint specialArray(vector<int>& nums) {\\n        \\n        int lo=0,hi=1000,mid,count;\\n        \\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            \\n            count=0;\\n            for(int i=0;i<nums.size();++i){\\n                if(nums[i]>=mid) count++;\\n                \\n            }\\n\\n            if(count==mid) return count;\\n            if(count>mid) lo=mid+1;\\n            else hi=mid-1;\\n            \\n        }\\n        return -1;\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nint specialArray(vector<int>& nums) {\\n        \\n        int lo=0,hi=1000,mid,count;\\n        \\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            \\n            count=0;\\n            for(int i=0;i<nums.size();++i){\\n                if(nums[i]>=mid) count++;\\n                \\n            }\\n\\n            if(count==mid) return count;\\n            if(count>mid) lo=mid+1;\\n            else hi=mid-1;\\n            \\n        }\\n        return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2314642,
                "title": "easy-to-understand-and-optimized-java-binary-search-solution",
                "content": "The search space will be from 0 to N(size of array)\\nWe will get mid first. \\nWe will get count by checking number of elements are greater than equal to mid.\\nIf mid is equal to count return mid \\nelse mid is less than count go for higher values\\nelse mid is greater than count go for smaller values\\n```\\nclass Solution {\\n    int getCount(int arr[], int x){\\n        int count = 0;\\n        for(int i = 0; i<arr.length; i++){\\n            if(arr[i]>=x) count++;\\n        }\\n        return count;\\n    }\\n    public int specialArray(int[] nums) {\\n        int start = 0;\\n        int end = nums.length;\\n        while(start <= end){\\n            int mid = start + (end -  start)/2;\\n            int count = getCount(nums, mid);\\n            if(count == mid){\\n                return mid;\\n            }\\n            else if(count > mid){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid -1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int getCount(int arr[], int x){\\n        int count = 0;\\n        for(int i = 0; i<arr.length; i++){\\n            if(arr[i]>=x) count++;\\n        }\\n        return count;\\n    }\\n    public int specialArray(int[] nums) {\\n        int start = 0;\\n        int end = nums.length;\\n        while(start <= end){\\n            int mid = start + (end -  start)/2;\\n            int count = getCount(nums, mid);\\n            if(count == mid){\\n                return mid;\\n            }\\n            else if(count > mid){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid -1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305656,
                "title": "easy-to-understand-c-code",
                "content": "int specialArray(vector<int>& nums) \\n    {\\n        int l=0,h=*max_element(nums.begin(),nums.end()),res=-1 ;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2,count=0 ;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n               if(nums[i]>=mid) \\n                   count++ ;\\n            }\\n            if(count>=mid)\\n                l=mid+1 ;\\n                \\n            else \\n                h=mid-1 ;\\n            \\n            if(count==mid)\\n                res=mid ;\\n            \\n        }\\n        return res ;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "int specialArray(vector<int>& nums) \\n    {\\n        int l=0,h=*max_element(nums.begin(),nums.end()),res=-1 ;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2,count=0 ;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n               if(nums[i]>=mid) \\n                   count++ ;\\n            }\\n            if(count>=mid)\\n                l=mid+1 ;\\n                \\n            else \\n                h=mid-1 ;\\n            \\n            if(count==mid)\\n                res=mid ;\\n            \\n        }\\n        return res ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2296910,
                "title": "python-o-n-solution-counting-faster-than-80",
                "content": "Since the output would not be greater than` len(nums)`, so we can cut the numbers greater than ` len(nums)` to be ` len(nums)`, and count them as \"The time numbers euqal or greater than ` len(nums)` appear\"\\n\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        dic = collections.defaultdict(int)\\n        for num in nums:\\n                dic[min(num, len(nums))] += 1\\n        count = 0\\n        for i in range(len(nums), 0, -1):\\n            if i in dic:\\n                count += dic[i]\\n            if count == i:\\n                return i\\n        return -1\\n```\\n\\neg1. \\n`nums = [3,6,7,7,0] `\\n-> `dic = {3: 1, 5: 3, 0: 1}` (Three numbers greater than len(nums)\\n-> Run a for loop from i = 5 -> 1:\\n-->when `i = 5` -> 3 numbers greater or equal than 5 -> `3 < 5` -> continue\\n-->when `i = 4` -> 3 numbers greater or equal than 4 -> `3 < 4` -> continue\\n-->when `i = 3` -> 3 + 1 numbers greater or equal than 3 -> `4 > 3` -> stop and return `-1`\\n\\neg2. \\n`nums = [4,6,7,7,0] `\\n-> `dic = {4: 1, 5: 3, 0: 1}` (Three numbers greater than len(nums)\\n-> Run a for loop from i = 5 -> 1:\\n-->when `i = 5` -> 3 numbers greater or equal than 5 -> `3 < 5` -> continue\\n-->when `i = 4` -> 3 + 1 numbers greater or equal than 4 -> `4 = 4` -> stop and return `4`\\n\\n\\nSimilar Question\\n274. H-Index : https://leetcode.com/problems/h-index/",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        dic = collections.defaultdict(int)\\n        for num in nums:\\n                dic[min(num, len(nums))] += 1\\n        count = 0\\n        for i in range(len(nums), 0, -1):\\n            if i in dic:\\n                count += dic[i]\\n            if count == i:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223828,
                "title": "python-solution-optimized-brute-force-nlog-n-n-2",
                "content": "```\\n#the brute-force solution, checking each element with each other untill find our ans\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        for i in range(0, len(nums)+1):\\n            x = 0\\n            for j in nums:\\n\\n                if j >= i:\\n                    x += 1\\n            if x == i:\\n                return i\\n        return -1\\n```\\n\\n```\\n#this one is more optimized one! used binary search..\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        low = 0\\n        high= len(nums) - 1\\n        mid = 0\\n        while low <= high:\\n            mid = (high+low)//2\\n            ans = (len(nums)) - mid\\n            if nums[mid] >= ans:\\n                if mid == 0 or nums[mid-1] < ans:\\n                    return ans\\n                else:\\n                    high = mid -1\\n            else:\\n                low = mid+1\\n        return -1        \\n```\\n\\n#fun-fact is that, for this special case! i dont know why but, the brute-force solution runs faster than the optimal one.. is it even optimal ? upvote and comment!! AND TRY BOTH..",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n#the brute-force solution, checking each element with each other untill find our ans\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        for i in range(0, len(nums)+1):\\n            x = 0\\n            for j in nums:\\n\\n                if j >= i:\\n                    x += 1\\n            if x == i:\\n                return i\\n        return -1\\n```\n```\\n#this one is more optimized one! used binary search..\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        nums.sort()\\n        low = 0\\n        high= len(nums) - 1\\n        mid = 0\\n        while low <= high:\\n            mid = (high+low)//2\\n            ans = (len(nums)) - mid\\n            if nums[mid] >= ans:\\n                if mid == 0 or nums[mid-1] < ans:\\n                    return ans\\n                else:\\n                    high = mid -1\\n            else:\\n                low = mid+1\\n        return -1        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221650,
                "title": "100-c-easy-understandable-binary-search",
                "content": "class Solution {\\npublic:\\n    int specialArray(vector<int>& v) {\\n        \\n        sort(v.begin(),v.end());\\n        int l=0,r=v.size();\\n        while(l<=r){\\n            int mid =l+(r-l)/2;\\n            int c=0;\\n            for(auto it:v){\\n                if(it>=mid)c++;\\n            }\\n            \\n           if(mid==c)return mid ;\\n            else if(mid<c)\\n                l= mid+1;\\n            else\\n                    r=mid-1;\\n            \\n            \\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int specialArray(vector<int>& v) {\\n        \\n        sort(v.begin(),v.end());\\n        int l=0,r=v.size();\\n        while(l<=r){\\n            int mid =l+(r-l)/2;\\n            int c=0;\\n            for(auto it:v){\\n                if(it>=mid)c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2194015,
                "title": "c-00-faster-most-easiest",
                "content": "class Solution {\\npublic:\\n    int findspecial(vector<int> &nums,int mid)\\n    {\\n      int cnt=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i]>=mid) cnt++;\\n            }\\n        return cnt;\\n    }\\n    int specialArray(vector<int>& nums) {\\n        \\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            maxi=max(maxi,nums[i]);\\n        }\\n        if(maxi==0) return -1;\\n        int start=1;\\n        int end=maxi;\\n        int ans=-1;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(findspecial(nums,mid)==mid)\\n            {\\n                ans=mid;\\n                break;\\n            }\\n            else if(findspecial(nums,mid)<mid)\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};![image](https://assets.leetcode.com/users/images/2f7a6739-6856-460c-8d63-0295ffc48ae6_1656138343.5403702.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    int findspecial(vector<int> &nums,int mid)\\n    {\\n      int cnt=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i]>=mid) cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2166014,
                "title": "java-with-binary-search",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int left = 0;\\n        int right = nums.length;\\n        int answer = -1;\\n        \\n        while(left <= right) {\\n            int mid = left + (right-left)/2;\\n            int counter = 0;\\n            for (int j = 0; j<nums.length; j++) {\\n                if (nums[j] >= mid) {\\n                    counter ++;\\n                }\\n            }\\n            if (mid == counter) {\\n                answer = mid;\\n                left = mid + 1;\\n            } else if (mid > counter) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int left = 0;\\n        int right = nums.length;\\n        int answer = -1;\\n        \\n        while(left <= right) {\\n            int mid = left + (right-left)/2;\\n            int counter = 0;\\n            for (int j = 0; j<nums.length; j++) {\\n                if (nums[j] >= mid) {\\n                    counter ++;\\n                }\\n            }\\n            if (mid == counter) {\\n                answer = mid;\\n                left = mid + 1;\\n            } else if (mid > counter) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162756,
                "title": "java-easy-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int n = nums.length;\\n        int ans = -1;\\n        \\n        for(int i=1; i<=n; i++){\\n            int count = 0;\\n            for(int j=0; j<n; j++){\\n                if(nums[j] >= i){\\n                    count++;\\n                }\\n            }\\n            if(count == i){\\n                return count;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int specialArray(int[] nums) {\\n        int n = nums.length;\\n        int ans = -1;\\n        \\n        for(int i=1; i<=n; i++){\\n            int count = 0;\\n            for(int j=0; j<n; j++){\\n                if(nums[j] >= i){\\n                    count++;\\n                }\\n            }\\n            if(count == i){\\n                return count;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150785,
                "title": "c-sol",
                "content": "int specialArray(vector<int>& nums) {\\n       sort(nums.begin(), nums.end());\\n        \\n        int c=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i] >= count + 1){\\n                c++;\\n            }\\n            else if(nums[i] == c)\\n                return -1;\\n        }\\n        return c;\\n    }",
                "solutionTags": [],
                "code": "int specialArray(vector<int>& nums) {\\n       sort(nums.begin(), nums.end());\\n        \\n        int c=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i] >= count + 1){\\n                c++;\\n            }\\n            else if(nums[i] == c)\\n                return -1;\\n        }\\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2139846,
                "title": "java-o-n-logn",
                "content": "```\\nclass Solution {      \\n     public int specialArray(int[] nums) {\\n         Arrays.sort(nums);\\n         for(int i = 0, len = nums.length; i < len; i++) {\\n             int x = len - i;                          \\n             if(nums[i] >= x && (i == 0 || nums[i - 1] < x)) return x;             \\n         }\\n         return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {      \\n     public int specialArray(int[] nums) {\\n         Arrays.sort(nums);\\n         for(int i = 0, len = nums.length; i < len; i++) {\\n             int x = len - i;                          \\n             if(nums[i] >= x && (i == 0 || nums[i - 1] < x)) return x;             \\n         }\\n         return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130295,
                "title": "nlogn-very-fast-java-solution",
                "content": "```\\nclass Solution {\\n    int searchInsert(int[] nums, int n, int target){\\n        int min=0,max=n-1,mid=0;\\n        while(max>=min){\\n            mid=(max+min)/2;\\n            if(nums[mid]>target)\\n                max=mid-1;\\n            else if(nums[mid]<target)\\n                min=mid+1;\\n            else return mid;\\n        }\\n        if(target<nums[mid])\\n            return mid;\\n        return mid+1;\\n    }\\n    \\n    public int specialArray(int[] nums) {\\n        int i,n=nums.length,in;\\n        Arrays.sort(nums);\\n        //System.out.println(Arrays.toString(nums));\\n        for(i=0;i<=n;i++){\\n            in=searchInsert(nums,n,i);\\n            while(in<n && in>0 && nums[in-1]==nums[in])\\n                in--;\\n            if(i==(n-in))\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int searchInsert(int[] nums, int n, int target){\\n        int min=0,max=n-1,mid=0;\\n        while(max>=min){\\n            mid=(max+min)/2;\\n            if(nums[mid]>target)\\n                max=mid-1;\\n            else if(nums[mid]<target)\\n                min=mid+1;\\n            else return mid;\\n        }\\n        if(target<nums[mid])\\n            return mid;\\n        return mid+1;\\n    }\\n    \\n    public int specialArray(int[] nums) {\\n        int i,n=nums.length,in;\\n        Arrays.sort(nums);\\n        //System.out.println(Arrays.toString(nums));\\n        for(i=0;i<=n;i++){\\n            in=searchInsert(nums,n,i);\\n            while(in<n && in>0 && nums[in-1]==nums[in])\\n                in--;\\n            if(i==(n-in))\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128747,
                "title": "javascript-sort-and-binary-search",
                "content": "```\\nvar specialArray = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let n = nums.length;\\n    let i = 0, j = n-1;\\n    \\n    while (i < j) {\\n        let mid = Math.floor((i+j)/2);\\n        \\n        if (nums[mid] < n-mid) {\\n            i = mid+1;\\n        }\\n        else {\\n            j = mid;\\n        }\\n    }\\n    \\n    return ((i == 0 && n <= nums[i]) || (nums[i-1] < n-i && n-i <= nums[i])) ? n-i : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar specialArray = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let n = nums.length;\\n    let i = 0, j = n-1;\\n    \\n    while (i < j) {\\n        let mid = Math.floor((i+j)/2);\\n        \\n        if (nums[mid] < n-mid) {\\n            i = mid+1;\\n        }\\n        else {\\n            j = mid;\\n        }\\n    }\\n    \\n    return ((i == 0 && n <= nums[i]) || (nums[i-1] < n-i && n-i <= nums[i])) ? n-i : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127095,
                "title": "c-solution-o-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int count=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i] >= count + 1){\\n                count++;\\n            }\\n            else if(nums[i] == count)\\n                return -1;\\n        }\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int count=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i] >= count + 1){\\n                count++;\\n            }\\n            else if(nums[i] == count)\\n                return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115262,
                "title": "c-solution-binary-search",
                "content": "```\\nclass Solution {\\n     int helper(vector<int>& nums,int val){\\n        int count=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]>=val){\\n                ++count;\\n            }\\n        }\\n        return count;\\n    }\\npublic:\\n    int specialArray(vector<int>& nums) {\\n     //   sort(nums.begin(),nums.end()); // 0 0 3 4 4   3 5 \\n        int low=0;\\n        int high=1000;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            int greaternum=helper(nums,mid);\\n            if(mid==greaternum)return greaternum;\\n            else if(greaternum>mid)low=mid+1;\\n            else high=mid-1;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n     int helper(vector<int>& nums,int val){\\n        int count=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]>=val){\\n                ++count;\\n            }\\n        }\\n        return count;\\n    }\\npublic:\\n    int specialArray(vector<int>& nums) {\\n     //   sort(nums.begin(),nums.end()); // 0 0 3 4 4   3 5 \\n        int low=0;\\n        int high=1000;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            int greaternum=helper(nums,mid);\\n            if(mid==greaternum)return greaternum;\\n            else if(greaternum>mid)low=mid+1;\\n            else high=mid-1;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099426,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int specialArray(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int n=nums.length;\\n    while(n>0)\\n      {\\n          int low=0;\\n          int high=nums.length-1;\\n          int mid=low + (high-low)/2;\\n          int index=-1; \\n          while(low<=high)\\n          {\\n              mid=low + (high-low)/2;\\n               if(nums[mid]<n)\\n              {\\n                  low=mid +1;\\n              }\\n              else\\n              {\\n                 index=mid;\\n                 high=mid-1;\\n              }\\n          }\\n          if((nums.length-index)==n)\\n          {\\n              return n;\\n          }\\n       n--;       \\n      }\\n        return -1;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int specialArray(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int n=nums.length;\\n    while(n>0)\\n      {\\n          int low=0;\\n          int high=nums.length-1;\\n          int mid=low + (high-low)/2;\\n          int index=-1; \\n          while(low<=high)\\n          {\\n              mid=low + (high-low)/2;\\n               if(nums[mid]<n)\\n              {\\n                  low=mid +1;\\n              }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1795742,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1725664,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1714459,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1790413,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1576236,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1988624,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 2063455,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 2044585,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 2042663,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1966385,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1795742,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1725664,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1714459,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1790413,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1576236,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1988624,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 2063455,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 2044585,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 2042663,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            },
            {
                "id": 1966385,
                "content": [
                    {
                        "username": "nalpaktre",
                        "content": "I literally don\\'t understand the question. What are we looking for?\\n"
                    },
                    {
                        "username": "shin_98",
                        "content": "Assume you have an array [2,3,8,9,11,12] na you want to check if there is a number X such that X numbers in given array are greater than or equal to that number X.\\n\\nLet\\'s say we choose X = 1. Every number in given array is greater than 1. There are six numbers in that array, so 1 != 6. Therfore X can\\'t be 1.\\nLet\\'s say X = 2. Again, every number in array above is grater than or equal 2. There are 6 numbers in that array so 2 != 6. Therfore X can\\'t be 2.\\nNow take X = 3. First number in array (2) is smaller than 3. So there are 5 numbers greater than or equal 3. 3 != 5, so X can\\'t be 3.\\nAnd lastly, take X = 4. There are six elements in given array. 2 and 3 are smaller than 4. So there are only four elements (8,9,11,12) in array that are greater than or equal 4. We\\'ve got a winner. There are 4 numbers that are bigger than or equal 4. 4 = 4, so X can be 4. Ans. X = 4. Hope it helps"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 100\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^5 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "startupveteran",
                        "content": "It\\'s an \"Easy\" for a reason, bro. I thought the difficulty level was appropriate."
                    },
                    {
                        "username": "Marat-Gasanyan",
                        "content": "Please can someone tells me why in this case we expected -1?\\nMy solution gave answer 3 and I suppose the answer correct. My be I misunderstood problem ))\\nnums = [3,6,7,7,0]\\noutput = 3\\nexpected = -1 \\nThank you in advance. "
                    },
                    {
                        "username": "bng5",
                        "content": "In that case there are 4 numbers greater or equal than 3.\\n\\nYou must return a value `x` such that there are `x` amount of numbers greater than or equal to `x`.\\n\\nFor example:\\n * There are *4* numbers greater than or equal to *4*\\n * There are *7* numbers greater than or equal to *7*"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "bro actually it should be grater than equal to n but here their are 4 elements which is grater than equal to 3 \\nso ans is -1 okay"
                    },
                    {
                        "username": "nishant7372",
                        "content": "For given constraints - Brute Force and BinarySearch+Sort/CountingSort solutions all are giving 1ms runtime. \n\nBut, with Binary Search + Linear Search (to find count of elements>=mid), 0ms runtime can be achieved."
                    },
                    {
                        "username": "theCuriousCoder",
                        "content": "+1 the post for upvote, -1 for downvote"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "This description is not sufficient. "
                    },
                    {
                        "username": "srijadhar",
                        "content": "What will be the optimised time complexity? O(nlogn) or can it be more optimised?\\n"
                    },
                    {
                        "username": "hanzla07",
                        "content": "Please help me in this testcase :\\n\\n[3,9,7,8,3,8,6,6]\\nOutput\\n-1\\nExpected\\n6"
                    },
                    {
                        "username": "Dedicate1999",
                        "content": "The question should be tagged medieum level this is not an easy level problem"
                    },
                    {
                        "username": "shubham-31",
                        "content": "nums = [3,6,7,7,0]\\nOutput = 3\\nExpected = -1\\nplease anyone can explain this ??"
                    },
                    {
                        "username": "LynxSumit",
                        "content": "look the problem here is there are 4 numbers which are greater than 3 so according to description they both must be equal then only this array called as special array so in this case this array is not special hence return -1"
                    }
                ]
            }
        ]
    },
    {
        "title": "Unique Length-3 Palindromic Subsequences",
        "question_content": "<p>Given a string <code>s</code>, return <em>the number of <strong>unique palindromes of length three</strong> that are a <strong>subsequence</strong> of </em><code>s</code>.</p>\n\n<p>Note that even if there are multiple ways to obtain the same subsequence, it is still only counted <strong>once</strong>.</p>\n\n<p>A <strong>palindrome</strong> is a string that reads the same forwards and backwards.</p>\n\n<p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p>\n\n<ul>\n\t<li>For example, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aabca&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The 3 palindromic subsequences of length 3 are:\n- &quot;aba&quot; (subsequence of &quot;<u>a</u>a<u>b</u>c<u>a</u>&quot;)\n- &quot;aaa&quot; (subsequence of &quot;<u>aa</u>bc<u>a</u>&quot;)\n- &quot;aca&quot; (subsequence of &quot;<u>a</u>ab<u>ca</u>&quot;)\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;adc&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no palindromic subsequences of length 3 in &quot;adc&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbcbaba&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The 4 palindromic subsequences of length 3 are:\n- &quot;bbb&quot; (subsequence of &quot;<u>bb</u>c<u>b</u>aba&quot;)\n- &quot;bcb&quot; (subsequence of &quot;<u>b</u>b<u>cb</u>aba&quot;)\n- &quot;bab&quot; (subsequence of &quot;<u>b</u>bcb<u>ab</u>a&quot;)\n- &quot;aba&quot; (subsequence of &quot;bbcb<u>aba</u>&quot;)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1330165,
                "title": "leftmost-rightmost-and-in-between",
                "content": "I initially over-thought this problem, but it\\'s quite straightforward. We track the first and last occurence of each character.\\n\\nThen, for each character, we count unique characters between its first and last occurence. That is the number of palindromes with that character in the first and last positions.\\n\\nExample: `abcbba`, we have two unique chars between first and last `a` (`c` and `b`), and two - between first and last `b` (`b` and `c`). No characters in between `c` so it forms no palindromes.\\n\\n**C++**\\n```cpp\\nint countPalindromicSubsequence(string s) {\\n    int first[26] = {[0 ... 25] = INT_MAX}, last[26] = {}, res = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        first[s[i] - \\'a\\'] = min(first[s[i] - \\'a\\'], i);\\n        last[s[i] - \\'a\\'] = i;\\n    }\\n    for (int i = 0; i < 26; ++i)\\n        if (first[i] < last[i])\\n            res += unordered_set<char>(begin(s) + first[i] + 1, begin(s) + last[i]).size();\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int countPalindromicSubsequence(String s) {\\n    int first[] = new int[26], last[] = new int[26], res = 0;\\n    Arrays.fill(first, Integer.MAX_VALUE);\\n    for (int i = 0; i < s.length(); ++i) {\\n        first[s.charAt(i) - \\'a\\'] = Math.min(first[s.charAt(i) - \\'a\\'], i);\\n        last[s.charAt(i) - \\'a\\'] = i;\\n    }\\n    for (int i = 0; i < 26; ++i)\\n        if (first[i] < last[i])\\n            res += s.substring(first[i] + 1, last[i]).chars().distinct().count();\\n    return res;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n). We go though the string fixed number of times.\\n- Memory: O(1)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint countPalindromicSubsequence(string s) {\\n    int first[26] = {[0 ... 25] = INT_MAX}, last[26] = {}, res = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        first[s[i] - \\'a\\'] = min(first[s[i] - \\'a\\'], i);\\n        last[s[i] - \\'a\\'] = i;\\n    }\\n    for (int i = 0; i < 26; ++i)\\n        if (first[i] < last[i])\\n            res += unordered_set<char>(begin(s) + first[i] + 1, begin(s) + last[i]).size();\\n    return res;\\n}\\n```\n```java\\npublic int countPalindromicSubsequence(String s) {\\n    int first[] = new int[26], last[] = new int[26], res = 0;\\n    Arrays.fill(first, Integer.MAX_VALUE);\\n    for (int i = 0; i < s.length(); ++i) {\\n        first[s.charAt(i) - \\'a\\'] = Math.min(first[s.charAt(i) - \\'a\\'], i);\\n        last[s.charAt(i) - \\'a\\'] = i;\\n    }\\n    for (int i = 0; i < 26; ++i)\\n        if (first[i] < last[i])\\n            res += s.substring(first[i] + 1, last[i]).chars().distinct().count();\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330178,
                "title": "python-straight-forward-solution",
                "content": "# **Explanation**\\nFor each palindromes in format of \"aba\",\\nwe enumerate the character on two side.\\n\\nWe find its first occurrence and its last occurrence,\\nall the characters in the middle are the candidate for the midd char.\\n<br>\\n\\n# **Complexity**\\nTime `O(26n)`\\nSpace `O(26n)`\\n<br>\\n\\n**Python**\\n```py\\n    def countPalindromicSubsequence(self, s):\\n        res = 0\\n        for c in string.ascii_lowercase:\\n            i, j = s.find(c), s.rfind(c)\\n            if i > -1:\\n                res += len(set(s[i + 1: j]))\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def countPalindromicSubsequence(self, s):\\n        res = 0\\n        for c in string.ascii_lowercase:\\n            i, j = s.find(c), s.rfind(c)\\n            if i > -1:\\n                res += len(set(s[i + 1: j]))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1330166,
                "title": "very-intuitive-solution-in-c-o-26-n-with-explanation",
                "content": "**You just need to calculate unique elements between first occurrence of the alphabet(char) and last occurrence of the alphabet(char).**\\n\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        vector<pair<int, int> > v(26, {-1, -1} ); //to store first occurance  and last occurance of every alphabet.\\n        \\n        int n = s.length(); //size of the string\\n        \\n        for (int i = 0 ; i< n ;i++ ){\\n            if (v[s[i] - \\'a\\'].first == -1 ) v[s[i] - \\'a\\'].first = i; // storing when alphabet appered first time.\\n            else v[s[i] - \\'a\\'].second = i; // else whenever it appears again. So that the last occurrence will be stored at last.\\n        }\\n        \\n        int ans = 0 ;\\n        for (int i = 0 ; i <26 ;i++ ){ //traversing over all alphabets.\\n\\n            if (v[i].second != -1 ){ //only if alphabet occured second time.\\n                \\n                unordered_set<char> st; //using set to keep only unique elements between the range.\\n                \\n                for (int x = v[i].first + 1 ; x < v[i].second ; x++ ) st.insert(s[x]); // set keeps only unique elemets.\\n                    \\n                ans += ((int)st.size()); // adding number of unique elements to the answer.\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        vector<pair<int, int> > v(26, {-1, -1} ); //to store first occurance  and last occurance of every alphabet.\\n        \\n        int n = s.length(); //size of the string\\n        \\n        for (int i = 0 ; i< n ;i++ ){\\n            if (v[s[i] - \\'a\\'].first == -1 ) v[s[i] - \\'a\\'].first = i; // storing when alphabet appered first time.\\n            else v[s[i] - \\'a\\'].second = i; // else whenever it appears again. So that the last occurrence will be stored at last.\\n        }\\n        \\n        int ans = 0 ;\\n        for (int i = 0 ; i <26 ;i++ ){ //traversing over all alphabets.\\n\\n            if (v[i].second != -1 ){ //only if alphabet occured second time.\\n                \\n                unordered_set<char> st; //using set to keep only unique elements between the range.\\n                \\n                for (int x = v[i].first + 1 ; x < v[i].second ; x++ ) st.insert(s[x]); // set keeps only unique elemets.\\n                    \\n                ans += ((int)st.size()); // adding number of unique elements to the answer.\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330187,
                "title": "java-o-26-n-solution-with-explanation",
                "content": "**Basic Idea**\\nSince we need to make a palindrome of length three(3), we can guarantee that the first and last character will be equal. ( e.g - \"aba\" )\\nWe can fix first and last character and now we only need to find the middle character.\\n\\n**Approach**\\nCalculate the first and last occurrence of every character. Now all we have to do is check how many unique characters are there between them.\\n\\n**Example**\\ns = \"aabca\"\\nFor character \\'a\\',\\nfirstOcc = 0, lastOcc = 4\\nUnique characters between 0 and 4 are three(3) (a, b, c)\\nHence, the palindromes starting with \\'a\\' will be\\n\"aaa\", \"aba\", \"aca\"\\n\\nRepeat this for every character.\\n\\n**Note : We will check each character only once.**\\n\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        \\n        int n = s.length();\\n        \\n        char[] chArr = s.toCharArray();\\n        \\n        int[] firstOcc = new int[26];\\n        int[] lastOcc = new int[26];\\n        \\n        Arrays.fill(firstOcc, -1);\\n        Arrays.fill(lastOcc, -1);\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            char ch = chArr[i];\\n            \\n            if(firstOcc[ch - \\'a\\'] == -1){\\n                firstOcc[ch - \\'a\\'] = i;\\n            }\\n            \\n            lastOcc[ch - \\'a\\'] = i;\\n        }\\n        \\n        int ans = 0, count = 0;\\n        \\n        boolean[] visited;\\n        \\n\\t\\t// check for each character ( start or end of palindrome )\\n        for(int i = 0; i < 26; i++){\\n            \\n            int si = firstOcc[i]; // si - starting index\\n            int ei = lastOcc[i]; // ei - ending index\\n            \\n            visited = new boolean[26];\\n            \\n            count = 0;\\n            \\n\\t\\t\\t// check for unique charcters ( middle of palindrome )\\n            for(int j = si + 1; j < ei; j++){\\n                \\n                if(!visited[chArr[j] - \\'a\\']){\\n                    visited[chArr[j] - \\'a\\'] = true;\\n                    count++;\\n                }\\n            }\\n            \\n            ans += count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n**Time Complexity** - O(26 * n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        \\n        int n = s.length();\\n        \\n        char[] chArr = s.toCharArray();\\n        \\n        int[] firstOcc = new int[26];\\n        int[] lastOcc = new int[26];\\n        \\n        Arrays.fill(firstOcc, -1);\\n        Arrays.fill(lastOcc, -1);\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            char ch = chArr[i];\\n            \\n            if(firstOcc[ch - \\'a\\'] == -1){\\n                firstOcc[ch - \\'a\\'] = i;\\n            }\\n            \\n            lastOcc[ch - \\'a\\'] = i;\\n        }\\n        \\n        int ans = 0, count = 0;\\n        \\n        boolean[] visited;\\n        \\n\\t\\t// check for each character ( start or end of palindrome )\\n        for(int i = 0; i < 26; i++){\\n            \\n            int si = firstOcc[i]; // si - starting index\\n            int ei = lastOcc[i]; // ei - ending index\\n            \\n            visited = new boolean[26];\\n            \\n            count = 0;\\n            \\n\\t\\t\\t// check for unique charcters ( middle of palindrome )\\n            for(int j = si + 1; j < ei; j++){\\n                \\n                if(!visited[chArr[j] - \\'a\\']){\\n                    visited[chArr[j] - \\'a\\'] = true;\\n                    count++;\\n                }\\n            }\\n            \\n            ans += count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330186,
                "title": "easy-python-solution",
                "content": "1. basicsally first stores all elements with indices \\n2. now for elment having twice occurence of more using the first and last occurnces and getting how many distinct chaaracters are therir in betweemn this way u can form palindrom\\n**if u like the way i solved do upvote it gives  A Lot of motivation**\\n```py\\nclass Solution(object):\\n    def countPalindromicSubsequence(self, s):\\n        d=defaultdict(list)\\n        for i,c in enumerate(s):\\n            d[c].append(i)\\n        ans=0\\n        for el in d:\\n            if len(d[el])<2:\\n                continue\\n            a=d[el][0]\\n            b=d[el][-1]\\n            ans+=len(set(s[a+1:b]))\\n        return(ans)\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "1. basicsally first stores all elements with indices \\n2. now for elment having twice occurence of more using the first and last occurnces and getting how many distinct chaaracters are therir in betweemn this way u can form palindrom\\n**if u like the way i solved do upvote it gives  A Lot of motivation**\\n```py\\nclass Solution(object):\\n    def countPalindromicSubsequence(self, s):\\n        d=defaultdict(list)\\n        for i,c in enumerate(s):\\n            d[c].append(i)\\n        ans=0\\n        for el in d:\\n            if len(d[el])<2:\\n                continue\\n            a=d[el][0]\\n            b=d[el][-1]\\n            ans+=len(set(s[a+1:b]))\\n        return(ans)\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1330203,
                "title": "simple-and-easy-to-understand-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        int n = s.length(), ans = 0;\\n        \\n        vector <int> f(26,0);\\n        \\n        for (int i = 0; i < n; i++) // Frequency Calculation for each Lower-Case Letter\\n            f[s[i]-\\'a\\']++;\\n        \\n        // Only possibility of subsequence is XYX, where Y can be X.\\n        \\n        for (int i = 0; i < 26; i++){\\n            \\n            if (f[i] <= 1)// This character cannot be at the STARTING and the END ( cannot be X in XYX )\\n                continue;\\n            \\n            int first=-1, last=-1; // First occurence and Last occurence of character counter\\n            \\n            for(int j=0;j<n;j++){  // First occurence of character i\\n                if((s[j]-\\'a\\')==i){\\n                    first=j; break;\\n                }\\n            }\\n            \\n            for(int j=n-1;j>=0;j--){ // Last occurence of character i\\n                if((s[j]-\\'a\\')==i){\\n                    last=j; break;\\n                }\\n            }\\n            \\n            unordered_set<int> st; // To count the number of unique characters between the first occurence and last occurence\\n            \\n            for(int k=first+1;k<last;k++)\\n                st.insert((s[k]-\\'a\\'));\\n            // Number of unique characters = Number of Palindromic Subsequences possible with this charcter at the STARTING and the END\\n            ans+=st.size(); \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Upvote if it helps and ask something you don\\'t understand :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        int n = s.length(), ans = 0;\\n        \\n        vector <int> f(26,0);\\n        \\n        for (int i = 0; i < n; i++) // Frequency Calculation for each Lower-Case Letter\\n            f[s[i]-\\'a\\']++;\\n        \\n        // Only possibility of subsequence is XYX, where Y can be X.\\n        \\n        for (int i = 0; i < 26; i++){\\n            \\n            if (f[i] <= 1)// This character cannot be at the STARTING and the END ( cannot be X in XYX )\\n                continue;\\n            \\n            int first=-1, last=-1; // First occurence and Last occurence of character counter\\n            \\n            for(int j=0;j<n;j++){  // First occurence of character i\\n                if((s[j]-\\'a\\')==i){\\n                    first=j; break;\\n                }\\n            }\\n            \\n            for(int j=n-1;j>=0;j--){ // Last occurence of character i\\n                if((s[j]-\\'a\\')==i){\\n                    last=j; break;\\n                }\\n            }\\n            \\n            unordered_set<int> st; // To count the number of unique characters between the first occurence and last occurence\\n            \\n            for(int k=first+1;k<last;k++)\\n                st.insert((s[k]-\\'a\\'));\\n            // Number of unique characters = Number of Palindromic Subsequences possible with this charcter at the STARTING and the END\\n            ans+=st.size(); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330340,
                "title": "python-solution-faster-than-200-ms",
                "content": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        if len(s) < 3:\\n            return 0\\n\\n        elif len(s) == 3:\\n            return 1 if s[0]==s[2] else 0\\n                \\n        else:\\n            num_of_palindromes = 0\\n            unique = list(set(s))\\n            for char in unique:\\n                count = s.count(char)\\n                if count > 1:\\n                    # find first and last index of char in s\\n                    a_index = s.index(char)\\n                    c_index = s.rindex(char)\\n                    # find num of unique chars between the two indeces \\n                    between = s[a_index+1:c_index]\\n                    num_of_palindromes += len(list(set(between)))\\n                \\n            return num_of_palindromes\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        if len(s) < 3:\\n            return 0\\n\\n        elif len(s) == 3:\\n            return 1 if s[0]==s[2] else 0\\n                \\n        else:\\n            num_of_palindromes = 0\\n            unique = list(set(s))\\n            for char in unique:\\n                count = s.count(char)\\n                if count > 1:\\n                    # find first and last index of char in s\\n                    a_index = s.index(char)\\n                    c_index = s.rindex(char)\\n                    # find num of unique chars between the two indeces \\n                    between = s[a_index+1:c_index]\\n                    num_of_palindromes += len(list(set(between)))\\n                \\n            return num_of_palindromes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330251,
                "title": "c-generate-all-palindrome-with-length-3-o-n",
                "content": "Since there are only 26 * 26 * 1 distinct palindromes with length 3, we can iterate through all of the palindromes and check if the palindrome is a subsequence of the given string.\\nO(26 * 26 * N) -> O(N)\\n```\\nbool sub(const string& pattern, const string& text) {\\n    int i, j;\\n    for(i = 0, j = 0; i < text.size() && j < 3; ++i) {\\n        if(text[i] == pattern[j])\\n            ++j;\\n    }\\n    return j == 3;\\n}\\n\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0;\\n        for(char a = \\'a\\'; a <= \\'z\\'; ++a) {\\n            for(char b = \\'a\\'; b <= \\'z\\'; ++b) {\\n                string str;\\n                str += a;\\n                str += b;\\n                str += a;\\n                ans += sub(str, s);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nWe can also reduce the constant by checking subsequence using indices. Using greedy, we find the first and last index that palindrome[0] appear in the given string, and check if there are any index of palindrome[1] is in between. This can be done using binary search.\\nO(N * log(N))\\n```\\nset<int> pos[26];\\n\\nbool sub(string text, string pattern) {\\n    if(pos[pattern[0] - \\'a\\'].size() >= 2 && pos[pattern[1] - \\'a\\'].size()) {\\n        int f = *pos[pattern[0] - \\'a\\'].begin(), e = *pos[pattern[0] - \\'a\\'].rbegin();\\n        auto it = pos[pattern[1] - \\'a\\'].lower_bound(f);\\n        if(it == pos[pattern[1] - \\'a\\'].end())\\n            return 0;\\n        return *it < e;\\n    } else\\n        return 0;\\n}\\n\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        for(int i = 0; i < 26; ++i)\\n            pos[i].clear();\\n        for(int i = 0; i < s.size(); ++i)\\n            pos[s[i] - \\'a\\'].insert(i);\\n        int ans = 0;\\n        for(char a = \\'a\\'; a <= \\'z\\'; ++a) {\\n            for(char b = \\'a\\'; b <= \\'z\\'; ++b) {\\n                if(b == a)\\n                    continue;\\n                string str;\\n                str += a;\\n                str += b;\\n                str += a;\\n                ans += sub(s, str);\\n            }\\n        }\\n        for(char a = \\'a\\'; a <= \\'z\\'; ++a)\\n            ans += pos[a - \\'a\\'].size() >= 3;\\n        return ans;\\n    }\\n};\\n```\\nPlease consider upvote if it helps ^^",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nbool sub(const string& pattern, const string& text) {\\n    int i, j;\\n    for(i = 0, j = 0; i < text.size() && j < 3; ++i) {\\n        if(text[i] == pattern[j])\\n            ++j;\\n    }\\n    return j == 3;\\n}\\n\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0;\\n        for(char a = \\'a\\'; a <= \\'z\\'; ++a) {\\n            for(char b = \\'a\\'; b <= \\'z\\'; ++b) {\\n                string str;\\n                str += a;\\n                str += b;\\n                str += a;\\n                ans += sub(str, s);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nset<int> pos[26];\\n\\nbool sub(string text, string pattern) {\\n    if(pos[pattern[0] - \\'a\\'].size() >= 2 && pos[pattern[1] - \\'a\\'].size()) {\\n        int f = *pos[pattern[0] - \\'a\\'].begin(), e = *pos[pattern[0] - \\'a\\'].rbegin();\\n        auto it = pos[pattern[1] - \\'a\\'].lower_bound(f);\\n        if(it == pos[pattern[1] - \\'a\\'].end())\\n            return 0;\\n        return *it < e;\\n    } else\\n        return 0;\\n}\\n\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        for(int i = 0; i < 26; ++i)\\n            pos[i].clear();\\n        for(int i = 0; i < s.size(); ++i)\\n            pos[s[i] - \\'a\\'].insert(i);\\n        int ans = 0;\\n        for(char a = \\'a\\'; a <= \\'z\\'; ++a) {\\n            for(char b = \\'a\\'; b <= \\'z\\'; ++b) {\\n                if(b == a)\\n                    continue;\\n                string str;\\n                str += a;\\n                str += b;\\n                str += a;\\n                ans += sub(s, str);\\n            }\\n        }\\n        for(char a = \\'a\\'; a <= \\'z\\'; ++a)\\n            ans += pos[a - \\'a\\'].size() >= 3;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132933,
                "title": "c-using-map-and-set-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**HINT**: For length 3 palindromes first and last character should be same so find  no. of distinct characters b/w first and last occurence of a character and that will be the  number of distinct  3 size palindromes b/w that type character in the given string so do this for all the presnt characters in the string we will get all the 3 sized palindromes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo first we should find first and last occurences of each character in the string then for each character find how many distinct characters  lie b/w its first and last occurence . \\nCan be done using two arrays in which we store first and last occutence as indexes and for checking distinct characters we use a set and just add the set\\'s size in our answer that will be 3 sized palindromes between that particular characters first and last occurence.\\n# Complexity\\n- Time complexity:$$O(26*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n    \\n        int  n=s.size();\\n        vector<int>f(26,1000001),last(26);\\n        for(int i=0;i<n;i++){\\n            f[s[i]-\\'a\\']=min(i,f[s[i]-\\'a\\']);\\n            last[s[i]-\\'a\\']=i;\\n        }\\n      int  ans=0;\\n      for(int i=0;i<26;i++){\\n           unordered_set<char>st;\\n\\n        for(int j=f[i]+1;j<last[i];j++){\\n            st.insert(s[j]);\\n        } \\n        ans+=st.size();\\n  }\\n      return ans;\\n\\n    }\\n};\\n```\\n**Just One line**\\n```\\n int countPalindromicSubsequence(string s) {\\n    \\n        int  n=s.size();\\n        vector<int>f(26,1000001),last(26);\\n        for(int i=0;i<n;i++){\\n            f[s[i]-\\'a\\']=min(i,f[s[i]-\\'a\\']);\\n            last[s[i]-\\'a\\']=i;\\n        }\\n      int  ans=0;\\n      for(int i=0;i<26;i++){\\n          if(f[i]<last[i])\\n          ans+=unordered_set(begin(s)+f[i]+1,begin(s)+last[i]).size();\\n      }\\n      return ans;\\n\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n    \\n        int  n=s.size();\\n        vector<int>f(26,1000001),last(26);\\n        for(int i=0;i<n;i++){\\n            f[s[i]-\\'a\\']=min(i,f[s[i]-\\'a\\']);\\n            last[s[i]-\\'a\\']=i;\\n        }\\n      int  ans=0;\\n      for(int i=0;i<26;i++){\\n           unordered_set<char>st;\\n\\n        for(int j=f[i]+1;j<last[i];j++){\\n            st.insert(s[j]);\\n        } \\n        ans+=st.size();\\n  }\\n      return ans;\\n\\n    }\\n};\\n```\n```\\n int countPalindromicSubsequence(string s) {\\n    \\n        int  n=s.size();\\n        vector<int>f(26,1000001),last(26);\\n        for(int i=0;i<n;i++){\\n            f[s[i]-\\'a\\']=min(i,f[s[i]-\\'a\\']);\\n            last[s[i]-\\'a\\']=i;\\n        }\\n      int  ans=0;\\n      for(int i=0;i<26;i++){\\n          if(f[i]<last[i])\\n          ans+=unordered_set(begin(s)+f[i]+1,begin(s)+last[i]).size();\\n      }\\n      return ans;\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330309,
                "title": "java-17-lines-code-easy-to-understand-string-built-in-functions",
                "content": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int count = 0;\\n        for(int i = 0; i < 26; i++) {\\n            char ch = (char) (i + \\'a\\');\\n            int start = s.indexOf(ch);\\n            int last = s.lastIndexOf(ch);\\n            if (last == -1) continue;\\n            Set<Character> uniqChars = new HashSet<>();\\n            for(int j = start + 1; j < last; j++) {\\n                uniqChars.add(s.charAt(j));\\n            }\\n            count += uniqChars.size();\\n        }        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int count = 0;\\n        for(int i = 0; i < 26; i++) {\\n            char ch = (char) (i + \\'a\\');\\n            int start = s.indexOf(ch);\\n            int last = s.lastIndexOf(ch);\\n            if (last == -1) continue;\\n            Set<Character> uniqChars = new HashSet<>();\\n            for(int j = start + 1; j < last; j++) {\\n                uniqChars.add(s.charAt(j));\\n            }\\n            count += uniqChars.size();\\n        }        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375163,
                "title": "c-simple-and-clean-short-and-easy-solution",
                "content": "Save the first and last accurance of each character, and all the chars inbetween will form length-3 palindromes.\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<pair<int, int>> v(26, {-1, -1});\\n        for (int i = 0; i < s.size(); i++) {\\n            if (v[s[i] - \\'a\\'].first == -1) v[s[i] - \\'a\\'].first = i;\\n            else v[s[i] - \\'a\\'].second = i;\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (v[i].second != -1) {\\n                unordered_set<char> tmp;\\n                for (int j = v[i].first + 1; j < v[i].second; j++) tmp.insert(s[j]);\\n                res += tmp.size();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<pair<int, int>> v(26, {-1, -1});\\n        for (int i = 0; i < s.size(); i++) {\\n            if (v[s[i] - \\'a\\'].first == -1) v[s[i] - \\'a\\'].first = i;\\n            else v[s[i] - \\'a\\'].second = i;\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (v[i].second != -1) {\\n                unordered_set<char> tmp;\\n                for (int j = v[i].first + 1; j < v[i].second; j++) tmp.insert(s[j]);\\n                res += tmp.size();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345937,
                "title": "c-simple-as-you-like",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        unordered_map<char,vector<int>> um;\\n        //store all occurances of a giver character\\n        for(int i=0;i<s.size();i++)\\n            um[s[i]].push_back(i);\\n        int ans=0;\\n        for( auto &p : um){\\n            auto v=p.second;\\n            set<char> us;\\n            //first and last caharcter have to be equal\\n            //then answer using this char as endpoints is\\n            //no of distinct characters between first and last occurance \\n            if(v.size()>=2){\\n                for(int j=v[0]+1;j<v.back();j++)\\n                    us.insert(s[j]);\\n                ans+=us.size();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        unordered_map<char,vector<int>> um;\\n        //store all occurances of a giver character\\n        for(int i=0;i<s.size();i++)\\n            um[s[i]].push_back(i);\\n        int ans=0;\\n        for( auto &p : um){\\n            auto v=p.second;\\n            set<char> us;\\n            //first and last caharcter have to be equal\\n            //then answer using this char as endpoints is\\n            //no of distinct characters between first and last occurance \\n            if(v.size()>=2){\\n                for(int j=v[0]+1;j<v.back();j++)\\n                    us.insert(s[j]);\\n                ans+=us.size();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331480,
                "title": "simple-easy-100-faster-well-explained-6-lines-of-code",
                "content": "## Idea :\\n**Since we have to find palindromic number of length 3. \\nThen first and last index of that three letter word should be same for the palindromic condition.\\nBetween character can be all the unique charater present between that both index.**\\n\\n\\uD83D\\uDC49 find the index (from starting and ending both) of each unique character in the string.\\n\\uD83D\\uDC49 Then if starting index < ending index of that charactrer. \\n\\uD83D\\uDC49 Add the number of unique characters present between them.\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res = 0\\n        unq_str = set(s)\\n        for ch in unq_str:\\n            st = s.find(ch)\\n            ed = s.rfind(ch)\\n            if st<ed:\\n                res+=len(set(s[st+1:ed]))\\n        \\n        return res\\n\\nFeel free to ask if any doubt. \\uD83E\\uDD1E\\nif you got any help then please **Upvote !!** \\u270C \\n**Thank You**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## Idea :\\n**Since we have to find palindromic number of length 3. \\nThen first and last index of that three letter word should be same for the palindromic condition.\\nBetween character can be all the unique charater present between that both index.**\\n\\n\\uD83D\\uDC49 find the index (from starting and ending both) of each unique character in the string.\\n\\uD83D\\uDC49 Then if starting index < ending index of that charactrer. \\n\\uD83D\\uDC49 Add the number of unique characters present between them.\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res = 0\\n        unq_str = set(s)\\n        for ch in unq_str:\\n            st = s.find(ch)\\n            ed = s.rfind(ch)\\n            if st<ed:\\n                res+=len(set(s[st+1:ed]))\\n        \\n        return res\\n\\nFeel free to ask if any doubt. \\uD83E\\uDD1E\\nif you got any help then please **Upvote !!** \\u270C \\n**Thank You**",
                "codeTag": "Java"
            },
            {
                "id": 1330271,
                "title": "c-o-n-solution-with-explanation-check-for-occurences",
                "content": "Explanation:\\n1.Store the occurences of each alphabet in a vector O(n)\\n2.For each alphabet say alpha1, iterate over 26 alphabets to get a possible palindrome like alpha1 -alpha2-alpha1. \\n3.For all the combinations, find if some index of alpha2 lies between the first and the last index of alpha1 using lower_bound(O(logn))\\n\\nOverall Time complexity = O(n)+ 26 * 26 * log(n)\\n\\n```class Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans=0;\\n        vector < vector < int > >location(26);\\n        for( int i = 0 ; i < s.length() ; i +=1)\\n        {\\n\\t\\t\\t\\t\\tlocation[s[i]-\\'a\\'].push_back(i);  //storing indices of ith character\\n        }\\n        for (  int  i = 0 ;  i <  26  ;  i + = 1 )                  //choosing alpha1\\n        {\\n            if(  int( location[i].size() ) > 1)        // alpha1 occurs should atleast be 2 to form (alpha1-alpha2-alpha1) \\n            {\\n                for( int j = 0 ; j < 26 ; j + = 1)                      //Choosing alpha2\\n                {\\n                    int x=upper_bound(location[j].begin(),location[j].end(),location[i][0])-location[j].begin();\\n\\t\\t\\t\\t\\t//location[ j ][ x ] is the first index, after the first location of alpha1, where alpha2 is found\\n\\t\\t\\t\\t\\t\\n                    if( ( x ! = location[j].size() ) && location[j][x] < location[i].back() )      //x is less than the last occurence of alpha1\\n\\t\\t\\t\\t\\t\\t\\tans+=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans=0;\\n        vector < vector < int > >location(26);\\n        for( int i = 0 ; i < s.length() ; i +=1)\\n        {\\n\\t\\t\\t\\t\\tlocation[s[i]-\\'a\\'].push_back(i);  //storing indices of ith character\\n        }\\n        for (  int  i = 0 ;  i <  26  ;  i + = 1 )                  //choosing alpha1\\n        {\\n            if(  int( location[i].size() ) > 1)        // alpha1 occurs should atleast be 2 to form (alpha1-alpha2-alpha1) \\n            {\\n                for( int j = 0 ; j < 26 ; j + = 1)                      //Choosing alpha2\\n                {\\n                    int x=upper_bound(location[j].begin(),location[j].end(),location[i][0])-location[j].begin();\\n\\t\\t\\t\\t\\t//location[ j ][ x ] is the first index, after the first location of alpha1, where alpha2 is found\\n\\t\\t\\t\\t\\t\\n                    if( ( x ! = location[j].size() ) && location[j][x] < location[i].back() )      //x is less than the last occurence of alpha1\\n\\t\\t\\t\\t\\t\\t\\tans+=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598419,
                "title": "python3-4-lines-counter-w-explanation-t-m-96-80",
                "content": "```\\nclass Solution:             # Here\\'s the plan:\\n                            #   1) Construct a counter to determine the set of letters that\\n                            #      appear at least twice in s.\\n                            #   2) For each double, determine its first (l) and last (r)\\n                            #      occurrence in s.\\n                            #   3) Construct the set of distinct letters between l and r.\\n                            #      Each will account for a palindrome\\n                            \\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        \\n        c, ans = Counter(s), 0                             # <-- 1)\\n        doubles = {ch for ch in c if c[ch] > 1}\\n\\n        for ch in doubles:                              \\n            ans+= len(set(s[s.find(ch)+1:s.rfind(ch)]))    # <-- 2) and 3)\\n\\n        return ans\\n```\\t\\t\\n\\t\\t\\n[https://leetcode.com/submissions/detail/803828323/](http://)\\t\\n\\nAnd, you could do it with a one-liner (if you must):\\n\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        return sum(len(set(s[s.find(ch)+1:s.rfind(ch)]))for ch in {ch for ch, n in Counter(s).items() if n > 1})\\n\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:             # Here\\'s the plan:\\n                            #   1) Construct a counter to determine the set of letters that\\n                            #      appear at least twice in s.\\n                            #   2) For each double, determine its first (l) and last (r)\\n                            #      occurrence in s.\\n                            #   3) Construct the set of distinct letters between l and r.\\n                            #      Each will account for a palindrome\\n                            \\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        \\n        c, ans = Counter(s), 0                             # <-- 1)\\n        doubles = {ch for ch in c if c[ch] > 1}\\n\\n        for ch in doubles:                              \\n            ans+= len(set(s[s.find(ch)+1:s.rfind(ch)]))    # <-- 2) and 3)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494003,
                "title": "c-beginner-idea-explained-easy-to-understand-hashtable",
                "content": "# ***Idea***\\nAt first this problem looks like of a dp kind of problem but is a simple hashtable problem\\nWhat we will do is store char => (first_occurence_index , last_occurence_index) in a map\\n\\n* Main step : For a particualar char : number of unique chars between first and last occurence of that char is the number of 3-length palindromes formed by that char!!!\\n    \\nwe have to do above step for all chars to obtain result!!!\\n    \\n* For example: abcdea\\n=> contribution of a = 4 [number of unique chars between 0 and 5 is 4]\\n=> contribution of b = 0 [because it occur single time]\\n=> contribution of c = 0 [because it occur single time]\\n=> contribution of d = 0 [because it occur single time]\\n=> contribution of e = 0 [because it occur single time]\\n        res = 4\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        unordered_map<char,pair<int,int>> map; // map char to (left , right)\\n        int res = 0;\\n        \\n        for(int i = 0 ; i < s.size() ; ++i)\\n        {\\n            if(map.find(s[i]) == map.end())\\n                map[s[i]] = make_pair(i , -1); \\n            else\\n                map[s[i]].second = i;\\n        }\\n        for(auto p : map)\\n        {\\n            auto pair = p.second;\\n            if(pair.second != -1) // means current char occured 2 or more times\\n            {\\n                int left = pair.first , right = pair.second;\\n                unordered_set<int> uniques;\\n                for(int i = left + 1 ; i < right ; ++i)\\n                    uniques.insert(s[i]);\\n                res += uniques.size();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n# ***If you liked the Solution , Give it an Upvote :)***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        unordered_map<char,pair<int,int>> map; // map char to (left , right)\\n        int res = 0;\\n        \\n        for(int i = 0 ; i < s.size() ; ++i)\\n        {\\n            if(map.find(s[i]) == map.end())\\n                map[s[i]] = make_pair(i , -1); \\n            else\\n                map[s[i]].second = i;\\n        }\\n        for(auto p : map)\\n        {\\n            auto pair = p.second;\\n            if(pair.second != -1) // means current char occured 2 or more times\\n            {\\n                int left = pair.first , right = pair.second;\\n                unordered_set<int> uniques;\\n                for(int i = left + 1 ; i < right ; ++i)\\n                    uniques.insert(s[i]);\\n                res += uniques.size();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331255,
                "title": "unique-characters-between-first-index-last-index",
                "content": "# **********Take two arrays of 26 length to store the index of characters in string. Now left \\n# ******array will have the first index of character and right array will have last index of character . Now traverse in both arrays from  0 and  if right[i]>left[i] (i.e we have more than 1 count of that character) cnt+=unique characters  between right index and left index.   \\n\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int[] left = new int[26]; // this array will keep the first index of a character\\n        int[] right = new int[26];  // this array will keep the last index of a character\\n        int n = s.length();\\n        Arrays.fill(left, Integer.MAX_VALUE);  // to compare and get leftmost index\\n        for(int i=0;i<n;i++){\\n            char ch = s.charAt(i);\\n            left[ch-\\'a\\'] = Math.min(left[ch-\\'a\\'],i);  // update only when there is minimum\\n            right[ch-\\'a\\']=i;   // update everytime you see character\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            if(right[i]>left[i]){\\n                cnt+=s.substring(left[i]+1,right[i]).chars().distinct().count();  //+=cnt of distinct characters between left and right characters\\n            }\\n        }\\n        return cnt;\\n    }\\n## }**\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int[] left = new int[26]; // this array will keep the first index of a character\\n        int[] right = new int[26];  // this array will keep the last index of a character\\n        int n = s.length();\\n        Arrays.fill(left, Integer.MAX_VALUE);  // to compare and get leftmost index\\n        for(int i=0;i<n;i++){\\n            char ch = s.charAt(i);\\n            left[ch-\\'a\\'] = Math.min(left[ch-\\'a\\'],i);  // update only when there is minimum\\n            right[ch-\\'a\\']=i;   // update everytime you see character\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            if(right[i]>left[i]){\\n                cnt+=s.substring(left[i]+1,right[i]).chars().distinct().count();  //+=cnt of distinct characters between left and right characters\\n            }\\n        }\\n        return cnt;\\n    }\\n## }**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330266,
                "title": "easy-c-solution-using-unordered-map",
                "content": "class Solution {\\npublic:\\n\\n    int countPalindromicSubsequence(string s) {\\n        int ans=0;\\n\\t\\t// um will count for every charecter what are the starting and ending index\\n        unordered_map<int,pair<int,int>> um;\\n        for(int i=0;i<s.size();i++){\\n            if(um.find(s[i])==um.end()){\\n                um[s[i]]={i,i};\\n            }\\n            else{\\n                um[s[i]].second=i;\\n            }\\n        }\\n\\t\\t// if diff between starting and ending index is greater than equal to 2, we\\'ll find the number of unique elements between these two possition\\n        for(auto x:um){\\n            if(x.second.second-x.second.first >= 2){\\n                int i=x.second.second;\\n                int j=x.second.first;\\n                unordered_map<int,int> dp;\\n                for(int k=j+1;k<i;k++){\\n                    if(dp.find(s[k])==dp.end()){\\n                        dp[s[k]]++;\\n                    }\\n                }\\n                ans+=dp.size();\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countPalindromicSubsequence(string s) {\\n        int ans=0;\\n\\t\\t// um will count for every charecter what are the starting and ending index\\n        unordered_map<int,pair<int,int>> um;\\n        for(int i=0;i<s.size();i++){\\n            if(um.find(s[i])==um.end()){\\n                um[s[i]]={i,i}",
                "codeTag": "Java"
            },
            {
                "id": 1330213,
                "title": "c-o-26-n-c",
                "content": "The idea behind this is  :\\nFind the first and last index of each lower case letter present in the string s.\\nTry to find number of unique characters between the indices obtained for each character and increment the counter accordingly.\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        vector<pair<int,int>>indexes(26,{-1,-1});\\n        \\n        int i=0;\\n        \\n        while(s[i]){\\n            \\n            if(indexes[s[i]-\\'a\\'].first==-1){\\n                indexes[s[i]-\\'a\\']={i,i};\\n            }\\n            else{\\n                indexes[s[i]-\\'a\\'].second=i;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        int count=0;\\n        int ind=0;\\n        for(auto ele:indexes){\\n            \\n            int start=ele.first;\\n            int end=ele.second;\\n            \\n            set<char>sArr;\\n            start++;\\n            \\n            while(start<end){\\n                sArr.insert(s[start]);\\n                start++;\\n            }\\n            \\n            count+=sArr.size();\\n        }\\n        \\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        vector<pair<int,int>>indexes(26,{-1,-1});\\n        \\n        int i=0;\\n        \\n        while(s[i]){\\n            \\n            if(indexes[s[i]-\\'a\\'].first==-1){\\n                indexes[s[i]-\\'a\\']={i,i};\\n            }\\n            else{\\n                indexes[s[i]-\\'a\\'].second=i;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        int count=0;\\n        int ind=0;\\n        for(auto ele:indexes){\\n            \\n            int start=ele.first;\\n            int end=ele.second;\\n            \\n            set<char>sArr;\\n            start++;\\n            \\n            while(start<end){\\n                sArr.insert(s[start]);\\n                start++;\\n            }\\n            \\n            count+=sArr.size();\\n        }\\n        \\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217322,
                "title": "easiest-c-solution-simple-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        unordered_map<char,int>mp;\\n        \\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        unordered_map<char,int>m=mp;\\n        unordered_set<string>st;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]--;\\n            if(mp[s[i]]==0){m.erase(s[i]);continue;}\\n            m=mp;\\n            for(int j=i+1;j<s.length();j++){\\n              \\n                m[s[j]]--;\\n                \\n                if(m[s[i]]>0){\\n                    string t=\"\";\\n                    t+=s[i];\\n                    t+=s[j];\\n                    t+=s[i];\\n                    \\n                    st.insert(t);\\n                }\\n                if(s[i]==s[j]){break;}\\n            }\\n           \\n        }\\n        \\n       \\n        return st.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        unordered_map<char,int>mp;\\n        \\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        unordered_map<char,int>m=mp;\\n        unordered_set<string>st;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]--;\\n            if(mp[s[i]]==0){m.erase(s[i]);continue;}\\n            m=mp;\\n            for(int j=i+1;j<s.length();j++){\\n              \\n                m[s[j]]--;\\n                \\n                if(m[s[i]]>0){\\n                    string t=\"\";\\n                    t+=s[i];\\n                    t+=s[j];\\n                    t+=s[i];\\n                    \\n                    st.insert(t);\\n                }\\n                if(s[i]==s[j]){break;}\\n            }\\n           \\n        }\\n        \\n       \\n        return st.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392214,
                "title": "why-is-everyone-upvoting-o-26-n-time-when-there-exists-a-pure-o-n-solution-c",
                "content": "The solution below is O(N + 26 * 26  * log(N)) < O(26 * N) time which I would consider a big difference.\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n = s.size();\\n        vector <int> a[26];\\n        for (int i = 0; i < n; i++) \\n            a[s[i] - \\'a\\'].push_back(i); \\n        int ret = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (a[i].size() > 1) {\\n                for (int j = 0; j < 26; j++) {\\n                    int k = lower_bound(a[j].begin(), \\n                        a[j].end(), a[i].front() + 1) - a[j].begin();\\n                    if (k != a[j].size() && a[j][k] < a[i].back())\\n                        ret++;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\nThe solution above does have a downside of using more memory. It uses O(N) extra space, which is a lot compared to the solution below, that everyone likes so much, that uses O(26) extra space, but has O(26 * N) time:\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n = s.size();\\n        vector <int> l(26, n), r(26, 0);\\n        for (int i = 0; i < n; i++) { \\n            r[s[i] - \\'a\\'] = i;\\n            l[s[n - i - 1] - \\'a\\'] = n - i - 1;\\n        }\\n        int ret = 0;\\n        vector <int> cnt(26, 0);\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) cnt[j] = 0;\\n            for (int j = l[i] + 1; j < r[i]; j++) \\n                if (cnt[s[j] - \\'a\\']++ == 0)\\n                    ret++;\\n        }\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n = s.size();\\n        vector <int> a[26];\\n        for (int i = 0; i < n; i++) \\n            a[s[i] - \\'a\\'].push_back(i); \\n        int ret = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (a[i].size() > 1) {\\n                for (int j = 0; j < 26; j++) {\\n                    int k = lower_bound(a[j].begin(), \\n                        a[j].end(), a[i].front() + 1) - a[j].begin();\\n                    if (k != a[j].size() && a[j][k] < a[i].back())\\n                        ret++;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n = s.size();\\n        vector <int> l(26, n), r(26, 0);\\n        for (int i = 0; i < n; i++) { \\n            r[s[i] - \\'a\\'] = i;\\n            l[s[n - i - 1] - \\'a\\'] = n - i - 1;\\n        }\\n        int ret = 0;\\n        vector <int> cnt(26, 0);\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) cnt[j] = 0;\\n            for (int j = l[i] + 1; j < r[i]; j++) \\n                if (cnt[s[j] - \\'a\\']++ == 0)\\n                    ret++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342491,
                "title": "python-one-liner-faster-than-98-59",
                "content": "For each unique character in given string S,\\n* \\tFind leftmost index of its occurrence\\n* \\tFind rigthmost index of its occurrence\\n* \\tSince the problem asks to find triple length palindromes, we can assume first and third char should be same. Hence each **unique** character that lies between these two indices leftmost and rightmost will results in an unique palindrome of length three...\\n\\n\\n```\\nclass Solution(object):\\n    def countPalindromicSubsequence(self, s):\\n        return sum(map(lambda i: len(set(s[s.index(i)+1:s.rindex(i)])), set(s)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPalindromicSubsequence(self, s):\\n        return sum(map(lambda i: len(set(s[s.index(i)+1:s.rindex(i)])), set(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333313,
                "title": "javascript-solution",
                "content": "```\\nvar countPalindromicSubsequence = function(s) {\\n    //Keeps track of the initial starting index of each unique character from the input string\\n    var l={}\\n\\t//Keeps track of the last index of each unique character from the input string\\n    var r={}\\n\\t//Counter for unique length-3 palindrome\\n    var res=0\\n\\t//Stores unique length-3 palindrome and checks for duplicates\\n    var marked= new Set();\\n    for (let i=0; i<s.length; i++){\\n        if (l[s[i]]==undefined)l[s[i]]=i\\n        r[s[i]]=i\\n    }\\n    \\n    for (let key in l){\\n\\t/*\\n\\t\\t   Since in a length 3 palindrome string, our first and last character must be the same,\\n\\t\\t   so we will need the first and last index of each unique character that occurs in the input string.\\n\\t\\t   \\n\\t       For each unique character found in the input, or \\'key\\' in this case, loop from the (firstOccurringIndex,lastOccurringIndex) of the character \\n\\t\\t   and check for unique middle character.\\n\\t\\t   \\n\\t\\t   so if we have \\'aabbbccda\\', and our current \\'key\\' is the letter \\'a\\',\\n\\t\\t   we will loop from the starting index (0) all the way to the last index (8) of \\'a\\' \\n\\t\\t   (excluding both starting and ending index, since we will be checking for middle\\n\\t\\t   character and form a length 3 palindrome with (key+middleCharacter+key))\\n\\t\\t   \\n\\t\\t   So if key is currently the letter \\'a\\', the loop below will check for:\\n\\t\\t   \\'aaa\\',  \\'aba\\', \\'aba\\', \\'aba\\', \\'aca\\', \\'aca\\', \\'ada\\'.  Here there are 4 unique palindromes.\\n\\t\\t   \\n\\t\\t   We move to the next key, \\'b\\', so we check:\\n\\t\\t   \\'bbb\\' (note that there is only one middle character between the first and last index of \\'b\\'). Here there is one unique palindrome.\\n\\t\\t   \\n\\t\\t   Then we will check the remaining unique keys, \\'c\\' and \\'d\\' following the same process as above. \\n\\t\\t   There is no middle character for these two keys so we do not have a unique length 3 palindrome. \\n\\t\\t   \\n\\t\\t   Therefore, the solution to the input string \\'aabbbccda\\' will be 4+1+0+0 = 5.\\n\\t\\t   \\n\\t*/\\n        for (let i=l[key]+1; i<r[key]; i++){\\n          if (!marked.has(key+s[i]+key)){\\n              marked.add(key+s[i]+key);\\n              res++;\\n          }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPalindromicSubsequence = function(s) {\\n    //Keeps track of the initial starting index of each unique character from the input string\\n    var l={}\\n\\t//Keeps track of the last index of each unique character from the input string\\n    var r={}\\n\\t//Counter for unique length-3 palindrome\\n    var res=0\\n\\t//Stores unique length-3 palindrome and checks for duplicates\\n    var marked= new Set();\\n    for (let i=0; i<s.length; i++){\\n        if (l[s[i]]==undefined)l[s[i]]=i\\n        r[s[i]]=i\\n    }\\n    \\n    for (let key in l){\\n\\t/*\\n\\t\\t   Since in a length 3 palindrome string, our first and last character must be the same,\\n\\t\\t   so we will need the first and last index of each unique character that occurs in the input string.\\n\\t\\t   \\n\\t       For each unique character found in the input, or \\'key\\' in this case, loop from the (firstOccurringIndex,lastOccurringIndex) of the character \\n\\t\\t   and check for unique middle character.\\n\\t\\t   \\n\\t\\t   so if we have \\'aabbbccda\\', and our current \\'key\\' is the letter \\'a\\',\\n\\t\\t   we will loop from the starting index (0) all the way to the last index (8) of \\'a\\' \\n\\t\\t   (excluding both starting and ending index, since we will be checking for middle\\n\\t\\t   character and form a length 3 palindrome with (key+middleCharacter+key))\\n\\t\\t   \\n\\t\\t   So if key is currently the letter \\'a\\', the loop below will check for:\\n\\t\\t   \\'aaa\\',  \\'aba\\', \\'aba\\', \\'aba\\', \\'aca\\', \\'aca\\', \\'ada\\'.  Here there are 4 unique palindromes.\\n\\t\\t   \\n\\t\\t   We move to the next key, \\'b\\', so we check:\\n\\t\\t   \\'bbb\\' (note that there is only one middle character between the first and last index of \\'b\\'). Here there is one unique palindrome.\\n\\t\\t   \\n\\t\\t   Then we will check the remaining unique keys, \\'c\\' and \\'d\\' following the same process as above. \\n\\t\\t   There is no middle character for these two keys so we do not have a unique length 3 palindrome. \\n\\t\\t   \\n\\t\\t   Therefore, the solution to the input string \\'aabbbccda\\' will be 4+1+0+0 = 5.\\n\\t\\t   \\n\\t*/\\n        for (let i=l[key]+1; i<r[key]; i++){\\n          if (!marked.has(key+s[i]+key)){\\n              marked.add(key+s[i]+key);\\n              res++;\\n          }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330314,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        \\n        ctr = 0\\n        \\n        for i in range(97,123):\\n        \\n            first = s.find(chr(i))\\n            \\n            if first != -1:\\n                last = s.rfind(chr(i))\\n                ctr += len(set(s[first+1:last])) # count of unique characters between first and last character\\n    \\n        return ctr\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        \\n        ctr = 0\\n        \\n        for i in range(97,123):\\n        \\n            first = s.find(chr(i))\\n            \\n            if first != -1:\\n                last = s.rfind(chr(i))\\n                ctr += len(set(s[first+1:last])) # count of unique characters between first and last character\\n    \\n        return ctr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330164,
                "title": "python-o-26n-easy-understand-with-comments",
                "content": "```\\nclass Solution(object):\\n    def countPalindromicSubsequence(self, s):\\n        n = len(s)\\n        ans = 0\\n        # loop through all 26 character Time: O(1)\\n        for i in range(26):\\n            \\n            # Two pointer find the same charactor with the longest distance Time: O(N)\\n            start = 0\\n            end = n-1\\n            while (ord(s[start]) - ord(\\'a\\') != i) and start < n-1:\\n                start += 1\\n            while (ord(s[end]) - ord(\\'a\\') != i) and end > 0:\\n                end -= 1\\n            \\n            # if out-bounded change to next charactor\\n            if start == n-1 or end == 0:\\n                continue\\n            \\n            # find how many different alphabets in this string. Time: O(N)\\n            alpha = collections.Counter(s[start+1:end])\\n            # add to answer\\n            ans += len(alpha.keys())\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPalindromicSubsequence(self, s):\\n        n = len(s)\\n        ans = 0\\n        # loop through all 26 character Time: O(1)\\n        for i in range(26):\\n            \\n            # Two pointer find the same charactor with the longest distance Time: O(N)\\n            start = 0\\n            end = n-1\\n            while (ord(s[start]) - ord(\\'a\\') != i) and start < n-1:\\n                start += 1\\n            while (ord(s[end]) - ord(\\'a\\') != i) and end > 0:\\n                end -= 1\\n            \\n            # if out-bounded change to next charactor\\n            if start == n-1 or end == 0:\\n                continue\\n            \\n            # find how many different alphabets in this string. Time: O(N)\\n            alpha = collections.Counter(s[start+1:end])\\n            # add to answer\\n            ans += len(alpha.keys())\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330150,
                "title": "o-26n-time-and-simple-solution-with-comments-clean-java-code",
                "content": "High Level Idea: mimic the prefixSum & suffixSum\\n\\nwe just consider about the middle char in out Length-3 Palindromic Subsequences \\n\\nFor every current middle char, which belongs to [1, s.length() - 1].\\n\\nint[] left: record the number of lowercase English letters which is located in the leftside of current middle char.\\nint[] right: record the number of lowercase English letters which is located in the rightside of current middle char.\\n\\nOne reasonable Length-3 Palindromic Subsequences:\\n    as for the current middle index char      -- O(n)\\n        we need to traverse 26 lowwercase english letters in both left and right array.   --O(26)\\n            if both side has this lowwercase english letter, it means that we find one reasonable solution.\\n\\nAnd we use set to avoid the repeat solution.\\n\\nTime: O(26n)\\nSpace: O(the number of unique palindromes of length three that are a subsequence of s).\\n```\\npublic int countPalindromicSubsequence(String s) {\\n        int[] left = new int[26];\\n        int[] right = new int[26];\\n        left[s.charAt(0) - \\'a\\']++;\\n        right[s.charAt(s.length() - 1) - \\'a\\']++;\\n        Set<String> set = new HashSet<>();\\n        \\n        for (int i = 1; i < s.length() - 1; i++) {  // pre-processing the right side array\\n            right[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for (int i = 1; i < s.length() - 1; i++) {\\n            char c = s.charAt(i);\\n            right[s.charAt(i) - \\'a\\']--;             // remove current char from the right side array\\n            for (int l = 0; l < 26; l++) {\\n                if (left[l] != 0 && right[l] != 0) {\\n                    char cur = (char)(l + \\'a\\');\\n                    set.add(cur + \",\" + c + \",\" + cur);               \\n                }\\n            }\\n            left[s.charAt(i) - \\'a\\']++;              // add current char into the left side array\\n        }\\n        return set.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countPalindromicSubsequence(String s) {\\n        int[] left = new int[26];\\n        int[] right = new int[26];\\n        left[s.charAt(0) - \\'a\\']++;\\n        right[s.charAt(s.length() - 1) - \\'a\\']++;\\n        Set<String> set = new HashSet<>();\\n        \\n        for (int i = 1; i < s.length() - 1; i++) {  // pre-processing the right side array\\n            right[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for (int i = 1; i < s.length() - 1; i++) {\\n            char c = s.charAt(i);\\n            right[s.charAt(i) - \\'a\\']--;             // remove current char from the right side array\\n            for (int l = 0; l < 26; l++) {\\n                if (left[l] != 0 && right[l] != 0) {\\n                    char cur = (char)(l + \\'a\\');\\n                    set.add(cur + \",\" + c + \",\" + cur);               \\n                }\\n            }\\n            left[s.charAt(i) - \\'a\\']++;              // add current char into the left side array\\n        }\\n        return set.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330147,
                "title": "c-easy-to-understand-set-approach-check-occurances-and-count-inbetween",
                "content": "we will check the first and last occured character of each element.\\nand then check for the unique elements in between the occurance of them.\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans=0;\\n//   make a string t of unique and sorted elements of s\\n        string t=s;\\n        sort(t.begin(),t.end());\\n        t.erase(unique(t.begin(),t.end()),t.end());\\n\\t\\t// for every element of t check the first and last occurance and assign as a and b\\n        for(auto tt:t)\\n        {\\n            int a,b;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]==tt)\\n                   { a=i;\\n                     break;\\n                   }\\n            }\\n            for(int i=s.size()-1;i>=0;i--)\\n            {\\n                \\n                if(s[i]==tt)\\n                {\\n                    b=i;\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// create a set and add them the elements between a and b to it\\n            set<char> myset;\\n            if(abs(a-b)<=1)\\n                continue;\\n            for(int i=a+1;i<b;i++)\\n            {\\n                myset.insert(s[i]);\\n            } \\n\\t\\t\\t// keep adding the size of set to ans\\n            ans+=myset.size();\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans=0;\\n//   make a string t of unique and sorted elements of s\\n        string t=s;\\n        sort(t.begin(),t.end());\\n        t.erase(unique(t.begin(),t.end()),t.end());\\n\\t\\t// for every element of t check the first and last occurance and assign as a and b\\n        for(auto tt:t)\\n        {\\n            int a,b;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]==tt)\\n                   { a=i;\\n                     break;\\n                   }\\n            }\\n            for(int i=s.size()-1;i>=0;i--)\\n            {\\n                \\n                if(s[i]==tt)\\n                {\\n                    b=i;\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// create a set and add them the elements between a and b to it\\n            set<char> myset;\\n            if(abs(a-b)<=1)\\n                continue;\\n            for(int i=a+1;i<b;i++)\\n            {\\n                myset.insert(s[i]);\\n            } \\n\\t\\t\\t// keep adding the size of set to ans\\n            ans+=myset.size();\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348088,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n = s.size(), ans = 0;\\n        vector<pair<int, int>> m(26, pair<int, int>({1e9, -1e9}));\\n\\n        for(int i=0; i<n; i++) {\\n            m[s[i] - \\'a\\'].first = min(m[s[i] - \\'a\\'].first, i);\\n            m[s[i] - \\'a\\'].second = max(m[s[i] - \\'a\\'].second, i);\\n        }\\n        \\n        for(auto i : m) {\\n            int l = i.first, r = i.second;\\n            if(l == 1e9) continue;\\n            unordered_set<char> st;\\n            for(int j=l+1; j<r; j++) st.insert(s[j]);\\n            ans += st.size();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n = s.size(), ans = 0;\\n        vector<pair<int, int>> m(26, pair<int, int>({1e9, -1e9}));\\n\\n        for(int i=0; i<n; i++) {\\n            m[s[i] - \\'a\\'].first = min(m[s[i] - \\'a\\'].first, i);\\n            m[s[i] - \\'a\\'].second = max(m[s[i] - \\'a\\'].second, i);\\n        }\\n        \\n        for(auto i : m) {\\n            int l = i.first, r = i.second;\\n            if(l == 1e9) continue;\\n            unordered_set<char> st;\\n            for(int j=l+1; j<r; j++) st.insert(s[j]);\\n            ans += st.size();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315710,
                "title": "c-solution-easy-solution-and-intuitive",
                "content": "The Question is simple in the way as it is only asking to find unique palindromic strings of only length 3\\n                                  ----------\\nSo lets suppose there is a string of length 3\\n\\n___ ___ ___\\n\\nWe know that it is palindromic if first and last letter are same\\n\\n_a__ ____ __a__ \\n\\nNow all we have to do is find the middle letter which can be anything a, b, c, d ,e , , , , but the middle character cannot repeated as we have find unique palindromic strings\\n\\nLets fill up the first and last block by placing the all 26 characters a,b,c,d,e,f,g,h,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z as the first and last letter of the 3 length string\\n\\nAll the remaining work left to do is take the input *string s* and find the first and last index of the letter and if our string does contain only 1 letter or even does not have that letter we will mark it -1 so to know we dont need to process it\\n\\nNow ever thing is prepared and only thing left to do is to traverse thought the string s for each letter from its first index to the last index and find the unique characters between it and then add it to our answer\\n\\nTime complexity is 0(26*n) = O(n)\\n\\n    \\nclass Solution {\\npublic:\\n\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0;\\n        \\n        vector<vector<int>> arr(26,vector<int> (2,-1));\\n\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(arr[s[i] - \\'a\\'][0] == -1) arr[s[i] - \\'a\\'][0] = i;\\n            else arr[s[i] - \\'a\\'][1] = i; \\n        }\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            int freq[26] = {0};\\n\\n            for(int k = arr[i][0]+1; k<arr[i][1]; k++)\\n            {\\n               if(freq[s[k] - \\'a\\'] == 0) ans++;\\n               freq[s[k] - \\'a\\'] = 1;      \\n            }\\n            \\n        }\\n\\n        return ans;\\n\\n        }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0;\\n        \\n        vector<vector<int>> arr(26,vector<int> (2,-1));\\n\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(arr[s[i] - \\'a\\'][0] == -1) arr[s[i] - \\'a\\'][0] = i;\\n            else arr[s[i] - \\'a\\'][1] = i; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1979957,
                "title": "explained-with-graphic",
                "content": "![image](https://assets.leetcode.com/users/images/803a8a0c-7bd2-423d-b3e1-76efe1d52ed6_1650851805.6065621.png)\\n\\n```cpp\\nint countPalindromicSubsequence(string s) {\\n\\tint n = s.size();\\n\\tmap<char, vector<int>> idx;\\n\\tint cnt = 0;\\n\\t\\n\\t// record the index of each char\\n\\tfor (int i = 0; i < n; ++i)\\n\\t\\tidx[s[i]].push_back(i);\\n\\n\\t// for very char that has every appeared in s,\\n\\tfor (auto &h : idx)\\n\\t{\\n\\t\\t// if there the char appears on once, skip it.\\n\\t\\tif (h.second.size() < 2)\\n\\t\\t\\tcontinue;\\n\\t\\t\\n\\t\\t// find how many identical chars are there in between.\\n\\t\\tset<char> ss;\\n\\t\\t\\n\\t\\tfor (int i = h.second.front() + 1; i < h.second.back(); ++i)\\n\\t\\t\\tss.insert(s[i]);\\n\\t\\t\\n\\t\\tcnt += ss.size();\\n\\t}\\n\\t\\n\\treturn cnt;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\nint countPalindromicSubsequence(string s) {\\n\\tint n = s.size();\\n\\tmap<char, vector<int>> idx;\\n\\tint cnt = 0;\\n\\t\\n\\t// record the index of each char\\n\\tfor (int i = 0; i < n; ++i)\\n\\t\\tidx[s[i]].push_back(i);\\n\\n\\t// for very char that has every appeared in s,\\n\\tfor (auto &h : idx)\\n\\t{\\n\\t\\t// if there the char appears on once, skip it.\\n\\t\\tif (h.second.size() < 2)\\n\\t\\t\\tcontinue;\\n\\t\\t\\n\\t\\t// find how many identical chars are there in between.\\n\\t\\tset<char> ss;\\n\\t\\t\\n\\t\\tfor (int i = h.second.front() + 1; i < h.second.back(); ++i)\\n\\t\\t\\tss.insert(s[i]);\\n\\t\\t\\n\\t\\tcnt += ss.size();\\n\\t}\\n\\t\\n\\treturn cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1603022,
                "title": "easy-c-solution-using-vectors-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        vector<int> first(26,-1);\\n        vector<int> last(26,-1);\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(first[s[i]-\\'a\\']==-1)\\n                first[s[i]-\\'a\\']=i;\\n            last[s[i]-\\'a\\']=i;\\n        }\\n        int res=0;\\n        int cnt=0;\\n        //for every character findout the unique characters in between the first and last char \\n        for(int i=0;i<26;i++)\\n        {\\n            if(first[i]==-1)\\n                continue;\\n            cnt=0;\\n            vector<int> freq(26,0);\\n            for(int j=first[i]+1;j<last[i];j++)\\n            {\\n                if(freq[s[j]-\\'a\\']==0)\\n                {\\n                    freq[s[j]-\\'a\\']=1;\\n                    cnt++;\\n                }\\n            }\\n            res+=cnt;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        vector<int> first(26,-1);\\n        vector<int> last(26,-1);\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(first[s[i]-\\'a\\']==-1)\\n                first[s[i]-\\'a\\']=i;\\n            last[s[i]-\\'a\\']=i;\\n        }\\n        int res=0;\\n        int cnt=0;\\n        //for every character findout the unique characters in between the first and last char \\n        for(int i=0;i<26;i++)\\n        {\\n            if(first[i]==-1)\\n                continue;\\n            cnt=0;\\n            vector<int> freq(26,0);\\n            for(int j=first[i]+1;j<last[i];j++)\\n            {\\n                if(freq[s[j]-\\'a\\']==0)\\n                {\\n                    freq[s[j]-\\'a\\']=1;\\n                    cnt++;\\n                }\\n            }\\n            res+=cnt;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346614,
                "title": "python-o-n-26",
                "content": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        indices = {}\\n        for i in range(len(s)):\\n            if s[i] in indices:\\n                indices[s[i]][1] = i\\n            else:\\n                indices[s[i]] = [i, i]\\n        count = 0\\n\\t\\t\\n\\t\\t#indices[char] denotes first and last occurrence of char in the given string \\n\\t\\t\\n        for c in indices:\\n            if indices[c][0] == indices[c][1]:\\n\\t\\t\\t\\t#if the character occurs only once in the given string\\n                pass\\n            else:\\n                tempAdded = set()\\n                for i in range(indices[c][0]+1, indices[c][1], 1):\\n\\t\\t\\t\\t\\t#counts the number of distinct middle character in the three lettered palindrome that could be formed with c at either ends\\n                    tempAdded.add(s[i])\\n                count += len(tempAdded)\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        indices = {}\\n        for i in range(len(s)):\\n            if s[i] in indices:\\n                indices[s[i]][1] = i\\n            else:\\n                indices[s[i]] = [i, i]\\n        count = 0\\n\\t\\t\\n\\t\\t#indices[char] denotes first and last occurrence of char in the given string \\n\\t\\t\\n        for c in indices:\\n            if indices[c][0] == indices[c][1]:\\n\\t\\t\\t\\t#if the character occurs only once in the given string\\n                pass\\n            else:\\n                tempAdded = set()\\n                for i in range(indices[c][0]+1, indices[c][1], 1):\\n\\t\\t\\t\\t\\t#counts the number of distinct middle character in the three lettered palindrome that could be formed with c at either ends\\n                    tempAdded.add(s[i])\\n                count += len(tempAdded)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344128,
                "title": "java-solution-using-set",
                "content": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int res = 0;\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            int start = s.indexOf(c);\\n            int end = s.lastIndexOf(c);\\n            if (start != end) {\\n\\t\\t\\t    Set<Character> set = new HashSet<>();\\n                for (int i = start + 1; i <= end - 1; i++) {\\n                    set.add(s.charAt(i));\\n                }\\n                res += set.size();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int res = 0;\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            int start = s.indexOf(c);\\n            int end = s.lastIndexOf(c);\\n            if (start != end) {\\n\\t\\t\\t    Set<Character> set = new HashSet<>();\\n                for (int i = start + 1; i <= end - 1; i++) {\\n                    set.add(s.charAt(i));\\n                }\\n                res += set.size();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338928,
                "title": "1930-normal-short-1-liner-solutions",
                "content": "---\\n\\nLong solution is from contest. After several tries, got out of TLE :)\\nIf you have `isSubsequence` and `isPalindrome` functions ready, then you are in luck.\\n\\n---\\n\\n**Algo**\\n\\n- **Long solution**\\n  - Do a bruteforce `[a-z]` to `[a-z]` to `[a-z]` combinations\\n    - They will be all unique subsequences possible\\n      - Check if it `subsequence` of `s`\\n      - Check if it is `palindrome`\\n        - If both pass, then increment `count`\\n    - return `count`\\n- **Short solution 1**\\n  - Logic is from **based on contest solution of https://leetcode.com/venkateshwar1996/**\\n  - For each char in alphabets\\n    - Find first char is found in `s`\\n    - Find last char is found in `s`\\n      - If they both are not same\\n      - Find how many unique chars in middle   (`a & b` in `aaba`, and  `z` in `aza`)\\n        - sum them all up\\n  - return sum\\n- **Short solution 2**\\n  - Same as `Short solution 1`, different conditions & implementation\\n- Short solution 3\\n  - Same as `Short solution 2`, different conditions & implementation\\n- 1 line solution\\n  - This is for the `1-liners`\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Long solution**\\n\\n```\\nvar countPalindromicSubsequence = function (s) {\\n    const isPalindrome = (s) => {\\n        let halfN = Math.trunc(s.length / 2);\\n        let n = s.length;\\n        for (let i = 0; i < halfN; i++) {\\n            if (s[i] !== s[n - 1 - i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    };\\n\\n    const isSubsequence = (s, t) => {\\n        if (!s.length) return true;\\n        if (s.length > t.length) return false;\\n\\n        let [m, n, i, j] = [s.length, t.length, 0, 0];\\n        while (i < m && j < n)\\n            if (s[i] === t[j]) i++, j++;\\n            else j++;\\n\\n        return i === m;\\n    };\\n\\n    let small = \"abcdefghijklmnopqrstuvwxyz\";\\n\\n    let count = 0;\\n    for (let ch1 of small) {\\n        for (let ch2 of small) {\\n            for (let ch3 of small) {\\n                const strOf3Chars = ch1 + ch2 + ch3;\\n                if (isPalindrome(strOf3Chars)) {\\n                    if (isSubsequence(strOf3Chars, s)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2c915728-da81-48cb-b8a6-70b0d740ad75_1625981552.4267788.png)\\n\\n---\\n\\n**Short solution 1**\\n\\n```\\nvar countPalindromicSubsequence = function (s) {\\n    return \"abcdefghijklmnopqrstuvwxyz\" //\\n        .split(\"\")\\n        .reduce((count, ch) => {\\n            const i = s.indexOf(ch); //     find index of        ch from left\\n            const j = s.lastIndexOf(ch); // find index of (same) ch from right\\n            if (i < j) {\\n                return count + new Set(s.slice(i + 1, j)).size; // how many unique in middle? add and return\\n            }\\n            return count; // otherwise, return old count\\n        }, 0);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/747e5196-659a-4542-9050-c1e9c5ba0e3c_1625981138.0999262.png)\\n\\n---\\n\\n**Short solution 2**\\n\\n```\\nconst small_alpha_arr = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\\nvar countPalindromicSubsequence = function (s) {\\n    return small_alpha_arr //\\n        .reduce((count, ch) => {\\n            const i = s.indexOf(ch); //     find index of        ch from left\\n            const j = s.lastIndexOf(ch); // find index of (same) ch from right\\n            if (i !== j) {\\n                return count + new Set(s.slice(i + 1, j)).size; // how many unique in middle? add and return\\n            } else {\\n                return count; // otherwise, return old count\\n            }\\n        }, 0);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/57581323-aee0-44c3-b7e3-742a930acbd5_1625981160.765759.png)\\n\\n---\\n\\n**Short solution 3**\\n\\n```\\nconst small_alpha_arr = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\\nvar countPalindromicSubsequence = function (s) {\\n    return small_alpha_arr //\\n        .reduce((count, ch) => {\\n            const i = s.indexOf(ch); //     find index of        ch from left\\n            const j = s.lastIndexOf(ch); // find index of (same) ch from right\\n            return (\\n                count +\\n                (i !== j\\n                    ? new Set(s.slice(i + 1, j)).size // how many unique in middle? add and return\\n                    : 0)\\n            );\\n        }, 0);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a526f655-9234-4175-964d-433f44257322_1625981198.5110543.png)\\n\\n---\\n\\n**Now, we are ready for 1-liner solutions**\\n\\n```\\nvar countPalindromicSubsequence = function (s) {\\n    return \"abcdefghijklmnopqrstuvwxyz\"\\n        .split(\"\")\\n        .reduce(\\n            (count, ch) =>\\n                count +\\n                (s.indexOf(ch) !== s.lastIndexOf(ch)\\n                    ? new Set(s.slice(s.indexOf(ch) + 1, s.lastIndexOf(ch))).size\\n                    : 0),\\n            0\\n        );\\n};\\n```\\n\\nOr, may be\\n\\n```\\nvar countPalindromicSubsequence = function (s) {\\n    return \"abcdefghijklmnopqrstuvwxyz\".split(\"\").reduce((count, ch) => count + (s.indexOf(ch) !== s.lastIndexOf(ch) ? new Set(s.slice(s.indexOf(ch) + 1, s.lastIndexOf(ch))).size : 0), 0);\\n};\\n```\\n\\nOr, may be\\n\\n```\\nvar countPalindromicSubsequence = (s) => \"abcdefghijklmnopqrstuvwxyz\".split(\"\").reduce((count, ch) => count + (s.indexOf(ch) !== s.lastIndexOf(ch) ? new Set(s.slice(s.indexOf(ch) + 1, s.lastIndexOf(ch))).size : 0), 0);\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e931591f-500f-45c0-be02-e85320100129_1625988533.5785885.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPalindromicSubsequence = function (s) {\\n    const isPalindrome = (s) => {\\n        let halfN = Math.trunc(s.length / 2);\\n        let n = s.length;\\n        for (let i = 0; i < halfN; i++) {\\n            if (s[i] !== s[n - 1 - i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    };\\n\\n    const isSubsequence = (s, t) => {\\n        if (!s.length) return true;\\n        if (s.length > t.length) return false;\\n\\n        let [m, n, i, j] = [s.length, t.length, 0, 0];\\n        while (i < m && j < n)\\n            if (s[i] === t[j]) i++, j++;\\n            else j++;\\n\\n        return i === m;\\n    };\\n\\n    let small = \"abcdefghijklmnopqrstuvwxyz\";\\n\\n    let count = 0;\\n    for (let ch1 of small) {\\n        for (let ch2 of small) {\\n            for (let ch3 of small) {\\n                const strOf3Chars = ch1 + ch2 + ch3;\\n                if (isPalindrome(strOf3Chars)) {\\n                    if (isSubsequence(strOf3Chars, s)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```\n```\\nvar countPalindromicSubsequence = function (s) {\\n    return \"abcdefghijklmnopqrstuvwxyz\" //\\n        .split(\"\")\\n        .reduce((count, ch) => {\\n            const i = s.indexOf(ch); //     find index of        ch from left\\n            const j = s.lastIndexOf(ch); // find index of (same) ch from right\\n            if (i < j) {\\n                return count + new Set(s.slice(i + 1, j)).size; // how many unique in middle? add and return\\n            }\\n            return count; // otherwise, return old count\\n        }, 0);\\n};\\n```\n```\\nconst small_alpha_arr = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\\nvar countPalindromicSubsequence = function (s) {\\n    return small_alpha_arr //\\n        .reduce((count, ch) => {\\n            const i = s.indexOf(ch); //     find index of        ch from left\\n            const j = s.lastIndexOf(ch); // find index of (same) ch from right\\n            if (i !== j) {\\n                return count + new Set(s.slice(i + 1, j)).size; // how many unique in middle? add and return\\n            } else {\\n                return count; // otherwise, return old count\\n            }\\n        }, 0);\\n};\\n```\n```\\nconst small_alpha_arr = \"abcdefghijklmnopqrstuvwxyz\".split(\"\");\\nvar countPalindromicSubsequence = function (s) {\\n    return small_alpha_arr //\\n        .reduce((count, ch) => {\\n            const i = s.indexOf(ch); //     find index of        ch from left\\n            const j = s.lastIndexOf(ch); // find index of (same) ch from right\\n            return (\\n                count +\\n                (i !== j\\n                    ? new Set(s.slice(i + 1, j)).size // how many unique in middle? add and return\\n                    : 0)\\n            );\\n        }, 0);\\n};\\n```\n```\\nvar countPalindromicSubsequence = function (s) {\\n    return \"abcdefghijklmnopqrstuvwxyz\"\\n        .split(\"\")\\n        .reduce(\\n            (count, ch) =>\\n                count +\\n                (s.indexOf(ch) !== s.lastIndexOf(ch)\\n                    ? new Set(s.slice(s.indexOf(ch) + 1, s.lastIndexOf(ch))).size\\n                    : 0),\\n            0\\n        );\\n};\\n```\n```\\nvar countPalindromicSubsequence = function (s) {\\n    return \"abcdefghijklmnopqrstuvwxyz\".split(\"\").reduce((count, ch) => count + (s.indexOf(ch) !== s.lastIndexOf(ch) ? new Set(s.slice(s.indexOf(ch) + 1, s.lastIndexOf(ch))).size : 0), 0);\\n};\\n```\n```\\nvar countPalindromicSubsequence = (s) => \"abcdefghijklmnopqrstuvwxyz\".split(\"\").reduce((count, ch) => count + (s.indexOf(ch) !== s.lastIndexOf(ch) ? new Set(s.slice(s.indexOf(ch) + 1, s.lastIndexOf(ch))).size : 0), 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330607,
                "title": "python3-one-liner-faster-144ms",
                "content": "```\\n\\nclass Solution:\\n    def countPalindromicSubsequence(self, s):\\n\\t\\t return sum(len(set(s[s.index(i)+1:s.rindex(i)])) for i in ascii_lowercase if i in s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\n\\nclass Solution:\\n    def countPalindromicSubsequence(self, s):\\n\\t\\t return sum(len(set(s[s.index(i)+1:s.rindex(i)])) for i in ascii_lowercase if i in s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330224,
                "title": "java-o-26n",
                "content": "1. Find the boundary of each character\\n2. Find the unique characters between these boundaries\\n3. Sum\\n\\n```\\npublic int countPalindromicSubsequence(String s) {\\n\\tint[][] bounds = new int[26][2];\\n\\tfor (int i = 0; i < 26; i++) {\\n\\t\\tbounds[i][0] = Integer.MAX_VALUE;\\n\\t\\tbounds[i][1] = Integer.MIN_VALUE;\\n\\t}\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tint pos = s.charAt(i) - \\'a\\';\\n\\t\\tbounds[pos][0] = Math.min(bounds[pos][0], i);\\n\\t\\tbounds[pos][1] = Math.max(bounds[pos][1], i);\\n\\t}\\n\\tint ans = 0;\\n\\tboolean[] seen;\\n\\tfor (int i = 0; i < 26; i++) {\\n\\t\\tseen = new boolean[26];\\n\\t\\tfor (int j = bounds[i][0] + 1; j < bounds[i][1]; j++) {\\n\\t\\t\\tchar c = s.charAt(j);\\n\\t\\t\\tif (!seen[c - \\'a\\']) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tseen[c - \\'a\\'] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countPalindromicSubsequence(String s) {\\n\\tint[][] bounds = new int[26][2];\\n\\tfor (int i = 0; i < 26; i++) {\\n\\t\\tbounds[i][0] = Integer.MAX_VALUE;\\n\\t\\tbounds[i][1] = Integer.MIN_VALUE;\\n\\t}\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tint pos = s.charAt(i) - \\'a\\';\\n\\t\\tbounds[pos][0] = Math.min(bounds[pos][0], i);\\n\\t\\tbounds[pos][1] = Math.max(bounds[pos][1], i);\\n\\t}\\n\\tint ans = 0;\\n\\tboolean[] seen;\\n\\tfor (int i = 0; i < 26; i++) {\\n\\t\\tseen = new boolean[26];\\n\\t\\tfor (int j = bounds[i][0] + 1; j < bounds[i][1]; j++) {\\n\\t\\t\\tchar c = s.charAt(j);\\n\\t\\t\\tif (!seen[c - \\'a\\']) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tseen[c - \\'a\\'] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330212,
                "title": "simple-java-solution",
                "content": "A subsequence of 3 length will be a palindrome only if its first and last element are same.\\nSo we keep track of last index and first index and use set to remove duplicacy.\\n\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        Map<Character, Integer> mp = new HashMap<>();\\n        for(int i=0;i<s.length();i++) mp.put(s.charAt(i), i);\\n        Set<String> result = new HashSet<>();\\n        Set<String> currSet = new HashSet<>();;\\n        for(int i=0;i<s.length();i++) {\\n            if(currSet.contains(String.valueOf(s.charAt(i))) && mp.get(s.charAt(i)) == i) \\n                currSet.remove(String.valueOf(s.charAt(i)));\\n            for(String c: currSet) result.add(c + s.charAt(i) + c);\\n            if(mp.get(s.charAt(i)) != i)\\n                currSet.add(String.valueOf(s.charAt(i)));\\n        }\\n\\treturn result.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        Map<Character, Integer> mp = new HashMap<>();\\n        for(int i=0;i<s.length();i++) mp.put(s.charAt(i), i);\\n        Set<String> result = new HashSet<>();\\n        Set<String> currSet = new HashSet<>();;\\n        for(int i=0;i<s.length();i++) {\\n            if(currSet.contains(String.valueOf(s.charAt(i))) && mp.get(s.charAt(i)) == i) \\n                currSet.remove(String.valueOf(s.charAt(i)));\\n            for(String c: currSet) result.add(c + s.charAt(i) + c);\\n            if(mp.get(s.charAt(i)) != i)\\n                currSet.add(String.valueOf(s.charAt(i)));\\n        }\\n\\treturn result.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330196,
                "title": "java-brute-force-weak-test-cases-and-high-constraints",
                "content": "i wasted more than half an hour before i coded bruteForce for this. As according to constraints n sq. approach will surely give TLE.\\nShouldn\\'t be accepted tbh.\\nBut luckily it got.\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int[] occ = new int[26];\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            occ[s.charAt(i) - \\'a\\'] = i;\\n        }\\n        \\n        HashSet<Character> set = new HashSet<>();\\n        \\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            \\n            if(occ[s.charAt(i) - \\'a\\'] <= i || set.contains(s.charAt(i)))continue;\\n            \\n            int j = occ[s.charAt(i) - \\'a\\'];\\n            \\n            count += uniqueChar(s, i , j);\\n            set.add(s.charAt(i));\\n        }\\n        return count;\\n    }\\n    int uniqueChar(String s, int si, int ei){\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = si + 1; i < ei; i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int[] occ = new int[26];\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            occ[s.charAt(i) - \\'a\\'] = i;\\n        }\\n        \\n        HashSet<Character> set = new HashSet<>();\\n        \\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            \\n            if(occ[s.charAt(i) - \\'a\\'] <= i || set.contains(s.charAt(i)))continue;\\n            \\n            int j = occ[s.charAt(i) - \\'a\\'];\\n            \\n            count += uniqueChar(s, i , j);\\n            set.add(s.charAt(i));\\n        }\\n        return count;\\n    }\\n    int uniqueChar(String s, int si, int ei){\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = si + 1; i < ei; i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330195,
                "title": "c-solution-detailed-explained-with-o-n-complexity",
                "content": "Points to be noted:\\n1. Palindrome string is of length 3. So only first and third character have to be same.\\n2. Duplicate strings are not allowed. So we have to get unique characters as a second character.\\n\\nAlgorithm:\\n1. Loop through all \\'a\\' to \\'z\\' characters. We will count palindrome starting with each character from \\'a\\' to \\'z\\'.\\n2. Get the first and last occurance of a character.\\n3. Count unique characters in between these two indices. These will be candidates for second character in our palindrome.\\n4. Keep adding count in final answer.\\n```\\npublic int CountPalindromicSubsequence(string s) {\\n        var cnt = 0;\\n        var arr = s.ToCharArray();\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            var st = Array.IndexOf(arr, c);\\n            var end = Array.LastIndexOf(arr, c);\\n            var hash = new HashSet<char>();\\n            for (var j = st + 1; j < end; j++)\\n            {\\n                hash.Add(arr[j]);\\n            }\\n            \\n            cnt += hash.Count;\\n        }\\n        \\n        return cnt;\\n    }",
                "solutionTags": [],
                "code": "Points to be noted:\\n1. Palindrome string is of length 3. So only first and third character have to be same.\\n2. Duplicate strings are not allowed. So we have to get unique characters as a second character.\\n\\nAlgorithm:\\n1. Loop through all \\'a\\' to \\'z\\' characters. We will count palindrome starting with each character from \\'a\\' to \\'z\\'.\\n2. Get the first and last occurance of a character.\\n3. Count unique characters in between these two indices. These will be candidates for second character in our palindrome.\\n4. Keep adding count in final answer.\\n```\\npublic int CountPalindromicSubsequence(string s) {\\n        var cnt = 0;\\n        var arr = s.ToCharArray();\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            var st = Array.IndexOf(arr, c);\\n            var end = Array.LastIndexOf(arr, c);\\n            var hash = new HashSet<char>();\\n            for (var j = st + 1; j < end; j++)\\n            {\\n                hash.Add(arr[j]);\\n            }\\n            \\n            cnt += hash.Count;\\n        }\\n        \\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1330190,
                "title": "using-prefix-and-sufix-sum-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<vector<bool>>pre(26,vector<bool>(s.size(),0));\\n        vector<vector<bool>>su(26,vector<bool>(s.size(),0));\\n        \\n        pre[s[0]-\\'a\\'][0]=1;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                pre[j][i]=pre[j][i-1];\\n            }\\n            pre[s[i]-\\'a\\'][i]=1;\\n        }\\n        int n=s.size();\\n        su[s[n-1]-\\'a\\'][n-1]=1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                su[j][i]=su[j][i+1];\\n            }\\n            su[s[i]-\\'a\\'][i]=1;\\n        }\\n        int ans=0;\\n        vector<vector<bool>>vis(26,vector<bool>(26,0));\\n        for(int i=1;i<n-1;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(vis[j][(s[i]-\\'a\\')]==0 && pre[j][i-1]!=0 && su[j][i+1]!=0)\\n                {\\n                    vis[j][(s[i]-\\'a\\')]=1;\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<vector<bool>>pre(26,vector<bool>(s.size(),0));\\n        vector<vector<bool>>su(26,vector<bool>(s.size(),0));\\n        \\n        pre[s[0]-\\'a\\'][0]=1;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                pre[j][i]=pre[j][i-1];\\n            }\\n            pre[s[i]-\\'a\\'][i]=1;\\n        }\\n        int n=s.size();\\n        su[s[n-1]-\\'a\\'][n-1]=1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                su[j][i]=su[j][i+1];\\n            }\\n            su[s[i]-\\'a\\'][i]=1;\\n        }\\n        int ans=0;\\n        vector<vector<bool>>vis(26,vector<bool>(26,0));\\n        for(int i=1;i<n-1;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(vis[j][(s[i]-\\'a\\')]==0 && pre[j][i-1]!=0 && su[j][i+1]!=0)\\n                {\\n                    vis[j][(s[i]-\\'a\\')]=1;\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640197,
                "title": "c-set-map-uncomment-code-for-all-steps-understaning",
                "content": "# Intuition\\nAs there should be same element for s[i] on left  & right to be palindrome, so we will use set for left & map for right side elements.\\n\\n# Approach\\n1. store all elements instance in map(right)\\n2. iterate on s.size()\\n3. take s[i] & find elements in left & first remove from right bcs it\\'s no more element of right , if both are found it means s[i] is middle element & there are same elements at left & right of s[i], so string will become \"a-s[i]-a\" of length 3.\\n4.  store founded string in set. bcs we want al unique strings.\\n5. return size of set.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(26*n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\n#include<unordered_map>\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        unordered_map<int,int> right(26);\\n        unordered_set<int> left;\\n        unordered_set<string> ans;\\n        for(int i=0;i<s.size();i++){\\n          right[s[i]-\\'a\\']++;\\n        }\\n\\n        // for(auto it:right){\\n        //     cout<<it.first << \" -> \"<<it.second<<endl;\\n        // }\\n        //cout<<endl;\\n       \\n        for(int i=0;i<s.size();i++){\\n                       \\n                       right[s[i]-\\'a\\']--;\\n                       if(right[s[i]-\\'a\\'] == 0){\\n                           right.erase(s[i]-\\'a\\');\\n                       }\\n        //     cout<<\"right\"<<endl;\\n        //     for(auto it:right){cout<<it.first << \" -> \"<<it.second<<endl;}\\n            if(left.size()>0){\\n                for(auto it:left){\\n                    string temp=\"\";\\n                    if(right.find(it)!=right.end()){\\n                        temp+=it;\\n                        temp+=s[i];\\n                        temp+=it;\\n                          ans.insert(temp);\\n                    }   \\n                }   \\n            }\\n             left.insert(s[i]-\\'a\\');\\n                // cout<<\"left\"<<endl;\\n                // for(auto it:left){cout<<it<<\" \";}\\n                // cout<<endl;\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<unordered_map>\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        unordered_map<int,int> right(26);\\n        unordered_set<int> left;\\n        unordered_set<string> ans;\\n        for(int i=0;i<s.size();i++){\\n          right[s[i]-\\'a\\']++;\\n        }\\n\\n        // for(auto it:right){\\n        //     cout<<it.first << \" -> \"<<it.second<<endl;\\n        // }\\n        //cout<<endl;\\n       \\n        for(int i=0;i<s.size();i++){\\n                       \\n                       right[s[i]-\\'a\\']--;\\n                       if(right[s[i]-\\'a\\'] == 0){\\n                           right.erase(s[i]-\\'a\\');\\n                       }\\n        //     cout<<\"right\"<<endl;\\n        //     for(auto it:right){cout<<it.first << \" -> \"<<it.second<<endl;}\\n            if(left.size()>0){\\n                for(auto it:left){\\n                    string temp=\"\";\\n                    if(right.find(it)!=right.end()){\\n                        temp+=it;\\n                        temp+=s[i];\\n                        temp+=it;\\n                          ans.insert(temp);\\n                    }   \\n                }   \\n            }\\n             left.insert(s[i]-\\'a\\');\\n                // cout<<\"left\"<<endl;\\n                // for(auto it:left){cout<<it<<\" \";}\\n                // cout<<endl;\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3231688,
                "title": "javascript-easy-to-understand-solution-o-26-n-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing brute force, we can do a triple for-loop to iterate every subsequence. This has a time complexity of O(n^3).\\n\\nUsing the fact that the palindrome len == 3, we know a valid subsequence is just 3 chars where the first and last are the same, the middle char can be anything.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTherefore, we can first simplify this question to become:\\n1. For every index, check if character `\\'a\\'` exists in both the left and right subarray, check if character `\\'b\\'` exists in both the left and right subarray... and so on.\\n2. This has an overall time complexity of O(n^2). We can further improve the time complexity at the cost of using O(n) space.\\n\\nFurther optimized approach using 2 passes:\\n1. first pass to create a map of `{ character => [first occurence, last occurence] }`\\n2. second pass to loop through input. At every index i, scan the entire mapping for any characters with first occurence < i && last occurrence > i. This means that the char exists in the left subarray and right subarray of current index i.\\n3. store current palindrome in a set to ensure uniqueness. \\n4. return number of unique palindrome\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(26 * n) as input may contain up to 26 unique chars, we iterate over the 26 chars at every index.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2 * n)\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    let map = new Map()\\n    for (let i = 0; i < s.length; i++) {\\n        if (!map.has(s[i])) {\\n            map.set(s[i], [s.length, 0])\\n        }\\n        if (i < map.get(s[i])[0]) {\\n            map.get(s[i])[0] = i\\n        }\\n        if (i > map.get(s[i])[1]) {\\n            map.get(s[i])[1] = i\\n        }\\n    }\\n    let res = new Set()\\n    for (let i = 1; i < s.length - 1; i++) {\\n        for (const [char, minMax] of map) {\\n            if (minMax[0] < i && i < minMax[1]) {\\n                res.add(`${s[i]},${char}`)\\n            }\\n        }\\n    }\\n    return res.size\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    let map = new Map()\\n    for (let i = 0; i < s.length; i++) {\\n        if (!map.has(s[i])) {\\n            map.set(s[i], [s.length, 0])\\n        }\\n        if (i < map.get(s[i])[0]) {\\n            map.get(s[i])[0] = i\\n        }\\n        if (i > map.get(s[i])[1]) {\\n            map.get(s[i])[1] = i\\n        }\\n    }\\n    let res = new Set()\\n    for (let i = 1; i < s.length - 1; i++) {\\n        for (const [char, minMax] of map) {\\n            if (minMax[0] < i && i < minMax[1]) {\\n                res.add(`${s[i]},${char}`)\\n            }\\n        }\\n    }\\n    return res.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3008825,
                "title": "yet-another-javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    let letterSet = new Set();\\n    let res = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (letterSet.has(s[i])) continue;\\n        let tempSet = new Set();\\n        letterSet.add(s[i]);\\n        let lastIndex = s.lastIndexOf(s[i]);\\n        if (lastIndex !== i) {\\n            for (let j = i + 1; j < lastIndex; j++) {\\n                tempSet.add(s[j]);\\n            }\\n            res += tempSet.size;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    let letterSet = new Set();\\n    let res = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (letterSet.has(s[i])) continue;\\n        let tempSet = new Set();\\n        letterSet.add(s[i]);\\n        let lastIndex = s.lastIndexOf(s[i]);\\n        if (lastIndex !== i) {\\n            for (let j = i + 1; j < lastIndex; j++) {\\n                tempSet.add(s[j]);\\n            }\\n            res += tempSet.size;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2345930,
                "title": "26-x-size-s-passes",
                "content": "**time: `O(N)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/3edeb584-70fa-4701-a862-3d433d7889dd_1659030770.7768395.png)\\n\\n```\\nint countPalindromicSubsequence(string s) \\n{\\n\\tvector b(27, INT_MAX), e(27, -1);\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t\\t(b[s[i]-\\'a\\']==INT_MAX ? b[s[i]-\\'a\\'] : e[s[i]-\\'a\\']) = i;\\n\\n\\tint out{};\\n\\tfor(int i{}, d[27]{}; i<size(s); ++i)\\n\\t{\\n\\t\\tif(i==e[s[i]-\\'a\\']) \\n\\t\\t\\t out += __builtin_popcount(d[s[i]-\\'a\\']);\\n\\n\\t\\tfor(int j{}; j<27; ++j)\\n\\t\\t\\tif(i>b[j] and i<e[j])\\n\\t\\t\\t\\td[j] |= 1<<s[i]-\\'a\\';\\n\\t}\\n\\treturn out;\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/24bcb563-c858-4386-a649-0e5172f998d8_1659031323.4731755.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint countPalindromicSubsequence(string s) \\n{\\n\\tvector b(27, INT_MAX), e(27, -1);\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t\\t(b[s[i]-\\'a\\']==INT_MAX ? b[s[i]-\\'a\\'] : e[s[i]-\\'a\\']) = i;\\n\\n\\tint out{};\\n\\tfor(int i{}, d[27]{}; i<size(s); ++i)\\n\\t{\\n\\t\\tif(i==e[s[i]-\\'a\\']) \\n\\t\\t\\t out += __builtin_popcount(d[s[i]-\\'a\\']);\\n\\n\\t\\tfor(int j{}; j<27; ++j)\\n\\t\\t\\tif(i>b[j] and i<e[j])\\n\\t\\t\\t\\td[j] |= 1<<s[i]-\\'a\\';\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2292246,
                "title": "python-simple-maths",
                "content": "\\n    def countPalindromicSubsequence(self, s):\\n        total = 0\\n        \\n        for i in set(s):\\n            l, r = s.find(i), s.rfind(i)\\n            \\n            if l < r:\\n                total += len(set(s[l+1:r]))\\n                \\n        return total",
                "solutionTags": [],
                "code": "\\n    def countPalindromicSubsequence(self, s):\\n        total = 0\\n        \\n        for i in set(s):\\n            l, r = s.find(i), s.rfind(i)\\n            \\n            if l < r:\\n                total += len(set(s[l+1:r]))\\n                \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 2282039,
                "title": "c-prefix-easy-simple",
                "content": "```````````````````\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n=s.size();\\n        int maxl=0;\\n        for(auto i: s){\\n            maxl=max(maxl,int(i-\\'a\\'));\\n        }\\n        \\n        vector<vector<int>>v(maxl+1,vector<int>(n+1,0));\\n        \\n        for(int i=0;i<n;i++){\\n            v[s[i]-\\'a\\'][i+1]++;\\n        }\\n        \\n        for(int i=0;i<=maxl;i++){\\n            for(int j=1;j<=n;j++){\\n                v[i][j]+=v[i][j-1];\\n            }\\n        }\\n        \\n        int ans=0;\\n        int temp1=0;\\n        int temp2=0;\\n        vector<vector<int>>mp(maxl+1,vector<int>(maxl+1,0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=maxl;j++){\\n                temp1=v[j][i];\\n                temp2=v[j][n]-v[j][i+1];\\n                if(temp1>0 && temp2>0)\\n                {\\n                     if(mp[j][s[i]-\\'a\\']==0)\\n                     { ans++;  }\\n                     mp[j][s[i]-\\'a\\']++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``````\n``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 1658158,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int min[]=new int[26];\\n        int max[]=new int[26];\\n        for(int i=0;i<s.length();i++) max[s.charAt(i)-97]=i;\\n        for(int i=s.length()-1;i>=0;i--) min[s.charAt(i)-97]=i;\\n        HashSet<Character> set=new HashSet<>();\\n        int result=0;\\n        for(int i=0;i<26;i++){\\n                for(int j=min[i]+1;j<max[i];j++)\\n                    set.add(s.charAt(j));\\n                result+=set.size();\\n                set.clear();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int min[]=new int[26];\\n        int max[]=new int[26];\\n        for(int i=0;i<s.length();i++) max[s.charAt(i)-97]=i;\\n        for(int i=s.length()-1;i>=0;i--) min[s.charAt(i)-97]=i;\\n        HashSet<Character> set=new HashSet<>();\\n        int result=0;\\n        for(int i=0;i<26;i++){\\n                for(int j=min[i]+1;j<max[i];j++)\\n                    set.add(s.charAt(j));\\n                result+=set.size();\\n                set.clear();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628260,
                "title": "c-easy-solution",
                "content": "```\\n int countPalindromicSubsequence(string s) {\\n        vector<int>first(26,-1);\\n        vector<int>last(26,-1);\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(first[s[i]-\\'a\\']==-1)\\n                first[s[i]-\\'a\\']=i;\\n            last[s[i]-\\'a\\']=i;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            if(first[i]!=-1){\\n                int cnt=0;\\n                vector<bool>vis(26,false);\\n                for(int j=first[i]+1;j<last[i];j++){\\n                    if(vis[s[j]-\\'a\\']==false){\\n                        vis[s[j]-\\'a\\']=true;\\n                        cnt++;\\n                    }\\n                }\\n                ans+=cnt;\\n            }\\n            \\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n int countPalindromicSubsequence(string s) {\\n        vector<int>first(26,-1);\\n        vector<int>last(26,-1);\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(first[s[i]-\\'a\\']==-1)\\n                first[s[i]-\\'a\\']=i;\\n            last[s[i]-\\'a\\']=i;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            if(first[i]!=-1){\\n                int cnt=0;\\n                vector<bool>vis(26,false);\\n                for(int j=first[i]+1;j<last[i];j++){\\n                    if(vis[s[j]-\\'a\\']==false){\\n                        vis[s[j]-\\'a\\']=true;\\n                        cnt++;\\n                    }\\n                }\\n                ans+=cnt;\\n            }\\n            \\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1388137,
                "title": "c-counting-letters-clean-and-fast-o-n",
                "content": "For each letter, use it as the starting and ending letter, try to count the number of 3-letter palindromes.\\n\\nFor example, we have a sequence \"abcadca\". For letter \"a\", we can find its index at 0, 3, and 6. We can count all possible palindromes (without duplicates) that has a form \"a?a\". Note that when we have more than 2 \"a\" in the string, we can also construct \"aaa\".\\n\\nIterate though all possible letters from \"a\" -> \"z\" and get the count.\\n\\nTime complexity would be O(26N) = O(N).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0;\\n        for (int i = 0; i < 26; ++i){\\n            ans += countLetter(s, \\'a\\' + i);\\n        }\\n        return ans;\\n    }\\n    \\n    int countLetter(string s, char c){\\n        auto i = s.find(c);\\n        if (i == -1) return 0;\\n        auto j = s.find(c, i + 1);\\n        if (j == -1) return 0;\\n        \\n        int ans = 0;\\n        vector<int> vec(26, 0);\\n        int matches = 1;\\n        while (j != -1){\\n            matches++;\\n            for (int k = i + 1; k < j; ++k){\\n                if (!vec[s[k] - \\'a\\']){\\n                    vec[s[k] - \\'a\\']++;\\n                    ans++;\\n                }\\n            }\\n            i = j, j = s.find(c, j + 1);\\n        }\\n        return matches > 2 ? 1 + ans: ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0;\\n        for (int i = 0; i < 26; ++i){\\n            ans += countLetter(s, \\'a\\' + i);\\n        }\\n        return ans;\\n    }\\n    \\n    int countLetter(string s, char c){\\n        auto i = s.find(c);\\n        if (i == -1) return 0;\\n        auto j = s.find(c, i + 1);\\n        if (j == -1) return 0;\\n        \\n        int ans = 0;\\n        vector<int> vec(26, 0);\\n        int matches = 1;\\n        while (j != -1){\\n            matches++;\\n            for (int k = i + 1; k < j; ++k){\\n                if (!vec[s[k] - \\'a\\']){\\n                    vec[s[k] - \\'a\\']++;\\n                    ans++;\\n                }\\n            }\\n            i = j, j = s.find(c, j + 1);\\n        }\\n        return matches > 2 ? 1 + ans: ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386842,
                "title": "shortest-in-c-explained-with-comments",
                "content": "**Shortest In C++**\\n* Find **First** and **last** Occurence of each character [a,z] in given string.\\n* Find the number of unique characters between first and last occurance of a character.\\n\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n=s.length(),ans=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            int last=s.find_last_of(\\'a\\'+i);\\n            int first=s.find_first_of(\\'a\\'+i);\\n            //if last is greater than first that means there are some characters in between them\\n            if(last>first)\\n            {   //count of unique chars between them\\n                  unordered_set<char>set;\\n                for(int j=first+1;j<last;j++)\\n                {\\n                    set.insert(s[j]);\\n                }\\n                ans+=set.size();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n=s.length(),ans=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            int last=s.find_last_of(\\'a\\'+i);\\n            int first=s.find_first_of(\\'a\\'+i);\\n            //if last is greater than first that means there are some characters in between them\\n            if(last>first)\\n            {   //count of unique chars between them\\n                  unordered_set<char>set;\\n                for(int j=first+1;j<last;j++)\\n                {\\n                    set.insert(s[j]);\\n                }\\n                ans+=set.size();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373598,
                "title": "java-o-n-26-solution-using-hashset-with-explanation",
                "content": "Basic Idea : \\n1. For every alphabet find the first and last index\\n2. If they are -1 or both equal skip to next alphabet\\n3. if first and last index are different, then add the number of unique characters between both indices to the count\\n\\n\\nclass Solution {\\n\\n    public int countPalindromicSubsequence(String s) {\\n        int count = 0;\\n        HashSet<Character> hset = new HashSet<Character>();\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            int x = s.indexOf(\"\"+c);\\n            if(x == -1) continue;\\n            int y = s.lastIndexOf(\"\"+c);\\n            if(y == x) continue;\\n            hset.clear();\\n            while(++x < y) {\\n                hset.add(s.charAt(x));\\n            }\\n            count += hset.size();\\n        }\\n        return count;\\n    }\\n\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int countPalindromicSubsequence(String s) {\\n        int count = 0;\\n        HashSet<Character> hset = new HashSet<Character>();\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            int x = s.indexOf(\"\"+c);\\n            if(x == -1) continue;\\n            int y = s.lastIndexOf(\"\"+c);\\n            if(y == x) continue;\\n            hset.clear();\\n            while(++x < y) {\\n                hset.add(s.charAt(x));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1361100,
                "title": "simple-logic-c-using-vector-and-set",
                "content": "Here three size palindrome means 1st and 3rd letters are same. So first I stored all positions of each chars. Then using that 1st and last position I calculated how many different chars are in between them. That gives the largest answer.\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<vector<int>> v(26);\\n        int i=0,ans=0;\\n        while(i<s.size())\\n        {\\n            v[s[i]-\\'a\\'].push_back(i);\\n            i++;\\n        }\\n        i=0;\\n        while(i<26)\\n        {\\n            if(v[i].size()>1)\\n            {\\n                set<char> st;\\n                int l=v[i][0]+1,r=v[i].back();\\n                while(l<r&&st.size()<26)\\n                {\\n                    st.insert(s[l]);\\n                    l++;\\n                }\\n                ans+=st.size();\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<vector<int>> v(26);\\n        int i=0,ans=0;\\n        while(i<s.size())\\n        {\\n            v[s[i]-\\'a\\'].push_back(i);\\n            i++;\\n        }\\n        i=0;\\n        while(i<26)\\n        {\\n            if(v[i].size()>1)\\n            {\\n                set<char> st;\\n                int l=v[i][0]+1,r=v[i].back();\\n                while(l<r&&st.size()<26)\\n                {\\n                    st.insert(s[l]);\\n                    l++;\\n                }\\n                ans+=st.size();\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343354,
                "title": "python-easy-solution",
                "content": "from collections import Counter\\n\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        c1 = dict(Counter(s))\\n        c2 = dict()\\n        temp = set()\\n\\n        i = 0\\n        while i < len(s) - 1:\\n\\n            if len(c2) == 0:\\n                c2[s[i]] = 1\\n                c1[s[i]] -= 1\\n\\n                if c1[s[i]] == 0:\\n                    c1.pop(s[i])\\n                i += 1\\n\\n            else:\\n                c1[s[i]] -= 1\\n                if c1[s[i]] == 0:\\n                    c1.pop(s[i])\\n\\n                for j in c2.keys():\\n                    if j in c1:\\n                        p = j + s[i] + j\\n                        temp.add(p)\\n\\n                if s[i] in c2:\\n                    c2[s[i]] += 1\\n                else:\\n                    c2[s[i]] = 1\\n\\n                i += 1\\n\\n\\n        return (len(temp))\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "from collections import Counter\\n\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        c1 = dict(Counter(s))\\n        c2 = dict()\\n        temp = set()\\n\\n        i = 0\\n        while i < len(s) - 1:\\n\\n            if len(c2) == 0:\\n                c2[s[i]] = 1\\n                c1[s[i]] -= 1\\n\\n                if c1[s[i]] == 0:\\n                    c1.pop(s[i])\\n                i += 1\\n\\n            else:\\n                c1[s[i]] -= 1\\n                if c1[s[i]] == 0:\\n                    c1.pop(s[i])\\n\\n                for j in c2.keys():\\n                    if j in c1:\\n                        p = j + s[i] + j\\n                        temp.add(p)\\n\\n                if s[i] in c2:\\n                    c2[s[i]] += 1\\n                else:\\n                    c2[s[i]] = 1\\n\\n                i += 1\\n\\n\\n        return (len(temp))\\n",
                "codeTag": "Java"
            },
            {
                "id": 1340504,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n        char[] arr = s.toCharArray();\\n        int result = 0;\\n        for(int i = 0; i < arr.length;i++){\\n            if(!map.containsKey(arr[i])){\\n                List<Integer> list = new LinkedList<>();\\n                list.add(i);\\n                map.put(arr[i],list);\\n            }else{\\n                map.get(arr[i]).add(i);\\n            }\\n        }\\n       for(Character c : map.keySet()){\\n           List<Integer> list = map.get(c);\\n           if(list.size() < 2) continue;\\n           Set<Character> set = new HashSet<>();\\n           for(int i = list.get(0) + 1; i< list.get(list.size()-1); i++){\\n               set.add(arr[i]);\\n           }\\n           result = result + set.size();\\n       }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n        char[] arr = s.toCharArray();\\n        int result = 0;\\n        for(int i = 0; i < arr.length;i++){\\n            if(!map.containsKey(arr[i])){\\n                List<Integer> list = new LinkedList<>();\\n                list.add(i);\\n                map.put(arr[i],list);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1337046,
                "title": "prefix-sum-solution-with-explanation",
                "content": "Please upvote if you find this solution useful. More than happy to solve your queries in comments.\\n\\n**Intuition:**\\n3 Letter Palidrome means the first and the last letters are same and the middle element can be anything. Therefore, the number of unique middle elements is the answer.\\nSo if we are given the first and last indices of a character, we should be able to determine the number of unique elements in between. This can be achieved by prefix sum technique.\\n\\nWe iterate through the given string once and store the first and last indices of every character. We also store the occurences of a character in a 2D array.\\n\\nThen we iterate through the alphabets and find the number of unique middle elements.\\n\\n**Code:**\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String given) {\\n        int n = given.length(), ans = 0;\\n        char[] s = given.toCharArray();\\n        int[][] unique = new int[n + 1][26];\\n        int[] lastIndex = new int[26], firstIndex = new int[26];\\n        Arrays.fill(firstIndex, n);\\n        for(int i = 0; i < n; i++){\\n            unique[i + 1] = Arrays.copyOf(unique[i], 26);\\n            unique[i + 1][s[i] - \\'a\\']++;\\n            lastIndex[s[i] - \\'a\\'] = i;\\n            firstIndex[s[i] - \\'a\\'] = Math.min(i, firstIndex[s[i] - \\'a\\']);\\n        }\\n        for(int i = 0; i < 26; i++){\\n            //If firstindex is greater than or equal to last index, then there is only one occurence of the character\\n            if(firstIndex[i] >= lastIndex[i])\\n                continue;\\n            int first = firstIndex[i];\\n            int last = lastIndex[i];\\n            \\n            //logic to find unique middle elements\\n            for(int j = 0; j < 26; j++)\\n                if(unique[last][j] - unique[first + 1][j] > 0)\\n                    ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\nTime Complexity = O(26 + n) = O(n)\\nSpace Complexity = O(26 * n) = O(n)\\n\\nLooking at the discussions page, this post is very similar to https://leetcode.com/problems/unique-length-3-palindromic-subsequences/discuss/1330165/Leftmost-rightmost-and-in-between except for the prefix sum logic.",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String given) {\\n        int n = given.length(), ans = 0;\\n        char[] s = given.toCharArray();\\n        int[][] unique = new int[n + 1][26];\\n        int[] lastIndex = new int[26], firstIndex = new int[26];\\n        Arrays.fill(firstIndex, n);\\n        for(int i = 0; i < n; i++){\\n            unique[i + 1] = Arrays.copyOf(unique[i], 26);\\n            unique[i + 1][s[i] - \\'a\\']++;\\n            lastIndex[s[i] - \\'a\\'] = i;\\n            firstIndex[s[i] - \\'a\\'] = Math.min(i, firstIndex[s[i] - \\'a\\']);\\n        }\\n        for(int i = 0; i < 26; i++){\\n            //If firstindex is greater than or equal to last index, then there is only one occurence of the character\\n            if(firstIndex[i] >= lastIndex[i])\\n                continue;\\n            int first = firstIndex[i];\\n            int last = lastIndex[i];\\n            \\n            //logic to find unique middle elements\\n            for(int j = 0; j < 26; j++)\\n                if(unique[last][j] - unique[first + 1][j] > 0)\\n                    ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333609,
                "title": "c-100-faster-with-explaination",
                "content": "It is obvious that, we could think of checking each subsequence, but for 10^5, it will obviously take much time and give TLE.\\nBut, the main thing here is, we have to check the palindrome of size 3 only,\\nSo, we just need to take two alphabets, let say\\na and b\\nand check if aba is a subsequence or not. \\nfor \"aba\" being a subsequence of a string, the index of \\'b\\' must be in between the indices of the \\'a\\' s.\\nSo, here we came to know, we have to make a data structure that maintains all the positions of all the 26 alphabets. For that, we can make 2D array of size 26 x ?\\nhere ? means, we should use vector as we don\\'t know how many occurrences will be there.\\nThat\\'s why I\\'ve created\\n```\\nvector<int> arr[26];\\n//array of type vector<int> (it stores vector<int> at each of 26 positions) size 26 \\n```\\nNow, we can check each alphabet ```a``` and for each alphabet ```b```, \\nif any of the index ```b``` lies in between any two indices of ```a``` or more precisely,\\n\\twe would check, **whether  ```b``` lies in between** **first and last index** **of ```a```** in string s.\\nTo do so, we can use upper_bound (returns the first iterator position on which the element is greater than the given element)\\n[example: a b c d e f -> upper_bound(\\'c\\') = 3 (\\'d\\' is greater than \\'c\\')\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0, n = s.size();\\n        vector<int> arr[26];\\n        for (int i = 0; i < n; i++)\\n        {\\n            arr[s[i]-\\'a\\'].push_back(i); // s[i] -> charactor , - \\'a\\' means ascii of charactor - ascii of \\'a\\' = position of an alphabet from 0 (i.e. 0 for a, 1 for b, 2 for c...)\\n        }\\n        for(int i=0; i<26; i++) //first and last charactor in palindrome (0 for a, 1 for b, 2 for c...)\\n        {\\n            if(arr[i].size()==0) continue; //If it even doesn\\'t exist in string s, then skip this i\\n            int l = arr[i].front(); // first position of a (aba)\\n            int r = arr[i].back(); // last position of a\\n            for(int j=0; j<26; j++) // middle element of palindrome (i.e. b in aba)\\n            {\\n\\t\\t\\t\\t//from now, consider arr[j] as an array, for simplicity \\n                int x = upper_bound(arr[j].begin(), arr[j].end(), l) - arr[j].begin(); // iterator - startingAddress = exact position (from 0)\\n                if(x >= arr[j].size()) continue; // check if it exist or not\\n                if(l < arr[j][x] && arr[j][x] < r)  // if lies then ans++ \\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Clean Code:\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0, n = s.size();\\n        vector<int> arr[26];\\n        for (int i = 0; i < n; i++)\\n        {\\n            arr[s[i]-\\'a\\'].push_back(i);\\n        }\\n        for(int i=0; i<26; i++) \\n        {\\n            if(arr[i].size()==0) continue;\\n            int l = arr[i].front();\\n            int r = arr[i].back();\\n            for(int j=0; j<26; j++) \\n            {\\n                int x = upper_bound(arr[j].begin(), arr[j].end(), l) - arr[j].begin(); \\n                if(x >= arr[j].size()) continue; \\n                if(l < arr[j][x] && arr[j][x] < r) \\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> arr[26];\\n//array of type vector<int> (it stores vector<int> at each of 26 positions) size 26 \\n```\n```a```\n```b```\n```b```\n```a```\n```b```\n```a```\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0, n = s.size();\\n        vector<int> arr[26];\\n        for (int i = 0; i < n; i++)\\n        {\\n            arr[s[i]-\\'a\\'].push_back(i); // s[i] -> charactor , - \\'a\\' means ascii of charactor - ascii of \\'a\\' = position of an alphabet from 0 (i.e. 0 for a, 1 for b, 2 for c...)\\n        }\\n        for(int i=0; i<26; i++) //first and last charactor in palindrome (0 for a, 1 for b, 2 for c...)\\n        {\\n            if(arr[i].size()==0) continue; //If it even doesn\\'t exist in string s, then skip this i\\n            int l = arr[i].front(); // first position of a (aba)\\n            int r = arr[i].back(); // last position of a\\n            for(int j=0; j<26; j++) // middle element of palindrome (i.e. b in aba)\\n            {\\n\\t\\t\\t\\t//from now, consider arr[j] as an array, for simplicity \\n                int x = upper_bound(arr[j].begin(), arr[j].end(), l) - arr[j].begin(); // iterator - startingAddress = exact position (from 0)\\n                if(x >= arr[j].size()) continue; // check if it exist or not\\n                if(l < arr[j][x] && arr[j][x] < r)  // if lies then ans++ \\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0, n = s.size();\\n        vector<int> arr[26];\\n        for (int i = 0; i < n; i++)\\n        {\\n            arr[s[i]-\\'a\\'].push_back(i);\\n        }\\n        for(int i=0; i<26; i++) \\n        {\\n            if(arr[i].size()==0) continue;\\n            int l = arr[i].front();\\n            int r = arr[i].back();\\n            for(int j=0; j<26; j++) \\n            {\\n                int x = upper_bound(arr[j].begin(), arr[j].end(), l) - arr[j].begin(); \\n                if(x >= arr[j].size()) continue; \\n                if(l < arr[j][x] && arr[j][x] < r) \\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332717,
                "title": "js-o-n",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    const len = s.length\\n    const chs = []\\n    const aCode = 97\\n    for (let offset = 0; offset < 26; offset++) {\\n        const ch = String.fromCharCode(aCode + offset)\\n        chs.push(ch)\\n    }\\n    \\n    \\n    const counts = {}\\n    for (const ch of chs.values())\\n        counts[ch] = 0\\n    for (const ch of s)\\n        counts[ch]++\\n        \\n        \\n    const countsSF = {}\\n    for (const ch of chs.values())\\n        countsSF[ch] = 0\\n    const firstCh = s[0]\\n    countsSF[firstCh]++\\n\\n\\n    const set = new Set()\\n    for (let i = 1; i + 1 < len; i++) {\\n        const chHere = s[i]\\n        for (const ch of chs.values()) {\\n            let countFL = countsSF[ch]\\n            let countFR = counts[ch] - countFL\\n            if (chHere === ch)\\n                countFR--\\n\\n            if (countFL > 0 && countFR > 0) {\\n                const outcome = ch + chHere + ch\\n                set.add(outcome)\\n            }\\n        }\\n        \\n        \\n        countsSF[chHere]++\\n    }\\n    \\n    \\n    let result = set.size\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    const len = s.length\\n    const chs = []\\n    const aCode = 97\\n    for (let offset = 0; offset < 26; offset++) {\\n        const ch = String.fromCharCode(aCode + offset)\\n        chs.push(ch)\\n    }\\n    \\n    \\n    const counts = {}\\n    for (const ch of chs.values())\\n        counts[ch] = 0\\n    for (const ch of s)\\n        counts[ch]++\\n        \\n        \\n    const countsSF = {}\\n    for (const ch of chs.values())\\n        countsSF[ch] = 0\\n    const firstCh = s[0]\\n    countsSF[firstCh]++\\n\\n\\n    const set = new Set()\\n    for (let i = 1; i + 1 < len; i++) {\\n        const chHere = s[i]\\n        for (const ch of chs.values()) {\\n            let countFL = countsSF[ch]\\n            let countFR = counts[ch] - countFL\\n            if (chHere === ch)\\n                countFR--\\n\\n            if (countFL > 0 && countFR > 0) {\\n                const outcome = ch + chHere + ch\\n                set.add(outcome)\\n            }\\n        }\\n        \\n        \\n        countsSF[chHere]++\\n    }\\n    \\n    \\n    let result = set.size\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332680,
                "title": "simple-complete-search-time-o-n-space-o-1",
                "content": "1. Enumerate all possible length 3 palindrome (total 26 * 26 cases).\\n2. For each length 3 palindrome check whether it is subsequence of given string.\\n\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int countPalindromicSubsequence(string s) {\\n    int ans = 0;\\n    auto isSub = [&](string ss) {\\n      for (int i = 0, j = 0; i < s.size(); ++i) {\\n        if (ss[j] == s[i]) {\\n          ++j;\\n          if (j == ss.size()) {\\n            return true;\\n          }\\n        }\\n      }\\n      return false;\\n    };\\n    for (char ht = \\'a\\'; ht <= \\'z\\'; ++ht) {\\n      for (char m = \\'a\\'; m <= \\'z\\'; ++m) {\\n        if (isSub(string{ht, m, ht}) {\\n          ++ans;\\n        }\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int countPalindromicSubsequence(string s) {\\n    int ans = 0;\\n    auto isSub = [&](string ss) {\\n      for (int i = 0, j = 0; i < s.size(); ++i) {\\n        if (ss[j] == s[i]) {\\n          ++j;\\n          if (j == ss.size()) {\\n            return true;\\n          }\\n        }\\n      }\\n      return false;\\n    };\\n    for (char ht = \\'a\\'; ht <= \\'z\\'; ++ht) {\\n      for (char m = \\'a\\'; m <= \\'z\\'; ++m) {\\n        if (isSub(string{ht, m, ht}) {\\n          ++ans;\\n        }\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1331933,
                "title": "intuitive-finding-same-letter-to-left-and-right-of-every-element-26-n",
                "content": "```\\nint countPalindromicSubsequence(string s) {\\n     vector<int> m1(26), m2(26);//m1 stores values to left of an element and m2 to right\\n\\n            m1[s[0]-\\'a\\']++;// storing first character in m1 i.e. left\\n        \\n        for(int i=1;i<s.size();i++)\\n        {\\n            m2[s[i]-\\'a\\']++;// storing all other characters in m2 i.e. right\\n        }\\n       set<string> ans; // we\\'ll store all palindromes of length 3 in set\\n        for(int i=1;i<s.size()-1;i++)\\n        {\\n             m2[s[i]-\\'a\\']--;  // removing the currently visiting character from m2 i.e. right \\n             \\n            for(int it=0;it<26;it++)\\n            {\\n                if(m2[it]&&m1[it])// if character is present in both left and right then it should be added to the set\\n                {\\n                \\tchar y=char(it+97);\\n                \\tstring p;\\n                \\tp+=y;\\n                     p+=s[i];\\n                     p+=y;\\n                    ans.insert(p);\\n                    if(ans.size()==676) // as total no. of palindromes can\\'t be greater than 676(26+26+... 26 times) so we break to reduce time complexity\\n                     break;\\n                }\\n            }\\n            \\n            m1[s[i]-\\'a\\']++;// adding the visiting character to m1 i.e. left \\n        }\\n        \\n        return ans.size();// finally the length of array gives us the number of palidrome\\n    }\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nint countPalindromicSubsequence(string s) {\\n     vector<int> m1(26), m2(26);//m1 stores values to left of an element and m2 to right\\n\\n            m1[s[0]-\\'a\\']++;// storing first character in m1 i.e. left\\n        \\n        for(int i=1;i<s.size();i++)\\n        {\\n            m2[s[i]-\\'a\\']++;// storing all other characters in m2 i.e. right\\n        }\\n       set<string> ans; // we\\'ll store all palindromes of length 3 in set\\n        for(int i=1;i<s.size()-1;i++)\\n        {\\n             m2[s[i]-\\'a\\']--;  // removing the currently visiting character from m2 i.e. right \\n             \\n            for(int it=0;it<26;it++)\\n            {\\n                if(m2[it]&&m1[it])// if character is present in both left and right then it should be added to the set\\n                {\\n                \\tchar y=char(it+97);\\n                \\tstring p;\\n                \\tp+=y;\\n                     p+=s[i];\\n                     p+=y;\\n                    ans.insert(p);\\n                    if(ans.size()==676) // as total no. of palindromes can\\'t be greater than 676(26+26+... 26 times) so we break to reduce time complexity\\n                     break;\\n                }\\n            }\\n            \\n            m1[s[i]-\\'a\\']++;// adding the visiting character to m1 i.e. left \\n        }\\n        \\n        return ans.size();// finally the length of array gives us the number of palidrome\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331781,
                "title": "my-java-solution-using-2-firstoccur-and-lastoccur-array-counting-distinct-bw-them",
                "content": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        if (s == null || s.length() == 0)\\n            return 0;\\n        int length = s.length();\\n        int count = 0;\\n        // we need to find the first and last oocurance of each charcater\\n        // now our problem reduced to finding the distint charcaters between these fixed characters\\n        int [] firstOccurance = new int [26];\\n        int [] finalOccurance = new int [26];\\n        Arrays.fill(firstOccurance, -1);\\n        Arrays.fill(finalOccurance, -1);\\n        for (int i=0; i<s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (firstOccurance[ch - \\'a\\'] == -1) {\\n                // ie this index is the first occurance of ch\\n                firstOccurance[ch - \\'a\\'] = i;\\n            }\\n            finalOccurance[ch - \\'a\\'] = i;\\n        }\\n        // only needed the distinct characters in between\\n        // so a set or boolean array is needed to mark visited\\n        boolean [] visited;\\n        for (int i=0; i<26; i++) {\\n            int firstIndex = firstOccurance[i];\\n            int finalIndex = finalOccurance[i];\\n            visited = new boolean [26];\\n            for (int j=firstIndex + 1; j<finalIndex; j++) {\\n                if (!visited[s.charAt(j) - \\'a\\']) {\\n                    count += 1;\\n                    visited[s.charAt(j) - \\'a\\'] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        if (s == null || s.length() == 0)\\n            return 0;\\n        int length = s.length();\\n        int count = 0;\\n        // we need to find the first and last oocurance of each charcater\\n        // now our problem reduced to finding the distint charcaters between these fixed characters\\n        int [] firstOccurance = new int [26];\\n        int [] finalOccurance = new int [26];\\n        Arrays.fill(firstOccurance, -1);\\n        Arrays.fill(finalOccurance, -1);\\n        for (int i=0; i<s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (firstOccurance[ch - \\'a\\'] == -1) {\\n                // ie this index is the first occurance of ch\\n                firstOccurance[ch - \\'a\\'] = i;\\n            }\\n            finalOccurance[ch - \\'a\\'] = i;\\n        }\\n        // only needed the distinct characters in between\\n        // so a set or boolean array is needed to mark visited\\n        boolean [] visited;\\n        for (int i=0; i<26; i++) {\\n            int firstIndex = firstOccurance[i];\\n            int finalIndex = finalOccurance[i];\\n            visited = new boolean [26];\\n            for (int j=firstIndex + 1; j<finalIndex; j++) {\\n                if (!visited[s.charAt(j) - \\'a\\']) {\\n                    count += 1;\\n                    visited[s.charAt(j) - \\'a\\'] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331499,
                "title": "intuitive-detailed-explanation-o-n",
                "content": "**Intuition**\\nSince the palindrome we want is of size 3 we know the first and last letter of the palindrome will be the same, the element in the middle may be same or different.\\n\\n**Explanation**-\\n\\n1.In first pass we store the first and the last occurence of every alphabet present in the string, we do this using a vector of size 26(0->a,1->b..) which contains a pair at every index, the first element of pair points to the first occurence and the second points to the last one.\\n **Eg.** in this string- abbcdac-> vector[0].first=0    vector[0].second=5\\n \\n2.In the second pass we iterate over every element in i and check whether this element lies in between the start and end of any other character.If it does then we have encountered a palindrome.\\n\\n3. Now note that we are bound to encounter duplicates here as we have not provided a check for them. Thus we maintain a hashmap of <string,bool>which stores whether we have encountered this string before.\\n\\n4.In the end we just return the size of hashmap as it will only contain the unique strings.\\n\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<pair<int,int>>umap(26,{INT_MAX,INT_MIN});\\n    \\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            umap[s[i]-\\'a\\'].first=min(umap[s[i]-\\'a\\'].first,i);\\n            umap[s[i]-\\'a\\'].second=max(umap[s[i]-\\'a\\'].second,i);\\n          }\\n       \\n        unordered_map<string,bool>check;\\n      \\n        for(int i=0;i<s.size();i++){\\n            \\n                for(int j=0;j<26;j++){\\n                    if(umap[j].first<i&&umap[j].second>i){\\n                        char x=\\'a\\'+j;\\n                        string a=\"\";\\n                        a+=x;\\n                        a+=s[i];\\n                        a+=x;\\n                       check[a]=true;\\n                    }\\n                }\\n        }\\n      return check.size();  \\n        \\n        \\n      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<pair<int,int>>umap(26,{INT_MAX,INT_MIN});\\n    \\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            umap[s[i]-\\'a\\'].first=min(umap[s[i]-\\'a\\'].first,i);\\n            umap[s[i]-\\'a\\'].second=max(umap[s[i]-\\'a\\'].second,i);\\n          }\\n       \\n        unordered_map<string,bool>check;\\n      \\n        for(int i=0;i<s.size();i++){\\n            \\n                for(int j=0;j<26;j++){\\n                    if(umap[j].first<i&&umap[j].second>i){\\n                        char x=\\'a\\'+j;\\n                        string a=\"\";\\n                        a+=x;\\n                        a+=s[i];\\n                        a+=x;\\n                       check[a]=true;\\n                    }\\n                }\\n        }\\n      return check.size();  \\n        \\n        \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330828,
                "title": "o-n-solution-with-approach-explanation-complexity-analysis-and-optimisations",
                "content": "Though reading the problem statement, this seems like a subsequence problem, it can actually be reduced into a smaller sliding window kind of problem. The key to this is the length of palindrome, which is 3.\\n\\nOnce we are clear that we are only looking at palindromes of length 3, we can look at the strings which have same left and right character and different/same middle character.\\nEg: aba, bbb\\n\\nGiven a string like badfrb -> the number of unique palindromes here can be calculated this way:\\n\\nGet me all unique characters between first b and last b -> 4\\nThis should be the same as number of unique palindromes.\\nRepeat the same for all unique characters with count >=2\\nLet us apply the above logic for the string: \"baccbdbaba\"\\n\\nUnique characters with frequency>=2 are b,a,c\\nGet all unique characters between first b and last b -> 4, between first c and last c -> 0 and between first s and last a -> 1\\nTotal unique palindromes = 4+0+1 = 5\\nComplexity:\\n\\nIterating over entire string for frequency - O(N)\\nGo over loop for every character with frequency >=2 - O(26)\\nO(Nk) where k is 26 but as 26 is a small constant -> O(N)\\n\\nOptimization:\\n\\nStarting positions of every repeating character can be stored in an array along with ending positions in another array to reduce looping over most part of the string in most cases.\\n\\nHere is the code for the same:\\n\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int[] freq = new int[26];\\n\\t\\t//having starting positions of characters in an array\\n        int[] starting = new int[26];\\n        Arrays.fill(starting, -1);\\n        char[] ch = s.toCharArray();\\n\\t\\t// considering only characters with freq >= 2\\n        Set<Character> required = new HashSet<>();\\n        for(int i=0; i<ch.length; i++){\\n            int c = ch[i]-\\'a\\';\\n            freq[c]++;\\n            if(freq[c]>=2)\\n                required.add(ch[i]);\\n            if(starting[c]==-1)\\n                starting[c] = i;\\n        }  \\n        int total = 0;\\n        for(Character ci: required){\\n            Set<Character> unique = new HashSet<>();\\n            int end = ch.length-1;\\n            for(end = ch.length-1; end>0; end--){\\n                if(ch[end]==ci)\\n                    break;\\n            }\\n            for(int i=starting[ci-\\'a\\']+1; i<end; i++){\\n                unique.add(ch[i]);\\n            }\\n            total += unique.size();\\n        }\\n        return total;\\n        \\n    }\\n\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int[] freq = new int[26];\\n\\t\\t//having starting positions of characters in an array\\n        int[] starting = new int[26];\\n        Arrays.fill(starting, -1);\\n        char[] ch = s.toCharArray();\\n\\t\\t// considering only characters with freq >= 2\\n        Set<Character> required = new HashSet<>();\\n        for(int i=0; i<ch.length; i++){\\n            int c = ch[i]-\\'a\\';\\n            freq[c]++;\\n            if(freq[c]>=2)\\n                required.add(ch[i]);\\n            if(starting[c]==-1)\\n                starting[c] = i;\\n        }  \\n        int total = 0;\\n        for(Character ci: required){\\n            Set<Character> unique = new HashSet<>();\\n            int end = ch.length-1;\\n            for(end = ch.length-1; end>0; end--){\\n                if(ch[end]==ci)\\n                    break;\\n            }\\n            for(int i=starting[ci-\\'a\\']+1; i<end; i++){\\n                unique.add(ch[i]);\\n            }\\n            total += unique.size();\\n        }\\n        return total;\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330731,
                "title": "javascript-binary-search",
                "content": "```javascript\\nvar countPalindromicSubsequence = function(s) {\\n    const charToIndices = {};\\n    for (let i = 0; i < s.length; i++) {\\n        const char = s[i];\\n        if (charToIndices[char]) {\\n            charToIndices[char].push(i);\\n        } else {\\n            charToIndices[char] = [i];\\n        }\\n    }\\n    \\n    let count = 0;\\n    for (const currChar in charToIndices) {\\n        if (charToIndices[currChar].length < 2) continue;\\n        const currCharIndices = charToIndices[currChar];\\n        const firstIndex = currCharIndices[0];\\n        const lastIndex = currCharIndices[currCharIndices.length - 1];\\n        \\n        for (const char in charToIndices) {\\n            const indices = charToIndices[char];\\n            let lo = 0;\\n            let hi = indices.length;\\n            while (lo < hi) {\\n                const mid = (lo + hi) >> 1;\\n                if (indices[mid] <= firstIndex) {\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid;\\n                }\\n            }\\n            if (indices[lo] && indices[lo] < lastIndex) {\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```javascript\\nvar countPalindromicSubsequence = function(s) {\\n    const charToIndices = {};\\n    for (let i = 0; i < s.length; i++) {\\n        const char = s[i];\\n        if (charToIndices[char]) {\\n            charToIndices[char].push(i);\\n        } else {\\n            charToIndices[char] = [i];\\n        }\\n    }\\n    \\n    let count = 0;\\n    for (const currChar in charToIndices) {\\n        if (charToIndices[currChar].length < 2) continue;\\n        const currCharIndices = charToIndices[currChar];\\n        const firstIndex = currCharIndices[0];\\n        const lastIndex = currCharIndices[currCharIndices.length - 1];\\n        \\n        for (const char in charToIndices) {\\n            const indices = charToIndices[char];\\n            let lo = 0;\\n            let hi = indices.length;\\n            while (lo < hi) {\\n                const mid = (lo + hi) >> 1;\\n                if (indices[mid] <= firstIndex) {\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid;\\n                }\\n            }\\n            if (indices[lo] && indices[lo] < lastIndex) {\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330641,
                "title": "c-solution-with-o-26-n-complexity",
                "content": "O(26*n) approach -> Finding sum of unique number of characters between the first and last occurrence of each alphabet. \\n\\nCode: \\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int res = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            char ch = (char)(i + \\'a\\');\\n            int ind1 = -1, ind2 = -1;\\n            for(int j = 0; j < s.length(); j++)\\n            {\\n                if(s[j] == ch)\\n                {\\n                    if(ind1 == -1)\\n                    {\\n                        ind1 = j;\\n                        ind2 = j;\\n                    }\\n                    else\\n                    {\\n                        ind2 = j;\\n                    }\\n                }\\n            }\\n            vector<bool> vis(26, false);\\n            int cntr = 0;\\n            if(ind1 == ind2)\\n                continue;\\n            for(int j = ind1+1; j < ind2; j++)\\n            {\\n                if(!vis[s[j]-\\'a\\'])\\n                {\\n                    cntr++;\\n                    vis[s[j]-\\'a\\'] = true;\\n                }\\n            }\\n            res += cntr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int res = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            char ch = (char)(i + \\'a\\');\\n            int ind1 = -1, ind2 = -1;\\n            for(int j = 0; j < s.length(); j++)\\n            {\\n                if(s[j] == ch)\\n                {\\n                    if(ind1 == -1)\\n                    {\\n                        ind1 = j;\\n                        ind2 = j;\\n                    }\\n                    else\\n                    {\\n                        ind2 = j;\\n                    }\\n                }\\n            }\\n            vector<bool> vis(26, false);\\n            int cntr = 0;\\n            if(ind1 == ind2)\\n                continue;\\n            for(int j = ind1+1; j < ind2; j++)\\n            {\\n                if(!vis[s[j]-\\'a\\'])\\n                {\\n                    cntr++;\\n                    vis[s[j]-\\'a\\'] = true;\\n                }\\n            }\\n            res += cntr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330632,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n            \\n        int n=s.length(),cnt=0;\\n        vector<int> first(26,n);\\n        vector<int> last(26);\\n            \\n        for(int i=0;i<n;i++){\\n            first[s[i]-\\'a\\']=min(first[s[i]-\\'a\\'],i);\\n            last[s[i]-\\'a\\']=i;\\n        } \\n    \\n        unordered_set<char> se;   \\n        for(int i=0;i<26;i++){\\n          if(first[i]<last[i]){\\n            for(int j=first[i]+1;j<last[i];j++){     \\n                 if(!se.count(s[j]))cnt++,se.insert(s[j]);\\n            }\\n            se.clear();\\n          }    \\n        }  \\n            \\nreturn cnt;            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n            \\n        int n=s.length(),cnt=0;\\n        vector<int> first(26,n);\\n        vector<int> last(26);\\n            \\n        for(int i=0;i<n;i++){\\n            first[s[i]-\\'a\\']=min(first[s[i]-\\'a\\'],i);\\n            last[s[i]-\\'a\\']=i;\\n        } \\n    \\n        unordered_set<char> se;   \\n        for(int i=0;i<26;i++){\\n          if(first[i]<last[i]){\\n            for(int j=first[i]+1;j<last[i];j++){     \\n                 if(!se.count(s[j]))cnt++,se.insert(s[j]);\\n            }\\n            se.clear();\\n          }    \\n        }  \\n            \\nreturn cnt;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330536,
                "title": "javascript-o-26-n-easy-to-understand",
                "content": "The palindrome of length 3 must be in the form like **ABA**, which means that the start character and the end character of the palindrome must be the same, while the character in the middle can be anything.\\n\\nTherefore, we can simply loop through \\'a\\' - \\'z\\'  to be our canditate of start character and end character (meaning we are finding palindromes like *a?a, b?b, c?c .... z?z* ), and for each canditate, count the distinct characters that can be placed in the middle.\\n\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    let lowercaseChars = [];\\n    for(let i = 0; i < 26; i++) {\\n        lowercaseChars.push(String.fromCharCode(\\'a\\'.charCodeAt(0) + i));\\n    }\\n    \\n    let count = 0;\\n    lowercaseChars.forEach(ch => {\\n        let set = new Set();\\n        const start = s.indexOf(ch);\\n        const end = s.lastIndexOf(ch);\\n        if(start!==end && start !== -1) {\\n            for(let i = start+1; i < end ; i++) {\\n                if(!set.has(s[i])) {\\n                    set.add(s[i]);\\n                    count++;\\n                }\\n            }\\n        }\\n    })\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    let lowercaseChars = [];\\n    for(let i = 0; i < 26; i++) {\\n        lowercaseChars.push(String.fromCharCode(\\'a\\'.charCodeAt(0) + i));\\n    }\\n    \\n    let count = 0;\\n    lowercaseChars.forEach(ch => {\\n        let set = new Set();\\n        const start = s.indexOf(ch);\\n        const end = s.lastIndexOf(ch);\\n        if(start!==end && start !== -1) {\\n            for(let i = start+1; i < end ; i++) {\\n                if(!set.has(s[i])) {\\n                    set.add(s[i]);\\n                    count++;\\n                }\\n            }\\n        }\\n    })\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330358,
                "title": "simplest-approach-using-set-java",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int count = 0;\\n        for (char c = \\'a\\'; c <= \\'z\\'; ++c) {\\n            int l = s.indexOf(c);\\n            int r = s.lastIndexOf(c);\\n            Set<Character> map = new HashSet<>();\\n            for (int i = l + 1; i < r; ++i) {\\n                map.add(s.charAt(i));\\n            }\\n            if (l != -1) {\\n                count += map.size();\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int count = 0;\\n        for (char c = \\'a\\'; c <= \\'z\\'; ++c) {\\n            int l = s.indexOf(c);\\n            int r = s.lastIndexOf(c);\\n            Set<Character> map = new HashSet<>();\\n            for (int i = l + 1; i < r; ++i) {\\n                map.add(s.charAt(i));\\n            }\\n            if (l != -1) {\\n                count += map.size();\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330345,
                "title": "python-solution-100-faster",
                "content": "```\\ndef countPalindromicSubsequence(s: str) -> int:\\n    count = 0\\n    sub_str = list(set(s))\\n    for x in sub_str:\\n        i, j = s.find(x), s.rfind(x)\\n\\n        if i < j:\\n            count += len(set(s[i + 1:j]))\\n\\n    return count\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countPalindromicSubsequence(s: str) -> int:\\n    count = 0\\n    sub_str = list(set(s))\\n    for x in sub_str:\\n        i, j = s.find(x), s.rfind(x)\\n\\n        if i < j:\\n            count += len(set(s[i + 1:j]))\\n\\n    return count\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1330310,
                "title": "java-o-26-26-n",
                "content": "\\n```\\npublic int countPalindromicSubsequence(String s) {\\n        int ans=0;\\n        int n = s.length();\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                int flag=0;\\n                for(int k=0;k<s.length();k++){\\n                    if(flag==0){\\n                        if((int)s.charAt(k)-97==i){\\n                            flag++;\\n                        }\\n                    }\\n                    else if(flag==1){\\n                        if((int)s.charAt(k)-97==j){\\n                            flag++;\\n                        }\\n                    }\\n                    else if(flag==2){\\n                        if((int)s.charAt(k)-97==i){\\n                            flag++;\\n                        }\\n                    }\\n                }\\n                if(flag==3)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\n```\\npublic int countPalindromicSubsequence(String s) {\\n        int ans=0;\\n        int n = s.length();\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                int flag=0;\\n                for(int k=0;k<s.length();k++){\\n                    if(flag==0){\\n                        if((int)s.charAt(k)-97==i){\\n                            flag++;\\n                        }\\n                    }\\n                    else if(flag==1){\\n                        if((int)s.charAt(k)-97==j){\\n                            flag++;\\n                        }\\n                    }\\n                    else if(flag==2){\\n                        if((int)s.charAt(k)-97==i){\\n                            flag++;\\n                        }\\n                    }\\n                }\\n                if(flag==3)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1330273,
                "title": "java-easy-left-right-and-inbetween",
                "content": "class Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        \\n        //store first and last occ of each element\\n        HashMap<Character,pair> map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(!map.containsKey(ch)){\\n                map.put(ch,new pair(i,-1));\\n            }\\n            else{\\n                pair rp=map.get(ch);\\n                map.put(ch,new pair(rp.si,i));\\n            }\\n        }\\n        \\n        //traverse on map \\n        for(char ch:map.keySet()){\\n            pair rp=map.get(ch);\\n            if(rp.ei==-1){  //if char appears only once\\n                continue;\\n            }\\n            \\n            //store unique charaters between si and ei and add that into the count\\n            HashSet<Character> set=new HashSet<>();\\n            for(int i=rp.si+1;i<rp.ei;i++){\\n                set.add(s.charAt(i));\\n            }\\n            count+=set.size();\\n        }\\n        return count;\\n    }\\n}\\n\\n\\t\\tclass pair{\\n\\t\\t\\tint si;\\n\\t\\t\\tint ei;\\n\\t\\t\\tpair(int si,int ei){\\n\\t\\t\\t\\tthis.si=si;\\n\\t\\t\\t\\tthis.ei=ei;\\n\\t\\t\\t}\\n    }",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        \\n        //store first and last occ of each element\\n        HashMap<Character,pair> map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(!map.containsKey(ch)){\\n                map.put(ch,new pair(i,-1));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1330207,
                "title": "python-3-one-line",
                "content": "Basic idea:\\n```python\\nclass Solution:\\n  def countPalindromicSubsequence(self, s: str) -> int:\\n    total = 0\\n    for a in ascii_lowercase:\\n      i, j = s.find(a), s.rfind(a)\\n      if i < j:\\n        total += len(set(s[i+1:j]))\\n    return total\\n```\\n\\nIn one not terribly efficient line:\\n\\n```python\\nclass Solution:\\n  def countPalindromicSubsequence(self, s: str) -> int:\\n    return sum(len(set(s[s.find(a)+1:s.rfind(a)])) for a in ascii_lowercase if s.find(a) < s.rfind(a))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def countPalindromicSubsequence(self, s: str) -> int:\\n    total = 0\\n    for a in ascii_lowercase:\\n      i, j = s.find(a), s.rfind(a)\\n      if i < j:\\n        total += len(set(s[i+1:j]))\\n    return total\\n```\n```python\\nclass Solution:\\n  def countPalindromicSubsequence(self, s: str) -> int:\\n    return sum(len(set(s[s.find(a)+1:s.rfind(a)])) for a in ascii_lowercase if s.find(a) < s.rfind(a))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330204,
                "title": "c-super-simple-solution-using-unordered-map-with-comments",
                "content": "```\\n    int countPalindromicSubsequence(string s) {\\n        \\n        //Get the positions of each char in the map.\\n        unordered_map<char, vector<int>> cmap;        \\n        for(int i = 0; i < s.size(); i++){\\n            cmap[s[i]].push_back(i);\\n        }\\n        \\n        int count = 0;\\n        \\n        for(auto cm: cmap){\\n            //If atleast there are two similar char present\\n            if(cm.second.size() <= 1)\\n                continue;\\n            \\n            //First and last char\\n            int f = cm.second[0];\\n            int l = cm.second[cm.second.size()-1];            \\n            \\n            \\n            //Find all unique char which are within the first and last char boundary\\n            for(auto tm: cmap){                    \\n                auto v = tm.second;\\n                if( upper_bound(v.begin(), v.end(), f) != v.end() && *upper_bound(v.begin(), v.end(), f) < l)\\n                    count++;                \\n            }            \\n        }\\n        \\n        return count;        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int countPalindromicSubsequence(string s) {\\n        \\n        //Get the positions of each char in the map.\\n        unordered_map<char, vector<int>> cmap;        \\n        for(int i = 0; i < s.size(); i++){\\n            cmap[s[i]].push_back(i);\\n        }\\n        \\n        int count = 0;\\n        \\n        for(auto cm: cmap){\\n            //If atleast there are two similar char present\\n            if(cm.second.size() <= 1)\\n                continue;\\n            \\n            //First and last char\\n            int f = cm.second[0];\\n            int l = cm.second[cm.second.size()-1];            \\n            \\n            \\n            //Find all unique char which are within the first and last char boundary\\n            for(auto tm: cmap){                    \\n                auto v = tm.second;\\n                if( upper_bound(v.begin(), v.end(), f) != v.end() && *upper_bound(v.begin(), v.end(), f) < l)\\n                    count++;                \\n            }            \\n        }\\n        \\n        return count;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330198,
                "title": "o-26-n-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int k = 26,n=s.length();\\n        vector<vector<int>>v(k,vector<int>(k,0));\\n        vector<int>fi(k,-1);\\n        vector<int>li(k,-1);\\n        for(int i=0;i<n;i++){\\n            li[s[i]-\\'a\\']=i;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            fi[s[i]-\\'a\\']=i;\\n        }\\n        for(int c=0;c<26;c++){\\n            for(int i=0;i<n;i++){\\n                if(i>fi[c] && i<li[c]){\\n                    v[c][s[i]-\\'a\\']++;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int c=0;c<26;c++){\\n            for(int cc=0;cc<26;cc++){ \\n                if(v[c][cc]>0)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int k = 26,n=s.length();\\n        vector<vector<int>>v(k,vector<int>(k,0));\\n        vector<int>fi(k,-1);\\n        vector<int>li(k,-1);\\n        for(int i=0;i<n;i++){\\n            li[s[i]-\\'a\\']=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1330132,
                "title": "a-few-solutions",
                "content": "We can use two maps `beg` and `end` which track the first (left-most) and last (right-most) index of each character `c` of the input string `s` correspondingly.  Let `i` and `j` be the first and last index of the character `c`, Then we are only interested in counting the unique characters `x = s[k]` where `i < k < j` to formulate unique 3mers.  Return the cardinality of the unique 3mers set `kmers`.\\n\\n---\\n\\n**Optimized Solutions:** accumulate the count `cnt` of unique `x = s[k]` where `i < k < j` and `s[i] == s[j]` and `i, j` are the left-most and right-most indices correspondingly of each unique `c` in `s`.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countPalindromicSubsequence(s: String): Int {\\n        var cnt = 0\\n        var (beg, end) = listOf(mutableMapOf<Char, Int>(), mutableMapOf<Char, Int>())\\n        for (i in 0 until s.length) {\\n            var c = s[i]\\n            if (!beg.contains(c))\\n                beg[c] = i\\n            end[c] = i\\n        }\\n        for (c in s.toSet()) {\\n            var (i, j) = listOf(beg[c]!!, end[c]!!)\\n            if (i == j || i + 1 == j)\\n                continue\\n            cnt += s.substring(i + 1, j).toSet().size\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countPalindromicSubsequence = (s, beg = new Map(), end = new Map(), cnt = 0) => {\\n    for (let i = 0; i < s.length; ++i) {\\n        let c = s[i];\\n        if (!beg.has(c))\\n            beg.set(c, i);\\n        end.set(c, i);\\n    }\\n    for (let c of new Set(s)) {\\n        let [i, j] = [beg.get(c), end.get(c)];\\n        if (i == j || i + 1 == j)\\n            continue;\\n        cnt += new Set(s.substring(i + 1, j)).size;\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str, cnt = 0) -> int:\\n        kmers = set()\\n        beg, end = {}, {}\\n        for i in range(len(s)):\\n            c = s[i]\\n            if c not in beg:\\n                beg[c] = i\\n            end[c] = i\\n        for c in set(s):\\n            i, j = beg[c], end[c]\\n            if i == j or i + 1 == j:\\n                continue\\n            cnt += len(set(s[i + 1:j]))\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    using Set = unordered_set<string>;\\n    using Unique = unordered_set<char>;\\n    int countPalindromicSubsequence(string s, Map beg = {}, Map end = {}, int cnt = 0) {\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto c = s[i];\\n            if (beg.find(c) == beg.end())\\n                beg[c] = i;\\n            end[c] = i;\\n        }\\n        for (auto c: Unique{ s.begin(), s.end() }) {\\n            auto [i, j] = tie(beg[c], end[c]);\\n            if (i == j || i + 1 == j)\\n                continue;\\n            cnt += Unique{ s.begin() + i + 1, s.begin() + j }.size();\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---\\n\\n**Original Solutions:** formulate unique 3mers.  Return the cardinality of the unique 3mers set `kmers`.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countPalindromicSubsequence(s: String): Int {\\n        var kmers = mutableSetOf<String>()\\n        var (beg, end) = listOf(mutableMapOf<Char, Int>(), mutableMapOf<Char, Int>())\\n        for (i in 0 until s.length) {\\n            var c = s[i]\\n            if (!beg.contains(c))\\n                beg[c] = i\\n            end[c] = i\\n        }\\n        for (c in s.toSet()) {\\n            var (i, j) = listOf(beg[c]!!, end[c]!!)\\n            if (i == j || i + 1 == j)\\n                continue\\n            var chars = mutableSetOf<Char>()\\n            var k = i + 1;\\n            while (k < j)\\n                chars.add(s[k++])\\n            for (x in chars)\\n                kmers.add(\"${s[i]}$x${s[j]}\")\\n        }\\n        return kmers.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countPalindromicSubsequence = (s, beg = new Map(), end = new Map(), kmers = new Set()) => {\\n    for (let i = 0; i < s.length; ++i) {\\n        let c = s[i];\\n        if (!beg.has(c))\\n            beg.set(c, i);\\n        end.set(c, i);\\n    }\\n    let cand = [];\\n    for (let c of new Set(s)) {\\n        let [i, j] = [beg.get(c), end.get(c)];\\n        if (i == j || i + 1 == j)\\n            continue;\\n        let unique = new Set();\\n        let k = i + 1;\\n        while (k < j)\\n            unique.add(s[k++]);\\n        for (let x of unique)\\n            kmers.add(`${s[i]}${x}${s[j]}`);\\n    }\\n    return kmers.size;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        kmers = set()\\n        beg, end = {}, {}\\n        for i in range(len(s)):\\n            c = s[i]\\n            if c not in beg:\\n                beg[c] = i\\n            end[c] = i\\n        for c in set(s):\\n            i, j = beg[c], end[c]\\n            if i == j or i + 1 == j:\\n                continue\\n            chars = set()\\n            k = i + 1\\n            while k < j:\\n                chars.add(s[k]); k += 1\\n            for x in chars:\\n                kmers.add(f\\'{s[i]}{x}{s[j]}\\')\\n        return len(kmers)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    using Set = unordered_set<string>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Unique = unordered_set<char>;\\n    int countPalindromicSubsequence(string s, Map beg = {}, Map end = {}, Set kmers = {}) {\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto c = s[i];\\n            if (beg.find(c) == beg.end())\\n                beg[c] = i;\\n            end[c] = i;\\n        }\\n        for (auto c: Unique{ s.begin(), s.end() }) {\\n            auto [i, j] = tie(beg[c], end[c]);\\n            if (i == j || i + 1 == j)\\n                continue;\\n            Unique chars;\\n            auto k = i + 1;\\n            while (k < j)\\n                chars.insert(s[k++]);\\n            for (auto x: chars) {\\n                stringstream ss; ss << s[i] << x << s[j];\\n                kmers.insert(ss.str());\\n            }\\n        }\\n        return kmers.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countPalindromicSubsequence(s: String): Int {\\n        var cnt = 0\\n        var (beg, end) = listOf(mutableMapOf<Char, Int>(), mutableMapOf<Char, Int>())\\n        for (i in 0 until s.length) {\\n            var c = s[i]\\n            if (!beg.contains(c))\\n                beg[c] = i\\n            end[c] = i\\n        }\\n        for (c in s.toSet()) {\\n            var (i, j) = listOf(beg[c]!!, end[c]!!)\\n            if (i == j || i + 1 == j)\\n                continue\\n            cnt += s.substring(i + 1, j).toSet().size\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countPalindromicSubsequence = (s, beg = new Map(), end = new Map(), cnt = 0) => {\\n    for (let i = 0; i < s.length; ++i) {\\n        let c = s[i];\\n        if (!beg.has(c))\\n            beg.set(c, i);\\n        end.set(c, i);\\n    }\\n    for (let c of new Set(s)) {\\n        let [i, j] = [beg.get(c), end.get(c)];\\n        if (i == j || i + 1 == j)\\n            continue;\\n        cnt += new Set(s.substring(i + 1, j)).size;\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str, cnt = 0) -> int:\\n        kmers = set()\\n        beg, end = {}, {}\\n        for i in range(len(s)):\\n            c = s[i]\\n            if c not in beg:\\n                beg[c] = i\\n            end[c] = i\\n        for c in set(s):\\n            i, j = beg[c], end[c]\\n            if i == j or i + 1 == j:\\n                continue\\n            cnt += len(set(s[i + 1:j]))\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    using Set = unordered_set<string>;\\n    using Unique = unordered_set<char>;\\n    int countPalindromicSubsequence(string s, Map beg = {}, Map end = {}, int cnt = 0) {\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto c = s[i];\\n            if (beg.find(c) == beg.end())\\n                beg[c] = i;\\n            end[c] = i;\\n        }\\n        for (auto c: Unique{ s.begin(), s.end() }) {\\n            auto [i, j] = tie(beg[c], end[c]);\\n            if (i == j || i + 1 == j)\\n                continue;\\n            cnt += Unique{ s.begin() + i + 1, s.begin() + j }.size();\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun countPalindromicSubsequence(s: String): Int {\\n        var kmers = mutableSetOf<String>()\\n        var (beg, end) = listOf(mutableMapOf<Char, Int>(), mutableMapOf<Char, Int>())\\n        for (i in 0 until s.length) {\\n            var c = s[i]\\n            if (!beg.contains(c))\\n                beg[c] = i\\n            end[c] = i\\n        }\\n        for (c in s.toSet()) {\\n            var (i, j) = listOf(beg[c]!!, end[c]!!)\\n            if (i == j || i + 1 == j)\\n                continue\\n            var chars = mutableSetOf<Char>()\\n            var k = i + 1;\\n            while (k < j)\\n                chars.add(s[k++])\\n            for (x in chars)\\n                kmers.add(\"${s[i]}$x${s[j]}\")\\n        }\\n        return kmers.size\\n    }\\n}\\n```\n```\\nlet countPalindromicSubsequence = (s, beg = new Map(), end = new Map(), kmers = new Set()) => {\\n    for (let i = 0; i < s.length; ++i) {\\n        let c = s[i];\\n        if (!beg.has(c))\\n            beg.set(c, i);\\n        end.set(c, i);\\n    }\\n    let cand = [];\\n    for (let c of new Set(s)) {\\n        let [i, j] = [beg.get(c), end.get(c)];\\n        if (i == j || i + 1 == j)\\n            continue;\\n        let unique = new Set();\\n        let k = i + 1;\\n        while (k < j)\\n            unique.add(s[k++]);\\n        for (let x of unique)\\n            kmers.add(`${s[i]}${x}${s[j]}`);\\n    }\\n    return kmers.size;\\n};\\n```\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        kmers = set()\\n        beg, end = {}, {}\\n        for i in range(len(s)):\\n            c = s[i]\\n            if c not in beg:\\n                beg[c] = i\\n            end[c] = i\\n        for c in set(s):\\n            i, j = beg[c], end[c]\\n            if i == j or i + 1 == j:\\n                continue\\n            chars = set()\\n            k = i + 1\\n            while k < j:\\n                chars.add(s[k]); k += 1\\n            for x in chars:\\n                kmers.add(f\\'{s[i]}{x}{s[j]}\\')\\n        return len(kmers)\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    using Set = unordered_set<string>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Unique = unordered_set<char>;\\n    int countPalindromicSubsequence(string s, Map beg = {}, Map end = {}, Set kmers = {}) {\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto c = s[i];\\n            if (beg.find(c) == beg.end())\\n                beg[c] = i;\\n            end[c] = i;\\n        }\\n        for (auto c: Unique{ s.begin(), s.end() }) {\\n            auto [i, j] = tie(beg[c], end[c]);\\n            if (i == j || i + 1 == j)\\n                continue;\\n            Unique chars;\\n            auto k = i + 1;\\n            while (k < j)\\n                chars.insert(s[k++]);\\n            for (auto x: chars) {\\n                stringstream ss; ss << s[i] << x << s[j];\\n                kmers.insert(ss.str());\\n            }\\n        }\\n        return kmers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4106940,
                "title": "java",
                "content": "**Approach**:\\n\\nThe approach used in this code is to find the number of distinct palindromic subsequences that can be formed from the given string `s`. To do this, the code iterates through each lowercase letter of the English alphabet (\\'a\\' to \\'z\\') and finds the first and last occurrences of that letter in the string `s`. If the letter is not present in the string or if its first and last occurrences are the same, it continues to the next letter. Otherwise, it extracts a substring from `s` that lies between the first and last occurrences of the letter.\\n\\nFor each extracted substring, the code again iterates through each lowercase letter (\\'a\\' to \\'z\\') and checks if that letter is present in the substring. If it is, the count is incremented. Finally, the code returns the total count of distinct palindromic subsequences that can be formed.\\n\\n**Intuition**:\\n\\n1. The code first iterates through each letter of the English alphabet to find the first and last occurrences of that letter in the given string `s`. This is done to identify potential substrings that can be used to form palindromic subsequences.\\n\\n2. For each potential substring, the code again iterates through each letter of the English alphabet to check if that letter is present in the substring. If it is, this indicates that a palindromic subsequence can be formed using the current letter along with the potential substring.\\n\\n3. By counting such subsequences for all letters and potential substrings, the code computes the total count of distinct palindromic subsequences that can be formed from the input string `s`.\\n\\n**Complexity**:\\n\\n- Time Complexity: \\n  - The code iterates through the English alphabet, which has 26 letters. For each letter, it performs operations such as `indexOf` and `lastIndexOf` on the input string `s` to find the first and last occurrences of the letter, and then it extracts a substring. The `indexOf` and `lastIndexOf` operations take O(n) time in the worst case, where n is the length of the input string.\\n  - For each potential substring, the code iterates through the English alphabet again, performing the `indexOf` operation, which can also take O(n) time.\\n  - Therefore, the overall time complexity of the code is O(26 * n * 26) \\u2248 O(n).\\n\\n- Space Complexity: \\n  - The code uses a few variables to store indices and characters, which require a constant amount of space.\\n  - The most significant space usage comes from the substrings created. In the worst case, the substrings could collectively have a size of O(n).\\n  - Therefore, the overall space complexity of the code is O(n).\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        \\n         int count = 0;\\n         for(int i=0; i<=25; i++) {\\n             char c = (char)(\\'a\\' + i);\\n             int first = s.indexOf(c);\\n             int last = s.lastIndexOf(c);\\n             if(first==-1 || last ==-1) continue;\\n             if(first==last) continue;\\n             String sub = s.substring(first+1, last);\\n             for(int j=0; j<=25; j++) {\\n                 char ch = (char)(\\'a\\' + j);\\n                 int ind = sub.indexOf(ch);\\n                 if(ind != -1) count++;\\n             }\\n         }\\n         return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        \\n         int count = 0;\\n         for(int i=0; i<=25; i++) {\\n             char c = (char)(\\'a\\' + i);\\n             int first = s.indexOf(c);\\n             int last = s.lastIndexOf(c);\\n             if(first==-1 || last ==-1) continue;\\n             if(first==last) continue;\\n             String sub = s.substring(first+1, last);\\n             for(int j=0; j<=25; j++) {\\n                 char ch = (char)(\\'a\\' + j);\\n                 int ind = sub.indexOf(ch);\\n                 if(ind != -1) count++;\\n             }\\n         }\\n         return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099916,
                "title": "1500-ms-c-o-26-n-solution-t-t",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string a) {\\n        unordered_map<string, int>m;\\n\\n        int n=a.size(), ans=0;\\n        vector<vector<int>>left(n,vector<int>(26,0));\\n        vector<vector<int>>right(n,vector<int>(26,0));\\n\\n        for(int i=1;i<n;i++){\\n            left[i]=left[i-1];\\n            left[i][a[i-1]-\\'a\\']++;\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=right[i+1];\\n            right[i][a[i+1]-\\'a\\']++;\\n        }\\n\\n        for(int i=1;i<n-1;i++){\\n            for(int j=0;j<26;j++){\\n                if(left[i][j]>0 && right[i][j]>0){\\n                    char lc = \\'a\\'+j;\\n                    char mid = a[i];\\n                    string key;\\n                    key.push_back(lc);\\n                    key.push_back(mid);\\n                    // cout<<key<<endl;\\n                    if(m.count(key))continue;\\n                    else{\\n                        m[key]=1;\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string a) {\\n        unordered_map<string, int>m;\\n\\n        int n=a.size(), ans=0;\\n        vector<vector<int>>left(n,vector<int>(26,0));\\n        vector<vector<int>>right(n,vector<int>(26,0));\\n\\n        for(int i=1;i<n;i++){\\n            left[i]=left[i-1];\\n            left[i][a[i-1]-\\'a\\']++;\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=right[i+1];\\n            right[i][a[i+1]-\\'a\\']++;\\n        }\\n\\n        for(int i=1;i<n-1;i++){\\n            for(int j=0;j<26;j++){\\n                if(left[i][j]>0 && right[i][j]>0){\\n                    char lc = \\'a\\'+j;\\n                    char mid = a[i];\\n                    string key;\\n                    key.push_back(lc);\\n                    key.push_back(mid);\\n                    // cout<<key<<endl;\\n                    if(m.count(key))continue;\\n                    else{\\n                        m[key]=1;\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4099656,
                "title": "c-hash-map-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n       vector<int>l(26,0), r(26,0);\\n        unordered_set<string> vis;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            r[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            r[s[i]-\\'a\\']--;\\n            for(int j=0; j<26; j++)\\n            {\\n                if(l[j]>0 && r[j]>0)\\n                {\\n                    char ch=j+\\'a\\';\\n                    string curr=\"\";\\n                    curr+=ch;\\n                    curr+=s[i];\\n                    curr+=ch;\\n                    vis.insert(curr);\\n                }\\n            }\\n            l[s[i]-\\'a\\']++;\\n        }\\n        return vis.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n       vector<int>l(26,0), r(26,0);\\n        unordered_set<string> vis;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            r[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            r[s[i]-\\'a\\']--;\\n            for(int j=0; j<26; j++)\\n            {\\n                if(l[j]>0 && r[j]>0)\\n                {\\n                    char ch=j+\\'a\\';\\n                    string curr=\"\";\\n                    curr+=ch;\\n                    curr+=s[i];\\n                    curr+=ch;\\n                    vis.insert(curr);\\n                }\\n            }\\n            l[s[i]-\\'a\\']++;\\n        }\\n        return vis.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094011,
                "title": "c-hash-table",
                "content": "# Code\\n```\\n// Prefix Sum + Hash Table\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0, n = s.length();\\n        vector<vector<int>> prefix(26, vector<int>(n + 1));\\n        vector<int> firstInd(26, n - 1), lastInd(26, 0);\\n        for(int i = 0; i < n; i++) {\\n            firstInd[s[i] - \\'a\\'] = min(firstInd[s[i] - \\'a\\'], i);\\n            lastInd[s[i] - \\'a\\'] = i;\\n            prefix[s[i] - \\'a\\'][i + 1]++;\\n            for(int j = 0; j < 26; j++) {\\n                prefix[j][i + 1] += prefix[j][i];\\n            }\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                ans += (prefix[j][lastInd[i]] > prefix[j][firstInd[i] + 1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nOR\\n\\n\\n// Hash Table\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0, n = s.length();\\n        vector<int> firstInd(26, n - 1), lastInd(26, 0);\\n        for(int i = 0; i < n; i++) {\\n            firstInd[s[i] - \\'a\\'] = min(firstInd[s[i] - \\'a\\'], i);\\n            lastInd[s[i] - \\'a\\'] = i;\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            ans += firstInd[i] < lastInd[i]? unordered_set<char>(s.begin() + firstInd[i] + 1, s.begin() + lastInd[i]).size(): 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\n// Prefix Sum + Hash Table\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0, n = s.length();\\n        vector<vector<int>> prefix(26, vector<int>(n + 1));\\n        vector<int> firstInd(26, n - 1), lastInd(26, 0);\\n        for(int i = 0; i < n; i++) {\\n            firstInd[s[i] - \\'a\\'] = min(firstInd[s[i] - \\'a\\'], i);\\n            lastInd[s[i] - \\'a\\'] = i;\\n            prefix[s[i] - \\'a\\'][i + 1]++;\\n            for(int j = 0; j < 26; j++) {\\n                prefix[j][i + 1] += prefix[j][i];\\n            }\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                ans += (prefix[j][lastInd[i]] > prefix[j][firstInd[i] + 1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nOR\\n\\n\\n// Hash Table\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int ans = 0, n = s.length();\\n        vector<int> firstInd(26, n - 1), lastInd(26, 0);\\n        for(int i = 0; i < n; i++) {\\n            firstInd[s[i] - \\'a\\'] = min(firstInd[s[i] - \\'a\\'], i);\\n            lastInd[s[i] - \\'a\\'] = i;\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            ans += firstInd[i] < lastInd[i]? unordered_set<char>(s.begin() + firstInd[i] + 1, s.begin() + lastInd[i]).size(): 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080074,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        ans = 0\\n        used = {}\\n        left = Counter(s[:1])\\n        right = Counter(s[1:])\\n\\n        for i in range(1, len(s)-1):\\n            right[s[i]] = right.get(s[i], 1) - 1\\n            for j in left.keys():\\n                if left.get(j) and right.get(j):\\n                    if not used.get(j+s[i]+j, 0):\\n                        ans += 1\\n                        used[j+s[i]+j] = 1\\n            left[s[i]] = 1 + left.get(s[i], 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        ans = 0\\n        used = {}\\n        left = Counter(s[:1])\\n        right = Counter(s[1:])\\n\\n        for i in range(1, len(s)-1):\\n            right[s[i]] = right.get(s[i], 1) - 1\\n            for j in left.keys():\\n                if left.get(j) and right.get(j):\\n                    if not used.get(j+s[i]+j, 0):\\n                        ans += 1\\n                        used[j+s[i]+j] = 1\\n            left[s[i]] = 1 + left.get(s[i], 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075961,
                "title": "perfect",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int count = 0;\\n        int n = s.length();\\n        \\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            int firstOccurrence = -1;\\n            int lastOccurrence = -1;\\n            \\n            for (int i = 0; i < n; i++) {\\n                if (s.charAt(i) == c) {\\n                    if (firstOccurrence == -1) {\\n                        firstOccurrence = i;\\n                    }\\n                    lastOccurrence = i;\\n                }\\n            }\\n            \\n            if (firstOccurrence != -1 && lastOccurrence != -1 && lastOccurrence - firstOccurrence >= 2) {\\n                HashSet<Character> uniqueChars = new HashSet<>();\\n                \\n                for (int i = firstOccurrence + 1; i < lastOccurrence; i++) {\\n                    uniqueChars.add(s.charAt(i));\\n                }\\n                \\n                count += uniqueChars.size();\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int count = 0;\\n        int n = s.length();\\n        \\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            int firstOccurrence = -1;\\n            int lastOccurrence = -1;\\n            \\n            for (int i = 0; i < n; i++) {\\n                if (s.charAt(i) == c) {\\n                    if (firstOccurrence == -1) {\\n                        firstOccurrence = i;\\n                    }\\n                    lastOccurrence = i;\\n                }\\n            }\\n            \\n            if (firstOccurrence != -1 && lastOccurrence != -1 && lastOccurrence - firstOccurrence >= 2) {\\n                HashSet<Character> uniqueChars = new HashSet<>();\\n                \\n                for (int i = firstOccurrence + 1; i < lastOccurrence; i++) {\\n                    uniqueChars.add(s.charAt(i));\\n                }\\n                \\n                count += uniqueChars.size();\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074392,
                "title": "java-100-beats-10ms-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Computes at most 26*n, it is O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1), if we consider charArray as given one\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        char[] c = s.toCharArray();\\n        boolean[] v = new boolean[128];\\n        int a=0, t=0;\\n\\n        int l, r;\\n        for(char x=\\'a\\'; x<=\\'z\\'; x++){\\n            for(l=0; l<c.length && c[l]!=x; l++);\\n            if(l==c.length)continue;\\n            for(r=c.length-1; r>=0 && c[r]!=x; r--);\\n            if(l>=r)continue;\\n\\n            Arrays.fill(v, false); t=0;\\n            for(int i=l+1; i<r; i++){\\n                if(!v[c[i]]){\\n                    v[c[i]]=true; t++;\\n                    if(t==26)break;\\n                }\\n            }\\n            a+=t;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        char[] c = s.toCharArray();\\n        boolean[] v = new boolean[128];\\n        int a=0, t=0;\\n\\n        int l, r;\\n        for(char x=\\'a\\'; x<=\\'z\\'; x++){\\n            for(l=0; l<c.length && c[l]!=x; l++);\\n            if(l==c.length)continue;\\n            for(r=c.length-1; r>=0 && c[r]!=x; r--);\\n            if(l>=r)continue;\\n\\n            Arrays.fill(v, false); t=0;\\n            for(int i=l+1; i<r; i++){\\n                if(!v[c[i]]){\\n                    v[c[i]]=true; t++;\\n                    if(t==26)break;\\n                }\\n            }\\n            a+=t;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070986,
                "title": "python-solution-o-n-2",
                "content": "# Intuition\\n\\n# Approach\\nFind list lowest index and highest of same characters and then search between them.\\n\\n# Complexity\\n- Time complexity:\\nO(n**2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n        map_char = {}\\n        count = 0\\n        pal_set = set()\\n        for i in range(len(s)):\\n            if s[i] in map_char:\\n                # insert lowest,highest indexes\\n                map_char[s[i]][0]= min(i,map_char[s[i]][0])\\n                map_char[s[i]][1]= max(i,map_char[s[i]][1])\\n            else:\\n                map_char[s[i]] = [i, i]\\n        # look for values in between\\n        for v in map_char.values():\\n             if v[0] != v[1]:\\n                curr = v[0] + 1\\n                while curr < v[1]:\\n                    if s[v[0]]+s[curr]+s[v[0]] not in pal_set:\\n                        pal_set.add(s[v[0]]+s[curr]+s[v[0]])\\n                    curr += 1\\n        return len(pal_set)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n        map_char = {}\\n        count = 0\\n        pal_set = set()\\n        for i in range(len(s)):\\n            if s[i] in map_char:\\n                # insert lowest,highest indexes\\n                map_char[s[i]][0]= min(i,map_char[s[i]][0])\\n                map_char[s[i]][1]= max(i,map_char[s[i]][1])\\n            else:\\n                map_char[s[i]] = [i, i]\\n        # look for values in between\\n        for v in map_char.values():\\n             if v[0] != v[1]:\\n                curr = v[0] + 1\\n                while curr < v[1]:\\n                    if s[v[0]]+s[curr]+s[v[0]] not in pal_set:\\n                        pal_set.add(s[v[0]]+s[curr]+s[v[0]])\\n                    curr += 1\\n        return len(pal_set)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057534,
                "title": "intuitive-with-o-26n-tc",
                "content": "```\\nclass Solution {\\n    \\n    public int countDistinctElement(int l, int r, String s) {\\n        int []freq = new int[26];\\n        int cnt = 0;\\n        for(int i=l+1; i<r; i++) {\\n            int d = s.charAt(i) - \\'a\\';\\n            freq[d] += 1;\\n            if(freq[d] == 1) cnt += 1;\\n        }\\n        return cnt;\\n    }\\n    \\n    public int countPalindromicSubsequence(String s) {\\n        int len = s.length();\\n        Map<Integer, int[]> store = new HashMap<>();\\n        for(int i=0; i<26; i++) {\\n            store.put(i, new int[]{len, -1});\\n        }\\n        int index = 0;\\n        for(char ch : s.toCharArray()) {\\n            int []val = store.get(ch - \\'a\\');\\n            int minIndex = Math.min(val[0], index);\\n            int maxIndex = Math.max(val[1], index);\\n            store.put(ch - \\'a\\', new int[]{minIndex, maxIndex});\\n            index += 1;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<26; i++) {\\n            int minIndex = store.get(i)[0];\\n            int maxIndex = store.get(i)[1];\\n            if(minIndex != -1 && maxIndex < len) {\\n                ans += countDistinctElement(minIndex, maxIndex, s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int countDistinctElement(int l, int r, String s) {\\n        int []freq = new int[26];\\n        int cnt = 0;\\n        for(int i=l+1; i<r; i++) {\\n            int d = s.charAt(i) - \\'a\\';\\n            freq[d] += 1;\\n            if(freq[d] == 1) cnt += 1;\\n        }\\n        return cnt;\\n    }\\n    \\n    public int countPalindromicSubsequence(String s) {\\n        int len = s.length();\\n        Map<Integer, int[]> store = new HashMap<>();\\n        for(int i=0; i<26; i++) {\\n            store.put(i, new int[]{len, -1});\\n        }\\n        int index = 0;\\n        for(char ch : s.toCharArray()) {\\n            int []val = store.get(ch - \\'a\\');\\n            int minIndex = Math.min(val[0], index);\\n            int maxIndex = Math.max(val[1], index);\\n            store.put(ch - \\'a\\', new int[]{minIndex, maxIndex});\\n            index += 1;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<26; i++) {\\n            int minIndex = store.get(i)[0];\\n            int maxIndex = store.get(i)[1];\\n            if(minIndex != -1 && maxIndex < len) {\\n                ans += countDistinctElement(minIndex, maxIndex, s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990110,
                "title": "c-use-unordered-map-and-unordered-set-straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind the first index and last index of the same character\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        // if a string is s...s...s\\n        // we only need to check first s and last s\\n        // middle s do not need to think about\\n        unordered_map<char, vector<int>> mp;\\n        for(int i = 0; i < s.length(); ++i){\\n            mp[s[i]].push_back(i);\\n        }\\n\\n        unordered_set<string> st;\\n        for(auto it : mp){\\n            if(it.second.size() <= 1)\\n                continue;\\n            int pos1 = it.second[0];\\n            int pos2 = it.second.back();\\n\\n            for(int i = pos1 + 1; i < pos2; ++i){\\n                st.insert(string(1, it.first) + s[i] + string(1, it.first));\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        // if a string is s...s...s\\n        // we only need to check first s and last s\\n        // middle s do not need to think about\\n        unordered_map<char, vector<int>> mp;\\n        for(int i = 0; i < s.length(); ++i){\\n            mp[s[i]].push_back(i);\\n        }\\n\\n        unordered_set<string> st;\\n        for(auto it : mp){\\n            if(it.second.size() <= 1)\\n                continue;\\n            int pos1 = it.second[0];\\n            int pos2 = it.second.back();\\n\\n            for(int i = pos1 + 1; i < pos2; ++i){\\n                st.insert(string(1, it.first) + s[i] + string(1, it.first));\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981855,
                "title": "python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def countPalindromicSubsequence(self, s: str) -> int:\\n    ans = 0\\n    first = [len(s)] * 26\\n    last = [0] * 26\\n\\n    for i, c in enumerate(s):\\n      index = ord(c) - ord(\\'a\\')\\n      first[index] = min(first[index], i)\\n      last[index] = i\\n\\n    for f, l in zip(first, last):\\n      if f < l:\\n        ans += len(set(s[f + 1:l]))\\n\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def countPalindromicSubsequence(self, s: str) -> int:\\n    ans = 0\\n    first = [len(s)] * 26\\n    last = [0] * 26\\n\\n    for i, c in enumerate(s):\\n      index = ord(c) - ord(\\'a\\')\\n      first[index] = min(first[index], i)\\n      last[index] = i\\n\\n    for f, l in zip(first, last):\\n      if f < l:\\n        ans += len(set(s[f + 1:l]))\\n\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979752,
                "title": "intuitive-solution-java",
                "content": "# Intuition\\nA palindrome of size 3 will look like this xyx. \\nThere can be any character in between.\\n# Approach\\nHave 2 sets.\\nUnique - stores the \\'x\\' lets say babbabccba\\nbab, bbb, bcb are all possible palindromes of the letter \\'b\\' on both ends.\\nWe try to find the first and last occurence of this b in our string using 2 pointer approach.\\n\\nOnce we find it, all the unique characters in between will be our unique palindromes. For this we use an intermediate set, called \\'set\\' (conviniently)\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\nlet\\'s say the string is\\nabcdefghijkl\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n        int totalPalindromes = 0;\\n        HashSet<Character> unique = new HashSet<>();\\n\\n        while (left < s.length()) {\\n            if (!unique.contains(s.charAt(left))) {\\n                unique.add(s.charAt(left));\\n\\n                while (s.charAt(left) != s.charAt(right)) {\\n                    right--;\\n                }\\n                HashSet<Character> set = new HashSet<>();\\n                for (int i = left + 1; i < right; i++) {\\n                    set.add(s.charAt(i));\\n                }\\n                totalPalindromes += set.size();\\n            }\\n            left++;\\n            right = s.length() - 1;\\n        }\\n\\n        return totalPalindromes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n        int totalPalindromes = 0;\\n        HashSet<Character> unique = new HashSet<>();\\n\\n        while (left < s.length()) {\\n            if (!unique.contains(s.charAt(left))) {\\n                unique.add(s.charAt(left));\\n\\n                while (s.charAt(left) != s.charAt(right)) {\\n                    right--;\\n                }\\n                HashSet<Character> set = new HashSet<>();\\n                for (int i = left + 1; i < right; i++) {\\n                    set.add(s.charAt(i));\\n                }\\n                totalPalindromes += set.size();\\n            }\\n            left++;\\n            right = s.length() - 1;\\n        }\\n\\n        return totalPalindromes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978573,
                "title": "c-solution-using-set",
                "content": "class Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        int count = 0;\\n        \\n        unordered_set<char> chars;\\n        \\n        for(char c : s){\\n            chars.insert(c);\\n        }\\n        \\n        for(char c : chars){\\n            size_t first = s.find(c);\\n            size_t last = s.rfind(c);\\n            \\n            if(last > first+1){\\n                \\n                unordered_set<char> uniqueChars(s.begin() + first+1 , s.begin() + last);\\n                \\n                count += uniqueChars.size();\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n\\n/*\\nint main() {\\n    Solution solution;\\n    std::string input_string = \"aabca\";\\n    int result = solution.countPalindromicSubsequence(input_string);\\n    std::cout << \"Result: \" << result << std::endl;\\n    return 0;\\n}\\n*/",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        int count = 0;\\n        \\n        unordered_set<char> chars;\\n        \\n        for(char c : s){\\n            chars.insert(c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3978556,
                "title": "python3-solution-using-set",
                "content": "## time: o(n^2)\\n## space:o(n)\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        \\n        ## initialize count variable for counting unique characters in input\\n        count = 0\\n        \\n        ## use set() for extracting unique characters from the  input string\\n        \\n        chars = set(s)\\n        \\n        ## iterate\\n        for char in chars:\\n            \\n            \\n            # s.find(char) gets the index of first occurence of character and s.rfind(char) gets the index in reverse order i.e last \\n            \\n            #For \\'a\\', first would be 0 and last would be 3.\\n            #For \\'b\\', first would be 1 and last would be 1.\\n            #For \\'c\\', first would be 2 and last would be 2.\\n            first = s.find(char)\\n            last  = s.rfind(char)\\n            \\n            count += len(set(s[first+1:last]))\\n            \\n            \\n        return count     \\n    \\n    \\n# Example usage\\n#if __name__ == \"__main__\":\\n    #solution = Solution()\\n    #input_string = \"aabca\"\\n    #result = solution.countPalindromicSubsequence(input_string)\\n    #print(\"Result:\", result)  \\n                         \\n                         \\n",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "## time: o(n^2)\\n## space:o(n)\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        \\n        ## initialize count variable for counting unique characters in input\\n        count = 0\\n        \\n        ## use set() for extracting unique characters from the  input string\\n        \\n        chars = set(s)\\n        \\n        ## iterate\\n        for char in chars:\\n            \\n            \\n            # s.find(char) gets the index of first occurence of character and s.rfind(char) gets the index in reverse order i.e last \\n            \\n            #For \\'a\\', first would be 0 and last would be 3.\\n            #For \\'b\\', first would be 1 and last would be 1.\\n            #For \\'c\\', first would be 2 and last would be 2.\\n            first = s.find(char)\\n            last  = s.rfind(char)\\n            \\n            count += len(set(s[first+1:last]))\\n            \\n            \\n        return count     \\n    \\n    \\n# Example usage\\n#if __name__ == \"__main__\":\\n    #solution = Solution()\\n    #input_string = \"aabca\"\\n    #result = solution.countPalindromicSubsequence(input_string)\\n    #print(\"Result:\", result)  \\n                         \\n                         \\n",
                "codeTag": "Java"
            },
            {
                "id": 3944765,
                "title": "100-runtime-beat-c-o-n-solution",
                "content": "# Code\\n```\\n\\nint countPalindromicSubsequence(char * s){\\n    int** index = (int**)malloc(sizeof(int*)*26);\\n    for(int i = 0;i < 26;i++){\\n        index[i] = (int*)malloc(sizeof(int)*2);\\n        index[i][0] = -1;\\n        index[i][1] = -1;\\n    }\\n\\n    int len = strlen(s);\\n    int start,end;\\n    for(int i = 0;i < 26;i++){\\n        start = 0;\\n        while(start < len && s[start] != \\'a\\' + i){\\n            start++;\\n        }\\n        end = len-1;\\n        while(end >= 0 && s[end] != \\'a\\' + i){\\n            end--;\\n        }\\n        if(end - start >= 2){\\n            index[i][0] = start;\\n            index[i][1] = end;\\n        }\\n    }\\n\\n    int hash,result = 0;\\n    for(int i = 0;i < 26;i++){\\n        hash = 0;\\n        if(index[i][0] != -1){\\n            for(int j = index[i][0]+1;j < index[i][1];j++){\\n                if( ((1<<(s[j]-\\'a\\'))&hash) == 0 ){\\n                    hash += (1<<(s[j]-\\'a\\'));\\n                    result++;\\n                }\\n            }\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint countPalindromicSubsequence(char * s){\\n    int** index = (int**)malloc(sizeof(int*)*26);\\n    for(int i = 0;i < 26;i++){\\n        index[i] = (int*)malloc(sizeof(int)*2);\\n        index[i][0] = -1;\\n        index[i][1] = -1;\\n    }\\n\\n    int len = strlen(s);\\n    int start,end;\\n    for(int i = 0;i < 26;i++){\\n        start = 0;\\n        while(start < len && s[start] != \\'a\\' + i){\\n            start++;\\n        }\\n        end = len-1;\\n        while(end >= 0 && s[end] != \\'a\\' + i){\\n            end--;\\n        }\\n        if(end - start >= 2){\\n            index[i][0] = start;\\n            index[i][1] = end;\\n        }\\n    }\\n\\n    int hash,result = 0;\\n    for(int i = 0;i < 26;i++){\\n        hash = 0;\\n        if(index[i][0] != -1){\\n            for(int j = index[i][0]+1;j < index[i][1];j++){\\n                if( ((1<<(s[j]-\\'a\\'))&hash) == 0 ){\\n                    hash += (1<<(s[j]-\\'a\\'));\\n                    result++;\\n                }\\n            }\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932086,
                "title": "c-with-explanation-two-sets-o-n-runtime-and-space",
                "content": "# Approach\\n\\nWe exploit the fact that in 3-paindromes you only need the leftmost and rightmost letters to match, then in the middle you can have any letter and it\\'d still make a valid palindrome.\\n\\nThe complication though is that letters may repeat. So you can\\'t just go along `s[0]..s[n]` and count everything in-between equal letters. Example: `aaba`, here you have a palindrome `aba` repeated. To solve this problem we use a `set` to save letters we already seen and skip them.\\n\\nSimilarly, when calculating an open interval in-between two letters that weren\\'t calculated before, we create a `set` of all unique letters in that open interval and use its size as the number of 3-palindromes.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$. This one is not really obvious as the number of cycles would imply it is $$O(n\\xB2)$$. But since the task is created on string palindromes, there can only be 26 letters. So actual complexity is as follows: the inner cycle is run at most `26` times, so $$O(n \\xD7 26)$$, and then the outer cycle will be run `n` times, however note again that the inner cycle will not be run more than `26` times. So you have `26 * n + (n - 26)`, so here you go, a $$O(n)$$. You can make it even more clear if you change the outer cycle condition as follows: `; i + 3 <= s.size() && found_3_palindromes.size() < 26;`.\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(const string& s) {\\n        int n_subseqs = 0;\\n        unordered_set<size_t> found_3_palindromes;\\n        for (size_t i = 0; i + 3 <= s.size(); ++i) {\\n            if (found_3_palindromes.find(s[i]) == found_3_palindromes.end()) {\\n                for (size_t j = s.size() - 1; j > i; --j) {\\n                    if (s[i] == s[j]) {\\n                        found_3_palindromes.insert(s[i]);\\n                        n_subseqs += unordered_set<int>(&s[i+1], &s[j]).size();\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return n_subseqs;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(const string& s) {\\n        int n_subseqs = 0;\\n        unordered_set<size_t> found_3_palindromes;\\n        for (size_t i = 0; i + 3 <= s.size(); ++i) {\\n            if (found_3_palindromes.find(s[i]) == found_3_palindromes.end()) {\\n                for (size_t j = s.size() - 1; j > i; --j) {\\n                    if (s[i] == s[j]) {\\n                        found_3_palindromes.insert(s[i]);\\n                        n_subseqs += unordered_set<int>(&s[i+1], &s[j]).size();\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return n_subseqs;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899717,
                "title": "solution-using-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        vector<pair<int,int>>mp(26,{-1,-1});\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int val=s[i]-\\'a\\';\\n            if(mp[val].first==-1)mp[val].first=i;\\n            else mp[val].second=i;\\n        }\\n\\n        for(int i=0;i<26;i++){\\n            if(mp[i].second!=-1){\\n                unordered_set<char> ust;\\n                for(int j=mp[i].first+1;j<mp[i].second;j++){\\n                    ust.insert(s[j]);\\n                }\\n                ans+=ust.size();\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        \\n        vector<pair<int,int>>mp(26,{-1,-1});\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int val=s[i]-\\'a\\';\\n            if(mp[val].first==-1)mp[val].first=i;\\n            else mp[val].second=i;\\n        }\\n\\n        for(int i=0;i<26;i++){\\n            if(mp[i].second!=-1){\\n                unordered_set<char> ust;\\n                for(int j=mp[i].first+1;j<mp[i].second;j++){\\n                    ust.insert(s[j]);\\n                }\\n                ans+=ust.size();\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899656,
                "title": "simple-12line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        cnt = 0\\n        appear = {chr(i):[-1, -1] for i in range(97, 123)}\\n        for i, c in enumerate(s):\\n            if appear[c][0] == -1:\\n                appear[c][0] = i\\n            appear[c][1] = i\\n        for c in appear:\\n            if appear[c][0] == -1:\\n                continue\\n            p = set(s[appear[c][0]+1:appear[c][1]])\\n            cnt += len(p)\\n        return cnt\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        cnt = 0\\n        appear = {chr(i):[-1, -1] for i in range(97, 123)}\\n        for i, c in enumerate(s):\\n            if appear[c][0] == -1:\\n                appear[c][0] = i\\n            appear[c][1] = i\\n        for c in appear:\\n            if appear[c][0] == -1:\\n                continue\\n            p = set(s[appear[c][0]+1:appear[c][1]])\\n            cnt += len(p)\\n        return cnt\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873199,
                "title": "simple-c-solution-using-set-with-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<pair<int,int>> vec(26,{-1,-1});\\n        for(int i =0;i<s.size();i++){\\n            if(vec[s[i]-\\'a\\'].first == -1){\\n                vec[s[i]- \\'a\\'].first = i;\\n            }else {\\n                vec[s[i]-\\'a\\'].second = i;\\n            }\\n        }\\n        int result = 0;\\n        for(int i = 0;i< 26;i++){\\n            if(vec[i].second!=-1){\\n                unordered_set<char> temp;\\n                for(int j = vec[i].first+1;j<vec[i].second;j++){\\n                    temp.insert(s[j]);\\n                }\\n                result+= temp.size();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<pair<int,int>> vec(26,{-1,-1});\\n        for(int i =0;i<s.size();i++){\\n            if(vec[s[i]-\\'a\\'].first == -1){\\n                vec[s[i]- \\'a\\'].first = i;\\n            }else {\\n                vec[s[i]-\\'a\\'].second = i;\\n            }\\n        }\\n        int result = 0;\\n        for(int i = 0;i< 26;i++){\\n            if(vec[i].second!=-1){\\n                unordered_set<char> temp;\\n                for(int j = vec[i].first+1;j<vec[i].second;j++){\\n                    temp.insert(s[j]);\\n                }\\n                result+= temp.size();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846772,
                "title": "c-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- \\n- Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<vector<int>> v(26, vector<int> (2,-1));\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(v[s[i]-\\'a\\'][0] != -1)    v[s[i]-\\'a\\'][1]=i;\\n            else                        v[s[i]-\\'a\\'][0]=i;\\n        }\\n\\n        for(int i=0;i<26;i++)\\n        {\\n            set<int> st;\\n            if(v[i][1]!=-1)\\n            {\\n                for(int j=v[i][0]+1;j<v[i][1];j++)\\n                    st.insert(s[j]);\\n            }\\n            ans+=st.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<vector<int>> v(26, vector<int> (2,-1));\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(v[s[i]-\\'a\\'][0] != -1)    v[s[i]-\\'a\\'][1]=i;\\n            else                        v[s[i]-\\'a\\'][0]=i;\\n        }\\n\\n        for(int i=0;i<26;i++)\\n        {\\n            set<int> st;\\n            if(v[i][1]!=-1)\\n            {\\n                for(int j=v[i][0]+1;j<v[i][1];j++)\\n                    st.insert(s[j]);\\n            }\\n            ans+=st.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845503,
                "title": "c-two-pointer-unique-triplets-count",
                "content": "# Intuition\\nWe need to count the number of distinct characters that occur between the first and last occurrences of each character in the string. For example, in the string \"aabca\", the first occurrence of \\'a\\' is at index 0, and the last occurrence is at index 3. The distinct characters between these indices are \\'b\\' and \\'c\\', so the count for \\'a\\' would be 2.\\n\\n# Approach\\nThe given code provides an approach to solve the problem. The algorithm uses two arrays, `first` and `last`, to store the first and last occurrences of each character in the input string. Then, it iterates through the characters and calculates the count of distinct characters between the first and last occurrences of each character. Finally, it sums up these counts for all characters to get the total count of palindromic subsequences.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1) (since the size of the `first` and `last` arrays is fixed at 26)\\n\\nThe time complexity is O(n) because the algorithm iterates through the input string once to populate the `first` and `last` arrays and then iterates through the 26 characters once more to calculate the counts of distinct characters between their first and last occurrences.\\n\\nThe space complexity is O(1) because the sizes of the `first` and `last` arrays are fixed at 26, regardless of the size of the input string. Therefore, the space used by these arrays is constant and not dependent on the input size. Additionally, the space used by the `unordered_set<char> ch` is also constant for each character as there are at most 26 distinct characters in the English alphabet.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<int> first(26,-1) ,last(26,0);\\n        int result = 0;\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            if(first[s[i]-\\'a\\'] == -1) first[s[i]-\\'a\\'] = i;\\n            last[s[i]-\\'a\\'] = i;\\n        }\\n\\n        for(int i = 0 ; i < 26 ; ++i){\\n            if(first[i] < last[i]){\\n                unordered_set<char> ch;\\n                for(int j = first[i]+1 ; j < last[i] ; ++j) \\n                    ch.insert(s[j]);\\n                result += ch.size();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<int> first(26,-1) ,last(26,0);\\n        int result = 0;\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            if(first[s[i]-\\'a\\'] == -1) first[s[i]-\\'a\\'] = i;\\n            last[s[i]-\\'a\\'] = i;\\n        }\\n\\n        for(int i = 0 ; i < 26 ; ++i){\\n            if(first[i] < last[i]){\\n                unordered_set<char> ch;\\n                for(int j = first[i]+1 ; j < last[i] ; ++j) \\n                    ch.insert(s[j]);\\n                result += ch.size();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805499,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nRuntime\\n216ms , Beats 80.91% of users with Python3\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nMemory\\n17.31mb , Beats 43.49% of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        chars = set(s)\\n        count = 0\\n        for char in chars:\\n            first , last = s.find(char) , s.rfind(char)\\n            count+=len(set(s[first+1:last]))\\n        return count    \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        chars = set(s)\\n        count = 0\\n        for char in chars:\\n            first , last = s.find(char) , s.rfind(char)\\n            count+=len(set(s[first+1:last]))\\n        return count    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764854,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountPalindromicSubsequence(string s) {\\n        var count = 0;\\n        var firstOccIdx = new int[26];\\n        var lastOccIdx = new int[26];\\n        \\n        Array.Fill(firstOccIdx, -1);\\n\\n        for(int idx = 0; idx < s.Length; idx++) {\\n            if(firstOccIdx[s[idx] - \\'a\\'] == -1)\\n                firstOccIdx[s[idx] - \\'a\\'] = idx;\\n            else\\n                lastOccIdx[s[idx] - \\'a\\'] = idx;\\n        }\\n\\n        for(int idx = 0; idx < 26; idx++)\\n            count += CountUniqueChars(s, firstOccIdx[idx] + 1, lastOccIdx[idx] - 1);\\n        \\n        return count;\\n    }\\n\\n    private int CountUniqueChars(string s, int start, int end) {\\n        var count = 0;\\n        var isPresent = new int[26];\\n        for(int idx = start; idx <= end; idx++) {\\n            if(isPresent[s[idx] - \\'a\\'] == 0) {\\n                isPresent[s[idx] - \\'a\\'] = 1;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPalindromicSubsequence(string s) {\\n        var count = 0;\\n        var firstOccIdx = new int[26];\\n        var lastOccIdx = new int[26];\\n        \\n        Array.Fill(firstOccIdx, -1);\\n\\n        for(int idx = 0; idx < s.Length; idx++) {\\n            if(firstOccIdx[s[idx] - \\'a\\'] == -1)\\n                firstOccIdx[s[idx] - \\'a\\'] = idx;\\n            else\\n                lastOccIdx[s[idx] - \\'a\\'] = idx;\\n        }\\n\\n        for(int idx = 0; idx < 26; idx++)\\n            count += CountUniqueChars(s, firstOccIdx[idx] + 1, lastOccIdx[idx] - 1);\\n        \\n        return count;\\n    }\\n\\n    private int CountUniqueChars(string s, int start, int end) {\\n        var count = 0;\\n        var isPresent = new int[26];\\n        for(int idx = start; idx <= end; idx++) {\\n            if(isPresent[s[idx] - \\'a\\'] == 0) {\\n                isPresent[s[idx] - \\'a\\'] = 1;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741681,
                "title": "weird-working-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self,  str) -> int:\\n        count1=0\\n        count2=0\\n        set1=set()\\n        set2=set()\\n        for i in range(len(str)-2):\\n            if str[i] in set1:\\n                continue\\n            set1.add(str[i])\\n            set2.add(str[i+1])\\n            for j in range(i+2,len(str)):\\n                if(str[i]==str[j]):\\n                    count2 = len(set2)\\n                set2.add(str[j])\\n            count1+=count2\\n            count2=0\\n            set2=set()\\n\\n        return count1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self,  str) -> int:\\n        count1=0\\n        count2=0\\n        set1=set()\\n        set2=set()\\n        for i in range(len(str)-2):\\n            if str[i] in set1:\\n                continue\\n            set1.add(str[i])\\n            set2.add(str[i+1])\\n            for j in range(i+2,len(str)):\\n                if(str[i]==str[j]):\\n                    count2 = len(set2)\\n                set2.add(str[j])\\n            count1+=count2\\n            count2=0\\n            set2=set()\\n\\n        return count1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721220,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        map<char,vector<int>> mp;\\n        for(int i = 0 ; i < s.size(); i++)\\n        {\\n            mp[s[i]].push_back(i);\\n        }\\n        auto it = mp.begin();\\n        int ans = 0;\\n        while(it!=mp.end())\\n        {\\n            vector<int> v = mp[it->first];\\n            set<char> st;\\n            int l = v[0];\\n            int r = v[v.size()-1];\\n            for(int i = l+1 ; i < r ; i++)\\n            {\\n                st.insert(s[i]);\\n            }\\n            ans+=st.size();\\n            it++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        map<char,vector<int>> mp;\\n        for(int i = 0 ; i < s.size(); i++)\\n        {\\n            mp[s[i]].push_back(i);\\n        }\\n        auto it = mp.begin();\\n        int ans = 0;\\n        while(it!=mp.end())\\n        {\\n            vector<int> v = mp[it->first];\\n            set<char> st;\\n            int l = v[0];\\n            int r = v[v.size()-1];\\n            for(int i = l+1 ; i < r ; i++)\\n            {\\n                st.insert(s[i]);\\n            }\\n            ans+=st.size();\\n            it++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714350,
                "title": "python-medium-binary-search",
                "content": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n\\n        d = defaultdict(list)\\n\\n        for i, char in enumerate(s):\\n            d[char].append(i)\\n        \\n        ans = 0\\n\\n        for key in d:\\n            if len(d[key]) >= 3:\\n                ans += 1\\n        \\n\\n        for key in d:\\n            count = 0\\n            if len(d[key]) >= 2:\\n                min_ = d[key][0]\\n                max_ = d[key][-1]\\n\\n\\n                for other in d:\\n                    if other == key:\\n                        continue\\n\\n                    l, r = 0, len(d[other]) - 1\\n\\n                    check = True\\n\\n                    while l < r:\\n                        mid = (l + r) // 2\\n\\n\\n\\n                        if min_ < d[other][mid] < max_:\\n                            count += 1\\n                            check = False\\n                            break\\n\\n                        elif min_ > d[other][mid]:\\n                            l = mid + 1\\n\\n                        else:\\n                            r = mid\\n                    \\n                    if not check:\\n                        continue\\n                    \\n                    if min_ < d[other][l] < max_:\\n                        count += 1\\n\\n\\n            ans += count\\n\\n\\n\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n\\n        d = defaultdict(list)\\n\\n        for i, char in enumerate(s):\\n            d[char].append(i)\\n        \\n        ans = 0\\n\\n        for key in d:\\n            if len(d[key]) >= 3:\\n                ans += 1\\n        \\n\\n        for key in d:\\n            count = 0\\n            if len(d[key]) >= 2:\\n                min_ = d[key][0]\\n                max_ = d[key][-1]\\n\\n\\n                for other in d:\\n                    if other == key:\\n                        continue\\n\\n                    l, r = 0, len(d[other]) - 1\\n\\n                    check = True\\n\\n                    while l < r:\\n                        mid = (l + r) // 2\\n\\n\\n\\n                        if min_ < d[other][mid] < max_:\\n                            count += 1\\n                            check = False\\n                            break\\n\\n                        elif min_ > d[other][mid]:\\n                            l = mid + 1\\n\\n                        else:\\n                            r = mid\\n                    \\n                    if not check:\\n                        continue\\n                    \\n                    if min_ < d[other][l] < max_:\\n                        count += 1\\n\\n\\n            ans += count\\n\\n\\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706699,
                "title": "easy-simple-hash-table-approach-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPTR->Palindrome of size 3 ar wo bhi subsequence me to har ek palin me ek char 2 bar ayega hi\\n# Approach\\n\\n--> 26 char ka ek pair wala map banao initialise {-1,-1}\\n-->fr string traverse kro har char ka pahla ar second (ya last occurrence) index store kro\\n-->fr jin jin char ka second index hai unke beech me unique kitne char hai ye count kro\\n--> set ya map ki help lekr ar ans me add krte jao \\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<pair<int,int>>mp(26,{-1,-1});\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int val=s[i]-\\'a\\';\\n            if(mp[val].first==-1)mp[val].first=i;\\n            else mp[val].second=i;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(mp[i].second!=-1)\\n            {\\n                unordered_map<char,int>m;\\n                for(int j=mp[i].first+1;j<mp[i].second;j++)\\n                {\\n                    m[s[j]]=1;\\n                }\\n                ans+=m.size();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<pair<int,int>>mp(26,{-1,-1});\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int val=s[i]-\\'a\\';\\n            if(mp[val].first==-1)mp[val].first=i;\\n            else mp[val].second=i;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(mp[i].second!=-1)\\n            {\\n                unordered_map<char,int>m;\\n                for(int j=mp[i].first+1;j<mp[i].second;j++)\\n                {\\n                    m[s[j]]=1;\\n                }\\n                ans+=m.size();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690111,
                "title": "tc-o-26-n-sc-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char, pair<int, int>> tracker;\\n\\n        for (int idx = 0; idx < n; idx++) {\\n            if (tracker.find(s[idx]) == tracker.end()) {\\n                tracker[s[idx]] = {idx, -1};\\n            } else {\\n                tracker[s[idx]] = {tracker[s[idx]].first, idx};\\n            }\\n        }\\n\\n        int palindromeCnt = 0;\\n\\n        for (auto it : tracker) {\\n            int firstIdx = it.second.first;\\n            int lastIdx = it.second.second;\\n\\n            unordered_set<char> uniqueTracker;\\n\\n            for (int idx = firstIdx + 1; idx < lastIdx; idx++) {\\n                uniqueTracker.insert(s[idx]);\\n            }\\n\\n            palindromeCnt += uniqueTracker.size();\\n        }\\n\\n        return palindromeCnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char, pair<int, int>> tracker;\\n\\n        for (int idx = 0; idx < n; idx++) {\\n            if (tracker.find(s[idx]) == tracker.end()) {\\n                tracker[s[idx]] = {idx, -1};\\n            } else {\\n                tracker[s[idx]] = {tracker[s[idx]].first, idx};\\n            }\\n        }\\n\\n        int palindromeCnt = 0;\\n\\n        for (auto it : tracker) {\\n            int firstIdx = it.second.first;\\n            int lastIdx = it.second.second;\\n\\n            unordered_set<char> uniqueTracker;\\n\\n            for (int idx = firstIdx + 1; idx < lastIdx; idx++) {\\n                uniqueTracker.insert(s[idx]);\\n            }\\n\\n            palindromeCnt += uniqueTracker.size();\\n        }\\n\\n        return palindromeCnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668875,
                "title": "o-n-m-code-better-appraoch-java-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem says to count distict palindrom sequences of length 3 in the string which is provided \\nIn this string aabca we have 3 distinct palindrom sequence of length 3\\naaa, aba, aca\\n\\nNow we know how the sequence are formed. Next we need to figure out how to code.\\nWe can use this approach where we check every chareacter in the string with every other 2 characters in the string and check if first and last is same. If yes then increase count or not.\\n\\nBut it will take n^3 timecomplexity becasue of 3 nested loop.\\nThere is better approach. We know the chanractesr are in between a and z. so what if we check if a is avaiable in the string.\\nIf yes then find the lastindex of a .\\nThen we can check for every if between indexOf(a)+1 and lastIndexOf(a) are we finding any characters which are unique. Meaning \"aaaa\" substring this will only make palidrom sequence of aaa because we are also finding unique sequence.\\n\\nSo we can have another for loop where we iterate from a to z and check if these anyof these characters are found or not. If they are not found then continue else count++;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe would create a count integer.\\nCreate a for loop to iterate from a to z\\ncheck if character is present in the string if not then continue.\\nalso check that indexOf charact is not equal to lastindexof character.that would mean there is only one character in the string if they are equal\\nonce done that we can then itrate through a to z character j = a j<=z\\nnow chekc if j is present in the substring of index of and lastindexof.\\nif yes then we count++;\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\nsince we are running the outer loop for 26 time and inner loop for 26 times which is both are constant.\\n\\nand then we are using indexOf method which has timecomplexity of O(n) and substring method which has time compexity of O(m) where m is size of substring\\n\\nthe total timecomplexity if O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\nwe are only using constant time.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        \\n        HashMap<String, Integer> map = new HashMap<>();\\n        HashSet<String> set = new HashSet<>();\\n        HashSet<Character> set2 = new HashSet<>();\\n\\n       ArrayList<Character> list = new ArrayList<>();\\n\\n        // for(int i =0;i<s.length()-2;i++){\\n\\n        //     int index = s.lastIndexOf(s.charAt(i));\\n            \\n        //     if(s.indexOf(s.charAt(i)) != index && !set2.contains(s.charAt(i))){\\n\\n        //        set2.add(s.charAt(i));\\n\\n        //         for( int j = i+1 ; j < index ; j++ ){\\n        //              StringBuilder sb = new StringBuilder();\\n        //             sb.append(s.charAt(i)).append(s.charAt(j)).append(s.charAt(index));\\n                    \\n        //             set.add(sb.toString());\\n        //         }\\n        //     }\\n\\n        //     }\\n        int count =0;\\n        for(char i =\\'a\\';i<=\\'z\\';i++){\\n\\n            int start = s.indexOf(i);\\n            int last = s.lastIndexOf(i);\\n\\n            if(start == -1 || last == -1) continue;\\n            if(start == last) continue;\\n\\n            String sub = s.substring(start+1,last);\\n            \\n            for(int j = 0;j<=26;j++){\\n\\n                int index = sub.indexOf(\\'a\\'+j);\\n\\n                if(index != -1) count++;\\n\\n            }\\n        }\\n        \\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        \\n        HashMap<String, Integer> map = new HashMap<>();\\n        HashSet<String> set = new HashSet<>();\\n        HashSet<Character> set2 = new HashSet<>();\\n\\n       ArrayList<Character> list = new ArrayList<>();\\n\\n        // for(int i =0;i<s.length()-2;i++){\\n\\n        //     int index = s.lastIndexOf(s.charAt(i));\\n            \\n        //     if(s.indexOf(s.charAt(i)) != index && !set2.contains(s.charAt(i))){\\n\\n        //        set2.add(s.charAt(i));\\n\\n        //         for( int j = i+1 ; j < index ; j++ ){\\n        //              StringBuilder sb = new StringBuilder();\\n        //             sb.append(s.charAt(i)).append(s.charAt(j)).append(s.charAt(index));\\n                    \\n        //             set.add(sb.toString());\\n        //         }\\n        //     }\\n\\n        //     }\\n        int count =0;\\n        for(char i =\\'a\\';i<=\\'z\\';i++){\\n\\n            int start = s.indexOf(i);\\n            int last = s.lastIndexOf(i);\\n\\n            if(start == -1 || last == -1) continue;\\n            if(start == last) continue;\\n\\n            String sub = s.substring(start+1,last);\\n            \\n            for(int j = 0;j<=26;j++){\\n\\n                int index = sub.indexOf(\\'a\\'+j);\\n\\n                if(index != -1) count++;\\n\\n            }\\n        }\\n        \\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662795,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        return sum( len(set(s[s.find(ch)+1:s.rfind(ch)]))  for ch in set(s) )\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        return sum( len(set(s[s.find(ch)+1:s.rfind(ch)]))  for ch in set(s) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649534,
                "title": "easiest-solution-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n\\n        res=0\\n        uniq=set(s)\\n\\n        for c in uniq:\\n            left = s.find(c)\\n            right=s.rfind(c)\\n\\n            if left<right:\\n                res += len(set(s[left+1:right])) \\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n\\n        res=0\\n        uniq=set(s)\\n\\n        for c in uniq:\\n            left = s.find(c)\\n            right=s.rfind(c)\\n\\n            if left<right:\\n                res += len(set(s[left+1:right])) \\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641591,
                "title": "linear-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res = set() # at most 26^2 palindrome can be possible\\n        left = set() # to avoid duplicates\\n        right = collections.Counter(s)\\n\\n        for i in range(len(s)):\\n            right[s[i]] -= 1\\n            if right[s[i]] == 0:\\n                right.pop(s[i])\\n\\n            for j in range(26):\\n                c = chr(ord(\\'a\\')+j)\\n\\n                if c in left and c in right:\\n                    res.add((s[i],c))\\n\\n            left.add(s[i])\\n\\n        return len(res)\\n\\n# time adn space complexity -- O(N)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res = set() # at most 26^2 palindrome can be possible\\n        left = set() # to avoid duplicates\\n        right = collections.Counter(s)\\n\\n        for i in range(len(s)):\\n            right[s[i]] -= 1\\n            if right[s[i]] == 0:\\n                right.pop(s[i])\\n\\n            for j in range(26):\\n                c = chr(ord(\\'a\\')+j)\\n\\n                if c in left and c in right:\\n                    res.add((s[i],c))\\n\\n            left.add(s[i])\\n\\n        return len(res)\\n\\n# time adn space complexity -- O(N)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631959,
                "title": "simple-c-o-26-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(number of distinct charcters*length of string)\\n\\n- Space complexity:\\nO(26)+O(26) complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n       vector<int>a(26,0),b(26,0);\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           b[s[i]-97]=i;\\n       }\\n       for(int i=0;i<s.size();i++){\\n           if(a[s[i]-97]==0&&i!=b[s[i]-97]){\\n               a[s[i]-97]=1;\\n               unordered_set<char>st;\\n               for(int j=i+1;j<b[s[i]-97];j++)st.insert(s[j]);\\n               c+=st.size();\\n           }\\n       }\\n       return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n       vector<int>a(26,0),b(26,0);\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           b[s[i]-97]=i;\\n       }\\n       for(int i=0;i<s.size();i++){\\n           if(a[s[i]-97]==0&&i!=b[s[i]-97]){\\n               a[s[i]-97]=1;\\n               unordered_set<char>st;\\n               for(int j=i+1;j<b[s[i]-97];j++)st.insert(s[j]);\\n               c+=st.size();\\n           }\\n       }\\n       return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614730,
                "title": "easy-and-intuitive-c-solution",
                "content": "# Intuition\\nSum of number of distinct letters between first and last occurance of each alphabet is the answer :)\\n\\n# Approach\\nFirst calculated the index of first and last occurance for each letter and stored it using unordered map.\\nNow iterated through each letter in the map and calculated number of distinct alphabets between first and last occurance of each letter.\\nThe sum of the the above number for each letter is the answer.\\n\\n# Code\\n```\\nstruct divyam\\n{\\n    int first=0;\\n    int last=0;\\n};\\n\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        unordered_map<char,divyam> map;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(map.find(s[i])==map.end())\\n            {\\n                map[s[i]].first=i;\\n            }\\n        }\\n\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(map[s[i]].last==0)\\n            {\\n                map[s[i]].last=i;\\n            }\\n        }\\n\\n\\n\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            vector<char> lol;\\n            for(int j=map[s[i]].first+1;j<map[s[i]].last;j++)\\n            {\\n                if(find(lol.begin(),lol.end(),s[j])==lol.end())\\n                {\\n                    count++;\\n                    lol.push_back(s[j]);\\n                }\\n            }\\n           // cout<<count<<endl;\\n            map[s[i]].first=0;\\n            map[s[i]].last=0;\\n        }\\n\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct divyam\\n{\\n    int first=0;\\n    int last=0;\\n};\\n\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        unordered_map<char,divyam> map;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(map.find(s[i])==map.end())\\n            {\\n                map[s[i]].first=i;\\n            }\\n        }\\n\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(map[s[i]].last==0)\\n            {\\n                map[s[i]].last=i;\\n            }\\n        }\\n\\n\\n\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            vector<char> lol;\\n            for(int j=map[s[i]].first+1;j<map[s[i]].last;j++)\\n            {\\n                if(find(lol.begin(),lol.end(),s[j])==lol.end())\\n                {\\n                    count++;\\n                    lol.push_back(s[j]);\\n                }\\n            }\\n           // cout<<count<<endl;\\n            map[s[i]].first=0;\\n            map[s[i]].last=0;\\n        }\\n\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3530570,
                "title": "without-hashset-intuitive-beginner",
                "content": "int countPalindromicSubsequence(string s)\\n    {\\n        vector<vector<int>>vis(26,vector<int>(26,0));\\n        int n=s.size();\\n        vector<vector<int>>mat(26,vector<int>(n,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mat[s[i]-\\'a\\'][i]=1;\\n        }\\n        \\n        \\n        // convert this matrix into prefix matrix for  all 26 character\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            // consider i is the middle character of palindrome\\n            \\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {   \\n                // character ch present in left\\n                if(mat[ch-\\'a\\'][i-1]>0)\\n                {   \\n                    // character ch present in right\\n                    if(mat[ch-\\'a\\'][n-1]-mat[ch-\\'a\\'][i]>0)\\n                    {   \\n                        \\n                        // unique\\n                        if(vis[s[i]-\\'a\\'][ch-\\'a\\']==0)\\n                        {\\n                            ans++;\\n                            vis[s[i]-\\'a\\'][ch-\\'a\\']=1;\\n                        }\\n                    }\\n                }\\n            }\\n              \\n        }\\n        return ans; \\n    }",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "int countPalindromicSubsequence(string s)\\n    {\\n        vector<vector<int>>vis(26,vector<int>(26,0));\\n        int n=s.size();\\n        vector<vector<int>>mat(26,vector<int>(n,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mat[s[i]-\\'a\\'][i]=1;\\n        }\\n        \\n        \\n        // convert this matrix into prefix matrix for  all 26 character\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            // consider i is the middle character of palindrome\\n            \\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {   \\n                // character ch present in left\\n                if(mat[ch-\\'a\\'][i-1]>0)\\n                {   \\n                    // character ch present in right\\n                    if(mat[ch-\\'a\\'][n-1]-mat[ch-\\'a\\'][i]>0)\\n                    {   \\n                        \\n                        // unique\\n                        if(vis[s[i]-\\'a\\'][ch-\\'a\\']==0)\\n                        {\\n                            ans++;\\n                            vis[s[i]-\\'a\\'][ch-\\'a\\']=1;\\n                        }\\n                    }\\n                }\\n            }\\n              \\n        }\\n        return ans; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3507798,
                "title": "javascript-solution",
                "content": "Just simply use two loop the see how many palindrome between letters.\\nNeed to notice that the Time Complexity of second loop is maximum O(26 * N) because key in `map` only store English letters `a - z`.\\n\\nSo overall the Time Complexity will be O(N + 26 * N) -> O(N)\\n\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    let map = {}\\n    for(let i = 0; i < s.length; i++) {\\n        if(map[s[i]] === undefined) {\\n            map[s[i]] = [i,i]\\n        } else {\\n            let [left, right] = map[s[i]]\\n            \\n            map[s[i]] = [Math.min(i, left), Math.max(i, right)]\\n        }\\n    }\\n    \\n    let res = 0\\n    for(let [left, right] of Object.values(map)) {\\n        let map1 = {}\\n\\n        for(let i = left + 1; i < right; i++) {\\n            if(map1[s[i]] === undefined) {\\n                map1[s[i]] = true\\n                res++\\n            }\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    let map = {}\\n    for(let i = 0; i < s.length; i++) {\\n        if(map[s[i]] === undefined) {\\n            map[s[i]] = [i,i]\\n        } else {\\n            let [left, right] = map[s[i]]\\n            \\n            map[s[i]] = [Math.min(i, left), Math.max(i, right)]\\n        }\\n    }\\n    \\n    let res = 0\\n    for(let [left, right] of Object.values(map)) {\\n        let map1 = {}\\n\\n        for(let i = left + 1; i < right; i++) {\\n            if(map1[s[i]] === undefined) {\\n                map1[s[i]] = true\\n                res++\\n            }\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3499588,
                "title": "o-n-time-o-1-space-solution-explained",
                "content": "In a 3-length palindrome:\\n- middle character can be any character\\n- the left and right characters are the same\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- use two sets. res for the final result res and left to check the left side characters\\n- to check the right side characters, use a hashmap and count the characters\\n- iterate through every character \\n    - remove the char from the right by decrementing its count\\n    - if the char is in the left and also in the right, add it to the res\\n    - add the char to the left \\n- return the length of res\\n \\n# Complexity\\n- Time complexity: O(string traversal * hash set traversal) \\u2192 O(n * 26) \\u2192 O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(hash set) \\u2192 O(26) \\u2192 O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res = set()\\n        left = set()\\n        right = collections.Counter(s)\\n        for i in range(len(s)):\\n            right[s[i]] -= 1\\n            for c in left:\\n                if c in right and right[c] > 0:\\n                    res.add((s[i], c))\\n            left.add(s[i])\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res = set()\\n        left = set()\\n        right = collections.Counter(s)\\n        for i in range(len(s)):\\n            right[s[i]] -= 1\\n            for c in left:\\n                if c in right and right[c] > 0:\\n                    res.add((s[i], c))\\n            left.add(s[i])\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496984,
                "title": "unique-length-3-palindromic-subsequences",
                "content": "------------------- Easy C++ Solution ------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n    int ans = 0;\\n    vector<int> first(26, s.length()); /* 6 6 6 6 */\\n    vector<int> last(26);   /* 0 0 0 0 */\\n\\n    for (int i = 0; i < s.length(); ++i) {\\n      int index = s[i] - \\'a\\';\\n      first[index] = min(first[index], i);\\n      last[index] = i;\\n    }\\n\\n    for (int i = 0; i < 26; ++i)\\n      if (first[i] < last[i])\\n        ans += unordered_set<int>(begin(s) + first[i] + 1, begin(s) + last[i]).size();\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n    int ans = 0;\\n    vector<int> first(26, s.length()); /* 6 6 6 6 */\\n    vector<int> last(26);   /* 0 0 0 0 */\\n\\n    for (int i = 0; i < s.length(); ++i) {\\n      int index = s[i] - \\'a\\';\\n      first[index] = min(first[index], i);\\n      last[index] = i;\\n    }\\n\\n    for (int i = 0; i < 26; ++i)\\n      if (first[i] < last[i])\\n        ans += unordered_set<int>(begin(s) + first[i] + 1, begin(s) + last[i]).size();\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493443,
                "title": "first-solution-in-dart",
                "content": "# Intuition\\nTo key is to get unique characters in string  then get their occurance in string and where they are in string/index  then getting all the characters in between creating a unique character list out of them and incrementing their length\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n   int countPalindromicSubsequence(String s) {\\n     s = s.toLowerCase();\\n     int lengthOfString = s.length;\\n\\n     ///if String length is less than 3\\n     \\n    if(lengthOfString<3){\\n  \\n     return 0;\\n  \\n     }\\n     \\n     \\n        ///if String length is 3\\n     else if (lengthOfString==3){\\n       \\n       if(s[0]==s[s.length-1]){\\n         return 1;\\n       }else{\\n         return 0;\\n       }\\n       \\n     }\\n     else {\\n       \\n      int counter=0;\\n       \\n       ///Get all unique Characters\\n       List<String> uniqueCharactersInString = s.split(\\'\\').toSet().toList();\\n       \\n      for (String uChar in uniqueCharactersInString){\\n        ///Getting character repetion\\n        final int occuranceCount = s.split(\\'\\').where((char) => char == uChar).length;\\n        \\n        if(occuranceCount>1){\\n           final List<int> indexesOfUniqueCharacter = [];\\n          \\n          for(int i =0;i<s.length;i++){\\n            if(s[i]==uChar){\\n              indexesOfUniqueCharacter.add(i);\\n            }\\n            \\n          }\\n          \\n          \\n         final int startIndexOfUniqueCharacter = indexesOfUniqueCharacter.first;\\n          final int lastIndexOfUniqueCharacter = indexesOfUniqueCharacter.last;\\n          \\n          String valuesInBetweenBothIndexes = s.substring(startIndexOfUniqueCharacter+1,lastIndexOfUniqueCharacter);\\n          counter += valuesInBetweenBothIndexes.split(\\'\\').toSet().toList().length;\\n          \\n          \\n        }\\n        \\n      }\\n       \\n       return counter;\\n       \\n       \\n       \\n       }\\n     \\n\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Dart",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\n   int countPalindromicSubsequence(String s) {\\n     s = s.toLowerCase();\\n     int lengthOfString = s.length;\\n\\n     ///if String length is less than 3\\n     \\n    if(lengthOfString<3){\\n  \\n     return 0;\\n  \\n     }\\n     \\n     \\n        ///if String length is 3\\n     else if (lengthOfString==3){\\n       \\n       if(s[0]==s[s.length-1]){\\n         return 1;\\n       }else{\\n         return 0;\\n       }\\n       \\n     }\\n     else {\\n       \\n      int counter=0;\\n       \\n       ///Get all unique Characters\\n       List<String> uniqueCharactersInString = s.split(\\'\\').toSet().toList();\\n       \\n      for (String uChar in uniqueCharactersInString){\\n        ///Getting character repetion\\n        final int occuranceCount = s.split(\\'\\').where((char) => char == uChar).length;\\n        \\n        if(occuranceCount>1){\\n           final List<int> indexesOfUniqueCharacter = [];\\n          \\n          for(int i =0;i<s.length;i++){\\n            if(s[i]==uChar){\\n              indexesOfUniqueCharacter.add(i);\\n            }\\n            \\n          }\\n          \\n          \\n         final int startIndexOfUniqueCharacter = indexesOfUniqueCharacter.first;\\n          final int lastIndexOfUniqueCharacter = indexesOfUniqueCharacter.last;\\n          \\n          String valuesInBetweenBothIndexes = s.substring(startIndexOfUniqueCharacter+1,lastIndexOfUniqueCharacter);\\n          counter += valuesInBetweenBothIndexes.split(\\'\\').toSet().toList().length;\\n          \\n          \\n        }\\n        \\n      }\\n       \\n       return counter;\\n       \\n       \\n       \\n       }\\n     \\n\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461027,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        int count = 0;\\n        int n = s.size();\\n        unordered_map<char,int> mp;\\n        for(auto c:s){\\n            mp[c]++;\\n        }\\n        for(auto m:mp){\\n            if(m.second < 2){\\n                continue;\\n            }\\n            int is = s.find(m.first);\\n            int ie = t.find(m.first);\\n            // cout << is << \" \" << ie << endl;\\n            int k = 0;\\n            set<char> st;\\n            for(int i=is+1;i<(n - ie - 1);i++ ){\\n                st.insert(s[i]);\\n            }\\n            count += st.size();\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        int count = 0;\\n        int n = s.size();\\n        unordered_map<char,int> mp;\\n        for(auto c:s){\\n            mp[c]++;\\n        }\\n        for(auto m:mp){\\n            if(m.second < 2){\\n                continue;\\n            }\\n            int is = s.find(m.first);\\n            int ie = t.find(m.first);\\n            // cout << is << \" \" << ie << endl;\\n            int k = 0;\\n            set<char> st;\\n            for(int i=is+1;i<(n - ie - 1);i++ ){\\n                st.insert(s[i]);\\n            }\\n            count += st.size();\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446364,
                "title": "python3-clean-and-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        \\n        count=Counter()\\n        \\n        for i,ch in enumerate(s):\\n            if ch not in count:\\n                count[ch]=[i,-1]\\n            else:\\n                count[ch][1]=i\\n                \\n        ans=0\\n        \\n        for ch in string.ascii_lowercase:\\n            if ch in count and count[ch][1]!=-1:\\n                \\n                st=count[ch][0]\\n                e=count[ch][1]\\n                ans+=len(set(s[st+1:e]))\\n            \\n        return ans\\n                \\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        \\n        count=Counter()\\n        \\n        for i,ch in enumerate(s):\\n            if ch not in count:\\n                count[ch]=[i,-1]\\n            else:\\n                count[ch][1]=i\\n                \\n        ans=0\\n        \\n        for ch in string.ascii_lowercase:\\n            if ch in count and count[ch][1]!=-1:\\n                \\n                st=count[ch][0]\\n                e=count[ch][1]\\n                ans+=len(set(s[st+1:e]))\\n            \\n        return ans\\n                \\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424500,
                "title": "c-simple-prefix-sum-intuitive-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nin a three length palindromic subsequence first and last char must be same but b/w element can be anything \\ninthis approach I have created a prefix array of letters at evry index and calculated the first and last index of every char which is appearing in string for >=2 times all the distinct no of letters b/w these st(first indexwhere char is seen) and end(last index where this char is seen)\\nwill create a unique pal. sub and contribute to the ans\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nprefix array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(26*n) + (O(c)->at worst case 26^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(26*n)\\n\\n\\n**PLS UPVOTE IF YOU LIKE THE SOLUTION AND EXPLANATION**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> char_arr(n,vector<int>(26,0));\\n        vector<pair<int,int>> char_map(26,{-1,-1});\\n        char_arr[0][s[0]-\\'a\\']++;\\n        int ans=0;\\n        char_map[s[0]-\\'a\\'].first=0;\\n        for(int i=1;i<n;i++){\\n            for(int k=0;k<26;k++){\\n                char_arr[i][k]+=char_arr[i-1][k];\\n            }\\n            char_arr[i][s[i]-\\'a\\']++;\\n            if(char_map[s[i]-\\'a\\'].first==-1){\\n                char_map[s[i]-\\'a\\'].first=i;\\n            }\\n            else{\\n                char_map[s[i]-\\'a\\'].second=i;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            int cnt=0;\\n            if(char_arr[n-1][i]>1){\\n                auto [st,end]=char_map[i];\\n                for(int j=0;j<26;j++){\\n                    int x=char_arr[end][j]-char_arr[st][j];\\n                    cnt+=(j!=i)?(x>0):(x>1);\\n                }\\n                ans+=cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> char_arr(n,vector<int>(26,0));\\n        vector<pair<int,int>> char_map(26,{-1,-1});\\n        char_arr[0][s[0]-\\'a\\']++;\\n        int ans=0;\\n        char_map[s[0]-\\'a\\'].first=0;\\n        for(int i=1;i<n;i++){\\n            for(int k=0;k<26;k++){\\n                char_arr[i][k]+=char_arr[i-1][k];\\n            }\\n            char_arr[i][s[i]-\\'a\\']++;\\n            if(char_map[s[i]-\\'a\\'].first==-1){\\n                char_map[s[i]-\\'a\\'].first=i;\\n            }\\n            else{\\n                char_map[s[i]-\\'a\\'].second=i;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            int cnt=0;\\n            if(char_arr[n-1][i]>1){\\n                auto [st,end]=char_map[i];\\n                for(int j=0;j<26;j++){\\n                    int x=char_arr[end][j]-char_arr[st][j];\\n                    cnt+=(j!=i)?(x>0):(x>1);\\n                }\\n                ans+=cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421473,
                "title": "64-ms-beats-100-easy-to-understand",
                "content": "# Code\\n```\\nfunc countPalindromicSubsequence(_ s: String) -> Int {\\n    var count = 0\\n    let d = Dictionary(grouping: s.enumerated()) { $0.1 }.mapValues { l in l.map(\\\\.0) }\\n    for (c, cis) in d.filter({ $0.value.count > 1 }) {\\n        for (m, mis) in d {\\n            if c != m && mis.contains(where: { $0 > cis[0] && $0 < cis[cis.count - 1] }) {\\n                count += 1\\n            } else if c == m && cis.count > 2 {\\n                count += 1\\n            }\\n        }\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc countPalindromicSubsequence(_ s: String) -> Int {\\n    var count = 0\\n    let d = Dictionary(grouping: s.enumerated()) { $0.1 }.mapValues { l in l.map(\\\\.0) }\\n    for (c, cis) in d.filter({ $0.value.count > 1 }) {\\n        for (m, mis) in d {\\n            if c != m && mis.contains(where: { $0 > cis[0] && $0 < cis[cis.count - 1] }) {\\n                count += 1\\n            } else if c == m && cis.count > 2 {\\n                count += 1\\n            }\\n        }\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3391439,
                "title": "c-hash-map",
                "content": "# Approach\\nSince size 3 strings are needed so find first and last index of each character and count distinct number of characters between the first and last index of that character. This will tell number of 3 sized subsequence. For example **babcaba** is the string and first index of b is 0 and last index of b is 5 so number of distinct characters between 0 and 5 are 3 hence subsequences will be bbb, bab, bcb. Hence we can iterate over all 26 characters and do the same to find all 3 sized subsequences.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        map<char,int> first,last;\\n        map<char,set<int>> idx;\\n        int n = s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            idx[s[i]].insert(i);\\n            if(first.find(s[i])==first.end())\\n            {\\n                first[s[i]] = i;\\n            }\\n            last[s[i]] = i;\\n        }\\n        int ans=0;\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            char ch = i+97;\\n            if(first.find(ch)!=first.end() && \\n            last.find(ch)!=last.end())\\n            {\\n                if(first[ch]!=last[ch])\\n                {\\n                    int l = first[ch];\\n                    int r = last[ch];\\n                    int cnt=0;\\n                    for(int j=0;j<26;j++)\\n                    {\\n                        if(idx.find(j+97)!=idx.end())\\n                        {\\n                            auto it = idx[j+97].upper_bound(l);\\n                            if(it==idx[j+97].end())\\n                            continue;\\n                            if(*it<r)\\n                            cnt++;\\n                        }\\n                    }\\n                    ans+=cnt;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        map<char,int> first,last;\\n        map<char,set<int>> idx;\\n        int n = s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            idx[s[i]].insert(i);\\n            if(first.find(s[i])==first.end())\\n            {\\n                first[s[i]] = i;\\n            }\\n            last[s[i]] = i;\\n        }\\n        int ans=0;\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            char ch = i+97;\\n            if(first.find(ch)!=first.end() && \\n            last.find(ch)!=last.end())\\n            {\\n                if(first[ch]!=last[ch])\\n                {\\n                    int l = first[ch];\\n                    int r = last[ch];\\n                    int cnt=0;\\n                    for(int j=0;j<26;j++)\\n                    {\\n                        if(idx.find(j+97)!=idx.end())\\n                        {\\n                            auto it = idx[j+97].upper_bound(l);\\n                            if(it==idx[j+97].end())\\n                            continue;\\n                            if(*it<r)\\n                            cnt++;\\n                        }\\n                    }\\n                    ans+=cnt;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366842,
                "title": "java-prefixsum-26-n",
                "content": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int[][] chars=new int[s.length()][26];\\n        for(int i=0; i<s.length(); i++){\\n            if(i!=0){\\n                copy(chars[i-1], chars[i], s.charAt(i)-\\'a\\');\\n            }else{\\n                chars[i][s.charAt(i)-\\'a\\']=1;\\n            }\\n        }\\n        int ans=0;\\n        int[] lastIndex=new int[26];\\n        Arrays.fill(lastIndex, -1);\\n        for(int i=s.length()-1; i>=0; i--){\\n            int ch=s.charAt(i)-\\'a\\';\\n            if(lastIndex[ch]==-1){\\n                lastIndex[ch]=i;\\n            }\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            int ch=s.charAt(i)-\\'a\\';\\n            if(lastIndex[ch]==-1 || lastIndex[ch]-i<2){\\n                continue;\\n            }\\n            int[] dest=chars[lastIndex[ch]];\\n            int[] src=chars[i];\\n            for(int j=0; j<26; j++){\\n                if(dest[j]>0){\\n                    if(dest[j]-src[j]-(j==ch?1:0)>0){\\n                        ans++;   \\n                    }\\n                }\\n            }\\n            lastIndex[ch]=-1;\\n        }\\n        return ans;\\n    }\\n    void copy(int[] src, int[] dest, int bonusIndex){\\n        for(int i=0; i<26; i++){\\n            dest[i]=src[i]+(bonusIndex==i?1:0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int[][] chars=new int[s.length()][26];\\n        for(int i=0; i<s.length(); i++){\\n            if(i!=0){\\n                copy(chars[i-1], chars[i], s.charAt(i)-\\'a\\');\\n            }else{\\n                chars[i][s.charAt(i)-\\'a\\']=1;\\n            }\\n        }\\n        int ans=0;\\n        int[] lastIndex=new int[26];\\n        Arrays.fill(lastIndex, -1);\\n        for(int i=s.length()-1; i>=0; i--){\\n            int ch=s.charAt(i)-\\'a\\';\\n            if(lastIndex[ch]==-1){\\n                lastIndex[ch]=i;\\n            }\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            int ch=s.charAt(i)-\\'a\\';\\n            if(lastIndex[ch]==-1 || lastIndex[ch]-i<2){\\n                continue;\\n            }\\n            int[] dest=chars[lastIndex[ch]];\\n            int[] src=chars[i];\\n            for(int j=0; j<26; j++){\\n                if(dest[j]>0){\\n                    if(dest[j]-src[j]-(j==ch?1:0)>0){\\n                        ans++;   \\n                    }\\n                }\\n            }\\n            lastIndex[ch]=-1;\\n        }\\n        return ans;\\n    }\\n    void copy(int[] src, int[] dest, int bonusIndex){\\n        for(int i=0; i<26; i++){\\n            dest[i]=src[i]+(bonusIndex==i?1:0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365270,
                "title": "js-solution-using-hash-set-and-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The middle character in the palindrome should be unique. \\n- If the middle character takes the place, other two characters must be same.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(26*n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    const res = new Set()\\n    const left = new Set()\\n    const right = new Map()\\n    const spreaded = [...s]\\n    spreaded.forEach((ch) => {\\n        if (right.has(ch)) {\\n            right.set(ch, right.get(ch) + 1)\\n        } else {\\n            right.set(ch, 1)\\n        }\\n    })\\n\\n    for (let i=0;i<s.length;i++) {\\n        const k = s[i]\\n        const deduction = right.get(k) - 1\\n        right.set(k, deduction)\\n        if (deduction === 0) {\\n            right.delete(k)\\n        }\\n        \\n        for (let j=0;j<26;j++) {\\n            const charCode = \"a\".charCodeAt(0)\\n            const char = String.fromCharCode(charCode + j)\\n            \\n            if (left.has(char) && right.has(char)) {\\n                res.add(`${char}${k}${char}`)\\n            }\\n        }\\n        left.add(k)\\n    }\\n    return res.size\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    const res = new Set()\\n    const left = new Set()\\n    const right = new Map()\\n    const spreaded = [...s]\\n    spreaded.forEach((ch) => {\\n        if (right.has(ch)) {\\n            right.set(ch, right.get(ch) + 1)\\n        } else {\\n            right.set(ch, 1)\\n        }\\n    })\\n\\n    for (let i=0;i<s.length;i++) {\\n        const k = s[i]\\n        const deduction = right.get(k) - 1\\n        right.set(k, deduction)\\n        if (deduction === 0) {\\n            right.delete(k)\\n        }\\n        \\n        for (let j=0;j<26;j++) {\\n            const charCode = \"a\".charCodeAt(0)\\n            const char = String.fromCharCode(charCode + j)\\n            \\n            if (left.has(char) && right.has(char)) {\\n                res.add(`${char}${k}${char}`)\\n            }\\n        }\\n        left.add(k)\\n    }\\n    return res.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3363274,
                "title": "java-solution",
                "content": "\\n# code\\n- find the first occurance of all the character and last occurance of all the characters\\n- calculate the number of unique elements between the first and last occurance \\n- add the value to result variable\\n```\\nclass Solution {\\n    public int find(String s,int x,int y)\\n    {\\n        if(x==-1 || y==-1 || x==y)\\n            return 0;\\n        Set<Character> set=new HashSet<>();\\n        int i;\\n        for(i=x+1;i<y;i++)\\n        {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n    public int countPalindromicSubsequence(String s) {\\n        int res=0;\\n        int i,n=s.length();\\n        int f[]=new int[26];\\n        int l[]=new int[26];\\n        Arrays.fill(f,-1);\\n        Arrays.fill(l,-1);\\n        for(i=0;i<n;i++)\\n        {\\n            int x=s.charAt(i)-\\'a\\';\\n            if(f[x]==-1)\\n            {\\n                f[x]=i;\\n            }\\n        }\\n        for(i=n-1;i>=0;i--)\\n        {\\n            int x=s.charAt(i)-\\'a\\';\\n            if(l[x]==-1)\\n            {\\n                l[x]=i;\\n            } \\n        }     \\n        for(i=0;i<26;i++)\\n        {\\n            int x=find(s,f[i],l[i]);\\n            res+=x;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int find(String s,int x,int y)\\n    {\\n        if(x==-1 || y==-1 || x==y)\\n            return 0;\\n        Set<Character> set=new HashSet<>();\\n        int i;\\n        for(i=x+1;i<y;i++)\\n        {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n    public int countPalindromicSubsequence(String s) {\\n        int res=0;\\n        int i,n=s.length();\\n        int f[]=new int[26];\\n        int l[]=new int[26];\\n        Arrays.fill(f,-1);\\n        Arrays.fill(l,-1);\\n        for(i=0;i<n;i++)\\n        {\\n            int x=s.charAt(i)-\\'a\\';\\n            if(f[x]==-1)\\n            {\\n                f[x]=i;\\n            }\\n        }\\n        for(i=n-1;i>=0;i--)\\n        {\\n            int x=s.charAt(i)-\\'a\\';\\n            if(l[x]==-1)\\n            {\\n                l[x]=i;\\n            } \\n        }     \\n        for(i=0;i<26;i++)\\n        {\\n            int x=find(s,f[i],l[i]);\\n            res+=x;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351333,
                "title": "hash-set-and-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- hash set and hash map\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- left can use set as there is always plus\\n- right can use hash map as there is minus, we need to check if there is element in it by using if right[c]\\n- i is the middle character as left and right will be the same\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) max is 26 * n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) max is 26 * 26\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res, left, right = set(), set(), Counter(s)\\n        for i in range(len(s)):\\n            right[s[i]] -= 1\\n            for c in left:\\n                if right[c]:\\n                    res.add((s[i], c))\\n            left.add(s[i])\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res, left, right = set(), set(), Counter(s)\\n        for i in range(len(s)):\\n            right[s[i]] -= 1\\n            for c in left:\\n                if right[c]:\\n                    res.add((s[i], c))\\n            left.add(s[i])\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339696,
                "title": "o-26-n-with-set-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(26*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    func countPalindromicSubsequence(_ s: String) -> Int {\\n        var string = Array(s)\\n        var leftSet = Set<Character>()\\n        var rightHash = Dictionary<Character, Int>()\\n        \\n        var result = Set<String>()\\n        \\n        for char in s {\\n            rightHash[char, default: 0] += 1\\n        }\\n        \\n        for current in string {\\n            \\n            rightHash[current, default: 0] -= 1\\n            \\n            for char in \"abcdefghijklmnopqrstuvwxyz\" {\\n                if leftSet.contains(char) && rightHash[char, default: 0] > 0 {\\n                    result.insert(\"\\\\(char)\\\\(current)\\\\(char)\")\\n                }\\n            }\\n            \\n            leftSet.insert(current)\\n\\n        }\\n        \\n        return result.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countPalindromicSubsequence(_ s: String) -> Int {\\n        var string = Array(s)\\n        var leftSet = Set<Character>()\\n        var rightHash = Dictionary<Character, Int>()\\n        \\n        var result = Set<String>()\\n        \\n        for char in s {\\n            rightHash[char, default: 0] += 1\\n        }\\n        \\n        for current in string {\\n            \\n            rightHash[current, default: 0] -= 1\\n            \\n            for char in \"abcdefghijklmnopqrstuvwxyz\" {\\n                if leftSet.contains(char) && rightHash[char, default: 0] > 0 {\\n                    result.insert(\"\\\\(char)\\\\(current)\\\\(char)\")\\n                }\\n            }\\n            \\n            leftSet.insert(current)\\n\\n        }\\n        \\n        return result.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332738,
                "title": "java-o-26n-and-constant-space-solution",
                "content": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int ans = 0;\\n        int len = s.length();\\n        \\n        for(char c = \\'a\\';c <= \\'z\\';c++){\\n            int start = 0, end = len - 1;\\n            \\n            while(start < end && (s.charAt(start) != c || s.charAt(end) != c)){\\n                if(s.charAt(start) != c){\\n                    start++;\\n                }\\n                if(s.charAt(end) != c){\\n                    end--;\\n                }\\n            }\\n            \\n            if(start == end) continue;\\n            \\n            int[] map = new int[26];\\n            \\n            for(int i = start + 1;i < end;i++){\\n                int index = s.charAt(i) - \\'a\\';\\n                if(map[index] == 0) ans++;\\n                map[index]++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int ans = 0;\\n        int len = s.length();\\n        \\n        for(char c = \\'a\\';c <= \\'z\\';c++){\\n            int start = 0, end = len - 1;\\n            \\n            while(start < end && (s.charAt(start) != c || s.charAt(end) != c)){\\n                if(s.charAt(start) != c){\\n                    start++;\\n                }\\n                if(s.charAt(end) != c){\\n                    end--;\\n                }\\n            }\\n            \\n            if(start == end) continue;\\n            \\n            int[] map = new int[26];\\n            \\n            for(int i = start + 1;i < end;i++){\\n                int index = s.charAt(i) - \\'a\\';\\n                if(map[index] == 0) ans++;\\n                map[index]++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313375,
                "title": "very-hard-aproach-beats-99-95-wana-make-it-a-peice-of-cake-for-you",
                "content": "# Intuition\\n**# first thought was to store all the indexes in the my 2d vector... in form of hash table**\\n\\n# Approach\\n>$$1>$$  firstly storing all te index in vector ..\\n\\n>$$1>$$  Now its time to itterate..\\n>$$1>$$  if(find z size()>2 .i.e a plandrome can be formed from it .) \\nthan we go on search the entive v for a value of x less than l and less than  r; and will do ans++;\\n>$$1>$$  and at lst return answr\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ for worst case ...!\\n  $$O(n)$$ for good case ...!\\n\\n\\n- Space complexity:\\n<O(n)>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint countPalindromicSubsequence(string s) {\\n    if(s.size()==3){return s[0]==s[1];} // dealing with a small case. \\n  \\n    // will stored index in it ...\\n    vector<vector<int>>v(26);\\n    // storing index corresponding to ascii value of s[i];\\n    for(int i=0;i<s.size();i++){\\n        v[s[i]-\\'a\\'].push_back(i);\\n    }\\n    int ans=0;  // initialy the answer is 0..\\n\\n    for(vector<int>z:v){\\n        if(z.size()>1){\\n            int l=z[0];             // l for left bound ..\\n            int r=*(z.end()-1);     // r for right bound ....\\n\\n            for(vector<int> y:v ){  // going and doing search . \\n\\n                for(int x:y){\\n              //for such value of x that lie in bound \\n                    if(l<x && x<r){\\n                  // and will do ans++ if found ..\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return ans; // return the final answer obtained !!!!!\\n}\\n}; \\n// Do upvote please.. if it solved your query or gave you a new way to solve these type of problemm...",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\nint countPalindromicSubsequence(string s) {\\n    if(s.size()==3){return s[0]==s[1];}",
                "codeTag": "Java"
            },
            {
                "id": 3302410,
                "title": "c-array-traversing",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each character starting from index 0, find the corresponding position of that character on the opposite end. Then accumulate the count of the number of distinct characters between these 2 indexes.\\n\\nWe will need to use a hash set to store each pair of same characters that have been processed.\\n\\n\\n# Complexity\\n- Time complexity: $$O(26n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountPalindromicSubsequence(string s) {\\n        var count = 0;\\n        var dict = new bool[26];\\n\\n        for (var i = 0; i < s.Length; i++)\\n        {\\n            if (dict[s[i]-\\'a\\']) { continue; }\\n\\n            var j = s.Length-1;\\n            while (j > i && s[i]!=s[j]) {j--;}\\n            count += CountDistinct(s, i+1, j-1);\\n            dict[s[i]-\\'a\\'] = true;\\n        }\\n\\n        return count;\\n    }\\n\\n    // Count distinct characters between index x and y (inclusive)\\n    private int CountDistinct(string s, int x, int y)\\n    {\\n        if (x > y)\\n        {\\n            return 0;\\n        }\\n\\n        var count = 0;\\n        var dict = new bool[26];\\n        for (var i = x; i <= y; i++)\\n        {\\n            var c = s[i] - \\'a\\';\\n            if (!dict[c])\\n            {\\n                count++;\\n            }\\n            dict[c] = true;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPalindromicSubsequence(string s) {\\n        var count = 0;\\n        var dict = new bool[26];\\n\\n        for (var i = 0; i < s.Length; i++)\\n        {\\n            if (dict[s[i]-\\'a\\']) { continue; }\\n\\n            var j = s.Length-1;\\n            while (j > i && s[i]!=s[j]) {j--;}\\n            count += CountDistinct(s, i+1, j-1);\\n            dict[s[i]-\\'a\\'] = true;\\n        }\\n\\n        return count;\\n    }\\n\\n    // Count distinct characters between index x and y (inclusive)\\n    private int CountDistinct(string s, int x, int y)\\n    {\\n        if (x > y)\\n        {\\n            return 0;\\n        }\\n\\n        var count = 0;\\n        var dict = new bool[26];\\n        for (var i = x; i <= y; i++)\\n        {\\n            var c = s[i] - \\'a\\';\\n            if (!dict[c])\\n            {\\n                count++;\\n            }\\n            dict[c] = true;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288339,
                "title": "simple-hash-map-solution-c",
                "content": "```\\nint countPalindromicSubsequence(string s) {\\n        \\n        int left[26] = {0};\\n        int right[26] = {0};\\n        int used[26][26] = {0};\\n        int n = s.size();\\n        int ans = 0;\\n        \\n        for(int i = 1;i<n;i++){\\n            right[s[i]-\\'a\\']++;\\n        }\\n        left[s[0]-\\'a\\']++;\\n        \\n        for(int i = 1;i<n-1;i++){\\n            right[s[i]-\\'a\\']--;\\n            for(int j = 0;j<26;j++){\\n                if(used[s[i]-\\'a\\'][j]==0){\\n                    if(right[j]>0 and left[j]>0){ \\n                        ans++;\\n                        used[s[i]-\\'a\\'][j] = 1;\\n                    }\\n                }\\n            }                \\n            left[s[i]-\\'a\\']++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```\\nint countPalindromicSubsequence(string s) {\\n        \\n        int left[26] = {0};\\n        int right[26] = {0};\\n        int used[26][26] = {0};\\n        int n = s.size();\\n        int ans = 0;\\n        \\n        for(int i = 1;i<n;i++){\\n            right[s[i]-\\'a\\']++;\\n        }\\n        left[s[0]-\\'a\\']++;\\n        \\n        for(int i = 1;i<n-1;i++){\\n            right[s[i]-\\'a\\']--;\\n            for(int j = 0;j<26;j++){\\n                if(used[s[i]-\\'a\\'][j]==0){\\n                    if(right[j]>0 and left[j]>0){ \\n                        ans++;\\n                        used[s[i]-\\'a\\'][j] = 1;\\n                    }\\n                }\\n            }                \\n            left[s[i]-\\'a\\']++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285367,
                "title": "linear-time",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport collections\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res = set() # at most 26^2 palindrome\\n        left = set()\\n        right = collections.Counter(s)\\n        # print(right)\\n        for i in range(len(s)):\\n            right[s[i]] -= 1\\n            # print(right)\\n            if right[s[i]] == 0:\\n                right.pop(s[i])\\n                # print(right)\\n\\n            for j in range(26):\\n                c = chr(ord(\\'a\\') + j)\\n                # print(c)\\n                if c in left and c in right:\\n                    res.add((s[i],c))\\n                    # print(res)\\n\\n            left.add(s[i])\\n            # print(left)\\n        # print(res)\\n        # print(left)\\n        # print(right)\\n\\n        return len(res)\\n\\n# s = Solution()\\n# a = s.countPalindromicSubsequence(\"aabca\")\\n# print(a)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res = set() # at most 26^2 palindrome\\n        left = set()\\n        right = collections.Counter(s)\\n        # print(right)\\n        for i in range(len(s)):\\n            right[s[i]] -= 1\\n            # print(right)\\n            if right[s[i]] == 0:\\n                right.pop(s[i])\\n                # print(right)\\n\\n            for j in range(26):\\n                c = chr(ord(\\'a\\') + j)\\n                # print(c)\\n                if c in left and c in right:\\n                    res.add((s[i],c))\\n                    # print(res)\\n\\n            left.add(s[i])\\n            # print(left)\\n        # print(res)\\n        # print(left)\\n        # print(right)\\n\\n        return len(res)\\n\\n# s = Solution()\\n# a = s.countPalindromicSubsequence(\"aabca\")\\n# print(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276343,
                "title": "c-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void check(unordered_map<char,int>&left , unordered_map<char,int>&right , set<pair<char,char>>&st, char mid){\\n        for(int i=0;i<26;i++){\\n            char ch= \\'a\\'+i;\\n            if(left[ch]>0 and right[ch]>0) st.insert(make_pair(ch,mid));\\n        }\\n    }\\n\\n    int countPalindromicSubsequence(string s) {\\n        int n=s.length();\\n        set<pair<char, char>>st;\\n        unordered_map<char,int>left;        \\n        unordered_map<char,int>right;  \\n        for(int i=0;i<n;i++){\\n            right[s[i]]++;\\n        }      \\n        for(int i=0;i<n;i++){\\n\\n            right[s[i]]--;\\n            check(left , right , st ,s[i]);\\n            left[s[i]]++;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(unordered_map<char,int>&left , unordered_map<char,int>&right , set<pair<char,char>>&st, char mid){\\n        for(int i=0;i<26;i++){\\n            char ch= \\'a\\'+i;\\n            if(left[ch]>0 and right[ch]>0) st.insert(make_pair(ch,mid));\\n        }\\n    }\\n\\n    int countPalindromicSubsequence(string s) {\\n        int n=s.length();\\n        set<pair<char, char>>st;\\n        unordered_map<char,int>left;        \\n        unordered_map<char,int>right;  \\n        for(int i=0;i<n;i++){\\n            right[s[i]]++;\\n        }      \\n        for(int i=0;i<n;i++){\\n\\n            right[s[i]]--;\\n            check(left , right , st ,s[i]);\\n            left[s[i]]++;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258908,
                "title": "go-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(s.length)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(26^3)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nfunc countPalindromicSubsequence(s string) int {\\n\\ttotalCnt := [26]int{}\\n\\tfor _, c := range s {\\n\\t\\ttotalCnt[c-\\'a\\']++\\n\\t}\\n\\n\\tcnt := [26]int{}\\n\\tres := map[[3]rune]bool{}\\n\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\tc := rune(s[i])\\n\\n\\t\\tfor j := \\'a\\'; j <= \\'z\\'; j++ {\\n\\t\\t\\tstr1 := [3]rune{j, c, j}\\n\\t\\t\\tbeforeC := cnt[j-\\'a\\']\\n\\t\\t\\tafterC := totalCnt[j-\\'a\\'] - cnt[j-\\'a\\']\\n\\t\\t\\tif j == c {\\n\\t\\t\\t\\tafterC--\\n\\t\\t\\t}\\n\\n\\t\\t\\tif beforeC == 0 || afterC == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tif _, f := res[str1]; f {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tres[str1] = true\\n\\t\\t}\\n\\n\\t\\tcnt[c-\\'a\\']++\\n\\t}\\n\\n\\treturn len(res)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nfunc countPalindromicSubsequence(s string) int {\\n\\ttotalCnt := [26]int{}\\n\\tfor _, c := range s {\\n\\t\\ttotalCnt[c-\\'a\\']++\\n\\t}\\n\\n\\tcnt := [26]int{}\\n\\tres := map[[3]rune]bool{}\\n\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\tc := rune(s[i])\\n\\n\\t\\tfor j := \\'a\\'; j <= \\'z\\'; j++ {\\n\\t\\t\\tstr1 := [3]rune{j, c, j}\\n\\t\\t\\tbeforeC := cnt[j-\\'a\\']\\n\\t\\t\\tafterC := totalCnt[j-\\'a\\'] - cnt[j-\\'a\\']\\n\\t\\t\\tif j == c {\\n\\t\\t\\t\\tafterC--\\n\\t\\t\\t}\\n\\n\\t\\t\\tif beforeC == 0 || afterC == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tif _, f := res[str1]; f {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tres[str1] = true\\n\\t\\t}\\n\\n\\t\\tcnt[c-\\'a\\']++\\n\\t}\\n\\n\\treturn len(res)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257163,
                "title": "easy-python-solution-o-n-time-complexity-o-1-space-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Iterating through unique characters in a string.\\n2) Per character, finding it\\'s starting and ending index in a string\\n3) Finding the length of unique character between left and right index\\n4) Adding it to the global count variable\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        count = 0\\n\\n        chars = {char for char in s}\\n\\n        for char in chars:\\n            left = s.find(char)\\n            right = s.rfind(char)\\n\\n            if right - left > 1:\\n                count += len(set(s[left + 1: right]))\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        count = 0\\n\\n        chars = {char for char in s}\\n\\n        for char in chars:\\n            left = s.find(char)\\n            right = s.rfind(char)\\n\\n            if right - left > 1:\\n                count += len(set(s[left + 1: right]))\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256614,
                "title": "java-clear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int n = s.length();\\n        HashSet <Character> adds = new HashSet<>();\\n        HashSet <String> res = new HashSet<>();\\n        for(int i =0; i < s.length(); i++){\\n              if(adds.contains(s.charAt(i))) continue;\\n            for(int j = n-1; j > i+1 ; j--){\\n                \\n                if(s.charAt(i)==s.charAt(j)){\\n                  for(int k=i+1; k<j;k++){\\n                      StringBuffer x = new StringBuffer();\\n                       x.append(s.charAt(i));\\n                       x.append(s.charAt(j));\\n                        x.append(s.charAt(k));\\n                       res.add(x.toString());\\n                  }\\n                  adds.add(s.charAt(i));\\n                  break;\\n                  \\n                }\\n            }\\n        }\\n\\n    \\n        return res.size();\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int n = s.length();\\n        HashSet <Character> adds = new HashSet<>();\\n        HashSet <String> res = new HashSet<>();\\n        for(int i =0; i < s.length(); i++){\\n              if(adds.contains(s.charAt(i))) continue;\\n            for(int j = n-1; j > i+1 ; j--){\\n                \\n                if(s.charAt(i)==s.charAt(j)){\\n                  for(int k=i+1; k<j;k++){\\n                      StringBuffer x = new StringBuffer();\\n                       x.append(s.charAt(i));\\n                       x.append(s.charAt(j));\\n                        x.append(s.charAt(k));\\n                       res.add(x.toString());\\n                  }\\n                  adds.add(s.charAt(i));\\n                  break;\\n                  \\n                }\\n            }\\n        }\\n\\n    \\n        return res.size();\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235962,
                "title": "easy-to-understand-prefix-sum",
                "content": "# Intuition\\nTake the array of n x 26 and store the prefix value.\\nTake the array of 26 x 2 and store the starting and ending index of every character.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(26N) + O(26N) = O(N)\\n\\n- Space complexity:\\n- O(26N) + O(26x2)(Which is contant) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<vector<int>> check(26,vector<int> (2,-1));\\n        vector<vector<int>> dic(s.length(),vector<int> (26,0));\\n        for(int i=0 ; i<s.length() ; ++i) {\\n            if(check[s[i]-\\'a\\'][0]==-1) check[s[i]-\\'a\\'][0]=i;\\n            check[s[i]-\\'a\\'][1]=i;\\n            for(int j=0 ; j<26 ; ++j) {\\n                dic[i][j]=(i==0?0:dic[i-1][j]);\\n            }\\n            dic[i][s[i]-\\'a\\']=(i==0?0:dic[i-1][s[i]-\\'a\\'])+1;\\n        }\\n        int ans = 0;\\n        // for(auto i:dic) {\\n        //     for(auto j:i) cout << j << \" \"; cout << \"\\\\n\";\\n        // }\\n        for(int i=0 ; i<26 ; ++i) {\\n            if(check[i][0]==-1) continue;\\n            for(int j=0 ; j<26 ; ++j) {\\n                if(i==j)  {\\n                    if(dic[check[i][1]][j]-dic[check[i][0]][j]>1) {\\n                        ans+=1;\\n                    }\\n                }\\n                else if(dic[check[i][1]][j]-dic[check[i][0]][j]>0) {\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<vector<int>> check(26,vector<int> (2,-1));\\n        vector<vector<int>> dic(s.length(),vector<int> (26,0));\\n        for(int i=0 ; i<s.length() ; ++i) {\\n            if(check[s[i]-\\'a\\'][0]==-1) check[s[i]-\\'a\\'][0]=i;\\n            check[s[i]-\\'a\\'][1]=i;\\n            for(int j=0 ; j<26 ; ++j) {\\n                dic[i][j]=(i==0?0:dic[i-1][j]);\\n            }\\n            dic[i][s[i]-\\'a\\']=(i==0?0:dic[i-1][s[i]-\\'a\\'])+1;\\n        }\\n        int ans = 0;\\n        // for(auto i:dic) {\\n        //     for(auto j:i) cout << j << \" \"; cout << \"\\\\n\";\\n        // }\\n        for(int i=0 ; i<26 ; ++i) {\\n            if(check[i][0]==-1) continue;\\n            for(int j=0 ; j<26 ; ++j) {\\n                if(i==j)  {\\n                    if(dic[check[i][1]][j]-dic[check[i][0]][j]>1) {\\n                        ans+=1;\\n                    }\\n                }\\n                else if(dic[check[i][1]][j]-dic[check[i][0]][j]>0) {\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3232561,
                "title": "hashmap-based-crisp-and-commented-solution-o-26n-time-complexity",
                "content": "### Approach\\n\\n**Brute Force**\\n\\n- Use three nested loops. First loop will have the pointer initialized in index 0, second loop will have a pointer at index 1 and third pointer a index 2.\\n\\n- So we would iterate through all the characters and check if its a palindrome or not.\\n\\n- These palindromes would be added to a HashSet.\\n\\n- The length of the hashSet is the solution.\\n\\n- TC is O(n^3)\\n\\n**Optimised**\\n\\n- One thing to notice in length 3 sub sequences is that the first and last characters is the same, the middle character can be any one of the 26 characters. So there will be a total of 26^2 palindromes.\\n\\n- We can use a HashSet which has the key with the middle and last character. The middle character can have 26^2  possibilities.\\n\\n- So now we would begin with index 1 and do a for loop ```for c in \"abc...z\"``` and check if there are same characters on the left and on the right of c character. \\n\\n- We are checking anywhere on the right and left because we need a subsequence to be a palindrome and not substring.\\n\\n- We can check the characters efficiently by having a left set with all the unique characters to the left and a right hashSet with all the unique characters to the right.\\n\\n- We remove characters from the hashMap whenever it is checked.\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res = set()\\n        left = set()\\n        right = collections.Counter(s)\\n\\n        # this loop is to retrive the middle character s[i]\\n        for i in range(len(s)):\\n            right[s[i]] -= 1 # since the middle character wont be part of the left ot right, we decrement its value in the HashMap.\\n            # if count is 0 then remove the character\\n            if right[s[i]] == 0:\\n                right.pop(s[i])\\n\\n        # check for all 26 characters\\n            for j in range(26):\\n                c = chr(ord(\\'a\\')+j)\\n                if c in left and c in right:\\n                    res.add((s[i],c))\\n            left.add(s[i]) # once we finish the middle character it will be part of the left portion\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```for c in \"abc...z\"```\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        res = set()\\n        left = set()\\n        right = collections.Counter(s)\\n\\n        # this loop is to retrive the middle character s[i]\\n        for i in range(len(s)):\\n            right[s[i]] -= 1 # since the middle character wont be part of the left ot right, we decrement its value in the HashMap.\\n            # if count is 0 then remove the character\\n            if right[s[i]] == 0:\\n                right.pop(s[i])\\n\\n        # check for all 26 characters\\n            for j in range(26):\\n                c = chr(ord(\\'a\\')+j)\\n                if c in left and c in right:\\n                    res.add((s[i],c))\\n            left.add(s[i]) # once we finish the middle character it will be part of the left portion\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172851,
                "title": "example-based-explanation-worst-case-o-26n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPalindrome: 1st and last chr must match, i.e. palindrome[0] == palindrome[2].\\n\\nLet\\'s start off with an example. Say we want to track palindromes of the \\'A-A\\' series, where chr A consists of the extreme ends. In string s we will first track for the 1st occurrence of A.\\n\\n```\\n[\\'A\\', ...]\\n```\\n\\nThen on the next encounter with A at idx i we simply take all unique values in btw and form \\'A-A\\' series palindromes.\\n\\n```\\n[\\'A\\', \\'B\\', \\'C\\', \\'A\\', ...]\\n```\\n\\nWe will then store the last unique value check idx i - 1 and continue our search for the next A. Once we encounter the next A again we do the same as above.\\n\\n```\\n[\\'A\\', \\'B\\', \\'C\\', \\'A\\', \\'E\\', \\'F\\', \\'G\\', \\'A\\', ...]\\n```\\n\\nNote that \\'AAA\\' is a valid palindrome too. Storing last unique check idx allows us to not have to iterate from first occurrence of A.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMap first_occr_chr tracks first occr of a chr and map last_tracked tracks the last in between chr we are tracking for each chr series.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) generally, worst case is O(26n), where 26 is A-Z. This occurs when we have an string with [A-Z] + long seq + [A-Z] and we have to loop through almost the entire string 26 times.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution(object):\\n    def countPalindromicSubsequence(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        # 1st and 3rd chr of each subseq must equal\\n        # map first occur of chrs\\n        # track last checked idx of each chr so that if we encounter chr agn\\n        # we can cont checking\\n        # solves edge cases of eg. \"AAA\"\\n        first_occr_chr = {}\\n        last_tracked = {}\\n        palindromes = {}\\n        for i in range(len(s)):\\n            if s[i] not in first_occr_chr:\\n                first_occr_chr[s[i]] = i\\n                last_tracked[s[i]] = i + 1\\n            else:\\n                # time to check in btw first occr and curr\\n                for j in range(last_tracked[s[i]], i):\\n                    palindrome = s[i] + s[j] + s[i]\\n                    palindromes[palindrome] = 1\\n                # set last checked for next time\\n                last_tracked[s[i]] = i\\n        \\n        return len(palindromes)\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n[\\'A\\', ...]\\n```\n```\\n[\\'A\\', \\'B\\', \\'C\\', \\'A\\', ...]\\n```\n```\\n[\\'A\\', \\'B\\', \\'C\\', \\'A\\', \\'E\\', \\'F\\', \\'G\\', \\'A\\', ...]\\n```\n```\\nclass Solution(object):\\n    def countPalindromicSubsequence(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        # 1st and 3rd chr of each subseq must equal\\n        # map first occur of chrs\\n        # track last checked idx of each chr so that if we encounter chr agn\\n        # we can cont checking\\n        # solves edge cases of eg. \"AAA\"\\n        first_occr_chr = {}\\n        last_tracked = {}\\n        palindromes = {}\\n        for i in range(len(s)):\\n            if s[i] not in first_occr_chr:\\n                first_occr_chr[s[i]] = i\\n                last_tracked[s[i]] = i + 1\\n            else:\\n                # time to check in btw first occr and curr\\n                for j in range(last_tracked[s[i]], i):\\n                    palindrome = s[i] + s[j] + s[i]\\n                    palindromes[palindrome] = 1\\n                # set last checked for next time\\n                last_tracked[s[i]] = i\\n        \\n        return len(palindromes)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157147,
                "title": "cpp-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        map<char,pair<int,int>>mp;\\n        for(int i=0;i<s.size();i++){\\n            if(!(mp.find(s[i])!=mp.end()))mp[s[i]]={i,-1};\\n            else{\\n                mp[s[i]].second=i;\\n            }\\n        }\\n        int ans=0;\\n        for(auto a:mp){\\n            if(a.second.second!=-1){\\n                int m=a.second.first;\\n                int n=a.second.second;\\n                set<char>si;\\n                for(int i=m+1;i<n;i++){\\n                    si.insert(s[i]);\\n                }\\n                ans+=si.size();\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        map<char,pair<int,int>>mp;\\n        for(int i=0;i<s.size();i++){\\n            if(!(mp.find(s[i])!=mp.end()))mp[s[i]]={i,-1};\\n            else{\\n                mp[s[i]].second=i;\\n            }\\n        }\\n        int ans=0;\\n        for(auto a:mp){\\n            if(a.second.second!=-1){\\n                int m=a.second.first;\\n                int n=a.second.second;\\n                set<char>si;\\n                for(int i=m+1;i<n;i++){\\n                    si.insert(s[i]);\\n                }\\n                ans+=si.size();\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133811,
                "title": "java-87-high-efficiency-explanations",
                "content": "# Approach\\n 1. Get the last indices of each character in the string in an int[26] lastIndices;\\n    - \"ceabc\" -> [2,3,4,0,1];\\n2. Starting with i = 0 ..n-2 and j = i+1..n-1, we need to know if there is another character matching i that is AFTER index j. We know this from lastIndices.\\n    - EX: i = 0;\\n    - j = 1: c, e -> is there another c after index 1 ? yes: lastIndices[c] = 4. We have a palindrome cec    \\n    - j = 2: c, a -> any character c after index 2 ? yes, at index 4: we have a palindrome cac\\n    - j = 3: c, b -> any character c after index 2? yes: we have another palindrime cbc\\n    - i = 1  We should skip this point because we see lastIdnex[e] == i (1), so no palindrome can be formed (only 1 single char) \\n    - i = 2  We should skip this point because we see lastIdnex[a] == i (2), so no palindrome can be formed (only 1 single char) \\n3. While doing this, use a boolean[26][27] to mark any combinations done by characters: \\n    - eg: \"aaaaa\": as we have done \"aaa\" we should mark [0][0] = true.\\n4. For high optimization, the 27th column is used to mark if the letter has been checked. \\n    - EX: \"aeaeat\"\\n    - on i = 0 we check a as head of palindrome, so we should not check a again when we reach i = 2 onwards\\n    - on i = 1 we check e as head of palindrome, so we should not check e again when we reach i = 3 onwards\\n\\n5. If letter a was checked for palindromes, then mark [0][27] true. There is no point in checking the same letter twice as head of palindrome.\\n\\n# Complexity\\n- Time complexity:$$O(n + n*n)$$ (the boolean[][] checks will cut the n square significantly)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n + 26 + 26*27)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int count = 0;\\n        boolean[][] doneCombinations = new boolean[26][27];\\n        char[] chrs = s.toCharArray();\\n        int[] lastIndices = getLastIndices(chrs);\\n        for (int i = 0; i < chrs.length - 2; i++) {\\n             for (int j = i + 1; j < chrs.length - 1 && lastIndices[chrs[i] - \\'a\\'] > i && !doneCombinations[chrs[i] -\\'a\\'][26]; j++) {\\n                if (!doneCombinations[chrs[i] -\\'a\\'][chrs[j] - \\'a\\']) {\\n                    doneCombinations[chrs[i] -\\'a\\'][chrs[j] - \\'a\\'] = true;\\n                    if (lastIndices[chrs[i] - \\'a\\'] > j) {\\n                        count++;\\n                    }\\n                }\\n            }\\n            doneCombinations[chrs[i] -\\'a\\'][26] = true;\\n        }\\n        return count;\\n    }\\n\\n    private int[] getLastIndices(char[] chrs) {\\n        int[] lastIndices = new int[26];\\n        for (int i = 0; i < chrs.length; i++) {\\n            lastIndices[chrs[i] - \\'a\\'] = i;\\n        }\\n        return lastIndices;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        int count = 0;\\n        boolean[][] doneCombinations = new boolean[26][27];\\n        char[] chrs = s.toCharArray();\\n        int[] lastIndices = getLastIndices(chrs);\\n        for (int i = 0; i < chrs.length - 2; i++) {\\n             for (int j = i + 1; j < chrs.length - 1 && lastIndices[chrs[i] - \\'a\\'] > i && !doneCombinations[chrs[i] -\\'a\\'][26]; j++) {\\n                if (!doneCombinations[chrs[i] -\\'a\\'][chrs[j] - \\'a\\']) {\\n                    doneCombinations[chrs[i] -\\'a\\'][chrs[j] - \\'a\\'] = true;\\n                    if (lastIndices[chrs[i] - \\'a\\'] > j) {\\n                        count++;\\n                    }\\n                }\\n            }\\n            doneCombinations[chrs[i] -\\'a\\'][26] = true;\\n        }\\n        return count;\\n    }\\n\\n    private int[] getLastIndices(char[] chrs) {\\n        int[] lastIndices = new int[26];\\n        for (int i = 0; i < chrs.length; i++) {\\n            lastIndices[chrs[i] - \\'a\\'] = i;\\n        }\\n        return lastIndices;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127920,
                "title": "kotlin-2-different-ways-o-n",
                "content": "Here is two different ways to solve this problem in Kotlin. I will shortly explain both below.\\n\\n***Approach 1***\\nFor each character in `s` we find the characters first and last occurence, and map them in `first` and `last` (character to index). \\n\\nThen, for each character `c` in the english lowercase alphabet, we check for all unique characters `x` in between the index of `c` first and last occurence in `s`, if `c` exists in our map (`first` and `second`). We increment our result res for each unique character x we encountered.\\n\\nTime Complexity: `O(26 * N)` ~ `O(N)`\\n\\nSpace Complexity: = `O(26)` ~ `O(N)`\\n\\n# Code\\n```\\nclass Solution {\\n    fun countPalindromicSubsequence(s: String): Int {\\n\\n        val first = IntArray(26) {Integer.MAX_VALUE}\\n        val last = IntArray(26)\\n        var res = 0\\n\\n        for(i in s.indices) {\\n            first[s[i] - \\'a\\'] = minOf(first[s[i] - \\'a\\'], i)\\n            last[s[i] - \\'a\\'] = i\\n        }\\n\\n        for(i in 0 until 26) {\\n            if(first[i] < last[i]) \\n                res += s.substring(first[i]+1, last[i]).toCharArray().distinct().count()\\n        }\\n\\n        return res\\n    }\\n}\\n```\\n***Approach 2***\\nHere, for each `c` in string `s`, we map the count of occurences in map `right`.\\n\\nThen, for each index `i` in `s`:\\nWe increment the characters (at index `i`) count in our `right` map (Make sure count doesn\\'t go under zero when removing)\\nThen loop through the english lowercase alphabets size (indices 0 to 25), check if each `c` in the alphabet exists in both our left and right map, if it does, add a outer characters-to-inner pair (example, the palindrom `aba` where `a` is the other and `b` is the inner character of the palindrome) to our res map (Only unique will be added, duplicates get discarded)\\n\\nTime Complexity: `O(26 * N)` ~ `O(N)`\\n\\nSpace Complexity: = `O(26 * 2)` ~ `O(1)`\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun countPalindromicSubsequence(s: String): Int {\\n\\n        val left = HashSet<Char>()\\n        val right = IntArray(26)\\n        var res = HashSet<Pair<Char, Char>>()\\n\\n        for(c in s) right[c - \\'a\\']++\\n\\n        for(i in s.indices) {\\n            if(right[s[i] - \\'a\\'] > 0 ) right[s[i] - \\'a\\']--\\n            for(j in 0 until 26) {\\n                val c = \\'a\\'.plus(j)\\n                if(c in left && right[c - \\'a\\'] > 0) {\\n                    res.add(s[i] to c)\\n                }\\n            }\\n            left.add(s[i])\\n        }\\n\\n        return res.size\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countPalindromicSubsequence(s: String): Int {\\n\\n        val first = IntArray(26) {Integer.MAX_VALUE}\\n        val last = IntArray(26)\\n        var res = 0\\n\\n        for(i in s.indices) {\\n            first[s[i] - \\'a\\'] = minOf(first[s[i] - \\'a\\'], i)\\n            last[s[i] - \\'a\\'] = i\\n        }\\n\\n        for(i in 0 until 26) {\\n            if(first[i] < last[i]) \\n                res += s.substring(first[i]+1, last[i]).toCharArray().distinct().count()\\n        }\\n\\n        return res\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun countPalindromicSubsequence(s: String): Int {\\n\\n        val left = HashSet<Char>()\\n        val right = IntArray(26)\\n        var res = HashSet<Pair<Char, Char>>()\\n\\n        for(c in s) right[c - \\'a\\']++\\n\\n        for(i in s.indices) {\\n            if(right[s[i] - \\'a\\'] > 0 ) right[s[i] - \\'a\\']--\\n            for(j in 0 until 26) {\\n                val c = \\'a\\'.plus(j)\\n                if(c in left && right[c - \\'a\\'] > 0) {\\n                    res.add(s[i] to c)\\n                }\\n            }\\n            left.add(s[i])\\n        }\\n\\n        return res.size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118371,
                "title": "hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number number of solution strings formed from indices i to j is the unique number of characters between  s [ i ] and s [ j ].\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:   \\n        if len(s) in [0, 1, 2] : return 0\\n        startWith = set()\\n        res = 0 \\n        for ind in range(len(s) - 2) : \\n            if s[ind] in startWith : continue\\n            k = len(s) - 1 \\n            while s[k] != s[ind] : k -= 1\\n            res += len(set(list(s[ind + 1 : k])))\\n            startWith.add(s[ind])\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:   \\n        if len(s) in [0, 1, 2] : return 0\\n        startWith = set()\\n        res = 0 \\n        for ind in range(len(s) - 2) : \\n            if s[ind] in startWith : continue\\n            k = len(s) - 1 \\n            while s[k] != s[ind] : k -= 1\\n            res += len(set(list(s[ind + 1 : k])))\\n            startWith.add(s[ind])\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118370,
                "title": "hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number number of solution strings formed from indices i to j is the unique number of characters between  s [ i ] and s [ j ].\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:   \\n        if len(s) in [0, 1, 2] : return 0\\n        startWith = set()\\n        res = 0 \\n        for ind in range(len(s) - 2) : \\n            if s[ind] in startWith : continue\\n            k = len(s) - 1 \\n            while s[k] != s[ind] : k -= 1\\n            res += len(set(list(s[ind + 1 : k])))\\n            startWith.add(s[ind])\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:   \\n        if len(s) in [0, 1, 2] : return 0\\n        startWith = set()\\n        res = 0 \\n        for ind in range(len(s) - 2) : \\n            if s[ind] in startWith : continue\\n            k = len(s) - 1 \\n            while s[k] != s[ind] : k -= 1\\n            res += len(set(list(s[ind + 1 : k])))\\n            startWith.add(s[ind])\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116105,
                "title": "accelerated-o-26-n-solution-beat-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<int> hist1(26, 0);  // histogram of characters before the middle point\\n        vector<int> hist2(26, 0);  // histogram of characters after the middle point\\n        for (char ch : s) {\\n            hist2[ch - \\'a\\']++;\\n        }\\n\\n        vector<int> visited(26 << 5, 0);\\n        for (int i = 0; i < s.size(); ++i) {\\n            // If the ith index is the middle character of the\\n            // 3 length palindromic subsequence.\\n            int middle = s[i] - \\'a\\';\\n\\n            // The middle character is not part of hist2. Remove it.\\n            hist2[middle]--;\\n            auto *hist1_ptr = hist1.data();\\n            auto *hist2_ptr = hist2.data();\\n            for (int c = 0; c < 26; ++c) {\\n                if (std::min(*hist1_ptr++, *hist2_ptr++) > 0) {\\n                    // The key is simply (middle character - \\'a\\') * 32 + the other character - \\'a\\'\\n                    visited[(middle << 5) | c] = 1;\\n                }\\n            }\\n            // After passing this character, add it to the left.\\n            hist1[middle]++;\\n        }\\n        return std::accumulate(visited.begin(), visited.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        vector<int> hist1(26, 0);  // histogram of characters before the middle point\\n        vector<int> hist2(26, 0);  // histogram of characters after the middle point\\n        for (char ch : s) {\\n            hist2[ch - \\'a\\']++;\\n        }\\n\\n        vector<int> visited(26 << 5, 0);\\n        for (int i = 0; i < s.size(); ++i) {\\n            // If the ith index is the middle character of the\\n            // 3 length palindromic subsequence.\\n            int middle = s[i] - \\'a\\';\\n\\n            // The middle character is not part of hist2. Remove it.\\n            hist2[middle]--;\\n            auto *hist1_ptr = hist1.data();\\n            auto *hist2_ptr = hist2.data();\\n            for (int c = 0; c < 26; ++c) {\\n                if (std::min(*hist1_ptr++, *hist2_ptr++) > 0) {\\n                    // The key is simply (middle character - \\'a\\') * 32 + the other character - \\'a\\'\\n                    visited[(middle << 5) | c] = 1;\\n                }\\n            }\\n            // After passing this character, add it to the left.\\n            hist1[middle]++;\\n        }\\n        return std::accumulate(visited.begin(), visited.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108181,
                "title": "87-86-faster-first-and-last-position-of-character-c-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int countPalindromicSubsequence(string s) {\\n        ll n=s.length(),answer=0;\\n        vector<ll>first(26,INT_MAX),last(26,INT_MIN);\\n        for(ll i=0;i<n;i++){\\n            first[s[i]-\\'a\\']=min(first[s[i]-\\'a\\'],i);\\n            last[s[i]-\\'a\\']=max(last[s[i]-\\'a\\'],i);\\n        }\\n        for(ll i=0;i<26;i++){\\n            if(first[i]==INT_MAX || first[i]==last[i]){\\n                continue;\\n            }\\n            ll count=0;\\n            vector<ll>container(26,0);\\n            for(ll j=first[i]+1;j<=last[i]-1;j++){\\n                if(container[s[j]-\\'a\\']==0){\\n                    count++;\\n                }\\n                container[s[j]-\\'a\\']++;\\n            }\\n            answer+=count;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int countPalindromicSubsequence(string s) {\\n        ll n=s.length(),answer=0;\\n        vector<ll>first(26,INT_MAX),last(26,INT_MIN);\\n        for(ll i=0;i<n;i++){\\n            first[s[i]-\\'a\\']=min(first[s[i]-\\'a\\'],i);\\n            last[s[i]-\\'a\\']=max(last[s[i]-\\'a\\'],i);\\n        }\\n        for(ll i=0;i<26;i++){\\n            if(first[i]==INT_MAX || first[i]==last[i]){\\n                continue;\\n            }\\n            ll count=0;\\n            vector<ll>container(26,0);\\n            for(ll j=first[i]+1;j<=last[i]-1;j++){\\n                if(container[s[j]-\\'a\\']==0){\\n                    count++;\\n                }\\n                container[s[j]-\\'a\\']++;\\n            }\\n            answer+=count;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103578,
                "title": "rust-solution",
                "content": "# Intuition\\nWe must not count the same palindromic sequence. So we count the unique character number between the left-most character and right-most character.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn count_palindromic_subsequence(s: String) -> i32 {\\n    let s = s.chars().collect::<Vec<char>>();\\n    let n = s.len();\\n\\n    let mut result = 0;\\n    let mut seen = vec![false;26];\\n    for i in 0..n {\\n      let ti = (s[i] as u8 - \\'a\\' as u8) as usize;\\n      if seen[ti] { continue }\\n      seen[ti] = true;\\n\\n      let mut ti = 0;\\n      for j in (i+1..n).rev() {\\n        if s[i] == s[j] {\\n          ti = j;\\n          break\\n        }\\n      }\\n\\n      if ti == 0 { continue }\\n      let mut exists = vec![false;26];\\n      for j in i+1..ti {\\n        exists[(s[j] as u8 - \\'a\\' as u8) as usize] = true;\\n      }\\n\\n      for v in exists {\\n        if v {\\n          result += 1;\\n        }\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn count_palindromic_subsequence(s: String) -> i32 {\\n    let s = s.chars().collect::<Vec<char>>();\\n    let n = s.len();\\n\\n    let mut result = 0;\\n    let mut seen = vec![false;26];\\n    for i in 0..n {\\n      let ti = (s[i] as u8 - \\'a\\' as u8) as usize;\\n      if seen[ti] { continue }\\n      seen[ti] = true;\\n\\n      let mut ti = 0;\\n      for j in (i+1..n).rev() {\\n        if s[i] == s[j] {\\n          ti = j;\\n          break\\n        }\\n      }\\n\\n      if ti == 0 { continue }\\n      let mut exists = vec![false;26];\\n      for j in i+1..ti {\\n        exists[(s[j] as u8 - \\'a\\' as u8) as usize] = true;\\n      }\\n\\n      for v in exists {\\n        if v {\\n          result += 1;\\n        }\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3103577,
                "title": "rust-solution",
                "content": "# Intuition\\nWe must not count the same palindromic sequence. So we count the unique character number between the left-most character and right-most character.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn count_palindromic_subsequence(s: String) -> i32 {\\n    let s = s.chars().collect::<Vec<char>>();\\n    let n = s.len();\\n\\n    let mut result = 0;\\n    let mut seen = vec![false;26];\\n    for i in 0..n {\\n      let ti = (s[i] as u8 - \\'a\\' as u8) as usize;\\n      if seen[ti] { continue }\\n      seen[ti] = true;\\n\\n      let mut ti = 0;\\n      for j in (i+1..n).rev() {\\n        if s[i] == s[j] {\\n          ti = j;\\n          break\\n        }\\n      }\\n\\n      if ti == 0 { continue }\\n      let mut exists = vec![false;26];\\n      for j in i+1..ti {\\n        exists[(s[j] as u8 - \\'a\\' as u8) as usize] = true;\\n      }\\n\\n      for v in exists {\\n        if v {\\n          result += 1;\\n        }\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn count_palindromic_subsequence(s: String) -> i32 {\\n    let s = s.chars().collect::<Vec<char>>();\\n    let n = s.len();\\n\\n    let mut result = 0;\\n    let mut seen = vec![false;26];\\n    for i in 0..n {\\n      let ti = (s[i] as u8 - \\'a\\' as u8) as usize;\\n      if seen[ti] { continue }\\n      seen[ti] = true;\\n\\n      let mut ti = 0;\\n      for j in (i+1..n).rev() {\\n        if s[i] == s[j] {\\n          ti = j;\\n          break\\n        }\\n      }\\n\\n      if ti == 0 { continue }\\n      let mut exists = vec![false;26];\\n      for j in i+1..ti {\\n        exists[(s[j] as u8 - \\'a\\' as u8) as usize] = true;\\n      }\\n\\n      for v in exists {\\n        if v {\\n          result += 1;\\n        }\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3096991,
                "title": "intuitive-python-solution",
                "content": "# Intuition\\nAll we need is two identical characters that are sandwiching at least one character for us to find a palindrome. \\n\\n# Approach\\nSo we use hash map with key being the character and the value being a list that holds the indexes of this character. We then take the min and max value of that list and if the difference is less than 2 it means that the chars are next to each other and therefore can\\'t form a palindrome (this is controlled through the range values). Otherwise, we construct palindromes using all the characters between the min and max values and we put them into a set in order to keep only the unique ones.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        hashmap = defaultdict(list)\\n        output=set()\\n        for i in range(len(s)):\\n            hashmap[s[i]].append(i)\\n        for key in hashmap:\\n            for i in range(min(hashmap[key])+1, max(hashmap[key])):\\n                output.add(key+s[i]+key)\\n        return len(output)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        hashmap = defaultdict(list)\\n        output=set()\\n        for i in range(len(s)):\\n            hashmap[s[i]].append(i)\\n        for key in hashmap:\\n            for i in range(min(hashmap[key])+1, max(hashmap[key])):\\n                output.add(key+s[i]+key)\\n        return len(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096990,
                "title": "intuitive-python-solution",
                "content": "# Intuition\\nAll we need is two identical characters that are sandwiching at least one character for us to find a palindrome. \\n\\n# Approach\\nSo we use hash map with key being the character and the value being a list that holds the indexes of this character. We then take the min and max value of that list and if the difference is less than 2 it means that the chars are next to each other and therefore can\\'t form a palindrome. Otherwise, we construct palindromes using all the characters between the min and max values and we put them into a set in order to keep only the unique ones.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        hashmap={}\\n        output=set()\\n        for i in range(len(s)):\\n            hashmap.setdefault(s[i],[]).append(i)\\n        for key in hashmap:\\n            if max(hashmap[key]) - min(hashmap[key]) < 2:\\n                continue\\n            for i in range(min(hashmap[key])+1, max(hashmap[key])):\\n                output.add(key+s[i]+key)\\n        return len(output)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        hashmap={}\\n        output=set()\\n        for i in range(len(s)):\\n            hashmap.setdefault(s[i],[]).append(i)\\n        for key in hashmap:\\n            if max(hashmap[key]) - min(hashmap[key]) < 2:\\n                continue\\n            for i in range(min(hashmap[key])+1, max(hashmap[key])):\\n                output.add(key+s[i]+key)\\n        return len(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088182,
                "title": "python-o-26n-solution",
                "content": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        d = {}\\n        for i, c in enumerate(s):\\n            if c not in d:\\n                d[c] = [i, i]\\n            else:\\n                d[c][1] = i\\n        \\n        seen = set()\\n        for i, c in enumerate(s):\\n            for c2, (start_idx, end_idx) in d.items():\\n                if start_idx < i < end_idx:\\n                    seen.add((c2, c, c2))\\n        return len(seen)\\n```\\nThe following solution is better than the previous one.\\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        d = {}\\n        for i, c in enumerate(s):\\n            if c not in d:\\n                d[c] = [i, i]\\n            else:\\n                d[c][1] = i\\n        \\n        res = 0\\n        for c, (start_idx, end_idx) in d.items():\\n            res += len(set(s[start_idx + 1:end_idx]))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        d = {}\\n        for i, c in enumerate(s):\\n            if c not in d:\\n                d[c] = [i, i]\\n            else:\\n                d[c][1] = i\\n        \\n        seen = set()\\n        for i, c in enumerate(s):\\n            for c2, (start_idx, end_idx) in d.items():\\n                if start_idx < i < end_idx:\\n                    seen.add((c2, c, c2))\\n        return len(seen)\\n```\n```\\nclass Solution:\\n    def countPalindromicSubsequence(self, s: str) -> int:\\n        d = {}\\n        for i, c in enumerate(s):\\n            if c not in d:\\n                d[c] = [i, i]\\n            else:\\n                d[c][1] = i\\n        \\n        res = 0\\n        for c, (start_idx, end_idx) in d.items():\\n            res += len(set(s[start_idx + 1:end_idx]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083524,
                "title": "c-hashmap-o-n-alphabet",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        unordered_map<char, int> left;\\n        unordered_map<char, int> right;\\n        for (auto& c : s) ++right[c];\\n        string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n        int ans = 0;\\n        unordered_map<char, unordered_set<char>> m;\\n        for (int i = 0; i < s.size(); ++i){\\n            --right[s[i]];\\n            if (m[s[i]].size() != 26){\\n                for (auto& c : alphabet){\\n                if (left[c] > 0 && right[c] > 0 \\n                   && m[s[i]].find(c) == m[s[i]].end()){\\n                    m[s[i]].insert(c);\\n                    ++ans;\\n                }\\n            }\\n            }\\n            ++left[s[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequence(string s) {\\n        unordered_map<char, int> left;\\n        unordered_map<char, int> right;\\n        for (auto& c : s) ++right[c];\\n        string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n        int ans = 0;\\n        unordered_map<char, unordered_set<char>> m;\\n        for (int i = 0; i < s.size(); ++i){\\n            --right[s[i]];\\n            if (m[s[i]].size() != 26){\\n                for (auto& c : alphabet){\\n                if (left[c] > 0 && right[c] > 0 \\n                   && m[s[i]].find(c) == m[s[i]].end()){\\n                    m[s[i]].insert(c);\\n                    ++ans;\\n                }\\n            }\\n            }\\n            ++left[s[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054801,
                "title": "javascript-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDefinitely not the best solution, but I post it to remember some thoughts.\\n\\nThe test case I cought the error after the first submission: \\ns = \"tlpjzdmtwderpkpmgoyrcxttiheassztncqvnfjeyxxp\", the best for testing in future\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If initial s length les than size of subsequences(3) -> 0\\n2. Added dictionary where key = {str character} and value is array of indexes of this character in the string\\n3. iterate through dictionary, handling 3 cases:\\n    - amount of indexes >= 3 => it is 1 palindrome, so increamen the result\\n    - amount of indexes == 1 => just proceed, there is no new palindroms with it\\n    - amount of indexes > 1 => count all the uniqueue digits that are between the two nearest indexes, increase result to this number\\n\\n# Complexity\\n- Time complexity: O(s * m * u), s - slice method, m - max characters amount between duplicates, u - number of unique chars in string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    // s = \"tlpjzdmtwderpkpmgoyrcxttiheassztncqvnfjeyxxp\"\\n\\n    let result = 0;\\n\\n    if (s.length < 3) return result;\\n\\n    const orderRangeDict = {};\\n\\n    for (let i in s) {\\n        if (!orderRangeDict[s[i]]) {\\n            orderRangeDict[s[i]] = [];\\n        } \\n        orderRangeDict[s[i]].push(i);\\n    }\\n\\n    for (let key in orderRangeDict) {\\n        const value = orderRangeDict[key];\\n        const charAmount = value.length;\\n        if (charAmount >= 3) result++;\\n        if (charAmount === 1) continue;\\n        if (charAmount > 1) {\\n            let j = 0;\\n            let initSubstr = \\'\\';\\n            while (j < charAmount - 1) {\\n                const start = Number(value[j]);\\n                const end = Number(value[j + 1]);\\n                initSubstr += s.slice(start + 1, end);\\n                j++;\\n            } \\n\\n            const uniqCharacters = new Set(initSubstr);\\n\\n            result += uniqCharacters.size;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromicSubsequence = function(s) {\\n    // s = \"tlpjzdmtwderpkpmgoyrcxttiheassztncqvnfjeyxxp\"\\n\\n    let result = 0;\\n\\n    if (s.length < 3) return result;\\n\\n    const orderRangeDict = {};\\n\\n    for (let i in s) {\\n        if (!orderRangeDict[s[i]]) {\\n            orderRangeDict[s[i]] = [];\\n        } \\n        orderRangeDict[s[i]].push(i);\\n    }\\n\\n    for (let key in orderRangeDict) {\\n        const value = orderRangeDict[key];\\n        const charAmount = value.length;\\n        if (charAmount >= 3) result++;\\n        if (charAmount === 1) continue;\\n        if (charAmount > 1) {\\n            let j = 0;\\n            let initSubstr = \\'\\';\\n            while (j < charAmount - 1) {\\n                const start = Number(value[j]);\\n                const end = Number(value[j + 1]);\\n                initSubstr += s.slice(start + 1, end);\\n                j++;\\n            } \\n\\n            const uniqCharacters = new Set(initSubstr);\\n\\n            result += uniqCharacters.size;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3051649,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\n    public int countPalindromicSubsequence(String s) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            m.put(s.charAt(i), m.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        for (Character c: m.keySet()) {\\n            if (m.get(c) > 1) {\\n                countPalindrome(s, c);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public void countPalindrome(String s, Character c) {\\n        int first = s.indexOf(c);\\n        int last = s.lastIndexOf(c);\\n        Set<Character> st = new HashSet<>();\\n        for (int i = first + 1; i < last; i++) {\\n            if (!st.contains(s.charAt(i))) {\\n                res++;\\n                st.add(s.charAt(i));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int countPalindromicSubsequence(String s) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            m.put(s.charAt(i), m.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        for (Character c: m.keySet()) {\\n            if (m.get(c) > 1) {\\n                countPalindrome(s, c);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public void countPalindrome(String s, Character c) {\\n        int first = s.indexOf(c);\\n        int last = s.lastIndexOf(c);\\n        Set<Character> st = new HashSet<>();\\n        for (int i = first + 1; i < last; i++) {\\n            if (!st.contains(s.charAt(i))) {\\n                res++;\\n                st.add(s.charAt(i));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1698224,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try thinking about \" What is 3-length palindrome and it\\'s form \"\\nyou will get an idea..."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@apjo2009](/apjo2009) suppose we have \"bbcbaba\" ,in here suppose we are finding unique combination for \"bxb:.\n1. So consider first b(idx:0) and last b(idx:5), from 0 to 5 running we get these possibilities : bbb,bcb,bbb,bab => unique are bbb,bcb,bab .\n\n  2. \n       - Now lets take like this first b(idx:0) and last b(idx:1) \n                                 no 3length strings possible\n       - first b(idx:1) and last b(idx:3),    from 1 to 3  , \n                                 possibilities : bcb( unique )\n       - Now,first b(idx:3) and last b(idx:5),   from 3 to 5 ,  \n                                possibilities :bab ( unique )\n       - now first b(idx:0) and last b(idx:3), from 0 to 3,\n                            possibilities : bbb,bcb ( unique )\n  if any other diff idx combinations will give reductant possibilities of bxb\n\nSo doing from start to last index of a specific char, we always cover everything in between them,we can sure they are unique(middle elements) to minimise complexity \n\n\n     "
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@apjo2009](/apjo2009) Since the palindrom only has the length of 3, we know that the 0th and 2nd character must be same. and the middle character is independent. so for each character in the string `s` we can check if any of the lowercase letter is present inside the left and right portion of the string `s`. if it is present we can consider that to be a palindrome. The idea is that we need to store the left elements to the left set and right elements to the right map. The reason we are using map for the right element is, we are performing removal of characters from the right . if we use a set and we have multiple same characters, set will only consist of one occurance of the character. we need to make sure that the right portion must contain all the characters. Sorry If this explanation was not clear for you. just use a pen and paper and you can understand this. the program will work if we use 2 maps for left and right. but using set for the right portion will not work."
                    },
                    {
                        "username": "apjo2009",
                        "content": "I knew this part, but somehow not able to understand the how part of the top voted solutions. I mean how counting unique characters between first and last character == getting the answer?"
                    },
                    {
                        "username": "johnnychang",
                        "content": "The solution is so non-intuitive."
                    },
                    {
                        "username": "EverythingIsSoHard",
                        "content": "Can someone please explain why this fails on 70/70th test case for TLE. It does not even show the test case. Is this a leetcode bug. \\n\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        if(s.length() == 0)\\n            return 0;\\n\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n\\n        Set<String> results = new HashSet<>();\\n\\n        for(int i = 0; i< s.length(); i++) {\\n            char c = s.charAt(i);\\n            List<Integer> list = new ArrayList<>();\\n            if(map.containsKey(c))\\n                list = map.get(c);\\n            list.add(i);\\n            map.put(c, list);\\n        }\\n\\n        for(char c: map.keySet()) {\\n            int start = map.get(c).get(0);\\n            int end = map.get(c).get(map.get(c).size()-1);\\n\\n            if(start != end) {\\n                for(int i=start+1; i<end; i++) {\\n                    String target = Character.toString(c) + Character.toString(s.charAt(i)) + Character.toString(c);\\n                    results.add(target);\\n                }\\n            }\\n\\n        }\\n\\n\\n        \\n        return results.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "We are using hashmap only for first and last indxs, try storing them in arrays ."
                    },
                    {
                        "username": "ms0686714",
                        "content": "+1....."
                    },
                    {
                        "username": "Limbobo",
                        "content": "Does someone know how to speed up this solution? Sometimes it is passed and other time I have TLE. \\nDescription of solution:\\nFor every ` mid` char check if there are the same characters in left hashSet and \\nin right hashMap.\\n\\n \\n        // time O(26*n)\\n        // space O(n)\\n    `    Set<Character> left = new HashSet<>();\\n        Map<Character, Integer> right = new HashMap<>();\\n        Set<String> res = new HashSet<>();\\n\\n        // fill map\\n        for(int i = 2; i < s.length(); i++) {\\n            right.put(s.charAt(i), right.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n\\n        left.add(s.charAt(0));\\n        for(int mid = 1; mid < s.length() - 1; mid++) {\\n\\n            for(int j = 0; j < 26; j++) {\\n                char ch = (char)((int)\\'a\\' + j);\\n                if(left.contains(ch) && right.containsKey(ch))\\n                   res.add(new StringBuilder().append(ch).append(s.charAt(mid)).append(ch).toString());\\n            }\\n\\n            left.add(s.charAt(mid));\\n            Integer value = right.get(s.charAt(mid + 1));           \\n            if(value == 1)\\n                right.remove(s.charAt(mid + 1));\\n            else\\n                right.put(s.charAt(mid + 1), value - 1);           \\n\\n        }\\n\\n        return res.size();\\n`"
                    }
                ]
            },
            {
                "id": 1972993,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try thinking about \" What is 3-length palindrome and it\\'s form \"\\nyou will get an idea..."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@apjo2009](/apjo2009) suppose we have \"bbcbaba\" ,in here suppose we are finding unique combination for \"bxb:.\n1. So consider first b(idx:0) and last b(idx:5), from 0 to 5 running we get these possibilities : bbb,bcb,bbb,bab => unique are bbb,bcb,bab .\n\n  2. \n       - Now lets take like this first b(idx:0) and last b(idx:1) \n                                 no 3length strings possible\n       - first b(idx:1) and last b(idx:3),    from 1 to 3  , \n                                 possibilities : bcb( unique )\n       - Now,first b(idx:3) and last b(idx:5),   from 3 to 5 ,  \n                                possibilities :bab ( unique )\n       - now first b(idx:0) and last b(idx:3), from 0 to 3,\n                            possibilities : bbb,bcb ( unique )\n  if any other diff idx combinations will give reductant possibilities of bxb\n\nSo doing from start to last index of a specific char, we always cover everything in between them,we can sure they are unique(middle elements) to minimise complexity \n\n\n     "
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@apjo2009](/apjo2009) Since the palindrom only has the length of 3, we know that the 0th and 2nd character must be same. and the middle character is independent. so for each character in the string `s` we can check if any of the lowercase letter is present inside the left and right portion of the string `s`. if it is present we can consider that to be a palindrome. The idea is that we need to store the left elements to the left set and right elements to the right map. The reason we are using map for the right element is, we are performing removal of characters from the right . if we use a set and we have multiple same characters, set will only consist of one occurance of the character. we need to make sure that the right portion must contain all the characters. Sorry If this explanation was not clear for you. just use a pen and paper and you can understand this. the program will work if we use 2 maps for left and right. but using set for the right portion will not work."
                    },
                    {
                        "username": "apjo2009",
                        "content": "I knew this part, but somehow not able to understand the how part of the top voted solutions. I mean how counting unique characters between first and last character == getting the answer?"
                    },
                    {
                        "username": "johnnychang",
                        "content": "The solution is so non-intuitive."
                    },
                    {
                        "username": "EverythingIsSoHard",
                        "content": "Can someone please explain why this fails on 70/70th test case for TLE. It does not even show the test case. Is this a leetcode bug. \\n\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        if(s.length() == 0)\\n            return 0;\\n\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n\\n        Set<String> results = new HashSet<>();\\n\\n        for(int i = 0; i< s.length(); i++) {\\n            char c = s.charAt(i);\\n            List<Integer> list = new ArrayList<>();\\n            if(map.containsKey(c))\\n                list = map.get(c);\\n            list.add(i);\\n            map.put(c, list);\\n        }\\n\\n        for(char c: map.keySet()) {\\n            int start = map.get(c).get(0);\\n            int end = map.get(c).get(map.get(c).size()-1);\\n\\n            if(start != end) {\\n                for(int i=start+1; i<end; i++) {\\n                    String target = Character.toString(c) + Character.toString(s.charAt(i)) + Character.toString(c);\\n                    results.add(target);\\n                }\\n            }\\n\\n        }\\n\\n\\n        \\n        return results.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "We are using hashmap only for first and last indxs, try storing them in arrays ."
                    },
                    {
                        "username": "ms0686714",
                        "content": "+1....."
                    },
                    {
                        "username": "Limbobo",
                        "content": "Does someone know how to speed up this solution? Sometimes it is passed and other time I have TLE. \\nDescription of solution:\\nFor every ` mid` char check if there are the same characters in left hashSet and \\nin right hashMap.\\n\\n \\n        // time O(26*n)\\n        // space O(n)\\n    `    Set<Character> left = new HashSet<>();\\n        Map<Character, Integer> right = new HashMap<>();\\n        Set<String> res = new HashSet<>();\\n\\n        // fill map\\n        for(int i = 2; i < s.length(); i++) {\\n            right.put(s.charAt(i), right.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n\\n        left.add(s.charAt(0));\\n        for(int mid = 1; mid < s.length() - 1; mid++) {\\n\\n            for(int j = 0; j < 26; j++) {\\n                char ch = (char)((int)\\'a\\' + j);\\n                if(left.contains(ch) && right.containsKey(ch))\\n                   res.add(new StringBuilder().append(ch).append(s.charAt(mid)).append(ch).toString());\\n            }\\n\\n            left.add(s.charAt(mid));\\n            Integer value = right.get(s.charAt(mid + 1));           \\n            if(value == 1)\\n                right.remove(s.charAt(mid + 1));\\n            else\\n                right.put(s.charAt(mid + 1), value - 1);           \\n\\n        }\\n\\n        return res.size();\\n`"
                    }
                ]
            },
            {
                "id": 1752003,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try thinking about \" What is 3-length palindrome and it\\'s form \"\\nyou will get an idea..."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@apjo2009](/apjo2009) suppose we have \"bbcbaba\" ,in here suppose we are finding unique combination for \"bxb:.\n1. So consider first b(idx:0) and last b(idx:5), from 0 to 5 running we get these possibilities : bbb,bcb,bbb,bab => unique are bbb,bcb,bab .\n\n  2. \n       - Now lets take like this first b(idx:0) and last b(idx:1) \n                                 no 3length strings possible\n       - first b(idx:1) and last b(idx:3),    from 1 to 3  , \n                                 possibilities : bcb( unique )\n       - Now,first b(idx:3) and last b(idx:5),   from 3 to 5 ,  \n                                possibilities :bab ( unique )\n       - now first b(idx:0) and last b(idx:3), from 0 to 3,\n                            possibilities : bbb,bcb ( unique )\n  if any other diff idx combinations will give reductant possibilities of bxb\n\nSo doing from start to last index of a specific char, we always cover everything in between them,we can sure they are unique(middle elements) to minimise complexity \n\n\n     "
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@apjo2009](/apjo2009) Since the palindrom only has the length of 3, we know that the 0th and 2nd character must be same. and the middle character is independent. so for each character in the string `s` we can check if any of the lowercase letter is present inside the left and right portion of the string `s`. if it is present we can consider that to be a palindrome. The idea is that we need to store the left elements to the left set and right elements to the right map. The reason we are using map for the right element is, we are performing removal of characters from the right . if we use a set and we have multiple same characters, set will only consist of one occurance of the character. we need to make sure that the right portion must contain all the characters. Sorry If this explanation was not clear for you. just use a pen and paper and you can understand this. the program will work if we use 2 maps for left and right. but using set for the right portion will not work."
                    },
                    {
                        "username": "apjo2009",
                        "content": "I knew this part, but somehow not able to understand the how part of the top voted solutions. I mean how counting unique characters between first and last character == getting the answer?"
                    },
                    {
                        "username": "johnnychang",
                        "content": "The solution is so non-intuitive."
                    },
                    {
                        "username": "EverythingIsSoHard",
                        "content": "Can someone please explain why this fails on 70/70th test case for TLE. It does not even show the test case. Is this a leetcode bug. \\n\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        if(s.length() == 0)\\n            return 0;\\n\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n\\n        Set<String> results = new HashSet<>();\\n\\n        for(int i = 0; i< s.length(); i++) {\\n            char c = s.charAt(i);\\n            List<Integer> list = new ArrayList<>();\\n            if(map.containsKey(c))\\n                list = map.get(c);\\n            list.add(i);\\n            map.put(c, list);\\n        }\\n\\n        for(char c: map.keySet()) {\\n            int start = map.get(c).get(0);\\n            int end = map.get(c).get(map.get(c).size()-1);\\n\\n            if(start != end) {\\n                for(int i=start+1; i<end; i++) {\\n                    String target = Character.toString(c) + Character.toString(s.charAt(i)) + Character.toString(c);\\n                    results.add(target);\\n                }\\n            }\\n\\n        }\\n\\n\\n        \\n        return results.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "We are using hashmap only for first and last indxs, try storing them in arrays ."
                    },
                    {
                        "username": "ms0686714",
                        "content": "+1....."
                    },
                    {
                        "username": "Limbobo",
                        "content": "Does someone know how to speed up this solution? Sometimes it is passed and other time I have TLE. \\nDescription of solution:\\nFor every ` mid` char check if there are the same characters in left hashSet and \\nin right hashMap.\\n\\n \\n        // time O(26*n)\\n        // space O(n)\\n    `    Set<Character> left = new HashSet<>();\\n        Map<Character, Integer> right = new HashMap<>();\\n        Set<String> res = new HashSet<>();\\n\\n        // fill map\\n        for(int i = 2; i < s.length(); i++) {\\n            right.put(s.charAt(i), right.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n\\n        left.add(s.charAt(0));\\n        for(int mid = 1; mid < s.length() - 1; mid++) {\\n\\n            for(int j = 0; j < 26; j++) {\\n                char ch = (char)((int)\\'a\\' + j);\\n                if(left.contains(ch) && right.containsKey(ch))\\n                   res.add(new StringBuilder().append(ch).append(s.charAt(mid)).append(ch).toString());\\n            }\\n\\n            left.add(s.charAt(mid));\\n            Integer value = right.get(s.charAt(mid + 1));           \\n            if(value == 1)\\n                right.remove(s.charAt(mid + 1));\\n            else\\n                right.put(s.charAt(mid + 1), value - 1);           \\n\\n        }\\n\\n        return res.size();\\n`"
                    }
                ]
            },
            {
                "id": 1674906,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try thinking about \" What is 3-length palindrome and it\\'s form \"\\nyou will get an idea..."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@apjo2009](/apjo2009) suppose we have \"bbcbaba\" ,in here suppose we are finding unique combination for \"bxb:.\n1. So consider first b(idx:0) and last b(idx:5), from 0 to 5 running we get these possibilities : bbb,bcb,bbb,bab => unique are bbb,bcb,bab .\n\n  2. \n       - Now lets take like this first b(idx:0) and last b(idx:1) \n                                 no 3length strings possible\n       - first b(idx:1) and last b(idx:3),    from 1 to 3  , \n                                 possibilities : bcb( unique )\n       - Now,first b(idx:3) and last b(idx:5),   from 3 to 5 ,  \n                                possibilities :bab ( unique )\n       - now first b(idx:0) and last b(idx:3), from 0 to 3,\n                            possibilities : bbb,bcb ( unique )\n  if any other diff idx combinations will give reductant possibilities of bxb\n\nSo doing from start to last index of a specific char, we always cover everything in between them,we can sure they are unique(middle elements) to minimise complexity \n\n\n     "
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@apjo2009](/apjo2009) Since the palindrom only has the length of 3, we know that the 0th and 2nd character must be same. and the middle character is independent. so for each character in the string `s` we can check if any of the lowercase letter is present inside the left and right portion of the string `s`. if it is present we can consider that to be a palindrome. The idea is that we need to store the left elements to the left set and right elements to the right map. The reason we are using map for the right element is, we are performing removal of characters from the right . if we use a set and we have multiple same characters, set will only consist of one occurance of the character. we need to make sure that the right portion must contain all the characters. Sorry If this explanation was not clear for you. just use a pen and paper and you can understand this. the program will work if we use 2 maps for left and right. but using set for the right portion will not work."
                    },
                    {
                        "username": "apjo2009",
                        "content": "I knew this part, but somehow not able to understand the how part of the top voted solutions. I mean how counting unique characters between first and last character == getting the answer?"
                    },
                    {
                        "username": "johnnychang",
                        "content": "The solution is so non-intuitive."
                    },
                    {
                        "username": "EverythingIsSoHard",
                        "content": "Can someone please explain why this fails on 70/70th test case for TLE. It does not even show the test case. Is this a leetcode bug. \\n\\n```\\nclass Solution {\\n    public int countPalindromicSubsequence(String s) {\\n        if(s.length() == 0)\\n            return 0;\\n\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n\\n        Set<String> results = new HashSet<>();\\n\\n        for(int i = 0; i< s.length(); i++) {\\n            char c = s.charAt(i);\\n            List<Integer> list = new ArrayList<>();\\n            if(map.containsKey(c))\\n                list = map.get(c);\\n            list.add(i);\\n            map.put(c, list);\\n        }\\n\\n        for(char c: map.keySet()) {\\n            int start = map.get(c).get(0);\\n            int end = map.get(c).get(map.get(c).size()-1);\\n\\n            if(start != end) {\\n                for(int i=start+1; i<end; i++) {\\n                    String target = Character.toString(c) + Character.toString(s.charAt(i)) + Character.toString(c);\\n                    results.add(target);\\n                }\\n            }\\n\\n        }\\n\\n\\n        \\n        return results.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "We are using hashmap only for first and last indxs, try storing them in arrays ."
                    },
                    {
                        "username": "ms0686714",
                        "content": "+1....."
                    },
                    {
                        "username": "Limbobo",
                        "content": "Does someone know how to speed up this solution? Sometimes it is passed and other time I have TLE. \\nDescription of solution:\\nFor every ` mid` char check if there are the same characters in left hashSet and \\nin right hashMap.\\n\\n \\n        // time O(26*n)\\n        // space O(n)\\n    `    Set<Character> left = new HashSet<>();\\n        Map<Character, Integer> right = new HashMap<>();\\n        Set<String> res = new HashSet<>();\\n\\n        // fill map\\n        for(int i = 2; i < s.length(); i++) {\\n            right.put(s.charAt(i), right.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n\\n        left.add(s.charAt(0));\\n        for(int mid = 1; mid < s.length() - 1; mid++) {\\n\\n            for(int j = 0; j < 26; j++) {\\n                char ch = (char)((int)\\'a\\' + j);\\n                if(left.contains(ch) && right.containsKey(ch))\\n                   res.add(new StringBuilder().append(ch).append(s.charAt(mid)).append(ch).toString());\\n            }\\n\\n            left.add(s.charAt(mid));\\n            Integer value = right.get(s.charAt(mid + 1));           \\n            if(value == 1)\\n                right.remove(s.charAt(mid + 1));\\n            else\\n                right.put(s.charAt(mid + 1), value - 1);           \\n\\n        }\\n\\n        return res.size();\\n`"
                    }
                ]
            }
        ]
    }
]