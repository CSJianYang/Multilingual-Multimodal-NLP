[
    {
        "title": "Divide Players Into Teams of Equal Skill",
        "question_content": "You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.\nThe chemistry of a team is equal to the product of the skills of the players on that team.\nReturn the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.\n&nbsp;\nExample 1:\n\nInput: skill = [3,2,5,1,3,4]\nOutput: 22\nExplanation: \nDivide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.\nThe sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.\n\nExample 2:\n\nInput: skill = [3,4]\nOutput: 12\nExplanation: \nThe two players form a team with a total skill of 7.\nThe chemistry of the team is 3 * 4 = 12.\n\nExample 3:\n\nInput: skill = [1,1,2,3]\nOutput: -1\nExplanation: \nThere is no way to divide the players into teams such that the total skill of each team is equal.\n\n&nbsp;\nConstraints:\n\n\t2 <= skill.length <= 105\n\tskill.length is even.\n\t1 <= skill[i] <= 1000",
        "solutions": [
            {
                "id": 2875011,
                "title": "python-c-o-n-counting-and-pair-matching-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs counting of skill frequencies for further pair matching. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Python #1.** Count frequencies then match pairs.\\n```\\nclass Solution:\\n    def dividePlayers(self, ss: List[int]) -> int:\\n        \\n        s = 2 * sum(ss) // len(ss)        # [1] compute each team\\'s expected skill\\n        chemistry = 0     \\n        cnt = Counter(ss)                 # [2] count skills\\n\\n        for v, c in cnt.items():          # [3] for all players with a given skill, \\n            if c != cnt[s-v]:             #     check that there is the same number\\n                return -1                 #     of players with paired skill...\\n            chemistry += c * v * (s-v)    # [4] ...and compute chemistry for these pairs\\n            \\n        return chemistry // 2             # [5] we double-counted, correct for this\\n```\\n\\n**Python #2.** Sort then sum. This solution has **O(N\\\\*logN)** time complexity.\\n```\\nclass Solution:\\n    def dividePlayers(self, ss: List[int]) -> int:\\n        \\n        ss.sort()\\n        chemistry, s = 0, ss[0] + ss[-1]\\n\\n        for i in range(len(ss)//2):\\n            if ss[i] + ss[-i-1] == s:\\n                chemistry += ss[i] * ss[-i-1]\\n            else:\\n                return -1\\n        return chemistry\\n```\\n\\n**C++.** Count frequencies then match pairs.\\n```\\nclass Solution \\n{\\npublic:\\n    long long dividePlayers(vector<int>& ss) \\n    {\\n        int s = 2 * accumulate(ss.begin(), ss.end(), 0) / ss.size();\\n        long long chemistry = 0;\\n        \\n        unordered_map<long long, int> cnt;\\n        for (int n : ss) ++cnt[n];\\n        \\n        for (auto[v,c] : cnt)\\n            if (!cnt.count(s-v) || cnt[s-v] != c)\\n                return -1;\\n            else\\n                chemistry += c * v * (s-v);\\n        \\n        return chemistry / 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, ss: List[int]) -> int:\\n        \\n        s = 2 * sum(ss) // len(ss)        # [1] compute each team\\'s expected skill\\n        chemistry = 0     \\n        cnt = Counter(ss)                 # [2] count skills\\n\\n        for v, c in cnt.items():          # [3] for all players with a given skill, \\n            if c != cnt[s-v]:             #     check that there is the same number\\n                return -1                 #     of players with paired skill...\\n            chemistry += c * v * (s-v)    # [4] ...and compute chemistry for these pairs\\n            \\n        return chemistry // 2             # [5] we double-counted, correct for this\\n```\n```\\nclass Solution:\\n    def dividePlayers(self, ss: List[int]) -> int:\\n        \\n        ss.sort()\\n        chemistry, s = 0, ss[0] + ss[-1]\\n\\n        for i in range(len(ss)//2):\\n            if ss[i] + ss[-i-1] == s:\\n                chemistry += ss[i] * ss[-i-1]\\n            else:\\n                return -1\\n        return chemistry\\n```\n```\\nclass Solution \\n{\\npublic:\\n    long long dividePlayers(vector<int>& ss) \\n    {\\n        int s = 2 * accumulate(ss.begin(), ss.end(), 0) / ss.size();\\n        long long chemistry = 0;\\n        \\n        unordered_map<long long, int> cnt;\\n        for (int n : ss) ++cnt[n];\\n        \\n        for (auto[v,c] : cnt)\\n            if (!cnt.count(s-v) || cnt[s-v] != c)\\n                return -1;\\n            else\\n                chemistry += c * v * (s-v);\\n        \\n        return chemistry / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875028,
                "title": "simple-python-solution",
                "content": "*Time Complexity :* **O(NlogN)** (For sorting skill list.)\\n*Space Complexity :* **O(1)**\\n```\\nclass Solution(object):\\n    def dividePlayers(self, skill):\\n        skill.sort()\\n        ans, sum_ = 0, 0\\n        ptr1, ptr2 = 0, len(skill) - 1\\n        for i in range(len(skill) // 2):\\n            if i == 0:\\n                sum_ = skill[ptr1] + skill[ptr2]\\n                ans += (skill[ptr1] * skill[ptr2])\\n            else:\\n                if (skill[ptr1] + skill[ptr2]) != sum_: return -1\\n                ans += (skill[ptr1] * skill[ptr2])\\n            ptr1 += 1\\n            ptr2 -= 1\\n        return ans\\n```\\n**UpVote**, if it helps a little to you **:)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def dividePlayers(self, skill):\\n        skill.sort()\\n        ans, sum_ = 0, 0\\n        ptr1, ptr2 = 0, len(skill) - 1\\n        for i in range(len(skill) // 2):\\n            if i == 0:\\n                sum_ = skill[ptr1] + skill[ptr2]\\n                ans += (skill[ptr1] * skill[ptr2])\\n            else:\\n                if (skill[ptr1] + skill[ptr2]) != sum_: return -1\\n                ans += (skill[ptr1] * skill[ptr2])\\n            ptr1 += 1\\n            ptr2 -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874970,
                "title": "explained-both-map-sorting-solutions-space-optimized-o-1-time-optimized-o-n",
                "content": "<b>Up Vote if you like the solution\\n<b>Solution 1: Time optimized - O(n) time & O(n) space\\n```\\n/*\\nApproach : \\nKeep on checking if the complimetary value is already seen or not, if seen then simply\\nreduce the count of the complimentary one and calculate the result. \\n\\nTo check if all the elements are metched or not a count can be used to see it is equal to zero or not.\\ncount can be increament when a match found and decremented when not found.\\n*/\\nlong long dividePlayers(vector<int>& skill) {\\n    long long ans = 0;\\n    unordered_map<int, int> mp;\\n    long sum = 0, count = 0, n = skill.size()/2;\\n    for(auto s: skill) sum+= s; \\n    if(sum % n != 0) return -1;\\n    int teamSize = sum/n;\\n    for(auto s: skill){ \\n        if(mp[teamSize - s] > 0 ){\\n            mp[teamSize - s]--;\\n            ans += s * (teamSize - s);\\n            count--;\\n        }else{\\n            mp[s]++; count++;\\n        }\\n    }\\n    if(count != 0 ) return -1;\\n    return ans;\\n}\\n```\\n\\n<b>Solution 2: Space optimized - Time Complexity O(nlogn) & Space Complexity O(1)\\n```\\n/*\\nApproach:\\nSort the skill array and then take one one from start and end and check with the teamSize if equal or not\\n*/\\nlong long dividePlayers(vector<int>& skill) {\\n    sort(skill.begin(), skill.end());\\n    long long ans = 0, teamSize = skill[0] + skill.back(); \\n    for(int i = 0; i < skill.size()/2; ++i){ \\n        if(skill[i] + skill[skill.size() - i - 1] == teamSize)  ans += skill[i] * (teamSize - skill[i]);\\n        else return -1;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nApproach : \\nKeep on checking if the complimetary value is already seen or not, if seen then simply\\nreduce the count of the complimentary one and calculate the result. \\n\\nTo check if all the elements are metched or not a count can be used to see it is equal to zero or not.\\ncount can be increament when a match found and decremented when not found.\\n*/\\nlong long dividePlayers(vector<int>& skill) {\\n    long long ans = 0;\\n    unordered_map<int, int> mp;\\n    long sum = 0, count = 0, n = skill.size()/2;\\n    for(auto s: skill) sum+= s; \\n    if(sum % n != 0) return -1;\\n    int teamSize = sum/n;\\n    for(auto s: skill){ \\n        if(mp[teamSize - s] > 0 ){\\n            mp[teamSize - s]--;\\n            ans += s * (teamSize - s);\\n            count--;\\n        }else{\\n            mp[s]++; count++;\\n        }\\n    }\\n    if(count != 0 ) return -1;\\n    return ans;\\n}\\n```\n```\\n/*\\nApproach:\\nSort the skill array and then take one one from start and end and check with the teamSize if equal or not\\n*/\\nlong long dividePlayers(vector<int>& skill) {\\n    sort(skill.begin(), skill.end());\\n    long long ans = 0, teamSize = skill[0] + skill.back(); \\n    for(int i = 0; i < skill.size()/2; ++i){ \\n        if(skill[i] + skill[skill.size() - i - 1] == teamSize)  ans += skill[i] * (teamSize - skill[i]);\\n        else return -1;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2874961,
                "title": "c-java-python-sort-and-check",
                "content": "# **C++**\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& s) {\\n        sort(begin(s), end(s));\\n        long long ans = 0;\\n        long long set = s[0] + s[(int)s.size() - 1];\\n        int l = 0,  r = s.size() - 1;\\n        while(l<r){\\n            ll diff = s[l] + s[r];\\n            ans += s[l] * s[r];\\n            l++, r--;\\n            if(set != diff)     return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# **JAVA**\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int l = 0, r = skill.length - 1;\\n        long ans = 0;\\n        long set = skill[l] + skill[r];\\n        while ( l < r ){\\n            long diff = skill[l] + skill[r];\\n            ans += skill[l] * skill[r];\\n            l++; r--;\\n            if ( set != diff ) return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# **Python**\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill.sort()\\n        l, r = 0, len(skill)-1\\n        req, ans = skill[l] + skill[r], 0\\n        while l<r:\\n            diff = skill[l] + skill[r]\\n            ans = ans + skill[l] * skill[r]\\n            l, r = l + 1, r - 1\\n            if req != diff:\\n                return -1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& s) {\\n        sort(begin(s), end(s));\\n        long long ans = 0;\\n        long long set = s[0] + s[(int)s.size() - 1];\\n        int l = 0,  r = s.size() - 1;\\n        while(l<r){\\n            ll diff = s[l] + s[r];\\n            ans += s[l] * s[r];\\n            l++, r--;\\n            if(set != diff)     return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int l = 0, r = skill.length - 1;\\n        long ans = 0;\\n        long set = skill[l] + skill[r];\\n        while ( l < r ){\\n            long diff = skill[l] + skill[r];\\n            ans += skill[l] * skill[r];\\n            l++; r--;\\n            if ( set != diff ) return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill.sort()\\n        l, r = 0, len(skill)-1\\n        req, ans = skill[l] + skill[r], 0\\n        while l<r:\\n            diff = skill[l] + skill[r]\\n            ans = ans + skill[l] * skill[r]\\n            l, r = l + 1, r - 1\\n            if req != diff:\\n                return -1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874958,
                "title": "c-easy-and-simple-o-nlogn-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        long long maxi=0;\\n        int start=0;\\n        int end=skill.size()-1;\\n        long sum=skill[start]+skill[end];\\n        while(start<=end){\\n            long currsum=skill[start]+skill[end];\\n            if(sum!=currsum) return -1;\\n            maxi=maxi+(skill[start]*skill[end]);\\n            start++;\\n            end--;\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        long long maxi=0;\\n        int start=0;\\n        int end=skill.size()-1;\\n        long sum=skill[start]+skill[end];\\n        while(start<=end){\\n            long currsum=skill[start]+skill[end];\\n            if(sum!=currsum) return -1;\\n            maxi=maxi+(skill[start]*skill[end]);\\n            start++;\\n            end--;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875081,
                "title": "c-super-simple-solution-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n\\t\\t// sort the skill vector.\\n        sort(skill.begin(), skill.end());\\n        int s = 0, e = skill.size() - 1;\\n        long long ans = 0;\\n\\t\\t// vector to store sum of the skill of two players.\\n        vector<long long> v;\\n        while (s <= e)\\n        {\\n            v.push_back(skill[s] + skill[e]); \\n            ans += skill[s++] * skill[e--];\\n        }\\n\\t\\t// if every values in sum is not equal, then return -1.\\n        for (int i = 1; i < v.size(); i++)\\n            if (v[i - 1] != v[i])\\n                return -1;\\n\\t\\t// since it is not given that size of array is even check for the size.\\n        if (v.size() == skill.size()/ 2)\\n            return ans;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n\\t\\t// sort the skill vector.\\n        sort(skill.begin(), skill.end());\\n        int s = 0, e = skill.size() - 1;\\n        long long ans = 0;\\n\\t\\t// vector to store sum of the skill of two players.\\n        vector<long long> v;\\n        while (s <= e)\\n        {\\n            v.push_back(skill[s] + skill[e]); \\n            ans += skill[s++] * skill[e--];\\n        }\\n\\t\\t// if every values in sum is not equal, then return -1.\\n        for (int i = 1; i < v.size(); i++)\\n            if (v[i - 1] != v[i])\\n                return -1;\\n\\t\\t// since it is not given that size of array is even check for the size.\\n        if (v.size() == skill.size()/ 2)\\n            return ans;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875067,
                "title": "c-short-and-easy-o-1-space",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        \\n        long long ans = 0 ;\\n        int n = skill.size() ;\\n        \\n        // skill = [3,4]\\n        if( skill.size() == 3 ) return skill[0]*skill[1] ;\\n        // sort the skills \\n        sort( skill.begin(), skill.end() );\\n        \\n        int i=n/2-1 ;\\n        int j=n/2 ;\\n        int sum = skill[i]+ skill[j];\\n        \\n        while( i>=0 && j<n ){\\n            \\n            int tmp = skill[i] + skill[j] ;\\n            \\n            // It is necessary to divide all the teams equally \\n            if( tmp == sum ){\\n                // Calculate the chemistry \\n                ans += skill[i]*skill[j] ;\\n            }\\n            else {\\n                // If we are not able to divide the teams equally \\n                ans = 0;\\n                break ;\\n            }\\n            \\n            i--;\\n            j++;\\n        }\\n        \\n        if( ans == 0 ) return -1 ;\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        \\n        long long ans = 0 ;\\n        int n = skill.size() ;\\n        \\n        // skill = [3,4]\\n        if( skill.size() == 3 ) return skill[0]*skill[1] ;\\n        // sort the skills \\n        sort( skill.begin(), skill.end() );\\n        \\n        int i=n/2-1 ;\\n        int j=n/2 ;\\n        int sum = skill[i]+ skill[j];\\n        \\n        while( i>=0 && j<n ){\\n            \\n            int tmp = skill[i] + skill[j] ;\\n            \\n            // It is necessary to divide all the teams equally \\n            if( tmp == sum ){\\n                // Calculate the chemistry \\n                ans += skill[i]*skill[j] ;\\n            }\\n            else {\\n                // If we are not able to divide the teams equally \\n                ans = 0;\\n                break ;\\n            }\\n            \\n            i--;\\n            j++;\\n        }\\n        \\n        if( ans == 0 ) return -1 ;\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875167,
                "title": "sorting-2-pointers-easy-for-all-nlogn",
                "content": "**Simple approach just sort the array choose the smallest and the largest they will be your a single team \\ncreated a checker of which consist the sum of first and last index of array if the next sum is not equal to the checker return -1 simple !**\\n```\\nclass Solution\\n{\\npublic:\\n  long long dividePlayers(vector<int> &skill)\\n  {\\n\\n    sort(skill.begin(), skill.end());\\n    int i = 0, j = skill.size() - 1;\\n    long long ans = 0, checker = skill[i] + skill[j];\\n    while (i < j)\\n    {\\n      if (checker ! = skill[i] + skill[j])\\n        return -1;\\n      ans += skill[i++] * skill[j--];\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  long long dividePlayers(vector<int> &skill)\\n  {\\n\\n    sort(skill.begin(), skill.end());\\n    int i = 0, j = skill.size() - 1;\\n    long long ans = 0, checker = skill[i] + skill[j];\\n    while (i < j)\\n    {\\n      if (checker ! = skill[i] + skill[j])\\n        return -1;\\n      ans += skill[i++] * skill[j--];\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874988,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] s) {\\n        if(s.length==2)\\n        {\\n            return s[0]*s[1];\\n        }\\n        int p=0;\\n        for(int i:s)\\n        {\\n            p+=i;\\n        }\\n        Arrays.sort(s);\\n        long m=0;\\n        int x=s[0]+s[s.length-1];\\n        for(int i=0;i<s.length/2;i++)\\n        {\\n            //System.out.println(s[i]+\" \"+s[s.length-i-1]);\\n            if(s[i]+s[s.length-i-1] == x)\\n                m=m+(s[i]*s[s.length-i-1]);\\n            else\\n                return -1;\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] s) {\\n        if(s.length==2)\\n        {\\n            return s[0]*s[1];\\n        }\\n        int p=0;\\n        for(int i:s)\\n        {\\n            p+=i;\\n        }\\n        Arrays.sort(s);\\n        long m=0;\\n        int x=s[0]+s[s.length-1];\\n        for(int i=0;i<s.length/2;i++)\\n        {\\n            //System.out.println(s[i]+\" \"+s[s.length-i-1]);\\n            if(s[i]+s[s.length-i-1] == x)\\n                m=m+(s[i]*s[s.length-i-1]);\\n            else\\n                return -1;\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875947,
                "title": "c-python-c-sorting-solution-intuition-explanation",
                "content": "**Please upvote if it helps.**\\n\\n# **Intuition:**\\n\\nIn the question it is given we have to form teams of size 2 such that the total skill of each team is equal.\\n\\n**Note:- Total skill of each team should be equal.**\\n\\nSuppose the given array is `arr = [3,2,5,1,3,4]`\\n\\nTo make it qualify for the above condition we have to check for each team that the skills match.\\n\\nIn the above array the player 4(indexed 3) having least skill is of 1(skill[3]).\\n\\nSo in order to balance the team we have to make a team with the pair having weakest and strongest player in it.\\n\\n***Now, we can get the intuition that if the weakest have to team up with the strongest we can sort the array.***\\n\\nSorted `arr = [1,2,3,3,4,5]`\\n\\nNow, team can be formed with:\\n\\n* Player 1 and Player 6, Skill = 6\\n* Player 2 and Player 5, Skill = 6\\n* Player 3 and Player 4, Skill = 6\\n\\n**Code:**\\n\\n**C#**\\n\\n```\\npublic class Solution {\\n    public long DividePlayers(int[] skill) {\\n        int len = skill.Count() - 1;\\n        Array.Sort(skill, (a,b) => a-b);\\n        int reqSum = skill[0] + skill[len];\\n        int i = 0, j = len;\\n        long chem = 0;\\n        \\n        while(i < j)\\n        {\\n          int sum = skill[i] + skill[j];\\n          if(sum != reqSum) return -1;\\n          else chem = chem + (skill[i] * skill[j]);\\n          i++;\\n          j--;\\n        }\\n        return chem;\\n    }\\n}\\n```\\n\\n**Python:**\\n\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        \\n        skill.sort()\\n        chemistry, s = 0, skill[0] + skill[-1]\\n\\n        for i in range(len(ss)//2):\\n            if skill[i] + skill[-i-1] == s:\\n                chemistry += skill[i] * skill[-i-1]\\n            else:\\n                return -1\\n        return chemistry\\n\\n```\\n\\n**C++:**\\n\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int len = skill.size() - 1;\\n\\t\\tsort(skill.begin(), skill.end());\\n\\t\\tint reqSum = skill[0] + skill[len];\\n\\t\\tint i = 0, j = len;\\n\\t\\tlong chem = 0;\\n\\t\\twhile(i < j)\\n        {\\n          int sum = skill[i] + skill[j];\\n          if(sum != reqSum) return -1;\\n          else chem = chem + (skill[i] * skill[j]);\\n          i++;\\n          j--;\\n        }\\n        return chem;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public long DividePlayers(int[] skill) {\\n        int len = skill.Count() - 1;\\n        Array.Sort(skill, (a,b) => a-b);\\n        int reqSum = skill[0] + skill[len];\\n        int i = 0, j = len;\\n        long chem = 0;\\n        \\n        while(i < j)\\n        {\\n          int sum = skill[i] + skill[j];\\n          if(sum != reqSum) return -1;\\n          else chem = chem + (skill[i] * skill[j]);\\n          i++;\\n          j--;\\n        }\\n        return chem;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        \\n        skill.sort()\\n        chemistry, s = 0, skill[0] + skill[-1]\\n\\n        for i in range(len(ss)//2):\\n            if skill[i] + skill[-i-1] == s:\\n                chemistry += skill[i] * skill[-i-1]\\n            else:\\n                return -1\\n        return chemistry\\n\\n```\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int len = skill.size() - 1;\\n\\t\\tsort(skill.begin(), skill.end());\\n\\t\\tint reqSum = skill[0] + skill[len];\\n\\t\\tint i = 0, j = len;\\n\\t\\tlong chem = 0;\\n\\t\\twhile(i < j)\\n        {\\n          int sum = skill[i] + skill[j];\\n          if(sum != reqSum) return -1;\\n          else chem = chem + (skill[i] * skill[j]);\\n          i++;\\n          j--;\\n        }\\n        return chem;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875004,
                "title": "o-n-and-o-nlogn-approaches",
                "content": "**Approach-1:** Sorting + two-pointer, quite a simple one\\nTC->O(nlogn)\\n\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int lo = 0, hi = skill.length-1;\\n        \\n        int sum = skill[lo] + skill[hi];\\n        long prod = (long) skill[lo]*skill[hi];\\n        \\n        lo++;\\n        hi--;\\n        \\n        while(lo<hi){\\n            if(skill[hi] + skill[lo] != sum)\\n                return -1;\\n            else{\\n                prod +=(long) skill[lo] * skill[hi];\\n                lo++;\\n                hi--;\\n             }\\n        }\\n        return prod;\\n    }\\n}\\n```\\n**x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x=x**\\n\\n**Approach-2:** HashMap, if you have any doubts regarding this, you can ask them in comment.\\nTC->O(n)\\nSC->O(n), because obviously we\\'re using map,\\n\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Map<Integer,Integer> map = new HashMap();\\n        int sum = 0;\\n        int n = skill.length;\\n        \\n        for(int num : skill){\\n            sum += num;\\n            map.put(num, (map.getOrDefault(num,0)+1));\\n        }\\n\\t\\t\\t\\n        //checking whether we can divide sum into n/2 pairs,\\n\\t\\t\\n        if(sum%(n/2) != 0)\\n            return -1;\\n        \\n        int div = sum/(n/2);            // 6 for [3,2,5,1,3,4]\\n        \\n        long prod = 0;\\n        for(int i=0; i<n; i++){\\n            int num = skill[i];\\n            \\n\\t\\t\\t// div-num i.e. our target for each num, \\n\\t\\t\\t//either is not present in map, or has been used in previous iterations\\n\\t\\t\\t\\n            if(!map.containsKey(div - num) || map.get(div-num)<=0)\\n                return -1;\\n            \\n            map.put(div-num, map.get(div-num) - 1);\\n            \\n            prod += (long)(num*(div-num));\\n            \\n        }\\n        return prod/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int lo = 0, hi = skill.length-1;\\n        \\n        int sum = skill[lo] + skill[hi];\\n        long prod = (long) skill[lo]*skill[hi];\\n        \\n        lo++;\\n        hi--;\\n        \\n        while(lo<hi){\\n            if(skill[hi] + skill[lo] != sum)\\n                return -1;\\n            else{\\n                prod +=(long) skill[lo] * skill[hi];\\n                lo++;\\n                hi--;\\n             }\\n        }\\n        return prod;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Map<Integer,Integer> map = new HashMap();\\n        int sum = 0;\\n        int n = skill.length;\\n        \\n        for(int num : skill){\\n            sum += num;\\n            map.put(num, (map.getOrDefault(num,0)+1));\\n        }\\n\\t\\t\\t\\n        //checking whether we can divide sum into n/2 pairs,\\n\\t\\t\\n        if(sum%(n/2) != 0)\\n            return -1;\\n        \\n        int div = sum/(n/2);            // 6 for [3,2,5,1,3,4]\\n        \\n        long prod = 0;\\n        for(int i=0; i<n; i++){\\n            int num = skill[i];\\n            \\n\\t\\t\\t// div-num i.e. our target for each num, \\n\\t\\t\\t//either is not present in map, or has been used in previous iterations\\n\\t\\t\\t\\n            if(!map.containsKey(div - num) || map.get(div-num)<=0)\\n                return -1;\\n            \\n            map.put(div-num, map.get(div-num) - 1);\\n            \\n            prod += (long)(num*(div-num));\\n            \\n        }\\n        return prod/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874986,
                "title": "c-use-2-pointers-approach-easy-efficient-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n        int n=skill.size();\\n        sort(skill.begin(), skill.end());\\n        \\n\\t\\t//using two pointers approach to find equal skills for each team\\n        int l=0, h=n-1;\\n        long long chem=0;\\n        int team1 = skill[l]+skill[h];\\n        chem += skill[l++]*skill[h--];\\n        \\n        while(l<h)\\n        {\\n            if(team1 != skill[l]+skill[h]) return -1;\\n            chem += skill[l]*skill[h];\\n            l++, h--;\\n        }\\n        \\n        return chem;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n        int n=skill.size();\\n        sort(skill.begin(), skill.end());\\n        \\n\\t\\t//using two pointers approach to find equal skills for each team\\n        int l=0, h=n-1;\\n        long long chem=0;\\n        int team1 = skill[l]+skill[h];\\n        chem += skill[l++]*skill[h--];\\n        \\n        while(l<h)\\n        {\\n            if(team1 != skill[l]+skill[h]) return -1;\\n            chem += skill[l]*skill[h];\\n            l++, h--;\\n        }\\n        \\n        return chem;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937073,
                "title": "sort-inner-product",
                "content": "**C++**\\n```cpp\\nlong long dividePlayers(vector<int>& s) {\\n    sort(begin(s), end(s));\\n    for (int i = 1, j = s.size() - 2; i < j; ++i, --j)\\n        if (s[i] + s[j] != s[i - 1] + s[j + 1])\\n            return -1;\\n    return inner_product(begin(s), begin(s) + s.size() / 2, rbegin(s), 0LL);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long dividePlayers(vector<int>& s) {\\n    sort(begin(s), end(s));\\n    for (int i = 1, j = s.size() - 2; i < j; ++i, --j)\\n        if (s[i] + s[j] != s[i - 1] + s[j + 1])\\n            return -1;\\n    return inner_product(begin(s), begin(s) + s.size() / 2, rbegin(s), 0LL);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2896358,
                "title": "java-using-sorting-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        long res=0;\\n        int d=skill[0]+skill[skill.length-1];\\n        for(int i=0;i<skill.length/2;i++)\\n        {\\n            int s=skill[i];\\n            int e=skill[skill.length-1-i];\\n            if(d!=s+e)return -1;\\n            res+=(s*e);\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        long res=0;\\n        int d=skill[0]+skill[skill.length-1];\\n        for(int i=0;i<skill.length/2;i++)\\n        {\\n            int s=skill[i];\\n            int e=skill[skill.length-1-i];\\n            if(d!=s+e)return -1;\\n            res+=(s*e);\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874955,
                "title": "java-o-n-array-counting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse map to count the skill, and pair them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince `skill` is between [1, 1000], so we can use array to count the skill.\\nThen pair the team with total `chemistry` skill to a team.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long dividePlayers(int[] skill) {\\n    final int n = skill.length;\\n    int total = 0;\\n    int[] count = new int[2001];\\n    for (int s : skill) {\\n      total += s;\\n      count[s]++;\\n    }\\n\\n    if (total % (n / 2) != 0) {\\n      return -1;\\n    }\\n\\n    // skill of each team\\n    final int chemistry = total / (n / 2);\\n    // number of player paired\\n    int seen = 0;\\n    long result = 0;\\n    for (int i = 1; i < Math.min(chemistry, 2001); i++) {\\n      if (count[i] != count[chemistry - i]) {\\n        return -1;\\n      }\\n\\n      if (i == chemistry - i) {\\n        // player with same skill with even count\\n        if (count[i] % 2 != 0) {\\n          return -1;\\n        }\\n        result += (long) count[i] / 2 * i * (chemistry - i);\\n        seen += count[i];\\n      } else {\\n        result += (long) count[i] * i * (chemistry - i);\\n        seen += 2 * count[i];\\n      }\\n\\n      count[i] = 0;\\n      count[chemistry - i] = 0;\\n    }\\n\\n    if (seen != n) {\\n      return -1;\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n  public long dividePlayers(int[] skill) {\\n    final int n = skill.length;\\n    int total = 0;\\n    int[] count = new int[2001];\\n    for (int s : skill) {\\n      total += s;\\n      count[s]++;\\n    }\\n\\n    if (total % (n / 2) != 0) {\\n      return -1;\\n    }\\n\\n    // skill of each team\\n    final int chemistry = total / (n / 2);\\n    // number of player paired\\n    int seen = 0;\\n    long result = 0;\\n    for (int i = 1; i < Math.min(chemistry, 2001); i++) {\\n      if (count[i] != count[chemistry - i]) {\\n        return -1;\\n      }\\n\\n      if (i == chemistry - i) {\\n        // player with same skill with even count\\n        if (count[i] % 2 != 0) {\\n          return -1;\\n        }\\n        result += (long) count[i] / 2 * i * (chemistry - i);\\n        seen += count[i];\\n      } else {\\n        result += (long) count[i] * i * (chemistry - i);\\n        seen += 2 * count[i];\\n      }\\n\\n      count[i] = 0;\\n      count[chemistry - i] = 0;\\n    }\\n\\n    if (seen != n) {\\n      return -1;\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254751,
                "title": "time-o-nlogn-c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int i = 0, n = v.size()-1;\\n        int x = v[i]+v[n];\\n        while(++i<--n){\\n            if(x != v[i]+v[n])return -1;\\n        }\\n        long long int ans = 0;\\n        i = 0, n = v.size()-1;\\n        while(i<n){\\n            ans += (v[i++]*1LL*v[n--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int i = 0, n = v.size()-1;\\n        int x = v[i]+v[n];\\n        while(++i<--n){\\n            if(x != v[i]+v[n])return -1;\\n        }\\n        long long int ans = 0;\\n        i = 0, n = v.size()-1;\\n        while(i<n){\\n            ans += (v[i++]*1LL*v[n--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991530,
                "title": "c-sorting-two-pointers-easy-48-time-34-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& v) {\\n      int n = v.size(), l = 0, r = n - 1;\\n      sort(v.begin(), v.end());\\n      while(l < r){\\n        if(v[r - 1] - v[l] != v[r] - v[l + 1]) return -1;      \\n\\t\\t// Rearranged the equation v[r] + v[l] != v[r - 1] + v[l + 1] to avoid integer overflow\\n        l++; r--;\\n      }\\n      l = 0; r = n - 1;\\n      long long int ans = 0;\\n      while(l < r) ans += v[l++] * v[r--];\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& v) {\\n      int n = v.size(), l = 0, r = n - 1;\\n      sort(v.begin(), v.end());\\n      while(l < r){\\n        if(v[r - 1] - v[l] != v[r] - v[l + 1]) return -1;      \\n\\t\\t// Rearranged the equation v[r] + v[l] != v[r - 1] + v[l + 1] to avoid integer overflow\\n        l++; r--;\\n      }\\n      l = 0; r = n - 1;\\n      long long int ans = 0;\\n      while(l < r) ans += v[l++] * v[r--];\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879426,
                "title": "two-pointer-appraoch-java",
                "content": "First ,Sort the array so we can use two pointer approach to team up the weakest and strongest player.\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int len=skill.length;\\n        if(len == 2) return skill[0]*skill[1];\\n        int teams=len/2, sum=0;\\n        for(int i=0; i<len; i++){\\n            sum += skill[i];\\n        }\\n        int teamSkill = sum/teams;\\n        if(sum%teams != 0) return -1;\\n        long chem=0;\\n        Arrays.sort(skill);\\n        int low=0, high=len-1;\\n        while(low<high){\\n            int teammate1 = skill[low];\\n            int teammate2 = skill[high];\\n            int tempSum = teammate1 + teammate2;\\n            if(tempSum != teamSkill) return -1;\\n            chem = chem + (teammate1*teammate2);\\n            low++;\\n            high--;\\n        }\\n        return chem;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int len=skill.length;\\n        if(len == 2) return skill[0]*skill[1];\\n        int teams=len/2, sum=0;\\n        for(int i=0; i<len; i++){\\n            sum += skill[i];\\n        }\\n        int teamSkill = sum/teams;\\n        if(sum%teams != 0) return -1;\\n        long chem=0;\\n        Arrays.sort(skill);\\n        int low=0, high=len-1;\\n        while(low<high){\\n            int teammate1 = skill[low];\\n            int teammate2 = skill[high];\\n            int tempSum = teammate1 + teammate2;\\n            if(tempSum != teamSkill) return -1;\\n            chem = chem + (teammate1*teammate2);\\n            low++;\\n            high--;\\n        }\\n        return chem;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878023,
                "title": "c-simple-explanation-using-sorting",
                "content": "//T.C-> O(nlogn) for sorting\\n\\t\\t//S.C-> O(1) as no extra space is used\\n\\t\\t\\n\\t\\tint n=skill.size();\\n        sort(skill.begin(),skill.end());\\n        \\n        int curr_sum=skill[0]+skill[n-1];\\n        long long int product=skill[0]*skill[n-1];\\n        long long int final_sum=product;\\n        \\n        int i=1;\\n        int j=n-2;\\n         while(i<j){\\n             if((skill[i]+skill[j])==curr_sum){\\n                 final_sum+=(skill[i]*skill[j]);\\n             }\\n             else{\\n                 return -1;\\n             }\\n             i++;\\n             j--;\\n         }\\n        \\n        return final_sum;",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "//T.C-> O(nlogn) for sorting\\n\\t\\t//S.C-> O(1) as no extra space is used\\n\\t\\t\\n\\t\\tint n=skill.size();\\n        sort(skill.begin(),skill.end());\\n        \\n        int curr_sum=skill[0]+skill[n-1];\\n        long long int product=skill[0]*skill[n-1];\\n        long long int final_sum=product;\\n        \\n        int i=1;\\n        int j=n-2;\\n         while(i<j){\\n             if((skill[i]+skill[j])==curr_sum){\\n                 final_sum+=(skill[i]*skill[j]);\\n             }\\n             else{\\n                 return -1;\\n             }\\n             i++;\\n             j--;\\n         }\\n        \\n        return final_sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 2877684,
                "title": "javascript-simple-solution-149-ms",
                "content": "var dividePlayers = function(skill) {\\n  \\n    skill.sort((a,b)=>a-b)\\n    let j=skill.length-1\\n    let maxVal=skill[0]+skill[skill.length-1]\\n    let finalVal=0\\n    for(let i=0;i<=j/2;i++){\\n        if(maxVal==(skill[i]+skill[j-i]))\\n        finalVal+=(skill[i]*skill[j-i])\\n        else return -1;\\n    }\\n    return finalVal\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var dividePlayers = function(skill) {\\n  \\n    skill.sort((a,b)=>a-b)\\n    let j=skill.length-1\\n    let maxVal=skill[0]+skill[skill.length-1]\\n    let finalVal=0\\n    for(let i=0;i<=j/2;i++){\\n        if(maxVal==(skill[i]+skill[j-i]))\\n        finalVal+=(skill[i]*skill[j-i])\\n        else return -1;\\n    }\\n    return finalVal\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2876970,
                "title": "grouping-the-best-with-worst",
                "content": "# Intuition\\nSort the skill then pair the best with the worst and so on.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAfter sorting applying two pointers for first and last.\\nsumming up to see if it fulfills the requirements of equal sum and caluculating the chemistry.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(nlogn)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(), skill.end());\\n        int l = 0, r = skill.size() - 1;\\n        int sum = skill[l] + skill[r];\\n        long long chem = 0;\\n        while(l < r) {\\n            if(skill[l] + skill[r] != sum)\\n                return -1;\\n            chem += skill[l] * skill[r];\\n            l++;\\n            r--;\\n        }\\n        return chem;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(), skill.end());\\n        int l = 0, r = skill.size() - 1;\\n        int sum = skill[l] + skill[r];\\n        long long chem = 0;\\n        while(l < r) {\\n            if(skill[l] + skill[r] != sum)\\n                return -1;\\n            chem += skill[l] * skill[r];\\n            l++;\\n            r--;\\n        }\\n        return chem;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875350,
                "title": "simple-optimized-and-easy-solution-in-c-o-nlogn-time",
                "content": "# Intuition\\nWE  need to check the skill in order to make it equal skilled team \\nit will  happen  only if lower skills plahyer will be matched with higher skilled player So i have sorted the given vector\\n```\\n  sort(v.begin(),v.end());\\n```\\n# Approach\\nI have taken a two vector f,g of type int to store sum and product of the elemnts  \\nI have ietrate to size/2 as we need to made team of 2 and size/2 teams one iteration for one team \\nI have mapped 0 to n,  1 to n-1 , 2 to n-2 and so on  and such that there skill can be balanced \\nThier sum is stored in  vector f and Product is in vector  g\\n```\\nfor(int i=0;i<l/2; i++)\\n   {\\n       int x=v[i]+v[l-i-1];\\n       int y=v[i]*v[l-i-1];\\n      \\n       f.push_back(x);\\n       g.push_back(y);    \\n   }\\n```\\n\\n Example test case\\nInput: skill = [3,2,5,1,3,4]\\nOutput: 22\\nAfter sorting [1,2,3,3,4,5]\\nnow mapping 1-5,2-4,3-3 \\n\\nNow we will iterate through vector f if any two elements found unequal we will return false as team cann\\'t be made with equal skills\\n```\\n for(int i=0; i<f.size()-1; i++)\\n        {\\n            if(f[i]!=f[i+1]){\\n                return -1;\\n            }\\n        }\\n``` \\n\\nFinally we will sum up all the elwments in vector g and return  it.\\nIt will run only if teams are divided with same skills otherwise in the uppper part of code we have already checked for false codition \\nand returned -1;\\n```\\n\\n         for(int i=0; i<g.size(); i++)\\n         {\\n           sum+=g[i];  \\n         }\\n``` \\nWe will return sum which will our result\\n\\nWE can use two pointer approach as well\\n\\n\\n# Complexity\\n- Time complexity:\\n$O(nlogn)$\\n\\n- Space complexity:\\n$O(n) as we have used vector to store sum and product\\n\\n\\n# IF IT\\'S HELPFUL UPVOTE MY SOLUTION\\n##### FOR ANY DOUBT ASK IN COMMENT SECTION\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& v) {\\n        int l=v.size();\\n        vector<int> f,g;\\n        long long int sum=0;\\n       \\n        sort(v.begin(),v.end());\\n   for(int i=0;i<l/2; i++)\\n   {\\n       int x=v[i]+v[l-i-1];\\n       int y=v[i]*v[l-i-1];\\n      \\n       f.push_back(x);\\n       g.push_back(y);    \\n   }\\n        for(int i=0; i<f.size()-1; i++)\\n        {\\n            if(f[i]!=f[i+1]){\\n                return -1;\\n            }\\n        }\\n         for(int i=0; i<g.size(); i++)\\n         {\\n           sum+=g[i];  \\n         }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n  sort(v.begin(),v.end());\\n```\n```\\nfor(int i=0;i<l/2; i++)\\n   {\\n       int x=v[i]+v[l-i-1];\\n       int y=v[i]*v[l-i-1];\\n      \\n       f.push_back(x);\\n       g.push_back(y);    \\n   }\\n```\n```\\n for(int i=0; i<f.size()-1; i++)\\n        {\\n            if(f[i]!=f[i+1]){\\n                return -1;\\n            }\\n        }\\n```\n```\\n\\n         for(int i=0; i<g.size(); i++)\\n         {\\n           sum+=g[i];  \\n         }\\n```\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& v) {\\n        int l=v.size();\\n        vector<int> f,g;\\n        long long int sum=0;\\n       \\n        sort(v.begin(),v.end());\\n   for(int i=0;i<l/2; i++)\\n   {\\n       int x=v[i]+v[l-i-1];\\n       int y=v[i]*v[l-i-1];\\n      \\n       f.push_back(x);\\n       g.push_back(y);    \\n   }\\n        for(int i=0; i<f.size()-1; i++)\\n        {\\n            if(f[i]!=f[i+1]){\\n                return -1;\\n            }\\n        }\\n         for(int i=0; i<g.size(); i++)\\n         {\\n           sum+=g[i];  \\n         }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875199,
                "title": "c-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skills) \\n    {\\n        int n = skills.size();\\n        sort(skills.begin(), skills.end());\\n        long long ans = (skills[0] * skills[n - 1]);\\n        int target = skills[0] + skills[n - 1];\\n        for (int i = 1, j = n - 2; i < j; i++, j--)\\n        {\\n            int sum = skills[i] + skills[j];\\n            if (sum != target) return -1;\\n            \\n            long long prod = skills[i] * skills[j];\\n            ans += prod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skills) \\n    {\\n        int n = skills.size();\\n        sort(skills.begin(), skills.end());\\n        long long ans = (skills[0] * skills[n - 1]);\\n        int target = skills[0] + skills[n - 1];\\n        for (int i = 1, j = n - 2; i < j; i++, j--)\\n        {\\n            int sum = skills[i] + skills[j];\\n            if (sum != target) return -1;\\n            \\n            long long prod = skills[i] * skills[j];\\n            ans += prod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875126,
                "title": "java-easy-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic long dividePlayers(int[] skill) {\\n\\t\\t\\tlong ans = 0;\\n\\t\\t\\t Arrays.sort(skill);\\n\\t\\t\\tint n = skill.length;\\n\\t\\t\\tfor(int i=0;i<n/2;i++){\\n\\t\\t\\t\\tif(skill[i]+skill[n-i-1]!=skill[0]+skill[n-1]){\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans+=skill[i]*skill[n-i-1];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic long dividePlayers(int[] skill) {\\n\\t\\t\\tlong ans = 0;\\n\\t\\t\\t Arrays.sort(skill);\\n\\t\\t\\tint n = skill.length;\\n\\t\\t\\tfor(int i=0;i<n/2;i++){\\n\\t\\t\\t\\tif(skill[i]+skill[n-i-1]!=skill[0]+skill[n-1]){\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2875115,
                "title": "java-solution-using-two-pointer",
                "content": "```\\npublic long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int i=0;\\n        int j=skill.length-1;\\n        int sum=skill[i]+skill[j];\\n        long product=skill[i]*skill[j];\\n        i++;\\n        j--;\\n        while(i<j){\\n            if(sum!=skill[i]+skill[j]){\\n                return -1;\\n            }\\n            else{\\n                product+=skill[i]*skill[j];\\n                i++;\\n                j--;\\n            }\\n        }\\n        return product;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int i=0;\\n        int j=skill.length-1;\\n        int sum=skill[i]+skill[j];\\n        long product=skill[i]*skill[j];\\n        i++;\\n        j--;\\n        while(i<j){\\n            if(sum!=skill[i]+skill[j]){\\n                return -1;\\n            }\\n            else{\\n                product+=skill[i]*skill[j];\\n                i++;\\n                j--;\\n            }\\n        }\\n        return product;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2875091,
                "title": "c-using-pairs-stl-simple-approach",
                "content": "class Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n\\t\\n        long long  len = skill.size();\\n        if(len==2) return skill[0]*skill[1];\\n        sort(skill.begin(),skill.end());\\n        vector<pair<long long ,long long >> ans;\\n        long long  sum = skill[0]+skill[len-1];\\n        long long  start = 0,end = len-1;\\n        while(start<=end){\\n            if(sum!=skill[start]+skill[end]) return -1;\\n            else ans.push_back({skill[start],skill[end]});\\n            start++;\\n            end--;\\n        }\\n        long long  sum_ans=0;\\n        for(auto i : ans){\\n            sum_ans = sum_ans +  (i.first*i.second);\\n        }\\n        return sum_ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n\\t\\n        long long  len = skill.size();\\n        if(len==2) return skill[0]*skill[1];\\n        sort(skill.begin(),skill.end());\\n        vector<pair<long long ,long long >> ans;\\n        long long  sum = skill[0]+skill[len-1];\\n        long long  start = 0,end = len-1;\\n        while(start<=end){\\n            if(sum!=skill[start]+skill[end]) return -1;\\n            else ans.push_back({skill[start],skill[end]}",
                "codeTag": "Java"
            },
            {
                "id": 2875084,
                "title": "why-use-pair-when-you-can-use-vector",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        \\n        long long n = skill.size();\\n        sort(skill.begin() , skill.end());\\n        vector<long long>a;\\n        long long start = 0,end = n-1;\\n        long long sum = skill[0] + skill[n-1];\\n        long long k = 0;\\n        \\n        while(start<=end){\\n            if((skill[start] + skill[end])!= sum) return -1;\\n            a.push_back(skill[start]);\\n            a.push_back(skill[end]);\\n            start++;end--;k++;\\n        }\\n        k=0;\\n        long long ans = 0;\\n        for(long long i = 0 ; i < a.size() ; i+=2){\\n            ans+=a[i]*a[i+1];\\n            k++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        \\n        long long n = skill.size();\\n        sort(skill.begin() , skill.end());\\n        vector<long long>a;\\n        long long start = 0,end = n-1;\\n        long long sum = skill[0] + skill[n-1];\\n        long long k = 0;\\n        \\n        while(start<=end){\\n            if((skill[start] + skill[end])!= sum) return -1;\\n            a.push_back(skill[start]);\\n            a.push_back(skill[end]);\\n            start++;end--;k++;\\n        }\\n        k=0;\\n        long long ans = 0;\\n        for(long long i = 0 ; i < a.size() ; i+=2){\\n            ans+=a[i]*a[i+1];\\n            k++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875046,
                "title": "python-two-approaches-video-solution",
                "content": "I have tried to explain both the solutions in a [video](https://youtu.be/a3rEeERB0Qk).\\n# HashMap\\n\\nIn this case, the **desired_sum** is `2 * sum(skill) // len(skill)`\\n\\nSo, for each number **x** we have to pair it with `desired_sum - x`.\\n\\nThe counts for both of them should be exactly equal, else we cannot pair all elements.\\n\\nWe are counting each pair, twice ( one from each number).\\n\\nHence, we are dividing our answer by 2.\\n\\n**Time**: `O(N)`\\n**Space**: `O(N)`\\n\\n\\n\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        \\n        desired_sum = 2 * sum(skill) // len(skill)\\n        \\n        chemistry = 0\\n        cnt = Counter(skill)\\n        \\n        for val, count in cnt.items():\\n            diff = desired_sum - val\\n            \\n            if count != cnt[diff]: return -1\\n            \\n            chemistry += count * val * diff\\n            \\n        return chemistry // 2\\n```\\n\\n# Two Sum\\n\\nThis is similar problem to `Two Sum` https://leetcode.com/problems/two-sum/.\\n\\n\\nOur desired sum for each pair is `total // no_of_pairs`.\\n\\nNo of pairs is `n//2`\\n\\nThen we can sort and use **Two Pointer** approach just like in **Two Sum**.\\n\\n\\n**Time**: `O(NlogN)`\\n**Space**: `O(1)`\\n\\n\\n\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        total_sum = sum(skill)              # Total sum\\n        n = len(skill)\\n        \\n        total_no = n//2              # No of pairs\\n                \\n        desired = total_sum // total_no        # Desired sum of each pair\\n                \\n        skill.sort()\\n        \\n        chemistry_tot = 0\\n        \\n        l = 0                           # Two Pointer (Two Sum)             \\n        r = n-1\\n        \\n        while l<r:\\n            if skill[l]+skill[r]==desired:\\n                chemistry_tot+=skill[l]*skill[r]\\n            else:\\n                return -1\\n            l+=1\\n            r-=1\\n            \\n        return chemistry_tot\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        \\n        desired_sum = 2 * sum(skill) // len(skill)\\n        \\n        chemistry = 0\\n        cnt = Counter(skill)\\n        \\n        for val, count in cnt.items():\\n            diff = desired_sum - val\\n            \\n            if count != cnt[diff]: return -1\\n            \\n            chemistry += count * val * diff\\n            \\n        return chemistry // 2\\n```\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        total_sum = sum(skill)              # Total sum\\n        n = len(skill)\\n        \\n        total_no = n//2              # No of pairs\\n                \\n        desired = total_sum // total_no        # Desired sum of each pair\\n                \\n        skill.sort()\\n        \\n        chemistry_tot = 0\\n        \\n        l = 0                           # Two Pointer (Two Sum)             \\n        r = n-1\\n        \\n        while l<r:\\n            if skill[l]+skill[r]==desired:\\n                chemistry_tot+=skill[l]*skill[r]\\n            else:\\n                return -1\\n            l+=1\\n            r-=1\\n            \\n        return chemistry_tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875038,
                "title": "c-sort-easy",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time com/plexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll; \\n    long long dividePlayers(vector<int>& skill) {\\n        \\n        ll len=skill.size(),ans=0;\\n        sort(skill.begin(),skill.end());\\n        int st=0,en=len-1,pre=skill[st]+skill[en];\\n        \\n        while(st<en){\\n            \\n            if(skill[st]+skill[en] != pre)\\n                return -1;\\n        \\n            ans += (skill[st++]*skill[en--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll; \\n    long long dividePlayers(vector<int>& skill) {\\n        \\n        ll len=skill.size(),ans=0;\\n        sort(skill.begin(),skill.end());\\n        int st=0,en=len-1,pre=skill[st]+skill[en];\\n        \\n        while(st<en){\\n            \\n            if(skill[st]+skill[en] != pre)\\n                return -1;\\n        \\n            ans += (skill[st++]*skill[en--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875032,
                "title": "easiest-without-map-solution-intuition-and-steps-explained",
                "content": "##### Intuition and Steps: \\n\\n1. Lets say skills = `{3,2,5,1,3,4}`\\nSo 3 can be paired with 3 and skills become --> `{2, 5, 1, 4}`\\nThen 2 can be paired with 4 and skills become --> `{5, 1}`\\nThen 5 can be paired with 1 and skills become --> `{}`\\nObservation - The largest skill teams up with the smallest skill, the 2nd largest with 2nd smallest and so on.\\nConclusion - we need to sort the array.\\n\\n2. We can now use a two pointers approach to check if 2 skills can be paired or not. If not, return `-1`.\\n\\n3. Return `sum of (product of skills in a team)`.\\n\\n```java\\nclass Solution {\\n    public long dividePlayers(int[] skills) {\\n\\t\\tArrays.sort(skills);\\n\\t\\tint i = 0;\\n\\t\\tint j = skills.length-1;\\n        int reqSkill = skills[i] + skills[j];\\n        \\n        long ans = 0;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tif (skills[i] + skills[j] == reqSkill) {\\n\\t\\t\\t\\tans += skills[i++] * skills[j--];\\n\\t\\t\\t}\\n\\t\\t\\telse return -1;\\n\\t\\t}\\n        \\n        return ans;\\t\\n    }\\n}\\n```\\n\\n**Time complexity:** `O(NlogN)`\\n**Space complexity:** `O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public long dividePlayers(int[] skills) {\\n\\t\\tArrays.sort(skills);\\n\\t\\tint i = 0;\\n\\t\\tint j = skills.length-1;\\n        int reqSkill = skills[i] + skills[j];\\n        \\n        long ans = 0;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tif (skills[i] + skills[j] == reqSkill) {\\n\\t\\t\\t\\tans += skills[i++] * skills[j--];\\n\\t\\t\\t}\\n\\t\\t\\telse return -1;\\n\\t\\t}\\n        \\n        return ans;\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874964,
                "title": "c-easy-o-n-solution-with-explanation",
                "content": "## Approach\\nAccording to the definition of this problem.\\nWe can know the sum of each teams is **sum of all players divide by (n / 2)**.\\n\\nSo calculate the total sum and check it\\'s valid or not.\\n\\nSimilar to **[2206. Divide Array Into Equal Pairs](https://leetcode.com/problems/divide-array-into-equal-pairs/)**\\n## Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& s) {\\n        ll n = s.size(), sum = 0, ans = 0;\\n        unordered_map<int, ll> m;\\n        for(const auto &i : s) {\\n            sum += i;\\n            ++m[i];\\n        }\\n        // check it\\'s valid or not\\n        if(sum % (n / 2) != 0)\\n            return -1;\\n        // sum of each team \\n        sum /= (n / 2);\\n        for(auto i : s) {\\n            if(!m[i])\\n                continue;\\n            ll want = sum - i;\\n            --m[i];\\n            if(m[want] > 0) {\\n                ans += i * want;\\n                --m[want];\\n            }\\n            else\\n                return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Upvote** if you like this post : )",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& s) {\\n        ll n = s.size(), sum = 0, ans = 0;\\n        unordered_map<int, ll> m;\\n        for(const auto &i : s) {\\n            sum += i;\\n            ++m[i];\\n        }\\n        // check it\\'s valid or not\\n        if(sum % (n / 2) != 0)\\n            return -1;\\n        // sum of each team \\n        sum /= (n / 2);\\n        for(auto i : s) {\\n            if(!m[i])\\n                continue;\\n            ll want = sum - i;\\n            --m[i];\\n            if(m[want] > 0) {\\n                ans += i * want;\\n                --m[want];\\n            }\\n            else\\n                return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874950,
                "title": "python-sorting-solution",
                "content": "sort and pair next smallest and largest \\n```\\nclass Solution:\\n    def dividePlayers(self, S: List[int]) -> int:\\n        S.sort()\\n        n = len(S)\\n        s = S[0] + S[-1]\\n        total = 0\\n        for i in range(n // 2):\\n            if s != S[i] + S[n - i - 1]:\\n                return -1\\n            total += S[i] * S[n - i - 1]\\n            \\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, S: List[int]) -> int:\\n        S.sort()\\n        n = len(S)\\n        s = S[0] + S[-1]\\n        total = 0\\n        for i in range(n // 2):\\n            if s != S[i] + S[n - i - 1]:\\n                return -1\\n            total += S[i] * S[n - i - 1]\\n            \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617984,
                "title": "simple-python-solution-using-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, A: List[int]) -> int:\\n        A.sort()\\n        n = len(A)\\n        a = [A[i]+A[n-i-1] for i in range(n//2)]\\n        if len(set(a)) != 1: return -1\\n        return sum(A[i]*A[n-i-1] for i in range(n//2)) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, A: List[int]) -> int:\\n        A.sort()\\n        n = len(A)\\n        a = [A[i]+A[n-i-1] for i in range(n//2)]\\n        if len(set(a)) != 1: return -1\\n        return sum(A[i]*A[n-i-1] for i in range(n//2)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193639,
                "title": "sorting-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan\\'t we just sort and check for the elements????\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust sort the array and check the sum of end elements.\\nIf the sum of the end elements are same then store their product in a variable \"ans\" and repeat the process till the mid.\\n\\nIf any pair don\\'t sum-up equal to its previous pair-sum then simply return \\'-1\\'.\\nOtherwise return \"ans\" in the end.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n// // **************** Using sorting *****************\\n// class Solution {\\n// public:\\n//     long long dividePlayers(vector<int>& skill) {\\n//         int n=skill.size();\\n//         sort(skill.begin(), skill.end());\\n//         long long ans=0;\\n//         int low=0, high=n-1;\\n//         int skl=skill[low]+skill[high];\\n\\n//         while(low<=high){\\n//             if( (skill[low]+skill[high])!=skl) return -1;\\n//             ans+=skill[low]*skill[high];\\n//             low++;\\n//             high--;\\n//         }\\n\\n//         return ans;\\n//     }\\n// };\\n\\n\\n\\n\\n\\n// **************** Using map *****************\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n=skill.size();\\n        long long sum=accumulate(skill.begin(), skill.end(), 0);\\n        if(sum%(n/2)) return -1;\\n        long long skillTeam=sum/(n/2);\\n\\n        unordered_map<int,int>mp;\\n        for(auto it: skill){\\n            mp[it]++;\\n        }\\n\\n        long long ans=0;\\n\\n        for(auto it: skill){\\n            if(mp.find(it)==mp.end()) continue;\\n            mp[it]--;\\n\\n            int temp=skillTeam-it;\\n            if(mp.find(temp)!=mp.end()){\\n                mp[temp]--;\\n                if(mp[temp]==0) mp.erase(temp);\\n                ans+=it*temp;\\n                if(mp[it]==0) mp.erase(it);\\n            }\\n        }\\n\\n        if(mp.size()>0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\n// // **************** Using sorting *****************\\n// class Solution {\\n// public:\\n//     long long dividePlayers(vector<int>& skill) {\\n//         int n=skill.size();\\n//         sort(skill.begin(), skill.end());\\n//         long long ans=0;\\n//         int low=0, high=n-1;\\n//         int skl=skill[low]+skill[high];\\n\\n//         while(low<=high){\\n//             if( (skill[low]+skill[high])!=skl) return -1;\\n//             ans+=skill[low]*skill[high];\\n//             low++;\\n//             high--;\\n//         }\\n\\n//         return ans;\\n//     }\\n// };\\n\\n\\n\\n\\n\\n// **************** Using map *****************\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n=skill.size();\\n        long long sum=accumulate(skill.begin(), skill.end(), 0);\\n        if(sum%(n/2)) return -1;\\n        long long skillTeam=sum/(n/2);\\n\\n        unordered_map<int,int>mp;\\n        for(auto it: skill){\\n            mp[it]++;\\n        }\\n\\n        long long ans=0;\\n\\n        for(auto it: skill){\\n            if(mp.find(it)==mp.end()) continue;\\n            mp[it]--;\\n\\n            int temp=skillTeam-it;\\n            if(mp.find(temp)!=mp.end()){\\n                mp[temp]--;\\n                if(mp[temp]==0) mp.erase(temp);\\n                ans+=it*temp;\\n                if(mp[it]==0) mp.erase(it);\\n            }\\n        }\\n\\n        if(mp.size()>0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146159,
                "title": "divide-players-into-teams-of-equal-skill",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, s: List[int]) -> int:\\n        s.sort()\\n        l = 0\\n        r = len(s)-1\\n        p = []\\n        f = []\\n        while l< len(s)/2:\\n            p.append(s[l] * s[r])\\n            f.append(s[l] + s[r])\\n            l+=1\\n            r-=1\\n        if len(set(f))==1:\\n            return (sum(p))\\n        else:\\n            return (-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, s: List[int]) -> int:\\n        s.sort()\\n        l = 0\\n        r = len(s)-1\\n        p = []\\n        f = []\\n        while l< len(s)/2:\\n            p.append(s[l] * s[r])\\n            f.append(s[l] + s[r])\\n            l+=1\\n            r-=1\\n        if len(set(f))==1:\\n            return (sum(p))\\n        else:\\n            return (-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126164,
                "title": "very-easy-c-solution-100-beat-time-complexity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n = skill.size();\\n        int sum = skill[0]+skill[n-1];\\n        long long ans = skill[0]*skill[n-1];\\n        for(int i=1;i<n/2;i++)\\n        {\\n            if(sum != skill[i]+skill[n-i-1])\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                ans = ans + (skill[i]*skill[n-i-1]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n = skill.size();\\n        int sum = skill[0]+skill[n-1];\\n        long long ans = skill[0]*skill[n-1];\\n        for(int i=1;i<n/2;i++)\\n        {\\n            if(sum != skill[i]+skill[n-i-1])\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                ans = ans + (skill[i]*skill[n-i-1]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998649,
                "title": "c-sorting-easy-to-understand",
                "content": "# Intuition\\nCombine weakest with Strongest\\n\\n# Approach\\nSort the vector and combine weakest one with strongest one , if it matches the sequence update the ressult else return -1\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        long long ans=skill[0]*skill[skill.size()-1];\\n        int holder=skill[0]+skill[skill.size()-1];\\n        int p=2;\\n        for(int i=1;i<skill.size()-p;i++){\\n            int j=skill.size()-p;\\n            if(skill[i]+skill[j]!=holder) return -1;\\n            ans+=(skill[i]*skill[j]);\\n            p+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        long long ans=skill[0]*skill[skill.size()-1];\\n        int holder=skill[0]+skill[skill.size()-1];\\n        int p=2;\\n        for(int i=1;i<skill.size()-p;i++){\\n            int j=skill.size()-p;\\n            if(skill[i]+skill[j]!=holder) return -1;\\n            ans+=(skill[i]*skill[j]);\\n            p+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903292,
                "title": "java-easy-sorting",
                "content": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int n = skill.length;\\n        long sum = skill[0] + skill[n-1];\\n        long ans = 0L;\\n        for(int i = 0; i <n/2; i++) {\\n            if(sum == (skill[i] + skill[n-1-i])) {\\n                ans += skill[i]*skill[n-1-i];\\n                continue;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int n = skill.length;\\n        long sum = skill[0] + skill[n-1];\\n        long ans = 0L;\\n        for(int i = 0; i <n/2; i++) {\\n            if(sum == (skill[i] + skill[n-1-i])) {\\n                ans += skill[i]*skill[n-1-i];\\n                continue;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897802,
                "title": "java-solution-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem that is trick in the first time when we have seen. However, look at the problem when we sort, you can see that we will have the pair when we combine the smallest and largest values together. Similarly to the next pair is the second smallest and second largest values\\n\\nFor example:\\nint[] arr = {3,6,5,4,2,7};\\n\\nAfter sorting that arr = {2,3,4,5,6,7};\\nwe have three pairs they are : {2,7}, {3,6}, {4,5}\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) cause we have we sort using function in built that use merge sort and while loop will be decrease by divide 2 it means if we have 10 values => we will start from 1 to 5 (1, 10) (2, 9) (3, 8), (4, 7), (5, 6) => O(logn) \\n\\n=> O(nlogn) + O(logn) => O(logn) \\n\\nPLEASE GUYS. If you see that my solution is helpful. Please voit it. I appreciate that. \\uD83D\\uDE0E\\uD83D\\uDE0E\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int len = skill.length-1;\\n        Arrays.sort(skill);\\n        \\n        int sumInit = skill[0] + skill[len];\\n        long res = skill[0] * skill[len];\\n        \\n        int i = 1, j = len-1, sumCont = 0;\\n        while(i < j){\\n            sumCont = skill[i] + skill[j];\\n            if(sumCont != sumInit) {\\n                return -1;\\n            }else{\\n                res += skill[i] * skill[j];      \\n            }\\n            i++;\\n            j--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int len = skill.length-1;\\n        Arrays.sort(skill);\\n        \\n        int sumInit = skill[0] + skill[len];\\n        long res = skill[0] * skill[len];\\n        \\n        int i = 1, j = len-1, sumCont = 0;\\n        while(i < j){\\n            sumCont = skill[i] + skill[j];\\n            if(sumCont != sumInit) {\\n                return -1;\\n            }else{\\n                res += skill[i] * skill[j];      \\n            }\\n            i++;\\n            j--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890478,
                "title": "go-simple-solution",
                "content": "# Code\\n```\\nfunc dividePlayers(skill []int) int64 {\\n    sort.Ints(skill)\\n\\n    var result int64\\n    sum := skill[0] + skill[len(skill)-1]\\n    \\n    for i, j := 0, len(skill)-1; i < j; i, j = i+1, j-1 {\\n        if (skill[i] + skill [j]) != sum { return -1 }\\n        result += int64(skill[j] * skill[i])\\n    }\\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc dividePlayers(skill []int) int64 {\\n    sort.Ints(skill)\\n\\n    var result int64\\n    sum := skill[0] + skill[len(skill)-1]\\n    \\n    for i, j := 0, len(skill)-1; i < j; i, j = i+1, j-1 {\\n        if (skill[i] + skill [j]) != sum { return -1 }\\n        result += int64(skill[j] * skill[i])\\n    }\\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2890162,
                "title": "java-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int target=skill[0]+skill[skill.length-1];\\n        int i=0,j=skill.length-1;\\n        if(skill.length%2==1) return -1;\\n        long ans=0;\\n        while(i<j){\\n            int sum= skill[i]+skill[j];\\n            if(sum!=target) return -1;\\n            else {\\n                ans+=skill[i]*skill[j];\\n            }\\n            i++;j--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int target=skill[0]+skill[skill.length-1];\\n        int i=0,j=skill.length-1;\\n        if(skill.length%2==1) return -1;\\n        long ans=0;\\n        while(i<j){\\n            int sum= skill[i]+skill[j];\\n            if(sum!=target) return -1;\\n            else {\\n                ans+=skill[i]*skill[j];\\n            }\\n            i++;j--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885542,
                "title": "python-beats-99",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ Linear passes through array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ For map in worst case.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        n = len(skill)\\n        # Target sum for each group\\n        target = 2 * sum(skill) / n\\n        # Check that this target is an integer\\n        if target % 1 != 0: return -1\\n        counts = Counter(skill)\\n        ans = 0\\n        for s, c in counts.items():\\n            # Sanity checks, we need to check that for each number s,\\n            # we can make a total of c pairs\\n            if target - s not in counts: return -1\\n            if c != counts[target - s]: return -1\\n            # Add to answer. Note that we will also iterate over target - s\\n            # therefore we are double counting.\\n            # Furthermore, when s == target - s, note that in the final solution\\n            # only c / 2 pairs are valid, so this line \\'double counts\\'\\n            # in this case as well\\n            total_chem = int(s * (target - s) * c)\\n            ans += total_chem\\n        # Divide answer by 2\\n        return ans >> 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        n = len(skill)\\n        # Target sum for each group\\n        target = 2 * sum(skill) / n\\n        # Check that this target is an integer\\n        if target % 1 != 0: return -1\\n        counts = Counter(skill)\\n        ans = 0\\n        for s, c in counts.items():\\n            # Sanity checks, we need to check that for each number s,\\n            # we can make a total of c pairs\\n            if target - s not in counts: return -1\\n            if c != counts[target - s]: return -1\\n            # Add to answer. Note that we will also iterate over target - s\\n            # therefore we are double counting.\\n            # Furthermore, when s == target - s, note that in the final solution\\n            # only c / 2 pairs are valid, so this line \\'double counts\\'\\n            # in this case as well\\n            total_chem = int(s * (target - s) * c)\\n            ans += total_chem\\n        # Divide answer by 2\\n        return ans >> 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879383,
                "title": "o-n-java-solution-using-sort-and-two-pointer",
                "content": "# Intuition\\nSorting, Two pointer \\nEg. 3 2 5 1 3 4\\nafter sorting it will become 1 2 3 3 4 5 (now just keep checking sum of first and last index, they are equal \\uD83D\\uDE0E)  \\n\\n# Approach\\nSort the array and just check sum of first and last index.\\nIf they are equal add in ans, else return -1;\\n\\n# Complexity\\n- Time complexity:\\nO(n) + for sorting (O(nlog(n)))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int temp = 0;\\n        Arrays.sort(skill);\\n        int len = skill.length;\\n        long ans = 0;\\n        for(int i = 0; i < len / 2; i++) {\\n            int first = skill[i];\\n            int last = skill[len - i - 1];\\n            int sum = first + last;\\n            if(i > 0 && sum != temp) { // temp for storing previous sum\\n                return -1;\\n            }\\n            temp = sum;\\n            ans += first * last;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int temp = 0;\\n        Arrays.sort(skill);\\n        int len = skill.length;\\n        long ans = 0;\\n        for(int i = 0; i < len / 2; i++) {\\n            int first = skill[i];\\n            int last = skill[len - i - 1];\\n            int sum = first + last;\\n            if(i > 0 && sum != temp) { // temp for storing previous sum\\n                return -1;\\n            }\\n            temp = sum;\\n            ans += first * last;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878424,
                "title": "easy-js-solution-using-2-pointer-strategy-o-nlogn",
                "content": "### Easy JS solution using sorting and two-pointer approach\\n```\\n// Sort the array to assign players to team such that one is a low skill player and another high skill player. This way we can try to divide teams so that all teams have equal skill rating\\n// store skill of prev team in a variable so that we can compare it to the skill of current team\\n// Return -1 if skill of prev and curr team is not equal\\n// if skills match, continue adding chemistry and return chemistry once all the teams are processed\\nvar dividePlayers = function(skill) {\\n    skill.sort((a, b) => a - b);\\n    const len = skill.length;\\n    let totalChemistry = 0;\\n    let prev = skill[0] + skill[len - 1];\\n    totalChemistry += skill[0]*skill[len - 1];\\n    let currSkill = prev;\\n    for(let i = 1; i < skill.length / 2; i++){\\n        currSkill = skill[i] + skill[len - i - 1];\\n        if(prev !== currSkill)\\n            return -1;\\n        totalChemistry += skill[i] * skill[len - i - 1];\\n        prev = currSkill;\\n    }\\n    return totalChemistry;\\n};\\n```\\n\\nFor example:\\nconsider sorted skill array: [1, 2, 3, 4, 5, 6]\\ni = 0, teams will be [1, 6], skill = 7, chemistry = 6\\ni = 1, teams will be [2, 5], skill = 7, chemistry = 10\\ni = 2, teams will be [3, 4], skill = 7, chemistry = 12\\nsince all the teams are processed, return sum of chemistry  = 28",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n// Sort the array to assign players to team such that one is a low skill player and another high skill player. This way we can try to divide teams so that all teams have equal skill rating\\n// store skill of prev team in a variable so that we can compare it to the skill of current team\\n// Return -1 if skill of prev and curr team is not equal\\n// if skills match, continue adding chemistry and return chemistry once all the teams are processed\\nvar dividePlayers = function(skill) {\\n    skill.sort((a, b) => a - b);\\n    const len = skill.length;\\n    let totalChemistry = 0;\\n    let prev = skill[0] + skill[len - 1];\\n    totalChemistry += skill[0]*skill[len - 1];\\n    let currSkill = prev;\\n    for(let i = 1; i < skill.length / 2; i++){\\n        currSkill = skill[i] + skill[len - i - 1];\\n        if(prev !== currSkill)\\n            return -1;\\n        totalChemistry += skill[i] * skill[len - i - 1];\\n        prev = currSkill;\\n    }\\n    return totalChemistry;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2877661,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long dividePlayers(vector<int>& skill) {\\n\\t\\t\\tif(skill.size()==2){return skill[0]*skill[1];}\\n\\t\\t\\tsort(skill.begin(), skill. end());\\n\\t\\t\\tlong long int pr=skill[0]+skill[skill.size()-1];\\n\\t\\t\\tlong long int ans=skill[0]*skill[skill.size()-1];\\n\\t\\t\\t//cout<<ans<<endl;\\n\\t\\t\\tfor(int i=1; i<(skill.size()/2); i++){\\n\\t\\t\\t\\t//cout<<skill[i]<<\" \"<<skill[skill.size()-1-i]<<\" \"<<skill[i]+skill[skill.size()-1-i]<<\" \"<<pr<<endl;\\n\\t\\t\\t\\tif(skill[i]+skill[skill.size()-1-i]!=pr){return -1;}\\n\\t\\t\\t\\tans+=skill[i]*skill[skill.size()-1-i];\\n\\t\\t\\t\\t//cout<<ans<<endl;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long dividePlayers(vector<int>& skill) {\\n\\t\\t\\tif(skill.size()==2){return skill[0]*skill[1];}",
                "codeTag": "Java"
            },
            {
                "id": 2877442,
                "title": "clean-c-8-line-code-using-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n=skill.size();\\n        if(n==2) return skill[0]*skill[n-1];\\n        \\n        sort(skill.begin(),skill.end());\\n        \\n        long long ans=0;\\n        for(int i=0;i<n/2;i++){\\n            if(skill[i]+skill[n-i-1] !=skill[0]+skill[n-1]){\\n                return -1;\\n            }\\n            ans+=skill[i]*skill[n-i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n=skill.size();\\n        if(n==2) return skill[0]*skill[n-1];\\n        \\n        sort(skill.begin(),skill.end());\\n        \\n        long long ans=0;\\n        for(int i=0;i<n/2;i++){\\n            if(skill[i]+skill[n-i-1] !=skill[0]+skill[n-1]){\\n                return -1;\\n            }\\n            ans+=skill[i]*skill[n-i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877063,
                "title": "c-short-and-easy-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int skill = nums[0] + nums[nums.size()-1];\\n        int i = 0 ;\\n        int j = nums.size()-1;\\n        long long ans=0;\\n        while(i<j){\\n            int sum = nums[i]+ nums[j];\\n            if(sum==skill){\\n                ans = ans + nums[i]*nums[j];\\n            }\\n            if(sum!=skill)return -1;\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int skill = nums[0] + nums[nums.size()-1];\\n        int i = 0 ;\\n        int j = nums.size()-1;\\n        long long ans=0;\\n        while(i<j){\\n            int sum = nums[i]+ nums[j];\\n            if(sum==skill){\\n                ans = ans + nums[i]*nums[j];\\n            }\\n            if(sum!=skill)return -1;\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876708,
                "title": "100-fast-solution-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int i = 0, j = skill.length-1;\\n        int sum1 = skill[i] + skill[j];\\n        long res = 0;\\n        while(i < j){\\n            if(sum1 != skill[i] + skill[j]) return -1;\\n            res += (long) skill[i] *skill[j];\\n            i++;\\n            j--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int i = 0, j = skill.length-1;\\n        int sum1 = skill[i] + skill[j];\\n        long res = 0;\\n        while(i < j){\\n            if(sum1 != skill[i] + skill[j]) return -1;\\n            res += (long) skill[i] *skill[j];\\n            i++;\\n            j--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876212,
                "title": "easy-and-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long dividePlayers(int[] arr) {\\n        Arrays.sort(arr);\\n  \\n        long require = arr[0]+arr[arr.length-1];\\n        long ans = arr[0]*arr[arr.length-1];\\n\\t\\tint i = 1;\\n        int j = arr.length-2;\\n        \\n        while(i<j && j>i){\\n            long sum = arr[i]+arr[j];\\n            if(sum == require){\\n                ans += arr[i]*arr[j];\\n            }else{\\n                return -1;\\n            }\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] arr) {\\n        Arrays.sort(arr);\\n  \\n        long require = arr[0]+arr[arr.length-1];\\n        long ans = arr[0]*arr[arr.length-1];\\n\\t\\tint i = 1;\\n        int j = arr.length-2;\\n        \\n        while(i<j && j>i){\\n            long sum = arr[i]+arr[j];\\n            if(sum == require){\\n                ans += arr[i]*arr[j];\\n            }else{\\n                return -1;\\n            }\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876162,
                "title": "c-easy-and-simple-o-nlogn-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointer approach\\n\\n> # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlog(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n     sort(skill.begin(),skill.end());\\n        if(skill.size()==2){\\n            return skill[0]*skill[1];\\n        }\\n        if(skill.size()==1)return skill[0];\\n        int val;\\n        int i=0;\\n        int l=skill.size()-1;\\n        val=skill[i]+skill[l];\\n        i++;\\n        l--;\\n        long long ans=0;\\n        ans+=skill[0]*skill[skill.size()-1];\\n        \\n        // cout<<i<<\" \"<<l;\\n        while(i<l){\\n            if(val!=skill[i]+skill[l])return -1;\\n            else\\n                ans+=(skill[i]*skill[l]);\\n            \\n            cout<<ans;\\n            i++;\\n            l--;\\n        }\\n        // cout<<ans;\\n        // ans+=skill[0]*skill[skill.size()-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n     sort(skill.begin(),skill.end());\\n        if(skill.size()==2){\\n            return skill[0]*skill[1];\\n        }\\n        if(skill.size()==1)return skill[0];\\n        int val;\\n        int i=0;\\n        int l=skill.size()-1;\\n        val=skill[i]+skill[l];\\n        i++;\\n        l--;\\n        long long ans=0;\\n        ans+=skill[0]*skill[skill.size()-1];\\n        \\n        // cout<<i<<\" \"<<l;\\n        while(i<l){\\n            if(val!=skill[i]+skill[l])return -1;\\n            else\\n                ans+=(skill[i]*skill[l]);\\n            \\n            cout<<ans;\\n            i++;\\n            l--;\\n        }\\n        // cout<<ans;\\n        // ans+=skill[0]*skill[skill.size()-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2876142,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill.sort()\\n        d=0\\n        chem=skill[0] + skill[-1]\\n        for i in range(len(skill)//2):\\n            if skill[i]+skill[-i-1]==chem:\\n                d+=skill[i]*skill[-i-1]\\n            else:\\n                return -1\\n        return d\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill.sort()\\n        d=0\\n        chem=skill[0] + skill[-1]\\n        for i in range(len(skill)//2):\\n            if skill[i]+skill[-i-1]==chem:\\n                d+=skill[i]*skill[-i-1]\\n            else:\\n                return -1\\n        return d\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876008,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n = skill.size();\\n        sort(skill.begin(),skill.end());\\n        int start=0,end=n-1;\\n        vector<long long> t;\\n        vector<pair<long long,long long>> p;\\n        while(start<=end){\\n            p.push_back({skill[start],skill[end]});\\n            t.push_back(skill[start]+skill[end]);\\n            start++;\\n            end--;\\n        }\\n        long long pro=0;\\n        unordered_map<long long,int> mp;\\n        for(int i=0;i<t.size();i++){\\n            mp[t[i]]++;\\n        }\\n        if(mp.size()>1){\\n            return -1;\\n        }\\n        else{\\n            for(int i=0;i<p.size();i++){\\n                pro+=(p[i].first*p[i].second);\\n            }\\n        }\\n        return pro;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n = skill.size();\\n        sort(skill.begin(),skill.end());\\n        int start=0,end=n-1;\\n        vector<long long> t;\\n        vector<pair<long long,long long>> p;\\n        while(start<=end){\\n            p.push_back({skill[start],skill[end]});\\n            t.push_back(skill[start]+skill[end]);\\n            start++;\\n            end--;\\n        }\\n        long long pro=0;\\n        unordered_map<long long,int> mp;\\n        for(int i=0;i<t.size();i++){\\n            mp[t[i]]++;\\n        }\\n        if(mp.size()>1){\\n            return -1;\\n        }\\n        else{\\n            for(int i=0;i<p.size();i++){\\n                pro+=(p[i].first*p[i].second);\\n            }\\n        }\\n        return pro;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875990,
                "title": "easy-c-solution-with-time-complexity",
                "content": "Here is my C++ Solution :-\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n= skill.size();\\n        long long prod=0; long long sum= skill[0]+skill[n-1];\\n        for (int i=0; i<n/2; i++){\\n            long long currsum= skill[i]+skill[n-i-1];\\n            if (currsum!=sum)return -1;\\n            prod+= (skill[i]*skill[n-i-1]);\\n        }\\n        return prod;\\n    }\\n};\\n```\\n\\n**Time complexity : O(NlogN)\\nSpace Complexity : O(1)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n= skill.size();\\n        long long prod=0; long long sum= skill[0]+skill[n-1];\\n        for (int i=0; i<n/2; i++){\\n            long long currsum= skill[i]+skill[n-i-1];\\n            if (currsum!=sum)return -1;\\n            prod+= (skill[i]*skill[n-i-1]);\\n        }\\n        return prod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875672,
                "title": "c-simple-solution-short-nd-easy-approach-sort",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n      sort(skill.begin(),skill.end());\\n\\t  \\n      int len = skill.size();      \\n      long long int result=0;\\n      long int sum = (skill[0] + skill[len-1]);\\n\\t  \\n      for(int i=0; i<len/2; i++)\\n      {\\n         if(sum == (skill[i] + skill[len-1-i]) )\\n         {\\n            result +=(skill[i] * skill[len-1-i]);\\n         }\\n        else\\n          return -1;  \\n      }\\n      return result ;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n      sort(skill.begin(),skill.end());\\n\\t  \\n      int len = skill.size();      \\n      long long int result=0;\\n      long int sum = (skill[0] + skill[len-1]);\\n\\t  \\n      for(int i=0; i<len/2; i++)\\n      {\\n         if(sum == (skill[i] + skill[len-1-i]) )\\n         {\\n            result +=(skill[i] * skill[len-1-i]);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2875634,
                "title": "java-o-n-time-without-sorting-counting-sort",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        \\n        int [] freq = new int[1001];\\n        \\n        for(int s : skill){\\n            freq[s]++;\\n        }\\n        \\n        int index = 0;\\n        \\n        for(int count = 1; count <= 1000; count++){\\n            \\n            while(freq[count] != 0){\\n                skill[index] = count;\\n                index++;\\n                freq[count]--;\\n            }\\n        }\\n        \\n        long product = 0;\\n        \\n        int chemistry = skill[0] + skill[skill.length - 1];\\n        \\n        int start = 0;\\n        int end = skill.length - 1;\\n        \\n        while(start < end){\\n            \\n            if(skill[start] + skill[end] != chemistry){\\n                return -1;\\n            }\\n            \\n            product = product + (skill[start] * skill[end]);\\n            \\n            start++;\\n            end--;\\n        }\\n        \\n        return product;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        \\n        int [] freq = new int[1001];\\n        \\n        for(int s : skill){\\n            freq[s]++;\\n        }\\n        \\n        int index = 0;\\n        \\n        for(int count = 1; count <= 1000; count++){\\n            \\n            while(freq[count] != 0){\\n                skill[index] = count;\\n                index++;\\n                freq[count]--;\\n            }\\n        }\\n        \\n        long product = 0;\\n        \\n        int chemistry = skill[0] + skill[skill.length - 1];\\n        \\n        int start = 0;\\n        int end = skill.length - 1;\\n        \\n        while(start < end){\\n            \\n            if(skill[start] + skill[end] != chemistry){\\n                return -1;\\n            }\\n            \\n            product = product + (skill[start] * skill[end]);\\n            \\n            start++;\\n            end--;\\n        }\\n        \\n        return product;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875582,
                "title": "c-sorting-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n=skill.size();\\n        int i=0;\\n        int j=n-1;\\n        long long sum=0;\\n        sort(skill.begin(),skill.end());\\n        while(i<j){\\n             if((skill[i] + skill[j])!= (skill[i+1]+skill[j-1])){\\n                 return -1;\\n             }\\n            sum+=skill[i]*skill[j];\\n            i++;\\n            j--;\\n        }\\n        return sum;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n=skill.size();\\n        int i=0;\\n        int j=n-1;\\n        long long sum=0;\\n        sort(skill.begin(),skill.end());\\n        while(i<j){\\n             if((skill[i] + skill[j])!= (skill[i+1]+skill[j-1])){\\n                 return -1;\\n             }\\n            sum+=skill[i]*skill[j];\\n            i++;\\n            j--;\\n        }\\n        return sum;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875552,
                "title": "easy-to-understand-simple-c-cpp",
                "content": "if you understand plz upvote\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        long long sumof=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=n-1;\\n        int sum=0;\\n        int c;\\n        sum+=nums[i]+nums[j];\\n        ans.push_back(nums[i]*nums[j]);\\n        i++;\\n        j--;\\n        c=sum;\\n      // cout<<sum;\\n       // cout<<i<<j;\\n       while(i<=j)\\n       {\\n           sum=0;\\n           sum+=nums[i]+nums[j];\\n          \\n           \\n          \\n           if(sum!=c)\\n               return -1;\\n           //cout<<nums[i]<<\" \"<<nums[j];\\n           ans.push_back(nums[i]*nums[j]);\\n            i++;\\n           j--;\\n       }\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            sumof+=ans[i];\\n        }\\n            // cout<<ans[i];\\n        \\n        return  sumof;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        long long sumof=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=n-1;\\n        int sum=0;\\n        int c;\\n        sum+=nums[i]+nums[j];\\n        ans.push_back(nums[i]*nums[j]);\\n        i++;\\n        j--;\\n        c=sum;\\n      // cout<<sum;\\n       // cout<<i<<j;\\n       while(i<=j)\\n       {\\n           sum=0;\\n           sum+=nums[i]+nums[j];\\n          \\n           \\n          \\n           if(sum!=c)\\n               return -1;\\n           //cout<<nums[i]<<\" \"<<nums[j];\\n           ans.push_back(nums[i]*nums[j]);\\n            i++;\\n           j--;\\n       }\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            sumof+=ans[i];\\n        }\\n            // cout<<ans[i];\\n        \\n        return  sumof;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2875459,
                "title": "two-pointers-c",
                "content": "~~~\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long ans=0;\\n        int sum=0;\\n        int n=skill.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=skill[i];\\n        }\\n        int k=sum*2/n;\\n        sort(skill.begin(),skill.end());\\n          int i=0,j=skill.size()-1;\\n        while(i<j)\\n       {\\n            int a=skill[i];\\n            int b=skill[j];\\n         if(a+b==k)\\n         {\\n            ans+=a*b;\\n             i++;\\n             j--;\\n         }\\n         else\\n         {\\n             return -1;\\n         }\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long ans=0;\\n        int sum=0;\\n        int n=skill.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=skill[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2875434,
                "title": "python-sorting-space-used-o-1-time-complexity-o-n-long",
                "content": "Here we sort the array and initially compute the value of sum (which is sum of first and last elemet in the sorted array).\\nIt is sure that the sum of largest and smallest element will make distribution equal. So we take it initially in a variable.\\nAnd using two pointer approach we check for equality to all the remaining element if any of that is not equal than it is sure that we can not make it equal after adding any other element.\\nLet\\'s suppose we take a other number and make it value equal to s but after that we have to pick smaller one and in the remaing array there will be no number present that make the smallest remaining equal to our build target(i.e. s).\\nSo we simply check the it using two pointer approach and if they are not equal we return -1.\\nelse at the end we return ans (as answer).\\nand the in process we calculate our answer as well.\\n\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill.sort()\\n        s = skill[0]+skill[-1]\\n        ans = 0\\n        n=len(skill)\\n        for i in range(int(len(skill)/2)):\\n            ans += skill[i]*skill[n-i-1]\\n            if(skill[i]+skill[n-i-1]!=s):\\n                return -1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill.sort()\\n        s = skill[0]+skill[-1]\\n        ans = 0\\n        n=len(skill)\\n        for i in range(int(len(skill)/2)):\\n            ans += skill[i]*skill[n-i-1]\\n            if(skill[i]+skill[n-i-1]!=s):\\n                return -1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875411,
                "title": "java-sorting-with-and-without-two-pointers-short-and-simple",
                "content": "### **Please Upvote** :D\\n##### 1. With two-pointers:\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n\\n        int n = skill.length;\\n        long ans = 0;\\n        int i = 0, j = n - 1, sum = skill[i] + skill[j];\\n        \\n        while (i <= j) {\\n            if (skill[i] + skill[j] != sum) {\\n                return -1;\\n            }\\n            \\n            ans += (skill[i++] * skill[j--]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n##### 2. Without two-pointers:\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        \\n        int n = skill.length;\\n        long ans = 0;\\n        int sum = skill[0] + skill[n - 1];\\n        \\n        for (int i = 0; i < n / 2; i++) {\\n            if (skill[i] + skill[n - i - 1] != sum) {\\n                return -1;\\n            }\\n            \\n            ans += (skill[i] * skill[n - i - 1]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n**Time complexity: `O(n * logn)`\\nSpace Complexity: `O(1)`**",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n\\n        int n = skill.length;\\n        long ans = 0;\\n        int i = 0, j = n - 1, sum = skill[i] + skill[j];\\n        \\n        while (i <= j) {\\n            if (skill[i] + skill[j] != sum) {\\n                return -1;\\n            }\\n            \\n            ans += (skill[i++] * skill[j--]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        \\n        int n = skill.length;\\n        long ans = 0;\\n        int sum = skill[0] + skill[n - 1];\\n        \\n        for (int i = 0; i < n / 2; i++) {\\n            if (skill[i] + skill[n - i - 1] != sum) {\\n                return -1;\\n            }\\n            \\n            ans += (skill[i] * skill[n - i - 1]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875337,
                "title": "python-o-n-and-o-nlogn",
                "content": "# Approach\\n- We can make frequency dictionary and then iterate through it while checking for every valid pair and update the ans.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution: #using dictionary | O(n) time\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        sum_ = sum(skill)\\n        team = len(skill)//2\\n        \\n        if sum_%team != 0:\\n            return -1\\n        \\n        d = {}\\n        skill_val = sum_//team\\n        ans = 0\\n        \\n        for i in skill:\\n            d[i] = d.get(i, 0)+1\\n                \\n        for i in range(len(skill)):\\n            if skill[i] in d:\\n                if skill_val-skill[i] in d:\\n                    ans += skill[i]*(skill_val-skill[i])\\n\\n                    if d[skill[i]] == 1:\\n                        del d[skill[i]]\\n                    else:\\n                        d[skill[i]] -= 1\\n                    if d[skill_val-skill[i]] == 1:\\n                        del d[skill_val-skill[i]]\\n                    else:\\n                        d[skill_val-skill[i]] -= 1\\n                else:\\n                    return -1 \\n\\n        return ans\\n\\n\\n```\\n-----------------------------\\n\\n# Approach\\n- Sort the array, now if team formation is possible then there would be pair of integers having equal sum at indices (0, n-1), (1, n-2)....(n/2, n/2-1).\\n- wherever the condition gets false that means team formation isn\\'t possible. \\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(1)\\n\\n\\n```\\nclass Solution: #using sorting and iteration in half list | O(nlogn) time\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill.sort()\\n        n = len(skill)\\n        s = skill[0] + skill[-1]\\n        ans = 0\\n        for i in range(n // 2):\\n            if s != skill[i] + skill[n-i-1]:\\n                return -1\\n            ans += (skill[i]*skill[n-i-1])\\n            \\n        return ans\\n```\\n------------------------\\n\\n**Upvote the post if you find it helpful.\\nHappy coding.**\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: #using dictionary | O(n) time\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        sum_ = sum(skill)\\n        team = len(skill)//2\\n        \\n        if sum_%team != 0:\\n            return -1\\n        \\n        d = {}\\n        skill_val = sum_//team\\n        ans = 0\\n        \\n        for i in skill:\\n            d[i] = d.get(i, 0)+1\\n                \\n        for i in range(len(skill)):\\n            if skill[i] in d:\\n                if skill_val-skill[i] in d:\\n                    ans += skill[i]*(skill_val-skill[i])\\n\\n                    if d[skill[i]] == 1:\\n                        del d[skill[i]]\\n                    else:\\n                        d[skill[i]] -= 1\\n                    if d[skill_val-skill[i]] == 1:\\n                        del d[skill_val-skill[i]]\\n                    else:\\n                        d[skill_val-skill[i]] -= 1\\n                else:\\n                    return -1 \\n\\n        return ans\\n\\n\\n```\n```\\nclass Solution: #using sorting and iteration in half list | O(nlogn) time\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill.sort()\\n        n = len(skill)\\n        s = skill[0] + skill[-1]\\n        ans = 0\\n        for i in range(n // 2):\\n            if s != skill[i] + skill[n-i-1]:\\n                return -1\\n            ans += (skill[i]*skill[n-i-1])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875297,
                "title": "c-easy-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        \\n        sort(skill.begin(), skill.end());\\n        \\n        long long sum = skill[0]+skill[skill.size()-1];\\n        long long result = skill[0]*skill[skill.size()-1];\\n        long long left = 1, right = skill.size()-2;\\n        while(left < right) {\\n            if(sum != skill[left]+skill[right]) {\\n                return -1;\\n            }\\n            result += skill[left]*skill[right];\\n            left++;\\n            right--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        \\n        sort(skill.begin(), skill.end());\\n        \\n        long long sum = skill[0]+skill[skill.size()-1];\\n        long long result = skill[0]*skill[skill.size()-1];\\n        long long left = 1, right = skill.size()-2;\\n        while(left < right) {\\n            if(sum != skill[left]+skill[right]) {\\n                return -1;\\n            }\\n            result += skill[left]*skill[right];\\n            left++;\\n            right--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875289,
                "title": "quick-c-sorting-and-single-pointer",
                "content": "First sort the skills with Olog(N). Then, run the loop till size/2. Keep moving from start and end each time.\\n\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        \\n        sort(skill.begin(), skill.end());\\n        \\n        long long size = skill.size();\\n        long long teamSkill = skill[0] + skill[size-1];\\n        \\n        long long teamChem=0;\\n        \\n        for(int i=0; i<skill.size()/2; i++)  {\\n            \\n            if( teamSkill != (skill[i] + skill[size-1-i]) ){\\n                return -1;\\n            } \\n            else {\\n                \\n                teamChem += (skill[i] * skill[size-1-i]);\\n            } \\n        }\\n        \\n        return teamChem;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        \\n        sort(skill.begin(), skill.end());\\n        \\n        long long size = skill.size();\\n        long long teamSkill = skill[0] + skill[size-1];\\n        \\n        long long teamChem=0;\\n        \\n        for(int i=0; i<skill.size()/2; i++)  {\\n            \\n            if( teamSkill != (skill[i] + skill[size-1-i]) ){\\n                return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2875276,
                "title": "c-solution-with-easy-explanation",
                "content": "By using sorting \\n\\n* Sort the skills array in accending order\\n* take 2 pointer  `L` and `R` at the start and the end of the array.\\n* check whether the sum is equal to  s[L] + s[R] or not\\n* and also calculate  s[L] * s[R] and add it to ans\\n* if not return -1;\\n* else increment `L` and `R`\\n* return ans\\n\\n```\\n\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& s) {\\n        sort(s.begin(), s.end());\\n        int n = s.size();\\n        int L = 0;\\n        int R = n - 1;\\n        long long sum = 0, ans = 0;\\n        \\n        sum = s[0] + s[n-1];\\n        \\n        while(L <= R){\\n            if(sum != (s[L] + s[R]))\\n                return -1;\\n            \\n            ans += (s[L] * s[R]);\\n            L++;\\n            R--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& s) {\\n        sort(s.begin(), s.end());\\n        int n = s.size();\\n        int L = 0;\\n        int R = n - 1;\\n        long long sum = 0, ans = 0;\\n        \\n        sum = s[0] + s[n-1];\\n        \\n        while(L <= R){\\n            if(sum != (s[L] + s[R]))\\n                return -1;\\n            \\n            ans += (s[L] * s[R]);\\n            L++;\\n            R--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875206,
                "title": "python-easy-logic-sort-2-pointers",
                "content": "**Upvote if it helped :)**\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        n = len(skill) \\n        if n == 2: return skill[0] * skill[1]\\n        skill.sort()\\n        prev = None\\n        res = 0\\n        \\n        for i in range(n//2):\\n            j = n - i - 1\\n            \\n            if prev is None:\\n                prev = skill[i] + skill[j]\\n                res = skill[i] * skill[j]\\n            elif prev == skill[i] + skill[j]:\\n                res += skill[i] * skill[j]\\n            else: return -1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        n = len(skill) \\n        if n == 2: return skill[0] * skill[1]\\n        skill.sort()\\n        prev = None\\n        res = 0\\n        \\n        for i in range(n//2):\\n            j = n - i - 1\\n            \\n            if prev is None:\\n                prev = skill[i] + skill[j]\\n                res = skill[i] * skill[j]\\n            elif prev == skill[i] + skill[j]:\\n                res += skill[i] * skill[j]\\n            else: return -1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875205,
                "title": "best-approach-with-explanation-java-solution",
                "content": "**Just believe in yourself one day you will become the best coder.. All the Best\\uD83D\\uDC4D**\\n```\\nclass Solution {\\n  //int mod = 1000000007;\\n  public  long isPossible(int N, int A[])\\n  {\\n   \\n    //sort the array\\n    Arrays.sort(A);\\n \\n    int target = A[0] + A[N - 1];\\n    //take the sum of smallest and largest num\\n    \\n    int i = 0, j = N - 1;\\n    long chemistry=0;\\n    while (i < j) {\\n \\n      //keep on checking the sum from start and last is equal to target or not\\n      if (A[i] + A[j] == target) {\\n        chemistry=(chemistry+((A[i]*A[j])));\\n        i++;\\n        j--;\\n      }\\n \\n      //if no pair is found return -1\\n      else {\\n        return -1;\\n      }\\n    }\\n \\n   // return sum\\n    return chemistry;\\n  }\\n    public long dividePlayers(int[] skill) {\\n        long res = isPossible(skill.length,skill);\\n        if(res==-1){\\n            return -1;\\n        }\\n        return res;\\n    }\\n}\\n```\\n**Please Upvote if you find it helpful..**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n  //int mod = 1000000007;\\n  public  long isPossible(int N, int A[])\\n  {\\n   \\n    //sort the array\\n    Arrays.sort(A);\\n \\n    int target = A[0] + A[N - 1];\\n    //take the sum of smallest and largest num\\n    \\n    int i = 0, j = N - 1;\\n    long chemistry=0;\\n    while (i < j) {\\n \\n      //keep on checking the sum from start and last is equal to target or not\\n      if (A[i] + A[j] == target) {\\n        chemistry=(chemistry+((A[i]*A[j])));\\n        i++;\\n        j--;\\n      }\\n \\n      //if no pair is found return -1\\n      else {\\n        return -1;\\n      }\\n    }\\n \\n   // return sum\\n    return chemistry;\\n  }\\n    public long dividePlayers(int[] skill) {\\n        long res = isPossible(skill.length,skill);\\n        if(res==-1){\\n            return -1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875193,
                "title": "simple-python-solution-brute-force-method",
                "content": "**upvote if u like the solution**\\n```\\n        dum=0\\n        k=sum(skill)\\n        if len(skill)==2:\\n            return skill[0]*skill[1]\\n        elif len(skill)%2==0 and  sum(skill)%(len(skill)/2)==0:\\n            ratio=k/(len(skill)/2)\\n        else:\\n            return -1\\n        skill.sort()\\n        for i in range(len(skill)//2):\\n            if skill[i]+skill[len(skill)-(i+1)]!=ratio:\\n                return -1\\n            dum+=skill[i]*skill[len(skill)-(i+1)]\\n        return dum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        dum=0\\n        k=sum(skill)\\n        if len(skill)==2:\\n            return skill[0]*skill[1]\\n        elif len(skill)%2==0 and  sum(skill)%(len(skill)/2)==0:\\n            ratio=k/(len(skill)/2)\\n        else:\\n            return -1\\n        skill.sort()\\n        for i in range(len(skill)//2):\\n            if skill[i]+skill[len(skill)-(i+1)]!=ratio:\\n                return -1\\n            dum+=skill[i]*skill[len(skill)-(i+1)]\\n        return dum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2875173,
                "title": "c-java-python3-freq-table",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int val = 2*accumulate(skill.begin(), skill.end(), 0) / skill.size(); \\n        long long ans = 0; \\n        unordered_map<int, int> freq; \\n        for (auto& x : skill) ++freq[x]; \\n        for (auto& [k, v] : freq) {\\n            if (v != freq[val-k]) return -1; \\n            ans += (long long) k * (val - k) * v; \\n        }\\n        return ans/2; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int val = 2*Arrays.stream(skill).sum() / skill.length; \\n        long ans = 0; \\n        HashMap<Integer, Integer> freq = new HashMap<>(); \\n        for (int x : skill) freq.merge(x, 1, Integer::sum); \\n        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\\n            int k = entry.getKey(), v = entry.getValue(); \\n            if (v != freq.getOrDefault(val-k, 0)) return -1; \\n            ans += (long) k*(val-k)*v; \\n        }\\n        return ans/2;\\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        ans = 0 \\n        val = 2*sum(skill) // len(skill)\\n        freq = Counter(skill)\\n        for i, (k, v) in enumerate(freq.items()):\\n            if v != freq[val - k]: return -1 \\n            ans += k*(val-k)*v\\n        return ans // 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int val = 2*accumulate(skill.begin(), skill.end(), 0) / skill.size(); \\n        long long ans = 0; \\n        unordered_map<int, int> freq; \\n        for (auto& x : skill) ++freq[x]; \\n        for (auto& [k, v] : freq) {\\n            if (v != freq[val-k]) return -1; \\n            ans += (long long) k * (val - k) * v; \\n        }\\n        return ans/2; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int val = 2*Arrays.stream(skill).sum() / skill.length; \\n        long ans = 0; \\n        HashMap<Integer, Integer> freq = new HashMap<>(); \\n        for (int x : skill) freq.merge(x, 1, Integer::sum); \\n        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\\n            int k = entry.getKey(), v = entry.getValue(); \\n            if (v != freq.getOrDefault(val-k, 0)) return -1; \\n            ans += (long) k*(val-k)*v; \\n        }\\n        return ans/2;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        ans = 0 \\n        val = 2*sum(skill) // len(skill)\\n        freq = Counter(skill)\\n        for i, (k, v) in enumerate(freq.items()):\\n            if v != freq[val - k]: return -1 \\n            ans += k*(val-k)*v\\n        return ans // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875106,
                "title": "simple-o-n-solution-no-sorting-two-sum-technique",
                "content": "## Time Complexity = O(N)\\n## Space Complexity = O(N)\\n\\n```python\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        \\n        n = len(skill)\\n        t = n//2    # how many pairs will be created\\n        s = sum(skill) // t  # what will be sum of each pair\\n        \\n        c = Counter(skill)  # keep track of how many numbers we have\\n        lookup =Counter() # keep track of how many pairs generated\\n        \\n        for num in skill:\\n            # If we have number and equal can be generated from that number the make a pair\\n            if c[num] and s- num in c and c[s-num]>0:\\n                c[s-num]-=1\\n                c[num]-=1\\n                lookup[(s-num, num)]+=1\\n        \\n        # If some number is unused then return -1\\n        for k, v in c.items():\\n            if v!= 0:\\n                return -1\\n\\n        # Calculate result as told\\n        result = 0\\n        for k,v in lookup.items():\\n            a, b = k\\n            # multiplying by v because that\\'s number of pairs\\n            result += a*b*v\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        \\n        n = len(skill)\\n        t = n//2    # how many pairs will be created\\n        s = sum(skill) // t  # what will be sum of each pair\\n        \\n        c = Counter(skill)  # keep track of how many numbers we have\\n        lookup =Counter() # keep track of how many pairs generated\\n        \\n        for num in skill:\\n            # If we have number and equal can be generated from that number the make a pair\\n            if c[num] and s- num in c and c[s-num]>0:\\n                c[s-num]-=1\\n                c[num]-=1\\n                lookup[(s-num, num)]+=1\\n        \\n        # If some number is unused then return -1\\n        for k, v in c.items():\\n            if v!= 0:\\n                return -1\\n\\n        # Calculate result as told\\n        result = 0\\n        for k,v in lookup.items():\\n            a, b = k\\n            # multiplying by v because that\\'s number of pairs\\n            result += a*b*v\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875103,
                "title": "c-solution-using-single-vector",
                "content": "class Solution {\\npublic:\\n    long long dividePlayers(vector<int>& s) {\\n\\t\\n        long long n = s.size();\\n        vector<long long> ans;\\n        if(n == 2){\\n            return s[0] * s[1];\\n        }\\n        \\n        sort(s.begin(),s.end());\\n        long long sum = s[0] + s[n-1];\\n        int start = 0,end = n-1;\\n        while(start <= end){\\n            if(sum != s[start] + s[end]){\\n                return -1;\\n            }else{\\n                ans.push_back(s[start] * s[end]);\\n            }\\n            start++;\\n            end--;\\n        }\\n        \\n        long long p = 0;\\n        for(auto i:ans){\\n            p += i;\\n        }\\n        \\n        return p;\\n\\t\\t\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long dividePlayers(vector<int>& s) {\\n\\t\\n        long long n = s.size();\\n        vector<long long> ans;\\n        if(n == 2){\\n            return s[0] * s[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2875092,
                "title": "c-sort",
                "content": "```\\n    public long DividePlayers(int[] skill) \\n    {\\n        long result = 0;\\n        Array.Sort(skill);\\n        int n = skill.Length;\\n        int twoSum = skill[0] + skill[n - 1];\\n\\n        for (int i = 0; i < n/2; i++)\\n        {\\n            if (skill[i] + skill[n - 1 - i] != twoSum)\\n                return -1;\\n            result += skill[i] * skill[n - 1 - i];\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n    public long DividePlayers(int[] skill) \\n    {\\n        long result = 0;\\n        Array.Sort(skill);\\n        int n = skill.Length;\\n        int twoSum = skill[0] + skill[n - 1];\\n\\n        for (int i = 0; i < n/2; i++)\\n        {\\n            if (skill[i] + skill[n - 1 - i] != twoSum)\\n                return -1;\\n            result += skill[i] * skill[n - 1 - i];\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2875088,
                "title": "java-easiest-solution-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] arr) {\\n       Arrays.sort(arr);\\n        long ans = 0;\\n        int n = arr.length;\\n        for(int i = 0; i< n/2; i++){\\n            if(arr[i] + arr[n-i-1] != arr[0] + arr[n-1]){\\n                return -1;\\n            }\\n            ans += arr[i] * arr[n-i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] arr) {\\n       Arrays.sort(arr);\\n        long ans = 0;\\n        int n = arr.length;\\n        for(int i = 0; i< n/2; i++){\\n            if(arr[i] + arr[n-i-1] != arr[0] + arr[n-1]){\\n                return -1;\\n            }\\n            ans += arr[i] * arr[n-i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875053,
                "title": "two-pointer",
                "content": "```\\npublic long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        long ans = 0;\\n        int i = 0,j = skill.length-1;\\n        int k = skill[i] + skill[j];\\n        while(i < j){\\n            if(skill[i] + skill[j] != k) return -1;\\n            ans += 1L * skill[i] * skill[j];\\n            i++; j--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        long ans = 0;\\n        int i = 0,j = skill.length-1;\\n        int k = skill[i] + skill[j];\\n        while(i < j){\\n            if(skill[i] + skill[j] != k) return -1;\\n            ans += 1L * skill[i] * skill[j];\\n            i++; j--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2875041,
                "title": "python3-o-nlogn-sorting-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        n = len(skill)\\n        skill.sort()\\n        res = 0\\n        for i in range(0, n//2):\\n            if skill[i] + skill[n-i-1] != skill[0] + skill[-1]:\\n                return -1\\n            res += (skill[i] * skill[n-i-1])\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        n = len(skill)\\n        skill.sort()\\n        res = 0\\n        for i in range(0, n//2):\\n            if skill[i] + skill[n-i-1] != skill[0] + skill[-1]:\\n                return -1\\n            res += (skill[i] * skill[n-i-1])\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875040,
                "title": "using-two-pointer-map",
                "content": "\\n\\n# Code : Two pointer\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int i = 0,j = skill.size() -1;\\n        long long req = skill[0] + skill.back();\\n        long long ans = 0;\\n        while(i<=j){\\n            if(req == skill[i + 1]+skill[j-1]) ans += (skill[i++]*skill[j--]);\\n            else return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code : Map\\n\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n         if(skill.size() == 2)return skill[0]* skill[1] * 1LL;\\n        \\n         long long sum = accumulate(skill.begin(),skill.end(),0);\\n         long long len = skill.size() / 2;\\n         long long req = sum / len;\\n        \\n         unordered_map<long long,long long> mp;\\n         for(auto ele:skill)mp[ele]++;\\n        \\n         long long ans = 0;\\n         for(int i = 0;i<skill.size();i++){\\n             if(!mp.count(skill[i]))continue;\\n             if(!mp.count(abs(req-skill[i])))return -1;\\n             \\n            ans+=(skill[i] * abs(req-skill[i]));\\n            if(--mp[skill[i]] == 0){\\n                mp.erase(skill[i]);\\n            };\\n             if(--mp[abs(req-skill[i])] == 0){\\n                 mp.erase(abs(req-skill[i]));\\n             }\\n         } \\n         return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int i = 0,j = skill.size() -1;\\n        long long req = skill[0] + skill.back();\\n        long long ans = 0;\\n        while(i<=j){\\n            if(req == skill[i + 1]+skill[j-1]) ans += (skill[i++]*skill[j--]);\\n            else return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n         if(skill.size() == 2)return skill[0]* skill[1] * 1LL;\\n        \\n         long long sum = accumulate(skill.begin(),skill.end(),0);\\n         long long len = skill.size() / 2;\\n         long long req = sum / len;\\n        \\n         unordered_map<long long,long long> mp;\\n         for(auto ele:skill)mp[ele]++;\\n        \\n         long long ans = 0;\\n         for(int i = 0;i<skill.size();i++){\\n             if(!mp.count(skill[i]))continue;\\n             if(!mp.count(abs(req-skill[i])))return -1;\\n             \\n            ans+=(skill[i] * abs(req-skill[i]));\\n            if(--mp[skill[i]] == 0){\\n                mp.erase(skill[i]);\\n            };\\n             if(--mp[abs(req-skill[i])] == 0){\\n                 mp.erase(abs(req-skill[i]));\\n             }\\n         } \\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875020,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n\\n        int[][] t=new int[skill.length/2][2];\\n        long ans=0;\\n        Arrays.sort(skill);\\n        for(int i=0;i<skill.length/2;i++)\\n            t[i][0]=skill[i];\\n        int j=0;\\n        for(int i=skill.length-1;i>=skill.length/2;i--){\\n            t[j][1]=skill[i];\\n            j++;\\n        }\\n        int sum=0;\\n        if(t.length>0){\\n         sum=t[0][0]+t[0][1];\\n        }\\n        //System.out.print(sum);\\n        for(int i=0;i<t.length;i++){\\n            int temp=0;\\n            for(int k=0;k<2;k++){\\n                temp+=t[i][k];\\n            }\\n            if(temp!=sum)\\n                return -1;\\n        }\\n        \\n        \\n        for(int i=0;i<t.length;i++){\\n            long q=1;\\n            for(int k=0;k<2;k++){\\n                q*=t[i][k];\\n            }\\n            ans+=q;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n\\n        int[][] t=new int[skill.length/2][2];\\n        long ans=0;\\n        Arrays.sort(skill);\\n        for(int i=0;i<skill.length/2;i++)\\n            t[i][0]=skill[i];\\n        int j=0;\\n        for(int i=skill.length-1;i>=skill.length/2;i--){\\n            t[j][1]=skill[i];\\n            j++;\\n        }\\n        int sum=0;\\n        if(t.length>0){\\n         sum=t[0][0]+t[0][1];\\n        }\\n        //System.out.print(sum);\\n        for(int i=0;i<t.length;i++){\\n            int temp=0;\\n            for(int k=0;k<2;k++){\\n                temp+=t[i][k];\\n            }\\n            if(temp!=sum)\\n                return -1;\\n        }\\n        \\n        \\n        for(int i=0;i<t.length;i++){\\n            long q=1;\\n            for(int k=0;k<2;k++){\\n                q*=t[i][k];\\n            }\\n            ans+=q;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875009,
                "title": "c-sum-2-and-map-use",
                "content": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long sum=0;\\n        for(auto it : skill) sum += it;\\n        sum*=2;\\n        if(sum%skill.size()==0) sum/=skill.size();\\n        else return -1;\\n        map<long long,long long> mp;\\n        for(auto it : skill) mp[it]++;\\n        long long ans=0;\\n        for(auto it : skill){\\n            if((sum-it)==it && mp[it]%2==0){\\n                ans += (mp[it]/2)*(it*it);\\n                mp[it] = 0;\\n            }\\n            else if(mp.find(sum-it)!=mp.end() && mp[it]==mp[sum-it]){\\n                ans += (mp[it])*(it*(sum-it));\\n                mp[it] = 0;\\n                mp[sum-it] = 0;    \\n            }\\n        }\\n        for(auto it : mp){\\n            if(it.second >0) return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long sum=0;\\n        for(auto it : skill) sum += it;\\n        sum*=2;\\n        if(sum%skill.size()==0) sum/=skill.size();\\n        else return -1;\\n        map<long long,long long> mp;\\n        for(auto it : skill) mp[it]++;\\n        long long ans=0;\\n        for(auto it : skill){\\n            if((sum-it)==it && mp[it]%2==0){\\n                ans += (mp[it]/2)*(it*it);\\n                mp[it] = 0;\\n            }\\n            else if(mp.find(sum-it)!=mp.end() && mp[it]==mp[sum-it]){\\n                ans += (mp[it])*(it*(sum-it));\\n                mp[it] = 0;\\n                mp[sum-it] = 0;    \\n            }\\n        }\\n        for(auto it : mp){\\n            if(it.second >0) return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2874994,
                "title": "java-one-of-the-easiest-solution-with-explanation-sorting",
                "content": "```\\npublic static long dividePlayers(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int it : nums) sum+=it;\\n        int teamSize = n/2;\\n        if(sum % teamSize !=0) return -1;\\n        int pairSize = sum/teamSize;\\n        long ans = 0;\\n        int left = 0;\\n        int right = n-1;\\n        while(left < right){\\n            if(nums[left]+nums[right] != pairSize) return -1;\\n            long temp = (long) nums[left] * nums[right];\\n            ans += temp;\\n            left++;\\n            right--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic static long dividePlayers(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int it : nums) sum+=it;\\n        int teamSize = n/2;\\n        if(sum % teamSize !=0) return -1;\\n        int pairSize = sum/teamSize;\\n        long ans = 0;\\n        int left = 0;\\n        int right = n-1;\\n        while(left < right){\\n            if(nums[left]+nums[right] != pairSize) return -1;\\n            long temp = (long) nums[left] * nums[right];\\n            ans += temp;\\n            left++;\\n            right--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2874977,
                "title": "simple-c-trivial",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& s) {\\n        sort(s.begin(), s.end());\\n        \\n        long long int sum = -1, pro = 0;\\n        \\n        for(int i=0, j=s.size()-1; i<j; i++, j--){\\n            long long int temp = s[i] + s[j];\\n            \\n            if(sum == -1) sum = temp;\\n            else {\\n                if(sum != temp) return -1;\\n            }\\n            \\n            pro += (s[i] * s[j]);\\n        }\\n        \\n        return pro;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& s) {\\n        sort(s.begin(), s.end());\\n        \\n        long long int sum = -1, pro = 0;\\n        \\n        for(int i=0, j=s.size()-1; i<j; i++, j--){\\n            long long int temp = s[i] + s[j];\\n            \\n            if(sum == -1) sum = temp;\\n            else {\\n                if(sum != temp) return -1;\\n            }\\n            \\n            pro += (s[i] * s[j]);\\n        }\\n        \\n        return pro;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874960,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int startIndex = 0;\\n        int endIndex = skill.length - 1;\\n        List<List<Integer>> pairs = new ArrayList<>();\\n        while (startIndex < endIndex) {\\n            int value1 = skill[startIndex];\\n            int value2 = skill[endIndex];\\n            startIndex++;\\n            endIndex--;\\n            List<Integer> pair = new ArrayList<>();\\n            pair.add(value1);\\n            pair.add(value2);\\n            pairs.add(pair);\\n        }\\n        int total = pairs.get(0).get(0) + pairs.get(0).get(1);\\n        long result = 0;\\n        for (int i = 0; i < pairs.size(); i++) {\\n            List<Integer> pair = pairs.get(i);\\n            int value1 = pair.get(0);\\n            int value2 = pair.get(1);\\n            if (value1 + value2 != total) {\\n                return -1;\\n            }   \\n            result = result + value1 * value2;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int startIndex = 0;\\n        int endIndex = skill.length - 1;\\n        List<List<Integer>> pairs = new ArrayList<>();\\n        while (startIndex < endIndex) {\\n            int value1 = skill[startIndex];\\n            int value2 = skill[endIndex];\\n            startIndex++;\\n            endIndex--;\\n            List<Integer> pair = new ArrayList<>();\\n            pair.add(value1);\\n            pair.add(value2);\\n            pairs.add(pair);\\n        }\\n        int total = pairs.get(0).get(0) + pairs.get(0).get(1);\\n        long result = 0;\\n        for (int i = 0; i < pairs.size(); i++) {\\n            List<Integer> pair = pairs.get(i);\\n            int value1 = pair.get(0);\\n            int value2 = pair.get(1);\\n            if (value1 + value2 != total) {\\n                return -1;\\n            }   \\n            result = result + value1 * value2;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096532,
                "title": "intuitive-2-pointer-approach-c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& nums) {\\n        long long i=0,j=nums.size()-1,sum = accumulate(nums.begin(),nums.end(),0),s = nums.size()/2,ans = 0;\\n        sort(nums.begin(),nums.end());\\n        while(i<j){\\n            if(nums[i]+nums[j] == sum/s){\\n                ans+=(nums[i]*nums[j]);\\n                i++;\\n                j--;\\n            }\\n            else return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& nums) {\\n        long long i=0,j=nums.size()-1,sum = accumulate(nums.begin(),nums.end(),0),s = nums.size()/2,ans = 0;\\n        sort(nums.begin(),nums.end());\\n        while(i<j){\\n            if(nums[i]+nums[j] == sum/s){\\n                ans+=(nums[i]*nums[j]);\\n                i++;\\n                j--;\\n            }\\n            else return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084937,
                "title": "simple-solution-runtime-o-n-space-o-1",
                "content": "# Approach\\nThe solution is exactly the same as the two pointer approach except we use bucket sort to reduce the runtime to O(n). \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skills) {\\n        bucketSort(skills);\\n        \\n        long chemistrySum = -1;\\n        int expectedSkillSum = -1;\\n        for (int i = 0; i < skills.length / 2; i++) {\\n            int skillSum = skills[i] + skills[skills.length - 1 - i];\\n            long chemistry = skills[i] * skills[skills.length - 1 - i];\\n\\n            if (chemistrySum == -1) {\\n                expectedSkillSum = skillSum;\\n                chemistrySum = chemistry;\\n            } else {\\n                if (skillSum != expectedSkillSum) {\\n                    chemistrySum = -1;\\n                    break;\\n                } else {\\n                    chemistrySum += chemistry;\\n                }\\n            }\\n        }\\n\\n        return chemistrySum;\\n    }\\n\\n    private void bucketSort(int[] skills) {\\n        int[] skillFrequencies = new int[1000];\\n        for (int skill : skills) {\\n            skillFrequencies[skill - 1] += 1;\\n        }\\n\\n        int index = 0;\\n        for (int i = 0; i < skillFrequencies.length; i++) {\\n            int skillFrequency = skillFrequencies[i];\\n            while (skillFrequency > 0) {\\n                skills[index++] = i + 1;\\n                skillFrequency--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skills) {\\n        bucketSort(skills);\\n        \\n        long chemistrySum = -1;\\n        int expectedSkillSum = -1;\\n        for (int i = 0; i < skills.length / 2; i++) {\\n            int skillSum = skills[i] + skills[skills.length - 1 - i];\\n            long chemistry = skills[i] * skills[skills.length - 1 - i];\\n\\n            if (chemistrySum == -1) {\\n                expectedSkillSum = skillSum;\\n                chemistrySum = chemistry;\\n            } else {\\n                if (skillSum != expectedSkillSum) {\\n                    chemistrySum = -1;\\n                    break;\\n                } else {\\n                    chemistrySum += chemistry;\\n                }\\n            }\\n        }\\n\\n        return chemistrySum;\\n    }\\n\\n    private void bucketSort(int[] skills) {\\n        int[] skillFrequencies = new int[1000];\\n        for (int skill : skills) {\\n            skillFrequencies[skill - 1] += 1;\\n        }\\n\\n        int index = 0;\\n        for (int i = 0; i < skillFrequencies.length; i++) {\\n            int skillFrequency = skillFrequencies[i];\\n            while (skillFrequency > 0) {\\n                skills[index++] = i + 1;\\n                skillFrequency--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081338,
                "title": "easy-cpp-solution-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n=skill.size();\\n        int st=0;int end=n-1;\\n        vector<int>v;long long ans=0;\\n        while(st<end){\\n         int sum=skill[st]+skill[end];\\n         int prod=skill[st]*skill[end];\\n         ans+=prod;\\n         st++;\\n         end--;\\n         v.push_back(sum);\\n        }\\n        for(int i=0;i<v.size()-1;i++){\\n            if(v[i]!=v[i+1]){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n=skill.size();\\n        int st=0;int end=n-1;\\n        vector<int>v;long long ans=0;\\n        while(st<end){\\n         int sum=skill[st]+skill[end];\\n         int prod=skill[st]*skill[end];\\n         ans+=prod;\\n         st++;\\n         end--;\\n         v.push_back(sum);\\n        }\\n        for(int i=0;i<v.size()-1;i++){\\n            if(v[i]!=v[i+1]){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079685,
                "title": "golang-array-o-n-time-and-o-1-space-fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSince we have to devide skill array into two pairs who with equal skill sum score. we can derive one pair score by min+max of array.\\n\\nnow we need to figure out pairs. We can sort array can iterate from start and end and create pairs. in above sorting of 10^5 will take time. \\nwe can also take map[int]int(key - skill number, value - number of occurence). and we can iterate array and find target value by doing target-skill. at this point we have o(n) time solution. we can do better\\nsince constrain in problem for skill value is 1000. we can allocate array of 1000 insted of hashmap this will same more cpu cycles\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc dividePlayers(skill []int) int64 {\\n \\tmin := 1001\\n\\tmax := 0\\n\\n\\thSkill := make([]int, 1000)\\n\\tfor _, k := range skill {\\n\\t\\tif k < min {\\n\\t\\t\\tmin = k\\n\\t\\t}\\n\\n\\t\\tif k > max {\\n\\t\\t\\tmax = k\\n\\t\\t}\\n\\n\\t\\thSkill[k-1]++\\n\\t}\\n\\n\\ttarget := min + max\\n\\n\\tvar sum int64\\n\\tfor _, k := range skill {\\n\\t\\tif hSkill[k-1] < 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\thSkill[k-1]--\\n\\t\\tr := target - k\\n\\t\\tif hSkill[r-1] < 1 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\n\\t\\thSkill[r-1]--\\n\\t\\tsum += int64(k * r)\\n\\t}\\n\\n\\treturn sum\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\nfunc dividePlayers(skill []int) int64 {\\n \\tmin := 1001\\n\\tmax := 0\\n\\n\\thSkill := make([]int, 1000)\\n\\tfor _, k := range skill {\\n\\t\\tif k < min {\\n\\t\\t\\tmin = k\\n\\t\\t}\\n\\n\\t\\tif k > max {\\n\\t\\t\\tmax = k\\n\\t\\t}\\n\\n\\t\\thSkill[k-1]++\\n\\t}\\n\\n\\ttarget := min + max\\n\\n\\tvar sum int64\\n\\tfor _, k := range skill {\\n\\t\\tif hSkill[k-1] < 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\thSkill[k-1]--\\n\\t\\tr := target - k\\n\\t\\tif hSkill[r-1] < 1 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\n\\t\\thSkill[r-1]--\\n\\t\\tsum += int64(k * r)\\n\\t}\\n\\n\\treturn sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077422,
                "title": "2491-divide-players-into-teams-of-equal-skill",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill=sorted(skill)\\n        l=0\\n        r=len(skill)-1\\n        s=skill[l]+skill[r]\\n        summ=0\\n        if len(skill)==2:\\n            return skill[0]*skill[1]\\n        while(l<r):\\n            if skill[l]+skill[r]==s:\\n                summ+=(skill[l]*skill[r])\\n            else:\\n                return -1\\n            l+=1\\n            r-=1\\n        return summ\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill=sorted(skill)\\n        l=0\\n        r=len(skill)-1\\n        s=skill[l]+skill[r]\\n        summ=0\\n        if len(skill)==2:\\n            return skill[0]*skill[1]\\n        while(l<r):\\n            if skill[l]+skill[r]==s:\\n                summ+=(skill[l]*skill[r])\\n            else:\\n                return -1\\n            l+=1\\n            r-=1\\n        return summ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068654,
                "title": "c-two-pointers-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skills) {\\n        int n=skills.size();\\n        sort(skills.begin(),skills.end());\\n        long long ans=0;\\n        int x=skills[0]+skills[n-1];\\n        int i=0,j=n-1;\\n        while(i<j){\\n            if(skills[i]+skills[j]==x){\\n                ans=ans+(skills[i]*skills[j]);\\n                i++;\\n                j--;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skills) {\\n        int n=skills.size();\\n        sort(skills.begin(),skills.end());\\n        long long ans=0;\\n        int x=skills[0]+skills[n-1];\\n        int i=0,j=n-1;\\n        while(i<j){\\n            if(skills[i]+skills[j]==x){\\n                ans=ans+(skills[i]*skills[j]);\\n                i++;\\n                j--;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064275,
                "title": "very-intuitive-c-question-just-like-k-sum-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.find out the total sum\\n2.no of pairs required is n/2 or n>>1, so if sum is not divisible by n/2 , return -1,since all pairs require equl sum \\n3.now equal sum required is given by  sum/(n>>1);\\n4.now question becomes find no of pairs with sum=sum/(n>>1);\\n5.k sum pairs question approach\\n6.sort and use two pointer\\n7.if no of pairs found is not equal to n/2 then -1\\n8.find chemistry then\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1) if chem is for the answer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n = skill.size();\\n        if(n==2){\\n            return (long long)(skill[0]*skill[1]);\\n        }\\n        int sum = accumulate(skill.begin(),skill.end(),0);\\n        if(sum%(n>>1) != 0){\\n            return -1;\\n        }\\n        //now we need n/2 pairs with sum = totalsum/(n>>1);\\n        //.           no of k sum pairs jaisa ho gya\\n        //if pairs == n/2 ,then valid\\n        int k = sum/(n>>1);\\n\\n        sort(skill.begin(), skill.end());\\n\\n        int s = 0;\\n        int e = n-1,ans=0;\\n\\n        while(s < e) {\\n            if(skill[s] + skill[e] == k) {\\n                ans++;\\n                s++;\\n                e--;\\n            }\\n            else if(skill[s] + skill[e] > k)\\n                e--;\\n            else \\n                s++;\\n        }\\n\\n        if(ans != (n>>1)){\\n            return -1;\\n        }\\n        long long chem  =0;\\n        for(int i=0;i<n/2;i++){\\n            chem += (long long )(skill[i]*skill[n-i-1]);\\n        }\\n        return chem;\\n    }\\n}; \\n# heading\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n = skill.size();\\n        if(n==2){\\n            return (long long)(skill[0]*skill[1]);\\n        }\\n        int sum = accumulate(skill.begin(),skill.end(),0);\\n        if(sum%(n>>1) != 0){\\n            return -1;\\n        }\\n        //now we need n/2 pairs with sum = totalsum/(n>>1);\\n        //.           no of k sum pairs jaisa ho gya\\n        //if pairs == n/2 ,then valid\\n        int k = sum/(n>>1);\\n\\n        sort(skill.begin(), skill.end());\\n\\n        int s = 0;\\n        int e = n-1,ans=0;\\n\\n        while(s < e) {\\n            if(skill[s] + skill[e] == k) {\\n                ans++;\\n                s++;\\n                e--;\\n            }\\n            else if(skill[s] + skill[e] > k)\\n                e--;\\n            else \\n                s++;\\n        }\\n\\n        if(ans != (n>>1)){\\n            return -1;\\n        }\\n        long long chem  =0;\\n        for(int i=0;i<n/2;i++){\\n            chem += (long long )(skill[i]*skill[n-i-1]);\\n        }\\n        return chem;\\n    }\\n}; \\n# heading\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042445,
                "title": "easy-and-simple-approach-using-hashmap",
                "content": "Please Upvote If you like the approach and the answer.\\n\\n# Approach\\n1. Sort the skill array in ascending order.\\n2. Intialize the two pointer **i,j** from 1 to n-2 (n = size of array ) and **flag** which contains the value of the first and last element of the skill array.\\n3. Intialize the hashmap.\\n4. Insert the first value of array as key and map last value array with it.\\n5. Run a while loop if flag is not equal to the *skill[i]+skill[j]* then return -1 as it means that array doesn\\'t have the teams with equal skill.\\n6. If flag is equal to the *skill[i]+skill[j]* then check whether the (i,j) pair exist if it exist then add the value to the existing pair.\\n7. If not then simply add the new pair in the hashmap.\\n8. Intialize a variable **ans** and traverse the map and multiply the key and value and add to the ans variable.\\n\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n- Space complexity:\\n**O(n)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        if(skill.size()==2) return skill[0]*skill[1];\\n\\n        sort(skill.begin(),skill.end());\\n\\n        int i=1,j=skill.size()-2,flag=skill[0]+skill[skill.size()-1];\\n\\n        unordered_map<long long ,long long>m;\\n\\n        m[skill[0]]=skill[skill.size()-1];\\n\\n        while(i<j){\\n            if(flag!=skill[i]+skill[j]) return -1;\\n            else{\\n              if(m.count(skill[i])==false) m[skill[i]]=skill[j];\\n              else m[skill[i]]+=skill[j];\\n            }\\n            i++; j--;\\n        }\\n\\n        long long ans=0;\\n        for(auto it:m){\\n          long long mult=it.first*it.second;\\n          ans=ans+mult;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        if(skill.size()==2) return skill[0]*skill[1];\\n\\n        sort(skill.begin(),skill.end());\\n\\n        int i=1,j=skill.size()-2,flag=skill[0]+skill[skill.size()-1];\\n\\n        unordered_map<long long ,long long>m;\\n\\n        m[skill[0]]=skill[skill.size()-1];\\n\\n        while(i<j){\\n            if(flag!=skill[i]+skill[j]) return -1;\\n            else{\\n              if(m.count(skill[i])==false) m[skill[i]]=skill[j];\\n              else m[skill[i]]+=skill[j];\\n            }\\n            i++; j--;\\n        }\\n\\n        long long ans=0;\\n        for(auto it:m){\\n          long long mult=it.first*it.second;\\n          ans=ans+mult;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033940,
                "title": "a-simple-solution-in-java",
                "content": "\\n# Java \\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n\\n        long result = 0;\\n        int n = skill.length;\\n        int left = 0;\\n        int right = n - 1;\\n        int[] products = new int[n / 2];\\n        int [] sommes = new int[n / 2];\\n        int index = 0;\\n        int index2 = 0;\\n\\n        if(skill.length % 2 != 0){\\n            return -1;\\n        } else if (skill.length == 2){\\n            result = skill[0] * skill[1];\\n            return result;\\n        } else {\\n            Arrays.sort(skill);\\n            while (left <= right){\\n                products[index] = skill[left] * skill[right];\\n                sommes[index2] = skill[left] + skill[right];\\n                left ++;\\n                right --;\\n                index ++;\\n                index2 ++;\\n            }\\n            for(int i = 0; i < sommes.length; i++){\\n                if(sommes[0] != sommes[i]){\\n                    return -1;\\n                }\\n            }\\n            for (int j = 0; j < products.length; j++){\\n                    result += products[j];\\n                }\\n            \\n            return result; \\n        }  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n\\n        long result = 0;\\n        int n = skill.length;\\n        int left = 0;\\n        int right = n - 1;\\n        int[] products = new int[n / 2];\\n        int [] sommes = new int[n / 2];\\n        int index = 0;\\n        int index2 = 0;\\n\\n        if(skill.length % 2 != 0){\\n            return -1;\\n        } else if (skill.length == 2){\\n            result = skill[0] * skill[1];\\n            return result;\\n        } else {\\n            Arrays.sort(skill);\\n            while (left <= right){\\n                products[index] = skill[left] * skill[right];\\n                sommes[index2] = skill[left] + skill[right];\\n                left ++;\\n                right --;\\n                index ++;\\n                index2 ++;\\n            }\\n            for(int i = 0; i < sommes.length; i++){\\n                if(sommes[0] != sommes[i]){\\n                    return -1;\\n                }\\n            }\\n            for (int j = 0; j < products.length; j++){\\n                    result += products[j];\\n                }\\n            \\n            return result; \\n        }  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029552,
                "title": "sorting-2-pointers",
                "content": "# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        n = len(skill)\\n        if n % 2 != 0:\\n            return -1\\n        total = sum(skill)/(n//2)\\n        skill.sort()\\n        left, right = 0, n-1\\n        ans = 0\\n        while left < right:\\n            if skill[left] + skill[right] != total:\\n                return -1\\n            ans += skill[left]*skill[right]\\n            left += 1\\n            right -= 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        n = len(skill)\\n        if n % 2 != 0:\\n            return -1\\n        total = sum(skill)/(n//2)\\n        skill.sort()\\n        left, right = 0, n-1\\n        ans = 0\\n        while left < right:\\n            if skill[left] + skill[right] != total:\\n                return -1\\n            ans += skill[left]*skill[right]\\n            left += 1\\n            right -= 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023373,
                "title": "java-solution-using-arraylist-simple-o-n-tc",
                "content": "# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        long ans = 0;\\n        Arrays.sort(skill);\\n        ArrayList<ArrayList<Integer>> al = new ArrayList<>();\\n        int k = skill.length-1;\\n        for(int i = 0; i < skill.length/2; i++){\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(skill[i]);\\n            temp.add(skill[k]);\\n            k--;\\n            al.add(temp);\\n        }\\n        int val = al.get(0).get(0)+al.get(0).get(1);\\n        for(int i = 0; i < al.size(); i++){\\n            if((al.get(i).get(0)+al.get(i).get(1))!=val){\\n                return -1;\\n            }\\n            else{\\n                ans = ans + al.get(i).get(0)*al.get(i).get(1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        long ans = 0;\\n        Arrays.sort(skill);\\n        ArrayList<ArrayList<Integer>> al = new ArrayList<>();\\n        int k = skill.length-1;\\n        for(int i = 0; i < skill.length/2; i++){\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(skill[i]);\\n            temp.add(skill[k]);\\n            k--;\\n            al.add(temp);\\n        }\\n        int val = al.get(0).get(0)+al.get(0).get(1);\\n        for(int i = 0; i < al.size(); i++){\\n            if((al.get(i).get(0)+al.get(i).get(1))!=val){\\n                return -1;\\n            }\\n            else{\\n                ans = ans + al.get(i).get(0)*al.get(i).get(1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002566,
                "title": "reduce-to-two-sum-problem-map-easy-java",
                "content": "# Intuition\\nThis problem can be reduced to `Two Sum` problem.\\n\\n# Approach\\n1. If the size of the array is 2 then just return their product and we are done.\\n2. The size will never be `odd`. So there would always be pairs of numbers that could potentially have same sum across all pairs.\\n3. Get the sum of entire array into a variable called `sum`.\\n4. Get the total number of pairs (`teams`). `skills.length/2`\\n5. Get the sum for each team (`teamTotal`) `sum/teams`\\n\\nNow we just need to solve this problem like a `Two Sum` problem and find if there are n/2 pairs that sum exactly as `teamTotal`. \\n\\n6. Calculate `chemistry` on the fly by multiplying the number (`skill`) with its complement. (`teamTotal - skill`).\\n\\nOnce we\\'re done with the loop, all we need to check is if there were matching numbers for all the n/2 elements. In other words, if their sum was equal to the `teamTotal`. \\n\\n7. Check if `map` is empty. If it is, then we\\'ve found all pairs that sum to `teamTotal`. If there\\'s any elements in the `map` then there was atleast one pair of numbers that didn\\'t sum the same as others and return `-1`.\\n\\n# Complexity\\n- Time complexity:\\nO(N) as we loop over the array twice.\\n\\n- Space complexity:\\nO(N) as all number in the `skill` array could be distinct and the map could grow until `N`.\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skills) {\\n        if(skills.length == 2) return (long)skills[0] * skills[1];\\n\\n        int sum = IntStream.of(skills).sum();\\n        int n = skills.length;\\n        int teams = n/2;\\n        int teamTotal = sum/teams;\\n\\n        long chemistry = 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int skill: skills){\\n            if(map.containsKey(skill)){\\n                int occurence = map.get(skill);\\n                if(occurence == 1){\\n                    map.remove(skill);\\n                }else{\\n                    map.put(skill, occurence - 1);\\n                }\\n                chemistry += skill * (teamTotal - skill);\\n            }else{\\n                map.put(teamTotal - skill, map.getOrDefault(teamTotal - skill, 0) + 1);\\n            }\\n        }\\n        return map.isEmpty() ? chemistry : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skills) {\\n        if(skills.length == 2) return (long)skills[0] * skills[1];\\n\\n        int sum = IntStream.of(skills).sum();\\n        int n = skills.length;\\n        int teams = n/2;\\n        int teamTotal = sum/teams;\\n\\n        long chemistry = 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int skill: skills){\\n            if(map.containsKey(skill)){\\n                int occurence = map.get(skill);\\n                if(occurence == 1){\\n                    map.remove(skill);\\n                }else{\\n                    map.put(skill, occurence - 1);\\n                }\\n                chemistry += skill * (teamTotal - skill);\\n            }else{\\n                map.put(teamTotal - skill, map.getOrDefault(teamTotal - skill, 0) + 1);\\n            }\\n        }\\n        return map.isEmpty() ? chemistry : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999435,
                "title": "easy-and-simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long sum=0;\\n\\n        sort(skill.begin(), skill.end());\\n\\n        int i=0, j=skill.size()-1;\\n        int sk=skill[i]+skill[j];\\n\\n        while(i < j){\\n            if(skill[i]+skill[j] == sk){\\n                sum+=skill[i]*skill[j];\\n            }\\n            else{\\n                return -1;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long sum=0;\\n\\n        sort(skill.begin(), skill.end());\\n\\n        int i=0, j=skill.size()-1;\\n        int sk=skill[i]+skill[j];\\n\\n        while(i < j){\\n            if(skill[i]+skill[j] == sk){\\n                sum+=skill[i]*skill[j];\\n            }\\n            else{\\n                return -1;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975357,
                "title": "simple-and-understandable-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int n = skill.length;\\n        int sum = skill[0] + skill[n-1];\\n        long mul = skill[0] * skill[n-1];\\n        if(skill.length == 2){\\n            return mul;\\n        }\\n        for(int i=1;i<n/2;i++){\\n            int newsum = skill[i] + skill[n-i-1];\\n            long nmul = skill[i] * skill[n-i-1];\\n            if(sum == newsum){\\n                mul += nmul;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return mul;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int n = skill.length;\\n        int sum = skill[0] + skill[n-1];\\n        long mul = skill[0] * skill[n-1];\\n        if(skill.length == 2){\\n            return mul;\\n        }\\n        for(int i=1;i<n/2;i++){\\n            int newsum = skill[i] + skill[n-i-1];\\n            long nmul = skill[i] * skill[n-i-1];\\n            if(sum == newsum){\\n                mul += nmul;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return mul;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959222,
                "title": "injava",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTo get equal sum, take smallest + largest element, that\\'s why we sort the array.\\n\\nLogic we not understood:- suppose you took 2 large numbers and some random 2 small large numbers, the sum will never to equal. So the best method to check equal pair of sums is ,to keep adding smallest and largest numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int sum = skill[0]+skill[skill.length-1];\\n        int i=1;\\n        int j=skill.length-2;\\n        long che = skill[0]*skill[skill.length-1];\\n        while(i<j)\\n        {\\n            int sum1 = skill[i]+skill[j];\\n            if(sum==sum1)\\n            che = che+(skill[i]*skill[j]);\\n            else if(sum!=sum1)\\n            return -1;\\n            i++;\\n            j--;\\n        }\\n        return che;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int sum = skill[0]+skill[skill.length-1];\\n        int i=1;\\n        int j=skill.length-2;\\n        long che = skill[0]*skill[skill.length-1];\\n        while(i<j)\\n        {\\n            int sum1 = skill[i]+skill[j];\\n            if(sum==sum1)\\n            che = che+(skill[i]*skill[j]);\\n            else if(sum!=sum1)\\n            return -1;\\n            i++;\\n            j--;\\n        }\\n        return che;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951500,
                "title": "c-simple-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skills) {\\n        sort(skills.begin(),skills.end());\\n        int sz=skills.size();\\n        long long res=0;\\n        int i=0;\\n        int j=sz-1;\\n        int sc=skills[i]+skills[j];\\n         res=skills[i]*skills[j];\\n        i++,j--;\\n       \\n        while(i<j)\\n         {\\n             int sum=skills[i]+skills[j];\\n             res=res+skills[i]*skills[j];\\n             if(sum!=sc)\\n            return -1;\\n             i++;j--;\\n         }\\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skills) {\\n        sort(skills.begin(),skills.end());\\n        int sz=skills.size();\\n        long long res=0;\\n        int i=0;\\n        int j=sz-1;\\n        int sc=skills[i]+skills[j];\\n         res=skills[i]*skills[j];\\n        i++,j--;\\n       \\n        while(i<j)\\n         {\\n             int sum=skills[i]+skills[j];\\n             res=res+skills[i]*skills[j];\\n             if(sum!=sc)\\n            return -1;\\n             i++;j--;\\n         }\\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936841,
                "title": "sorting-two-pointers",
                "content": "# Intuition\\n`for this problem , valid skill arrays must have these example shapes \\n[1,2,3,4]\\n[20,21,22,23]\\n[1,2,3,4,5,6]\\n[101,102,103,104,105,106] , \\nso simply must be consecutive n skills with diff between two adjcent skills = 1\\nso sorting + two pointers will help us discover this pattern in the skill array`\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill.sort()\\n        left, right = 0, len(skill) - 1\\n        teams_chem = []\\n        ref_team = [skill[left], skill[right]]\\n        while left < right:\\n            if skill[left] + skill[right] == ref_team[0] + ref_team[1]:\\n                teams_chem.append(skill[left] * skill[right])\\n                left += 1\\n                right -= 1\\n            else:\\n                return -1\\n        return sum(teams_chem)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill.sort()\\n        left, right = 0, len(skill) - 1\\n        teams_chem = []\\n        ref_team = [skill[left], skill[right]]\\n        while left < right:\\n            if skill[left] + skill[right] == ref_team[0] + ref_team[1]:\\n                teams_chem.append(skill[left] * skill[right])\\n                left += 1\\n                right -= 1\\n            else:\\n                return -1\\n        return sum(teams_chem)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932884,
                "title": "very-simple-easy-to-understand-code-using-basic-two-pointer-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n = skill.size();\\n        int start = 0, end = n-1;\\n        long long int ans = 0;\\n\\n        sort (skill.begin(),skill.end());\\n\\n        while (start < end){\\n            if ((skill[start]+skill[end]) != (skill[start+1]+skill[end-1]))\\n            return -1;\\n\\n            ans += (skill[start]*skill[end]);\\n            start++;\\n            end--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n = skill.size();\\n        int start = 0, end = n-1;\\n        long long int ans = 0;\\n\\n        sort (skill.begin(),skill.end());\\n\\n        while (start < end){\\n            if ((skill[start]+skill[end]) != (skill[start+1]+skill[end-1]))\\n            return -1;\\n\\n            ans += (skill[start]*skill[end]);\\n            start++;\\n            end--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910029,
                "title": "solution-without-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int i=0,j=skill.size()-1;\\n        long long ans=0;\\n        int target=skill[i]+skill[j];\\n        while(i<j){\\n            if(skill[i]+skill[j]==target){\\n                ans+=skill[i]*skill[j];\\n                i++,j--;\\n            }\\n            else return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int i=0,j=skill.size()-1;\\n        long long ans=0;\\n        int target=skill[i]+skill[j];\\n        while(i<j){\\n            if(skill[i]+skill[j]==target){\\n                ans+=skill[i]*skill[j];\\n                i++,j--;\\n            }\\n            else return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889455,
                "title": "fastest-solution-using-two-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n\\t\\t// sort the skill vector.\\n        sort(skill.begin(), skill.end());\\n        int s = 0, e = skill.size() - 1;\\n        long long ans = 0;\\n\\t\\t// vector to store sum of the skill of two players.\\n        vector<long long> v;\\n        while (s <= e)\\n        {\\n            v.push_back(skill[s] + skill[e]); \\n            ans += skill[s++] * skill[e--];\\n        }\\n\\t\\t// if every values in sum is not equal, then return -1.\\n        for (int i = 1; i < v.size(); i++)\\n            if (v[i - 1] != v[i])\\n                return -1;\\n\\t\\t// since it is not given that size of array is even check for the size.\\n        if (v.size() == skill.size()/ 2)\\n            return ans;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n\\t\\t// sort the skill vector.\\n        sort(skill.begin(), skill.end());\\n        int s = 0, e = skill.size() - 1;\\n        long long ans = 0;\\n\\t\\t// vector to store sum of the skill of two players.\\n        vector<long long> v;\\n        while (s <= e)\\n        {\\n            v.push_back(skill[s] + skill[e]); \\n            ans += skill[s++] * skill[e--];\\n        }\\n\\t\\t// if every values in sum is not equal, then return -1.\\n        for (int i = 1; i < v.size(); i++)\\n            if (v[i - 1] != v[i])\\n                return -1;\\n\\t\\t// since it is not given that size of array is even check for the size.\\n        if (v.size() == skill.size()/ 2)\\n            return ans;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884767,
                "title": "95-faster-solution-in-python-easy-to-undestand",
                "content": "## Solution\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        s, n = sum(skill), len(skill)\\n        if s%(n//2): return -1\\n        skill.sort()\\n        ans = 0\\n        expect = s//(n//2)\\n        for i in range(n//2):\\n            if expect!=skill[i]+skill[-i-1]: return -1\\n            ans += skill[i]*skill[-i-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        s, n = sum(skill), len(skill)\\n        if s%(n//2): return -1\\n        skill.sort()\\n        ans = 0\\n        expect = s//(n//2)\\n        for i in range(n//2):\\n            if expect!=skill[i]+skill[-i-1]: return -1\\n            ans += skill[i]*skill[-i-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884255,
                "title": "divide-players-into-teams-of-equal-skill",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int sum = skill[0]+skill[skill.length-1];\\n        int i=1;\\n        int j=skill.length-2;\\n        long che = skill[0]*skill[skill.length-1];\\n        while(i<j)\\n        {\\n            int sum1 = skill[i]+skill[j];\\n            if(sum==sum1)\\n            che = che+(skill[i]*skill[j]);\\n            else if(sum!=sum1)\\n            return -1;\\n            i++;\\n            j--;\\n        }\\n        return che;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int sum = skill[0]+skill[skill.length-1];\\n        int i=1;\\n        int j=skill.length-2;\\n        long che = skill[0]*skill[skill.length-1];\\n        while(i<j)\\n        {\\n            int sum1 = skill[i]+skill[j];\\n            if(sum==sum1)\\n            che = che+(skill[i]*skill[j]);\\n            else if(sum!=sum1)\\n            return -1;\\n            i++;\\n            j--;\\n        }\\n        return che;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866607,
                "title": "python-3-simple-2-pointer-approach",
                "content": "# Approach\\nSimple Arrithmetic Approach\\n\\nFirst calculate the number of teams required\\n\\nCalculate the skill per team and check if it is an integer\\n\\nSort the array \\n\\nUsing 2 pointers pair the players.\\nIf the total skill of a team is not equal to the required skill, then return -1\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        n = len(skill)\\n        no_of_teams = n/2\\n        chem = -1\\n        if sum(skill)%no != 0:\\n            return -1\\n        tskill = sum(skill)/no\\n        skill.sort()\\n        p =0 \\n        q = n-1\\n        while( p < q):\\n            if skill[p] + skill[q] == tskill:\\n                if chem == -1:\\n                    chem = skill[p] * skill[q]\\n                else:\\n                    chem += skill[p] * skill[q]\\n            else:\\n                return -1\\n            p +=1\\n            q -= 1\\n        return chem\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        n = len(skill)\\n        no_of_teams = n/2\\n        chem = -1\\n        if sum(skill)%no != 0:\\n            return -1\\n        tskill = sum(skill)/no\\n        skill.sort()\\n        p =0 \\n        q = n-1\\n        while( p < q):\\n            if skill[p] + skill[q] == tskill:\\n                if chem == -1:\\n                    chem = skill[p] * skill[q]\\n                else:\\n                    chem += skill[p] * skill[q]\\n            else:\\n                return -1\\n            p +=1\\n            q -= 1\\n        return chem\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859457,
                "title": "easy-c-sorting-based-two-pointer-based-solution-beginner-friendly",
                "content": "# Intuition\\nsort and use 2 pointers\\n# Approach\\nsorting\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n=skill.size();\\n        long long a=skill[0]+skill[n-1];\\n        long long ans=0;\\n        if(n==2)return skill[0]*skill[1];\\n        int i=0,j=n-1;\\n        while(i<j)\\n        {\\n            if(skill[i]+skill[j]==a)\\n            {\\n                ans+=(skill[i]*skill[j]);\\n            }\\n            else return -1;\\n            i++,j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n=skill.size();\\n        long long a=skill[0]+skill[n-1];\\n        long long ans=0;\\n        if(n==2)return skill[0]*skill[1];\\n        int i=0,j=n-1;\\n        while(i<j)\\n        {\\n            if(skill[i]+skill[j]==a)\\n            {\\n                ans+=(skill[i]*skill[j]);\\n            }\\n            else return -1;\\n            i++,j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854502,
                "title": "golang-sort-solution",
                "content": "# Code\\n```go\\nfunc dividePlayers(skill []int) int64 {\\n\\tsort.Ints(skill)\\n\\tchemistry := skill[0] * skill[len(skill)-1]\\n\\tfor i := 1; i < len(skill) / 2; i++ {\\n\\t\\tif skill[0] + skill[len(skill)-1] != skill[i] + skill[len(skill)-1-i] {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\tchemistry += skill[i] * skill[len(skill)-1-i]\\n\\t}\\n\\treturn int64(chemistry)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc dividePlayers(skill []int) int64 {\\n\\tsort.Ints(skill)\\n\\tchemistry := skill[0] * skill[len(skill)-1]\\n\\tfor i := 1; i < len(skill) / 2; i++ {\\n\\t\\tif skill[0] + skill[len(skill)-1] != skill[i] + skill[len(skill)-1-i] {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\tchemistry += skill[i] * skill[len(skill)-1-i]\\n\\t}\\n\\treturn int64(chemistry)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840700,
                "title": "python-two-pointers-solution-after-sorting-beats-99-5",
                "content": "# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        teams, total = len(skill) // 2, sum(skill)\\n        if total % teams != 0:\\n            return -1\\n\\n        skill.sort()\\n        expected_team_value, total_chemistry = total // teams, 0\\n        left, right = 0, len(skill) - 1\\n        \\n        while left < right:\\n            if skill[left] + skill[right] != expected_team_value:\\n                return -1\\n            total_chemistry += skill[left] * skill[right]\\n            left += 1\\n            right -= 1\\n\\n        return total_chemistry\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        teams, total = len(skill) // 2, sum(skill)\\n        if total % teams != 0:\\n            return -1\\n\\n        skill.sort()\\n        expected_team_value, total_chemistry = total // teams, 0\\n        left, right = 0, len(skill) - 1\\n        \\n        while left < right:\\n            if skill[left] + skill[right] != expected_team_value:\\n                return -1\\n            total_chemistry += skill[left] * skill[right]\\n            left += 1\\n            right -= 1\\n\\n        return total_chemistry\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833835,
                "title": "c-easy-solution-beats-99-9-time-89-space",
                "content": "# Approach\\n1. just simply sorted the skill first.\\n2. take the sum of smallest and largest element and called it tmp.\\n3. iterate a loop till n/2 for skill.\\n4. for each iteration check if i and n-i th elements\\' sum is equal to tmp or not, \\n    if not return -1.\\n    else add their product to ans.\\n5. return ans.\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long ans=0;\\n        int n=skill.size();\\n        if(n==2)\\n        return skill[0]*skill[1];\\n        sort(skill.begin(),skill.end());\\n        int tmp = skill[0] + skill[n-1];\\n        for(int i=0;i<n/2;i++)\\n        {\\n            long long check = (skill[i] + skill[n-1-i]);\\n            if(check != tmp)\\n            {\\n                return -1;\\n            }\\n            ans += skill[i]*skill[n-1-i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long ans=0;\\n        int n=skill.size();\\n        if(n==2)\\n        return skill[0]*skill[1];\\n        sort(skill.begin(),skill.end());\\n        int tmp = skill[0] + skill[n-1];\\n        for(int i=0;i<n/2;i++)\\n        {\\n            long long check = (skill[i] + skill[n-1-i]);\\n            if(check != tmp)\\n            {\\n                return -1;\\n            }\\n            ans += skill[i]*skill[n-1-i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827872,
                "title": "simple-sorting-and-two-pointer-technique",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long ans = 0;\\n        sort(skill.begin(),skill.end());\\n        int start = 0;\\n        int end = skill.size()-1;\\n        int sum = skill[start] + skill[end];\\n        ans += skill[start] * skill[end];\\n        start++;end--;\\n        while(start<=end){\\n            int a = skill[start] + skill[end];\\n            if(a==sum){\\n                ans += skill[start] * skill[end];\\n            }\\n            else{\\n                return -1;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long ans = 0;\\n        sort(skill.begin(),skill.end());\\n        int start = 0;\\n        int end = skill.size()-1;\\n        int sum = skill[start] + skill[end];\\n        ans += skill[start] * skill[end];\\n        start++;end--;\\n        while(start<=end){\\n            int a = skill[start] + skill[end];\\n            if(a==sum){\\n                ans += skill[start] * skill[end];\\n            }\\n            else{\\n                return -1;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820433,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(nlogn)$$\\n- Space complexity:$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int n=skill.length;\\n        if(n%2==1) return -1;\\n        Arrays.sort(skill);\\n        long che=0L;\\n        int sum=-1;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            int temp=skill[i]+skill[j];\\n            if(sum==-1){\\n                sum=temp;\\n            }\\n            else if(sum!=temp) return -1;\\n            che+=(skill[i]*skill[j]);\\n            i++;\\n            j--;\\n        }\\n        return che;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int n=skill.length;\\n        if(n%2==1) return -1;\\n        Arrays.sort(skill);\\n        long che=0L;\\n        int sum=-1;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            int temp=skill[i]+skill[j];\\n            if(sum==-1){\\n                sum=temp;\\n            }\\n            else if(sum!=temp) return -1;\\n            che+=(skill[i]*skill[j]);\\n            i++;\\n            j--;\\n        }\\n        return che;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818897,
                "title": "vector-game-with-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(), skill.end());\\n        vector<long long> temp;\\n        vector<long long> chem;\\n        for(int i=0; i<skill.size()/2; i++){\\n            long long a = skill[i] + skill[skill.size() - i-1];\\n            long long b = skill[i] * skill[skill.size() - i-1];\\n            chem.push_back(b);\\n            temp.push_back(a);\\n            cout<<a<<\" \";\\n        }\\n\\n        for(long long i=0; i<temp.size(); i++){\\n            if(temp[i] != temp[0]){\\n                return -1;\\n            }\\n        }\\n\\n        long long sum=0;\\n        for(long long i = 0; i<chem.size(); i++){\\n            sum+= chem[i];\\n        }\\n\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(), skill.end());\\n        vector<long long> temp;\\n        vector<long long> chem;\\n        for(int i=0; i<skill.size()/2; i++){\\n            long long a = skill[i] + skill[skill.size() - i-1];\\n            long long b = skill[i] * skill[skill.size() - i-1];\\n            chem.push_back(b);\\n            temp.push_back(a);\\n            cout<<a<<\" \";\\n        }\\n\\n        for(long long i=0; i<temp.size(); i++){\\n            if(temp[i] != temp[0]){\\n                return -1;\\n            }\\n        }\\n\\n        long long sum=0;\\n        for(long long i = 0; i<chem.size(); i++){\\n            sum+= chem[i];\\n        }\\n\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3789331,
                "title": "hashmap-python-two-pass-simple-solution-no-double-counting-pairs",
                "content": "# Intuition\\nThe approach for this solution is same as `https://leetcode.com/problems/max-number-of-k-sum-pairs/description/` except we just need to calculate `k` first.\\nThe idea is if `num` in `skill` exists, assume you can find a pair for it. If we can, calculate `prod`. Else, it means we found a situation where we cannot form a pair and we can immediately return `-1`\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`. Making the hashmap initially is O(n), and then another O(n) for looping.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        prod = 0\\n\\n        k = 2 * sum(skill) // len(skill)\\n        counts = collections.Counter(skill)\\n\\n        for num in skill:\\n            if counts[num] >= 1:\\n                y = k - num\\n                counts[num] -= 1\\n\\n                if counts[y] >= 1:\\n                    counts[y] -= 1\\n                    prod += (num * y)\\n                else:\\n                    return -1\\n                \\n        return prod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        prod = 0\\n\\n        k = 2 * sum(skill) // len(skill)\\n        counts = collections.Counter(skill)\\n\\n        for num in skill:\\n            if counts[num] >= 1:\\n                y = k - num\\n                counts[num] -= 1\\n\\n                if counts[y] >= 1:\\n                    counts[y] -= 1\\n                    prod += (num * y)\\n                else:\\n                    return -1\\n                \\n        return prod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783124,
                "title": "easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int k = skill.length-1;\\n        int count = skill[0]+skill[skill.length-1];\\n        long result = 0;\\n        int i =0;\\n        if(skill.length==2){\\n            return skill[0]*skill[1];\\n        }\\n        while(i<k){\\n            if(skill[i]+skill[k]==count){\\n                result+=skill[i]*skill[k];\\n                i++;\\n                k--;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int k = skill.length-1;\\n        int count = skill[0]+skill[skill.length-1];\\n        long result = 0;\\n        int i =0;\\n        if(skill.length==2){\\n            return skill[0]*skill[1];\\n        }\\n        while(i<k){\\n            if(skill[i]+skill[k]==count){\\n                result+=skill[i]*skill[k];\\n                i++;\\n                k--;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782287,
                "title": "2491-simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int i=0, j=skill.size()-1;\\n        long long int ans=0;\\n        while(i<j)\\n        {\\n            ans+=skill[i]*skill[j];\\n            int temp=skill[i]+skill[j];\\n            if(temp!=skill[i+1]+skill[j-1])\\n            return -1;\\n            i++, j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int i=0, j=skill.size()-1;\\n        long long int ans=0;\\n        while(i<j)\\n        {\\n            ans+=skill[i]*skill[j];\\n            int temp=skill[i]+skill[j];\\n            if(temp!=skill[i+1]+skill[j-1])\\n            return -1;\\n            i++, j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778206,
                "title": "python-easy-solution-using-two-sum-with-comments-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        s, n = sum(skill), len(skill)\\n        #If sum is not possible to be divided into n / 2 teams\\n        if s % (n // 2) != 0:\\n            return -1\\n        #Two Sum\\n        k = s // (n // 2)\\n        hash_map = defaultdict(int)\\n        ans, team_cnt = 0, 0\\n        for val in skill:\\n            if val > k:\\n                return -1\\n            if hash_map[k - val] != 0:\\n                hash_map[k - val] -= 1\\n                ans += val * (k - val)\\n                team_cnt += 1\\n            else:\\n                hash_map[val] += 1\\n        return ans if team_cnt == n // 2 else -1\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        s, n = sum(skill), len(skill)\\n        #If sum is not possible to be divided into n / 2 teams\\n        if s % (n // 2) != 0:\\n            return -1\\n        #Two Sum\\n        k = s // (n // 2)\\n        hash_map = defaultdict(int)\\n        ans, team_cnt = 0, 0\\n        for val in skill:\\n            if val > k:\\n                return -1\\n            if hash_map[k - val] != 0:\\n                hash_map[k - val] -= 1\\n                ans += val * (k - val)\\n                team_cnt += 1\\n            else:\\n                hash_map[val] += 1\\n        return ans if team_cnt == n // 2 else -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754779,
                "title": "two-pointer-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n        sort(skill.begin(), skill.end());\\n\\n        int n = skill.size();\\n\\n        long long ans = 0;\\n        int req_skill = skill[0] + skill[n-1];\\n        ans += skill[0]*skill[n-1];\\n\\n        int i=1, j=n-2;\\n\\n        while(i<j)\\n        {\\n            if(skill[i] + skill[j] == req_skill)\\n            {\\n                ans += (skill[i] * skill[j]);\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n        sort(skill.begin(), skill.end());\\n\\n        int n = skill.size();\\n\\n        long long ans = 0;\\n        int req_skill = skill[0] + skill[n-1];\\n        ans += skill[0]*skill[n-1];\\n\\n        int i=1, j=n-2;\\n\\n        while(i<j)\\n        {\\n            if(skill[i] + skill[j] == req_skill)\\n            {\\n                ans += (skill[i] * skill[j]);\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736158,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int t=skill[skill.size()-1]+skill[0];\\n        int low=1,high=skill.size()-2;\\n        while(low<high)\\n        if(skill[high--]+skill[low++]!=t)return -1;\\n        long long res=0;\\n        low=0,high=skill.size()-1;\\n        while(low<high)\\n        res+=(skill[low++]*skill[high--]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int t=skill[skill.size()-1]+skill[0];\\n        int low=1,high=skill.size()-2;\\n        while(low<high)\\n        if(skill[high--]+skill[low++]!=t)return -1;\\n        long long res=0;\\n        low=0,high=skill.size()-1;\\n        while(low<high)\\n        res+=(skill[low++]*skill[high--]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735951,
                "title": "using-sort-and-simple-loop-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirstly sort the array and check sum of 0th and last index is equal to sum of 1st and last - 1 and increment the count variable.If count is equal to half of array size then return sum otherwise return -1\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int count=0,i=0,j=skill.size()-1;long long sum=0;\\n        while(i<skill.size()/2){\\n            if(skill[i]+skill[j]==skill[i+1]+skill[j-1]){\\n            sum+=skill[i]*skill[j];\\n            count++;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(count==skill.size()/2)\\n        return sum;\\n        else\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int count=0,i=0,j=skill.size()-1;long long sum=0;\\n        while(i<skill.size()/2){\\n            if(skill[i]+skill[j]==skill[i+1]+skill[j-1]){\\n            sum+=skill[i]*skill[j];\\n            count++;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(count==skill.size()/2)\\n        return sum;\\n        else\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717468,
                "title": "simple-math-supported-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, I needed to know the pattern for this problem. Then, I need to find a proper way to apply my logic according to the pattern. The pattern is most likely a simple math and afterwards is just how to implement the logic according to constraints.\\n\\nMy mistake was to not properly check the constraints and possible size of the array. That\\'s why, I had used nested loops which means $$O(n^2)$$ time complexity which leads a **time-out.**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can find the common value of when we sum the pairs up. To do that, we need to get total of the all elements and divide that to the half of the size of the array. \\nMath to find the common value:\\n\\n**n:** Number of elements\\n**i:** Element of the set\\n**cv:** Common Value\\n\\n**cv = <sup>n</sup>\\u2211<sub>i=1</sub>(A[i])/(n/2)**\\n\\n\\n\\nOnce we find the value that is the common value after summing up elements of a pair, we check if its an integer or not. \\n\\nNow, we assume that the array could have all the matcing pairs. Thus, we loop through the array and extract the loop\\'s element from the **common value** to find a complement.\\n\\nDuring Iteration:\\n**c = cv - A[i]**\\n\\nNow, we check **c** and **A[i]** if they already exist by using a dictonary to avoid duplications. And, explanations are given below in the code snippet how duplications were avoided.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nDisclaimer: Possibility of mistakes within the code or explanation. If you notice, please notice me. Thank you. \\n\\n# Code\\n```\\npublic class Solution {\\n    public long DividePlayers(int[] skill) {\\n        //Check if the array is in correct size\\n        if (skill.Length % 2 != 0 || skill.Length == 0) return -1;\\n\\n        //Add all the elements to find the total value and count how many times an element occured.\\n        int sumOfElements = 0;\\n        foreach (int element in skill) sumOfElements += element;\\n        \\n        //Find the common summed value of subsets\\n        int equalValue = sumOfElements / (skill.Length / 2);\\n\\n        //Check if its an integer.\\n        if(equalValue * (skill.Length / 2) != sumOfElements) return -1;\\n\\n        //Get Chemistry and sum them up.\\n        long result = 0;\\n        Dictionary<int,int> elementOccurance = new Dictionary<int,int>();\\n\\n\\n        foreach (int element in skill)\\n        {\\n            if (!elementOccurance.ContainsKey(element))elementOccurance[element] = 0;\\n\\n            //Check if valid pair exists in the skill set.\\n            int difference = equalValue - element;\\n            //If difference exists and occurance count is bigger than 0.\\n            if (elementOccurance.ContainsKey(difference)  && elementOccurance[difference] > 0)\\n            {\\n                result += element * difference;\\n                elementOccurance[difference]--;\\n            }\\n            //Set the element if element did not appear in the dictionary or if it already exists increase the value.\\n            else\\n            {\\n                if(!elementOccurance.ContainsKey(element)) elementOccurance[element] = 0;\\n                elementOccurance[element]++;\\n            }\\n        }\\n       \\n        //Check if there are any left for the pair.\\n        foreach(var element in elementOccurance)\\n        {\\n            if(element.Value > 0) return -1;\\n        }\\n\\n        if (result == 0) return -1;\\n        else return result;\\n       \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public long DividePlayers(int[] skill) {\\n        //Check if the array is in correct size\\n        if (skill.Length % 2 != 0 || skill.Length == 0) return -1;\\n\\n        //Add all the elements to find the total value and count how many times an element occured.\\n        int sumOfElements = 0;\\n        foreach (int element in skill) sumOfElements += element;\\n        \\n        //Find the common summed value of subsets\\n        int equalValue = sumOfElements / (skill.Length / 2);\\n\\n        //Check if its an integer.\\n        if(equalValue * (skill.Length / 2) != sumOfElements) return -1;\\n\\n        //Get Chemistry and sum them up.\\n        long result = 0;\\n        Dictionary<int,int> elementOccurance = new Dictionary<int,int>();\\n\\n\\n        foreach (int element in skill)\\n        {\\n            if (!elementOccurance.ContainsKey(element))elementOccurance[element] = 0;\\n\\n            //Check if valid pair exists in the skill set.\\n            int difference = equalValue - element;\\n            //If difference exists and occurance count is bigger than 0.\\n            if (elementOccurance.ContainsKey(difference)  && elementOccurance[difference] > 0)\\n            {\\n                result += element * difference;\\n                elementOccurance[difference]--;\\n            }\\n            //Set the element if element did not appear in the dictionary or if it already exists increase the value.\\n            else\\n            {\\n                if(!elementOccurance.ContainsKey(element)) elementOccurance[element] = 0;\\n                elementOccurance[element]++;\\n            }\\n        }\\n       \\n        //Check if there are any left for the pair.\\n        foreach(var element in elementOccurance)\\n        {\\n            if(element.Value > 0) return -1;\\n        }\\n\\n        if (result == 0) return -1;\\n        else return result;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713481,
                "title": "c-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n = skill.size();\\n        if(n==2){\\n            return skill[0]*skill[1];\\n        }\\n\\n        sort(skill.begin() , skill.end());\\n        long long chemistry = 0;\\n        int teams = n/2;\\n        int s = skill[0]+skill[n-1];\\n        for(int i = 0 ; i < n/2 ; i++){\\n            if(skill[i]+skill[n-1-i]==s){\\n                chemistry += skill[i]*skill[n-1-i];\\n            }\\n            else{\\n                chemistry = -1;\\n                break;\\n            }\\n        }\\n\\n        return chemistry;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n = skill.size();\\n        if(n==2){\\n            return skill[0]*skill[1];\\n        }\\n\\n        sort(skill.begin() , skill.end());\\n        long long chemistry = 0;\\n        int teams = n/2;\\n        int s = skill[0]+skill[n-1];\\n        for(int i = 0 ; i < n/2 ; i++){\\n            if(skill[i]+skill[n-1-i]==s){\\n                chemistry += skill[i]*skill[n-1-i];\\n            }\\n            else{\\n                chemistry = -1;\\n                break;\\n            }\\n        }\\n\\n        return chemistry;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699034,
                "title": "divide-players-into-teams-of-equal-skill-100-beats-c-simple-solution",
                "content": "**#Upvote if you like the solution**\\n**#simple solution...just have to check sum of element from starting and end are equal or not...**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\nlong long dividePlayers(vector<int>& skill) {\\n        int n=skill.size();\\n        sort(skill.begin(),skill.end());\\n        int sum=skill[0]+skill[n-1];\\n        long long sum1=0;\\n        for(int i=0;i<(n/2);i++)\\n        {\\n            if(skill[i]+skill[n-i-1]==sum)\\n            {\\n                sum1+=(skill[i]*skill[n-i-1]);\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n            \\n        }\\n        \\n        \\n        return sum1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\nlong long dividePlayers(vector<int>& skill) {\\n        int n=skill.size();\\n        sort(skill.begin(),skill.end());\\n        int sum=skill[0]+skill[n-1];\\n        long long sum1=0;\\n        for(int i=0;i<(n/2);i++)\\n        {\\n            if(skill[i]+skill[n-i-1]==sum)\\n            {\\n                sum1+=(skill[i]*skill[n-i-1]);\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n            \\n        }\\n        \\n        \\n        return sum1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686169,
                "title": "c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long ans=0;\\n        int n=skill.size();\\n        sort(skill.begin(),skill.end());\\n        int sum = skill[0] + skill[n-1];\\n        for(int i=0; i<n/2; i++) {\\n            if(skill[i] + skill[n-1-i]!=sum)\\n                return -1;\\n            ans += (skill[i]*skill[n-1-i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long ans=0;\\n        int n=skill.size();\\n        sort(skill.begin(),skill.end());\\n        int sum = skill[0] + skill[n-1];\\n        for(int i=0; i<n/2; i++) {\\n            if(skill[i] + skill[n-1-i]!=sum)\\n                return -1;\\n            ans += (skill[i]*skill[n-1-i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685480,
                "title": "a-simple-and-different-approach-not-found-anywhere",
                "content": "# Intuition\\nFirst I thought about taking first and last members and their skills as target and trying to get the answer\\n\\n# Approach\\nSo I did compared first and last with target and next first++ and last-- with target if it is not same then we have to either do first++++ or last---- so which leaves one player so one will remain hence the result is -1\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int i=0;\\n        int j=skill.size()-1;\\n        sort(skill.begin(), skill.end());\\n        long long res = 0;\\n        int isteam = skill[i] + skill[j];\\n        while(i<j){\\n            if(skill[i]+skill[j] == isteam){\\n                res = res + skill[i] * skill[j];\\n                i++; j--;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int i=0;\\n        int j=skill.size()-1;\\n        sort(skill.begin(), skill.end());\\n        long long res = 0;\\n        int isteam = skill[i] + skill[j];\\n        while(i<j){\\n            if(skill[i]+skill[j] == isteam){\\n                res = res + skill[i] * skill[j];\\n                i++; j--;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678212,
                "title": "using-frequency-map",
                "content": "# Approach\\nSince there are only 2 members in each pair we can calculate the pair target by sum(skill)/(skill.length/2)\\nThen we build a frequency map for fast lookup\\nWe start iterating over \"skill\" and on every iteration, we use a \"frequency map\" to find the second member of the pair and keep building the product along the way\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar dividePlayers = function(skill) {\\n    const map={}, target = skill.reduce((acc,curr)=>acc+curr)/(skill.length/2);\\n    for(const sk of skill) map[sk]=map[sk]+1||1; // building frequency map\\n\\n    let totalProd=0;\\n    for(const sk of skill){\\n        const currPairTarget=target-sk; // second member to find to form a pair\\n        if(map[currPairTarget]!==undefined){\\n            if(map[currPairTarget]>0){\\n                totalProd+=currPairTarget*sk;\\n                map[currPairTarget]--; map[sk]--;\\n            }\\n        }else{\\n            return -1;\\n        }\\n    }\\n    // check if there are some leftovers, it means we can not form all pairs\\n    if(Object.keys(map).find(k=>map[k]>0)) return -1;\\n    return totalProd;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar dividePlayers = function(skill) {\\n    const map={}, target = skill.reduce((acc,curr)=>acc+curr)/(skill.length/2);\\n    for(const sk of skill) map[sk]=map[sk]+1||1; // building frequency map\\n\\n    let totalProd=0;\\n    for(const sk of skill){\\n        const currPairTarget=target-sk; // second member to find to form a pair\\n        if(map[currPairTarget]!==undefined){\\n            if(map[currPairTarget]>0){\\n                totalProd+=currPairTarget*sk;\\n                map[currPairTarget]--; map[sk]--;\\n            }\\n        }else{\\n            return -1;\\n        }\\n    }\\n    // check if there are some leftovers, it means we can not form all pairs\\n    if(Object.keys(map).find(k=>map[k]>0)) return -1;\\n    return totalProd;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670151,
                "title": "js-java-python-simple-and-clean-two-pointer-w-sort-o-n-log-n",
                "content": "# Approach\\nTo create pairs that all have the same skill, we can sort and pair the current leftmost and rightmost players. \\n\\nWe know that if they should all have the same skill, then they must have the skill of the initial left and right players, because of this we can do it in O(1) space without a map using our int skill variable.\\n\\nNow we simply check if the sum of the subsequent inner pairs have the same skill.\\n\\nIf they dont we return -1 immediately as this breaks the requirements.\\nIf they do have the same skill, we add the product of both players to the result.\\n\\nThen just bring the left and right pointers in and repeat until left > right.\\n\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n---\\n\\n\\n# Code\\n```javascript []\\nvar dividePlayers = function(skills) {\\n    let result = 0;\\n    skills.sort((a, b) => a - b);\\n\\n    let left = 0;\\n    let right = skills.length - 1;\\n\\n    let skill = skills[left] + skills[right];\\n    while (left <= right) {\\n        const sum = skills[left] + skills[right];\\n        if (sum != skill) return -1;\\n\\n        result += (skills[left] * skills[right]);\\n        left++;\\n        right--;\\n    }\\n\\n    return result;\\n};\\n```\\n```java []\\nclass Solution {\\n    public long dividePlayers(int[] skills) {\\n        long result = 0;\\n        Arrays.sort(skills);\\n\\n        int left = 0;\\n        int right = skills.length - 1;\\n\\n        int skill = skills[left] + skills[right];\\n        while (left <= right) {\\n            int sum = skills[left] + skills[right];\\n            if (sum != skill) return -1;\\n\\n            result += (skills[left] * skills[right]);\\n            left++;\\n            right--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def dividePlayers(self, skills: List[int]) -> int:\\n        result = 0\\n        skills.sort()\\n\\n        left = 0\\n        right = len(skills) - 1\\n\\n        skill = skills[left] + skills[right]\\n        while left <= right:\\n            sum = skills[left] + skills[right]\\n            if sum != skill:\\n                return -1\\n            \\n            result += (skills[left] * skills[right])\\n            left += 1\\n            right -= 1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```javascript []\\nvar dividePlayers = function(skills) {\\n    let result = 0;\\n    skills.sort((a, b) => a - b);\\n\\n    let left = 0;\\n    let right = skills.length - 1;\\n\\n    let skill = skills[left] + skills[right];\\n    while (left <= right) {\\n        const sum = skills[left] + skills[right];\\n        if (sum != skill) return -1;\\n\\n        result += (skills[left] * skills[right]);\\n        left++;\\n        right--;\\n    }\\n\\n    return result;\\n};\\n```\n```java []\\nclass Solution {\\n    public long dividePlayers(int[] skills) {\\n        long result = 0;\\n        Arrays.sort(skills);\\n\\n        int left = 0;\\n        int right = skills.length - 1;\\n\\n        int skill = skills[left] + skills[right];\\n        while (left <= right) {\\n            int sum = skills[left] + skills[right];\\n            if (sum != skill) return -1;\\n\\n            result += (skills[left] * skills[right]);\\n            left++;\\n            right--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def dividePlayers(self, skills: List[int]) -> int:\\n        result = 0\\n        skills.sort()\\n\\n        left = 0\\n        right = len(skills) - 1\\n\\n        skill = skills[left] + skills[right]\\n        while left <= right:\\n            sum = skills[left] + skills[right]\\n            if sum != skill:\\n                return -1\\n            \\n            result += (skills[left] * skills[right])\\n            left += 1\\n            right -= 1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668559,
                "title": "easy-solution-sorting-two-pointers",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int n=skill.length;\\n        int lo=0,hi=n-1;\\n        int prevSum=skill[lo]+skill[hi];\\n        List<List<Integer>> list=new ArrayList<>();\\n        while(lo<hi){\\n            List<Integer> team=new ArrayList<>();\\n            if(skill[lo]+skill[hi]==prevSum){\\n            team.add(skill[lo]);\\n            team.add(skill[hi]);\\n            list.add(team);\\n            lo++;\\n            hi--;\\n            }\\n            else\\n            break;\\n        }\\n\\n        if(list.size()<n/2)\\n        return -1;\\n\\n        long ans =0;\\n\\n        for(int i=0;i<n/2;i++){\\n            ans+=(list.get(i).get(0)*list.get(i).get(1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int n=skill.length;\\n        int lo=0,hi=n-1;\\n        int prevSum=skill[lo]+skill[hi];\\n        List<List<Integer>> list=new ArrayList<>();\\n        while(lo<hi){\\n            List<Integer> team=new ArrayList<>();\\n            if(skill[lo]+skill[hi]==prevSum){\\n            team.add(skill[lo]);\\n            team.add(skill[hi]);\\n            list.add(team);\\n            lo++;\\n            hi--;\\n            }\\n            else\\n            break;\\n        }\\n\\n        if(list.size()<n/2)\\n        return -1;\\n\\n        long ans =0;\\n\\n        for(int i=0;i<n/2;i++){\\n            ans+=(list.get(i).get(0)*list.get(i).get(1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658904,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long dividePlayers(int[] skills) {\\n        \\n        Arrays.sort(skills);\\n        int sum = skills[0] + skills[skills.length-1];\\n        int i = 0;\\n        int j = skills.length-1;\\n        long score = 0;\\n        while(i < j){\\n            if(skills[i]+skills[j] == sum){\\n                score += (skills[i]*skills[j]);\\n            }\\n            else{\\n                return -1;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return score;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skills) {\\n        \\n        Arrays.sort(skills);\\n        int sum = skills[0] + skills[skills.length-1];\\n        int i = 0;\\n        int j = skills.length-1;\\n        long score = 0;\\n        while(i < j){\\n            if(skills[i]+skills[j] == sum){\\n                score += (skills[i]*skills[j]);\\n            }\\n            else{\\n                return -1;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return score;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653896,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long ans = 0;\\n\\n        int sum = 0;\\n        for (int i : skill)\\n            sum += i;\\n\\n        int skillSum = sum/(skill.size()/2);\\n\\n        sort(skill.begin() , skill.end());\\n        int i=0 , j=skill.size()-1;\\n        while (i<j){\\n            if (skill[i]+skill[j] != skillSum)\\n                return -1;\\n\\n            ans += skill[i]*skill[j];   \\n            i++ , j--;\\n        }\\n   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long ans = 0;\\n\\n        int sum = 0;\\n        for (int i : skill)\\n            sum += i;\\n\\n        int skillSum = sum/(skill.size()/2);\\n\\n        sort(skill.begin() , skill.end());\\n        int i=0 , j=skill.size()-1;\\n        while (i<j){\\n            if (skill[i]+skill[j] != skillSum)\\n                return -1;\\n\\n            ans += skill[i]*skill[j];   \\n            i++ , j--;\\n        }\\n   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653344,
                "title": "easy-c-solution-beats-95-5-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        sort(skill.begin(),skill.end());\\n        long long k = 0;\\n        for(int  i = 0 ; i<skill.size()/2;i++){\\n            if(skill[i]+skill[skill.size()-i-1] ==skill[0]+skill[skill.size()-1] ){\\n                k = k + skill[i]*skill[skill.size()-i-1];\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        sort(skill.begin(),skill.end());\\n        long long k = 0;\\n        for(int  i = 0 ; i<skill.size()/2;i++){\\n            if(skill[i]+skill[skill.size()-i-1] ==skill[0]+skill[skill.size()-1] ){\\n                k = k + skill[i]*skill[skill.size()-i-1];\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645178,
                "title": "simple-easy-solution-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(), skill.end());\\n        int start = 0; \\n        int end = skill.size() - 1;\\n        int sum = skill[start] + skill[end];\\n        long long chemistry = 0;\\n        while(start < end){\\n            if(skill[start] + skill[end] != sum){ return -1;}\\n            chemistry += skill[start]*skill[end];\\n            start++;\\n            end--;\\n        }\\n        return chemistry;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(), skill.end());\\n        int start = 0; \\n        int end = skill.size() - 1;\\n        int sum = skill[start] + skill[end];\\n        long long chemistry = 0;\\n        while(start < end){\\n            if(skill[start] + skill[end] != sum){ return -1;}\\n            chemistry += skill[start]*skill[end];\\n            start++;\\n            end--;\\n        }\\n        return chemistry;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640302,
                "title": "very-easy-soln-beginner-friendly-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int sum=skill[0]+skill[skill.size()-1];\\n        long long ans=0;\\n        int s=0;\\n        int e=skill.size()-1;\\n        while(s<e){\\n            if(skill[s]+skill[e]==sum){\\n                ans=ans+skill[s]*skill[e];\\n                s++;\\n                e--;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int sum=skill[0]+skill[skill.size()-1];\\n        long long ans=0;\\n        int s=0;\\n        int e=skill.size()-1;\\n        while(s<e){\\n            if(skill[s]+skill[e]==sum){\\n                ans=ans+skill[s]*skill[e];\\n                s++;\\n                e--;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635338,
                "title": "divide-players-into-teams",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill=sorted(skill)\\n        lst=[]\\n        for i in range(len(skill)//2):\\n            lst.append([skill[i],skill[-i-1]])\\n        sim=0\\n        for i in lst:\\n            if sum(lst[0])==sum(i):\\n                sim+=(i[0]*i[1])\\n            else:\\n                return -1\\n        return sim        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        skill=sorted(skill)\\n        lst=[]\\n        for i in range(len(skill)//2):\\n            lst.append([skill[i],skill[-i-1]])\\n        sim=0\\n        for i in lst:\\n            if sum(lst[0])==sum(i):\\n                sim+=(i[0]*i[1])\\n            else:\\n                return -1\\n        return sim        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634586,
                "title": "hashmap-two-sum-variation-easy-understanding-two-pointers",
                "content": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        \\n        long totalSkill = 0L;\\n        \\n        for(int i = 0 ; i < skill.length ; i++){\\n            totalSkill+=skill[i];\\n        }\\n        long team  = skill.length/2;\\n        \\n        if(totalSkill%team != 0 ){\\n            return -1L;\\n        }\\n        \\n        long[][] pairs = new long[(int)team][2];\\n        \\n        //two sum;\\n        long target = totalSkill/team;\\n        //System.out.println(target);\\n        Map<Long,Integer> map = new HashMap<>();\\n        int index = 0;\\n        for(int i = 0 ; i < skill.length ; i++){\\n            \\n            long leftVal = target - skill[i];\\n            if(map.containsKey(leftVal)){\\n                //System.out.println(leftVal + \" : \" +map.get(leftVal));\\n                //if the other part is there then take that and remove the count of other part as symbol of already used \\n                pairs[index] = new long[]{leftVal,skill[i]};\\n                if(map.get(leftVal) == 1){\\n                    map.remove((long)leftVal);\\n                }else{\\n                   map.put(leftVal,map.get(leftVal) - 1); \\n                }\\n                index++;\\n            }else{\\n                map.put((long)skill[i],map.getOrDefault((long)skill[i],0)+1);\\n            }\\n            \\n        }\\n        \\n        long ans = 0 ;\\n    \\n        for(long[] eachPair : pairs){\\n           // System.out.println(eachPair[0]+\" \"+eachPair[1]);\\n            ans+=(eachPair[0]*eachPair[1]);\\n            if(eachPair[0] ==0 && eachPair[1] ==0){\\n                return -1L;\\n            }\\n        }\\n        \\n        return ans == 0 ? -1 : ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        \\n        long totalSkill = 0L;\\n        \\n        for(int i = 0 ; i < skill.length ; i++){\\n            totalSkill+=skill[i];\\n        }\\n        long team  = skill.length/2;\\n        \\n        if(totalSkill%team != 0 ){\\n            return -1L;\\n        }\\n        \\n        long[][] pairs = new long[(int)team][2];\\n        \\n        //two sum;\\n        long target = totalSkill/team;\\n        //System.out.println(target);\\n        Map<Long,Integer> map = new HashMap<>();\\n        int index = 0;\\n        for(int i = 0 ; i < skill.length ; i++){\\n            \\n            long leftVal = target - skill[i];\\n            if(map.containsKey(leftVal)){\\n                //System.out.println(leftVal + \" : \" +map.get(leftVal));\\n                //if the other part is there then take that and remove the count of other part as symbol of already used \\n                pairs[index] = new long[]{leftVal,skill[i]};\\n                if(map.get(leftVal) == 1){\\n                    map.remove((long)leftVal);\\n                }else{\\n                   map.put(leftVal,map.get(leftVal) - 1); \\n                }\\n                index++;\\n            }else{\\n                map.put((long)skill[i],map.getOrDefault((long)skill[i],0)+1);\\n            }\\n            \\n        }\\n        \\n        long ans = 0 ;\\n    \\n        for(long[] eachPair : pairs){\\n           // System.out.println(eachPair[0]+\" \"+eachPair[1]);\\n            ans+=(eachPair[0]*eachPair[1]);\\n            if(eachPair[0] ==0 && eachPair[1] ==0){\\n                return -1L;\\n            }\\n        }\\n        \\n        return ans == 0 ? -1 : ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631728,
                "title": "c-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        \\n        long long prod=0;\\n        int common=skill[0]+skill[skill.size()-1];\\n        \\n        if(skill.size()==2)return skill[0]*skill[1];\\n        int n=skill.size()-1;\\n        \\n        for(int i=0;i<skill.size()/2;i++){\\n            \\n            if(skill[i]+skill[n-i]!=common){\\n                return -1;\\n            }\\n            else{\\n                prod+=skill[i]*skill[n-i];\\n            }\\n            \\n        }\\n        \\n        return prod;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        \\n        long long prod=0;\\n        int common=skill[0]+skill[skill.size()-1];\\n        \\n        if(skill.size()==2)return skill[0]*skill[1];\\n        int n=skill.size()-1;\\n        \\n        for(int i=0;i<skill.size()/2;i++){\\n            \\n            if(skill[i]+skill[n-i]!=common){\\n                return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3628565,
                "title": "sorting-solution-java",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        long ans=0;\\n        int[] teams=new int[skill.length/2];\\n        int start=0;\\n        int end=skill.length-1;\\n        int i=0;\\n        int teamStrength=skill[0]+skill[skill.length-1];\\n        while(start<end){\\n            teams[i]=skill[start]*skill[end];\\n            if(skill[start]+skill[end]!=teamStrength){\\n                return -1;\\n            }\\n            ans+=teams[i];\\n            start++;\\n            end--;\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        long ans=0;\\n        int[] teams=new int[skill.length/2];\\n        int start=0;\\n        int end=skill.length-1;\\n        int i=0;\\n        int teamStrength=skill[0]+skill[skill.length-1];\\n        while(start<end){\\n            teams[i]=skill[start]*skill[end];\\n            if(skill[start]+skill[end]!=teamStrength){\\n                return -1;\\n            }\\n            ans+=teams[i];\\n            start++;\\n            end--;\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625166,
                "title": "c-solution",
                "content": "### ****Intuition****\\n**we have to create n/2 teams of size 2 so we need to use every number in array**.\\n\\n# Approach\\n**the sum of skills of eah team(elements of each team) should be equal.so if we sort th array and start adding product of skill of each team in our ans. we should keep in mind that the below condition is true.**\\n\\n## **skill[i] + skill[j] != skill[i - 1] + skill[j + 1]**\\n\\n\\n\\n\\nif this conition is false then we can\\'t form n/2 teams.\\n\\n\\n# **please upvote**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n=skill.size();\\n        long long ans=0;\\n        int i=(n/2)-1;\\n        int j=n/2;\\n        while(i>=0 && j<n){\\n            if(i>0 && j<n-1 && skill[i]+skill[j]!=skill[i-1]+skill[j+1])\\n            return -1;\\n\\n            ans+=skill[i]*skill[j];\\n            i--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n=skill.size();\\n        long long ans=0;\\n        int i=(n/2)-1;\\n        int j=n/2;\\n        while(i>=0 && j<n){\\n            if(i>0 && j<n-1 && skill[i]+skill[j]!=skill[i-1]+skill[j+1])\\n            return -1;\\n\\n            ans+=skill[i]*skill[j];\\n            i--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613171,
                "title": "divide-players-into-teams-of-equal-skill",
                "content": "```\\n        ans = 0\\n        n = len(skill)\\n        skill.sort()\\n        skill_sum = skill[0] + skill[-1]\\n        if n <= 2:\\n            ans = skill[0] * skill[1]\\n        else:\\n            for i in range(0,n//2):\\n                if (skill[i]+skill[-i-1]) != skill_sum:\\n                    ans = -1\\n                    break\\n                else:\\n                    ans += (skill[i] * skill[-i-1])\\n        return ans\\n```\\n\\n#Please ask in case of any queries",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n        ans = 0\\n        n = len(skill)\\n        skill.sort()\\n        skill_sum = skill[0] + skill[-1]\\n        if n <= 2:\\n            ans = skill[0] * skill[1]\\n        else:\\n            for i in range(0,n//2):\\n                if (skill[i]+skill[-i-1]) != skill_sum:\\n                    ans = -1\\n                    break\\n                else:\\n                    ans += (skill[i] * skill[-i-1])\\n        return ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612034,
                "title": "c-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n        sort(skill.begin(),skill.end());\\n        int s=0,e=skill.size()-1;\\n        long long ans = 0;\\n        vector<long long> v;\\n        while (s <= e)\\n        {\\n            v.push_back(skill[s] + skill[e]); \\n            ans += (skill[s++]*skill[e--]);\\n        }\\n\\n        for (int i = 1; i < v.size(); i++)\\n        {\\n            if(v[i - 1]!=v[i]){\\n            return -1;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) \\n    {\\n        sort(skill.begin(),skill.end());\\n        int s=0,e=skill.size()-1;\\n        long long ans = 0;\\n        vector<long long> v;\\n        while (s <= e)\\n        {\\n            v.push_back(skill[s] + skill[e]); \\n            ans += (skill[s++]*skill[e--]);\\n        }\\n\\n        for (int i = 1; i < v.size(); i++)\\n        {\\n            if(v[i - 1]!=v[i]){\\n            return -1;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590870,
                "title": "using-vector-of-pair-most-simplified-and-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin() , skill.end());\\n        vector<pair<int , int>>vp;\\n        int n = skill.size();\\n        int s = 0;\\n        int e = n-1;\\n        long long ans = 0;\\n        vector<int>finalAns;\\n        while(s<e)\\n        {\\n           vp.push_back(make_pair(skill[s++] , skill[e--]));\\n        }\\n        int targetSum = vp[0].first + vp[0].second;\\n        for(auto &pair : vp)\\n        {\\n            int sum = pair.first + pair.second;\\n            if(sum!=targetSum) return -1;\\n            finalAns.push_back(pair.first*pair.second);\\n        }\\n        for(auto it : finalAns) ans=ans+it;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin() , skill.end());\\n        vector<pair<int , int>>vp;\\n        int n = skill.size();\\n        int s = 0;\\n        int e = n-1;\\n        long long ans = 0;\\n        vector<int>finalAns;\\n        while(s<e)\\n        {\\n           vp.push_back(make_pair(skill[s++] , skill[e--]));\\n        }\\n        int targetSum = vp[0].first + vp[0].second;\\n        for(auto &pair : vp)\\n        {\\n            int sum = pair.first + pair.second;\\n            if(sum!=targetSum) return -1;\\n            finalAns.push_back(pair.first*pair.second);\\n        }\\n        for(auto it : finalAns) ans=ans+it;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582355,
                "title": "java-sort-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        if (skill.length == 1) return -1;\\n        if (skill.length == 2) return skill[0] * skill[1];\\n\\n        Arrays.sort(skill);\\n        long chemistry = 0;\\n\\n        int lo = 0, hi = skill.length - 1;\\n        int targetVal = skill[lo] + skill[hi];\\n\\n        while (lo < hi) {\\n            if (skill[lo] + skill[hi] != targetVal) return -1;\\n\\n            chemistry = chemistry + (skill[lo] * skill[hi]);\\n            lo++;\\n            hi--;\\n        }\\n\\n        return chemistry;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        if (skill.length == 1) return -1;\\n        if (skill.length == 2) return skill[0] * skill[1];\\n\\n        Arrays.sort(skill);\\n        long chemistry = 0;\\n\\n        int lo = 0, hi = skill.length - 1;\\n        int targetVal = skill[lo] + skill[hi];\\n\\n        while (lo < hi) {\\n            if (skill[lo] + skill[hi] != targetVal) return -1;\\n\\n            chemistry = chemistry + (skill[lo] * skill[hi]);\\n            lo++;\\n            hi--;\\n        }\\n\\n        return chemistry;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554995,
                "title": "python-easy-solution-sorting",
                "content": "# Complexity\\n- Time complexity:\\n    O(nlogn)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        res=0\\n        teams=len(skill)//2\\n        perSum=sum(skill)//teams\\n        skill.sort()\\n        for i in range(len(skill)//2):\\n            if skill[i]+skill[len(skill)-i-1]!=perSum:\\n                return -1\\n            else:\\n                res+=skill[i]*skill[len(skill)-i-1]\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        res=0\\n        teams=len(skill)//2\\n        perSum=sum(skill)//teams\\n        skill.sort()\\n        for i in range(len(skill)//2):\\n            if skill[i]+skill[len(skill)-i-1]!=perSum:\\n                return -1\\n            else:\\n                res+=skill[i]*skill[len(skill)-i-1]\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543276,
                "title": "most-simple-java-solution",
                "content": "\\n# Approach\\n* all number parts are have to do same summation value.\\n* it does mean biggest number and smallest numbers summation have to exists another combination.\\n* So, do sorting number array.\\n* get sum of biggest and smallest number.\\n* and find them. \\n* if there is no same value of sum of bigest&smallest return -1;\\n* if exists, add to result.\\n\\n# Complexity\\n- Time complexity:\\n  - sorting : O(n log n)\\n  - searching : O(log n/2)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n\\n        int num = skill[0] + skill[skill.length - 1];\\n        long result = skill[0] * skill[skill.length - 1];\\n        for(int i = 1 ; i < skill.length / 2 ; i++) {\\n            if(num == skill[i] + skill[skill.length - i - 1]) {\\n                result += skill[i] * skill[skill.length - i - 1];\\n            }else {\\n                return -1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n\\n        int num = skill[0] + skill[skill.length - 1];\\n        long result = skill[0] * skill[skill.length - 1];\\n        for(int i = 1 ; i < skill.length / 2 ; i++) {\\n            if(num == skill[i] + skill[skill.length - i - 1]) {\\n                result += skill[i] * skill[skill.length - i - 1];\\n            }else {\\n                return -1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535065,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        vector<int> v;\\n        long long ans=0;\\n        for(int i=0;i<skill.size()/2;i++){\\n            v.push_back(skill[i] + skill[skill.size()-1-i]);\\n        }\\n        sort(v.begin(),v.end());\\n        if(v[0]==v[v.size()-1]){\\n            for(int i=0;i<skill.size()/2;i++){\\n                ans= ans+ skill[i]*skill[skill.size()-1-i];\\n            }\\n        }\\n        if(ans!=0){\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        vector<int> v;\\n        long long ans=0;\\n        for(int i=0;i<skill.size()/2;i++){\\n            v.push_back(skill[i] + skill[skill.size()-1-i]);\\n        }\\n        sort(v.begin(),v.end());\\n        if(v[0]==v[v.size()-1]){\\n            for(int i=0;i<skill.size()/2;i++){\\n                ans= ans+ skill[i]*skill[skill.size()-1-i];\\n            }\\n        }\\n        if(ans!=0){\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530763,
                "title": "two-java-solutions-o-n-and-o-nlogn-easy-to-understand-fully-explained-beginner-friendly",
                "content": "# Method 1: Sorting + 2 Pointer\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first glance, since we only have to make teams of two, the problem resembles the \"Two Sum\" problem. We sort the array and run two pointers, one from the end and one from the front, and since the sum of all contemporaries have to be equal, we just check if it is and add their product to the final sum\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the array\\n- run pointer left from 0 to right\\n- run pointer right from end to left\\n- multiply skill[left] and skill[right] and add it to answer\\n- if skill[left] + skill[right] not equal to skill[0]+skill[n-1] return -1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int left = 0, right = skill.length-1;\\n        int sum = skill[left]+skill[right];\\n        long answer = 0;\\n        while(left<right){\\n            if(skill[left]+skill[right]!=sum){\\n                return -1;\\n            }\\n            answer+=skill[left]*skill[right];\\n            left++;\\n            right--;\\n        }\\n        return answer;\\n    }\\n}\\n```\\n# Method 2: Array as Hashmap\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter getting the above solution, we see that the sum of team skill will always be min(skill)+max(skill). after calculating that, we can simply run a loop over the array and check if all pairs add up to totalSkill. we add product of skill[i] and totalSkill-skill[i] to answer and since it means that all pairs have been added twice, we divide it by 2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. find min and max of array, totalSkill = min+max\\n2. create frequency array of length 1001 since 1<=skill[i]<=1000\\n3. iterate over the array and\\n    - add totalSkill-skill to element at index skill\\n    - subtract skill from element at index totalSkill-skill\\n    - add product of both of these to answer.\\n4. now, if all pairs are present, every element of frequency array will be 0. Otherwise return -1\\n5. return answer/2.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0;i<skill.length;i++){\\n            min = Math.min(min,skill[i]);\\n            max = Math.max(max,skill[i]);\\n        }\\n\\n        int totalSkill = min+max;\\n        int[] freq = new int[1001];\\n        long answer = 0;\\n\\n        for(int i = 0;i<skill.length;i++){\\n            freq[skill[i]] += totalSkill-skill[i];\\n            freq[totalSkill-skill[i]] -=skill[i];\\n            answer+=(totalSkill-skill[i])*skill[i];\\n        }\\n\\n        for(int i = 0;i<skill.length;i++){\\n            if(freq[skill[i]]!=0){\\n                return -1;\\n            }\\n        }\\n\\n        return answer/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int left = 0, right = skill.length-1;\\n        int sum = skill[left]+skill[right];\\n        long answer = 0;\\n        while(left<right){\\n            if(skill[left]+skill[right]!=sum){\\n                return -1;\\n            }\\n            answer+=skill[left]*skill[right];\\n            left++;\\n            right--;\\n        }\\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long dividePlayers(int[] skill) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0;i<skill.length;i++){\\n            min = Math.min(min,skill[i]);\\n            max = Math.max(max,skill[i]);\\n        }\\n\\n        int totalSkill = min+max;\\n        int[] freq = new int[1001];\\n        long answer = 0;\\n\\n        for(int i = 0;i<skill.length;i++){\\n            freq[skill[i]] += totalSkill-skill[i];\\n            freq[totalSkill-skill[i]] -=skill[i];\\n            answer+=(totalSkill-skill[i])*skill[i];\\n        }\\n\\n        for(int i = 0;i<skill.length;i++){\\n            if(freq[skill[i]]!=0){\\n                return -1;\\n            }\\n        }\\n\\n        return answer/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519541,
                "title": "two-pointer-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long sum=accumulate(skill.begin(),skill.end(),0);\\n        int sz=skill.size();\\n        int n=sz/2;\\n        if(sum%n!=0) return -1;\\n        int target=sum/n;\\n        int cnt=0;\\n        long long ans=0;\\n        sort(skill.begin(),skill.end());\\n        int lo=0,hi=sz-1;\\n        while(lo < hi)\\n        {\\n            int s=skill[lo]+skill[hi];\\n            if(s==target)\\n            {\\n                cnt++;\\n                \\n                ans+=(skill[lo]*1ll*skill[hi]);\\n                lo++;\\n                hi--;\\n\\n            }else if(s > target)\\n            {\\n                hi--;\\n            }else{\\n                lo++;\\n            }\\n        }\\n        return cnt==n ?ans :-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        long long sum=accumulate(skill.begin(),skill.end(),0);\\n        int sz=skill.size();\\n        int n=sz/2;\\n        if(sum%n!=0) return -1;\\n        int target=sum/n;\\n        int cnt=0;\\n        long long ans=0;\\n        sort(skill.begin(),skill.end());\\n        int lo=0,hi=sz-1;\\n        while(lo < hi)\\n        {\\n            int s=skill[lo]+skill[hi];\\n            if(s==target)\\n            {\\n                cnt++;\\n                \\n                ans+=(skill[lo]*1ll*skill[hi]);\\n                lo++;\\n                hi--;\\n\\n            }else if(s > target)\\n            {\\n                hi--;\\n            }else{\\n                lo++;\\n            }\\n        }\\n        return cnt==n ?ans :-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507340,
                "title": "c-solution-sorting-the-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int sum = 0;\\n        for (auto& num : skill) {\\n            sum += num;\\n        }\\n        if (sum % int(skill.size() / 2) != 0) return -1;\\n        int team_sum = sum / int(skill.size() / 2);\\n        std::sort(skill.begin(), skill.end());\\n        long long res = 0;\\n        for (int i = 0; i < int(skill.size() / 2); i++) {\\n            if (skill[i] + skill[skill.size() - 1 -i] == team_sum) {\\n                res += skill[i] * skill[skill.size() - 1 -i];\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int sum = 0;\\n        for (auto& num : skill) {\\n            sum += num;\\n        }\\n        if (sum % int(skill.size() / 2) != 0) return -1;\\n        int team_sum = sum / int(skill.size() / 2);\\n        std::sort(skill.begin(), skill.end());\\n        long long res = 0;\\n        for (int i = 0; i < int(skill.size() / 2); i++) {\\n            if (skill[i] + skill[skill.size() - 1 -i] == team_sum) {\\n                res += skill[i] * skill[skill.size() - 1 -i];\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495745,
                "title": "python-easy-solution-with-96-beat-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def dividePlayers(self, skill):\\n        \"\"\"\\n        :type skill: List[int]\\n        :rtype: int\\n        \"\"\"\\n        skill.sort()\\n\\n        result=[]\\n        prod=[]\\n        for i in range(len(skill)//2):\\n            \\n            result.append((skill[i]+skill[-i-1]))\\n            prod.append((skill[i]*skill[-i-1]))\\n\\n        if len(set(result))==1:\\n            return sum(prod)\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def dividePlayers(self, skill):\\n        \"\"\"\\n        :type skill: List[int]\\n        :rtype: int\\n        \"\"\"\\n        skill.sort()\\n\\n        result=[]\\n        prod=[]\\n        for i in range(len(skill)//2):\\n            \\n            result.append((skill[i]+skill[-i-1]))\\n            prod.append((skill[i]*skill[-i-1]))\\n\\n        if len(set(result))==1:\\n            return sum(prod)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484184,
                "title": "easy-sorting",
                "content": "# Intuition\\n1. Sort skill array\\n2. add extreme left to extreme right, arr[0]+arr[n-1], arr[1]+arr[n-2]..... all these sums should be equal, if not its not possible, return 1\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        if len(skill)%2==0:\\n            skill.sort()\\n            ans = 0\\n            last_sum=0\\n            for i in range(len(skill)//2):\\n                ans+=skill[i]*skill[-1-i]\\n                if last_sum>0:\\n                    if last_sum != skill[i]+skill[-1-i]:\\n                        return -1\\n                last_sum=skill[i]+skill[-1-i]\\n\\n            return ans\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def dividePlayers(self, skill: List[int]) -> int:\\n        if len(skill)%2==0:\\n            skill.sort()\\n            ans = 0\\n            last_sum=0\\n            for i in range(len(skill)//2):\\n                ans+=skill[i]*skill[-1-i]\\n                if last_sum>0:\\n                    if last_sum != skill[i]+skill[-1-i]:\\n                        return -1\\n                last_sum=skill[i]+skill[-1-i]\\n\\n            return ans\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481562,
                "title": "simple-golang-solution-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to divide players with different skill levels into two teams in such a way that the sum of skill levels of the players in each team is equal, and the product of the skill levels of the players in each team is maximum. A naive approach would be to generate all possible combinations of teams and check the sum and product for each of them. However, this approach would be inefficient for large inputs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve this problem using a greedy approach. First, we calculate the total sum of skill levels of all players and divide it by the number of teams to get the target team skill level. If the total sum is not divisible by the number of teams, we cannot form the teams and we return -1.\\n\\nNext, we sort the skill levels in decreasing order and use two pointers to form the teams. We start with the two highest skill level players and keep moving the pointers towards each other while checking if the sum of their skill levels is equal to the target team skill level. If it is, we add the product of their skill levels to the team chemistry, mark them as used, and decrement the frequency of their skill levels in an array. If the sum is less than the target team skill level, we move the left pointer one position to the right. If the sum is greater than the target team skill level, we move the right pointer one position to the left. We continue this process until we have formed all the teams.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the function is O(n log n), where n is the number of players. This is because we first sort the array of skill levels, which takes O(n log n) time, and then we use two pointers to traverse the array, which takes O(n) time in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the function is O(1), as we use a constant amount of extra space to store variables such as the total sum of skill levels, team chemistry, and the two pointers. We also use an array of size 100001 to store the frequency of skill levels, but since the maximum skill level is given as 100000, the size of this array is also constant.\\n\\n# Code\\n```\\nfunc dividePlayers(skill []int) int64 {\\n    totalSkills := 0\\n    chemistry :=0\\n    count := 0\\n    freq := make([]int, 100001)\\n    for _, v := range skill {\\n        totalSkills += v\\n        freq[v]++\\n    }\\n    n := len(skill) / 2\\n    if totalSkills%n != 0 {\\n        return -1\\n    }\\n    if n == 1 {\\n        return int64(skill[0] * skill[1])\\n    }\\n    teamSkills := totalSkills / n\\n    sort.Sort(sort.Reverse(sort.IntSlice(skill)))\\n    used := make([]bool, len(skill))\\n    for i, j := 0, len(skill)-1; i < j; {\\n        if used[i] {\\n            i++\\n            continue\\n        }\\n        if used[j] {\\n            j--\\n            continue\\n        }\\n        if skill[i]+skill[j] == teamSkills {\\n            chemistry += skill[i] * skill[j]\\n            count++\\n            used[i] = true\\n            used[j] = true\\n            freq[skill[i]]--\\n            freq[skill[j]]--\\n        } else if skill[i]+skill[j] < teamSkills {\\n            j--\\n        } else {\\n            i++\\n        }\\n        if count == n {\\n            break\\n        }\\n    }\\n    if chemistry == 0 || count != n {\\n        return -1\\n    }\\n    return int64(chemistry)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc dividePlayers(skill []int) int64 {\\n    totalSkills := 0\\n    chemistry :=0\\n    count := 0\\n    freq := make([]int, 100001)\\n    for _, v := range skill {\\n        totalSkills += v\\n        freq[v]++\\n    }\\n    n := len(skill) / 2\\n    if totalSkills%n != 0 {\\n        return -1\\n    }\\n    if n == 1 {\\n        return int64(skill[0] * skill[1])\\n    }\\n    teamSkills := totalSkills / n\\n    sort.Sort(sort.Reverse(sort.IntSlice(skill)))\\n    used := make([]bool, len(skill))\\n    for i, j := 0, len(skill)-1; i < j; {\\n        if used[i] {\\n            i++\\n            continue\\n        }\\n        if used[j] {\\n            j--\\n            continue\\n        }\\n        if skill[i]+skill[j] == teamSkills {\\n            chemistry += skill[i] * skill[j]\\n            count++\\n            used[i] = true\\n            used[j] = true\\n            freq[skill[i]]--\\n            freq[skill[j]]--\\n        } else if skill[i]+skill[j] < teamSkills {\\n            j--\\n        } else {\\n            i++\\n        }\\n        if count == n {\\n            break\\n        }\\n    }\\n    if chemistry == 0 || count != n {\\n        return -1\\n    }\\n    return int64(chemistry)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3474213,
                "title": "java-simple-explained",
                "content": "The sorted array should become an arithmetic progression like this : \\n`1,2,3,4,5,6`\\nBecause, arithmetic progression have a property that the sum of 1st and nth is the same as of 2nd and (n-1)th elements. \\ne.g.: `1+6=2+5=3+4`\\nso you go through the sorted array and check that it is the same sum all the time for 1 and n, 2 and n-1 and so forth. if it\\'s not - return -1. if it is - calculate result due course and return it afterwards. \\nhope it helps\\n```\\npublic long dividePlayers(int[] arr) {\\n\\tArrays.sort(arr);\\n\\tint i=0,j=arr.length-1; long res=0;\\n\\tvar expected = arr[0]+arr[arr.length-1];\\n\\twhile(i<j){\\n\\t\\tvar sum = arr[i]+arr[j];\\n\\t\\tif (sum!=expected) return -1;\\n\\t\\tres+=arr[i]*(long)arr[j];\\n\\t\\ti++;j--;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic long dividePlayers(int[] arr) {\\n\\tArrays.sort(arr);\\n\\tint i=0,j=arr.length-1; long res=0;\\n\\tvar expected = arr[0]+arr[arr.length-1];\\n\\twhile(i<j){\\n\\t\\tvar sum = arr[i]+arr[j];\\n\\t\\tif (sum!=expected) return -1;\\n\\t\\tres+=arr[i]*(long)arr[j];\\n\\t\\ti++;j--;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3456677,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long a=0;\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int size=skill[0]+skill[skill.length-1];\\n        for(int i=0;i<skill.length/2;i++){\\n            if(size==skill[i]+skill[skill.length-1-i])\\n            a+=skill[i]*skill[skill.length-1-i];\\n            else return -1;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    long a=0;\\n    public long dividePlayers(int[] skill) {\\n        Arrays.sort(skill);\\n        int size=skill[0]+skill[skill.length-1];\\n        for(int i=0;i<skill.length/2;i++){\\n            if(size==skill[i]+skill[skill.length-1-i])\\n            a+=skill[i]*skill[skill.length-1-i];\\n            else return -1;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1712222,
                "content": [
                    {
                        "username": "elsheraey",
                        "content": "This should be easy..."
                    },
                    {
                        "username": "karkisa",
                        "content": "maybe.. \\nIf you go the hash table way it gets cumbersome and a little tricky with edge cases.\\nTwo pointer solution is very simple if it strikes under pressure."
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach :\\n\\n1. sort the array\\n\\n2. As skill of each team is to be equal, we take target skill value to be smallest+largest in the array\\n\\n3. We pick the smallest element in the array and add the largest, check if this is equal to the target, if not, we immediately quit the program as we return -1\\nElse we add the product of the team into a variable\\n\\n4. return the variable "
                    },
                    {
                        "username": "asthana1011",
                        "content": "Why does the target skill need to be skill[0] + skill[n-1] after sorting i.e smallest+largest ??"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the return type is `long` guys. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bb20a811-2c14-4578-aff0-476676818ea9_1670764292.2877312.png)"
                    },
                    {
                        "username": "dimdos95",
                        "content": "https://www.youtube.com/watch?v=xQuYr9DNMbQ&ab_channel=YoucodewithDmytro"
                    },
                    {
                        "username": "Khattar1024",
                        "content": "WHAT IS THE PROBLEM IN THIS CODE  \\n\\nlong long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n = skill.size();\\n        long long ans = {-1};\\n        if(n == 2){\\n            ans = skill[0] * skill[1];\\n            return ans;\\n        }\\n        vector<pair<int,int>> v;\\n        int i =0;\\n        int r = n-1;\\n        int temp = skill[i] + skill[r];\\n        while(i<r){\\n            if(skill[i] + skill[r] != temp){\\n                return ans;\\n            }else{\\n                v.push_back({skill[i],skill[r]});\\n                i++;\\n                r--;\\n            }\\n        }\\n        for(auto it : v){\\n            ans += it.first * it.second;\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shamikh05",
                        "content": "You have initialized ans with -1. Initialize it with 0 and inside (skill[i] + skill[r] != temp) if block remove return ans with return -1. Make these couple of changes and your code will be accepted."
                    }
                ]
            },
            {
                "id": 1705326,
                "content": [
                    {
                        "username": "elsheraey",
                        "content": "This should be easy..."
                    },
                    {
                        "username": "karkisa",
                        "content": "maybe.. \\nIf you go the hash table way it gets cumbersome and a little tricky with edge cases.\\nTwo pointer solution is very simple if it strikes under pressure."
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach :\\n\\n1. sort the array\\n\\n2. As skill of each team is to be equal, we take target skill value to be smallest+largest in the array\\n\\n3. We pick the smallest element in the array and add the largest, check if this is equal to the target, if not, we immediately quit the program as we return -1\\nElse we add the product of the team into a variable\\n\\n4. return the variable "
                    },
                    {
                        "username": "asthana1011",
                        "content": "Why does the target skill need to be skill[0] + skill[n-1] after sorting i.e smallest+largest ??"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the return type is `long` guys. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bb20a811-2c14-4578-aff0-476676818ea9_1670764292.2877312.png)"
                    },
                    {
                        "username": "dimdos95",
                        "content": "https://www.youtube.com/watch?v=xQuYr9DNMbQ&ab_channel=YoucodewithDmytro"
                    },
                    {
                        "username": "Khattar1024",
                        "content": "WHAT IS THE PROBLEM IN THIS CODE  \\n\\nlong long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n = skill.size();\\n        long long ans = {-1};\\n        if(n == 2){\\n            ans = skill[0] * skill[1];\\n            return ans;\\n        }\\n        vector<pair<int,int>> v;\\n        int i =0;\\n        int r = n-1;\\n        int temp = skill[i] + skill[r];\\n        while(i<r){\\n            if(skill[i] + skill[r] != temp){\\n                return ans;\\n            }else{\\n                v.push_back({skill[i],skill[r]});\\n                i++;\\n                r--;\\n            }\\n        }\\n        for(auto it : v){\\n            ans += it.first * it.second;\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shamikh05",
                        "content": "You have initialized ans with -1. Initialize it with 0 and inside (skill[i] + skill[r] != temp) if block remove return ans with return -1. Make these couple of changes and your code will be accepted."
                    }
                ]
            },
            {
                "id": 2048574,
                "content": [
                    {
                        "username": "elsheraey",
                        "content": "This should be easy..."
                    },
                    {
                        "username": "karkisa",
                        "content": "maybe.. \\nIf you go the hash table way it gets cumbersome and a little tricky with edge cases.\\nTwo pointer solution is very simple if it strikes under pressure."
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach :\\n\\n1. sort the array\\n\\n2. As skill of each team is to be equal, we take target skill value to be smallest+largest in the array\\n\\n3. We pick the smallest element in the array and add the largest, check if this is equal to the target, if not, we immediately quit the program as we return -1\\nElse we add the product of the team into a variable\\n\\n4. return the variable "
                    },
                    {
                        "username": "asthana1011",
                        "content": "Why does the target skill need to be skill[0] + skill[n-1] after sorting i.e smallest+largest ??"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the return type is `long` guys. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bb20a811-2c14-4578-aff0-476676818ea9_1670764292.2877312.png)"
                    },
                    {
                        "username": "dimdos95",
                        "content": "https://www.youtube.com/watch?v=xQuYr9DNMbQ&ab_channel=YoucodewithDmytro"
                    },
                    {
                        "username": "Khattar1024",
                        "content": "WHAT IS THE PROBLEM IN THIS CODE  \\n\\nlong long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n = skill.size();\\n        long long ans = {-1};\\n        if(n == 2){\\n            ans = skill[0] * skill[1];\\n            return ans;\\n        }\\n        vector<pair<int,int>> v;\\n        int i =0;\\n        int r = n-1;\\n        int temp = skill[i] + skill[r];\\n        while(i<r){\\n            if(skill[i] + skill[r] != temp){\\n                return ans;\\n            }else{\\n                v.push_back({skill[i],skill[r]});\\n                i++;\\n                r--;\\n            }\\n        }\\n        for(auto it : v){\\n            ans += it.first * it.second;\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shamikh05",
                        "content": "You have initialized ans with -1. Initialize it with 0 and inside (skill[i] + skill[r] != temp) if block remove return ans with return -1. Make these couple of changes and your code will be accepted."
                    }
                ]
            },
            {
                "id": 1713291,
                "content": [
                    {
                        "username": "elsheraey",
                        "content": "This should be easy..."
                    },
                    {
                        "username": "karkisa",
                        "content": "maybe.. \\nIf you go the hash table way it gets cumbersome and a little tricky with edge cases.\\nTwo pointer solution is very simple if it strikes under pressure."
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach :\\n\\n1. sort the array\\n\\n2. As skill of each team is to be equal, we take target skill value to be smallest+largest in the array\\n\\n3. We pick the smallest element in the array and add the largest, check if this is equal to the target, if not, we immediately quit the program as we return -1\\nElse we add the product of the team into a variable\\n\\n4. return the variable "
                    },
                    {
                        "username": "asthana1011",
                        "content": "Why does the target skill need to be skill[0] + skill[n-1] after sorting i.e smallest+largest ??"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the return type is `long` guys. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bb20a811-2c14-4578-aff0-476676818ea9_1670764292.2877312.png)"
                    },
                    {
                        "username": "dimdos95",
                        "content": "https://www.youtube.com/watch?v=xQuYr9DNMbQ&ab_channel=YoucodewithDmytro"
                    },
                    {
                        "username": "Khattar1024",
                        "content": "WHAT IS THE PROBLEM IN THIS CODE  \\n\\nlong long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n = skill.size();\\n        long long ans = {-1};\\n        if(n == 2){\\n            ans = skill[0] * skill[1];\\n            return ans;\\n        }\\n        vector<pair<int,int>> v;\\n        int i =0;\\n        int r = n-1;\\n        int temp = skill[i] + skill[r];\\n        while(i<r){\\n            if(skill[i] + skill[r] != temp){\\n                return ans;\\n            }else{\\n                v.push_back({skill[i],skill[r]});\\n                i++;\\n                r--;\\n            }\\n        }\\n        for(auto it : v){\\n            ans += it.first * it.second;\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shamikh05",
                        "content": "You have initialized ans with -1. Initialize it with 0 and inside (skill[i] + skill[r] != temp) if block remove return ans with return -1. Make these couple of changes and your code will be accepted."
                    }
                ]
            },
            {
                "id": 1710980,
                "content": [
                    {
                        "username": "elsheraey",
                        "content": "This should be easy..."
                    },
                    {
                        "username": "karkisa",
                        "content": "maybe.. \\nIf you go the hash table way it gets cumbersome and a little tricky with edge cases.\\nTwo pointer solution is very simple if it strikes under pressure."
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach :\\n\\n1. sort the array\\n\\n2. As skill of each team is to be equal, we take target skill value to be smallest+largest in the array\\n\\n3. We pick the smallest element in the array and add the largest, check if this is equal to the target, if not, we immediately quit the program as we return -1\\nElse we add the product of the team into a variable\\n\\n4. return the variable "
                    },
                    {
                        "username": "asthana1011",
                        "content": "Why does the target skill need to be skill[0] + skill[n-1] after sorting i.e smallest+largest ??"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the return type is `long` guys. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bb20a811-2c14-4578-aff0-476676818ea9_1670764292.2877312.png)"
                    },
                    {
                        "username": "dimdos95",
                        "content": "https://www.youtube.com/watch?v=xQuYr9DNMbQ&ab_channel=YoucodewithDmytro"
                    },
                    {
                        "username": "Khattar1024",
                        "content": "WHAT IS THE PROBLEM IN THIS CODE  \\n\\nlong long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n = skill.size();\\n        long long ans = {-1};\\n        if(n == 2){\\n            ans = skill[0] * skill[1];\\n            return ans;\\n        }\\n        vector<pair<int,int>> v;\\n        int i =0;\\n        int r = n-1;\\n        int temp = skill[i] + skill[r];\\n        while(i<r){\\n            if(skill[i] + skill[r] != temp){\\n                return ans;\\n            }else{\\n                v.push_back({skill[i],skill[r]});\\n                i++;\\n                r--;\\n            }\\n        }\\n        for(auto it : v){\\n            ans += it.first * it.second;\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shamikh05",
                        "content": "You have initialized ans with -1. Initialize it with 0 and inside (skill[i] + skill[r] != temp) if block remove return ans with return -1. Make these couple of changes and your code will be accepted."
                    }
                ]
            },
            {
                "id": 1708904,
                "content": [
                    {
                        "username": "elsheraey",
                        "content": "This should be easy..."
                    },
                    {
                        "username": "karkisa",
                        "content": "maybe.. \\nIf you go the hash table way it gets cumbersome and a little tricky with edge cases.\\nTwo pointer solution is very simple if it strikes under pressure."
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach :\\n\\n1. sort the array\\n\\n2. As skill of each team is to be equal, we take target skill value to be smallest+largest in the array\\n\\n3. We pick the smallest element in the array and add the largest, check if this is equal to the target, if not, we immediately quit the program as we return -1\\nElse we add the product of the team into a variable\\n\\n4. return the variable "
                    },
                    {
                        "username": "asthana1011",
                        "content": "Why does the target skill need to be skill[0] + skill[n-1] after sorting i.e smallest+largest ??"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "the return type is `long` guys. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "![image.png](https://assets.leetcode.com/users/images/bb20a811-2c14-4578-aff0-476676818ea9_1670764292.2877312.png)"
                    },
                    {
                        "username": "dimdos95",
                        "content": "https://www.youtube.com/watch?v=xQuYr9DNMbQ&ab_channel=YoucodewithDmytro"
                    },
                    {
                        "username": "Khattar1024",
                        "content": "WHAT IS THE PROBLEM IN THIS CODE  \\n\\nlong long dividePlayers(vector<int>& skill) {\\n        sort(skill.begin(),skill.end());\\n        int n = skill.size();\\n        long long ans = {-1};\\n        if(n == 2){\\n            ans = skill[0] * skill[1];\\n            return ans;\\n        }\\n        vector<pair<int,int>> v;\\n        int i =0;\\n        int r = n-1;\\n        int temp = skill[i] + skill[r];\\n        while(i<r){\\n            if(skill[i] + skill[r] != temp){\\n                return ans;\\n            }else{\\n                v.push_back({skill[i],skill[r]});\\n                i++;\\n                r--;\\n            }\\n        }\\n        for(auto it : v){\\n            ans += it.first * it.second;\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shamikh05",
                        "content": "You have initialized ans with -1. Initialize it with 0 and inside (skill[i] + skill[r] != temp) if block remove return ans with return -1. Make these couple of changes and your code will be accepted."
                    }
                ]
            }
        ]
    }
]