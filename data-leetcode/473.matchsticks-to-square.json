[
    {
        "title": "Matchsticks to Square",
        "question_content": "You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\nReturn true if you can make this square and false otherwise.\n&nbsp;\nExample 1:\n\nInput: matchsticks = [1,1,2,2,2]\nOutput: true\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n\nExample 2:\n\nInput: matchsticks = [3,3,3,3,4]\nOutput: false\nExplanation: You cannot find a way to form a square with all the matchsticks.\n\n&nbsp;\nConstraints:\n\n\t1 <= matchsticks.length <= 15\n\t1 <= matchsticks[i] <= 108",
        "solutions": [
            {
                "id": 95744,
                "title": "cpp-6ms-solution-with-dfs",
                "content": "This is a NP problem. Time complexity should be O(4 ^ n), n is the length of array.\\n#### Trivial Solution:\\n```cpp\\nclass Solution {\\n    bool dfs(vector<int> &sidesLength,const vector<int> &matches, int index) {\\n        if (index == matches.size())\\n            return sidesLength[0] == sidesLength[1] && sidesLength[1] == sidesLength[2] && sidesLength[2] == sidesLength[3];\\n        for (int i = 0; i < 4; ++i) {\\n            sidesLength[i] += matches[index];\\n            if (dfs(sidesLength, matches, index + 1))\\n                return true;\\n            sidesLength[i] -= matches[index];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        if (nums.empty()) return false;\\n        vector<int> sidesLength(4, 0);\\n        return dfs(sidesLength, nums, 0);\\n    }\\n};\\n```\\nWithout pruning, this solution TLEs at 11th test case.\\n#### First Optimization:\\n>each matchstick must be used exactly one time.\\n\\nThe description says we need to use every single match exactly **once**, so we can get the **length of each side of the square** if there is one.\\nif the current length is larger than target length, we don't need to go any further.\\n```if (sidesLength[i] + matches[index] > target) continue;``` by adding this line of code into dfs function, solution get TLE at 147th test case.\\n#### Second Optimization:\\nAfter reading the description again, I realize that the length of a single match can be very long. If they put long ones after short ones, it will take a long time before my algorithm return false.\\nSo I sort all the matches to avoid the worst case:```sort(nums.begin(), nums.end(), [](const int &l, const int &r){return l > r;});```. After putting this line before my algorithm, solution passed all cases and beats 50% solutions. I saw someone's algorithm is amazingly fast, they even make me reconsider wether the problem is NP or not.\\n#### Third Optimization:\\nBecause their solutions is so fast, I need think about if I can use DP to solve the problem. It turns out that it's still a NP problem, which makes happy again. But I can actually use the concept of DP in optimization: **if I have checked the same length before, why do I need to bother checking again?**\\nAlthough we only have 4 sides in a square, we can still check if we have encountered the same length with the current match. After I add this to my code:\\n```cpp\\nint j = i;\\nwhile (--j >= 0)\\n    if (sidesLength[i] == sidesLength[j]) \\n        break;\\nif (j != -1) continue;\\n```\\n\\nIt passed all test case in 6ms.\\n```cpp\\nclass Solution {\\n    bool dfs(vector<int> &sidesLength,const vector<int> &matches, int index, const int target) {\\n        if (index == matches.size())\\n            return sidesLength[0] == sidesLength[1] && sidesLength[1] == sidesLength[2] && sidesLength[2] == sidesLength[3];\\n        for (int i = 0; i < 4; ++i) {\\n            if (sidesLength[i] + matches[index] > target) // first\\n                continue;\\n            int j = i;\\n            while (--j >= 0) // third\\n                if (sidesLength[i] == sidesLength[j]) \\n                    break;\\n            if (j != -1) continue;\\n            sidesLength[i] += matches[index];\\n            if (dfs(sidesLength, matches, index + 1, target))\\n                return true;\\n            sidesLength[i] -= matches[index];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        if (nums.size() < 4) return false;\\n        int sum = 0;\\n        for (const int val: nums) {\\n            sum += val;\\n        }\\n        if (sum % 4 != 0) return false;\\n        sort(nums.begin(), nums.end(), [](const int &l, const int &r){return l > r;}); // second\\n        vector<int> sidesLength(4, 0);\\n        return dfs(sidesLength, nums, 0, sum / 4);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    bool dfs(vector<int> &sidesLength,const vector<int> &matches, int index) {\\n        if (index == matches.size())\\n            return sidesLength[0] == sidesLength[1] && sidesLength[1] == sidesLength[2] && sidesLength[2] == sidesLength[3];\\n        for (int i = 0; i < 4; ++i) {\\n            sidesLength[i] += matches[index];\\n            if (dfs(sidesLength, matches, index + 1))\\n                return true;\\n            sidesLength[i] -= matches[index];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        if (nums.empty()) return false;\\n        vector<int> sidesLength(4, 0);\\n        return dfs(sidesLength, nums, 0);\\n    }\\n};\\n```\n```if (sidesLength[i] + matches[index] > target) continue;```\n```sort(nums.begin(), nums.end(), [](const int &l, const int &r){return l > r;});```\n```cpp\\nint j = i;\\nwhile (--j >= 0)\\n    if (sidesLength[i] == sidesLength[j]) \\n        break;\\nif (j != -1) continue;\\n```\n```cpp\\nclass Solution {\\n    bool dfs(vector<int> &sidesLength,const vector<int> &matches, int index, const int target) {\\n        if (index == matches.size())\\n            return sidesLength[0] == sidesLength[1] && sidesLength[1] == sidesLength[2] && sidesLength[2] == sidesLength[3];\\n        for (int i = 0; i < 4; ++i) {\\n            if (sidesLength[i] + matches[index] > target) // first\\n                continue;\\n            int j = i;\\n            while (--j >= 0) // third\\n                if (sidesLength[i] == sidesLength[j]) \\n                    break;\\n            if (j != -1) continue;\\n            sidesLength[i] += matches[index];\\n            if (dfs(sidesLength, matches, index + 1, target))\\n                return true;\\n            sidesLength[i] -= matches[index];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        if (nums.size() < 4) return false;\\n        int sum = 0;\\n        for (const int val: nums) {\\n            sum += val;\\n        }\\n        if (sum % 4 != 0) return false;\\n        sort(nums.begin(), nums.end(), [](const int &l, const int &r){return l > r;}); // second\\n        vector<int> sidesLength(4, 0);\\n        return dfs(sidesLength, nums, 0, sum / 4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95729,
                "title": "java-dfs-solution-with-explanation",
                "content": "According to https://en.wikipedia.org/wiki/Partition_problem, the partition problem (or number partitioning) is the task of deciding whether a given multiset ```S``` of positive integers can be partitioned into two subsets ```S1``` and ```S2``` such that the sum of the numbers in ```S1``` equals the sum of the numbers in ```S2```. The partition problem is ```NP-complete```.\\n\\nWhen I trying to think how to apply dynamic programming solution of above problem to this one (difference is divid ```S``` into 4 subsets), I took another look at the constraints of the problem:\\nThe length sum of the given matchsticks is in the range of ```0``` to ```10^9```.\\nThe length of the given matchstick array will not exceed ```15```.\\n\\nSounds like the input will not be very large... Then why not just do DFS? In fact, DFS solution passed judges.\\n\\nAnyone solved this problem by using DP? Please let me know :)\\n\\n```\\npublic class Solution {\\n    public boolean makesquare(int[] nums) {\\n    \\tif (nums == null || nums.length < 4) return false;\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum % 4 != 0) return false;\\n        \\n    \\treturn dfs(nums, new int[4], 0, sum / 4);\\n    }\\n    \\n    private boolean dfs(int[] nums, int[] sums, int index, int target) {\\n    \\tif (index == nums.length) {\\n    \\t    if (sums[0] == target && sums[1] == target && sums[2] == target) {\\n    \\t\\treturn true;\\n    \\t    }\\n    \\t    return false;\\n    \\t}\\n    \\t\\n    \\tfor (int i = 0; i < 4; i++) {\\n    \\t    if (sums[i] + nums[index] > target) continue;\\n    \\t    sums[i] += nums[index];\\n            if (dfs(nums, sums, index + 1, target)) return true;\\n    \\t    sums[i] -= nums[index];\\n    \\t}\\n    \\t\\n    \\treturn false;\\n    }\\n}\\n```\\n```Updates on 12/19/2016``` Thanks @benjamin19890721 for pointing out a very good optimization: Sorting the input array ```DESC``` will make the DFS process run much faster. Reason behind this is we always try to put the next matchstick in the first subset. If there is no solution, trying a longer matchstick first will get to negative conclusion earlier. Following is the updated code. Runtime is improved from more than 1000ms to around 40ms. A big improvement.\\n```\\npublic class Solution {\\n    public boolean makesquare(int[] nums) {\\n    \\tif (nums == null || nums.length < 4) return false;\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum % 4 != 0) return false;\\n        \\n        Arrays.sort(nums);\\n        reverse(nums);\\n        \\n    \\treturn dfs(nums, new int[4], 0, sum / 4);\\n    }\\n    \\n    private boolean dfs(int[] nums, int[] sums, int index, int target) {\\n    \\tif (index == nums.length) {\\n    \\t    if (sums[0] == target && sums[1] == target && sums[2] == target) {\\n    \\t\\treturn true;\\n    \\t    }\\n    \\t    return false;\\n    \\t}\\n    \\t\\n    \\tfor (int i = 0; i < 4; i++) {\\n    \\t    if (sums[i] + nums[index] > target) continue;\\n    \\t    sums[i] += nums[index];\\n            if (dfs(nums, sums, index + 1, target)) return true;\\n    \\t    sums[i] -= nums[index];\\n    \\t}\\n    \\t\\n    \\treturn false;\\n    }\\n    \\n    private void reverse(int[] nums) {\\n        int i = 0, j = nums.length - 1;\\n        while (i < j) {\\n            int temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n            i++; j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```S```\n```S1```\n```S2```\n```S1```\n```S2```\n```NP-complete```\n```S```\n```0```\n```10^9```\n```15```\n```\\npublic class Solution {\\n    public boolean makesquare(int[] nums) {\\n    \\tif (nums == null || nums.length < 4) return false;\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum % 4 != 0) return false;\\n        \\n    \\treturn dfs(nums, new int[4], 0, sum / 4);\\n    }\\n    \\n    private boolean dfs(int[] nums, int[] sums, int index, int target) {\\n    \\tif (index == nums.length) {\\n    \\t    if (sums[0] == target && sums[1] == target && sums[2] == target) {\\n    \\t\\treturn true;\\n    \\t    }\\n    \\t    return false;\\n    \\t}\\n    \\t\\n    \\tfor (int i = 0; i < 4; i++) {\\n    \\t    if (sums[i] + nums[index] > target) continue;\\n    \\t    sums[i] += nums[index];\\n            if (dfs(nums, sums, index + 1, target)) return true;\\n    \\t    sums[i] -= nums[index];\\n    \\t}\\n    \\t\\n    \\treturn false;\\n    }\\n}\\n```\n```Updates on 12/19/2016```\n```DESC```\n```\\npublic class Solution {\\n    public boolean makesquare(int[] nums) {\\n    \\tif (nums == null || nums.length < 4) return false;\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum % 4 != 0) return false;\\n        \\n        Arrays.sort(nums);\\n        reverse(nums);\\n        \\n    \\treturn dfs(nums, new int[4], 0, sum / 4);\\n    }\\n    \\n    private boolean dfs(int[] nums, int[] sums, int index, int target) {\\n    \\tif (index == nums.length) {\\n    \\t    if (sums[0] == target && sums[1] == target && sums[2] == target) {\\n    \\t\\treturn true;\\n    \\t    }\\n    \\t    return false;\\n    \\t}\\n    \\t\\n    \\tfor (int i = 0; i < 4; i++) {\\n    \\t    if (sums[i] + nums[index] > target) continue;\\n    \\t    sums[i] += nums[index];\\n            if (dfs(nums, sums, index + 1, target)) return true;\\n    \\t    sums[i] -= nums[index];\\n    \\t}\\n    \\t\\n    \\treturn false;\\n    }\\n    \\n    private void reverse(int[] nums) {\\n        int i = 0, j = nums.length - 1;\\n        while (i < j) {\\n            int temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n            i++; j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273756,
                "title": "c-simple-and-clean-backtracking-commented-solution",
                "content": "**This problem is a special case of: 698. Partition to K Equal Sum Subsets, where k = 4.**\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/1273738/C%2B%2B-Simple-and-Clean-Backtracking-Solution\\n```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum = 0;\\n        sum = accumulate(matchsticks.begin(), matchsticks.end(), sum);\\n        if (matchsticks.size() < 4 || sum % 4) return false;\\n        \\n        vector<int>visited(matchsticks.size(), false);\\n        return backtrack(matchsticks, visited, sum / 4, 0, 0, 4);\\n    }\\n    \\n    bool backtrack(vector<int>& matchsticks,vector<int>visited, int target, int curr_sum, int i, int k) {\\n        if (k == 1) // if k == 1 then we found all subsets\\n            return true;\\n        \\n        if (curr_sum == target) // we found one subset, go on to the next one starting from curr_sum = 0\\n            return backtrack(matchsticks, visited, target, 0, 0, k-1);\\n        \\n        for (int j = i; j < matchsticks.size(); j++) {\\n            if (visited[j] || curr_sum + matchsticks[j] > target) continue; // if we visited this index already or curr_sum + matchsticks[j] > target then we can\\'t use it\\n            \\n            visited[j] = true;\\n            if (backtrack(matchsticks, visited, target, curr_sum + matchsticks[j], j+1, k)) return true;\\n            visited[j] = false;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum = 0;\\n        sum = accumulate(matchsticks.begin(), matchsticks.end(), sum);\\n        if (matchsticks.size() < 4 || sum % 4) return false;\\n        \\n        vector<int>visited(matchsticks.size(), false);\\n        return backtrack(matchsticks, visited, sum / 4, 0, 0, 4);\\n    }\\n    \\n    bool backtrack(vector<int>& matchsticks,vector<int>visited, int target, int curr_sum, int i, int k) {\\n        if (k == 1) // if k == 1 then we found all subsets\\n            return true;\\n        \\n        if (curr_sum == target) // we found one subset, go on to the next one starting from curr_sum = 0\\n            return backtrack(matchsticks, visited, target, 0, 0, k-1);\\n        \\n        for (int j = i; j < matchsticks.size(); j++) {\\n            if (visited[j] || curr_sum + matchsticks[j] > target) continue; // if we visited this index already or curr_sum + matchsticks[j] > target then we can\\'t use it\\n            \\n            visited[j] = true;\\n            if (backtrack(matchsticks, visited, target, curr_sum + matchsticks[j], j+1, k)) return true;\\n            visited[j] = false;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95746,
                "title": "c-bit-masking-dp-solution-with-detailed-comments",
                "content": "This is a solution inspired by a friend who doesn't do leetcode. I am just posting his solution with the best explanation I can give. The bitmasking technique may look sophisticated but the idea is actually pretty straightforward because it uses brute force with some optimizations. A bitmask is used as a representation of a subset. For example if nums = {1,1,2,2,2}, then a bitmask = 01100 represents the subset {1,2}.\\n```\\nbool makesquare(vector<int>& nums) {\\n    int n = nums.size();\\n\\n    long sum = accumulate(nums.begin(), nums.end(), 0l);\\n    if (sum % 4)\\n        return false;\\n    long sideLen = sum / 4;\\n    // need to solve the problem of partitioning nums into four equal subsets each having\\n    // sum equal to sideLen\\n    vector<int> usedMasks;\\n    // validHalfSubsets[i] == true iff the subset represented by bitmask i\\n    // has sum == 2*sideLen, AND the subset represented by i can be further partitioned into\\n    // two equal subsets. See below for how it is used.\\n    vector<bool> validHalfSubsets(1<<n, false);\\n\\n    // E.g., if n = 5, (1 << 5 - 1) = 11111 represents the whole set\\n    int all = (1 << n) - 1;\\n    // go through all possible subsets each represented by a bitmask\\n    for (int mask = 0; mask <= all; mask++) {\\n        long subsetSum = 0;\\n        // calculate the sum of this subset\\n        for (int i = 0; i < 32; i++) {\\n\\t    if ((mask >> i) & 1)\\n\\t\\tsubsetSum += nums[i];\\n        }\\n\\t// if this subset has what we want\\n\\tif (subsetSum == sideLen) {\\n\\t    for (int usedMask : usedMasks) {\\n\\t    // if this mask and usedMask are mutually exclusive\\n\\t        if ((usedMask & mask) == 0) {\\n\\t\\t    // then they form a valid half subset whose sum is 2 * sideLen,\\n                    // that can be further partitioned into two equal subsets (usedMask and mask)\\n\\t\\t    int validHalf = usedMask | mask;\\n\\t\\t    validHalfSubsets[validHalf] = true;\\n\\t\\t    // if in the past we concluded that the other half is also a valid\\n\\t\\t    // half subset, DONE!\\n\\t\\t    if (validHalfSubsets[all ^ validHalf])\\n\\t\\t        return true;\\n\\t        }\\n            }\\n\\t    usedMasks.push_back(mask);\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool makesquare(vector<int>& nums) {\\n    int n = nums.size();\\n\\n    long sum = accumulate(nums.begin(), nums.end(), 0l);\\n    if (sum % 4)\\n        return false;\\n    long sideLen = sum / 4;\\n    // need to solve the problem of partitioning nums into four equal subsets each having\\n    // sum equal to sideLen\\n    vector<int> usedMasks;\\n    // validHalfSubsets[i] == true iff the subset represented by bitmask i\\n    // has sum == 2*sideLen, AND the subset represented by i can be further partitioned into\\n    // two equal subsets. See below for how it is used.\\n    vector<bool> validHalfSubsets(1<<n, false);\\n\\n    // E.g., if n = 5, (1 << 5 - 1) = 11111 represents the whole set\\n    int all = (1 << n) - 1;\\n    // go through all possible subsets each represented by a bitmask\\n    for (int mask = 0; mask <= all; mask++) {\\n        long subsetSum = 0;\\n        // calculate the sum of this subset\\n        for (int i = 0; i < 32; i++) {\\n\\t    if ((mask >> i) & 1)\\n\\t\\tsubsetSum += nums[i];\\n        }\\n\\t// if this subset has what we want\\n\\tif (subsetSum == sideLen) {\\n\\t    for (int usedMask : usedMasks) {\\n\\t    // if this mask and usedMask are mutually exclusive\\n\\t        if ((usedMask & mask) == 0) {\\n\\t\\t    // then they form a valid half subset whose sum is 2 * sideLen,\\n                    // that can be further partitioned into two equal subsets (usedMask and mask)\\n\\t\\t    int validHalf = usedMask | mask;\\n\\t\\t    validHalfSubsets[validHalf] = true;\\n\\t\\t    // if in the past we concluded that the other half is also a valid\\n\\t\\t    // half subset, DONE!\\n\\t\\t    if (validHalfSubsets[all ^ validHalf])\\n\\t\\t        return true;\\n\\t        }\\n            }\\n\\t    usedMasks.push_back(mask);\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2270410,
                "title": "c-clean-code-backtracking-commented",
                "content": "```\\nclass Solution {\\n\\t// a,b,c,d are four sides of square\\n    int a,b,c,d;\\n    bool fun(vector<int>& matchsticks,int i){\\n        //Base Case\\n        if(i==matchsticks.size()){\\n            if(a==0 && b==0 && c==0 && d==0) return true;\\n            else return false;\\n        }\\n        \\n\\t\\t//Now we will explore for all side for given index\\n\\t\\t\\n\\t\\t// if matchstick size is less than side(a or b or c or d)  size , then in that case we will not explore that because that will cause negative side which is not possible\\n        if(matchsticks[i]<=a){\\n            a-=matchsticks[i];\\n            if(fun(matchsticks,i+1)) return true;\\n            a+=matchsticks[i];      // backtrack step\\n        }\\n        \\n        if(matchsticks[i]<=b){\\n            b-=matchsticks[i];\\n            if(fun(matchsticks,i+1)) return true;\\n            b+=matchsticks[i];        // backtrack step                    \\n        }\\n        \\n        if(matchsticks[i]<=c){\\n            c-=matchsticks[i];\\n            if(fun(matchsticks,i+1)) return true;\\n            c+=matchsticks[i];         // backtrack step\\n        }\\n        \\n        if(matchsticks[i]<=d){\\n            d-=matchsticks[i];\\n            if(fun(matchsticks,i+1)) return true;\\n            d+=matchsticks[i];         // backtrack step\\n        }\\n\\t\\t\\n\\t\\t//If none of the explored option retuen true then  we have to return false\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n\\t\\t//  if less than four number present in array , then we can not make square\\n        if(matchsticks.size()<4) return false;\\n        \\n\\t\\t// if sum of all number of array is not divisible by 4 , then we can not create a square\\n\\t\\tint sum = accumulate(matchsticks.begin(), matchsticks.end(),0);\\n        if(sum % 4 != 0) return false;\\n        \\n\\t\\tint sizeSum=sum/4;\\n        a=sizeSum,b=sizeSum,c=sizeSum,d=sizeSum;\\n        \\n\\t\\t// here we sort our array in reverse order to escape more cases\\n\\t\\tsort(matchsticks.rbegin(), matchsticks.rend());\\n        \\n\\t\\treturn fun(matchsticks,0);\\n    }\\n};\\n```\\n**Time Complexity : O(4 ^ N)\\nSpace Complexity : O(N)**\\n*Note :: it uses recursive calls to itself, it is O(depth) call stack space. And as the depth is the number of sticks given, it is O(n) space.*\\n\\n\\n\\n*If you like the solution , Upvote it.*",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\t// a,b,c,d are four sides of square\\n    int a,b,c,d;\\n    bool fun(vector<int>& matchsticks,int i){\\n        //Base Case\\n        if(i==matchsticks.size()){\\n            if(a==0 && b==0 && c==0 && d==0) return true;\\n            else return false;\\n        }\\n        \\n\\t\\t//Now we will explore for all side for given index\\n\\t\\t\\n\\t\\t// if matchstick size is less than side(a or b or c or d)  size , then in that case we will not explore that because that will cause negative side which is not possible\\n        if(matchsticks[i]<=a){\\n            a-=matchsticks[i];\\n            if(fun(matchsticks,i+1)) return true;\\n            a+=matchsticks[i];      // backtrack step\\n        }\\n        \\n        if(matchsticks[i]<=b){\\n            b-=matchsticks[i];\\n            if(fun(matchsticks,i+1)) return true;\\n            b+=matchsticks[i];        // backtrack step                    \\n        }\\n        \\n        if(matchsticks[i]<=c){\\n            c-=matchsticks[i];\\n            if(fun(matchsticks,i+1)) return true;\\n            c+=matchsticks[i];         // backtrack step\\n        }\\n        \\n        if(matchsticks[i]<=d){\\n            d-=matchsticks[i];\\n            if(fun(matchsticks,i+1)) return true;\\n            d+=matchsticks[i];         // backtrack step\\n        }\\n\\t\\t\\n\\t\\t//If none of the explored option retuen true then  we have to return false\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n\\t\\t//  if less than four number present in array , then we can not make square\\n        if(matchsticks.size()<4) return false;\\n        \\n\\t\\t// if sum of all number of array is not divisible by 4 , then we can not create a square\\n\\t\\tint sum = accumulate(matchsticks.begin(), matchsticks.end(),0);\\n        if(sum % 4 != 0) return false;\\n        \\n\\t\\tint sizeSum=sum/4;\\n        a=sizeSum,b=sizeSum,c=sizeSum,d=sizeSum;\\n        \\n\\t\\t// here we sort our array in reverse order to escape more cases\\n\\t\\tsort(matchsticks.rbegin(), matchsticks.rend());\\n        \\n\\t\\treturn fun(matchsticks,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270337,
                "title": "python3-dfs-cache-easy-to-understand",
                "content": "The idea is using dfs/backtracking to try all l1, l2, l3, l4 then check if all edges are equal to the `sum(matchsticks) // 4 `, I just did some simple pruning based on:\\n1. sort the matchsticks by length, then reverse check to reduce some time \\n2. if any l1, l2, l3, l4 are greater than edge , we stop searching \\n\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        value = sum(matchsticks)\\n        if value < 4:\\n            return False\\n        if value % 4 != 0:\\n            return False\\n        edge = value // 4\\n        matchsticks.sort(reverse=True)\\n        @cache\\n        def findedges(l1, l2, l3, l4, i):\\n            nonlocal edge\\n            if l1 == l2 == l3 == l4 == edge:\\n                return True\\n            if i > len(matchsticks) - 1:\\n                return False\\n            if l1 > edge or l2 > edge or l3 > edge or l4 > edge:\\n                return False\\n            return findedges(l1 + matchsticks[i], l2, l3, l4, i + 1) or findedges(l1, l2 + matchsticks[i] , l3, l4, i + 1) or findedges(l1, l2, l3 + matchsticks[i], l4, i + 1) or findedges(l1, l2, l3, l4 + matchsticks[i] , i + 1)\\n        return findedges(0, 0, 0, 0, 0)\\n                \\n```\\n\\nEdit:\\nFor explanation, thanks to @rcomesan\\n https://leetcode.com/problems/matchsticks-to-square/discuss/2274058/python-from-dfs-to-optimized-dp-using-bitmasks",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        value = sum(matchsticks)\\n        if value < 4:\\n            return False\\n        if value % 4 != 0:\\n            return False\\n        edge = value // 4\\n        matchsticks.sort(reverse=True)\\n        @cache\\n        def findedges(l1, l2, l3, l4, i):\\n            nonlocal edge\\n            if l1 == l2 == l3 == l4 == edge:\\n                return True\\n            if i > len(matchsticks) - 1:\\n                return False\\n            if l1 > edge or l2 > edge or l3 > edge or l4 > edge:\\n                return False\\n            return findedges(l1 + matchsticks[i], l2, l3, l4, i + 1) or findedges(l1, l2 + matchsticks[i] , l3, l4, i + 1) or findedges(l1, l2, l3 + matchsticks[i], l4, i + 1) or findedges(l1, l2, l3, l4 + matchsticks[i] , i + 1)\\n        return findedges(0, 0, 0, 0, 0)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273708,
                "title": "python-dp-on-subsets-explained",
                "content": "Special case of Problem **698** Partition to K Equal Sum Subsets, but here we need to partition into 4 equal sums, we say, put them into `buckets` (or sides of square).\\n\\nPlease also check my post https://leetcode.com/discuss/general-discussion/1125779/Dynamic-programming-on-subsets-with-examples-explained for more problems which can be solved with this technique.\\n\\nDenote by `dp(mask)` possibility to put numbers from bitmask `mask` into say `k` subsets, such that sum inside each of the first `k-1` subsets is equal to `basket` . In more detais: we return -1 if this partition is not possible and we return `t >= 0`, if it is possible, where `t` is remainder when we divide sum of all used numbers so far by basket: value, of how many we need to put in each group. Given our `mask` there is several options about what matchstick can be taken the last: the places, where we meet `1` bit. So, if `neib` is answer for smaller problem with this match removed `dfs(mask ^ 1<<j)`, and `neib >= 0`, that is solution exists, and `neib + nums[j] <= basket`, that is we still have place in the last backet, then we return `(neib + nums[j]) % basket`. We use `%` here, because basked can be filled fully and in this case we need to start new one.\\n\\n#### Complexity\\nWe have `O(2^n)` states with `O(n)` transactions for each one, so overall time complexity is `(2^n * n)` and space complexity is `O(2^n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def makesquare(self, nums):\\n        N = len(nums)\\n        basket, rem = divmod(sum(nums), 4)\\n        if rem or max(nums) > basket: return False\\n        \\n        @lru_cache(None)\\n        def dfs(mask):\\n            if mask == 0: return 0\\n            for j in range(N):\\n                if mask & 1<<j:\\n                    neib = dfs(mask ^ 1<<j)\\n                    if neib >= 0 and neib + nums[j] <= basket:\\n                        return (neib + nums[j]) % basket\\n            return -1\\n                    \\n        return dfs((1<<N) - 1) == 0\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def makesquare(self, nums):\\n        N = len(nums)\\n        basket, rem = divmod(sum(nums), 4)\\n        if rem or max(nums) > basket: return False\\n        \\n        @lru_cache(None)\\n        def dfs(mask):\\n            if mask == 0: return 0\\n            for j in range(N):\\n                if mask & 1<<j:\\n                    neib = dfs(mask ^ 1<<j)\\n                    if neib >= 0 and neib + nums[j] <= basket:\\n                        return (neib + nums[j]) % basket\\n            return -1\\n                    \\n        return dfs((1<<N) - 1) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270381,
                "title": "simple-java-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        \\n        int total = 0;\\n        \\n        for (int i : matchsticks) {\\n            total += i;\\n        }\\n        \\n        if (total % 4 != 0) return false; // if we cant make 4 equals sides then theres no way to make a square\\n        // sort the array and place the largest sides first. required optimization to not TLE\\n        Arrays.sort(matchsticks); \\n        return match(matchsticks, matchsticks.length - 1, 0, 0, 0, 0, total / 4);\\n    }\\n    \\n    public boolean match(int[] matchsticks, int index, int top, int bottom, int left, int right, int target) {\\n        \\n        if (top == target && bottom == target && left == target && right == target) return true;\\n\\n        if (top > target || bottom > target || left > target || right > target) return false;\\n                        \\n        int val = matchsticks[index];\\n        \\n        boolean t = match(matchsticks, index - 1, top + val, bottom, left, right, target);\\n        if (t) return true;\\n        boolean b = match(matchsticks, index - 1, top, bottom + val, left, right, target);\\n        if (b) return true;\\n        boolean l = match(matchsticks, index - 1, top, bottom, left + val, right, target);\\n        if (l) return true;\\n        boolean r = match(matchsticks, index - 1, top, bottom, left, right + val, target);\\n        if (r) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        \\n        int total = 0;\\n        \\n        for (int i : matchsticks) {\\n            total += i;\\n        }\\n        \\n        if (total % 4 != 0) return false; // if we cant make 4 equals sides then theres no way to make a square\\n        // sort the array and place the largest sides first. required optimization to not TLE\\n        Arrays.sort(matchsticks); \\n        return match(matchsticks, matchsticks.length - 1, 0, 0, 0, 0, total / 4);\\n    }\\n    \\n    public boolean match(int[] matchsticks, int index, int top, int bottom, int left, int right, int target) {\\n        \\n        if (top == target && bottom == target && left == target && right == target) return true;\\n\\n        if (top > target || bottom > target || left > target || right > target) return false;\\n                        \\n        int val = matchsticks[index];\\n        \\n        boolean t = match(matchsticks, index - 1, top + val, bottom, left, right, target);\\n        if (t) return true;\\n        boolean b = match(matchsticks, index - 1, top, bottom + val, left, right, target);\\n        if (b) return true;\\n        boolean l = match(matchsticks, index - 1, top, bottom, left + val, right, target);\\n        if (l) return true;\\n        boolean r = match(matchsticks, index - 1, top, bottom, left, right + val, target);\\n        if (r) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270895,
                "title": "beats-90-c-solutions-most-unique-and-simple-solution-ever-briefly-explained-with-pseudo-code",
                "content": "![image](https://assets.leetcode.com/users/images/b0c68f85-161b-475c-9e61-82fafbb43ead_1657600391.7468712.png)\\n![image](https://assets.leetcode.com/users/images/d37fb072-9fd1-45db-95e2-4cccf4b8c9f7_1657602532.3454869.png)\\n![image](https://assets.leetcode.com/users/images/51c19108-91a7-474c-a00f-ef2c5615af8c_1657602545.9510205.png)\\n![image](https://assets.leetcode.com/users/images/36686911-2125-407f-8f15-ede4932f50fb_1657602555.7759843.png)\\n![image](https://assets.leetcode.com/users/images/07e44ed2-5682-4225-ac55-5ffeb103dc52_1657602580.4135065.png)\\n\\n```\\nbool dfs(vector<int>& matchsticks, vector<int>& kow, int index, int target){\\n        if(index == -1){\\n            return true;\\n        }\\n        for(int i = 0; i < 4; i++){\\n            if(((kow[i] + matchsticks[index]) > target) or (i > 0 and kow[i] == kow[i - 1])){\\n                continue;\\n            }\\n            kow[i] += matchsticks[index];\\n            if(dfs(matchsticks, kow, index - 1, target)){\\n                return true;\\n            } \\n            kow[i] -= matchsticks[index];\\n        }\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum = 0;\\n        for(int i : matchsticks){\\n            sum += i;\\n        }\\n        if(sum%4 != 0 or matchsticks.size() < 3){\\n            return false;\\n        }\\n        sort(matchsticks.begin(), matchsticks.end());\\n        vector<int> kow(4, 0);\\n        return dfs(matchsticks, kow, matchsticks.size() - 1, sum/4);\\n    }\\n```\\n**Please upvote my solution if you understood, Also, let me know your doubts through comment section below, I will be happy to reply back!!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nbool dfs(vector<int>& matchsticks, vector<int>& kow, int index, int target){\\n        if(index == -1){\\n            return true;\\n        }\\n        for(int i = 0; i < 4; i++){\\n            if(((kow[i] + matchsticks[index]) > target) or (i > 0 and kow[i] == kow[i - 1])){\\n                continue;\\n            }\\n            kow[i] += matchsticks[index];\\n            if(dfs(matchsticks, kow, index - 1, target)){\\n                return true;\\n            } \\n            kow[i] -= matchsticks[index];\\n        }\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum = 0;\\n        for(int i : matchsticks){\\n            sum += i;\\n        }\\n        if(sum%4 != 0 or matchsticks.size() < 3){\\n            return false;\\n        }\\n        sort(matchsticks.begin(), matchsticks.end());\\n        vector<int> kow(4, 0);\\n        return dfs(matchsticks, kow, matchsticks.size() - 1, sum/4);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95752,
                "title": "java-dfs-solution-with-various-optimizations-sorting-sequential-partition-dp",
                "content": "As others pointed out, after proper preprocessing, this problem boiled down to a number partitioning problem which is NP-hard. Nevertheless, if the total number of elements is small, a naive DFS solution is possible.\\n\\n---\\n**`I -- Naive DFS`**\\n\\nFor better description of the problem, let's reformulate it in the following symbolic way: \\n\\n**Given an array `nums` with `n` elements, let `T(i, s1, s2, s3, s4)` denote whether we can partition the subarray `nums[0, i]`(both inclusive) into four disjoint groups such that the sum of elements in the `j-th`  group is `sj`, with `j = 1, 2, 3, 4`.**\\n\\nWith this definition, our original problem will be `T(n - 1, side, side, side, side)` where `side` is the side length of the square.\\n\\nTo solve for `T(i, s1, s2, s3, s4)`, note that the last element of the subarray `nums[0, i]` (which is `nums[i]`) must belong to one of the disjoint groups, therefore we have the following recurrence relation:\\n```\\nT(i, s1, s2, s3, s4) = T(i - 1, s1 - nums[i], s2, s3, s4) ||\\n                       T(i - 1, s1, s2 - nums[i], s3, s4) ||\\n                       T(i - 1, s1, s2, s3 - nums[i], s4) ||\\n                       T(i - 1, s1, s2, s3, s4 - nums[i])\\n```\\nThe interpretation is as follows: if `nums[i]` belongs to the `j-th` group, we subtract it from `sj`, then recursively solve for the subproblem with reduced array size and modified group sum. However, we do not know which group it belongs to beforehand, therefore each of the groups will be examined until we either hit the right group or determine that no partition is possible. Also note that if all elements in the input array are positive, an element cannot fall into a group with a group sum smaller than the element itself, i.e., `nums[i]` cannot belong to the `j-th` group if `nums[i] > sj`.\\n\\nThe termination condition for the recursion is when the subarray is empty, i.e., `i = -1`, at which time we will check whether the sum of each group is zero. If so, a partition is found and return true; otherwise no partition is possible and return false.\\n\\nHere is the java program based on the above ideas:\\n\\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n    \\n    int side = perimeter / 4;\\n\\n    return makesquareSub(nums, nums.length - 1, new int[] {side, side, side, side});\\n}\\n\\nprivate boolean makesquareSub(int[] nums, int i, int[] s) {\\n    if (i < 0) return s[0] == 0 && s[1] == 0 && s[2] == 0 && s[3] == 0;\\n        \\n    for (int j = 0; j < s.length; j++) {\\n        if (nums[i] > s[j]) continue;\\n        s[j] -= nums[i];\\n        if (makesquareSub(nums, i - 1, s)) return true;\\n        s[j] += nums[i];\\n    }\\n        \\n    return false;\\n}\\n```\\nWhile accepted, this solution runs rather slowly (~`450ms`). So let's see what optimizations can be done to enhance the time complexity.\\n\\n---\\n**`II -- DFS with sorting`**\\n\\nIn the recurrence relation above, we concluded that if `nums[i] > sj`, it cannot belong to the `j-th` group, which implies we needn't even bother to try that case. This condition is most likely to be met if we always choose the maximum element that is currently available in the subarray. Also note that the order of elements does not matter in the partition of the array. Therefore we can sort the input array in ascending order before rushing into DFS. This reduced the running time sharply to ~`40ms`.\\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n        \\n    Arrays.sort(nums);\\n    int side = perimeter / 4;\\n\\n    return makesquareSub(nums, nums.length - 1, new int[] {side, side, side, side});\\n}\\n    \\nprivate boolean makesquareSub(int[] nums, int i, int[] s) {\\n    if (i < 0) return s[0] == 0 && s[1] == 0 && s[2] == 0 && s[3] == 0;\\n        \\n    for (int j = 0; j < s.length; j++) {\\n        if (nums[i] > s[j]) continue;\\n        s[j] -= nums[i];\\n        if (makesquareSub(nums, i - 1, s)) return true;\\n        s[j] += nums[i];\\n    }\\n        \\n    return false;\\n}\\n```\\n---\\n***Note: It looks like the following solutions based on sequential ideas are not correct. See [oliver_feng's](https://discuss.leetcode.com/topic/72569/java-dfs-solution-with-various-optimizations-sorting-sequential-partition-dp/3) comment below.***\\n\\n~~**`III -- DFS with sequential-partition`**~~\\n\\nSo far, the partitioning of the array is done simultaneously for the four disjoint groups. With the array sorted, it is also possible to break the partitioning process into four sequential parts such that each part will find each of the disjoint groups. (Note: sorting in ascending order is **necessary** now. We have to choose greedily (maximum element available) for each group,  otherwise the total number of valid groups may decrease. Check out the case `[3,3,3,3,1,1,1,1]`.)\\n\\nTo this end, let's define `T(i, sum)` which denotes whether `sum` can be written as the summation of some elements in the subarray `nums[0, i]`, with each element used at most once. If so, a group is found such that the sum of its elements will be `sum`. Without much efforts, we can obtain the following recurrence relation:\\n```\\nT(i, sum) = T(i - 1, sum - nums[i]) || T(i - 1, sum) \\n```\\nThe two cases on the right hand side correspond to whether we choose the last element `nums[i]` to form the sum or not. And again, it cannot be chosen if `nums[i] > sum`.\\n\\nThe termination condition is either `sum = 0` in which case a group is found or `i = -1` in which case no such group exists.\\n\\nSo far everything looks pretty similar to what we have discussed in part `I`. However, a key difference here is now we need to explicitly mark the elements that are chosen to form previous groups since they are no longer available. Some straightforward ways would be using a `boolean array` or an `integer`(and do bit manipulations). Since the elements in the input array are initially positive, it is also possible to mark visited elements by negating their values. \\n\\nHere is the java program for sequential partition, with running time further reduced to ~`15ms`.\\n\\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n        \\n    Arrays.sort(nums);\\n    int side = perimeter / 4;\\n\\n    for (int i = 0; i < 3; i++) {\\n        if (!makesquareSub(nums, nums.length - 1, side)) return false;\\n    }\\n        \\n    return true;\\n}\\n    \\nprivate boolean makesquareSub(int[] nums, int i, int sum) {\\n    if (sum == 0) return true;\\n    if (i < 0) return false;\\n        \\n    if (nums[i] > 0 && nums[i] <= sum) {\\n        nums[i] = -nums[i];\\n        if (makesquareSub(nums, i - 1, sum + nums[i])) return true;\\n        nums[i] = -nums[i];\\n    }\\n        \\n    return makesquareSub(nums, i - 1, sum);\\n}\\n```\\n\\n---\\n~~**`IV -- DFS with DP`**~~\\n\\nFor all solutions above (`T(i, s1, s2, s3, s4)` or `T(i, sum)`), we did not take into account the possibility that there is overlapping among the subproblems.\\n\\nFor `T(i, s1, s2, s3, s4)`, each subproblem is characterized by **five** integers while for `T(i, sum)`, it is **two**. I would say the probability of overlapping subproblems for the former is relatively lower than the latter. So I only implemented DP for the sequential-partition case. However the running time (~`25ms`) did not get further improved, possibly due to the fact that the probability for overlapping subproblems is already rather low (if any) for this case with small number of elements. Not sure if DP will prevail for larger input size though.\\n\\nLast word about the following DP solution: naively we would use an array of HashMap (let's denote it as `map`) to memorize intermediate results, with `i` indexed into the array and `sum` as the key of the corresponding HashMap. However, due to our greedy strategy for finding each group, if two subproblems `T1(i1, sum1)` and `T2(i2, sum2)` have the same sum, i.e., `sum1 = sum2`, then the one with larger index `i` will always be solved before the other. Since `T(i, sum) = true` implies `T(j, sum) = true` with `j >= i`, and `T(i, sum) = false` implies `T(j, sum) = false` with `j <= i`, it is sufficient to use only the `sum` factor to characterize subproblems that yield `false` solution (if any of the subproblem yields true, the recursion will rewind and eventually terminate). Therefore you will see only a HashSet is used in the following implementation.\\n\\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n        \\n    Arrays.sort(nums);\\n    int side = perimeter / 4;\\n        \\n    for (int i = 0; i < 3; i++) {\\n        if (!makesquareSub(nums, nums.length - 1, side, new HashSet<>())) return false;\\n    }\\n    \\n    return true;\\n}\\n    \\nprivate boolean makesquareSub(int[] nums, int i, int sum, Set<Integer> set) {\\n    if (sum == 0) return true;\\n    if (set.contains(sum) || i < 0) return false;\\n    \\n    if (nums[i] > 0 && nums[i] <= sum) {\\n        nums[i] = -nums[i];\\n        if (makesquareSub(nums, i - 1, sum + nums[i], set)) return true;\\n        nums[i] = -nums[i];\\n    }\\n        \\n    if (makesquareSub(nums, i - 1, sum, set)) return true;\\n        \\n    set.add(sum);\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nT(i, s1, s2, s3, s4) = T(i - 1, s1 - nums[i], s2, s3, s4) ||\\n                       T(i - 1, s1, s2 - nums[i], s3, s4) ||\\n                       T(i - 1, s1, s2, s3 - nums[i], s4) ||\\n                       T(i - 1, s1, s2, s3, s4 - nums[i])\\n```\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n    \\n    int side = perimeter / 4;\\n\\n    return makesquareSub(nums, nums.length - 1, new int[] {side, side, side, side});\\n}\\n\\nprivate boolean makesquareSub(int[] nums, int i, int[] s) {\\n    if (i < 0) return s[0] == 0 && s[1] == 0 && s[2] == 0 && s[3] == 0;\\n        \\n    for (int j = 0; j < s.length; j++) {\\n        if (nums[i] > s[j]) continue;\\n        s[j] -= nums[i];\\n        if (makesquareSub(nums, i - 1, s)) return true;\\n        s[j] += nums[i];\\n    }\\n        \\n    return false;\\n}\\n```\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n        \\n    Arrays.sort(nums);\\n    int side = perimeter / 4;\\n\\n    return makesquareSub(nums, nums.length - 1, new int[] {side, side, side, side});\\n}\\n    \\nprivate boolean makesquareSub(int[] nums, int i, int[] s) {\\n    if (i < 0) return s[0] == 0 && s[1] == 0 && s[2] == 0 && s[3] == 0;\\n        \\n    for (int j = 0; j < s.length; j++) {\\n        if (nums[i] > s[j]) continue;\\n        s[j] -= nums[i];\\n        if (makesquareSub(nums, i - 1, s)) return true;\\n        s[j] += nums[i];\\n    }\\n        \\n    return false;\\n}\\n```\n```\\nT(i, sum) = T(i - 1, sum - nums[i]) || T(i - 1, sum) \\n```\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n        \\n    Arrays.sort(nums);\\n    int side = perimeter / 4;\\n\\n    for (int i = 0; i < 3; i++) {\\n        if (!makesquareSub(nums, nums.length - 1, side)) return false;\\n    }\\n        \\n    return true;\\n}\\n    \\nprivate boolean makesquareSub(int[] nums, int i, int sum) {\\n    if (sum == 0) return true;\\n    if (i < 0) return false;\\n        \\n    if (nums[i] > 0 && nums[i] <= sum) {\\n        nums[i] = -nums[i];\\n        if (makesquareSub(nums, i - 1, sum + nums[i])) return true;\\n        nums[i] = -nums[i];\\n    }\\n        \\n    return makesquareSub(nums, i - 1, sum);\\n}\\n```\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n        \\n    Arrays.sort(nums);\\n    int side = perimeter / 4;\\n        \\n    for (int i = 0; i < 3; i++) {\\n        if (!makesquareSub(nums, nums.length - 1, side, new HashSet<>())) return false;\\n    }\\n    \\n    return true;\\n}\\n    \\nprivate boolean makesquareSub(int[] nums, int i, int sum, Set<Integer> set) {\\n    if (sum == 0) return true;\\n    if (set.contains(sum) || i < 0) return false;\\n    \\n    if (nums[i] > 0 && nums[i] <= sum) {\\n        nums[i] = -nums[i];\\n        if (makesquareSub(nums, i - 1, sum + nums[i], set)) return true;\\n        nums[i] = -nums[i];\\n    }\\n        \\n    if (makesquareSub(nums, i - 1, sum, set)) return true;\\n        \\n    set.add(sum);\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95732,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def makesquare(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(nums, pos, target):\\n            if pos == len(nums): return True\\n            for i in range(4):\\n                if target[i] >= nums[pos]:\\n                    target[i] -= nums[pos]\\n                    if dfs(nums, pos+1, target): return True\\n                    target[i] += nums[pos]\\n            return False\\n        if len(nums) < 4 : return False\\n        numSum = sum(nums)\\n        nums.sort(reverse=True)\\n        if numSum % 4 != 0: return False\\n        target = [numSum/4] * 4;\\n        return dfs(nums,0, target)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def makesquare(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(nums, pos, target):\\n            if pos == len(nums): return True\\n            for i in range(4):\\n                if target[i] >= nums[pos]:\\n                    target[i] -= nums[pos]\\n                    if dfs(nums, pos+1, target): return True\\n                    target[i] += nums[pos]\\n            return False\\n        if len(nums) < 4 : return False\\n        numSum = sum(nums)\\n        nums.sort(reverse=True)\\n        if numSum % 4 != 0: return False\\n        target = [numSum/4] * 4;\\n        return dfs(nums,0, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275625,
                "title": "js-python-java-c-easy-optimized-backtracking-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n_(**Edit**: The code has been slightly reworked to be a more straightforward backtracking solution.)_\\n\\nAt first glance, this problem seems rather straightforward: find the total length of the matchsticks in **M**, figure out how long each **side** of the square must be, then find every combination of matchsticks that can add up to **side**. If four unique sets of matchsticks each add up to **side**, then we can **return true**. \\n\\nThe fact that the constraint upon the only imput is so low would seem to suggest that an **O(2^N)** solution is appropriate. There are, however, a few things we can do to optimize this process. The first key realization is that we _can_, in fact, use a **greedy** approach.\\n\\nConsider the case of **M = [1,1,1,2,2,2,3]**. In this case, we can easily see that the total is **12** and thus side = **3**. If we were to start iterating through **M** to find multiples of **3**, we\\'d first group together the first three elements and then also find the last element, but be unable to make two more **3**s from the middle elements of **M**. This would perhaps suggest that a greedy approach will not work, because it\\'s readily apparent that we need to save the **1**s to pair up with the **2**s to make three of the four sides.\\n\\nBut that also suggests the solution, which is that we can use a greedy approach _if_ we iterate through **M** in descending order. That way, each **2** will naturally seek out its matching **1** before we could ever attempt to match the **1**s together in a less efficient manner.\\n\\nThat means that we can just use a **recursive** **backtracking** helper (**btrack**) to help find the side groups in **M**. But first, we can take care of some edge cases: If the total sum of **M** is not divisble by **4**, or if any single matchstick in **M** is longer than the calculated **side**, then a solution is impossible and we should **return false**.\\n\\nAs for our recursive helper, it will need to iterate through the sorted **M** multiple times, attempting to build up groups that match **side**. We\\'ll also keep track of how many groups we\\'ve found (**done**), and whenever we find a match, start **btrack** back at the beginning with **done** incremented.\\n\\n_(**Note**: When incrementing done and starting the recursive helper over, we can start at index **1** instead of index **0** because **M[0]** will_ always _be a part of the first grouping.)_\\n\\nOnce we\\'ve finished **3** groups, we can go ahead and **return true**, because we know that the remaining pieces must add up to **side**. If at any point we reach the end of **M** without finishing the current group, however, we should **return false**.\\n\\nWhen attempting to add a piece to the current group, we can obviously skip pieces that are larger than the remaining **space**, as well as pieces that have already been used. Normally, this would require some kind of additional array or set to keep track of the used pieces, but we can use an **in-place** approach with **M** and just replace the used values with a value larger than **side**. This will simplify the check to skip elements to just one conditional.\\n\\n_(**Note**: If you don\\'t want to modify the input, you_ could _use a single integer and **bit manipulation** to achieve the same result in **O(1) space**. Sorting **M** will still take **O(N) space** if you don\\'t want to modify **M**, however, and in any case, we\\'ll be using **O(N) space** for the recursion stack.)_\\n\\nIf an attempted piece turns out to be unsuccessfully and we\\'re returned back up the recursion stack, we should remember to backtrack the current index (**i**) of **M** to its previous value (**num**).\\n\\n - _**Time Complexity: O(2^N)** where **N** is the length of **M** for the attempted combinations of elements in **M**_\\n - _**Space Complexity: O(N)** for the recursion stack_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava makes it more complicated to reverse sort a primitive array, so we can just use a simple sort and then iterate through **M** backwards instead.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **64ms / 39.9MB** (beats 100% / 31%).\\n```javascript\\nvar makesquare = function(M) {\\n    let n = M.length, side = M.reduce((a,c) => a + c) / 4\\n    M.sort((a,b) => b - a)\\n    if (side !== ~~side || M[0] > side)\\n        return false\\n    const btrack = (i, space, done) => {\\n        if (done === 3)\\n            return true\\n        for (; i < n; i++) {\\n            let num = M[i], res\\n            if (num > space)\\n                continue\\n            M[i] = side + 1\\n            if (num === space)\\n                res = btrack(1, side, done+1)\\n            else\\n                res = btrack(i+1, space-num, done)\\n            if (res)\\n                return true\\n            M[i] = num\\n            while (M[i+1] === num)\\n                i++\\n        }\\n        return false\\n    }\\n    return btrack(0, side, 0)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 14.0MB** (beats 97% / 100%).\\n```python\\nclass Solution:\\n    def makesquare(self, M: List[int]) -> bool:\\n        n, side = len(M), sum(M) / 4\\n        M.sort(reverse=True)\\n        if side != int(side) or M[0] > side:\\n            return False\\n        def btrack(i, space, done): \\n            if done == 3:\\n                return True\\n            while i < n:\\n                num = M[i]\\n                if num > space:\\n                    i += 1\\n                    continue\\n                M[i] = side + 1\\n                if num == space:\\n                    res = btrack(1, side, done+1)\\n                else:\\n                    res = btrack(i+1, space-num, done)\\n                if res:\\n                    return True\\n                M[i] = num\\n                while i < n and M[i] == num:\\n                    i += 1\\n            return False\\n        return btrack(0, side, 0)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 36.1MB** (beats 99% / 94%).\\n```java\\nclass Solution {\\n    public boolean makesquare(int[] M) {\\n        Arrays.sort(M);\\n        int total = 0;\\n        for (int i = 0; i < M.length; i++)\\n            total += M[i];\\n        side = total / 4;\\n        if ((float)total / 4 > side || M[M.length-1] > side)\\n            return false;\\n        return btrack(M.length-1, side, 0, M);\\n    }\\n    private int side;\\n    private boolean btrack(int i, int space, int done, int[] M) {\\n        if (done == 3)\\n            return true;\\n        for (; i >= 0; i--) {\\n            int num = M[i];\\n            boolean res;\\n            if (num > space)\\n                continue;\\n            M[i] = side + 1;\\n            if (num == space)\\n                res = btrack(M.length-2, side, done+1, M);\\n            else\\n                res = btrack(i-1, space-num, done, M);\\n            if (res)\\n                return true;\\n            M[i] = num;\\n            while (i > 0 && M[i-1] == num)\\n                i--;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 9.5MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& M) {\\n        sort(M.begin(), M.end(), greater<int>());\\n        int total = accumulate(M.begin(), M.end(), 0);\\n        side = total / 4;\\n        if ((float)total / 4 > side || M[0] > side)\\n            return false;\\n        return btrack(0, side, 0, M);\\n    }\\nprivate:\\n    int side;\\n    bool btrack(int i, int space, int done, vector<int>& M) {\\n        if (done == 3)\\n            return true;\\n        for (; i < M.size(); i++) {\\n            int num = M[i];\\n            bool res;\\n            if (num > space)\\n                continue;\\n            M[i] = side + 1;\\n            if (num == space)\\n                res = btrack(1, side, done+1, M);\\n            else\\n                res = btrack(i+1, space-num, done, M);\\n            if (res)\\n                return true;\\n            M[i] = num;\\n            while (i < M.size() and M[i+1] == num)\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar makesquare = function(M) {\\n    let n = M.length, side = M.reduce((a,c) => a + c) / 4\\n    M.sort((a,b) => b - a)\\n    if (side !== ~~side || M[0] > side)\\n        return false\\n    const btrack = (i, space, done) => {\\n        if (done === 3)\\n            return true\\n        for (; i < n; i++) {\\n            let num = M[i], res\\n            if (num > space)\\n                continue\\n            M[i] = side + 1\\n            if (num === space)\\n                res = btrack(1, side, done+1)\\n            else\\n                res = btrack(i+1, space-num, done)\\n            if (res)\\n                return true\\n            M[i] = num\\n            while (M[i+1] === num)\\n                i++\\n        }\\n        return false\\n    }\\n    return btrack(0, side, 0)\\n};\\n```\n```python\\nclass Solution:\\n    def makesquare(self, M: List[int]) -> bool:\\n        n, side = len(M), sum(M) / 4\\n        M.sort(reverse=True)\\n        if side != int(side) or M[0] > side:\\n            return False\\n        def btrack(i, space, done): \\n            if done == 3:\\n                return True\\n            while i < n:\\n                num = M[i]\\n                if num > space:\\n                    i += 1\\n                    continue\\n                M[i] = side + 1\\n                if num == space:\\n                    res = btrack(1, side, done+1)\\n                else:\\n                    res = btrack(i+1, space-num, done)\\n                if res:\\n                    return True\\n                M[i] = num\\n                while i < n and M[i] == num:\\n                    i += 1\\n            return False\\n        return btrack(0, side, 0)\\n```\n```java\\nclass Solution {\\n    public boolean makesquare(int[] M) {\\n        Arrays.sort(M);\\n        int total = 0;\\n        for (int i = 0; i < M.length; i++)\\n            total += M[i];\\n        side = total / 4;\\n        if ((float)total / 4 > side || M[M.length-1] > side)\\n            return false;\\n        return btrack(M.length-1, side, 0, M);\\n    }\\n    private int side;\\n    private boolean btrack(int i, int space, int done, int[] M) {\\n        if (done == 3)\\n            return true;\\n        for (; i >= 0; i--) {\\n            int num = M[i];\\n            boolean res;\\n            if (num > space)\\n                continue;\\n            M[i] = side + 1;\\n            if (num == space)\\n                res = btrack(M.length-2, side, done+1, M);\\n            else\\n                res = btrack(i-1, space-num, done, M);\\n            if (res)\\n                return true;\\n            M[i] = num;\\n            while (i > 0 && M[i-1] == num)\\n                i--;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& M) {\\n        sort(M.begin(), M.end(), greater<int>());\\n        int total = accumulate(M.begin(), M.end(), 0);\\n        side = total / 4;\\n        if ((float)total / 4 > side || M[0] > side)\\n            return false;\\n        return btrack(0, side, 0, M);\\n    }\\nprivate:\\n    int side;\\n    bool btrack(int i, int space, int done, vector<int>& M) {\\n        if (done == 3)\\n            return true;\\n        for (; i < M.size(); i++) {\\n            int num = M[i];\\n            bool res;\\n            if (num > space)\\n                continue;\\n            M[i] = side + 1;\\n            if (num == space)\\n                res = btrack(1, side, done+1, M);\\n            else\\n                res = btrack(i+1, space-num, done, M);\\n            if (res)\\n                return true;\\n            M[i] = num;\\n            while (i < M.size() and M[i+1] == num)\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369073,
                "title": "backtracking-thinking-process",
                "content": "Each matchstick can be part of any one of four sides. We should try all possibilities.\\n\\nThe goal state is that matchsticks are exhausted, and the lenght of each side is `perimeter / 4`.\\n\\nBrute force is natural in this case. \\n\\nWe may sort matchsticks decreasingly, and insist on a choice only if `sums[i] + matchsticks[cur] <= perimeter / 4`. That helps eliminate choices that are obviously not possible early.\\n\\nThat\\'s refined brute froce, so-called backtracking.\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        perimeter = sum(matchsticks)\\n        if perimeter % 4 != 0:\\n            return False\\n        possible_side = perimeter / 4\\n        \\n        matchsticks.sort(reverse=True)\\n        sums = [0, 0, 0, 0]\\n        \\n        def dfs(cur):\\n            if cur == len(matchsticks):\\n                return sums[0] == sums[1] == sums[2] == possible_side\\n            \\n            for i in range(4):\\n                if sums[i] + matchsticks[cur] <= possible_side:\\n                    sums[i] += matchsticks[cur]\\n                    if dfs(cur + 1):\\n                        return True\\n                    sums[i] -= matchsticks[cur]\\n                \\n            return False\\n\\n        return dfs(0)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        perimeter = sum(matchsticks)\\n        if perimeter % 4 != 0:\\n            return False\\n        possible_side = perimeter / 4\\n        \\n        matchsticks.sort(reverse=True)\\n        sums = [0, 0, 0, 0]\\n        \\n        def dfs(cur):\\n            if cur == len(matchsticks):\\n                return sums[0] == sums[1] == sums[2] == possible_side\\n            \\n            for i in range(4):\\n                if sums[i] + matchsticks[cur] <= possible_side:\\n                    sums[i] += matchsticks[cur]\\n                    if dfs(cur + 1):\\n                        return True\\n                    sums[i] -= matchsticks[cur]\\n                \\n            return False\\n\\n        return dfs(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274063,
                "title": "matchsticks-to-square-solution-with-explanation-optimisations",
                "content": "***\\u2705 Solution (Using BackTracking)***\\n\\n```\\n# Intuition:\\nLets see some of the finding from the question.\\n1. We need to build a square using all the matchsticks.\\n2. As we know,Every side of square is equal.\\n3. It means one side length == Parameter Of Square / 4\\n* If we carefully observe, parameter == sum of all sides\\n* We have given sides information in the form of matchsticks array,\\n* So parameter is nothing but Sum(All elements in matchsticks Array).\\n* Now the equation become oneSideLength = Sum(All elements in matchsticks Array) / 4\\n\\nNow from the above points,we can observe that, eachSideLength = TotalSum / 4,\\nwhich means we need to divide all the matchsticks into 4 subsets with equal sum.\\n```\\n```\\n# INVALID CASE:\\nIf total sum of matchsticks array is not divisible by 4, then we are sure that matchsticks elements can not be equally divided into 4 subsets.\\n```\\n\\n***Corner Cases to consider:***\\n```\\n1. If you write normal recursion code without pruning then it will fail,\\n2. we need to have some pruning steps.\\n* If we have choosen one matchstick for 1 side of square then we cannot consider this matchstick for forming other sides.\\n* it means if we visit one matchstick then we cannot visit it again.\\n* For checking this we can have a boolean array or Bitset, which will tell whether the matchstick element is taken or not.\\n```\\n```\\n# Options:\\n1. If we carefully observe then, every matchstick is having option to be choosen or not choosen(BackTracking Step)\\n2. We will first check possibility by choosing the matchstick and in backtrack step we will mark it as unchoosen.\\n3. Each matchstick has option to occur in any of the 4 subsets (i.e, to form any of the 4 sides),\\nso we need to consider this as well.\\n\\nFor more clarity, please see the solution below.\\n```\\n\\n**C++:**\\n```\\nclass Solution {\\n    public:\\n    bool vis[16];\\n    bool canMakeSquare(vector < int > & matchsticks, int currentSum, int oneSideLength, int totalSides, int idx = 0) {\\n        if (totalSides == 0)\\n            return true;\\n        if (currentSum == oneSideLength)\\n            return canMakeSquare(matchsticks, 0, oneSideLength, totalSides - 1, 0);\\n        if (idx >= size(matchsticks))\\n            return false;\\n        for (int i = idx; i < size(matchsticks); i++) {\\n            if (!vis[i]) {\\n                if (currentSum + matchsticks[i] <= oneSideLength) {\\n                    vis[i] = true;\\n                    if (canMakeSquare(matchsticks, currentSum + matchsticks[i], oneSideLength, totalSides, i + 1))\\n                        return true;\\n                    vis[i] = false;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool makesquare(vector < int > & matchsticks) {\\n        memset(vis, false, sizeof(vis));\\n        int sum = 0;\\n        for (int i: matchsticks)\\n            sum += i;\\n        if (sum % 4)\\n            return false;\\n        int oneSideLength = sum / 4;\\n        int totalSides = 4;\\n        return canMakeSquare(matchsticks, 0, oneSideLength, totalSides);\\n\\n    }\\n};\\n```\\n***NOTE: We can do one more optimisation though:***\\n```\\nsort the matchsticks elements into descending order,\\nso that the matchsticks with larger value will be picked up early.\\nRest everything will be the same.\\n\\n bool makesquare(vector < int > & matchsticks) {\\n        sort(matchsticks.rbegin(),matchsticks.rend());\\n        memset(vis, false, sizeof(vis));\\n        int sum = 0;\\n        for (int i: matchsticks)\\n            sum += i;\\n        if (sum % 4)\\n            return false;\\n        int oneSideLength = sum / 4;\\n        int totalSides = 4;\\n        return canMakeSquare(matchsticks, 0, oneSideLength, totalSides);\\n\\n    }\\n```\\n\\n***We can do one more optimisation related to subsets:***\\n```\\nIf we already formed 3 subsets with equal sum then we are sure that the 4th subset will also be equal.\\n```\\n```\\nbool canMakeSquare(vector < int > & matchsticks, int currentSum, int oneSideLength, int totalSides, int idx = 0) {\\n        if (totalSides == 1) // This is the optimisation\\n            return true;\\n        if (currentSum == oneSideLength)\\n            return canMakeSquare(matchsticks, 0, oneSideLength, totalSides - 1, 0);\\n        if (idx >= size(matchsticks))\\n            return false;\\n        for (int i = idx; i < size(matchsticks); i++) {\\n            if (!vis[i]) {\\n                if (currentSum + matchsticks[i] <= oneSideLength) {\\n                    vis[i] = true;\\n                    if (canMakeSquare(matchsticks, currentSum + matchsticks[i], oneSideLength, totalSides, i + 1))\\n                        return true;\\n                    vis[i] = false;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n# Intuition:\\nLets see some of the finding from the question.\\n1. We need to build a square using all the matchsticks.\\n2. As we know,Every side of square is equal.\\n3. It means one side length == Parameter Of Square / 4\\n* If we carefully observe, parameter == sum of all sides\\n* We have given sides information in the form of matchsticks array,\\n* So parameter is nothing but Sum(All elements in matchsticks Array).\\n* Now the equation become oneSideLength = Sum(All elements in matchsticks Array) / 4\\n\\nNow from the above points,we can observe that, eachSideLength = TotalSum / 4,\\nwhich means we need to divide all the matchsticks into 4 subsets with equal sum.\\n```\n```\\n# INVALID CASE:\\nIf total sum of matchsticks array is not divisible by 4, then we are sure that matchsticks elements can not be equally divided into 4 subsets.\\n```\n```\\n1. If you write normal recursion code without pruning then it will fail,\\n2. we need to have some pruning steps.\\n* If we have choosen one matchstick for 1 side of square then we cannot consider this matchstick for forming other sides.\\n* it means if we visit one matchstick then we cannot visit it again.\\n* For checking this we can have a boolean array or Bitset, which will tell whether the matchstick element is taken or not.\\n```\n```\\n# Options:\\n1. If we carefully observe then, every matchstick is having option to be choosen or not choosen(BackTracking Step)\\n2. We will first check possibility by choosing the matchstick and in backtrack step we will mark it as unchoosen.\\n3. Each matchstick has option to occur in any of the 4 subsets (i.e, to form any of the 4 sides),\\nso we need to consider this as well.\\n\\nFor more clarity, please see the solution below.\\n```\n```\\nclass Solution {\\n    public:\\n    bool vis[16];\\n    bool canMakeSquare(vector < int > & matchsticks, int currentSum, int oneSideLength, int totalSides, int idx = 0) {\\n        if (totalSides == 0)\\n            return true;\\n        if (currentSum == oneSideLength)\\n            return canMakeSquare(matchsticks, 0, oneSideLength, totalSides - 1, 0);\\n        if (idx >= size(matchsticks))\\n            return false;\\n        for (int i = idx; i < size(matchsticks); i++) {\\n            if (!vis[i]) {\\n                if (currentSum + matchsticks[i] <= oneSideLength) {\\n                    vis[i] = true;\\n                    if (canMakeSquare(matchsticks, currentSum + matchsticks[i], oneSideLength, totalSides, i + 1))\\n                        return true;\\n                    vis[i] = false;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool makesquare(vector < int > & matchsticks) {\\n        memset(vis, false, sizeof(vis));\\n        int sum = 0;\\n        for (int i: matchsticks)\\n            sum += i;\\n        if (sum % 4)\\n            return false;\\n        int oneSideLength = sum / 4;\\n        int totalSides = 4;\\n        return canMakeSquare(matchsticks, 0, oneSideLength, totalSides);\\n\\n    }\\n};\\n```\n```\\nsort the matchsticks elements into descending order,\\nso that the matchsticks with larger value will be picked up early.\\nRest everything will be the same.\\n\\n bool makesquare(vector < int > & matchsticks) {\\n        sort(matchsticks.rbegin(),matchsticks.rend());\\n        memset(vis, false, sizeof(vis));\\n        int sum = 0;\\n        for (int i: matchsticks)\\n            sum += i;\\n        if (sum % 4)\\n            return false;\\n        int oneSideLength = sum / 4;\\n        int totalSides = 4;\\n        return canMakeSquare(matchsticks, 0, oneSideLength, totalSides);\\n\\n    }\\n```\n```\\nIf we already formed 3 subsets with equal sum then we are sure that the 4th subset will also be equal.\\n```\n```\\nbool canMakeSquare(vector < int > & matchsticks, int currentSum, int oneSideLength, int totalSides, int idx = 0) {\\n        if (totalSides == 1) // This is the optimisation\\n            return true;\\n        if (currentSum == oneSideLength)\\n            return canMakeSquare(matchsticks, 0, oneSideLength, totalSides - 1, 0);\\n        if (idx >= size(matchsticks))\\n            return false;\\n        for (int i = idx; i < size(matchsticks); i++) {\\n            if (!vis[i]) {\\n                if (currentSum + matchsticks[i] <= oneSideLength) {\\n                    vis[i] = true;\\n                    if (canMakeSquare(matchsticks, currentSum + matchsticks[i], oneSideLength, totalSides, i + 1))\\n                        return true;\\n                    vis[i] = false;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95787,
                "title": "python-explanation",
                "content": "If the sum isn't divisible by 4, or if there are less than 4 matchsticks, or if one matchstick is greater than the expected sidelength, then it is impossible.\\n\\nOtherwise, let's see if it is possible to partition the set into 4 equal parts.  We do this by bitmask dp.  Let the i-th position of mask be 1 if we have not used A[i] yet, and let cur represent the length of an unfilled sidelength we have yet to fill.\\n\\nCode:\\n```\\nif len(A) < 4 or sum(A) % 4 or max(A) > sum(A) / 4:\\n  return False\\n\\nT = sum(A) / 4\\nN = len(A)\\nA.sort()\\n\\nmemo = {}\\ndef dp(mask, cur = T):\\n  if (mask, cur) in memo: return memo[mask, cur]\\n  if mask == 0: return cur == 0\\n  if cur == 0: return dp(mask, T)\\n\\n  ans = False\\n  for bit in xrange(N):\\n    if mask & (1 << bit):\\n      if A[bit] > cur:\\n        break\\n      if dp(mask ^ (1 << bit), cur - A[bit]):\\n        ans = True\\n        break\\n  memo[mask, cur] = ans\\n  return ans\\n\\nreturn dp(2**N - 1)\\n```",
                "solutionTags": [],
                "code": "```\\nif len(A) < 4 or sum(A) % 4 or max(A) > sum(A) / 4:\\n  return False\\n\\nT = sum(A) / 4\\nN = len(A)\\nA.sort()\\n\\nmemo = {}\\ndef dp(mask, cur = T):\\n  if (mask, cur) in memo: return memo[mask, cur]\\n  if mask == 0: return cur == 0\\n  if cur == 0: return dp(mask, T)\\n\\n  ans = False\\n  for bit in xrange(N):\\n    if mask & (1 << bit):\\n      if A[bit] > cur:\\n        break\\n      if dp(mask ^ (1 << bit), cur - A[bit]):\\n        ans = True\\n        break\\n  memo[mask, cur] = ans\\n  return ans\\n\\nreturn dp(2**N - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1273924,
                "title": "easy-to-understand-java-solution-explanation-with-comments-with-dfs",
                "content": "```\\nclass Solution {\\n    \\n    public boolean makesquare(int[] matchsticks) {\\n        \\n        \\n        /*  Approach:\\n        \\n            We will use DFS to search for all combinations where my sticks can form a square\\n        \\n        */\\n        \\n        \\n        // If no. of matchsticks are less than 4, then cannot form square.\\n        \\n        if (matchsticks == null || matchsticks.length < 4) {\\n            return false;\\n        }\\n        \\n        // Calculate sum of length of every sticks.\\n        \\n        int sum = 0;\\n        for (int stick : matchsticks)    sum = sum + stick;\\n        \\n        // Every side of square should have same length, so overall sum should be multiple of 4\\n        \\n        if (sum % 4 != 0) {\\n            return false;\\n        }\\n        \\n        /*  DFS:\\n            \\n            - We will send the current length of 4 sides of the squares to DFS. \\n              ( Intially we send length of all sides of squares as 0 )\\n\\n            - We will send array matchsticks and sum/4 of matchsticks to DFS\\n              ( It will remain static always in DFS and just used for checking purpose)\\n\\n            - We will send currIndex of array to DFS.\\n              ( Initially 0 -> arr[0].  Everytime, we use A[currIndex] and increment for further DFS)\\n              \\n              Whenever, \\n            \\n        */\\n        \\n        int side1 = 0, side2 = 0, side3 = 0, side4 = 0, currIndex = 0;\\n        \\n        int oneSideLen = sum/4;\\n        \\n        return dfs (side1, side2, side3, side4, matchsticks, currIndex, oneSideLen);\\n        \\n    }\\n    \\n    \\n    // DFS function to return if len of 4 sides are equal and sum up to total_sum/4 when arr ends.\\n    \\n    public boolean dfs (int s1, int s2, int s3, int s4, int arr[], int k, int len) {\\n        \\n        // If any of the side is more than Side Length of square needed, return false.\\n        \\n        if (s1 > len || s2 > len || s3 > len || s4 > len) {\\n            return false;\\n        }\\n        \\n        // If match sticks completed, i.e. index k crosses from 0 to n-1 and reaches n.\\n        \\n        if (k == arr.length) {\\n            \\n            /* Either all sides are equal (then it automatically sums upto len. as every element is used)\\n               Then return true, else false (not possile as arr completes and sides are not equal)\\n            */\\n            \\n            return s1 == s2 && s2 == s3 && s3 == s4;\\n            \\n        }\\n        \\n        \\n        // Call recursive DFS by adding curr element to sides one by one. \\n        // If any combination is true, return true.\\n        \\n        return (dfs (s1 + arr[k], s2         , s3         , s4         , arr, k + 1, len) ||\\n                dfs (s1         , s2 + arr[k], s3         , s4         , arr, k + 1, len) ||\\n                dfs (s1         , s2         , s3 + arr[k], s4         , arr, k + 1, len) ||\\n                dfs (s1         , s2         , s3         , s4 + arr[k], arr, k + 1, len));\\n    }\\n    \\n    \\n}\\n```\\n\\n**Please Upvote if you find it helpful. Happy Coding!**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean makesquare(int[] matchsticks) {\\n        \\n        \\n        /*  Approach:\\n        \\n            We will use DFS to search for all combinations where my sticks can form a square\\n        \\n        */\\n        \\n        \\n        // If no. of matchsticks are less than 4, then cannot form square.\\n        \\n        if (matchsticks == null || matchsticks.length < 4) {\\n            return false;\\n        }\\n        \\n        // Calculate sum of length of every sticks.\\n        \\n        int sum = 0;\\n        for (int stick : matchsticks)    sum = sum + stick;\\n        \\n        // Every side of square should have same length, so overall sum should be multiple of 4\\n        \\n        if (sum % 4 != 0) {\\n            return false;\\n        }\\n        \\n        /*  DFS:\\n            \\n            - We will send the current length of 4 sides of the squares to DFS. \\n              ( Intially we send length of all sides of squares as 0 )\\n\\n            - We will send array matchsticks and sum/4 of matchsticks to DFS\\n              ( It will remain static always in DFS and just used for checking purpose)\\n\\n            - We will send currIndex of array to DFS.\\n              ( Initially 0 -> arr[0].  Everytime, we use A[currIndex] and increment for further DFS)\\n              \\n              Whenever, \\n            \\n        */\\n        \\n        int side1 = 0, side2 = 0, side3 = 0, side4 = 0, currIndex = 0;\\n        \\n        int oneSideLen = sum/4;\\n        \\n        return dfs (side1, side2, side3, side4, matchsticks, currIndex, oneSideLen);\\n        \\n    }\\n    \\n    \\n    // DFS function to return if len of 4 sides are equal and sum up to total_sum/4 when arr ends.\\n    \\n    public boolean dfs (int s1, int s2, int s3, int s4, int arr[], int k, int len) {\\n        \\n        // If any of the side is more than Side Length of square needed, return false.\\n        \\n        if (s1 > len || s2 > len || s3 > len || s4 > len) {\\n            return false;\\n        }\\n        \\n        // If match sticks completed, i.e. index k crosses from 0 to n-1 and reaches n.\\n        \\n        if (k == arr.length) {\\n            \\n            /* Either all sides are equal (then it automatically sums upto len. as every element is used)\\n               Then return true, else false (not possile as arr completes and sides are not equal)\\n            */\\n            \\n            return s1 == s2 && s2 == s3 && s3 == s4;\\n            \\n        }\\n        \\n        \\n        // Call recursive DFS by adding curr element to sides one by one. \\n        // If any combination is true, return true.\\n        \\n        return (dfs (s1 + arr[k], s2         , s3         , s4         , arr, k + 1, len) ||\\n                dfs (s1         , s2 + arr[k], s3         , s4         , arr, k + 1, len) ||\\n                dfs (s1         , s2         , s3 + arr[k], s4         , arr, k + 1, len) ||\\n                dfs (s1         , s2         , s3         , s4 + arr[k], arr, k + 1, len));\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269763,
                "title": "c-o-2-n-dp-bitmask-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int getsum;\\n    vector<int> t;\\n    bool makesquare(vector<int>& a) {\\n        int sum=accumulate(a.begin(),a.end(),0);\\n        if(sum%4) \\n            return false;\\n        getsum=sum/4;\\n        t.resize(1<<(a.size()+1),-1);\\n        return solve(a,4,0,0,0);\\n    }\\n    bool solve(vector<int>& a, int k, int cursum, int mask, int i){\\n        if(k==1) // 3 sides have sum%4 then automatically 4 side will also equals to sum%4\\n            return true;\\n        if(i>=a.size())\\n            return false;\\n        if(t[mask]!=-1)\\n            return t[mask];\\n        if(cursum==getsum)\\n            return t[mask]=solve(a,k-1,0,mask,0); // If one is done we try to find for next side\\n        for(int j=i; j<a.size(); j++){\\n\\t\\t\\t//!(mask&(1<<j)) -> to check whether this matchstick has been chosen earlier \\n            if(!(mask&(1<<j)) and a[j]+cursum<=getsum and solve(a,k, a[j]+cursum,mask|(1<<j),j+1))\\n                return t[mask]=true;\\n        }\\n        return t[mask]=false;\\n    }\\n};\\n```\\nSame problem : https://leetcode.com/problems/partition-to-k-equal-sum-subsets/",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getsum;\\n    vector<int> t;\\n    bool makesquare(vector<int>& a) {\\n        int sum=accumulate(a.begin(),a.end(),0);\\n        if(sum%4) \\n            return false;\\n        getsum=sum/4;\\n        t.resize(1<<(a.size()+1),-1);\\n        return solve(a,4,0,0,0);\\n    }\\n    bool solve(vector<int>& a, int k, int cursum, int mask, int i){\\n        if(k==1) // 3 sides have sum%4 then automatically 4 side will also equals to sum%4\\n            return true;\\n        if(i>=a.size())\\n            return false;\\n        if(t[mask]!=-1)\\n            return t[mask];\\n        if(cursum==getsum)\\n            return t[mask]=solve(a,k-1,0,mask,0); // If one is done we try to find for next side\\n        for(int j=i; j<a.size(); j++){\\n\\t\\t\\t//!(mask&(1<<j)) -> to check whether this matchstick has been chosen earlier \\n            if(!(mask&(1<<j)) and a[j]+cursum<=getsum and solve(a,k, a[j]+cursum,mask|(1<<j),j+1))\\n                return t[mask]=true;\\n        }\\n        return t[mask]=false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352617,
                "title": "beats-100-java-solutions-1-ms-dfs-without-reversing-the-array",
                "content": "```\\nclass Solution {\\n    public boolean makesquare(int[] nums) {\\n        if(nums==null || nums.length==0) return false;\\n        int sum=0;\\n        for(int num:nums) sum+=num;\\n        if(sum%4!=0) return false;\\n        Arrays.sort(nums);\\n        return dfs(nums,new int[4],nums.length-1,sum/4);\\n    }\\n    boolean dfs(int[] nums,int[] sums,int index,int target){\\n        if(index==-1) return true;\\n        for(int i=0;i<4;i++){\\n            if((sums[i]+nums[index]>target) || (i>0 && sums[i]==sums[i-1])) continue;\\n            sums[i]+=nums[index];\\n            if(dfs(nums,sums,index-1,target)) return true;\\n            sums[i]-=nums[index];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] nums) {\\n        if(nums==null || nums.length==0) return false;\\n        int sum=0;\\n        for(int num:nums) sum+=num;\\n        if(sum%4!=0) return false;\\n        Arrays.sort(nums);\\n        return dfs(nums,new int[4],nums.length-1,sum/4);\\n    }\\n    boolean dfs(int[] nums,int[] sums,int index,int target){\\n        if(index==-1) return true;\\n        for(int i=0;i<4;i++){\\n            if((sums[i]+nums[index]>target) || (i>0 && sums[i]==sums[i-1])) continue;\\n            sums[i]+=nums[index];\\n            if(dfs(nums,sums,index-1,target)) return true;\\n            sums[i]-=nums[index];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95764,
                "title": "simple-recursion-java-solution-66ms",
                "content": "Since it is square, the basic idea is get width of each side(total 4 sides) and use recursive way to figure out which group each matchstick belongs. \\n``````\\npublic boolean makesquare(int[] nums) {\\n        Long sum=0l;\\n        for(int x:nums){\\n            sum=sum+x;\\n        }\\n        if(sum%4!=0||nums.length<4) return false;\\n        long width=(sum/4);\\n        Arrays.sort(nums);\\n        long sum1=0,sum2=0,sum3=0,sum4=0;\\n        return helper(nums,nums.length-1,sum1,sum2,sum3,sum4,width);\\n        \\n    }\\n    public boolean helper(int[] a, int i,long sum1,long sum2,long sum3,long sum4, long width){\\n        if(sum1>width||sum2>width||sum3>width||sum4>width) return false;\\n        if(i==-1){\\n            if(sum1==width&&sum2==width&&sum3==width&&sum4==width) return true;\\n            else return false;\\n        }\\n//check a[i]  belonging to side1,side2,side3,side4\\n        return helper(a,i-1,sum1+a[i],sum2,sum3,sum4,width)||\\n        helper(a,i-1,sum1,sum2+a[i],sum3,sum4,width)||\\n        helper(a,i-1,sum1,sum2,sum3+a[i],sum4,width)||\\n        helper(a,i-1,sum1,sum2,sum3,sum4+a[i],width);\\n    }\\n````",
                "solutionTags": [],
                "code": "``````",
                "codeTag": "Unknown"
            },
            {
                "id": 2270580,
                "title": "python-99-faster-95-space-efficient-solution-with-different-approaches",
                "content": "# Don\\'t Forget to Upvote\\n\\n# 1 Most time efficient solution:\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef makesquare(self, matchsticks: List[int]) -> bool:\\n\\t\\t\\t\\ttotal = sum(matchsticks)\\n\\t\\t\\t\\tif total % 4:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ttarget = total >> 2\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tfor n in matchsticks:\\n\\t\\t\\t\\t\\tif n > target:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telif n < target:\\n\\t\\t\\t\\t\\t\\tnums.append(n)\\n\\n\\t\\t\\t\\tif nums == []:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tk = 4 - (len(matchsticks) - len(nums))\\n\\t\\t\\t\\tnums.sort(reverse=True)\\n\\t\\t\\t\\tused = [False] * len(nums)\\n\\n\\t\\t\\t\\tdef helper(nums, used, start, target, sum, k):\\n\\t\\t\\t\\t\\tif k == 1:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\t\\ti = start\\n\\t\\t\\t\\t\\twhile i < len(nums):\\n\\t\\t\\t\\t\\t\\tif not used[i]:\\n\\t\\t\\t\\t\\t\\t\\tused[i] = True\\n\\t\\t\\t\\t\\t\\t\\tif sum + nums[i] < target and helper(nums, used, i + 1, target, sum + nums[i], k):\\n\\t\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\t\\tif sum + nums[i] == target and helper(nums, used, 0, target, 0, k - 1):\\n\\t\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\t\\tused[i] = False\\n\\t\\t\\t\\t\\t\\t\\twhile i + 1 < len(nums) and nums[i + 1] == nums[i]:\\n\\t\\t\\t\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\t\\t\\t\\tif sum == 0:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn helper(nums, used, 0, target, 0, k)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 2 A good memory efficient solution:\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef makesquare(self, matchsticks: List[int]) -> bool:\\n\\t\\t\\t\\tperimeter = sum(matchsticks)\\n\\n\\t\\t\\t\\tside = perimeter // 4\\n\\t\\t\\t\\tif side * 4 != perimeter:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tmatchsticks.sort(reverse = True)\\n\\t\\t\\t\\tres = [0 for _ in range(4)]\\n\\n\\t\\t\\t\\tdef backtrack(index):\\n\\t\\t\\t\\t\\tif index == len(matchsticks):\\n\\t\\t\\t\\t\\t\\treturn side == res[0] == res[1] == res[2]\\n\\n\\t\\t\\t\\t\\tfor i in range(4):\\n\\t\\t\\t\\t\\t\\tif res[i] + matchsticks[index] <= side:\\n\\t\\t\\t\\t\\t\\t\\tres[i] += matchsticks[index]\\n\\t\\t\\t\\t\\t\\t\\tret = backtrack(index + 1)\\n\\t\\t\\t\\t\\t\\t\\tif ret:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\t\\tres[i] -= matchsticks[index]\\n\\n\\t\\t\\t\\t\\t\\t\\tif res[i] == 0:\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn backtrack(0)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "# Don\\'t Forget to Upvote\\n\\n# 1 Most time efficient solution:\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef makesquare(self, matchsticks: List[int]) -> bool:\\n\\t\\t\\t\\ttotal = sum(matchsticks)\\n\\t\\t\\t\\tif total % 4:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ttarget = total >> 2\\n\\t\\t\\t\\tnums = []\\n\\t\\t\\t\\tfor n in matchsticks:\\n\\t\\t\\t\\t\\tif n > target:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telif n < target:\\n\\t\\t\\t\\t\\t\\tnums.append(n)\\n\\n\\t\\t\\t\\tif nums == []:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tk = 4 - (len(matchsticks) - len(nums))\\n\\t\\t\\t\\tnums.sort(reverse=True)\\n\\t\\t\\t\\tused = [False] * len(nums)\\n\\n\\t\\t\\t\\tdef helper(nums, used, start, target, sum, k):\\n\\t\\t\\t\\t\\tif k == 1:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\t\\ti = start\\n\\t\\t\\t\\t\\twhile i < len(nums):\\n\\t\\t\\t\\t\\t\\tif not used[i]:\\n\\t\\t\\t\\t\\t\\t\\tused[i] = True\\n\\t\\t\\t\\t\\t\\t\\tif sum + nums[i] < target and helper(nums, used, i + 1, target, sum + nums[i], k):\\n\\t\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\t\\tif sum + nums[i] == target and helper(nums, used, 0, target, 0, k - 1):\\n\\t\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\t\\tused[i] = False\\n\\t\\t\\t\\t\\t\\t\\twhile i + 1 < len(nums) and nums[i + 1] == nums[i]:\\n\\t\\t\\t\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\t\\t\\t\\tif sum == 0:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn helper(nums, used, 0, target, 0, k)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 2 A good memory efficient solution:\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef makesquare(self, matchsticks: List[int]) -> bool:\\n\\t\\t\\t\\tperimeter = sum(matchsticks)\\n\\n\\t\\t\\t\\tside = perimeter // 4\\n\\t\\t\\t\\tif side * 4 != perimeter:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tmatchsticks.sort(reverse = True)\\n\\t\\t\\t\\tres = [0 for _ in range(4)]\\n\\n\\t\\t\\t\\tdef backtrack(index):\\n\\t\\t\\t\\t\\tif index == len(matchsticks):\\n\\t\\t\\t\\t\\t\\treturn side == res[0] == res[1] == res[2]\\n\\n\\t\\t\\t\\t\\tfor i in range(4):\\n\\t\\t\\t\\t\\t\\tif res[i] + matchsticks[index] <= side:\\n\\t\\t\\t\\t\\t\\t\\tres[i] += matchsticks[index]\\n\\t\\t\\t\\t\\t\\t\\tret = backtrack(index + 1)\\n\\t\\t\\t\\t\\t\\t\\tif ret:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\t\\tres[i] -= matchsticks[index]\\n\\n\\t\\t\\t\\t\\t\\t\\tif res[i] == 0:\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn backtrack(0)",
                "codeTag": "Java"
            },
            {
                "id": 2270458,
                "title": "java-1ms-solution-beats-100-dfs-easy-understanding-w-video-explanation",
                "content": "*Please **upvote** if you find the solution helpful*\\n\\n**Video Explanation**\\n[Matchsticks to Square | YouTube](https://www.youtube.com/watch?v=oMAeBWdIJ2o)\\n\\n**Java Solution**\\n```\\n//1ms\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        if(matchsticks == null || matchsticks.length == 0)return false;\\n        int sum =0;\\n        for(int num:matchsticks)sum+=num;\\n        \\n        if(sum%4!=0)return false;\\n        \\n        Arrays.sort(matchsticks);\\n        \\n        return dfs(matchsticks,new int[4], matchsticks.length-1,sum/4);\\n    }\\n    \\n    boolean dfs(int[] matchsticks, int sum[], int index,int target){\\n        if(index == -1)return true;\\n        \\n        for(int i=0;i<4;i++){\\n            if((sum[i] + matchsticks[index]>target) || (i>0 && sum[i] == sum[i-1]))continue;\\n            \\n            sum[i]+=matchsticks[index];\\n            \\n            if(dfs(matchsticks,sum,index-1,target))return true;\\n            sum[i]-= matchsticks[index];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\n//1ms\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        if(matchsticks == null || matchsticks.length == 0)return false;\\n        int sum =0;\\n        for(int num:matchsticks)sum+=num;\\n        \\n        if(sum%4!=0)return false;\\n        \\n        Arrays.sort(matchsticks);\\n        \\n        return dfs(matchsticks,new int[4], matchsticks.length-1,sum/4);\\n    }\\n    \\n    boolean dfs(int[] matchsticks, int sum[], int index,int target){\\n        if(index == -1)return true;\\n        \\n        for(int i=0;i<4;i++){\\n            if((sum[i] + matchsticks[index]>target) || (i>0 && sum[i] == sum[i-1]))continue;\\n            \\n            sum[i]+=matchsticks[index];\\n            \\n            if(dfs(matchsticks,sum,index-1,target))return true;\\n            sum[i]-= matchsticks[index];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272610,
                "title": "backtracking-explained-with-image-commented",
                "content": "Upvote if you found it helpful <3\\n<hr />\\n\\nThis problem is a variation of the [bin packing](https://en.wikipedia.org/wiki/Bin_packing_problem) problem which is a NP-complete problem, therefore a polynomial solution isn\\'t possible.\\n\\n# Intuition\\nThe first thing to identify is the square side size. We know that the square has 4 equal sides, therefore `sum/4` is the size of each side.\\n\\nEvery element in our matchsticks array can be part of multiple sides.\\n\\nFor example we can form a side of size 3 with: [2,1] or [1,1,1]\\n\\nWe don\\'t know which one will form our solution. So we need to run a **backtracking** algorithm to check all the possible solutions.\\n\\nWe will create a `square_sides` array of size 4, which will count the size of the sides. \\n\\nEvery more in the backtracking algorithm, we will try to fill one of the sides and progress our search space, if we don\\'t find the answer, we backtrack and repeat.\\n\\n## Image of recursion tree\\nThe following image aims to help you understand the path that the recursion takes. I\\'ve skipped some of the steps as the complexity is `O(4^n)` but this should give you the general idea.\\n\\nThe arrays you see is the `square_sides` array that we are trying to fill.\\n\\n\\nInput for the example: `[2,1,1,2,2]`. Side size = `2`\\n\\n\\n![image](https://assets.leetcode.com/users/images/a889e218-e791-48fb-b1de-68423b02d1da_1657633663.7431076.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        \\n        # We don\\'t even have 4 matchsticks to form a square\\n        if n < 4:\\n            return False\\n    \\n        matchsticks_sum = sum(matchsticks)\\n        \\n        # Can\\'t divide into 4 equal sides\\n        if matchsticks_sum % 4 != 0:\\n            return False\\n        \\n        # The size of each side\\n        side = matchsticks_sum // 4\\n        \\n        # Simulate the square. We will fill the sies in the DFS\\n        square_sides = [0,0,0,0]\\n        \\n        # Sort to optimize the DFS by exiting early because we will start with the biggest elements\\n        matchsticks.sort(reverse=True)\\n        \\n        def dfs(i):\\n            if i == n:\\n                side_a = square_sides[0]\\n                side_b = square_sides[1] \\n                side_c = square_sides[2] \\n                side_d = square_sides[3] \\n                \\n                # Return true only if all sides are equal to the \"side\" size we are looking for\\n                return side == side_a == side_b == side_c == side_d\\n        \\n            for side_i in range(4):\\n                \\n                if square_sides[side_i] + matchsticks[i] > side:\\n                    continue\\n                    \\n                # Add the matchstick size to the side of the box\\n                square_sides[side_i] += matchsticks[i]\\n                \\n                if dfs(i + 1):\\n                    return True\\n                \\n                # Backtrack if we didn\\'t find the answer\\n                square_sides[side_i] -= matchsticks[i]\\n            \\n            return False\\n        \\n        \\n        return dfs(0)\\n```\\n\\n\\n# Complexity analysis\\n* Time - O(4^n). In every move we branch into 4 recursive calls, therefore our branching factor is 4. And our tree depth is n.\\n\\n* Space - O(n). The depth of the recursion stack is at max O(n).",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        \\n        # We don\\'t even have 4 matchsticks to form a square\\n        if n < 4:\\n            return False\\n    \\n        matchsticks_sum = sum(matchsticks)\\n        \\n        # Can\\'t divide into 4 equal sides\\n        if matchsticks_sum % 4 != 0:\\n            return False\\n        \\n        # The size of each side\\n        side = matchsticks_sum // 4\\n        \\n        # Simulate the square. We will fill the sies in the DFS\\n        square_sides = [0,0,0,0]\\n        \\n        # Sort to optimize the DFS by exiting early because we will start with the biggest elements\\n        matchsticks.sort(reverse=True)\\n        \\n        def dfs(i):\\n            if i == n:\\n                side_a = square_sides[0]\\n                side_b = square_sides[1] \\n                side_c = square_sides[2] \\n                side_d = square_sides[3] \\n                \\n                # Return true only if all sides are equal to the \"side\" size we are looking for\\n                return side == side_a == side_b == side_c == side_d\\n        \\n            for side_i in range(4):\\n                \\n                if square_sides[side_i] + matchsticks[i] > side:\\n                    continue\\n                    \\n                # Add the matchstick size to the side of the box\\n                square_sides[side_i] += matchsticks[i]\\n                \\n                if dfs(i + 1):\\n                    return True\\n                \\n                # Backtrack if we didn\\'t find the answer\\n                square_sides[side_i] -= matchsticks[i]\\n            \\n            return False\\n        \\n        \\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271015,
                "title": "c-recursive-dp-optimised",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool canMake ( int index , int bucketsize , vector<int> &matchsticks , vector<int> &bucket){ \\n        if ( index == matchsticks.size()) \\n            return bucket[0]==bucket[1] and bucket[1]==bucket[2] and bucket[2]==bucket[3] ;\\n        \\n        for ( int i = 0 ; i < 4 ; i ++ ){\\n            if ( bucket[i] + matchsticks.at(index) > bucketsize) continue ;  \\n           \\n            int j = i ;\\n            while ( --j >= 0) \\n                if ( bucket[i] == bucket[j]) break;\\n            \\n            if ( j != -1 ) continue ;\\n            \\n            bucket.at(i) += matchsticks.at(index);\\n            if ( canMake ( index + 1 , bucketsize , matchsticks , bucket )) return true;\\n            bucket.at(i) -= matchsticks.at(index);\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n       \\n        int sum = 0 ;\\n        \\n        for ( int i : matchsticks) sum += i ;\\n        if ( sum == 0 or sum % 4 ) return false;\\n         \\n        sort( matchsticks.begin() , matchsticks.end() , greater<int>());\\n        \\n        vector<int> bucket(4, 0 );\\n        return canMake( 0 , sum / 4 , matchsticks , bucket);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool canMake ( int index , int bucketsize , vector<int> &matchsticks , vector<int> &bucket){ \\n        if ( index == matchsticks.size()) \\n            return bucket[0]==bucket[1] and bucket[1]==bucket[2] and bucket[2]==bucket[3] ;\\n        \\n        for ( int i = 0 ; i < 4 ; i ++ ){\\n            if ( bucket[i] + matchsticks.at(index) > bucketsize) continue ;  \\n           \\n            int j = i ;\\n            while ( --j >= 0) \\n                if ( bucket[i] == bucket[j]) break;\\n            \\n            if ( j != -1 ) continue ;\\n            \\n            bucket.at(i) += matchsticks.at(index);\\n            if ( canMake ( index + 1 , bucketsize , matchsticks , bucket )) return true;\\n            bucket.at(i) -= matchsticks.at(index);\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n       \\n        int sum = 0 ;\\n        \\n        for ( int i : matchsticks) sum += i ;\\n        if ( sum == 0 or sum % 4 ) return false;\\n         \\n        sort( matchsticks.begin() , matchsticks.end() , greater<int>());\\n        \\n        vector<int> bucket(4, 0 );\\n        return canMake( 0 , sum / 4 , matchsticks , bucket);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281566,
                "title": "python-380ms-faster-than-78-soln-w-explanation-86-less-memory",
                "content": "```\\ndef makesquare(self, matchsticks: List[int]) -> bool:\\n\\ttotal = sum(matchsticks)\\n\\n\\tif total % 4: # if total isn\\'t perfectly divisible by 4 then we can\\'t make a square\\n\\t\\treturn False\\n\\n\\treqLen = total // 4 # calculate length of each side we require\\n\\tsides = [0] * 4\\n\\tmatchsticks.sort(reverse = True) # sort in reverse so if biggest value is greater than reqLen we can return False\\n\\n\\tdef recurse(i):\\n\\t\\tif i == len(matchsticks):\\n\\t\\t\\treturn True\\n\\n\\t\\tfor j in range(4):\\n\\t\\t\\tif sides[j] + matchsticks[i] <= reqLen:\\n\\t\\t\\t\\tsides[j] += matchsticks[i]\\n\\n\\t\\t\\t\\tif recurse(i + 1):\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tsides[j] -= matchsticks[i]\\n\\n\\t\\t\\t\\t# Important line, otherwise function will give TLE\\n\\t\\t\\t\\tif sides[j] == 0:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tExplanation:\\n\\t\\t\\t\\tIf sides[j] = 0, it means this is the first time we\\'ve added values to that side.\\n\\t\\t\\t\\tIf the backtrack search fails when adding the values to sides[j] and it remains 0, it will also fail for all sides from sides[j+1:].\\n\\t\\t\\t\\tBecause we are simply going through the previous recursive tree again for a different j+1 position.\\n\\t\\t\\t\\tSo we can effectively break from the for loop or directly return False.\\n\\t\\t\\t\\t\"\"\"\\n\\n\\t\\treturn False\\n\\n\\treturn recurse(0)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8da79db3-e7cf-4f0c-a882-00bfab98dfbb_1660755178.4026978.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef makesquare(self, matchsticks: List[int]) -> bool:\\n\\ttotal = sum(matchsticks)\\n\\n\\tif total % 4: # if total isn\\'t perfectly divisible by 4 then we can\\'t make a square\\n\\t\\treturn False\\n\\n\\treqLen = total // 4 # calculate length of each side we require\\n\\tsides = [0] * 4\\n\\tmatchsticks.sort(reverse = True) # sort in reverse so if biggest value is greater than reqLen we can return False\\n\\n\\tdef recurse(i):\\n\\t\\tif i == len(matchsticks):\\n\\t\\t\\treturn True\\n\\n\\t\\tfor j in range(4):\\n\\t\\t\\tif sides[j] + matchsticks[i] <= reqLen:\\n\\t\\t\\t\\tsides[j] += matchsticks[i]\\n\\n\\t\\t\\t\\tif recurse(i + 1):\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tsides[j] -= matchsticks[i]\\n\\n\\t\\t\\t\\t# Important line, otherwise function will give TLE\\n\\t\\t\\t\\tif sides[j] == 0:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tExplanation:\\n\\t\\t\\t\\tIf sides[j] = 0, it means this is the first time we\\'ve added values to that side.\\n\\t\\t\\t\\tIf the backtrack search fails when adding the values to sides[j] and it remains 0, it will also fail for all sides from sides[j+1:].\\n\\t\\t\\t\\tBecause we are simply going through the previous recursive tree again for a different j+1 position.\\n\\t\\t\\t\\tSo we can effectively break from the for loop or directly return False.\\n\\t\\t\\t\\t\"\"\"\\n\\n\\t\\treturn False\\n\\n\\treturn recurse(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2274058,
                "title": "python-from-dfs-to-optimized-dp-using-bitmasks",
                "content": "**SOLUTION 1)** DFS (no memoization).\\n\\nSame as LC\\'s solution, it\\'s a decision tree of height n, with 4 choices at each step. Each element can go to either of the 4 sides that make up a square. At most, we\\'ll have n recursive function calls.\\n```\\n    // TC: O(4^n)\\n    // SC: O(n)\\n```\\n\\n**SOLUTION 2)** DFS + Memoization.\\n\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        totalLength = sum(matchsticks)\\n        sideLength = totalLength // 4\\n        if sideLength * 4 != totalLength: return False\\n        \\n        matchsticks.sort(reverse=True)\\n\\n        @cache\\n        def findSquare(i, s1, s2, s3, s4):\\n            if i == n:\\n                return s1 == s2 == s3 == s4 == 0\\n\\n            return ((s1 >= matchsticks[i] and findSquare(i + 1, s1 - matchsticks[i], s2, s3, s4))\\n                or (s2 >= matchsticks[i] and findSquare(i + 1, s1, s2 - matchsticks[i], s3, s4))\\n                or (s3 >= matchsticks[i] and findSquare(i + 1, s1, s2, s3 - matchsticks[i], s4))\\n                or (s4 >= matchsticks[i] and findSquare(i + 1, s1, s2, s3, s4 - matchsticks[i])))\\n        \\n        return findSquare(0, sideLength, sideLength, sideLength, sideLength)\\n```\\n```\\n    // TC: O(n^5) (cache_entries * work_per_entry)\\n    // SC: O(n^5) (cache_entries)\\n```\\n* **work_per_entry**: constant work - O(1)\\n* **cache_entries**: n^5\\n    * **i** can take up to n different values\\n    * **s1,s2,s3,s4** can each take up to (roughly) n different values (permutations)\\n```\\n        s: ___ ___ ___ ___ --> n * (n-1) * (n-2) * (n-3) = n^4\\n            1   2   3   4\\n\\n        s1 can take any of the n values (upper-bounded by 15 according to the problem constraints)\\n        s2 can take any of the n-1 remaining values\\n        s3 can take any of the n-2 remaining values\\n        s4 can take any of the n-3 remaining values\\n```\\nWhy permutations? Even though in the real world we don\\'t care about the order of these sides as they all have to be equal in the end, for caching purposes, the order does matter. A cache entry (1,1,4,1) is different to the entry (1,4,1,1). So, the drawback of this solution is that we\\'re doing more work than it\\'s actually required.\\n\\n**SOLUTION 3)** DFS + Memoization + Bitmasks\\nLet\\'s consider the input (4,1,1,1,1,1,1,1,1,1,1,1,1). Each side should have a length of 4 to make a square.\\n\\nCalculating the entries: (5,1,1,1), (1,5,1,1), (1,1,5,1), and (1,1,1,5) is a total waste of time. \\n\\nDoes it matter if the side with length 5 is placed at the top? or at the bottom? is that a different state in terms of our problem? It\\'s not. No matter where we try to place that side with a length of 5, the result is the same: it won\\'t work (sides should have a length of 4!). The only constraint is that all sides are equal to make a square. It doesn\\'t matter where we place our matches as long as all sides are equal. \\n\\nSo, we\\'re using 3 additional cache entries to represent a single state of the problem. This is suboptimal in terms of space and also in terms of time as even if they take constant amount of work each of these to compute we still need to do it and store the result in the cache.\\n\\nA very clever way to represent the different states is using the number of remaining or \"incomplete\" sides, and a bitmask with n bits. Each bit set to 1 means an \\'unused matchstick\\'. When all bits are set to zero (no matches left), and all the sides are complete (remainingSides == 0), then we\\'ve found our answer!\\n\\nIn our bitmask we\\'ll need exactly n bits (one bit is mapped to one element for each element in the array). This will give us a total number of 2^n combinations (cache entries).\\n\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        totalLength = sum(matchsticks)\\n        sideLength = totalLength // 4\\n        if sideLength * 4 != totalLength: return False\\n        \\n        matchsticks.sort(reverse=True)\\n\\n        @cache\\n        def findSquare(remainingSides, remainingMatches):\\n            if remainingSides == 0:\\n                return remainingMatches == 0\\n            \\n            # calculate the length of the current side by adding up the length of the already\\n            # added matches. we use % to get rid of sides that are already completed\\n            currSideLength = 0\\n            for i in range(n):\\n                if remainingMatches & (1 << i) == 0:\\n                    currSideLength = (currSideLength + matchsticks[i]) % sideLength\\n\\n            for i in range(n):\\n                if remainingMatches & (1 << i) == 0: continue # skip already used matches\\n                # match at i is unused, let\\'s see if we can use it now\\n\\n                if currSideLength + matchsticks[i] > sideLength: break\\n\\n                completed = (currSideLength + matchsticks[i]) == sideLength\\n                if findSquare(remainingSides - completed, remainingMatches & ~(1 << i)):\\n                    return True\\n\\n            return False\\n\\n        return findSquare(4, 2 ** n - 1)\\n```\\n```\\n    // TC: O(2^n * n) (cache_entries * work_per_entry)\\n    // SC: O(2^n + n) (cache_entries + n space for the recursion stack + n space for timsort algorithm)\\n```\\n\\n**SOLUTION 4)** DFS + Memoization + Sorting (thanks to @JINLIU0)\\nThis solution is an optimization to solution 2) mentioned by JINLIU0 in the comments. It\\'s actually a very simple and effective way to get rid of duplicate calculations. With the help of a hash function that sorts the length of the sides we can make duplicate entries hash to the same entry. For example: (5,1,1,1), (1,5,1,1), (1,1,5,1), and (1,1,1,5) would all hash to (1,1,1,5).\\n\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        totalLength = sum(matchsticks)\\n        sideLength = totalLength // 4\\n        if sideLength * 4 != totalLength: return False\\n        \\n        matchsticks.sort(reverse=True)\\n        cache = collections.defaultdict(None)\\n\\n        def hashState(i, s1, s2, s3, s4):\\n            # T: O(1) - also, instead of using the built-in timsort algorithm\\n            # we could implement a hard-coded sort using if-else statements\\n            # as there\\'re only 4 elements\\n            return tuple(itertools.chain([i], sorted([s1, s2, s3, s4])))\\n\\n        def findSquare(i, s1, s2, s3, s4):\\n            state = hashState(i, s1, s2, s3, s4)\\n            if state in cache: return cache[state]\\n\\n            if i == n:\\n                cache[state] = s1 == s2 == s3 == s4 == 0\\n            else:\\n                cache[state] = ((s1 >= matchsticks[i] and findSquare(i + 1, s1 - matchsticks[i], s2, s3, s4))\\n                    or (s2 >= matchsticks[i] and findSquare(i + 1, s1, s2 - matchsticks[i], s3, s4))\\n                    or (s3 >= matchsticks[i] and findSquare(i + 1, s1, s2, s3 - matchsticks[i], s4))\\n                    or (s4 >= matchsticks[i] and findSquare(i + 1, s1, s2, s3, s4 - matchsticks[i])))\\n            \\n            return cache[state]\\n\\n        return findSquare(0, sideLength, sideLength, sideLength, sideLength)\\n```\\n```\\n    // TC: O(n^5)\\n    // SC: O(n^5)\\n```\\n\\nIn practice, this approach is apparently the fastest one (95% faster in 5 submissions).",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n    // TC: O(4^n)\\n    // SC: O(n)\\n```\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        totalLength = sum(matchsticks)\\n        sideLength = totalLength // 4\\n        if sideLength * 4 != totalLength: return False\\n        \\n        matchsticks.sort(reverse=True)\\n\\n        @cache\\n        def findSquare(i, s1, s2, s3, s4):\\n            if i == n:\\n                return s1 == s2 == s3 == s4 == 0\\n\\n            return ((s1 >= matchsticks[i] and findSquare(i + 1, s1 - matchsticks[i], s2, s3, s4))\\n                or (s2 >= matchsticks[i] and findSquare(i + 1, s1, s2 - matchsticks[i], s3, s4))\\n                or (s3 >= matchsticks[i] and findSquare(i + 1, s1, s2, s3 - matchsticks[i], s4))\\n                or (s4 >= matchsticks[i] and findSquare(i + 1, s1, s2, s3, s4 - matchsticks[i])))\\n        \\n        return findSquare(0, sideLength, sideLength, sideLength, sideLength)\\n```\n```\\n    // TC: O(n^5) (cache_entries * work_per_entry)\\n    // SC: O(n^5) (cache_entries)\\n```\n```\\n        s: ___ ___ ___ ___ --> n * (n-1) * (n-2) * (n-3) = n^4\\n            1   2   3   4\\n\\n        s1 can take any of the n values (upper-bounded by 15 according to the problem constraints)\\n        s2 can take any of the n-1 remaining values\\n        s3 can take any of the n-2 remaining values\\n        s4 can take any of the n-3 remaining values\\n```\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        totalLength = sum(matchsticks)\\n        sideLength = totalLength // 4\\n        if sideLength * 4 != totalLength: return False\\n        \\n        matchsticks.sort(reverse=True)\\n\\n        @cache\\n        def findSquare(remainingSides, remainingMatches):\\n            if remainingSides == 0:\\n                return remainingMatches == 0\\n            \\n            # calculate the length of the current side by adding up the length of the already\\n            # added matches. we use % to get rid of sides that are already completed\\n            currSideLength = 0\\n            for i in range(n):\\n                if remainingMatches & (1 << i) == 0:\\n                    currSideLength = (currSideLength + matchsticks[i]) % sideLength\\n\\n            for i in range(n):\\n                if remainingMatches & (1 << i) == 0: continue # skip already used matches\\n                # match at i is unused, let\\'s see if we can use it now\\n\\n                if currSideLength + matchsticks[i] > sideLength: break\\n\\n                completed = (currSideLength + matchsticks[i]) == sideLength\\n                if findSquare(remainingSides - completed, remainingMatches & ~(1 << i)):\\n                    return True\\n\\n            return False\\n\\n        return findSquare(4, 2 ** n - 1)\\n```\n```\\n    // TC: O(2^n * n) (cache_entries * work_per_entry)\\n    // SC: O(2^n + n) (cache_entries + n space for the recursion stack + n space for timsort algorithm)\\n```\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        totalLength = sum(matchsticks)\\n        sideLength = totalLength // 4\\n        if sideLength * 4 != totalLength: return False\\n        \\n        matchsticks.sort(reverse=True)\\n        cache = collections.defaultdict(None)\\n\\n        def hashState(i, s1, s2, s3, s4):\\n            # T: O(1) - also, instead of using the built-in timsort algorithm\\n            # we could implement a hard-coded sort using if-else statements\\n            # as there\\'re only 4 elements\\n            return tuple(itertools.chain([i], sorted([s1, s2, s3, s4])))\\n\\n        def findSquare(i, s1, s2, s3, s4):\\n            state = hashState(i, s1, s2, s3, s4)\\n            if state in cache: return cache[state]\\n\\n            if i == n:\\n                cache[state] = s1 == s2 == s3 == s4 == 0\\n            else:\\n                cache[state] = ((s1 >= matchsticks[i] and findSquare(i + 1, s1 - matchsticks[i], s2, s3, s4))\\n                    or (s2 >= matchsticks[i] and findSquare(i + 1, s1, s2 - matchsticks[i], s3, s4))\\n                    or (s3 >= matchsticks[i] and findSquare(i + 1, s1, s2, s3 - matchsticks[i], s4))\\n                    or (s4 >= matchsticks[i] and findSquare(i + 1, s1, s2, s3, s4 - matchsticks[i])))\\n            \\n            return cache[state]\\n\\n        return findSquare(0, sideLength, sideLength, sideLength, sideLength)\\n```\n```\\n    // TC: O(n^5)\\n    // SC: O(n^5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270654,
                "title": "easy-js-solution",
                "content": "```\\nvar makesquare = function(matchsticks) {\\n    const perimeter = matchsticks.reduce((a, b) => a + b, 0);\\n    if(perimeter % 4 != 0 || matchsticks.length < 4) return false;\\n    \\n    const sideLen = perimeter / 4;\\n    // find a way to divide the array in 4 group of sum side length\\n    const sides = new Array(4).fill(0);\\n    const len = matchsticks.length;\\n    matchsticks.sort((a, b) => b - a);\\n    \\n    const solve = (x = 0) => {\\n        if(x == len) {\\n            return sides.every(side => side == sideLen);\\n        }\\n        \\n        for(let i = 0; i < 4; i++) {\\n            if(sides[i] + matchsticks[x] > sideLen) {\\n                continue;\\n            }\\n            sides[i] += matchsticks[x];\\n            if(solve(x + 1)) return true;\\n            sides[i] -= matchsticks[x];\\n        }\\n        return false;\\n    }\\n    return solve();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar makesquare = function(matchsticks) {\\n    const perimeter = matchsticks.reduce((a, b) => a + b, 0);\\n    if(perimeter % 4 != 0 || matchsticks.length < 4) return false;\\n    \\n    const sideLen = perimeter / 4;\\n    // find a way to divide the array in 4 group of sum side length\\n    const sides = new Array(4).fill(0);\\n    const len = matchsticks.length;\\n    matchsticks.sort((a, b) => b - a);\\n    \\n    const solve = (x = 0) => {\\n        if(x == len) {\\n            return sides.every(side => side == sideLen);\\n        }\\n        \\n        for(let i = 0; i < 4; i++) {\\n            if(sides[i] + matchsticks[x] > sideLen) {\\n                continue;\\n            }\\n            sides[i] += matchsticks[x];\\n            if(solve(x + 1)) return true;\\n            sides[i] -= matchsticks[x];\\n        }\\n        return false;\\n    }\\n    return solve();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1273948,
                "title": "matchsticks-to-square-dfs-recursion-approach-easy-c",
                "content": "```\\n \\n    bool DFS(int i,vector<int>&m,int s1,int s2,int s3, int s4){\\n        \\n        if(s1==0 and s2==0 and s3==0 and s4==0){\\n                return true;    \\n        }\\n        \\n        if(s1<0 || s2<0 || s3<0 || s4<0){\\n                return false;    \\n        }\\n        if(i<0){\\n            return true;\\n        }\\n        return DFS( i-1,m,s1-m[i], s2, s3, s4) or DFS( i-1,m,s1, s2-m[i], s3, s4) or \\n            DFS( i-1,m,s1, s2, s3-m[i], s4) or DFS( i-1,m,s1, s2, s3, s4-m[i]);\\n        \\n    }\\n    bool makesquare(vector<int>& m) {\\n        int sum=0;\\n      \\n        for(int i=0;i<m.size();i++){\\n            sum+=m[i];\\n          \\n        }\\n        \\n        if(sum%4!=0){\\n            return false;\\n        }\\n        int n=m.size();\\n        return DFS(n-1,m,sum/4,sum/4,sum/4,sum/4);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n \\n    bool DFS(int i,vector<int>&m,int s1,int s2,int s3, int s4){\\n        \\n        if(s1==0 and s2==0 and s3==0 and s4==0){\\n                return true;    \\n        }\\n        \\n        if(s1<0 || s2<0 || s3<0 || s4<0){\\n                return false;    \\n        }\\n        if(i<0){\\n            return true;\\n        }\\n        return DFS( i-1,m,s1-m[i], s2, s3, s4) or DFS( i-1,m,s1, s2-m[i], s3, s4) or \\n            DFS( i-1,m,s1, s2, s3-m[i], s4) or DFS( i-1,m,s1, s2, s3, s4-m[i]);\\n        \\n    }\\n    bool makesquare(vector<int>& m) {\\n        int sum=0;\\n      \\n        for(int i=0;i<m.size();i++){\\n            sum+=m[i];\\n          \\n        }\\n        \\n        if(sum%4!=0){\\n            return false;\\n        }\\n        int n=m.size();\\n        return DFS(n-1,m,sum/4,sum/4,sum/4,sum/4);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 230555,
                "title": "java-solution-based-on-partition-to-k-equal-sum-subsets-problem",
                "content": "Time complexity : N(4^N) (approx upper bound)\\nwhere N = size of  nums array\\n\\nRuntime for leetcode : 15ms\\n\\n```\\nclass Solution {\\n    public boolean makesquare(int[] nums) {\\n        int sum = 0;\\n        for(int num : nums) {\\n            sum += num;\\n        }\\n        if(nums.length == 0 || nums == null || sum%4 != 0) {\\n            return false;\\n        }\\n        int target = sum / 4;\\n        boolean[] used = new boolean[nums.length];\\n        return makesquareHelper(nums , used , 0 , target , 0 , 4);\\n    }\\n    \\n    public boolean makesquareHelper(int[] nums , boolean[] used , int curSum , int target , int start , int k) {\\n        if(k == 1) return true;\\n        if(curSum == target) {\\n            return makesquareHelper(nums , used , 0 , target , 0 , k-1);\\n        }\\n        for(int i = start ; i < nums.length ; i++) {\\n            if(used[i]) continue;\\n            used[i] = true;\\n            if(makesquareHelper(nums , used , curSum + nums[i] , target , i+1 , k)) {\\n                return true;\\n            }\\n            used[i] = false;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] nums) {\\n        int sum = 0;\\n        for(int num : nums) {\\n            sum += num;\\n        }\\n        if(nums.length == 0 || nums == null || sum%4 != 0) {\\n            return false;\\n        }\\n        int target = sum / 4;\\n        boolean[] used = new boolean[nums.length];\\n        return makesquareHelper(nums , used , 0 , target , 0 , 4);\\n    }\\n    \\n    public boolean makesquareHelper(int[] nums , boolean[] used , int curSum , int target , int start , int k) {\\n        if(k == 1) return true;\\n        if(curSum == target) {\\n            return makesquareHelper(nums , used , 0 , target , 0 , k-1);\\n        }\\n        for(int i = start ; i < nums.length ; i++) {\\n            if(used[i]) continue;\\n            used[i] = true;\\n            if(makesquareHelper(nums , used , curSum + nums[i] , target , i+1 , k)) {\\n                return true;\\n            }\\n            used[i] = false;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270533,
                "title": "cpp-code-backtracking-dfs-dp-easy-to-follow",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool canMake ( int index , int bucketsize , vector<int> &matchsticks , vector<int> &bucket){\\n        // base case \\n        if ( index == matchsticks.size()) \\n            return bucket[0]==bucket[1] and bucket[1]==bucket[2] and bucket[2]==bucket[3] ;\\n        \\n        \\n        // simple dfs backtrack \\n        for ( int i = 0 ; i < 4 ; i ++ ){\\n            if ( bucket[i] + matchsticks.at(index) > bucketsize) continue ;  \\n            \\n            \\n            // concept of DP in optimization: if I have checked the same length before, \\n            //why do I need to bother checking again?\\n            //Although we only have 4 sides in a square, we can still \\n            //check if we have encountered the same length with the current match. \\n          \\n            \\n            int j = i ;\\n            while ( --j >= 0) \\n                if ( bucket[i] == bucket[j]) break;\\n            \\n            if ( j != -1 ) continue ;\\n            \\n            // noraml targetsum \\n            bucket.at(i) += matchsticks.at(index);\\n            if ( canMake ( index + 1 , bucketsize , matchsticks , bucket )) return true;\\n            bucket.at(i) -= matchsticks.at(index);\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n        // base case \\n        int sum = 0 ;\\n        \\n        for ( int i : matchsticks) sum += i ;\\n        if ( sum == 0 or sum % 4 ) return false;\\n        \\n        // we know that the side of the square will be atleast the max element of the match array\\n        // sorting the array elements  in descending order\\n        sort( matchsticks.begin() , matchsticks.end() , greater<int>());\\n        \\n        // now i will make bucket of size sum / 4 \\n        // and try all possibility to form that sum\\n        vector<int> bucket(4, 0 );\\n        return canMake( 0 , sum / 4 , matchsticks , bucket);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool canMake ( int index , int bucketsize , vector<int> &matchsticks , vector<int> &bucket){\\n        // base case \\n        if ( index == matchsticks.size()) \\n            return bucket[0]==bucket[1] and bucket[1]==bucket[2] and bucket[2]==bucket[3] ;\\n        \\n        \\n        // simple dfs backtrack \\n        for ( int i = 0 ; i < 4 ; i ++ ){\\n            if ( bucket[i] + matchsticks.at(index) > bucketsize) continue ;  \\n            \\n            \\n            // concept of DP in optimization: if I have checked the same length before, \\n            //why do I need to bother checking again?\\n            //Although we only have 4 sides in a square, we can still \\n            //check if we have encountered the same length with the current match. \\n          \\n            \\n            int j = i ;\\n            while ( --j >= 0) \\n                if ( bucket[i] == bucket[j]) break;\\n            \\n            if ( j != -1 ) continue ;\\n            \\n            // noraml targetsum \\n            bucket.at(i) += matchsticks.at(index);\\n            if ( canMake ( index + 1 , bucketsize , matchsticks , bucket )) return true;\\n            bucket.at(i) -= matchsticks.at(index);\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n        // base case \\n        int sum = 0 ;\\n        \\n        for ( int i : matchsticks) sum += i ;\\n        if ( sum == 0 or sum % 4 ) return false;\\n        \\n        // we know that the side of the square will be atleast the max element of the match array\\n        // sorting the array elements  in descending order\\n        sort( matchsticks.begin() , matchsticks.end() , greater<int>());\\n        \\n        // now i will make bucket of size sum / 4 \\n        // and try all possibility to form that sum\\n        vector<int> bucket(4, 0 );\\n        return canMake( 0 , sum / 4 , matchsticks , bucket);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605196,
                "title": "easy-c-back-tracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bitset<16> visited;\\n    \\n    bool dfs(vector<int>& nums, int lb, int sum, int target, int k) {\\n        if (k == 1) return true;\\n        if (sum == target) return dfs(nums, 0, 0, target, k-1);\\n        if (lb >= nums.size()) return false;\\n        for (int i=lb; i<nums.size(); i++) {\\n            if (sum + nums[i] <= target && !visited[i]) {\\n                visited[i] = true;\\n                if (dfs(nums, i+1, sum+nums[i], target, k))\\n                    return true;\\n                visited[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& nums) {\\n        if (!nums.size()) return false;\\n        int sum = 0;\\n        for (auto i : nums) sum += i;\\n        if (sum % 4 != 0) return false;\\n        return dfs(nums, 0, 0, sum/4, 4);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bitset<16> visited;\\n    \\n    bool dfs(vector<int>& nums, int lb, int sum, int target, int k) {\\n        if (k == 1) return true;\\n        if (sum == target) return dfs(nums, 0, 0, target, k-1);\\n        if (lb >= nums.size()) return false;\\n        for (int i=lb; i<nums.size(); i++) {\\n            if (sum + nums[i] <= target && !visited[i]) {\\n                visited[i] = true;\\n                if (dfs(nums, i+1, sum+nums[i], target, k))\\n                    return true;\\n                visited[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& nums) {\\n        if (!nums.size()) return false;\\n        int sum = 0;\\n        for (auto i : nums) sum += i;\\n        if (sum % 4 != 0) return false;\\n        return dfs(nums, 0, 0, sum/4, 4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271900,
                "title": "c-using-dfs-and-bitmasking",
                "content": "### **1) Simple Code Using DFS**(20ms)\\nWe Just check by taking the present element at index into all the boxes and check if we can create 4 subsets of Same size\\nIf we can create 4 subsets of same size we return True.\\n#### Optimizations:\\n1) We can sort The array and check if an element is greater than (sum/4)Target and Then we can directly return false.\\n2) Using the concept of DP in optimization: if I have checked the same length before, I dont need to check it again.\\nAlthough we only have 4 sides in a square, we can still check if we have encountered the same length with the current match(Which can considerably reduce the recursive calls).\\n```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int index, vector<int>& sideLength, int target, vector<int>&sti){\\n        if(index == sti.size()){\\n            return sideLength[0] == sideLength[1] && sideLength[1] == sideLength[2] && sideLength[2] == sideLength[3];\\n        }\\n        \\n        for(int i = 0; i < 4; i++){\\n            if(sideLength[i] + sti[index] > target)continue;\\n            \\n\\t\\t\\t\\n            int j = i;//Second Optimisation if the same length is present don\\'t need to check again\\n            while(--j >= 0){\\n                if(sideLength[i] == sideLength[j])break;\\n            }\\n            if(j != -1)continue;\\n            \\n            sideLength[i] += sti[index];\\n            if(dfs(index+1, sideLength, target, sti)){\\n                return true;\\n            }\\n            sideLength[i] -= sti[index];\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& sti) {\\n        int sum = 0, n = sti.size();\\n        for(auto it : sti)sum+=it;\\n        \\n        if(sum%4 != 0)return false;\\n        //First Optimisation\\n        sort(sti.begin(), sti.end(), greater<int>());\\n        if(sti[0] > sum/4)return false;\\n        \\n        int target = sum/4;\\n        vector<int>sideLength(4, 0);\\n        return dfs(0, sideLength, target, sti);\\n            \\n    }\\n};\\n```\\n\\n### **2)Using BitMasking**\\n**Alert:** This Solution is Slower than The Dfs solution mentioned above, but to Understand The Concept of BitMasking You Can check this solution.\\n\\n**Small Intro To BitMasking:**\\nA bitmask is used as a representation of a subset. For example if nums = {7,5,8,6,4}, then a bitmask = 01100 represents the subset {5,8}.\\nTotal No of subset = 2^n\\nTo get All The Subset We go from 0 to (2^n)-1, Each number represents a subset.\\nMask of a Subset implies Number Corresponding To it.\\nSo we will use a vector of int to Store Required Subsets.\\n\\n\\n**Solution Explanation:**\\nIn this Solution we will go through all the subsets  `for(int i = 0; i < all; i++)`and check if the sum of the elements of Subset is equal to Target(totalSum/4)\\n\\nIf a subset Have sum equal to Target let it be PresentSubset(and its Mask is \\'i\\' in code) Then we will push The Mask of that Subset into `vector<int>usedMasks`  Which Contain the Masks of All subsets Whose sum is equal to Target.\\n\\nNow We Check Whether There Exist a Subset Whose sum is Equal to Target and Has Elements which are entirely **different** from the PresentSubset This can be done by checking whether the &(AND) of masks of Both subsets is equal to 0. If the &(AND) of Both Subsets is equal to 0 that implies that both Subset Have entirely different Elements.\\n\\nNow We take `validSubSetof2` containg elements of both subsets (`mask | i`) and check if there exist a validSubset that contains 2 subsets as above but entirely different elements from Above.\\n\\nWe do this by taking XOR of all and present validSubSetof2 `if(validHalfSubSets[ all ^ validSubSetof2 ] == true)`\\nhere The `vector<bool>validHalfSubSets(1<<n, false);` contains all the ValidHalfSubSets That is We can Divide The Subset into Two parts With different elements and sum equal to Target(validHalfSubSet = 2 * satisfyingSubSet)\\n\\nIf there exists A validHalfSubSet with Different Elements from Present Subset That implies We have Found 4 subsets Whose Sum is Equal to Target.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool makesquare(vector<int>& sti) {\\n        int totalSum = 0, n = sti.size();\\n        for(auto it : sti)totalSum+=it;\\n        \\n        if(sum%4 != 0)return false;\\n        int target = totalSum / 4;\\n        \\n        int all = (1 << n);\\n        all--;\\n        vector<int>usedMasks;//Contains All the subsets Whose sum is equal to target\\n        vector<bool>validHalfSubSets(1<<n, false);\\n        \\n        for(int i = 0; i < all; i++){\\n            int sumOfPresentSubSet = 0;\\n            for(int j = 0; j < 15; j++){\\n                if(( (i>>j) & 1) ){\\n                    sumOfPresentSubSet += sti[j];\\n                }\\n            }\\n            \\n            if(sumOfPresentSubSet == target){\\n                for(auto mask : usedMasks){\\n                    if((mask & i) == 0){// This implies That the present subset and the mask have different elements as their and is equal to Zero\\n                        //It Satisfies\\n                        //This implies that we have two Subsets one is i and the other one is mask from usedMasks\\n                        //As their & is equal to zero They both have differet bits => Different elements in their subsets\\n                        int validSubSetof2 = (mask | i);//Combining these two to make a validSubset that can be divided into two parts\\n                        if(validHalfSubSets[ all ^ validSubSetof2 ] == true)//Checking Whether There Exist A validSubSetof2 with entirely Different elements form present validSubSetof2(Xor is Used to Find This)\\n                            return true;\\n                        \\n                        validHalfSubSets[validSubSetof2] = true; \\n                    }\\n                }\\n\\n                usedMasks.push_back(i);//Pushing The Present Mask Satisfying the condition subSetSum = target\\n            }\\n            \\n        }\\n        \\n        return false;\\n            \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int index, vector<int>& sideLength, int target, vector<int>&sti){\\n        if(index == sti.size()){\\n            return sideLength[0] == sideLength[1] && sideLength[1] == sideLength[2] && sideLength[2] == sideLength[3];\\n        }\\n        \\n        for(int i = 0; i < 4; i++){\\n            if(sideLength[i] + sti[index] > target)continue;\\n            \\n\\t\\t\\t\\n            int j = i;//Second Optimisation if the same length is present don\\'t need to check again\\n            while(--j >= 0){\\n                if(sideLength[i] == sideLength[j])break;\\n            }\\n            if(j != -1)continue;\\n            \\n            sideLength[i] += sti[index];\\n            if(dfs(index+1, sideLength, target, sti)){\\n                return true;\\n            }\\n            sideLength[i] -= sti[index];\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& sti) {\\n        int sum = 0, n = sti.size();\\n        for(auto it : sti)sum+=it;\\n        \\n        if(sum%4 != 0)return false;\\n        //First Optimisation\\n        sort(sti.begin(), sti.end(), greater<int>());\\n        if(sti[0] > sum/4)return false;\\n        \\n        int target = sum/4;\\n        vector<int>sideLength(4, 0);\\n        return dfs(0, sideLength, target, sti);\\n            \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool makesquare(vector<int>& sti) {\\n        int totalSum = 0, n = sti.size();\\n        for(auto it : sti)totalSum+=it;\\n        \\n        if(sum%4 != 0)return false;\\n        int target = totalSum / 4;\\n        \\n        int all = (1 << n);\\n        all--;\\n        vector<int>usedMasks;//Contains All the subsets Whose sum is equal to target\\n        vector<bool>validHalfSubSets(1<<n, false);\\n        \\n        for(int i = 0; i < all; i++){\\n            int sumOfPresentSubSet = 0;\\n            for(int j = 0; j < 15; j++){\\n                if(( (i>>j) & 1) ){\\n                    sumOfPresentSubSet += sti[j];\\n                }\\n            }\\n            \\n            if(sumOfPresentSubSet == target){\\n                for(auto mask : usedMasks){\\n                    if((mask & i) == 0){// This implies That the present subset and the mask have different elements as their and is equal to Zero\\n                        //It Satisfies\\n                        //This implies that we have two Subsets one is i and the other one is mask from usedMasks\\n                        //As their & is equal to zero They both have differet bits => Different elements in their subsets\\n                        int validSubSetof2 = (mask | i);//Combining these two to make a validSubset that can be divided into two parts\\n                        if(validHalfSubSets[ all ^ validSubSetof2 ] == true)//Checking Whether There Exist A validSubSetof2 with entirely Different elements form present validSubSetof2(Xor is Used to Find This)\\n                            return true;\\n                        \\n                        validHalfSubSets[validSubSetof2] = true; \\n                    }\\n                }\\n\\n                usedMasks.push_back(i);//Pushing The Present Mask Satisfying the condition subSetSum = target\\n            }\\n            \\n        }\\n        \\n        return false;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270373,
                "title": "python-3-dp-bitmask",
                "content": "```\\nclass Solution:\\n    def makesquare(self, arr: List[int]) -> bool:\\n\\t\\t# no way to make the square if total length not divisble by 4\\n        if sum(arr) % 4:\\n            return False\\n        \\n\\t\\t# target side length\\n        side = sum(arr) // 4\\n        \\n        @lru_cache(None)\\n        def dp(k, mask, s):\\n\\t\\t\\t# finish all four sides\\n            if k == 4:\\n                return True\\n\\t\\t\\t# move on to next side if current one finished\\n            if not s:\\n                return dp(k+1, mask, side)\\n            \\n            for i in range(len(arr)):\\n\\t\\t\\t\\t# if current matchstick used or longer than remaining side length to fill then skip\\n                if mask & (1 << i) or s < arr[i]: continue\\n                if dp(k, mask ^ (1 << i), s - arr[i]):\\n                    return True\\n            return False\\n        \\n        return dp(0, 0, side)\\n```\\n\\nCould drop one dimension of the dp\\n\\n```\\n    def makesquare(self, arr: List[int]) -> bool:\\n        if sum(arr) % 4:\\n            return False\\n        \\n        side = sum(arr) // 4\\n        n = len(arr)\\n        \\n        @lru_cache(None)\\n        def dp(mask, s):\\n            if mask == (1 << n) - 1:\\n                return True\\n            if not s:\\n                return dp(mask, side)\\n            \\n            for i in range(n):\\n                if mask & (1 << i) or s < arr[i]: continue\\n                if dp(mask ^ (1 << i), s - arr[i]):\\n                    return True\\n            return False\\n        \\n        return dp(0, side)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def makesquare(self, arr: List[int]) -> bool:\\n\\t\\t# no way to make the square if total length not divisble by 4\\n        if sum(arr) % 4:\\n            return False\\n        \\n\\t\\t# target side length\\n        side = sum(arr) // 4\\n        \\n        @lru_cache(None)\\n        def dp(k, mask, s):\\n\\t\\t\\t# finish all four sides\\n            if k == 4:\\n                return True\\n\\t\\t\\t# move on to next side if current one finished\\n            if not s:\\n                return dp(k+1, mask, side)\\n            \\n            for i in range(len(arr)):\\n\\t\\t\\t\\t# if current matchstick used or longer than remaining side length to fill then skip\\n                if mask & (1 << i) or s < arr[i]: continue\\n                if dp(k, mask ^ (1 << i), s - arr[i]):\\n                    return True\\n            return False\\n        \\n        return dp(0, 0, side)\\n```\n```\\n    def makesquare(self, arr: List[int]) -> bool:\\n        if sum(arr) % 4:\\n            return False\\n        \\n        side = sum(arr) // 4\\n        n = len(arr)\\n        \\n        @lru_cache(None)\\n        def dp(mask, s):\\n            if mask == (1 << n) - 1:\\n                return True\\n            if not s:\\n                return dp(mask, side)\\n            \\n            for i in range(n):\\n                if mask & (1 << i) or s < arr[i]: continue\\n                if dp(mask ^ (1 << i), s - arr[i]):\\n                    return True\\n            return False\\n        \\n        return dp(0, side)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275632,
                "title": "matchsticks-to-square-js-python-java-c-easy-optimized-backtracking-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n_(**Edit**: The code has been slightly reworked to be a more straightforward backtracking solution.)_\\n\\nAt first glance, this problem seems rather straightforward: find the total length of the matchsticks in **M**, figure out how long each **side** of the square must be, then find every combination of matchsticks that can add up to **side**. If four unique sets of matchsticks each add up to **side**, then we can **return true**. \\n\\nThe fact that the constraint upon the only imput is so low would seem to suggest that an **O(2^N)** solution is appropriate. There are, however, a few things we can do to optimize this process. The first key realization is that we _can_, in fact, use a **greedy** approach.\\n\\nConsider the case of **M = [1,1,1,2,2,2,3]**. In this case, we can easily see that the total is **12** and thus side = **3**. If we were to start iterating through **M** to find multiples of **3**, we\\'d first group together the first three elements and then also find the last element, but be unable to make two more **3**s from the middle elements of **M**. This would perhaps suggest that a greedy approach will not work, because it\\'s readily apparent that we need to save the **1**s to pair up with the **2**s to make three of the four sides.\\n\\nBut that also suggests the solution, which is that we can use a greedy approach _if_ we iterate through **M** in descending order. That way, each **2** will naturally seek out its matching **1** before we could ever attempt to match the **1**s together in a less efficient manner.\\n\\nThat means that we can just use a **recursive** **backtracking** helper (**btrack**) to help find the side groups in **M**. But first, we can take care of some edge cases: If the total sum of **M** is not divisble by **4**, or if any single matchstick in **M** is longer than the calculated **side**, then a solution is impossible and we should **return false**.\\n\\nAs for our recursive helper, it will need to iterate through the sorted **M** multiple times, attempting to build up groups that match **side**. We\\'ll also keep track of how many groups we\\'ve found (**done**), and whenever we find a match, start **btrack** back at the beginning with **done** incremented.\\n\\n_(**Note**: When incrementing done and starting the recursive helper over, we can start at index **1** instead of index **0** because **M[0]** will_ always _be a part of the first grouping.)_\\n\\nOnce we\\'ve finished **3** groups, we can go ahead and **return true**, because we know that the remaining pieces must add up to **side**. If at any point we reach the end of **M** without finishing the current group, however, we should **return false**.\\n\\nWhen attempting to add a piece to the current group, we can obviously skip pieces that are larger than the remaining **space**, as well as pieces that have already been used. Normally, this would require some kind of additional array or set to keep track of the used pieces, but we can use an **in-place** approach with **M** and just replace the used values with a value larger than **side**. This will simplify the check to skip elements to just one conditional.\\n\\n_(**Note**: If you don\\'t want to modify the input, you_ could _use a single integer and **bit manipulation** to achieve the same result in **O(1) space**. Sorting **M** will still take **O(N) space** if you don\\'t want to modify **M**, however, and in any case, we\\'ll be using **O(N) space** for the recursion stack.)_\\n\\nIf an attempted piece turns out to be unsuccessfully and we\\'re returned back up the recursion stack, we should remember to backtrack the current index (**i**) of **M** to its previous value (**num**).\\n\\n - _**Time Complexity: O(2^N)** where **N** is the length of **M** for the attempted combinations of elements in **M**_\\n - _**Space Complexity: O(N)** for the recursion stack_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava makes it more complicated to reverse sort a primitive array, so we can just use a simple sort and then iterate through **M** backwards instead.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **64ms / 39.9MB** (beats 100% / 31%).\\n```javascript\\nvar makesquare = function(M) {\\n    let n = M.length, side = M.reduce((a,c) => a + c) / 4\\n    M.sort((a,b) => b - a)\\n    if (side !== ~~side || M[0] > side)\\n        return false\\n    const btrack = (i, space, done) => {\\n        if (done === 3)\\n            return true\\n        for (; i < n; i++) {\\n            let num = M[i], res\\n            if (num > space)\\n                continue\\n            M[i] = side + 1\\n            if (num === space)\\n                res = btrack(1, side, done+1)\\n            else\\n                res = btrack(i+1, space-num, done)\\n            if (res)\\n                return true\\n            M[i] = num\\n            while (M[i+1] === num)\\n                i++\\n        }\\n        return false\\n    }\\n    return btrack(0, side, 0)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 14.0MB** (beats 97% / 100%).\\n```python\\nclass Solution:\\n    def makesquare(self, M: List[int]) -> bool:\\n        n, side = len(M), sum(M) / 4\\n        M.sort(reverse=True)\\n        if side != int(side) or M[0] > side:\\n            return False\\n        def btrack(i, space, done): \\n            if done == 3:\\n                return True\\n            while i < n:\\n                num = M[i]\\n                if num > space:\\n                    i += 1\\n                    continue\\n                M[i] = side + 1\\n                if num == space:\\n                    res = btrack(1, side, done+1)\\n                else:\\n                    res = btrack(i+1, space-num, done)\\n                if res:\\n                    return True\\n                M[i] = num\\n                while i < n and M[i] == num:\\n                    i += 1\\n            return False\\n        return btrack(0, side, 0)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 36.1MB** (beats 99% / 94%).\\n```java\\nclass Solution {\\n    public boolean makesquare(int[] M) {\\n        Arrays.sort(M);\\n        int total = 0;\\n        for (int i = 0; i < M.length; i++)\\n            total += M[i];\\n        side = total / 4;\\n        if ((float)total / 4 > side || M[M.length-1] > side)\\n            return false;\\n        return btrack(M.length-1, side, 0, M);\\n    }\\n    private int side;\\n    private boolean btrack(int i, int space, int done, int[] M) {\\n        if (done == 3)\\n            return true;\\n        for (; i >= 0; i--) {\\n            int num = M[i];\\n            boolean res;\\n            if (num > space)\\n                continue;\\n            M[i] = side + 1;\\n            if (num == space)\\n                res = btrack(M.length-2, side, done+1, M);\\n            else\\n                res = btrack(i-1, space-num, done, M);\\n            if (res)\\n                return true;\\n            M[i] = num;\\n            while (i > 0 && M[i-1] == num)\\n                i--;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 9.5MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& M) {\\n        sort(M.begin(), M.end(), greater<int>());\\n        int total = accumulate(M.begin(), M.end(), 0);\\n        side = total / 4;\\n        if ((float)total / 4 > side || M[0] > side)\\n            return false;\\n        return btrack(0, side, 0, M);\\n    }\\nprivate:\\n    int side;\\n    bool btrack(int i, int space, int done, vector<int>& M) {\\n        if (done == 3)\\n            return true;\\n        for (; i < M.size(); i++) {\\n            int num = M[i];\\n            bool res;\\n            if (num > space)\\n                continue;\\n            M[i] = side + 1;\\n            if (num == space)\\n                res = btrack(1, side, done+1, M);\\n            else\\n                res = btrack(i+1, space-num, done, M);\\n            if (res)\\n                return true;\\n            M[i] = num;\\n            while (i < M.size() and M[i+1] == num)\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar makesquare = function(M) {\\n    let n = M.length, side = M.reduce((a,c) => a + c) / 4\\n    M.sort((a,b) => b - a)\\n    if (side !== ~~side || M[0] > side)\\n        return false\\n    const btrack = (i, space, done) => {\\n        if (done === 3)\\n            return true\\n        for (; i < n; i++) {\\n            let num = M[i], res\\n            if (num > space)\\n                continue\\n            M[i] = side + 1\\n            if (num === space)\\n                res = btrack(1, side, done+1)\\n            else\\n                res = btrack(i+1, space-num, done)\\n            if (res)\\n                return true\\n            M[i] = num\\n            while (M[i+1] === num)\\n                i++\\n        }\\n        return false\\n    }\\n    return btrack(0, side, 0)\\n};\\n```\n```python\\nclass Solution:\\n    def makesquare(self, M: List[int]) -> bool:\\n        n, side = len(M), sum(M) / 4\\n        M.sort(reverse=True)\\n        if side != int(side) or M[0] > side:\\n            return False\\n        def btrack(i, space, done): \\n            if done == 3:\\n                return True\\n            while i < n:\\n                num = M[i]\\n                if num > space:\\n                    i += 1\\n                    continue\\n                M[i] = side + 1\\n                if num == space:\\n                    res = btrack(1, side, done+1)\\n                else:\\n                    res = btrack(i+1, space-num, done)\\n                if res:\\n                    return True\\n                M[i] = num\\n                while i < n and M[i] == num:\\n                    i += 1\\n            return False\\n        return btrack(0, side, 0)\\n```\n```java\\nclass Solution {\\n    public boolean makesquare(int[] M) {\\n        Arrays.sort(M);\\n        int total = 0;\\n        for (int i = 0; i < M.length; i++)\\n            total += M[i];\\n        side = total / 4;\\n        if ((float)total / 4 > side || M[M.length-1] > side)\\n            return false;\\n        return btrack(M.length-1, side, 0, M);\\n    }\\n    private int side;\\n    private boolean btrack(int i, int space, int done, int[] M) {\\n        if (done == 3)\\n            return true;\\n        for (; i >= 0; i--) {\\n            int num = M[i];\\n            boolean res;\\n            if (num > space)\\n                continue;\\n            M[i] = side + 1;\\n            if (num == space)\\n                res = btrack(M.length-2, side, done+1, M);\\n            else\\n                res = btrack(i-1, space-num, done, M);\\n            if (res)\\n                return true;\\n            M[i] = num;\\n            while (i > 0 && M[i-1] == num)\\n                i--;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& M) {\\n        sort(M.begin(), M.end(), greater<int>());\\n        int total = accumulate(M.begin(), M.end(), 0);\\n        side = total / 4;\\n        if ((float)total / 4 > side || M[0] > side)\\n            return false;\\n        return btrack(0, side, 0, M);\\n    }\\nprivate:\\n    int side;\\n    bool btrack(int i, int space, int done, vector<int>& M) {\\n        if (done == 3)\\n            return true;\\n        for (; i < M.size(); i++) {\\n            int num = M[i];\\n            bool res;\\n            if (num > space)\\n                continue;\\n            M[i] = side + 1;\\n            if (num == space)\\n                res = btrack(1, side, done+1, M);\\n            else\\n                res = btrack(i+1, space-num, done, M);\\n            if (res)\\n                return true;\\n            M[i] = num;\\n            while (i < M.size() and M[i+1] == num)\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278008,
                "title": "python3-71-48-faster-optimal-dfs-iteratively",
                "content": "## Runtime detail\\n### Runtime: 494 ms, faster than 71.48% of Python3 online submissions for Matchsticks to Square.\\n### Memory Usage: 13.9 MB, less than 86.43% of Python3 online submissions for Matchsticks to Square.\\n\\n## Explaination\\n### Basic DFS\\nThis solution is based on the DFS search and useing iterative method.\\nBasic idea of using DFS is searching for each matchstick to put at one of four side at a time.\\n### What\\'s optimized\\n#### Initiate state\\nWe only put the first match sticks into first side, the reason will be explain below.\\n#### Searching Process\\nThe mainly difference between this method and the original dfs is it avoids some uselesss search.\\n\\nFor example,\\nif our current state is [0,0,0,0], and the focusing matchstick length is 3 and we want to know which side should we put at.\\nthe selection is same select any side comparing to any other side, for more clear explaination\\nThe state is same either put the matchstick in four sides [3, 0, 0, 0], [3, 0, 0, 0], [0, 0, 3, 0], [0, 0, 0, 3]\\nso as if we\\'re finding next step to search, we only need to find the index which have unique length value.\\n```python\\nidx_dict = dict()\\nfor i in range(4):\\n\\tif side_list[i] not in idx_dict:\\n\\t\\tidx_dict[side_list[i]] = i\\n\\telse:\\n\\t\\tcontinue\\nfor i in idx_dict.values():\\n\\tstack.append([idx+1, i, False])\\n```\\n\\n## Solution Code\\nThe full solution code is in below\\n```python\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        matchsticks.sort(reverse=True)\\n        matchsticks_len = len(matchsticks)\\n        matchsticks_sum = sum(matchsticks)\\n        side_max = matchsticks_sum >> 2\\n        if side_max << 2 != matchsticks_sum:\\n            return False\\n        \\n        side_list = [0, 0, 0, 0] \\n\\n        stack = [[0,0,False]]\\n        while stack:\\n            idx, side, visited = stack[-1]\\n            if idx == matchsticks_len:\\n                if side_list[0] == side_list[1] == side_list[2] == side_max:\\n                    return True\\n                stack.pop()\\n                continue\\n            \\n            if not visited:\\n                if side_list[side] + matchsticks[idx] <= side_max:\\n                    side_list[side] += matchsticks[idx]\\n                    stack[-1][2] = True\\n                    idx_dict = dict()\\n                    for i in range(4):\\n                        if side_list[i] not in idx_dict:\\n                            idx_dict[side_list[i]] = i\\n                        else:\\n                            continue\\n                    for i in idx_dict.values():\\n                        stack.append([idx+1, i, False])\\n                else:\\n                    stack.pop()\\n                    continue\\n            else:\\n                side_list[side] -= matchsticks[idx]\\n                stack.pop()\\n        return False\\n```\\n\\nYou may upvote if you think this solution helps you in some.\\n**And I hope my solution helps you out in somehow : D**",
                "solutionTags": [
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```python\\nidx_dict = dict()\\nfor i in range(4):\\n\\tif side_list[i] not in idx_dict:\\n\\t\\tidx_dict[side_list[i]] = i\\n\\telse:\\n\\t\\tcontinue\\nfor i in idx_dict.values():\\n\\tstack.append([idx+1, i, False])\\n```\n```python\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        matchsticks.sort(reverse=True)\\n        matchsticks_len = len(matchsticks)\\n        matchsticks_sum = sum(matchsticks)\\n        side_max = matchsticks_sum >> 2\\n        if side_max << 2 != matchsticks_sum:\\n            return False\\n        \\n        side_list = [0, 0, 0, 0] \\n\\n        stack = [[0,0,False]]\\n        while stack:\\n            idx, side, visited = stack[-1]\\n            if idx == matchsticks_len:\\n                if side_list[0] == side_list[1] == side_list[2] == side_max:\\n                    return True\\n                stack.pop()\\n                continue\\n            \\n            if not visited:\\n                if side_list[side] + matchsticks[idx] <= side_max:\\n                    side_list[side] += matchsticks[idx]\\n                    stack[-1][2] = True\\n                    idx_dict = dict()\\n                    for i in range(4):\\n                        if side_list[i] not in idx_dict:\\n                            idx_dict[side_list[i]] = i\\n                        else:\\n                            continue\\n                    for i in idx_dict.values():\\n                        stack.append([idx+1, i, False])\\n                else:\\n                    stack.pop()\\n                    continue\\n            else:\\n                side_list[side] -= matchsticks[idx]\\n                stack.pop()\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270489,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Backtracking***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a sides array of length 4\\n    \\n    vector<int> sides = {0, 0, 0, 0};\\n    \\n    bool helper(vector<int>& matchsticks, int i, int n, int target)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return true;\\n        }\\n        \\n        // fill the sides array, with every possible combination\\n        \\n        for(int k = 0; k < 4; k++)\\n        {\\n            if(sides[k] + matchsticks[i] <= target)\\n            {\\n                // add the matchsticks\\'s length to sides\\n                \\n                sides[k] += matchsticks[i];\\n                \\n                // recusivilly call the helper\\n                \\n                if(helper(matchsticks, i + 1, n, target))\\n                    return true;\\n                \\n                // if added length doesn\\'t lead to result then backtrack\\n                \\n                sides[k] -= matchsticks[i];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        \\n        int n = matchsticks.size();\\n        \\n        // find total sum of length of matchsticks\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += matchsticks[i];\\n        }\\n        \\n        // if sum is not divisible by 4, then can\\'t be divided into 4 equal set\\n        \\n        if(sum % 4)\\n            return false;\\n        \\n        // size of each equal set\\n        \\n        int target = sum / 4;\\n        \\n        // sort the matchsticks into descending order, to avoid TLE\\n        \\n        sort(matchsticks.begin(), matchsticks.end(), greater<int> ());\\n        \\n        // call the helper function\\n        \\n        return helper(matchsticks, 0, n, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a sides array of length 4\\n    \\n    vector<int> sides = {0, 0, 0, 0};\\n    \\n    bool helper(vector<int>& matchsticks, int i, int n, int target)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return true;\\n        }\\n        \\n        // fill the sides array, with every possible combination\\n        \\n        for(int k = 0; k < 4; k++)\\n        {\\n            if(sides[k] + matchsticks[i] <= target)\\n            {\\n                // add the matchsticks\\'s length to sides\\n                \\n                sides[k] += matchsticks[i];\\n                \\n                // recusivilly call the helper\\n                \\n                if(helper(matchsticks, i + 1, n, target))\\n                    return true;\\n                \\n                // if added length doesn\\'t lead to result then backtrack\\n                \\n                sides[k] -= matchsticks[i];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        \\n        int n = matchsticks.size();\\n        \\n        // find total sum of length of matchsticks\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += matchsticks[i];\\n        }\\n        \\n        // if sum is not divisible by 4, then can\\'t be divided into 4 equal set\\n        \\n        if(sum % 4)\\n            return false;\\n        \\n        // size of each equal set\\n        \\n        int target = sum / 4;\\n        \\n        // sort the matchsticks into descending order, to avoid TLE\\n        \\n        sort(matchsticks.begin(), matchsticks.end(), greater<int> ());\\n        \\n        // call the helper function\\n        \\n        return helper(matchsticks, 0, n, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270456,
                "title": "a-simple-submask-enumeration",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& a) {\\n        int n = a.size();\\n        int tot = 0;\\n        for (auto x : a) tot += x;\\n        if (tot%4) return false; // the total sum of lengths should be divisible by 4\\n        \\n        for (int m=0; m<(1<<(n-1)); m++) {\\n            int part = 0;\\n            for (int i=0; i<n; i++) {\\n                if ((m>>i)&1) part += a[i];\\n            }\\n            if (part != tot/2) continue;  // we first check if the matches can be divided into two partitions with equal sums.\\n            \\n            bool b1 = false;\\n            bool b2 = false;\\n            \\n            for (int s=m; s>0; s=(s-1)&m) {  // submask enumeration\\n                int part = 0;\\n                for (int i=0; i<n; i++) {\\n                    if ((s>>i)&1) part += a[i];\\n                }\\n                if (part == tot/4) {\\n\\t\\t\\t\\t\\tb1 = true;  // we found a submask, sum of which is tot / 4\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n            }\\n            int m2 = m^((1<<n)-1);  // m2 is a \\'flip\\' of mask m\\n            for (int s=m2; s>0; s=(s-1)&m2) {  // second submask enumeration\\n                int part = 0;\\n                for (int i=0; i<n; i++) {\\n                    if ((s>>i)&1) part += a[i];\\n                }\\n                if (part == tot/4) {\\n\\t\\t\\t\\t\\tb2 = true; // we found another submask, sum of which is tot / 4\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n            }\\n            if (b1&&b2) return true;  // we found the desired partition :)\\n        }        \\n        \\n        return false; // we failed to find the desired partition :(\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& a) {\\n        int n = a.size();\\n        int tot = 0;\\n        for (auto x : a) tot += x;\\n        if (tot%4) return false; // the total sum of lengths should be divisible by 4\\n        \\n        for (int m=0; m<(1<<(n-1)); m++) {\\n            int part = 0;\\n            for (int i=0; i<n; i++) {\\n                if ((m>>i)&1) part += a[i];\\n            }\\n            if (part != tot/2) continue;  // we first check if the matches can be divided into two partitions with equal sums.\\n            \\n            bool b1 = false;\\n            bool b2 = false;\\n            \\n            for (int s=m; s>0; s=(s-1)&m) {  // submask enumeration\\n                int part = 0;\\n                for (int i=0; i<n; i++) {\\n                    if ((s>>i)&1) part += a[i];\\n                }\\n                if (part == tot/4) {\\n\\t\\t\\t\\t\\tb1 = true;  // we found a submask, sum of which is tot / 4\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n            }\\n            int m2 = m^((1<<n)-1);  // m2 is a \\'flip\\' of mask m\\n            for (int s=m2; s>0; s=(s-1)&m2) {  // second submask enumeration\\n                int part = 0;\\n                for (int i=0; i<n; i++) {\\n                    if ((s>>i)&1) part += a[i];\\n                }\\n                if (part == tot/4) {\\n\\t\\t\\t\\t\\tb2 = true; // we found another submask, sum of which is tot / 4\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n            }\\n            if (b1&&b2) return true;  // we found the desired partition :)\\n        }        \\n        \\n        return false; // we failed to find the desired partition :(\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270287,
                "title": "daily-leetcoding-challenge-july-day-12",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/matchsticks-to-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/matchsticks-to-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1275432,
                "title": "rust-back-tracking",
                "content": "```rust\\nimpl Solution {\\n    pub fn makesquare(mut matchsticks: Vec<i32>) -> bool {\\n        let perim: i32 = matchsticks.iter().sum();\\n        perim % 4 == 0 && Self::solve(&mut matchsticks[..], 0, 0, 1, perim / 4)\\n    }\\n\\n    fn solve(sticks: &mut [i32], l: usize, len: i32, side: u8, max: i32) -> bool {\\n        side == 4\\n            || len == max && Self::solve(sticks, 0, 0, side + 1, max)\\n            || (l..sticks.len()).any(|i| {\\n                let stick = std::mem::take(&mut sticks[i]);\\n                let res = stick != 0 && Self::solve(sticks, i + 1, len + stick, side, max);\\n                sticks[i] = stick;\\n                res\\n            })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn makesquare(mut matchsticks: Vec<i32>) -> bool {\\n        let perim: i32 = matchsticks.iter().sum();\\n        perim % 4 == 0 && Self::solve(&mut matchsticks[..], 0, 0, 1, perim / 4)\\n    }\\n\\n    fn solve(sticks: &mut [i32], l: usize, len: i32, side: u8, max: i32) -> bool {\\n        side == 4\\n            || len == max && Self::solve(sticks, 0, 0, side + 1, max)\\n            || (l..sticks.len()).any(|i| {\\n                let stick = std::mem::take(&mut sticks[i]);\\n                let res = stick != 0 && Self::solve(sticks, i + 1, len + stick, side, max);\\n                sticks[i] = stick;\\n                res\\n            })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 343379,
                "title": "better-solution-than-dfs-bfs-dp-with-bit-masking-best-for-interviews",
                "content": "The question can be converted into Can the array be partitioned into 4 equal sum subsequences. It is subset of [698. Partition to K Equal Sum Subsets](http://leetcode.com/problems/partition-to-k-equal-sum-subsets/) problem\\n\\nBelow is the thread for general solution with explaination of Bit Masking:\\n[DP with Bit Masking Solution :- Best for Interviews](http://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/335668/DP-with-Bit-Masking-Solution-%3A-Best-for-Interviews)\\n\\nThe below code is for this problem:\\ndp[i] denotes - whether sum can be divided into 4 subsets of equal sum.\\ntotal[i] denotes total sum using that nums[i] less than target sum.\\nNow loop over entire power set of nums, set the jth bit using newset = i | (1<<j) and check whether this sum is less or equal to target sum. If yes, mark this index true and set its total.\\nThe last index of D tells whether whole array can be divided into 4 subsets of equal sum.\\n\\t \\n\\t```\\n\\tpublic boolean makesquare(int[] nums) {\\n    \\tif(nums == null || nums.length < 4)\\n    \\t\\treturn false;\\n    \\tint n = nums.length;\\n    \\tboolean []dp = new boolean[1<<n];\\n    \\tdp[0] = true;\\n    \\tint []total = new int[1<<n];\\n    \\tint sum = 0;\\n    \\tfor(int num : nums)\\n    \\t\\tsum += num;\\n    \\tArrays.sort(nums);\\n    \\tif(sum%4 != 0)\\n    \\t\\treturn false;\\n    \\tsum /= 4;\\n    \\tif(nums[n-1] > sum)\\n    \\t\\treturn false;\\n    \\t// Loop over power set\\n    \\tfor(int i = 0;i < 1<<n;i++) {\\n    \\t\\tif(dp[i]) {\\n    \\t\\t\\tfor(int j = 0;j < n;j++) {\\n    \\t\\t\\t\\t// Loop over each element to find subset\\n    \\t\\t\\t\\tint temp = i | (1<<j);\\n    \\t\\t\\t\\tif(temp != i) {\\n    \\t\\t\\t\\t\\t// if total sum is less than target store in dp and total array\\n    \\t\\t\\t\\t\\tif(nums[j] <= (sum - (total[i]%sum))) {\\n    \\t\\t\\t\\t\\t\\tdp[temp] = true;\\n    \\t\\t\\t\\t\\t\\ttotal[temp] = nums[j] + total[i];\\n    \\t\\t\\t\\t\\t} else \\n    \\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn dp[(1<<n) -1]; \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean makesquare(int[] nums) {\\n    \\tif(nums == null || nums.length < 4)\\n    \\t\\treturn false;\\n    \\tint n = nums.length;\\n    \\tboolean []dp = new boolean[1<<n];\\n    \\tdp[0] = true;\\n    \\tint []total = new int[1<<n];\\n    \\tint sum = 0;\\n    \\tfor(int num : nums)\\n    \\t\\tsum += num;\\n    \\tArrays.sort(nums);\\n    \\tif(sum%4 != 0)\\n    \\t\\treturn false;\\n    \\tsum /= 4;\\n    \\tif(nums[n-1] > sum)\\n    \\t\\treturn false;\\n    \\t// Loop over power set\\n    \\tfor(int i = 0;i < 1<<n;i++) {\\n    \\t\\tif(dp[i]) {\\n    \\t\\t\\tfor(int j = 0;j < n;j++) {\\n    \\t\\t\\t\\t// Loop over each element to find subset\\n    \\t\\t\\t\\tint temp = i | (1<<j);\\n    \\t\\t\\t\\tif(temp != i) {\\n    \\t\\t\\t\\t\\t// if total sum is less than target store in dp and total array\\n    \\t\\t\\t\\t\\tif(nums[j] <= (sum - (total[i]%sum))) {\\n    \\t\\t\\t\\t\\t\\tdp[temp] = true;\\n    \\t\\t\\t\\t\\t\\ttotal[temp] = nums[j] + total[i];\\n    \\t\\t\\t\\t\\t} else \\n    \\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn dp[(1<<n) -1]; \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 132023,
                "title": "a-easy-java-dfs-solution-with-detailed-explanation-beats-86-76",
                "content": "Actually, It\\'s my second time to solve this question. In my first time, I just can not get any idea to solve this solution and I go for Discuss for a solution. In my second time, I begin to think: how would I solve this question using DFS? We just need find 4 disjoint subsequence in this array, and which each subsequence\\'s sum is the sum of array divided by 4.\\n\\nSo we can just exclude some situation, like the sum of the array can not divisable by 4. After that, we can using DFS to solve this solution. And we can easily to solve the problem: find a subsequence whoes\\'sum is the target. We just need to resuse it.\\n\\n```java\\nclass Solution {\\n    public boolean makesquare(int[] nums) {\\n        if (nums.length == 0) return false;\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n        }\\n        // First jude sum can divide by 4\\n        if (sum % 4 != 0) {\\n            return false;\\n        }\\n        int width = sum / 4;\\n        // If any num bigger than width, return false\\n        for (int num : nums) {\\n            if (num > width) return false;\\n        }\\n        boolean[] used = new boolean[nums.length];\\n        return dfs(nums, used, 0, 0, width, 0);\\n    }\\n    \\n    private boolean dfs(int[] nums, boolean[] used, int acc, int start, int target, int count) {\\n        if (count == 4) {\\n            // Judge if we use all the nums\\n            for (int i = 0; i < used.length; i++) {\\n                if (!used[i]) return false;\\n            }\\n            return true;\\n        } else if (acc > target) {\\n            return false;\\n        } else if (acc == target) {\\n            return dfs(nums, used, 0, 0, target, count + 1);\\n        } else {\\n           for (int i = start; i < nums.length; i++) {\\n               if (!used[i]) {\\n                   used[i] = true;\\n                   if (dfs(nums, used, acc + nums[i], i + 1, target, count)) return true;\\n                   used[i] = false;\\n               }\\n           }\\n           return false; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean makesquare(int[] nums) {\\n        if (nums.length == 0) return false;\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n        }\\n        // First jude sum can divide by 4\\n        if (sum % 4 != 0) {\\n            return false;\\n        }\\n        int width = sum / 4;\\n        // If any num bigger than width, return false\\n        for (int num : nums) {\\n            if (num > width) return false;\\n        }\\n        boolean[] used = new boolean[nums.length];\\n        return dfs(nums, used, 0, 0, width, 0);\\n    }\\n    \\n    private boolean dfs(int[] nums, boolean[] used, int acc, int start, int target, int count) {\\n        if (count == 4) {\\n            // Judge if we use all the nums\\n            for (int i = 0; i < used.length; i++) {\\n                if (!used[i]) return false;\\n            }\\n            return true;\\n        } else if (acc > target) {\\n            return false;\\n        } else if (acc == target) {\\n            return dfs(nums, used, 0, 0, target, count + 1);\\n        } else {\\n           for (int i = start; i < nums.length; i++) {\\n               if (!used[i]) {\\n                   used[i] = true;\\n                   if (dfs(nums, used, acc + nums[i], i + 1, target, count)) return true;\\n                   used[i] = false;\\n               }\\n           }\\n           return false; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688443,
                "title": "c-bitmask-memoization-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int z,int &n,int x,int &s,int y,vector<int> &v,vector<int> &dp){\\n        if(y==4){\\n            return true;\\n        }\\n        if(z == (1<<n)-1){\\n            return true;\\n        }\\n        if(dp[z] != -1)return dp[z];\\n        bool a = false;\\n        for(int i = 0; i < n; i++){\\n            if((z&(1<<i))==0){\\n                x += v[i];\\n                if(x<s){\\n                    a |= solve(z|(1<<i),n,x,s,y,v,dp);\\n                }else if(s==x){\\n                    a |= solve(z|(1<<i),n,0,s,y+1,v,dp);\\n                }\\n                x -= v[i];\\n            }\\n        }\\n        return dp[z] = a;\\n    }\\n    bool makesquare(vector<int>& v) {\\n        int s = 0;\\n        for(auto &i: v){\\n            s += i;\\n        }\\n        if(s%4)return false;\\n        s /= 4;\\n        int n = v.size();\\n        sort(v.begin(),v.end());\\n        vector<int> dp((1<<n)+15,-1);\\n        return solve(0,n,0,s,0,v,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int z,int &n,int x,int &s,int y,vector<int> &v,vector<int> &dp){\\n        if(y==4){\\n            return true;\\n        }\\n        if(z == (1<<n)-1){\\n            return true;\\n        }\\n        if(dp[z] != -1)return dp[z];\\n        bool a = false;\\n        for(int i = 0; i < n; i++){\\n            if((z&(1<<i))==0){\\n                x += v[i];\\n                if(x<s){\\n                    a |= solve(z|(1<<i),n,x,s,y,v,dp);\\n                }else if(s==x){\\n                    a |= solve(z|(1<<i),n,0,s,y+1,v,dp);\\n                }\\n                x -= v[i];\\n            }\\n        }\\n        return dp[z] = a;\\n    }\\n    bool makesquare(vector<int>& v) {\\n        int s = 0;\\n        for(auto &i: v){\\n            s += i;\\n        }\\n        if(s%4)return false;\\n        s /= 4;\\n        int n = v.size();\\n        sort(v.begin(),v.end());\\n        vector<int> dp((1<<n)+15,-1);\\n        return solve(0,n,0,s,0,v,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281146,
                "title": "473-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Calculate the total length of all matchsticks in the input list matchsticks.\\n2. If the total length is not divisible by 4 or if the length of the longest matchstick is greater than total_length // 4, return False as it\\'s impossible to form a square using the given matchsticks.\\n3. Calculate the target length of each side of the square by dividing total_length by 4.\\n4. Sort the matchsticks list in decreasing order so that we can consider the larger matchsticks first while forming the sides of the square.\\n5. Define a recursive function form_sides(i, sides) that takes two arguments - the index i of the current matchstick being considered, and a tuple sides representing the current lengths of each side of the square.\\n6. If we\\'ve considered all matchsticks and all sides of the square are of equal length, return True as we\\'ve successfully formed a square using the matchsticks.\\n7. For each of the 4 sides, check if adding the current matchstick\\'s length to the side\\'s length results in a length less than or equal to the target length. If yes, create a new list new_sides by updating the length of that side with the sum of its current length and the current matchstick\\'s length.\\n8. Recursively call the form_sides function with the updated index i+1 and the updated new_sides tuple as arguments. If this recursive call returns True, return True as well, since we\\'ve successfully formed a square.\\n9. If none of the recursive calls from step 8 returned True, return False, as it\\'s not possible to form a square using the given matchsticks.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def makesquare(self, matchsticks: List[int]) -> bool:\\n    total_length = sum(matchsticks)\\n    if total_length % 4 != 0 or max(matchsticks) > total_length // 4:\\n        return False\\n    target_length = total_length // 4\\n    matchsticks.sort(reverse=True)\\n    \\n    def form_sides(i, sides):\\n        if i == len(matchsticks) and all(side == target_length for side in sides):\\n            return True\\n        \\n        for j in range(4):\\n            if sides[j] + matchsticks[i] <= target_length:\\n                new_sides = list(sides)\\n                new_sides[j] += matchsticks[i]\\n                if form_sides(i+1, tuple(new_sides)):\\n                    return True\\n        \\n        return False\\n    \\n    return form_sides(0, (0, 0, 0, 0))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n  def makesquare(self, matchsticks: List[int]) -> bool:\\n    total_length = sum(matchsticks)\\n    if total_length % 4 != 0 or max(matchsticks) > total_length // 4:\\n        return False\\n    target_length = total_length // 4\\n    matchsticks.sort(reverse=True)\\n    \\n    def form_sides(i, sides):\\n        if i == len(matchsticks) and all(side == target_length for side in sides):\\n            return True\\n        \\n        for j in range(4):\\n            if sides[j] + matchsticks[i] <= target_length:\\n                new_sides = list(sides)\\n                new_sides[j] += matchsticks[i]\\n                if form_sides(i+1, tuple(new_sides)):\\n                    return True\\n        \\n        return False\\n    \\n    return form_sides(0, (0, 0, 0, 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270926,
                "title": "java-dp-tle-back-tracking-clean-code",
                "content": "__DP RECURSIVE SOLUTION__(Throws TLE)\\n* Would cause ```MLE``` if we try to memoize using the below recursive function. \\uD83E\\uDEE1\\n```\\nclass Solution {\\n\\n    public boolean makesquare(int[] matchsticks) {\\n        if (matchsticks == null || matchsticks.length < 4) return false;\\n        int n = matchsticks.length;\\n        return solve(matchsticks, 0, 0, 0, 0, 0);\\n    }\\n\\n    private boolean solve(int[] matchSticks, int left, int up, int right, int down, int index) {\\n        if (index == matchSticks.length) {\\n            return (left == right && down == up && left == down && right == up);\\n        }\\n\\n        boolean result = false;\\n\\n        result |= solve(matchSticks, left + matchSticks[index], up, right, down, index + 1);\\n        result |= solve(matchSticks, left, up + matchSticks[index], right, down, index + 1);\\n        result |= solve(matchSticks, left, up, right + matchSticks[index], down, index + 1);\\n        result |= solve(matchSticks, left, up, right, down + matchSticks[index], index + 1);\\n\\n        return result;\\n    }\\n}\\n```\\n\\n\\n__BACK TRACKING SOLUTION__\\n```\\nclass Solution {\\n\\n    public boolean makesquare(int[] matchsticks) {\\n        if (matchsticks == null || matchsticks.length < 4) return false;\\n        int n = matchsticks.length;\\n        int perimeter = getPerimeter(matchsticks);\\n        if (perimeter % 4 != 0) return false;\\n\\n        int side[] = { perimeter / 4, perimeter / 4, perimeter / 4, perimeter / 4 };\\n\\n        Arrays.sort(matchsticks);\\n\\n        return makesquareUtil(matchsticks, side, n - 1);\\n    }\\n\\n    private boolean makesquareUtil(int[] match, int[] sides, int index) {\\n        if (index == -1) \\n            return sides[0] == sides[1] && sides[1] == sides[2] && sides[2] == sides[3];\\n\\n        for (int i = 0; i < sides.length; i++) {\\n            if (match[index] <= sides[i]) {\\n                sides[i] -= match[index]; \\n                if (makesquareUtil(match, sides, index - 1)) \\n\\t\\t\\t\\t\\treturn true;\\n                sides[i] += match[index];//back track\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private int getPerimeter(int[] matchSticks) {\\n        int perimeter = 0;\\n        for (int stick : matchSticks) perimeter += stick;\\n        return perimeter;\\n    }\\n}\\n```\\n__Feel free to connect, comment and criticize__ \\uD83E\\uDEE1\\nauthor : [@bharathkalyans](https://leetcode.com/bharathkalyans/)\\nlinkedin : [@bharathkalyans](https://www.linkedin.com/in/bharathkalyans/)\\ntwitter : [@bharathkalyans](https://twitter.com/bharathkalyans)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```MLE```\n```\\nclass Solution {\\n\\n    public boolean makesquare(int[] matchsticks) {\\n        if (matchsticks == null || matchsticks.length < 4) return false;\\n        int n = matchsticks.length;\\n        return solve(matchsticks, 0, 0, 0, 0, 0);\\n    }\\n\\n    private boolean solve(int[] matchSticks, int left, int up, int right, int down, int index) {\\n        if (index == matchSticks.length) {\\n            return (left == right && down == up && left == down && right == up);\\n        }\\n\\n        boolean result = false;\\n\\n        result |= solve(matchSticks, left + matchSticks[index], up, right, down, index + 1);\\n        result |= solve(matchSticks, left, up + matchSticks[index], right, down, index + 1);\\n        result |= solve(matchSticks, left, up, right + matchSticks[index], down, index + 1);\\n        result |= solve(matchSticks, left, up, right, down + matchSticks[index], index + 1);\\n\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public boolean makesquare(int[] matchsticks) {\\n        if (matchsticks == null || matchsticks.length < 4) return false;\\n        int n = matchsticks.length;\\n        int perimeter = getPerimeter(matchsticks);\\n        if (perimeter % 4 != 0) return false;\\n\\n        int side[] = { perimeter / 4, perimeter / 4, perimeter / 4, perimeter / 4 };\\n\\n        Arrays.sort(matchsticks);\\n\\n        return makesquareUtil(matchsticks, side, n - 1);\\n    }\\n\\n    private boolean makesquareUtil(int[] match, int[] sides, int index) {\\n        if (index == -1) \\n            return sides[0] == sides[1] && sides[1] == sides[2] && sides[2] == sides[3];\\n\\n        for (int i = 0; i < sides.length; i++) {\\n            if (match[index] <= sides[i]) {\\n                sides[i] -= match[index]; \\n                if (makesquareUtil(match, sides, index - 1)) \\n\\t\\t\\t\\t\\treturn true;\\n                sides[i] += match[index];//back track\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private int getPerimeter(int[] matchSticks) {\\n        int perimeter = 0;\\n        for (int stick : matchSticks) perimeter += stick;\\n        return perimeter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270413,
                "title": "c-backtracking-beginner-friendly-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector <int> matchsticks;\\n    \\n    int target = 0;\\n    bool generate(int level,int a,int b,int c, int d){\\n        // if all match stick used and all sides have sum of target we return true\\n        if(level == n){\\n            return a == target && b == target && c == target && d == target; \\n        }\\n        \\n        // trying to add current stick to side a\\n        if(a+matchsticks[level]<=target){\\n           if(generate(level+1,a+matchsticks[level],b,c,d)) return true;\\n        }\\n        \\n        // trying to add current stick to side b\\n        if(b+matchsticks[level]<=target){\\n            if(generate(level+1,a,b+matchsticks[level],c,d)) return true;\\n        }\\n        \\n        // trying to add current stick to side c\\n        if(c+matchsticks[level]<=target){\\n           if(generate(level+1,a,b,c+matchsticks[level],d)) return true;\\n        }\\n        \\n        // trying to add current stick to side d\\n        if(d+matchsticks[level]<=target){\\n           if(generate(level+1,a,b,c,d+matchsticks[level])) return true;\\n        }\\n        \\n        // if none of them works return false\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& _matchsticks) {\\n        matchsticks = _matchsticks;\\n        n = matchsticks.size();\\n        int sm=0;\\n        for(int i=0;i<n;i++) sm+=matchsticks[i];\\n        // if sum is not divisible by 4 then its not possible\\n        if(sm%4 !=0) return false;\\n        \\n        // each side has to become sum by 4\\n        target = sm/4;\\n        sort(matchsticks.rbegin(),matchsticks.rend());\\n        return generate(0,0,0,0,0);\\n        }\\n    };\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector <int> matchsticks;\\n    \\n    int target = 0;\\n    bool generate(int level,int a,int b,int c, int d){\\n        // if all match stick used and all sides have sum of target we return true\\n        if(level == n){\\n            return a == target && b == target && c == target && d == target; \\n        }\\n        \\n        // trying to add current stick to side a\\n        if(a+matchsticks[level]<=target){\\n           if(generate(level+1,a+matchsticks[level],b,c,d)) return true;\\n        }\\n        \\n        // trying to add current stick to side b\\n        if(b+matchsticks[level]<=target){\\n            if(generate(level+1,a,b+matchsticks[level],c,d)) return true;\\n        }\\n        \\n        // trying to add current stick to side c\\n        if(c+matchsticks[level]<=target){\\n           if(generate(level+1,a,b,c+matchsticks[level],d)) return true;\\n        }\\n        \\n        // trying to add current stick to side d\\n        if(d+matchsticks[level]<=target){\\n           if(generate(level+1,a,b,c,d+matchsticks[level])) return true;\\n        }\\n        \\n        // if none of them works return false\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& _matchsticks) {\\n        matchsticks = _matchsticks;\\n        n = matchsticks.size();\\n        int sm=0;\\n        for(int i=0;i<n;i++) sm+=matchsticks[i];\\n        // if sum is not divisible by 4 then its not possible\\n        if(sm%4 !=0) return false;\\n        \\n        // each side has to become sum by 4\\n        target = sm/4;\\n        sort(matchsticks.rbegin(),matchsticks.rend());\\n        return generate(0,0,0,0,0);\\n        }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570227,
                "title": "c-easy-recursive-bitmasking",
                "content": "* The idea is to maintain a bitmask which is an integer with the number of bits set=no. of array elements already visited and remaining bits \\'0\\' so that we don\\'t visit the visited elements repeatedly.\\n* For those of you new to Bit Masking, refer this article : https://medium.com/analytics-vidhya/bits-bitmasking-62277789f6f5.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    long long int mask;\\n    \\n    bool solve(vector<int> &matchsticks, int target, long long mask, int currSum, int i, int k){\\n        if(k==1) return true; //If the sum is multiple of 4 and already 3 sides are built, then 4th side can be built.\\n        \\n        if(currSum==target) \\n                return solve(matchsticks, target, mask, 0, 0, k-1);  //If we have built a side, set back the currSum to \\'0\\' and start building the next side. \\n        \\n        for(int j=i; j<matchsticks.size(); j++){ //j=i because while building a side, we start traversing the array from where we left off\\n            \\n            if((mask&(1<<j))==0 || currSum+matchsticks[j]>target) continue; //If the element is already visited or it\\'s causing the currSum to exceed the target, don\\'t use the element.\\n            \\n            mask=mask&~(1<<j);  //If not, mark it as visited and continue.\\n            if(solve(matchsticks, target, mask, currSum+matchsticks[j], j+1, k))  //continue traversing the other elements with the currSum\\n                return true;\\n            mask=mask|(1<<j); //If we returned with a false, that means the curr_element is not working\\n            \\n        }\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum=0;\\n        sum = accumulate(matchsticks.begin(), matchsticks.end(), sum);\\n        if(matchsticks.size()<4||sum%4) return false; //If the elements don\\'t sum to aq multiple of 4, we can\\'t make a square.\\n        \\n        mask=(1<<matchsticks.size())-1; //Initially mask=1111... (no. of elements in the array) represents that none of the elements are visited\\n        return solve(matchsticks, sum/4, mask, 0, 0, 4); //k=4 is the number of sides to build.\\n    }\\n};\\n```\\n\\n**If you like my solution and explanation, please upvote!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mask;\\n    \\n    bool solve(vector<int> &matchsticks, int target, long long mask, int currSum, int i, int k){\\n        if(k==1) return true; //If the sum is multiple of 4 and already 3 sides are built, then 4th side can be built.\\n        \\n        if(currSum==target) \\n                return solve(matchsticks, target, mask, 0, 0, k-1);  //If we have built a side, set back the currSum to \\'0\\' and start building the next side. \\n        \\n        for(int j=i; j<matchsticks.size(); j++){ //j=i because while building a side, we start traversing the array from where we left off\\n            \\n            if((mask&(1<<j))==0 || currSum+matchsticks[j]>target) continue; //If the element is already visited or it\\'s causing the currSum to exceed the target, don\\'t use the element.\\n            \\n            mask=mask&~(1<<j);  //If not, mark it as visited and continue.\\n            if(solve(matchsticks, target, mask, currSum+matchsticks[j], j+1, k))  //continue traversing the other elements with the currSum\\n                return true;\\n            mask=mask|(1<<j); //If we returned with a false, that means the curr_element is not working\\n            \\n        }\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum=0;\\n        sum = accumulate(matchsticks.begin(), matchsticks.end(), sum);\\n        if(matchsticks.size()<4||sum%4) return false; //If the elements don\\'t sum to aq multiple of 4, we can\\'t make a square.\\n        \\n        mask=(1<<matchsticks.size())-1; //Initially mask=1111... (no. of elements in the array) represents that none of the elements are visited\\n        return solve(matchsticks, sum/4, mask, 0, 0, 4); //k=4 is the number of sides to build.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273866,
                "title": "python-simple-and-easy-to-understand-dfs",
                "content": "Memorization is not necessary. Sorting from largest to smallest is the trick.\\n\\n```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        matchsticks = sorted(matchsticks, reverse=True)\\n        self.flag = False\\n        perimeter = sum(matchsticks)\\n        n = len(matchsticks)\\n        if perimeter % 4 != 0: \\n            return False\\n        else:\\n            side = perimeter / 4\\n       # @lru_cache(maxsize=None)\\n        def dfs(l1, l2, l3, l4, k):\\n            if k == n or self.flag:\\n                if l1 == l2 == l3 == l4:\\n                    # print(l1, l2, l3, l4)\\n                    self.flag = True\\n                return\\n\\n            l = matchsticks[k]\\n            if l1 + l <= side:\\n                dfs(l1 + l, l2, l3, l4, k + 1)\\n            if l2 + l <= side:\\n                dfs(l1, l2 + l, l3, l4, k + 1)\\n            if l3 + l <= side:\\n                dfs(l1, l2, l3 + l, l4, k + 1)\\n            if l4 + l <= side:\\n                dfs(l1, l2, l3, l4 + l, k + 1)\\n        dfs(0, 0, 0, 0, 0)\\n        return self.flag\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        matchsticks = sorted(matchsticks, reverse=True)\\n        self.flag = False\\n        perimeter = sum(matchsticks)\\n        n = len(matchsticks)\\n        if perimeter % 4 != 0: \\n            return False\\n        else:\\n            side = perimeter / 4\\n       # @lru_cache(maxsize=None)\\n        def dfs(l1, l2, l3, l4, k):\\n            if k == n or self.flag:\\n                if l1 == l2 == l3 == l4:\\n                    # print(l1, l2, l3, l4)\\n                    self.flag = True\\n                return\\n\\n            l = matchsticks[k]\\n            if l1 + l <= side:\\n                dfs(l1 + l, l2, l3, l4, k + 1)\\n            if l2 + l <= side:\\n                dfs(l1, l2 + l, l3, l4, k + 1)\\n            if l3 + l <= side:\\n                dfs(l1, l2, l3 + l, l4, k + 1)\\n            if l4 + l <= side:\\n                dfs(l1, l2, l3, l4 + l, k + 1)\\n        dfs(0, 0, 0, 0, 0)\\n        return self.flag\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95762,
                "title": "two-different-solutions",
                "content": "**backtracking + memorization**\\n```\\npublic class Solution {\\n    Map<Integer, Boolean> map = new HashMap();\\n    public boolean makesquare(int[] nums) {\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum % 4 != 0 || sum == 0) return false;\\n        sum >>>= 2;\\n        Arrays.sort(nums);\\n        return canMatch(nums, sum, 0, 0, 0);\\n    }\\n    \\n    private boolean canMatch(int[] nums, int target, int sum, int vis, int count) {\\n        if (count == 4) return true;\\n        if (map.containsKey(vis)) return map.get(vis);\\n        for (int i = 0; i < nums.length; i++) {\\n            if ((vis >>> i & 1) == 1 || sum + nums[i] > target) continue;\\n            if (sum + nums[i] == target)\\n                if (canMatch(nums, target, 0, vis ^ (1 << i), count + 1)) {\\n                    map.put(vis, true);\\n                    return true;\\n                }\\n            if (canMatch(nums, target, sum + nums[i], vis ^ (1 << i), count)) {\\n                map.put(vis, true);\\n                return true;\\n            }\\n        }\\n        map.put(vis, false);\\n        return false;\\n    }\\n}\\n```\\n\\n**DP**, you can say this is DP, but it's actually more like **2^n** exponential time brute force. Although it's exponential, as [wiki](https://en.wikipedia.org/wiki/Partition_problem) says, it still pass OJ, and relatively fast because of the small data, which is less than 15. \\n\\nThis solution is inspired by a ACM dashen. )\\n\\n```\\npublic class Solution {\\n    public boolean makesquare(int[] nums) {\\n        int sum = 0, n = nums.length;\\n        for (int num : nums) sum += num;\\n        if (sum == 0 || n == 0 || (sum & 0b11) != 0) return false;\\n        sum >>>= 2;\\n        boolean[] dp = new boolean[1 << n];\\n        List<Integer> parts = new ArrayList();\\n        int all = (1 << n) - 1; // all possible choices\\n        // try all choices, 1 mask is 1 choice\\n        // time complexity O(2^n)\\n        for (int mask = 0; mask <= all; mask++) {\\n            int tmp = 0;\\n            for (int i = 0; i < n; i++) { // retrieve \"1\", choose num at i\\n                if (((mask >>> i) & 1) == 1)\\n                    tmp += nums[i];\\n            }\\n            if (tmp == sum) { // check whether it is valid\\n                for (int x : parts) {\\n                    // check whether the new choice is conflit with others\\n                    if ((mask & x) == 0) {\\n                        // if there is an exist mask x has no conflit with current mask\\n                        // mark their combination \"mask1 + mask2\" as true\\n                        dp[mask | x] = true;\\n                        // check whether there is another \"mask3 + mask4\" is valid\\n                        // if there is, return true\\n                        if (dp[all ^ (mask | x)]) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                // record every kinds of equal-to-sum combination\\n                parts.add(mask);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    Map<Integer, Boolean> map = new HashMap();\\n    public boolean makesquare(int[] nums) {\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum % 4 != 0 || sum == 0) return false;\\n        sum >>>= 2;\\n        Arrays.sort(nums);\\n        return canMatch(nums, sum, 0, 0, 0);\\n    }\\n    \\n    private boolean canMatch(int[] nums, int target, int sum, int vis, int count) {\\n        if (count == 4) return true;\\n        if (map.containsKey(vis)) return map.get(vis);\\n        for (int i = 0; i < nums.length; i++) {\\n            if ((vis >>> i & 1) == 1 || sum + nums[i] > target) continue;\\n            if (sum + nums[i] == target)\\n                if (canMatch(nums, target, 0, vis ^ (1 << i), count + 1)) {\\n                    map.put(vis, true);\\n                    return true;\\n                }\\n            if (canMatch(nums, target, sum + nums[i], vis ^ (1 << i), count)) {\\n                map.put(vis, true);\\n                return true;\\n            }\\n        }\\n        map.put(vis, false);\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean makesquare(int[] nums) {\\n        int sum = 0, n = nums.length;\\n        for (int num : nums) sum += num;\\n        if (sum == 0 || n == 0 || (sum & 0b11) != 0) return false;\\n        sum >>>= 2;\\n        boolean[] dp = new boolean[1 << n];\\n        List<Integer> parts = new ArrayList();\\n        int all = (1 << n) - 1; // all possible choices\\n        // try all choices, 1 mask is 1 choice\\n        // time complexity O(2^n)\\n        for (int mask = 0; mask <= all; mask++) {\\n            int tmp = 0;\\n            for (int i = 0; i < n; i++) { // retrieve \"1\", choose num at i\\n                if (((mask >>> i) & 1) == 1)\\n                    tmp += nums[i];\\n            }\\n            if (tmp == sum) { // check whether it is valid\\n                for (int x : parts) {\\n                    // check whether the new choice is conflit with others\\n                    if ((mask & x) == 0) {\\n                        // if there is an exist mask x has no conflit with current mask\\n                        // mark their combination \"mask1 + mask2\" as true\\n                        dp[mask | x] = true;\\n                        // check whether there is another \"mask3 + mask4\" is valid\\n                        // if there is, return true\\n                        if (dp[all ^ (mask | x)]) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                // record every kinds of equal-to-sum combination\\n                parts.add(mask);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219065,
                "title": "backtracking-c",
                "content": "```\\nclass Solution {\\n    bool dfs(int i, vector<int> &ms, int side, vector<int> &v, int n) {\\n        if(i == n) {\\n            return v[0] == v[1] && v[1] == v[2] && v[2] == v[3];\\n        }\\n        for(int k=0; k<4; k++) {\\n            if(v[k] + ms[i] > side) continue;\\n            v[k] += ms[i];\\n            if(dfs(i + 1, ms, side, v, n)) return true;\\n            v[k] -= ms[i];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& ms) {\\n        int s = accumulate(ms.begin(), ms.end(), 0), n = ms.size();\\n        if(s % 4) return false;\\n        sort(ms.begin(), ms.end(), greater<int>());\\n        int side = s / 4;\\n        vector<int> v(4);\\n        return dfs(0, ms, side, v, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(int i, vector<int> &ms, int side, vector<int> &v, int n) {\\n        if(i == n) {\\n            return v[0] == v[1] && v[1] == v[2] && v[2] == v[3];\\n        }\\n        for(int k=0; k<4; k++) {\\n            if(v[k] + ms[i] > side) continue;\\n            v[k] += ms[i];\\n            if(dfs(i + 1, ms, side, v, n)) return true;\\n            v[k] -= ms[i];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& ms) {\\n        int s = accumulate(ms.begin(), ms.end(), 0), n = ms.size();\\n        if(s % 4) return false;\\n        sort(ms.begin(), ms.end(), greater<int>());\\n        int side = s / 4;\\n        vector<int> v(4);\\n        return dfs(0, ms, side, v, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625621,
                "title": "bitmask-dp-simple-understandable-code-python-but-language-independent",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        \\n        s = sum(matchsticks)\\n        n = len(matchsticks)\\n        if s % 4 != 0 :   #basic case if square is not valid\\n            return  False\\n        \\n        dp = {}\\n        \\n        \\n        def solve( idx , x , included) :\\n            \\n            \\n            if (x , included) in dp :\\n                return dp[(x , included)]\\n            # memoization\\n            \\n            if x == 0:\\n                if included == ((2 ** n) - 1) :  # if all elements are included  and all edges are fulfilled\\n                    return True\\n                \\n                return solve( 0 , s // 4 , included ) # if there are still some edges to be solved\\n                \\n            if x < 0 or idx == n : # out of bound cases\\n                return  False\\n            \\n            \\n            flag = False\\n            for i in range(idx , n ) :\\n                if (1 << i) & included == 0  : #checking if the element id already included or not\\n                    flag = solve(i + 1 , x - matchsticks[i] , included ^ ( 1 << i )) # solving for subproblem , and setting the bit which is included\\n                    \\n                if flag :\\n                    dp[(x,included)] = True \\n                    return True\\n                \\n                \\n            dp[(x,included)] = False    \\n            return False\\n        \\n        \\n        ans = solve( 0 , s//4 , 0)\\n        return ans\\n\\t\\t\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "class Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        \\n        s = sum(matchsticks)\\n        n = len(matchsticks)\\n        if s % 4 != 0 :   #basic case if square is not valid\\n            return  False\\n        \\n        dp = {}",
                "codeTag": "Java"
            },
            {
                "id": 2362053,
                "title": "java-clean-solution",
                "content": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        int sum = 0;\\n        for(int m: matchsticks)\\n            sum += m;\\n        if(sum%4!=0)\\n            return false;\\n        Arrays.sort(matchsticks);\\n        return makeSquare(matchsticks, 0, 0, 0, 0, matchsticks.length-1, sum/4);\\n    }\\n    \\n    private boolean makeSquare(int[] m, int a, int b, int c, int d, int i, int s){\\n        if(a>s || b>s || c>s || d>s)\\n            return false;\\n        if(i==-1)\\n            return a==b && a==c && a==d;\\n        return makeSquare(m, a+m[i], b, c, d, i-1, s) || makeSquare(m, a, b+m[i], c, d, i-1, s) ||\\n            makeSquare(m, a, b, c+m[i], d, i-1, s) || makeSquare(m, a, b, c, d+m[i], i-1, s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        int sum = 0;\\n        for(int m: matchsticks)\\n            sum += m;\\n        if(sum%4!=0)\\n            return false;\\n        Arrays.sort(matchsticks);\\n        return makeSquare(matchsticks, 0, 0, 0, 0, matchsticks.length-1, sum/4);\\n    }\\n    \\n    private boolean makeSquare(int[] m, int a, int b, int c, int d, int i, int s){\\n        if(a>s || b>s || c>s || d>s)\\n            return false;\\n        if(i==-1)\\n            return a==b && a==c && a==d;\\n        return makeSquare(m, a+m[i], b, c, d, i-1, s) || makeSquare(m, a, b+m[i], c, d, i-1, s) ||\\n            makeSquare(m, a, b, c+m[i], d, i-1, s) || makeSquare(m, a, b, c, d+m[i], i-1, s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271990,
                "title": "ruby-o-2-n-100-100-backtrack-with-memoization",
                "content": "The worst case of this is  2 ** n. But in practice, it can perform multiple times faster because it fails very fast in the process.\\n\\nI also used a binary hash key so the we can have more efficient memo.\\n\\n- First, calculate the expected side length, check for all the edge cases\\n- [Optional] Sort the sticks from longest, this increases our change to reach the solution fast if exists\\n- Run backtrack with 3 parameters, the hash indicating which stick has already been used, how many sides left to be filled, and how much longer the first side left\\n- Iterating the hash by shifting bit to the left, bit == 1 means the stick at i has been used.\\n- If no remaining stick fits the first side remaining length, return false and memoize it, this is fail fast condition.\\n\\nPlease upvote if it\\'s helpful, thanks\\n\\n```\\n# @param {Integer[]} matchsticks\\n# @return {Boolean}\\ndef makesquare(matchsticks)\\n  @n = matchsticks.size\\n  return false if @n < 4\\n\\n  sum_length = matchsticks.sum\\n  return false if sum_length % 4 != 0\\n  @side = sum_length / 4\\n  @sticks = matchsticks.sort.reverse\\n  @memo = {}\\n  hash = (1 << @n) - 1\\n\\n  pick(hash, @side, 3)\\nend\\n\\ndef pick(hash, first_side, sides_left)\\n  return false if @memo[hash]\\n\\n  m = hash\\n  i = 0\\n  while m > 0\\n    bit = m & 1\\n    if bit == 1\\n      remaining = first_side - @sticks[i]\\n      if remaining < 0\\n        i += 1\\n        m = m >> 1\\n        next\\n      end\\n      if remaining == 0\\n        new_left = sides_left - 1\\n        return true if new_left == 0\\n        remaining = @side\\n      else\\n        new_left = sides_left\\n      end\\n\\n      return true if pick(hash - (1 << i), remaining, new_left)\\n    end\\n\\n    m = m >> 1\\n    i += 1\\n  end\\n\\n  @memo[hash] = true\\n  false\\nend\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "The worst case of this is  2 ** n. But in practice, it can perform multiple times faster because it fails very fast in the process.\\n\\nI also used a binary hash key so the we can have more efficient memo.\\n\\n- First, calculate the expected side length, check for all the edge cases\\n- [Optional] Sort the sticks from longest, this increases our change to reach the solution fast if exists\\n- Run backtrack with 3 parameters, the hash indicating which stick has already been used, how many sides left to be filled, and how much longer the first side left\\n- Iterating the hash by shifting bit to the left, bit == 1 means the stick at i has been used.\\n- If no remaining stick fits the first side remaining length, return false and memoize it, this is fail fast condition.\\n\\nPlease upvote if it\\'s helpful, thanks\\n\\n```\\n# @param {Integer[]} matchsticks\\n# @return {Boolean}\\ndef makesquare(matchsticks)\\n  @n = matchsticks.size\\n  return false if @n < 4\\n\\n  sum_length = matchsticks.sum\\n  return false if sum_length % 4 != 0\\n  @side = sum_length / 4\\n  @sticks = matchsticks.sort.reverse\\n  @memo = {}\\n  hash = (1 << @n) - 1\\n\\n  pick(hash, @side, 3)\\nend\\n\\ndef pick(hash, first_side, sides_left)\\n  return false if @memo[hash]\\n\\n  m = hash\\n  i = 0\\n  while m > 0\\n    bit = m & 1\\n    if bit == 1\\n      remaining = first_side - @sticks[i]\\n      if remaining < 0\\n        i += 1\\n        m = m >> 1\\n        next\\n      end\\n      if remaining == 0\\n        new_left = sides_left - 1\\n        return true if new_left == 0\\n        remaining = @side\\n      else\\n        new_left = sides_left\\n      end\\n\\n      return true if pick(hash - (1 << i), remaining, new_left)\\n    end\\n\\n    m = m >> 1\\n    i += 1\\n  end\\n\\n  @memo[hash] = true\\n  false\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2271072,
                "title": "c",
                "content": "```\\n\\n```class Solution {``\\n    bool dfs(vector<int>&v,vector<int>&matches,int index,int target){\\n        if(index==matches.size()) return true;\\n        for(int i=0;i<4;i++){\\n            if(v[i]+matches[index]>target) continue;\\n            int j=i;\\n            while(--j>=0)\\n                if(v[i]==v[j]) break;\\n            if(j!=-1) continue;\\n            v[i]+=matches[index];\\n            if(dfs(v,matches,index+1,target)) return true;\\n            v[i]-=matches[index];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        if(nums.size()<4) return false;\\n        int sum =accumulate(nums.begin(),nums.end(),0);\\n        if(sum%4!=0) return false;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<int>v(4,0);\\n        return dfs(v,nums,0,sum/4);\\n    }\\n};**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2270856,
                "title": "easy-c-sol-recursive-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int> matchsticks, int target,vector<int> &res, int idx){\\n        \\n        if(idx == matchsticks.size()){\\n            return (res[0] == res[1] && res[1] == res[2] && res[2] == res[3]);\\n        }\\n        \\n        for(int i=0;i<4;i++){\\n            \\n            if(res[i] + matchsticks[idx] > target){\\n                continue;\\n            }\\n            \\n            int j = i-1;\\n            \\n            while(j>=0){\\n                \\n                if(res[i] == res[j]) break;\\n                \\n                j--;\\n                \\n            }\\n            \\n            if(j != -1)\\n                continue;\\n            \\n            \\n            res[i] += matchsticks[idx];\\n            \\n            if(isPossible(matchsticks,target,res,idx+1)) return true;\\n            \\n            res[i] -= matchsticks[idx];\\n            \\n        }\\n        return false;\\n    }\\n    \\n    \\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        \\n        //Edge Case\\n        if(matchsticks.size() == 0)\\n            return 0;\\n        \\n        int sum = accumulate(matchsticks.begin(),matchsticks.end(),0);\\n        \\n        int target = sum/4;\\n            \\n        vector<int> sides(4,0);\\n        \\n        sort(matchsticks.begin(),matchsticks.end(),greater<int>());\\n        \\n        return isPossible(matchsticks,target,sides,0);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isPossible(vector<int> matchsticks, int target,vector<int> &res, int idx){\\n        \\n        if(idx == matchsticks.size()){\\n            return (res[0] == res[1] && res[1] == res[2] && res[2] == res[3]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2270798,
                "title": "clean-java-code",
                "content": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        if(matchsticks.length < 4)return false;\\n        \\n        int sum = 0 ;\\n        for(int a:matchsticks)sum+=a;\\n        \\n        if(sum % 4 != 0)return false;\\n        \\n        int side[] = {sum/4 , sum/4 , sum/4 , sum/4}; // 2 2 2 2 \\n        \\n        Arrays.sort(matchsticks);\\n        \\n        return dfs(matchsticks , side , matchsticks.length - 1);\\n    \\n    }\\n    \\n    private boolean dfs(int[] match , int[] sides , int idx){\\n        \\n        if(idx == -1)return sides[0] == sides[1] && sides[1] == sides[2] && sides[2] == sides[3];\\n        \\n        for(int i = 0 ; i < sides.length ; i++)\\n        {\\n            if(match[idx] <=sides[i])\\n            {\\n                sides[i]-=match[idx]; // 0 2 2 2 //0  0 2  2 // 0 0 0 2 // 0 0 0 0 \\n                if(dfs(match , sides , idx - 1))return true;\\n                sides[i]+=match[idx];\\n            }\\n        }return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        if(matchsticks.length < 4)return false;\\n        \\n        int sum = 0 ;\\n        for(int a:matchsticks)sum+=a;\\n        \\n        if(sum % 4 != 0)return false;\\n        \\n        int side[] = {sum/4 , sum/4 , sum/4 , sum/4}",
                "codeTag": "Java"
            },
            {
                "id": 2270668,
                "title": "c-easy-simple-solution-matchsticks-to-square",
                "content": "class Solution {\\npublic:\\n    bool func(int idx, vector<int>& matchsticks, vector<int>& sides, int& target)\\n    {\\n       //base condition\\n        if(idx==matchsticks.size())\\n        {\\n            if(sides[0]==sides[1] && sides[1]==sides[2] && sides[2]==sides[3])\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n        for(int i=0; i<4; i++)\\n        {\\n            if(sides[i]+matchsticks[idx]>target) //optimization - 1\\n            {\\n                continue;\\n            }\\n            int j = i - 1;  //optimization - 3\\n            while (j>=0){\\n                if(sides[j] == sides[i]){\\n                    break;\\n                }\\n                \\n                j -= 1;\\n            }\\n            \\n            if(j != -1){\\n                continue;\\n            }\\n            \\n            sides[i]+=matchsticks[idx];\\n            if(func(idx+1, matchsticks, sides, target))\\n            {\\n                return true;\\n            }\\n            sides[i]-=matchsticks[idx];    //backtracking\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        if(matchsticks.size()==0)\\n            return false;\\n        \\n        int sum=0;\\n        for(int i=0; i<matchsticks.size(); i++)\\n        {\\n            sum+=matchsticks[i];\\n        }\\n        \\n        int target=sum/4;\\n        \\n        vector<int>sides(4, 0);\\n        \\n        sort(matchsticks.begin(), matchsticks.end(), greater<int>()); //optimization 2\\n        \\n        return func(0, matchsticks, sides, target);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    bool func(int idx, vector<int>& matchsticks, vector<int>& sides, int& target)\\n    {\\n       //base condition\\n        if(idx==matchsticks.size())\\n        {\\n            if(sides[0]==sides[1] && sides[1]==sides[2] && sides[2]==sides[3])\\n            {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2140154,
                "title": "python-dfs-back-tracking-time-beats-98-4-space-beats-99-2",
                "content": "dfs with pruning:\\n1. if one number can\\'t work in one way, all the same number won\\'t work in this way.\\n2. if a way won\\'t work, any way starts from a brand new side in the same pattern won\\'t work.\\n\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        if len(matchsticks) < 4 or sum(matchsticks) % 4:\\n            return False      \\n        numSum = sum(matchsticks)\\n        matchsticks.sort(reverse = True)\\n        for x in matchsticks:\\n            if x > numSum // 4:\\n                return False\\n        visited = [False] * len(matchsticks)\\n        return self.dfs(matchsticks, 0, 0, 0, numSum // 4, visited)\\n        \\n    def dfs(self, a, made, cur, start, limit, visited):\\n        if made == 4:\\n            return True\\n        if cur == limit:\\n            return self.dfs(a, made + 1, 0, 0, limit, visited)\\n        i = start\\n        while i < len(a):\\n            if visited[i] or a[i] + cur > limit:\\n                i += 1\\n                continue\\n            visited[i] = True\\n            if self.dfs(a, made, cur + a[i], i + 1, limit, visited):\\n                return True\\n            visited[i] = False\\n            \\n            while i + 1 < len(a) and a[i + 1] == a[i]: #pruning #1\\n                i += 1\\n            if not cur or cur + a[i] == limit: #pruning #2\\n                return False\\n            i += 1\\n        return False",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "dfs with pruning:\\n1. if one number can\\'t work in one way, all the same number won\\'t work in this way.\\n2. if a way won\\'t work, any way starts from a brand new side in the same pattern won\\'t work.\\n\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        if len(matchsticks) < 4 or sum(matchsticks) % 4:\\n            return False      \\n        numSum = sum(matchsticks)\\n        matchsticks.sort(reverse = True)\\n        for x in matchsticks:\\n            if x > numSum // 4:\\n                return False\\n        visited = [False] * len(matchsticks)\\n        return self.dfs(matchsticks, 0, 0, 0, numSum // 4, visited)\\n        \\n    def dfs(self, a, made, cur, start, limit, visited):\\n        if made == 4:\\n            return True\\n        if cur == limit:\\n            return self.dfs(a, made + 1, 0, 0, limit, visited)\\n        i = start\\n        while i < len(a):\\n            if visited[i] or a[i] + cur > limit:\\n                i += 1\\n                continue\\n            visited[i] = True\\n            if self.dfs(a, made, cur + a[i], i + 1, limit, visited):\\n                return True\\n            visited[i] = False\\n            \\n            while i + 1 < len(a) and a[i + 1] == a[i]: #pruning #1\\n                i += 1\\n            if not cur or cur + a[i] == limit: #pruning #2\\n                return False\\n            i += 1\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1955832,
                "title": "c-bitmask-and-backtracking-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/matchsticks-to-square/\\n    \\n    Core Idea: In order to get a square made, we need to ensure that we can group\\n    the sides such that there are 4 groups of same size (sum). This problem is basically\\n    equal sum k partition problem.\\n    \\n    Solution 1: Backtracking \\n    We need to check if we can find 4 partitions with equal sum.\\n    \\n    Solution 2: Bitmask\\n    Here we use binary encoded representation to map selection of matchsticks.\\n    Mask: Current matchsticks chosen for selection. Some of them already are part of req \\n    partition and there might be few in the current partition which still doesn\\'t have total\\n    sum equal to req target sum.\\n    \\n    We use bitmasking to transition states starting with an empty subset and finally aim\\n    to reach the final state where all the matchsticks have been picked and put in some \\n    partition.\\n    Here is explanation of the logic in more depth\\n    https://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/1952411/C%2B%2B-Bitmasking-and-backtracking-solutions-Detailed-Explanation\\n*/\\nclass Solution {\\npublic:\\n    bool backtrack(int curr, int side_length, int partition,\\n                  int& target, vector<int>& nums, vector<bool>& visited) {\\n        // base case, when all paritions are done\\n        if(partition == 0)\\n            return true;\\n        if(side_length == target)\\n            return backtrack(0, 0, partition-1, target, nums, visited);\\n        \\n        // Try to fill the current partition with each of the matchstick sides\\n        for(int i = curr; i < nums.size(); i++) {\\n            // add the current side to curr partition only if it doesnt exceed target\\n            // and side has not been used yet\\n            if(!visited[i] && nums[i] + side_length <= target) {\\n                visited[i] = true;\\n                if(backtrack(i+1, side_length + nums[i], partition, target, nums, visited))\\n                    return true;\\n                visited[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // Backtracking solution\\n    // TC: O(4 * 2^N)\\n    bool backtrackSol(vector<int>& nums) {\\n        long sum = accumulate(nums.begin(), nums.end(), 0);\\n        // check if the total sum of side lengths can be divided into 4 equal partitions\\n        if(sum % 4)\\n            return false;\\n        // target side of square \\n        int target = sum / 4;\\n        // keeps track of sides used\\n        vector<bool> visited(nums.size(), false);\\n        \\n        return backtrack(0, 0, 4, target, nums, visited);\\n    }\\n    \\n    // Bitmask solution\\n    // TC: O(N * 2^N)\\n    // SC: O(2^N)\\n    bool bitmaskSol(vector<int>& nums) {\\n        long sum = accumulate(nums.begin(), nums.end(), 0);\\n        // check if the total sum of side lengths can be divided into 4 equal partitions\\n        if(sum % 4)\\n            return false;\\n        \\n        // target side of square \\n        int target = sum / 4;\\n        const int N = nums.size();\\n        // dp[mask] = total sum of elements for current partition, indicates if there is any remainder \\n        // left for curr partition\\n        vector<int> dp((1<<N) + 1, -1);\\n        dp[0] = 0;\\n        \\n        // try out all the matchstick subset combinations\\n        for(int mask = 0; mask < (1 << N); mask++) {\\n            if(dp[mask] == -1)\\n                continue;\\n            // try adding unadded matchstick to the current subset partition\\n            for(int i = 0; i < nums.size(); i++) {\\n                // current element is already part of subset\\n                if(mask & (1 << i))\\n                    continue;\\n                if(nums[i] + dp[mask] <= target)\\n                    dp[mask | (1 << i)] = (dp[mask] + nums[i]) % target;\\n            }\\n        }\\n            \\n        return dp[(1<<N) - 1] == 0;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        // return backtrackSol(matchsticks);\\n        return bitmaskSol(matchsticks);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/matchsticks-to-square/\\n    \\n    Core Idea: In order to get a square made, we need to ensure that we can group\\n    the sides such that there are 4 groups of same size (sum). This problem is basically\\n    equal sum k partition problem.\\n    \\n    Solution 1: Backtracking \\n    We need to check if we can find 4 partitions with equal sum.\\n    \\n    Solution 2: Bitmask\\n    Here we use binary encoded representation to map selection of matchsticks.\\n    Mask: Current matchsticks chosen for selection. Some of them already are part of req \\n    partition and there might be few in the current partition which still doesn\\'t have total\\n    sum equal to req target sum.\\n    \\n    We use bitmasking to transition states starting with an empty subset and finally aim\\n    to reach the final state where all the matchsticks have been picked and put in some \\n    partition.\\n    Here is explanation of the logic in more depth\\n    https://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/1952411/C%2B%2B-Bitmasking-and-backtracking-solutions-Detailed-Explanation\\n*/\\nclass Solution {\\npublic:\\n    bool backtrack(int curr, int side_length, int partition,\\n                  int& target, vector<int>& nums, vector<bool>& visited) {\\n        // base case, when all paritions are done\\n        if(partition == 0)\\n            return true;\\n        if(side_length == target)\\n            return backtrack(0, 0, partition-1, target, nums, visited);\\n        \\n        // Try to fill the current partition with each of the matchstick sides\\n        for(int i = curr; i < nums.size(); i++) {\\n            // add the current side to curr partition only if it doesnt exceed target\\n            // and side has not been used yet\\n            if(!visited[i] && nums[i] + side_length <= target) {\\n                visited[i] = true;\\n                if(backtrack(i+1, side_length + nums[i], partition, target, nums, visited))\\n                    return true;\\n                visited[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // Backtracking solution\\n    // TC: O(4 * 2^N)\\n    bool backtrackSol(vector<int>& nums) {\\n        long sum = accumulate(nums.begin(), nums.end(), 0);\\n        // check if the total sum of side lengths can be divided into 4 equal partitions\\n        if(sum % 4)\\n            return false;\\n        // target side of square \\n        int target = sum / 4;\\n        // keeps track of sides used\\n        vector<bool> visited(nums.size(), false);\\n        \\n        return backtrack(0, 0, 4, target, nums, visited);\\n    }\\n    \\n    // Bitmask solution\\n    // TC: O(N * 2^N)\\n    // SC: O(2^N)\\n    bool bitmaskSol(vector<int>& nums) {\\n        long sum = accumulate(nums.begin(), nums.end(), 0);\\n        // check if the total sum of side lengths can be divided into 4 equal partitions\\n        if(sum % 4)\\n            return false;\\n        \\n        // target side of square \\n        int target = sum / 4;\\n        const int N = nums.size();\\n        // dp[mask] = total sum of elements for current partition, indicates if there is any remainder \\n        // left for curr partition\\n        vector<int> dp((1<<N) + 1, -1);\\n        dp[0] = 0;\\n        \\n        // try out all the matchstick subset combinations\\n        for(int mask = 0; mask < (1 << N); mask++) {\\n            if(dp[mask] == -1)\\n                continue;\\n            // try adding unadded matchstick to the current subset partition\\n            for(int i = 0; i < nums.size(); i++) {\\n                // current element is already part of subset\\n                if(mask & (1 << i))\\n                    continue;\\n                if(nums[i] + dp[mask] <= target)\\n                    dp[mask | (1 << i)] = (dp[mask] + nums[i]) % target;\\n            }\\n        }\\n            \\n        return dp[(1<<N) - 1] == 0;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        // return backtrackSol(matchsticks);\\n        return bitmaskSol(matchsticks);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812991,
                "title": "c-backtracking-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& m, int idx, vector<int> &s){\\n          if(idx == m.size()){\\n               if(s[0] == 0 && s[1] == 0 && s[2] == 0 && s[3] == 0) return true;\\n               return false;\\n          }\\n        \\n          for(int i =0; i<4; i++){\\n              if(m[idx] > s[i]) continue;\\n              s[i] -= m[idx];\\n              if(solve(m, idx + 1, s)) return true;\\n              s[i] += m[idx];\\n          }\\n        return false;\\n    }\\n    bool makesquare(vector<int>& matchsticks) {\\n         int sum = accumulate(matchsticks.begin(), matchsticks.end(),0);\\n         if(sum % 4 != 0) return false;\\n         int side = sum / 4;\\n         sort(matchsticks.rbegin(), matchsticks.rend());\\n         vector<int> sides(4,side);\\n         return solve(matchsticks, 0, sides);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    bool solve(vector<int>& m, int idx, vector<int> &s){\\n          if(idx == m.size()){\\n               if(s[0] == 0 && s[1] == 0 && s[2] == 0 && s[3] == 0) return true;\\n               return false;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1396585,
                "title": "c-8ms-solution-with-dp-bit-masking",
                "content": "We can solve this using dynamic programming with bit masking. Where dp(k,mask) represent for a particular mask if we can divide the array int k equal parts. Let array be [1,1,2,2,2] so the initial mask is \\'11111\\' and k=4, so dp state is dp(4,11111) then the we choose [1,1] (to make current sum=2 which is equal to target) from array now the mask will be changed to \\'11100\\' as the starting two element is chosen so the bit corresponds to the chosen element is changed to \\'0\\', so now we have the array [2,2,2] and we have to divide it into k-1 that is 3 equal parts, so dp(3,11100) will give the answer for this state the transition is dp(k,mask)->dp(k-1,mask with chosen bit set to zero) when we found one target sum``\\n```\\n\\n\\nint dp[5][1<<16];\\n bool dfs(vector<int>& nums, int pos, int sum,int mask, int target, int k) {\\n\\t//when k==1 we can always divide the array in single parts so return true\\n\\t if (k == 1) return true;\\n\\t if(dp[k][mask]!=-1)return dp[k][mask];//if we calculated the answer before, the return answer, no need to calculate further\\n\\t //if current sum is equal to the (target=totalsum/4) then one part is found so check if\\n\\t //remaining array can be divided in k-1 parts and also change the sum to zero\\n\\tif (sum == target) return dfs(nums, 0, 0,mask, target, k-1);\\n\\tif (pos== nums.size()) return false;\\n\\tfor (int i=pos; i<nums.size(); i++) {\\n\\t\\t//mask&(1<<i) checks if the set bit is 1, meaning the element is present the set\\n\\t\\tif (mask&(1<<i) && sum + nums[i] <= target)\\n\\t\\t{\\n\\t\\t\\t//now as we chosen the current i\\'th element so set the i\\'th bit to zero, and the way to do is mask^(1<<i)\\n\\t\\t\\tif (dfs(nums, i+1, sum+nums[i],mask^(1<<i), target, k))\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn dp[k][mask]=false;//store the value \\n}\\n//given array where we have to divide the array in k equal parts and here k=4\\nbool makesquare(vector<int>& nums) {\\n\\tif (!nums.size()) return false;//if array size is zero square can\\'tbe made\\n\\tint sum = 0;\\n\\tfor (auto i : nums) sum += i;\\n\\tif (sum % 4 != 0) return false;//sum should be divisible by 4, as all sides must be equal\\n\\tmemset(dp,-1,sizeof(dp));//initializing dp with -1\\n\\treturn dfs(nums, 0, 0,(1<<nums.size())-1,sum/4, 4);\\n}\\n```\\nWe can also do it using only the mask in dp, no need of using k in the dp state.",
                "solutionTags": [],
                "code": "```\\n\\n\\nint dp[5][1<<16];\\n bool dfs(vector<int>& nums, int pos, int sum,int mask, int target, int k) {\\n\\t//when k==1 we can always divide the array in single parts so return true\\n\\t if (k == 1) return true;\\n\\t if(dp[k][mask]!=-1)return dp[k][mask];//if we calculated the answer before, the return answer, no need to calculate further\\n\\t //if current sum is equal to the (target=totalsum/4) then one part is found so check if\\n\\t //remaining array can be divided in k-1 parts and also change the sum to zero\\n\\tif (sum == target) return dfs(nums, 0, 0,mask, target, k-1);\\n\\tif (pos== nums.size()) return false;\\n\\tfor (int i=pos; i<nums.size(); i++) {\\n\\t\\t//mask&(1<<i) checks if the set bit is 1, meaning the element is present the set\\n\\t\\tif (mask&(1<<i) && sum + nums[i] <= target)\\n\\t\\t{\\n\\t\\t\\t//now as we chosen the current i\\'th element so set the i\\'th bit to zero, and the way to do is mask^(1<<i)\\n\\t\\t\\tif (dfs(nums, i+1, sum+nums[i],mask^(1<<i), target, k))\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn dp[k][mask]=false;//store the value \\n}\\n//given array where we have to divide the array in k equal parts and here k=4\\nbool makesquare(vector<int>& nums) {\\n\\tif (!nums.size()) return false;//if array size is zero square can\\'tbe made\\n\\tint sum = 0;\\n\\tfor (auto i : nums) sum += i;\\n\\tif (sum % 4 != 0) return false;//sum should be divisible by 4, as all sides must be equal\\n\\tmemset(dp,-1,sizeof(dp));//initializing dp with -1\\n\\treturn dfs(nums, 0, 0,(1<<nums.size())-1,sum/4, 4);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276038,
                "title": "java-simple-and-easy-backtracking-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\nComplexity\\nTime   : 4 ^ n\\nSpace : n \\n\\n\\n```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        int n = matchsticks.length;\\n        if(n < 4) return false;\\n        \\n        int perimeter = 0;\\n        for(int stick : matchsticks) perimeter += stick;\\n        \\n        //check perimeter is valid or not\\n        if(perimeter % 4 != 0) return false;\\n        \\n        //sort the stick in increasing order of their length\\n        Arrays.sort(matchsticks);\\n        \\n        //possible sqaure side\\n        int squareSide = perimeter / 4;\\n        \\n        //check the largest stick valid or not\\n        if(matchsticks[n - 1] > squareSide) return false;\\n        \\n        //this function return all stick can be \\n        return canFormSquare(matchsticks, new int[4], n - 1, squareSide);\\n    }\\n    \\n    private boolean canFormSquare(int[] matchsticks, int[] sides, int index, int squareSide){\\n        if(index == -1){\\n            //check all sides are equal, if equal it means sticks can be arranged in square\\n            return sides[0] == sides[1] && sides[1] == sides[2] && sides[2] == sides[3] && sides[3] == sides[0];\\n        }\\n        \\n        int stick = matchsticks[index];\\n        \\n        for(int i = 0; i < 4; i++){\\n            //ignore this side if add new stick will greater than valid square side\\n            if(sides[i] + stick > squareSide) continue;\\n            \\n            //add stick in current side\\n            sides[i] += stick;\\n            \\n            //check square can be formed or not\\n            //just return from, no need to try different combination of stick for sides\\n            if(canFormSquare(matchsticks, sides, index - 1, squareSide)) return true;\\n            \\n            //remove stick fromc current side\\n            sides[i] -= stick;\\n        }\\n        \\n        \\n        return false;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        int n = matchsticks.length;\\n        if(n < 4) return false;\\n        \\n        int perimeter = 0;\\n        for(int stick : matchsticks) perimeter += stick;\\n        \\n        //check perimeter is valid or not\\n        if(perimeter % 4 != 0) return false;\\n        \\n        //sort the stick in increasing order of their length\\n        Arrays.sort(matchsticks);\\n        \\n        //possible sqaure side\\n        int squareSide = perimeter / 4;\\n        \\n        //check the largest stick valid or not\\n        if(matchsticks[n - 1] > squareSide) return false;\\n        \\n        //this function return all stick can be \\n        return canFormSquare(matchsticks, new int[4], n - 1, squareSide);\\n    }\\n    \\n    private boolean canFormSquare(int[] matchsticks, int[] sides, int index, int squareSide){\\n        if(index == -1){\\n            //check all sides are equal, if equal it means sticks can be arranged in square\\n            return sides[0] == sides[1] && sides[1] == sides[2] && sides[2] == sides[3] && sides[3] == sides[0];\\n        }\\n        \\n        int stick = matchsticks[index];\\n        \\n        for(int i = 0; i < 4; i++){\\n            //ignore this side if add new stick will greater than valid square side\\n            if(sides[i] + stick > squareSide) continue;\\n            \\n            //add stick in current side\\n            sides[i] += stick;\\n            \\n            //check square can be formed or not\\n            //just return from, no need to try different combination of stick for sides\\n            if(canFormSquare(matchsticks, sides, index - 1, squareSide)) return true;\\n            \\n            //remove stick fromc current side\\n            sides[i] -= stick;\\n        }\\n        \\n        \\n        return false;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274939,
                "title": "rust-backtracking",
                "content": "```rust\\nimpl Solution {\\n    fn backtrack(matches: &mut [i32], matchsticks: &[i32], match_index: usize) -> bool {\\n        if match_index == matchsticks.len() {\\n            return matches.iter().all(|m| *m == 0);\\n        }\\n        for j in 0..4 {\\n            if matches[j] - matchsticks[match_index] >= 0 {\\n                matches[j] -= matchsticks[match_index];\\n                if Solution::backtrack(matches, matchsticks, match_index + 1) {\\n                    return true;\\n                }\\n                matches[j] += matchsticks[match_index];\\n            }\\n        }\\n        false\\n    }\\n    pub fn makesquare(matchsticks: Vec<i32>) -> bool {\\n        let sum = matchsticks.iter().sum::<i32>();\\n        if sum % 4 != 0 {\\n            return false;\\n        }\\n\\n        let avg = sum / 4;\\n        let mut matches = vec![avg; 4];\\n        Solution::backtrack(&mut matches, &matchsticks, 0)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    fn backtrack(matches: &mut [i32], matchsticks: &[i32], match_index: usize) -> bool {\\n        if match_index == matchsticks.len() {\\n            return matches.iter().all(|m| *m == 0);\\n        }\\n        for j in 0..4 {\\n            if matches[j] - matchsticks[match_index] >= 0 {\\n                matches[j] -= matchsticks[match_index];\\n                if Solution::backtrack(matches, matchsticks, match_index + 1) {\\n                    return true;\\n                }\\n                matches[j] += matchsticks[match_index];\\n            }\\n        }\\n        false\\n    }\\n    pub fn makesquare(matchsticks: Vec<i32>) -> bool {\\n        let sum = matchsticks.iter().sum::<i32>();\\n        if sum % 4 != 0 {\\n            return false;\\n        }\\n\\n        let avg = sum / 4;\\n        let mut matches = vec![avg; 4];\\n        Solution::backtrack(&mut matches, &matchsticks, 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172080,
                "title": "python3-dp-with-memoization",
                "content": "Bitmasking with memoization. Fast, beating 90%.\\n```python\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n, sm = len(matchsticks), sum(matchsticks)\\n        if n < 4 or sm % 4:\\n            return False\\n        q = sm // 4\\n        mask = 0\\n        matchsticks.sort(reverse=True)\\n\\n        @lru_cache(None)\\n        def dp(i, cur, mask):\\n            if i == 4:\\n                return True\\n            for j in range(n):\\n                if mask & (1<<j):\\n                    continue\\n                if cur + matchsticks[j] == q:\\n                    if dp(i + 1, 0, mask | (1<<j)):\\n                        return True\\n                elif cur + matchsticks[j] < q:\\n                    if dp(i, cur + matchsticks[j], mask | (1<<j)):\\n                        return True\\n                else:\\n                    break\\n            return False\\n                    \\n        return dp(0, 0, 0)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n, sm = len(matchsticks), sum(matchsticks)\\n        if n < 4 or sm % 4:\\n            return False\\n        q = sm // 4\\n        mask = 0\\n        matchsticks.sort(reverse=True)\\n\\n        @lru_cache(None)\\n        def dp(i, cur, mask):\\n            if i == 4:\\n                return True\\n            for j in range(n):\\n                if mask & (1<<j):\\n                    continue\\n                if cur + matchsticks[j] == q:\\n                    if dp(i + 1, 0, mask | (1<<j)):\\n                        return True\\n                elif cur + matchsticks[j] < q:\\n                    if dp(i, cur + matchsticks[j], mask | (1<<j)):\\n                        return True\\n                else:\\n                    break\\n            return False\\n                    \\n        return dp(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612209,
                "title": "python-backtrack-beat-90",
                "content": "```\\n    def makesquare(self, nums: List[int]) -> bool:\\n        if not nums: return False\\n        n = len(nums)\\n        total = sum(nums)\\n        side = total // 4\\n        if side * 4 != total:\\n            return False\\n        sides = [0] * 4\\n        nums.sort(reverse = True)\\n        def helper(i):\\n            if i == n:\\n                return sides[0] == sides[1] == sides[2] == sides[3] == side\\n            for j in range(4):\\n                if j > 0 and sides[j] == sides[j-1]:\\n                    continue\\n                if sides[j] + nums[i] <= side:\\n                    sides[j] += nums[i]\\n                    if helper(i+1):\\n                        return True\\n                    sides[j] -= nums[i]\\n            return False\\n        return helper(0)\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def makesquare(self, nums: List[int]) -> bool:\\n        if not nums: return False\\n        n = len(nums)\\n        total = sum(nums)\\n        side = total // 4\\n        if side * 4 != total:\\n            return False\\n        sides = [0] * 4\\n        nums.sort(reverse = True)\\n        def helper(i):\\n            if i == n:\\n                return sides[0] == sides[1] == sides[2] == sides[3] == side\\n            for j in range(4):\\n                if j > 0 and sides[j] == sides[j-1]:\\n                    continue\\n                if sides[j] + nums[i] <= side:\\n                    sides[j] += nums[i]\\n                    if helper(i+1):\\n                        return True\\n                    sides[j] -= nums[i]\\n            return False\\n        return helper(0)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 95778,
                "title": "9ms-c-dfs-solution-with-smallest-subsum-check-detailed-explanation",
                "content": "The problem is equivalent to ask if we can partition `nums` into 4 subsets such that their subsums will be `s = { sum/4, sum/4, sum/4, sum/4 }`.\\n\\nNote that for a generic subsum combo `s = { s[0], s[1], s[2], s[3] }` in ascending order, we can early terminate the DFS process if it violates the min subsum check:\\n* if `small[i] > s[i]` for any `0 <= i <= 3`, it is impossible to do such partition,\\n\\nwhere `small[i=0:3]` are the 4 smallest subsums of `nums`:\\n* `small[0] = nums[0]`,\\n* `small[1] = nums[1]`,\\n* `small[2] = min(nums[0] + nums[1], nums[2])`,\\n* `small[3] = min(max(nums[0] + nums[1], nums[2]), nums[3])`,\\n\\nwhere `nums[i=0:3]` are 4 smallest numbers in `nums`.\\n\\nFor example, for `nums = [99, 37, 37, 37, 37, 37, 37, 37, 37, 5]` whose `sum = 400`, it is obvious that there is no way to form a square with length `100` since no one can compensate `99` on a side. So after one DFS, we are trying to partition `nums` without `99` to subsums `s = {1, 100, 100, 100}` and this fails the min subsum check because smallest number `5 > 1`.\\n```\\npublic:    \\n    bool makesquare(vector<int>& nums) {\\n      int sum;\\n      if (nums.size() < 4 || (sum = accumulate(nums.begin(), nums.end(), 0))%4) return false;\\n      return sortSmall(nums), dfs(nums.begin(), vector<int>(4,sum/4));\\n    }\\nprivate: // helpers   \\n    // sort nums descendingly and calculate 4 smallest subsums\\n    void sortSmall(vector<int>& nums) {\\n      sort(nums.rbegin(), nums.rend());\\n      small = { *((e=nums.end())-1), *(e-2), min(*(e-1)+*(e-2),*(e-3)), \\n                min(max(*(e-1)+*(e-2),*(e-3)),*(e-4)) };\\n    }\\n\\n    // check if can partition into subsums {s[j]} starting at nums[i]\\n    bool dfs(vector<int>::iterator i, const vector<int>& s) {\\n      if (i == e) return true;\\n      // check min condition\\n      for (int j = 0; j < s.size(); ++j) if (small[j] > s[j]) return false; \\n      for (int j = 0; j < s.size(); ++j) {        \\n        if (s[j] < *i || j && s[j] == s[j-1]) continue;\\n        // build unique valid subsums\\n        vector<int> ss(s); if (!(ss[j] -= *i)) ss.erase(ss.begin()+j);\\n        if (sort(ss.begin(),ss.end()), dfs(i+1, ss)) return true;\\n      }\\n      return false;\\n    }\\n    \\n    vector<int>::iterator e; // end of nums sorted descendingly\\n    vector<int> small = vector<int>(4); // 4 smallest subsums\\n```",
                "solutionTags": [],
                "code": "```\\npublic:    \\n    bool makesquare(vector<int>& nums) {\\n      int sum;\\n      if (nums.size() < 4 || (sum = accumulate(nums.begin(), nums.end(), 0))%4) return false;\\n      return sortSmall(nums), dfs(nums.begin(), vector<int>(4,sum/4));\\n    }\\nprivate: // helpers   \\n    // sort nums descendingly and calculate 4 smallest subsums\\n    void sortSmall(vector<int>& nums) {\\n      sort(nums.rbegin(), nums.rend());\\n      small = { *((e=nums.end())-1), *(e-2), min(*(e-1)+*(e-2),*(e-3)), \\n                min(max(*(e-1)+*(e-2),*(e-3)),*(e-4)) };\\n    }\\n\\n    // check if can partition into subsums {s[j]} starting at nums[i]\\n    bool dfs(vector<int>::iterator i, const vector<int>& s) {\\n      if (i == e) return true;\\n      // check min condition\\n      for (int j = 0; j < s.size(); ++j) if (small[j] > s[j]) return false; \\n      for (int j = 0; j < s.size(); ++j) {        \\n        if (s[j] < *i || j && s[j] == s[j-1]) continue;\\n        // build unique valid subsums\\n        vector<int> ss(s); if (!(ss[j] -= *i)) ss.erase(ss.begin()+j);\\n        if (sort(ss.begin(),ss.end()), dfs(i+1, ss)) return true;\\n      }\\n      return false;\\n    }\\n    \\n    vector<int>::iterator e; // end of nums sorted descendingly\\n    vector<int> small = vector<int>(4); // 4 smallest subsums\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95743,
                "title": "java-dfs-dp-solution",
                "content": "```\\npublic class Solution {\\n\\tprivate Set<Integer> flags;\\n\\n\\tpublic boolean makesquare(int[] nums) {\\n\\t\\tif (nums.length == 0) return false;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tsum += num;\\n\\t\\t}\\n\\t\\tif (sum % 4 != 0) return false;\\n\\t\\tflags = new HashSet<>();\\n\\n\\t\\tdfs(nums, 0, sum / 4);\\n\\n\\t\\tint len = (int) Math.pow(2, nums.length);\\n\\t\\tboolean[] dp = new boolean[len];\\n\\t\\tdp[0] = true;\\n\\t\\tfor (int num : flags) {\\n\\t\\t\\tfor (int i = dp.length - 1; i >= 0; i--) {\\n\\t\\t\\t\\tif (dp[i] && (num&i)==0) {\\n\\t\\t\\t\\t\\tdp[i | num] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[len - 1];\\n\\t}\\n\\n\\tpublic void dfs(int[] nums, int flag, int sum) {\\n\\t\\tif (sum == 0) {\\n\\t\\t\\tflags.add(flag);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (nums.length == 0) return;\\n\\n\\t\\tif (nums[0] <= sum) {\\n\\t\\t\\tdfs(Arrays.copyOfRange(nums, 1, nums.length), flag | (1 << nums.length - 1), sum - nums[0]);\\n\\t\\t}\\n\\t\\tdfs(Arrays.copyOfRange(nums, 1, nums.length), flag, sum);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tprivate Set<Integer> flags;\\n\\n\\tpublic boolean makesquare(int[] nums) {\\n\\t\\tif (nums.length == 0) return false;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tsum += num;\\n\\t\\t}\\n\\t\\tif (sum % 4 != 0) return false;\\n\\t\\tflags = new HashSet<>();\\n\\n\\t\\tdfs(nums, 0, sum / 4);\\n\\n\\t\\tint len = (int) Math.pow(2, nums.length);\\n\\t\\tboolean[] dp = new boolean[len];\\n\\t\\tdp[0] = true;\\n\\t\\tfor (int num : flags) {\\n\\t\\t\\tfor (int i = dp.length - 1; i >= 0; i--) {\\n\\t\\t\\t\\tif (dp[i] && (num&i)==0) {\\n\\t\\t\\t\\t\\tdp[i | num] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[len - 1];\\n\\t}\\n\\n\\tpublic void dfs(int[] nums, int flag, int sum) {\\n\\t\\tif (sum == 0) {\\n\\t\\t\\tflags.add(flag);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (nums.length == 0) return;\\n\\n\\t\\tif (nums[0] <= sum) {\\n\\t\\t\\tdfs(Arrays.copyOfRange(nums, 1, nums.length), flag | (1 << nums.length - 1), sum - nums[0]);\\n\\t\\t}\\n\\t\\tdfs(Arrays.copyOfRange(nums, 1, nums.length), flag, sum);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831944,
                "title": "same-as-698-bitmask-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        int k = 4;\\n        // Just k = 4 and same as 698.\\n        int N = nums.size();\\n        int sm = accumulate(nums.begin(), nums.end(), 0);\\n        sort(nums.rbegin(), nums.rend());\\n        int basket = sm / k;\\n        int rem = sm % k;\\n        if(rem || nums[0] > basket) return false;\\n        vector<int> dp(1 << N, -1);\\n        dp[0] = 0;\\n        \\n        for(int i = 1; i < 1<<N; ++i) {\\n            for(int j = 0; j < N; ++j) {\\n                int nei = dp[i ^ (1 << j)];\\n                if(nei >= 0 && nei + nums[j] <= basket && i & (1 << j)) {\\n                    dp[i] = (nei + nums[j]) % basket;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp.back() == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        int k = 4;\\n        // Just k = 4 and same as 698.\\n        int N = nums.size();\\n        int sm = accumulate(nums.begin(), nums.end(), 0);\\n        sort(nums.rbegin(), nums.rend());\\n        int basket = sm / k;\\n        int rem = sm % k;\\n        if(rem || nums[0] > basket) return false;\\n        vector<int> dp(1 << N, -1);\\n        dp[0] = 0;\\n        \\n        for(int i = 1; i < 1<<N; ++i) {\\n            for(int j = 0; j < N; ++j) {\\n                int nei = dp[i ^ (1 << j)];\\n                if(nei >= 0 && nei + nums[j] <= basket && i & (1 << j)) {\\n                    dp[i] = (nei + nums[j]) % basket;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp.back() == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329230,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool dfs(int i, vector<int> &ms, int side, vector<int> &v, int n)\\n     {\\n        if(i == n) \\n        {\\n            return v[0] == v[1] && v[1] == v[2] && v[2] == v[3];\\n        }\\n        for(int k=0; k<4; k++)\\n         {\\n            if(v[k] + ms[i] > side) continue;\\n            v[k] += ms[i];\\n            if(dfs(i + 1, ms, side, v, n)) return true;\\n            v[k] -= ms[i];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& ms) \\n    {\\n        int s = accumulate(ms.begin(), ms.end(), 0), n = ms.size();\\n        if(s % 4) return false;\\n        sort(ms.begin(), ms.end(), greater<int>());\\n        int side = s / 4;\\n        vector<int> v(4);\\n        return dfs(0, ms, side, v, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(int i, vector<int> &ms, int side, vector<int> &v, int n)\\n     {\\n        if(i == n) \\n        {\\n            return v[0] == v[1] && v[1] == v[2] && v[2] == v[3];\\n        }\\n        for(int k=0; k<4; k++)\\n         {\\n            if(v[k] + ms[i] > side) continue;\\n            v[k] += ms[i];\\n            if(dfs(i + 1, ms, side, v, n)) return true;\\n            v[k] -= ms[i];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& ms) \\n    {\\n        int s = accumulate(ms.begin(), ms.end(), 0), n = ms.size();\\n        if(s % 4) return false;\\n        sort(ms.begin(), ms.end(), greater<int>());\\n        int side = s / 4;\\n        vector<int> v(4);\\n        return dfs(0, ms, side, v, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635714,
                "title": "c-simple-60-time-beats-55-space-beats",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(int &a,int &b){\\n        return a>b;\\n    }\\n    bool solve(int i,int &n,vector<int> &arr,vector<int> &v,int &sum){\\n        if(i==n){\\n            int j;\\n            for(j = 1; j < 4; j++){\\n                if(v[j]!=v[j-1])break;\\n            }\\n            return (j==4);\\n        }\\n        for(int j = 0; j < 4; j++){\\n            if(v[j]+arr[i]>sum){\\n                continue;\\n            }\\n            v[j] += arr[i];\\n            if(solve(i+1,n,arr,v,sum)){\\n                return true;\\n            }\\n            v[j] -= arr[i];\\n        }\\n        return false;\\n    }\\n    bool makesquare(vector<int>& arr) {\\n        if(arr.size()<=3)return false;\\n        int sum = 0;\\n        for(auto &i: arr){\\n            sum += i;\\n        }\\n        if(sum%4)return false;\\n        sum = (sum>>2);\\n        sort(arr.begin(),arr.end(),cmp);\\n        if(arr[0]>sum)return false;\\n        vector<int> v(4,0);\\n        int n = arr.size();\\n        return solve(0,n,arr,v,sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(int &a,int &b){\\n        return a>b;\\n    }\\n    bool solve(int i,int &n,vector<int> &arr,vector<int> &v,int &sum){\\n        if(i==n){\\n            int j;\\n            for(j = 1; j < 4; j++){\\n                if(v[j]!=v[j-1])break;\\n            }\\n            return (j==4);\\n        }\\n        for(int j = 0; j < 4; j++){\\n            if(v[j]+arr[i]>sum){\\n                continue;\\n            }\\n            v[j] += arr[i];\\n            if(solve(i+1,n,arr,v,sum)){\\n                return true;\\n            }\\n            v[j] -= arr[i];\\n        }\\n        return false;\\n    }\\n    bool makesquare(vector<int>& arr) {\\n        if(arr.size()<=3)return false;\\n        int sum = 0;\\n        for(auto &i: arr){\\n            sum += i;\\n        }\\n        if(sum%4)return false;\\n        sum = (sum>>2);\\n        sort(arr.begin(),arr.end(),cmp);\\n        if(arr[0]>sum)return false;\\n        vector<int> v(4,0);\\n        int n = arr.size();\\n        return solve(0,n,arr,v,sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292077,
                "title": "c-solution-with-explanation",
                "content": "The solution was inspired by https://leetcode.com/problems/matchsticks-to-square/discuss/95744/cpp-6ms-solution-with-DFS\\n```    \\nbool makesquare(vector<int>& matchsticks) {\\n        // initially each side length is 0\\n        // we maintain a vector of size 4, initially it\\'s [0, 0, 0, 0]\\n        // we pick one matchstick from the input into each side and do dfs to check whether it can make a square\\n        // if the first match stick length is 3, we would try\\n        // [3, 0, 0, 0], [0, 3, 0, 0], [0, 0, 3, 0] and [0, 0, 0, 3] one by one\\n        if (matchsticks.size() < 4) {\\n            return false;\\n        }\\n        int sum = 0;\\n        for (auto val : matchsticks) {\\n            sum += val;\\n        }\\n        if (sum % 4 != 0) {\\n            return false;\\n        }\\n        // sort matchsticks from longer length to shorter, so that we can return false early if they can\\'t make a square\\n        // for example, if the longest match stick is longer than the side length, then we can return very quick\\n        sort(matchsticks.begin(), matchsticks.end(), greater<int>());\\n        vector<int> length(4, 0);\\n        return canMake(length, matchsticks, 0, sum / 4);\\n    }\\n    \\n    bool canMake(vector<int>& length, vector<int>& nums, int index, int sideLength) {\\n        // the sum of all length is a multiple of 4, so that if 3 of the sides are with equal length, the square is exist\\n        if (index == nums.size()) {\\n            return length[0] == sideLength && length[1] == sideLength && length[2] == sideLength;\\n        }\\n        for (int i = 0; i < 4; i++) {\\n            // if the total side length exceeds sideLength, we need to put nums[index] to next side and have a try\\n            if (length[i] + nums[index] > sideLength) {\\n                continue;\\n            }\\n            int j = i - 1;\\n            // if a preivous side with the same length as the current one, then it means that we\\'ve tried to put nums[index] there, but failed\\n            // so we don\\'t need to try to put nums[index] here again\\n            for (; j >= 0; j--) {\\n                if (length[i] == length[j]) {\\n                    break;\\n                }\\n            }\\n            if (j != -1) {\\n                continue;\\n            }\\n            length[i] += nums[index] ;\\n            if (canMake(length, nums, index + 1, sideLength)) {\\n                return true;\\n            }\\n            // if we can\\'t make a square if we put nums[index] on this side, then we need to try to put nums[index] on the next side\\n            length[i] -= nums[index];\\n        }\\n        // if there\\'s no place to put nums[index], we need to return false\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```    \\nbool makesquare(vector<int>& matchsticks) {\\n        // initially each side length is 0\\n        // we maintain a vector of size 4, initially it\\'s [0, 0, 0, 0]\\n        // we pick one matchstick from the input into each side and do dfs to check whether it can make a square\\n        // if the first match stick length is 3, we would try\\n        // [3, 0, 0, 0], [0, 3, 0, 0], [0, 0, 3, 0] and [0, 0, 0, 3] one by one\\n        if (matchsticks.size() < 4) {\\n            return false;\\n        }\\n        int sum = 0;\\n        for (auto val : matchsticks) {\\n            sum += val;\\n        }\\n        if (sum % 4 != 0) {\\n            return false;\\n        }\\n        // sort matchsticks from longer length to shorter, so that we can return false early if they can\\'t make a square\\n        // for example, if the longest match stick is longer than the side length, then we can return very quick\\n        sort(matchsticks.begin(), matchsticks.end(), greater<int>());\\n        vector<int> length(4, 0);\\n        return canMake(length, matchsticks, 0, sum / 4);\\n    }\\n    \\n    bool canMake(vector<int>& length, vector<int>& nums, int index, int sideLength) {\\n        // the sum of all length is a multiple of 4, so that if 3 of the sides are with equal length, the square is exist\\n        if (index == nums.size()) {\\n            return length[0] == sideLength && length[1] == sideLength && length[2] == sideLength;\\n        }\\n        for (int i = 0; i < 4; i++) {\\n            // if the total side length exceeds sideLength, we need to put nums[index] to next side and have a try\\n            if (length[i] + nums[index] > sideLength) {\\n                continue;\\n            }\\n            int j = i - 1;\\n            // if a preivous side with the same length as the current one, then it means that we\\'ve tried to put nums[index] there, but failed\\n            // so we don\\'t need to try to put nums[index] here again\\n            for (; j >= 0; j--) {\\n                if (length[i] == length[j]) {\\n                    break;\\n                }\\n            }\\n            if (j != -1) {\\n                continue;\\n            }\\n            length[i] += nums[index] ;\\n            if (canMake(length, nums, index + 1, sideLength)) {\\n                return true;\\n            }\\n            // if we can\\'t make a square if we put nums[index] on this side, then we need to try to put nums[index] on the next side\\n            length[i] -= nums[index];\\n        }\\n        // if there\\'s no place to put nums[index], we need to return false\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2274853,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\n    bool helper(vector<int>&m, int p, int l, int r, int t, int d){\\n        if(p==m.size()) return true;\\n        if(m[p]>l  and m[p]>r  and m[p]>t  and m[p]>d) return false;\\n        if(m[p]<=l and helper(m, p+1, l-m[p], r, t, d)) return true;\\n        if(m[p]<=r and helper(m, p+1, l, r-m[p], t, d)) return true;\\n        if(m[p]<=t and helper(m, p+1, l, r, t-m[p], d)) return true;\\n        if(m[p]<=d and helper(m, p+1, l, r, t, d-m[p])) return true;\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& m) {\\n        int s = accumulate(m.begin(), m.end(), 0);\\n        if(s%4 != 0) return false;\\n        s/=4;\\n        sort(m.begin(), m.end(),greater<int>());\\n        return helper(m,0,s,s,s,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool helper(vector<int>&m, int p, int l, int r, int t, int d){\\n        if(p==m.size()) return true;\\n        if(m[p]>l  and m[p]>r  and m[p]>t  and m[p]>d) return false;\\n        if(m[p]<=l and helper(m, p+1, l-m[p], r, t, d)) return true;\\n        if(m[p]<=r and helper(m, p+1, l, r-m[p], t, d)) return true;\\n        if(m[p]<=t and helper(m, p+1, l, r, t-m[p], d)) return true;\\n        if(m[p]<=d and helper(m, p+1, l, r, t, d-m[p])) return true;\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& m) {\\n        int s = accumulate(m.begin(), m.end(), 0);\\n        if(s%4 != 0) return false;\\n        s/=4;\\n        sort(m.begin(), m.end(),greater<int>());\\n        return helper(m,0,s,s,s,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274462,
                "title": "c-bitmask-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    // state - sides, mask of matchsticks available, sum needed\\n    // but we dont cache sum needed as sides and mask can determine the needed\\n    // this is called state space optimization\\n    \\n    // Time complexity - number of states x avg transition cost = 4*(2^n)*n -> O(n*2^n)\\n    \\n    int dp[4][1<<15];\\n    vector<int> matchsticks;\\n    int n;\\n    int target;\\n    \\n    int rec(int sides,int mask,int needed){\\n        // if needed is 0 we can make a side and set needed as target for next side\\n        if(needed == 0){\\n            return rec(sides+1,mask,target);\\n        }\\n        // if we are able to choose 3 sides then 4th one will exist as we already checked sum is divisble by 4\\n        if(sides == 3){\\n            return 1;\\n        }\\n        if(dp[sides][mask] != -1) return dp[sides][mask];\\n        \\n        bool ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            // if ith matchstick is available to use\\n            if((mask&(1<<i))){\\n                if(matchsticks[i]<=needed){\\n                    ans |= rec(sides,(mask^(1<<i)),needed-matchsticks[i]);\\n                }\\n            }\\n        }\\n        \\n        return dp[sides][mask] = ans;\\n    }\\n    \\n    bool makesquare(vector<int>& _matchsticks) {\\n        matchsticks = _matchsticks;\\n        n = matchsticks.size();\\n        int sm = 0;\\n        for(auto val:matchsticks) sm+=val;\\n        \\n        // if sm%4 is non zero, its not possible\\n        if(sm%4) return 0;\\n       \\n        target = sm/4;\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,(1<<n)-1,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    // state - sides, mask of matchsticks available, sum needed\\n    // but we dont cache sum needed as sides and mask can determine the needed\\n    // this is called state space optimization\\n    \\n    // Time complexity - number of states x avg transition cost = 4*(2^n)*n -> O(n*2^n)\\n    \\n    int dp[4][1<<15];\\n    vector<int> matchsticks;\\n    int n;\\n    int target;\\n    \\n    int rec(int sides,int mask,int needed){\\n        // if needed is 0 we can make a side and set needed as target for next side\\n        if(needed == 0){\\n            return rec(sides+1,mask,target);\\n        }\\n        // if we are able to choose 3 sides then 4th one will exist as we already checked sum is divisble by 4\\n        if(sides == 3){\\n            return 1;\\n        }\\n        if(dp[sides][mask] != -1) return dp[sides][mask];\\n        \\n        bool ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            // if ith matchstick is available to use\\n            if((mask&(1<<i))){\\n                if(matchsticks[i]<=needed){\\n                    ans |= rec(sides,(mask^(1<<i)),needed-matchsticks[i]);\\n                }\\n            }\\n        }\\n        \\n        return dp[sides][mask] = ans;\\n    }\\n    \\n    bool makesquare(vector<int>& _matchsticks) {\\n        matchsticks = _matchsticks;\\n        n = matchsticks.size();\\n        int sm = 0;\\n        for(auto val:matchsticks) sm+=val;\\n        \\n        // if sm%4 is non zero, its not possible\\n        if(sm%4) return 0;\\n       \\n        target = sm/4;\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,(1<<n)-1,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274381,
                "title": "bitmask-much-simpler-approach-no-dfs-or-backtracking-needed",
                "content": "Step 1: Take the sum of all elements and divide by 4. That is the required length of each side.\\n\\nStep 2: Iterate through all subsets of array to get hold of subsets that sum up to the required length. We store the masks of all such subsets in a vector (masks explained below).\\n\\nSo to iterate over all subsets, we iterate on all numbers from 1 to 2^n, where n is the length of the array, and for every number, we sum up the values at indices at which bits are set. This is done something like below \\n```\\nfor (int i=1; i<(1<<n); i++) {\\n\\tint sum = 0;   // This will hold the sum of values for the current subset\\n\\t               // represented by the binary representation of i\\n    for (int j=0; j<n; j++) {\\n\\t    if ((i>>j)&1) {\\n\\t\\t    sum += arr[j];\\n\\t    }\\n\\t}\\n\\tif (sum == required_len) {\\n\\t\\tv.push_back(i); // Store the mask if the sum of subset if correct\\n\\t}\\n}\\n```\\n\\nFor example, we have the array `[11,12,13,14,15,16]`, when the value of `i` in the outer loop is `37` (binary `100101`), this will correspond to the subset `{11,13,16}` as 11 is the 0th element, 13 is the 2nd element and 16 is the 5th element, and those are the bits that are \"on\" in the binary representation of `i`.\\n\\nStep 3: With this clear, we now have a vector where we have all subsets that sum to the required length. Now, we check for all pair of masks in this vector, if they are mutually exclusive (this can be done quickly by taking logical and (&) of the masks and checking if it turns out to be 0), and for each such pair, we combine them together and store them in a set. This denotes subsets which have length twice the required length but can be divided into two subsets of required length. These can be seen as two sides of the squares combined.\\n\\nStep 4: Now comes the final step - for each combination of two sides, we check if the remaining array is already in this set holding subsets of twice the required length. This can be done as follows - Suppose the current mask for two sets combined is `010011`, we can get the complement of this set by subtracting or XORing this from `111111`, which can be easily written as `(1<<n)-1`. The result in this case will be `101100`, and if this mask already exists in our set, then it means `101100` can be divided into two sets which sum to the required length individually. Thus, we have the answer as true.\\n\\nBelow is the implementation I used -\\n\\n```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& arr) {\\n        int n = arr.size();\\n        long long sum = 0;\\n        for (auto x: arr) {\\n            sum += x;\\n        }\\n        \\n        if (sum%4) return false;\\n        sum >>= 2;\\n        \\n        vector<int> m1;\\n        for (int i=0; i<(1<<n); i++) {\\n            long long cur_sum = 0;\\n            for (int j=0; j<n; j++) {\\n                if ((i>>j)&1) cur_sum += arr[j];\\n            }\\n            \\n            if (cur_sum == sum) m1.push_back(i);\\n        }\\n        \\n        int l = m1.size();\\n        \\n        set<int> m2;\\n        int cap = (1<<n) - 1;\\n        \\n        for (int i=0; i<l; i++) {\\n            for (int j=i+1; j<l; j++) {\\n                if ((m1[i] & m1[j]) != 0) continue;\\n                \\n                int nmask = m1[i] | m1[j];\\n                if (m2.find(cap-nmask) != m2.end()) return true;\\n                \\n                m2.insert(nmask);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nfor (int i=1; i<(1<<n); i++) {\\n\\tint sum = 0;   // This will hold the sum of values for the current subset\\n\\t               // represented by the binary representation of i\\n    for (int j=0; j<n; j++) {\\n\\t    if ((i>>j)&1) {\\n\\t\\t    sum += arr[j];\\n\\t    }\\n\\t}\\n\\tif (sum == required_len) {\\n\\t\\tv.push_back(i); // Store the mask if the sum of subset if correct\\n\\t}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& arr) {\\n        int n = arr.size();\\n        long long sum = 0;\\n        for (auto x: arr) {\\n            sum += x;\\n        }\\n        \\n        if (sum%4) return false;\\n        sum >>= 2;\\n        \\n        vector<int> m1;\\n        for (int i=0; i<(1<<n); i++) {\\n            long long cur_sum = 0;\\n            for (int j=0; j<n; j++) {\\n                if ((i>>j)&1) cur_sum += arr[j];\\n            }\\n            \\n            if (cur_sum == sum) m1.push_back(i);\\n        }\\n        \\n        int l = m1.size();\\n        \\n        set<int> m2;\\n        int cap = (1<<n) - 1;\\n        \\n        for (int i=0; i<l; i++) {\\n            for (int j=i+1; j<l; j++) {\\n                if ((m1[i] & m1[j]) != 0) continue;\\n                \\n                int nmask = m1[i] | m1[j];\\n                if (m2.find(cap-nmask) != m2.end()) return true;\\n                \\n                m2.insert(nmask);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273455,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(int ind, int s1, int s2, int s3, int s4, vector<int> &a) {\\n        if(ind == a.size()) {\\n            return s1 == 0 && s2 == 0 && s3 == 0 && s4 == 0;\\n        }\\n        if(a[ind] <= s1) {\\n            s1 -= a[ind];\\n            if(f(ind + 1, s1, s2, s3, s4, a)) return 1;\\n            s1 += a[ind];\\n        }\\n        if(a[ind] <= s2) {\\n            s2 -= a[ind];\\n            if(f(ind + 1, s1, s2, s3, s4, a)) return 1;\\n            s2 += a[ind];\\n        }\\n        if(a[ind] <= s3) {\\n            s3 -= a[ind];\\n            if(f(ind + 1, s1, s2, s3, s4, a)) return 1;\\n            s3 += a[ind];\\n        }\\n        if(a[ind] <= s4) {\\n            s4 -= a[ind];\\n            if(f(ind + 1, s1, s2, s3, s4, a)) return 1;\\n            s4 += a[ind];\\n        }\\n        return 0;\\n    }\\n    bool makesquare(vector<int>& a) {\\n        if(a.size() < 4) return 0;\\n        int sum = 0, side;\\n        for(auto x: a) sum += x;\\n        if(sum%4 != 0) return 0;\\n        side = sum / 4;\\n        sort(a.rbegin(), a.rend());\\n        return f(0, side, side, side, side, a);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int ind, int s1, int s2, int s3, int s4, vector<int> &a) {\\n        if(ind == a.size()) {\\n            return s1 == 0 && s2 == 0 && s3 == 0 && s4 == 0;\\n        }\\n        if(a[ind] <= s1) {\\n            s1 -= a[ind];\\n            if(f(ind + 1, s1, s2, s3, s4, a)) return 1;\\n            s1 += a[ind];\\n        }\\n        if(a[ind] <= s2) {\\n            s2 -= a[ind];\\n            if(f(ind + 1, s1, s2, s3, s4, a)) return 1;\\n            s2 += a[ind];\\n        }\\n        if(a[ind] <= s3) {\\n            s3 -= a[ind];\\n            if(f(ind + 1, s1, s2, s3, s4, a)) return 1;\\n            s3 += a[ind];\\n        }\\n        if(a[ind] <= s4) {\\n            s4 -= a[ind];\\n            if(f(ind + 1, s1, s2, s3, s4, a)) return 1;\\n            s4 += a[ind];\\n        }\\n        return 0;\\n    }\\n    bool makesquare(vector<int>& a) {\\n        if(a.size() < 4) return 0;\\n        int sum = 0, side;\\n        for(auto x: a) sum += x;\\n        if(sum%4 != 0) return 0;\\n        side = sum / 4;\\n        sort(a.rbegin(), a.rend());\\n        return f(0, side, side, side, side, a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273302,
                "title": "partition-to-k-subset-equal-sum",
                "content": "```\\nclass Solution{\\npublic:\\n    \\n    int solve(vector<int>&nums,int i,int sum,int target,int cnt,bool visit[]){\\n        if(cnt==0)\\n            return true;\\n        if(sum==target)\\n            return solve(nums,0,0,target,cnt-1,visit);\\n        for(int k=i;k<nums.size();k++){\\n            if(sum+nums[k]<=target &&visit[k]==0){\\n                visit[k]=1;\\n                if(solve(nums,k+1,sum+nums[k],target,cnt,visit))\\n                    return true;\\n                visit[k]=0;\\n            }\\n        }\\n        return false;\\n            \\n    }\\n    bool makesquare(vector<int>& s) {\\n        int sum=accumulate(s.begin(),s.end(),0);\\n        if(sum%4)return 0;\\n        bool visit[s.size()];\\n        memset(visit,0,sizeof visit);\\n        return solve(s,0,0,sum/4,4,visit);\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    \\n    int solve(vector<int>&nums,int i,int sum,int target,int cnt,bool visit[]){\\n        if(cnt==0)\\n            return true;\\n        if(sum==target)\\n            return solve(nums,0,0,target,cnt-1,visit);\\n        for(int k=i;k<nums.size();k++){\\n            if(sum+nums[k]<=target &&visit[k]==0){\\n                visit[k]=1;\\n                if(solve(nums,k+1,sum+nums[k],target,cnt,visit))\\n                    return true;\\n                visit[k]=0;\\n            }\\n        }\\n        return false;\\n            \\n    }\\n    bool makesquare(vector<int>& s) {\\n        int sum=accumulate(s.begin(),s.end(),0);\\n        if(sum%4)return 0;\\n        bool visit[s.size()];\\n        memset(visit,0,sizeof visit);\\n        return solve(s,0,0,sum/4,4,visit);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273205,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool backtrack(vector<int>& matchsticks,vector<int>& v, int target, int curr_sum, int i, int k) {\\n        if (k == 1) {\\n            return true;\\n        }\\n        if (curr_sum == target) {\\n            return backtrack(matchsticks, v, target, 0, 0, k - 1);\\n        }\\n        for (int j = i; j < matchsticks.size(); j++) {\\n            if (v[j] || curr_sum + matchsticks[j] > target) {\\n                continue;\\n            }\\n            v[j] = true;\\n            if (backtrack(matchsticks, v, target, curr_sum + matchsticks[j], j + 1, k)) return true;\\n            v[j] = false;\\n        }\\n        return false;\\n    }\\n    int sum_vector(vector<int>& matchsticks) {\\n        int ans = 0;\\n        for(int i = 0; i < matchsticks.size(); i++) {\\n            ans += matchsticks[i];\\n        }\\n        return ans;\\n    }\\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum = sum_vector(matchsticks);\\n        if(matchsticks.size() < 4 || sum % 4 != 0) {\\n            return false;\\n        }\\n        vector<int> v(matchsticks.size(), false);\\n        return backtrack(matchsticks, v, sum / 4, 0, 0, 4);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool backtrack(vector<int>& matchsticks,vector<int>& v, int target, int curr_sum, int i, int k) {\\n        if (k == 1) {\\n            return true;\\n        }\\n        if (curr_sum == target) {\\n            return backtrack(matchsticks, v, target, 0, 0, k - 1);\\n        }\\n        for (int j = i; j < matchsticks.size(); j++) {\\n            if (v[j] || curr_sum + matchsticks[j] > target) {\\n                continue;\\n            }\\n            v[j] = true;\\n            if (backtrack(matchsticks, v, target, curr_sum + matchsticks[j], j + 1, k)) return true;\\n            v[j] = false;\\n        }\\n        return false;\\n    }\\n    int sum_vector(vector<int>& matchsticks) {\\n        int ans = 0;\\n        for(int i = 0; i < matchsticks.size(); i++) {\\n            ans += matchsticks[i];\\n        }\\n        return ans;\\n    }\\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum = sum_vector(matchsticks);\\n        if(matchsticks.size() < 4 || sum % 4 != 0) {\\n            return false;\\n        }\\n        vector<int> v(matchsticks.size(), false);\\n        return backtrack(matchsticks, v, sum / 4, 0, 0, 4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273157,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>sides={0,0,0,0};\\n    bool solve(int ind,vector<int>&v,int x){\\n        \\n        if(ind==v.size()){\\n            return 1;\\n        }\\n        \\n        for(int k=0;k<4;k++){\\n            if(sides[k]+v[ind]<=x){\\n                sides[k]+=v[ind];\\n                if(solve(ind+1,v,x)) return 1;\\n                sides[k]-=v[ind];\\n            }\\n        }\\n        return 0;    \\n    }\\n    bool makesquare(vector<int>& mat) {\\n        int sum=0;\\n        for(int i=0;i<mat.size();i++){\\n            sum+=mat[i];\\n        }\\n        \\n        if(sum%4!=0) return 0;\\n        sort(mat.begin(),mat.end(),greater<>());\\n        \\n        return solve(0,mat,sum/4);\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int>sides={0,0,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2272806,
                "title": "simple-python-solution-with-explanation-recursion-and-dp-no-tle",
                "content": "Basic idea:\\n===========\\n1.  Ensure the total sticks is divisible by 4.\\n\\n2.  Compute the length of ```side``` by taking the total sticks and dividing by 4.\\n\\n3.  Recurse using the following logic:\\n\\t- use ```remainder``` to track the remaining sticks.\\n\\t- select any stick ```i```, and compute the next number to find by deducting ```remainder[i]``` from ```side```.\\n\\t- store the results in a dictionary ```dp``` (dynamic programming)\\n\\n4.  Continuously iterate until either:\\n\\t- ```remainder``` is empty, where we return ```True```\\n\\t- or it\\'s not possible for ```remainder``` to be empty (because there will be some remaining items which are greater than ```find```), where we then return ```False```\\n\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        def recurse(remainder, find):\\n            if len(remainder) == 0:\\n                return True\\n            if tuple(remainder) in dp:\\n                return dp[tuple(remainder)]\\n\\n            result = False\\n            for i in range(len(remainder)):           \\n                if remainder[i] <= find: \\n                    result = result or recurse(remainder[:i] + remainder[i+1:], \\n                                   (find - remainder[i]) if find > remainder[i] else side)\\n                    if result: \\n                        dp[tuple(remainder)] = True\\n                        return True\\n            dp[tuple(remainder)] = False\\n            return False\\n        \\n        if sum(matchsticks) % 4 != 0: return False\\n        side = sum(matchsticks)//4\\n        for i in range(len(matchsticks)):\\n            if matchsticks[i] > side: return False\\n        \\n        dp = {}\\n        return recurse(matchsticks, side)\\n```",
                "solutionTags": [],
                "code": "```side```\n```remainder```\n```i```\n```remainder[i]```\n```side```\n```dp```\n```remainder```\n```True```\n```remainder```\n```find```\n```False```\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        def recurse(remainder, find):\\n            if len(remainder) == 0:\\n                return True\\n            if tuple(remainder) in dp:\\n                return dp[tuple(remainder)]\\n\\n            result = False\\n            for i in range(len(remainder)):           \\n                if remainder[i] <= find: \\n                    result = result or recurse(remainder[:i] + remainder[i+1:], \\n                                   (find - remainder[i]) if find > remainder[i] else side)\\n                    if result: \\n                        dp[tuple(remainder)] = True\\n                        return True\\n            dp[tuple(remainder)] = False\\n            return False\\n        \\n        if sum(matchsticks) % 4 != 0: return False\\n        side = sum(matchsticks)//4\\n        for i in range(len(matchsticks)):\\n            if matchsticks[i] > side: return False\\n        \\n        dp = {}\\n        return recurse(matchsticks, side)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272475,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        int sum=0;\\n        for(int m:matchsticks) \\n            sum+=m;\\n        if(sum%4!=0) \\n            return false;\\n        Arrays.sort(matchsticks);\\n        reverse(matchsticks,matchsticks.length);\\n        return solve(matchsticks,sum/4,0,0,new boolean[matchsticks.length],4);\\n    }\\n    \\n    private boolean solve(int[] match, int target, int curr, int idx, boolean used[], int k) {\\n        if(k==1) \\n            return true;\\n        if(curr>target) \\n            return false;\\n        if(curr==target) \\n            return solve(match,target,0,0,used,k-1);\\n        \\n        for(int i=idx;i<match.length;++i) {\\n            if(used[i]) \\n                continue;\\n            used[i] = true;\\n            if(solve(match,target,curr+match[i],i+1,used,k)) \\n                return true;\\n            used[i] = false;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private static void reverse(int a[], int n) {\\n        int i,k,t;\\n        for (i=0;i<n/2;++i) {\\n            t = a[i];\\n            a[i] = a[n - i - 1];\\n            a[n - i - 1] = t;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        int sum=0;\\n        for(int m:matchsticks) \\n            sum+=m;\\n        if(sum%4!=0) \\n            return false;\\n        Arrays.sort(matchsticks);\\n        reverse(matchsticks,matchsticks.length);\\n        return solve(matchsticks,sum/4,0,0,new boolean[matchsticks.length],4);\\n    }\\n    \\n    private boolean solve(int[] match, int target, int curr, int idx, boolean used[], int k) {\\n        if(k==1) \\n            return true;\\n        if(curr>target) \\n            return false;\\n        if(curr==target) \\n            return solve(match,target,0,0,used,k-1);\\n        \\n        for(int i=idx;i<match.length;++i) {\\n            if(used[i]) \\n                continue;\\n            used[i] = true;\\n            if(solve(match,target,curr+match[i],i+1,used,k)) \\n                return true;\\n            used[i] = false;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private static void reverse(int a[], int n) {\\n        int i,k,t;\\n        for (i=0;i<n/2;++i) {\\n            t = a[i];\\n            a[i] = a[n - i - 1];\\n            a[n - i - 1] = t;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272003,
                "title": "same-as-partition-to-k-equal-sum-subset-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(vector<int> nums,vector<bool>& visited,int currsum,int idx,int subsetsum,int k){\\n        if(k==0)    return true;\\n        if(currsum>subsetsum)   return false;\\n        \\n        if(currsum==subsetsum){\\n            return solve(nums,visited,0,0,subsetsum,k-1);\\n        }\\n        \\n        for(int i=idx;i<nums.size();i++){\\n            \\n            if(visited[i])  continue;\\n            \\n            visited[i] = true;\\n            if(solve(nums,visited,currsum+nums[i],i+1,subsetsum,k))return true;\\n            visited[i] = false;\\n            \\n            if(currsum==0)break;    // Optimisation\\n        }\\n        return false;\\n    }\\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k > n)   return false;\\n        int sum=0;\\n        for(auto n : nums)\\n            sum += n;\\n       \\n        if (nums.size() < k || sum % k) return false;\\n        int subsetsum = sum/k;\\n        vector<bool> v(n,false);\\n\\t\\t\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        return solve(nums,v,0,0,subsetsum,k);\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        return canPartitionKSubsets(matchsticks,4);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(vector<int> nums,vector<bool>& visited,int currsum,int idx,int subsetsum,int k){\\n        if(k==0)    return true;\\n        if(currsum>subsetsum)   return false;\\n        \\n        if(currsum==subsetsum){\\n            return solve(nums,visited,0,0,subsetsum,k-1);\\n        }\\n        \\n        for(int i=idx;i<nums.size();i++){\\n            \\n            if(visited[i])  continue;\\n            \\n            visited[i] = true;\\n            if(solve(nums,visited,currsum+nums[i],i+1,subsetsum,k))return true;\\n            visited[i] = false;\\n            \\n            if(currsum==0)break;    // Optimisation\\n        }\\n        return false;\\n    }\\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k > n)   return false;\\n        int sum=0;\\n        for(auto n : nums)\\n            sum += n;\\n       \\n        if (nums.size() < k || sum % k) return false;\\n        int subsetsum = sum/k;\\n        vector<bool> v(n,false);\\n\\t\\t\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        return solve(nums,v,0,0,subsetsum,k);\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        return canPartitionKSubsets(matchsticks,4);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271978,
                "title": "java-accepeted-by-just-using-backtracking-beginner-friendly",
                "content": "Easy understandable Solution using backtracking \\nTakes extra space but accepted \\n\\n\\n\\'\\'\\'\\n\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\tpublic boolean makesquare(int[] matchsticks) {\\n\\t\\t\\t\\t\\t\\tint n=matchsticks.length;\\n\\t\\t\\t\\t\\t\\t\\tif(n<4)return false;\\n\\t\\t\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\t\\t\\t\\tsum+=matchsticks[i];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(sum%4!=0)return false;\\n\\t\\t\\t\\t\\t\\t\\tArrays.sort(matchsticks); ///must  sort and reverse else it may node be accepeted\\n\\t\\t\\t\\t\\t\\t\\tint low=0;int high=n-1;\\n\\t\\t\\t\\t\\t\\t\\twhile(low<high){\\n\\t\\t\\t\\t\\t\\t\\t\\tint temp=matchsticks[low];\\n\\t\\t\\t\\t\\t\\t\\t\\tmatchsticks[low]=matchsticks[high];\\n\\t\\t\\t\\t\\t\\t\\t\\tmatchsticks[high]=temp;\\n\\t\\t\\t\\t\\t\\t\\t\\tlow++;\\n\\t\\t\\t\\t\\t\\t\\t\\thigh--;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif(matchsticks[0]>sum/4)return false;\\n\\n\\t\\t\\t\\t\\t\\t\\tint sides[]=new int[4];\\n\\n\\t\\t\\t\\t\\t\\t\\treturn solve(0,sum/4,n,matchsticks,sides);\\n\\t\\t\\t\\t\\t\\t}\\n\\n    public boolean solve(int i,int max,int n,int[] matchsticks,int[] sides){\\n        if(i==n){\\n            \\n               for(int itr=0;itr<4;itr++){\\n                   if(sides[itr]!=max)return false;\\n                   return true;\\n               }\\n        }\\n        \\n        for(int j=0;j<4;j++){\\n            if(sides[j]+matchsticks[i]<=max){\\n                sides[j]+=matchsticks[i];\\n                if(solve(i+1,max,n,matchsticks,sides)==true)return true;\\n                sides[j]-=matchsticks[i];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\t\\t\\tpublic boolean makesquare(int[] matchsticks) {\\n\\t\\t\\t\\t\\t\\tint n=matchsticks.length;\\n\\t\\t\\t\\t\\t\\t\\tif(n<4)return false;\\n\\t\\t\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\t\\t\\t\\tsum+=matchsticks[i];\\n\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2271575,
                "title": "c-easy-backtracking",
                "content": "class Solution {\\npublic:\\n\\n    int tar;\\n    bool solve(int i,int n,vector<int>&res,vector<int>&ms){\\n       if(i>=n){\\n        return (res[0]==res[1]&&res[1]==res[2]&&res[2]==res[3]&&res[3]== tar);\\n       }\\n       for(int j=0;j<4;j++){\\n           if(res[j]+ms[i] > tar)\\n           continue;\\n               res[j]+=ms[i];\\n               if(solve(i+1,n,res,ms))\\n               return true;\\n               res[j]-=ms[i];\\n       }\\n       return false;\\n    }\\n    bool makesquare(vector<int>& ms) {\\n        int n=ms.size();\\n        int sum =0;\\n        for(auto it : ms)\\n        sum+=it;\\n        if(sum % 4 != 0)\\n        return false;\\n        tar=sum/4;\\n        sort(ms.rbegin(), ms.rend());\\n        vector<int>res(4,0);\\n        return solve(0,n,res,ms);\\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int tar;\\n    bool solve(int i,int n,vector<int>&res,vector<int>&ms){\\n       if(i>=n){\\n        return (res[0]==res[1]&&res[1]==res[2]&&res[2]==res[3]&&res[3]== tar);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2271468,
                "title": "c-simple-code-backtracking-90-better",
                "content": "class Solution {\\npublic:\\n    bool sol(vector<int>& a,vector<int>& v,int i,int s) {\\n        if(i==a.size()) {\\n            if(v[0]==v[1]&&v[1]==v[2]&&v[2]==v[3]) return true;\\n            else return false;\\n        } else {\\n            for(int j=0;j<4;j++) {\\n                v[j]+=a[i];\\n                if(v[j]<=s&&sol(a,v,i+1,s)) return true;\\n                v[j]-=a[i];\\n            }\\n            return false;\\n        }\\n    }\\n    bool makesquare(vector<int>& a) {\\n        sort(a.rbegin(),a.rend());\\n        int s=0;\\n        for(int i:a) s+=i;\\n        if(s % 4 != 0) return false;\\n        vector<int> v(4,0);\\n        return sol(a,v,0,s/4);\\n    }\\n};",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    bool sol(vector<int>& a,vector<int>& v,int i,int s) {\\n        if(i==a.size()) {\\n            if(v[0]==v[1]&&v[1]==v[2]&&v[2]==v[3]) return true;\\n            else return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2271297,
                "title": "recursive-javascript-js",
                "content": "/**\\n * @param {number[]} matchsticks\\n * @return {boolean}\\n */\\n```\\nvar makesquare = function(matchsticks) {\\n    const sum =  matchsticks.reduce((acc, value) => acc + value, 0) \\n    if (sum % 4 !== 0 )  return false\\n    \\n    let sides =  new Array(4).fill(0)\\n    matchsticks.sort( ( a,b ) => b - a )\\n    \\n    function backtrack( i ){\\n       if ( i === matchsticks.length ) return true\\n        \\n       for ( let j = 0 ; j < 4 ;j++){\\n           if( sides[j] + matchsticks[i] <= sum/4 ){\\n               sides[j] += matchsticks[i]\\n               if( backtrack(i+1) ) return true\\n               sides[j] -=matchsticks[i]\\n           }\\n       }\\n        return false\\n    }\\n     return backtrack(0)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar makesquare = function(matchsticks) {\\n    const sum =  matchsticks.reduce((acc, value) => acc + value, 0) \\n    if (sum % 4 !== 0 )  return false\\n    \\n    let sides =  new Array(4).fill(0)\\n    matchsticks.sort( ( a,b ) => b - a )\\n    \\n    function backtrack( i ){\\n       if ( i === matchsticks.length ) return true\\n        \\n       for ( let j = 0 ; j < 4 ;j++){\\n           if( sides[j] + matchsticks[i] <= sum/4 ){\\n               sides[j] += matchsticks[i]\\n               if( backtrack(i+1) ) return true\\n               sides[j] -=matchsticks[i]\\n           }\\n       }\\n        return false\\n    }\\n     return backtrack(0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271252,
                "title": "java-solution-using-dfs-with-recursion",
                "content": "```\\nclass Solution {\\n    int arr[] = new int[4];\\n    int target = 0;\\n    int[] matchsticks;\\n    public boolean makesquare(int[] matchstick) {\\n        int n=matchstick.length;\\n        \\n        if(n<4) return false;\\n        \\n        matchsticks=matchstick;\\n        for (int i : matchsticks) target += i;   \\n        if (target % 4 != 0) return false; \\n        \\n        Arrays.sort(matchsticks);\\n        target/=4;\\n        \\n        return square(n - 1);\\n    }\\n    \\n    public boolean square(int index) {\\n        \\n        if (arr[0] == target && arr[1] == target && arr[2] == target && arr[3] == target) return true;\\n                \\n        arr[0] += matchsticks[index];\\n        if (arr[0]<= target && square(index - 1)) return true;\\n        arr[0] -= matchsticks[index];\\n        \\n        arr[1] += matchsticks[index];\\n        if (arr[1]<= target && square(index - 1)) return true;\\n        arr[1] -= matchsticks[index];\\n        \\n        arr[2] += matchsticks[index];\\n        if (arr[2]<= target && square(index - 1)) return true;\\n        arr[2] -= matchsticks[index];\\n        \\n        arr[3] += matchsticks[index];\\n        if (arr[3]<= target && square(index - 1)) return true;\\n        arr[3] -= matchsticks[index];\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int arr[] = new int[4];\\n    int target = 0;\\n    int[] matchsticks;\\n    public boolean makesquare(int[] matchstick) {\\n        int n=matchstick.length;\\n        \\n        if(n<4) return false;\\n        \\n        matchsticks=matchstick;\\n        for (int i : matchsticks) target += i;   \\n        if (target % 4 != 0) return false; \\n        \\n        Arrays.sort(matchsticks);\\n        target/=4;\\n        \\n        return square(n - 1);\\n    }\\n    \\n    public boolean square(int index) {\\n        \\n        if (arr[0] == target && arr[1] == target && arr[2] == target && arr[3] == target) return true;\\n                \\n        arr[0] += matchsticks[index];\\n        if (arr[0]<= target && square(index - 1)) return true;\\n        arr[0] -= matchsticks[index];\\n        \\n        arr[1] += matchsticks[index];\\n        if (arr[1]<= target && square(index - 1)) return true;\\n        arr[1] -= matchsticks[index];\\n        \\n        arr[2] += matchsticks[index];\\n        if (arr[2]<= target && square(index - 1)) return true;\\n        arr[2] -= matchsticks[index];\\n        \\n        arr[3] += matchsticks[index];\\n        if (arr[3]<= target && square(index - 1)) return true;\\n        arr[3] -= matchsticks[index];\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271156,
                "title": "python-i-have-a-simple-solution-for-you",
                "content": "## I have a simple solution for you :) \\n** [Click here.](https://linktr.ee/anandchauhan)\\n\\n\\n+ Easy solution\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        length = sum(matchsticks) // 4\\n        sides = [0] * 4\\n        if sum(matchsticks) / 4 != length:\\n            return False\\n        matchsticks.sort(reverse=True)\\n\\n        def backtrack(i):\\n            if i == len(matchsticks):\\n                return True\\n            for j in range(4):\\n                if sides[j] + matchsticks[i] <= length:\\n                    sides[j] += matchsticks[i]\\n                    if backtrack(i + 1):\\n                        return True\\n                    sides[j] -= matchsticks[i]\\n            return False\\n\\n        return backtrack(0)\\n```\\n\\n-----\\n\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        length = sum(matchsticks) // 4\\n        sides = [0] * 4\\n        if sum(matchsticks) / 4 != length:\\n            return False\\n        matchsticks.sort(reverse=True)\\n\\n        def backtrack(i):\\n            if i == len(matchsticks):\\n                return True\\n            for j in range(4):\\n                if sides[j] + matchsticks[i] <= length:\\n                    sides[j] += matchsticks[i]\\n                    if backtrack(i + 1):\\n                        return True\\n                    sides[j] -= matchsticks[i]\\n            return False\\n\\n        return backtrack(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271118,
                "title": "javascript-2-solutions-backtracking-dfs-sorting",
                "content": "**Solution 1: Neive DFS with Sorting**\\n\\n```\\n// Time Complexity: O(4^n)\\n// Space Complexity: O(n)\\n\\nvar makesquare = function(matchsticks) {\\n\\tif (!matchsticks || matchsticks.length < 4) \\n\\t\\treturn false;\\n\\t\\t\\n\\tlet sum = 0;\\n\\tfor (const match of matchsticks) \\n\\t\\tsum += match;\\n\\t\\t\\n\\tif (sum % 4 != 0) \\n\\t\\treturn false;\\n\\t\\n\\tmatchsticks.sort((a, b) => b - a);\\n    \\n    const sums = Array(4).fill(0);\\n\\t\\n\\tfunction dfs(index, target) {\\n\\t\\tif (index > matchsticks.length - 1) \\n\\t\\t\\treturn true;\\n\\n\\t\\tfor (let i = 0; i < 4; i++) {\\n\\t\\t\\tif (sums[i] + matchsticks[index] > target )\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\n\\t\\t\\tsums[i] += matchsticks[index];\\n\\n\\t\\t\\tif (dfs(index + 1, target)) \\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\n\\t\\t\\tsums[i] -= matchsticks[index];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n\\t\\n\\treturn dfs(0, sum / 4);\\n};\\n```\\n\\n**Solution 2: Optimized DFS with Set**\\n\\n```\\n// Time Complexity: O(4^n)\\n// Space Complexity: O(n)\\n\\nvar makesquare = function(matchsticks) {\\n\\tif (matchsticks.length < 4) \\n\\t\\treturn false;\\n\\t\\t\\n\\tlet sum = 0;\\n\\tfor (const match of matchsticks) \\n\\t\\tsum += match;\\n\\t\\t\\n\\tif (sum % 4 != 0) \\n\\t\\treturn false;\\n\\t\\n\\tmatchsticks.sort((a, b) => b - a);\\n\\n    const sums = Array(4).fill(0);\\n\\t\\n\\tfunction dfs(index, target) {\\n\\t\\tif (index > matchsticks.length - 1) \\n\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\tconst seen = new Set();\\n\\n\\t\\tfor (let i = 0; i < 4; i++) {\\n\\t\\t\\tif (sums[i] + matchsticks[index] > target || seen.has(sums[i]))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\n            seen.add(sums[i]);\\n\\t\\t\\tsums[i] += matchsticks[index];\\n\\t\\t\\t\\n\\t\\t\\tif (dfs(index + 1, target)) \\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\n\\t\\t\\tsums[i] -= matchsticks[index];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n\\t\\n\\treturn dfs(0, sum / 4);\\n};\\n```\\n\\nPlease leave comment for any suggesstion. Please upvote if you find this post useful.",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\n// Time Complexity: O(4^n)\\n// Space Complexity: O(n)\\n\\nvar makesquare = function(matchsticks) {\\n\\tif (!matchsticks || matchsticks.length < 4) \\n\\t\\treturn false;\\n\\t\\t\\n\\tlet sum = 0;\\n\\tfor (const match of matchsticks) \\n\\t\\tsum += match;\\n\\t\\t\\n\\tif (sum % 4 != 0) \\n\\t\\treturn false;\\n\\t\\n\\tmatchsticks.sort((a, b) => b - a);\\n    \\n    const sums = Array(4).fill(0);\\n\\t\\n\\tfunction dfs(index, target) {\\n\\t\\tif (index > matchsticks.length - 1) \\n\\t\\t\\treturn true;\\n\\n\\t\\tfor (let i = 0; i < 4; i++) {\\n\\t\\t\\tif (sums[i] + matchsticks[index] > target )\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\n\\t\\t\\tsums[i] += matchsticks[index];\\n\\n\\t\\t\\tif (dfs(index + 1, target)) \\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\n\\t\\t\\tsums[i] -= matchsticks[index];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n\\t\\n\\treturn dfs(0, sum / 4);\\n};\\n```\n```\\n// Time Complexity: O(4^n)\\n// Space Complexity: O(n)\\n\\nvar makesquare = function(matchsticks) {\\n\\tif (matchsticks.length < 4) \\n\\t\\treturn false;\\n\\t\\t\\n\\tlet sum = 0;\\n\\tfor (const match of matchsticks) \\n\\t\\tsum += match;\\n\\t\\t\\n\\tif (sum % 4 != 0) \\n\\t\\treturn false;\\n\\t\\n\\tmatchsticks.sort((a, b) => b - a);\\n\\n    const sums = Array(4).fill(0);\\n\\t\\n\\tfunction dfs(index, target) {\\n\\t\\tif (index > matchsticks.length - 1) \\n\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\tconst seen = new Set();\\n\\n\\t\\tfor (let i = 0; i < 4; i++) {\\n\\t\\t\\tif (sums[i] + matchsticks[index] > target || seen.has(sums[i]))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\n            seen.add(sums[i]);\\n\\t\\t\\tsums[i] += matchsticks[index];\\n\\t\\t\\t\\n\\t\\t\\tif (dfs(index + 1, target)) \\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\n\\t\\t\\tsums[i] -= matchsticks[index];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n\\t\\n\\treturn dfs(0, sum / 4);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271070,
                "title": "c-backtracking",
                "content": "**Question is similar to  Partition to K Equal Sum Subsets**\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\n\\n```\\nclass Solution {// # T.C--->  O(2^ (4*n)), because if we have K trees stacked on top of each other, the new height of the tree is K * n. i.e one is not independent from other.\\n// S.C---->O(N) \\npublic:\\n     bool backtrack(vector<int>&a,int start,int curr_sum,int k,int &req_sum,int n,vector<bool>&vis){\\n      if(k==1)return true;\\n      if(curr_sum==req_sum)return backtrack(a,0,0,k-1,req_sum,n,vis);\\n      \\n      for(int i=start;i<n;i++){\\n          if(vis[i]==false){\\n              if(curr_sum+a[i]>req_sum)continue;\\n              vis[i]=true;\\n              if(backtrack(a,i+1,curr_sum+a[i],k,req_sum,n,vis))return true;\\n              vis[i]=false;\\n                 if(curr_sum==0){cout<<i<<\" \";break; } //if a bucket do not find the right number to match the target, so the latter can be dropped off.\\n              \\n      //Ok, let\\'s understand this way. Do we need to proceed further if our curr_element is not included in any subset?\\n// Similarly, if we didn\\'t get k subset starting with ith index which means ith element not included in any subset, so we should drop further calls.\\n// Eg. nums [5,3,7], k=3. nums[6,3,6], k=3.        \\n//Eg: nums=[6,3,6], k=3\\n      }\\n          }\\n      return false;\\n  }\\n    bool makesquare(vector<int>& a) {\\n        int k=4;\\n         int sum=accumulate(a.begin(),a.end(),0);\\n        int n=a.size();\\n        sort(a.begin(),a.end(),greater<int>()); //This increase time complexity and reduce calls in backtracking break conditions. We can sort it in asccending order also\\n         if(sum%k ||n<k)return false;\\n         vector<bool>vis(n,false);\\n        int req_sum=sum/k;\\n         return backtrack(a,0,0,k,req_sum,n,vis);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {// # T.C--->  O(2^ (4*n)), because if we have K trees stacked on top of each other, the new height of the tree is K * n. i.e one is not independent from other.\\n// S.C---->O(N) \\npublic:\\n     bool backtrack(vector<int>&a,int start,int curr_sum,int k,int &req_sum,int n,vector<bool>&vis){\\n      if(k==1)return true;\\n      if(curr_sum==req_sum)return backtrack(a,0,0,k-1,req_sum,n,vis);\\n      \\n      for(int i=start;i<n;i++){\\n          if(vis[i]==false){\\n              if(curr_sum+a[i]>req_sum)continue;\\n              vis[i]=true;\\n              if(backtrack(a,i+1,curr_sum+a[i],k,req_sum,n,vis))return true;\\n              vis[i]=false;\\n                 if(curr_sum==0){cout<<i<<\" \";break; } //if a bucket do not find the right number to match the target, so the latter can be dropped off.\\n              \\n      //Ok, let\\'s understand this way. Do we need to proceed further if our curr_element is not included in any subset?\\n// Similarly, if we didn\\'t get k subset starting with ith index which means ith element not included in any subset, so we should drop further calls.\\n// Eg. nums [5,3,7], k=3. nums[6,3,6], k=3.        \\n//Eg: nums=[6,3,6], k=3\\n      }\\n          }\\n      return false;\\n  }\\n    bool makesquare(vector<int>& a) {\\n        int k=4;\\n         int sum=accumulate(a.begin(),a.end(),0);\\n        int n=a.size();\\n        sort(a.begin(),a.end(),greater<int>()); //This increase time complexity and reduce calls in backtracking break conditions. We can sort it in asccending order also\\n         if(sum%k ||n<k)return false;\\n         vector<bool>vis(n,false);\\n        int req_sum=sum/k;\\n         return backtrack(a,0,0,k,req_sum,n,vis);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2270876,
                "title": "java-easy-dfs-recursion-solution",
                "content": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        if(matchsticks.length < 4)return false;\\n        \\n        int sum = 0 ;\\n        for(int a:matchsticks)sum+=a;\\n        \\n        if(sum % 4 != 0)return false;\\n        \\n        int side[] = {sum/4 , sum/4 , sum/4 , sum/4}; \\n        \\n        Arrays.sort(matchsticks);\\n        \\n        return dfs(matchsticks , side , matchsticks.length - 1);\\n    \\n    }\\n    \\n    private boolean dfs(int[] match , int[] sides , int idx){\\n        \\n        if(idx == -1)return sides[0] == sides[1] && sides[1] == sides[2] && sides[2] == sides[3];\\n        \\n        for(int i = 0 ; i < sides.length ; i++)\\n        {\\n            if(match[idx] <=sides[i])\\n            {\\n                sides[i]-=match[idx]; \\n                if(dfs(match , sides , idx - 1))return true;\\n                sides[i]+=match[idx];\\n            }\\n        }return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        if(matchsticks.length < 4)return false;\\n        \\n        int sum = 0 ;\\n        for(int a:matchsticks)sum+=a;\\n        \\n        if(sum % 4 != 0)return false;\\n        \\n        int side[] = {sum/4 , sum/4 , sum/4 , sum/4}; \\n        \\n        Arrays.sort(matchsticks);\\n        \\n        return dfs(matchsticks , side , matchsticks.length - 1);\\n    \\n    }\\n    \\n    private boolean dfs(int[] match , int[] sides , int idx){\\n        \\n        if(idx == -1)return sides[0] == sides[1] && sides[1] == sides[2] && sides[2] == sides[3];\\n        \\n        for(int i = 0 ; i < sides.length ; i++)\\n        {\\n            if(match[idx] <=sides[i])\\n            {\\n                sides[i]-=match[idx]; \\n                if(dfs(match , sides , idx - 1))return true;\\n                sides[i]+=match[idx];\\n            }\\n        }return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270603,
                "title": "cleanest-python3-code-with-explanation-generalized-partitioning-into-k-buckets",
                "content": "### Breakdown\\n1. Few basic checks are needed \\u2013\\xA0there should be at least 4 matchsticks, the sum of matchstick lengths should be divisble by 4, and none of the matchstick length should exceed the side length of the square.\\n2. To partition a list of nums (matchsticks) into k-buckets (4 sides in our case), we use backtracking to place each number into each bucket, ensuring that bucket sum doesn\\'t exceed the target sum.\\n3. Pruning \\u2013\\xA0Since buckets are filled from left to right, if any bucket remains empty (i.e. no combination of elements sum up to target), then all buckets to the right of it will also be empty.\\n\\n### Code\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        # There should be at least 4 matchsticks.\\n        if len(matchsticks) < 4:\\n            return False\\n        \\n        # Sum of matchstick lengths should be divisble by four.\\n        side_length, remainder = divmod(sum(matchsticks), 4)\\n        if remainder != 0:\\n            return False\\n        \\n        # There shouldn\\'t be any single matchstick with length greater than side_length.\\n        if max(matchsticks) > side_length:\\n            return False\\n        \\n        # Check if partitioning is possible.\\n        return self.can_partition(matchsticks, 4, side_length)\\n    \\n    def can_partition(self, nums, k, target):\\n        buckets = [0] * k\\n        nums.sort(reverse=True)  # pruning\\n        \\n        def backtrack(idx):\\n            # If all elements have been used, check if all are equal.\\n            if idx == len(nums):\\n                return len(set(buckets)) == 1\\n            \\n            # Try placing numbers in each bucket.\\n            for b in range(k):\\n                buckets[b] += nums[idx]\\n                if buckets[b] <= target and backtrack(idx + 1):\\n                    return True\\n                buckets[b] -= nums[idx]\\n                \\n                # Pruning: Buckets are filled from left to right. If any bucket remains empty,\\n                # then all buckets to the right of it will also be empty.\\n                if buckets[b] == 0:\\n                    break\\n            \\n            return False\\n        \\n        return backtrack(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        # There should be at least 4 matchsticks.\\n        if len(matchsticks) < 4:\\n            return False\\n        \\n        # Sum of matchstick lengths should be divisble by four.\\n        side_length, remainder = divmod(sum(matchsticks), 4)\\n        if remainder != 0:\\n            return False\\n        \\n        # There shouldn\\'t be any single matchstick with length greater than side_length.\\n        if max(matchsticks) > side_length:\\n            return False\\n        \\n        # Check if partitioning is possible.\\n        return self.can_partition(matchsticks, 4, side_length)\\n    \\n    def can_partition(self, nums, k, target):\\n        buckets = [0] * k\\n        nums.sort(reverse=True)  # pruning\\n        \\n        def backtrack(idx):\\n            # If all elements have been used, check if all are equal.\\n            if idx == len(nums):\\n                return len(set(buckets)) == 1\\n            \\n            # Try placing numbers in each bucket.\\n            for b in range(k):\\n                buckets[b] += nums[idx]\\n                if buckets[b] <= target and backtrack(idx + 1):\\n                    return True\\n                buckets[b] -= nums[idx]\\n                \\n                # Pruning: Buckets are filled from left to right. If any bucket remains empty,\\n                # then all buckets to the right of it will also be empty.\\n                if buckets[b] == 0:\\n                    break\\n            \\n            return False\\n        \\n        return backtrack(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270510,
                "title": "java-simple-solution",
                "content": "\\'\\'\\'\\n class Solution {\\n   public boolean makesquare(int[] matchsticks) {\\n    if (matchsticks.length < 4) return false;\\n    int totalSum = 0;\\n    for (int m : matchsticks)\\n        totalSum += m;\\n    if (totalSum % 4 != 0) return false;\\n    int target = totalSum / 4;\\n    boolean[] used = new boolean[matchsticks.length];\\n    return backtracking(matchsticks, used, target, 0, 0, 0); \\n    }\\n\\nprivate boolean backtracking(int[] matchsticks, boolean[] used, int target, int count, int currSum, int start) {\\n    if (count == 3) return true;\\n    if (currSum > target) return false;\\n    if (currSum == target) return backtracking(matchsticks, used, target, count + 1, 0, 0);\\n    \\n    for (int i = start; i < matchsticks.length; i++) {\\n        if (!used[i]) {\\n            used[i] = true;\\n            if (backtracking(matchsticks, used, target, count, currSum + matchsticks[i], i + 1)) return true;\\n            used[i] = false;\\n        }\\n    }\\n    \\n    return false;\\n}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   public boolean makesquare(int[] matchsticks) {\\n    if (matchsticks.length < 4) return false;\\n    int totalSum = 0;\\n    for (int m : matchsticks)\\n        totalSum += m;\\n    if (totalSum % 4 != 0) return false;\\n    int target = totalSum / 4;\\n    boolean[] used = new boolean[matchsticks.length];\\n    return backtracking(matchsticks, used, target, 0, 0, 0); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2270450,
                "title": "c-code-backtracking-memoization",
                "content": "\\n\\'\\'\\'\\n\\n    int dp[16][32768];\\n    bool solve(vector<int> &ms, int &sum, int curr, int  cnt, int mask)\\n    {\\n        \\n        if(mask == (1<<ms.size())-1)\\n        {\\n            if(cnt==4)\\n               return true;\\n            else\\n               return false;\\n        }\\n        \\n        if(cnt>4)\\n            return false;\\n        \\n        if(dp[cnt][mask]!=-1)\\n            return dp[cnt][mask];\\n        \\n        bool f=false;\\n        for(int i=0;i<ms.size();i++)\\n        {\\n            if((mask & (1<<i))==0)\\n            {\\n                mask = mask ^ (1<<i);\\n                if(curr+ms[i]<sum)\\n                {\\n                    f = f || solve(ms,sum,curr+ms[i],cnt,mask);\\n                }\\n                else if(curr+ms[i]==sum)\\n                {\\n                    f = f || solve(ms,sum,0,cnt+1,mask);\\n                }\\n                mask = mask ^ (1<<i);\\n            }\\n        }\\n        \\n        return dp[cnt][mask]=f;\\n    }\\n\\t\\n    bool makesquare(vector<int>& ms) {\\n        int sum=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<ms.size();i++)\\n        {\\n            sum += ms[i];\\n        }\\n        \\n        if(sum%4!=0)\\n            return false;\\n        sum = sum/4;\\n        int mask=0;\\n        return solve(ms, sum, 0, 0, mask);\\n    }\\n\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "\\n\\'\\'\\'\\n\\n    int dp[16][32768];\\n    bool solve(vector<int> &ms, int &sum, int curr, int  cnt, int mask)\\n    {\\n        \\n        if(mask == (1<<ms.size())-1)\\n        {\\n            if(cnt==4)\\n               return true;\\n            else\\n               return false;\\n        }\\n        \\n        if(cnt>4)\\n            return false;\\n        \\n        if(dp[cnt][mask]!=-1)\\n            return dp[cnt][mask];\\n        \\n        bool f=false;\\n        for(int i=0;i<ms.size();i++)\\n        {\\n            if((mask & (1<<i))==0)\\n            {\\n                mask = mask ^ (1<<i);\\n                if(curr+ms[i]<sum)\\n                {\\n                    f = f || solve(ms,sum,curr+ms[i],cnt,mask);\\n                }\\n                else if(curr+ms[i]==sum)\\n                {\\n                    f = f || solve(ms,sum,0,cnt+1,mask);\\n                }\\n                mask = mask ^ (1<<i);\\n            }\\n        }\\n        \\n        return dp[cnt][mask]=f;\\n    }\\n\\t\\n    bool makesquare(vector<int>& ms) {\\n        int sum=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<ms.size();i++)\\n        {\\n            sum += ms[i];\\n        }\\n        \\n        if(sum%4!=0)\\n            return false;\\n        sum = sum/4;\\n        int mask=0;\\n        return solve(ms, sum, 0, 0, mask);\\n    }\\n\\n\\'\\'\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2270342,
                "title": "matchsticks-to-square-simple-requires-optimization",
                "content": "Requires Optimization.Any help in the comments is appreciated.\\n```\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    \\n    \\n    void dfs(int index,int edge1,int edge2,int edge3,int edge4,vector<int> &matchsticks,int edge)\\n    {\\n        \\n        if(index==matchsticks.size())//traversed to the array end\\n        {\\n            if(edge1==edge2 and edge2==edge3 and edge3==edge4)//Confirmation for a square\\n                flag=true;\\n            return;\\n        }\\n        else\\n        {//dfs along all the edges to finally equal all of them if possible\\n            if(edge1+matchsticks[index]<=edge)\\n            dfs(index+1,edge1+matchsticks[index],edge2,edge3,edge4,matchsticks,edge);\\n            if(edge2+matchsticks[index]<=edge)\\n           dfs(index+1,edge1,edge2+matchsticks[index],edge3,edge4,matchsticks,edge);\\n            if(edge3+matchsticks[index]<=edge)\\n            dfs(index+1,edge1,edge2,edge3+matchsticks[index],edge4,matchsticks,edge);\\n            if(edge4+matchsticks[index]<=edge)\\n           dfs(index+1,edge1,edge2,edge3,edge4+matchsticks[index],matchsticks,edge);\\n        }\\n    }\\n    \\n       \\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum=0;\\n        sum=accumulate(matchsticks.begin(),matchsticks.end(),0);\\n        if(sum%4!=0)//not a multiple of 4\\n            return false;\\n       int edge=sum/4;//Every edge should be the total sum of array/4,the primary condition\\n        dfs(0,0,0,0,0,matchsticks,edge);\\n        return flag;\\n    }  \\n    \\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool flag=false;\\n    \\n    \\n    void dfs(int index,int edge1,int edge2,int edge3,int edge4,vector<int> &matchsticks,int edge)\\n    {\\n        \\n        if(index==matchsticks.size())//traversed to the array end\\n        {\\n            if(edge1==edge2 and edge2==edge3 and edge3==edge4)//Confirmation for a square\\n                flag=true;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2270314,
                "title": "python-dp-bitmask-easy",
                "content": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        S = sum(matchsticks)\\n        \\n        if S % 4 != 0: return False\\n        target = S // 4\\n        \\n        total = (1<<n)-1\\n        \\n        @cache\\n        def check(mask, s):\\n            if mask == total: return s == 0\\n            for i in range(n):\\n                if mask & (1<<i): continue\\n                L = s+matchsticks[i]\\n                if L == target and check(mask | (1<<i), 0):\\n                    return True\\n                if L < target and check(mask | (1<<i), L):\\n                    return True\\n            return False\\n        \\n        return check(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        S = sum(matchsticks)\\n        \\n        if S % 4 != 0: return False\\n        target = S // 4\\n        \\n        total = (1<<n)-1\\n        \\n        @cache\\n        def check(mask, s):\\n            if mask == total: return s == 0\\n            for i in range(n):\\n                if mask & (1<<i): continue\\n                L = s+matchsticks[i]\\n                if L == target and check(mask | (1<<i), 0):\\n                    return True\\n                if L < target and check(mask | (1<<i), L):\\n                    return True\\n            return False\\n        \\n        return check(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082885,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Backtracking***\\n\\n* ***Time Complexity : O(4 ^ N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> sides = {0, 0, 0, 0};\\n    \\n    bool dfs(vector<int>& arr, int i, int n, int target)\\n    {\\n        if(i >= n)\\n        {\\n            return true;\\n        }\\n        \\n        for(int j = 0; j < 4; j++)\\n        {\\n            if(sides[j] + arr[i] <= target)\\n            {\\n                sides[j] += arr[i];\\n                \\n                if(dfs(arr, i + 1, n, target))\\n                {\\n                    return true;\\n                }\\n                \\n                sides[j] -= arr[i];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += arr[i];\\n        }\\n        \\n        if(sum % 4)\\n        {\\n            return false;\\n        }\\n        \\n        int target = sum / 4;\\n        \\n        sort(arr.begin(), arr.end(), greater<int> ());\\n        \\n        return dfs(arr, 0, n, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> sides = {0, 0, 0, 0};\\n    \\n    bool dfs(vector<int>& arr, int i, int n, int target)\\n    {\\n        if(i >= n)\\n        {\\n            return true;\\n        }\\n        \\n        for(int j = 0; j < 4; j++)\\n        {\\n            if(sides[j] + arr[i] <= target)\\n            {\\n                sides[j] += arr[i];\\n                \\n                if(dfs(arr, i + 1, n, target))\\n                {\\n                    return true;\\n                }\\n                \\n                sides[j] -= arr[i];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += arr[i];\\n        }\\n        \\n        if(sum % 4)\\n        {\\n            return false;\\n        }\\n        \\n        int target = sum / 4;\\n        \\n        sort(arr.begin(), arr.end(), greater<int> ());\\n        \\n        return dfs(arr, 0, n, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904858,
                "title": "greedy-does-not-work",
                "content": "There are a number of posts with solution that uses the greedy technique along with backtracking. The idea is sort the matches by length, then pick the longest ones in greedy fashion amongst the remaining matches to form each side continuously, until either 3 sides are formed or as soon as we fail to form one side of the square. \\n\\nTHIS DOES NOT WORK!!!\\n\\nExample from my own code:\\n```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        def backtrack(index, remain):\\n            if remain == 0: return True\\n            if remain < 0 or index == len(matchsticks): return False\\n\\n            # now we try using the current match\\n            curr = matchsticks[index]\\n            matchsticks[index] = 0\\n            if backtrack(index + 1, remain - curr): return True\\n\\n            # we tried using the current match, didn\\'t work; try without\\n            matchsticks[index] = curr\\n            return backtrack(index + 1, remain)\\n\\n        sideSums = sum(matchsticks)\\n        if sideSums % 4 != 0: return False\\n\\n        sideLen = sideSums // 4\\n        matchsticks.sort(reverse=True)\\n        if matchsticks[0] > sideLen: return False\\n\\n        return all(backtrack(0, sideLen) for _ in range(3))\\n```\\n\\nOther examples:\\nhttps://leetcode.com/problems/matchsticks-to-square/discuss/95776/14ms-Java-greedy\\nhttps://leetcode.com/problems/matchsticks-to-square/discuss/95774/Java-DFS-Using-Greedy-Approach\\nhttps://leetcode.com/problems/matchsticks-to-square/discuss/1275357/Java-Fastest-solution-using-greedy-algorithm\\nhttps://leetcode.com/problems/matchsticks-to-square/discuss/1067256/JAVA-100-beat-(-0-ms-)-oror-DFS-%2B-Greedy\\nhttps://leetcode.com/problems/matchsticks-to-square/discuss/1275615/c%2B%2B-solution-with-0ms-or-4ms-kind-of-greedy\\n\\nI have tried and all the solutions above fail the following case after passing 184/185 cases:\\n[13,11,1,8,6,7,8,8,6,7,8,9,8] -> sum = 100, sideLen = 25\\noutput: false\\nexpected: true\\n\\nThe correct way to form matches for this case:\\n[[13, 6, 6], [11, 7, 7], [9, 8, 8], [8, 8, 8, 1]]\\n\\nThe greedy approach however, will try [13, 11, 1] and get stuck from there.\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        def backtrack(index, remain):\\n            if remain == 0: return True\\n            if remain < 0 or index == len(matchsticks): return False\\n\\n            # now we try using the current match\\n            curr = matchsticks[index]\\n            matchsticks[index] = 0\\n            if backtrack(index + 1, remain - curr): return True\\n\\n            # we tried using the current match, didn\\'t work; try without\\n            matchsticks[index] = curr\\n            return backtrack(index + 1, remain)\\n\\n        sideSums = sum(matchsticks)\\n        if sideSums % 4 != 0: return False\\n\\n        sideLen = sideSums // 4\\n        matchsticks.sort(reverse=True)\\n        if matchsticks[0] > sideLen: return False\\n\\n        return all(backtrack(0, sideLen) for _ in range(3))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811712,
                "title": "c-bitmask-dfs-memorization",
                "content": "Refering to solution of https://leetcode.com/problems/partition-to-k-equal-sum-subsets/.\\nI prefer bruteforce first then optimize with momorization, which is more promising during interview. The momerization of this problem basically avoids number of the vector trying every bucket.\\n```\\nclass Solution {\\n    bool helper(int cur, int tar, int cnt, int k, int mask, vector<int>& s, vector<int>& dp)\\n    {\\n        if (cnt == k)\\n            return true;\\n        if (dp[mask] != -1) return dp[mask];\\n        int n = s.size();\\n        bool res = false;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (mask & (1<<i)) continue;\\n            if (cur+s[i] > tar) break;\\n            if (cur+s[i] == tar)\\n            {\\n                mask^=1<<i;\\n                res |= helper(0, tar, cnt+1, k, mask, s, dp);\\n                mask^=1<<i;\\n            }\\n            else\\n            {\\n                mask^=1<<i;\\n                res |= helper(cur+s[i], tar, cnt, k, mask, s, dp);\\n                mask^=1<<i;\\n            }\\n            if (res) break;\\n        }\\n        dp[mask] = res?1:0;\\n        return res;\\n    }\\npublic:\\n    bool makesquare(vector<int>& s) {\\n        int sum = 0, n = s.size();\\n        for (int i:s) sum+=i;\\n        if (sum%4 != 0) return false;\\n        sum/=4;\\n        sort(s.begin(), s.end());\\n        vector<int> dp(1<<n, -1);\\n        return helper(0, sum, 0, 4, 0, s, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    bool helper(int cur, int tar, int cnt, int k, int mask, vector<int>& s, vector<int>& dp)\\n    {\\n        if (cnt == k)\\n            return true;\\n        if (dp[mask] != -1) return dp[mask];\\n        int n = s.size();\\n        bool res = false;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (mask & (1<<i)) continue;\\n            if (cur+s[i] > tar) break;\\n            if (cur+s[i] == tar)\\n            {\\n                mask^=1<<i;\\n                res |= helper(0, tar, cnt+1, k, mask, s, dp);\\n                mask^=1<<i;\\n            }\\n            else\\n            {\\n                mask^=1<<i;\\n                res |= helper(cur+s[i], tar, cnt, k, mask, s, dp);\\n                mask^=1<<i;\\n            }\\n            if (res) break;\\n        }\\n        dp[mask] = res?1:0;\\n        return res;\\n    }\\npublic:\\n    bool makesquare(vector<int>& s) {\\n        int sum = 0, n = s.size();\\n        for (int i:s) sum+=i;\\n        if (sum%4 != 0) return false;\\n        sum/=4;\\n        sort(s.begin(), s.end());\\n        vector<int> dp(1<<n, -1);\\n        return helper(0, sum, 0, 4, 0, s, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807393,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dp(vector<int>&a,int sum1,int sum2,int sum3,int sum4,int idx,int &need)\\n    {\\n        if(sum1>need || sum2>need || sum3>need || sum4>need)\\n        {\\n            return false;\\n        }\\n        if(idx==a.size())\\n        {\\n            if(sum1==sum3 && sum1==sum2 && sum1==sum4)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if(sum1!=need && sum1+a[idx]>need)\\n        {\\n            return false;\\n        }\\n        if(sum2!=need && sum2+a[idx]>need)\\n        {\\n            return false;\\n        }\\n        if(sum3!=need && sum3+a[idx]>need)\\n        {\\n            return false;\\n        }\\n        if(sum4!=need && sum4+a[idx]>need)\\n        {\\n            return false;\\n        }\\n        bool flg=false;\\n        if(sum1<need)\\n        {\\n            flg|=dp(a,sum1+a[idx],sum2,sum3,sum4,idx+1,need);\\n        }\\n        if(flg==true)\\n        {\\n            return true;\\n        }\\n        if(sum2<need)\\n        {\\n            flg|=dp(a,sum1,sum2+a[idx],sum3,sum4,idx+1,need);\\n        }\\n        if(flg==true)\\n        {\\n            return true;\\n        }\\n        if(sum3<need)\\n        {\\n            flg|=dp(a,sum1,sum2,sum3+a[idx],sum4,idx+1,need);\\n        }\\n        if(flg==true)\\n        {\\n            return true;\\n        }\\n        if(sum4<need)\\n        {\\n            flg|=dp(a,sum1,sum2,sum3,sum4+a[idx],idx+1,need);\\n        }\\n        return flg;\\n    }\\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum=0;\\n        sort(matchsticks.begin(),matchsticks.end());\\n        for(int i:matchsticks)\\n        {\\n            sum+=i;\\n        }\\n        if(sum%4!=0)\\n        {\\n            return false;\\n        }\\n        int need=sum/4;\\n        for(int i:matchsticks)\\n        {\\n            if(i>need)\\n            {\\n                return false;\\n            }\\n        }\\n        return dp(matchsticks,0,0,0,0,0,need);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dp(vector<int>&a,int sum1,int sum2,int sum3,int sum4,int idx,int &need)\\n    {\\n        if(sum1>need || sum2>need || sum3>need || sum4>need)\\n        {\\n            return false;\\n        }\\n        if(idx==a.size())\\n        {\\n            if(sum1==sum3 && sum1==sum2 && sum1==sum4)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if(sum1!=need && sum1+a[idx]>need)\\n        {\\n            return false;\\n        }\\n        if(sum2!=need && sum2+a[idx]>need)\\n        {\\n            return false;\\n        }\\n        if(sum3!=need && sum3+a[idx]>need)\\n        {\\n            return false;\\n        }\\n        if(sum4!=need && sum4+a[idx]>need)\\n        {\\n            return false;\\n        }\\n        bool flg=false;\\n        if(sum1<need)\\n        {\\n            flg|=dp(a,sum1+a[idx],sum2,sum3,sum4,idx+1,need);\\n        }\\n        if(flg==true)\\n        {\\n            return true;\\n        }\\n        if(sum2<need)\\n        {\\n            flg|=dp(a,sum1,sum2+a[idx],sum3,sum4,idx+1,need);\\n        }\\n        if(flg==true)\\n        {\\n            return true;\\n        }\\n        if(sum3<need)\\n        {\\n            flg|=dp(a,sum1,sum2,sum3+a[idx],sum4,idx+1,need);\\n        }\\n        if(flg==true)\\n        {\\n            return true;\\n        }\\n        if(sum4<need)\\n        {\\n            flg|=dp(a,sum1,sum2,sum3,sum4+a[idx],idx+1,need);\\n        }\\n        return flg;\\n    }\\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum=0;\\n        sort(matchsticks.begin(),matchsticks.end());\\n        for(int i:matchsticks)\\n        {\\n            sum+=i;\\n        }\\n        if(sum%4!=0)\\n        {\\n            return false;\\n        }\\n        int need=sum/4;\\n        for(int i:matchsticks)\\n        {\\n            if(i>need)\\n            {\\n                return false;\\n            }\\n        }\\n        return dp(matchsticks,0,0,0,0,0,need);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768887,
                "title": "cpp-solution-with-dfs",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool dfs(vector<int> &nums, vector<int> &sizes, int ind, int target){\\n        if(nums.size()==ind){\\n            return (sizes[0]==sizes[1] && sizes[1]==sizes[2] && sizes [2]==sizes[3]);\\n        }\\n        for(int i=0; i<4; i++){\\n            if (sizes[i] + nums[ind] > target) \\n                continue;\\n            int j=i;\\n            while (--j>=0){\\n                if(sizes[j]==sizes[i]) break;\\n            }\\n            if(j!=-1)continue;\\n            sizes[i]+=nums[ind];\\n            if(dfs(nums, sizes, ind+1, target)) return true;\\n            sizes[i]-=nums[ind];\\n            \\n        }\\n        return false;\\n    }\\n    bool makesquare(vector<int>& matchsticks) {\\n        if(matchsticks.size()<4) return false;\\n        vector<int> sizes(4, 0);\\n        int sum = 0;\\n        for (int val: matchsticks) {\\n            sum += val;\\n        }\\n        if ((sum >>1)&1 || sum&1) return false;\\n        int need = sum>>2;\\n        for (int val: matchsticks) {\\n            if(val>need) return false;\\n        }\\n        return dfs(matchsticks, sizes, 0, need);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool dfs(vector<int> &nums, vector<int> &sizes, int ind, int target){\\n        if(nums.size()==ind){\\n            return (sizes[0]==sizes[1] && sizes[1]==sizes[2] && sizes [2]==sizes[3]);\\n        }\\n        for(int i=0; i<4; i++){\\n            if (sizes[i] + nums[ind] > target) \\n                continue;\\n            int j=i;\\n            while (--j>=0){\\n                if(sizes[j]==sizes[i]) break;\\n            }\\n            if(j!=-1)continue;\\n            sizes[i]+=nums[ind];\\n            if(dfs(nums, sizes, ind+1, target)) return true;\\n            sizes[i]-=nums[ind];\\n            \\n        }\\n        return false;\\n    }\\n    bool makesquare(vector<int>& matchsticks) {\\n        if(matchsticks.size()<4) return false;\\n        vector<int> sizes(4, 0);\\n        int sum = 0;\\n        for (int val: matchsticks) {\\n            sum += val;\\n        }\\n        if ((sum >>1)&1 || sum&1) return false;\\n        int need = sum>>2;\\n        for (int val: matchsticks) {\\n            if(val>need) return false;\\n        }\\n        return dfs(matchsticks, sizes, 0, need);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727855,
                "title": "c-using-dp-bitmasking",
                "content": "**Please Upvote if you like the solution!**\\n\\n    class Solution {\\n    public:\\n    bool makesquare(vector<int>& matchsticks) //Using BITMASKING\\n    {\\n        int n=matchsticks.size();\\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum=sum+matchsticks[i];\\n        }\\n        if(n<4 or sum%4 !=0)//when the size of array is less than 4 we are not able to make square and also when the sum is not divisible by 4\\n            return false;\\n        \\n        int target=sum/4;\\n        vector<int> dp((1<<n),-1);//create dp table of size 2^n size\\n        dp[0]=0;//start index\\n        \\n        for(int mask=0;mask<(1<<n);mask++)\\n        {\\n            if(dp[mask]==-1)// Invalid Case\\n                continue;\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                if(!(mask &(1<<j)) && dp[mask]+matchsticks[j]<=target)\\n                {\\n                    dp[mask | (1<<j)]=(dp[mask]+matchsticks[j])%target;\\n                }\\n            }\\n        }\\n        return dp[(1<<n)-1]==0?true:false;\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    bool makesquare(vector<int>& matchsticks) //Using BITMASKING\\n    {\\n        int n=matchsticks.size();\\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum=sum+matchsticks[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1652588,
                "title": "matchsticks-to-square",
                "content": "# ** Backtracking approach**:   \\nBasic idea of solving this problem is-> 1. First find what will be the length of each side of the square .\\n\\n2. As we must  use all of the given sticks , so length of the perimeter will be nothing but sum of all the given integers . So if sum of all integers are not a multiple of 4 , we simply return false .           \\n 3.  Else , if Sum is multiple of 4 , then we have to check can we form 4 parts of the array such that sum of each part is equal to sum/4 ... which is the len of each side of the square .\\n\\n**Intuition** :-> we will maintain a boolean function where we will pass a visited array to check wheather a certain element is already picked or not . we will call recursively if my current index element is not picked and we will land up \"TRUE\" if we follow that particular track and mark that index as visited . If that track returns false we will unmark that index .\\n\\n**Code is written below for better understanding :**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool solve(vector<int>& nums,int curr_ind,int n,int k,int req_sum,int curr_sum,vector<int>& vis){\\n        \\n\\t\\t// base case \\n\\t\\t//  if my curr_ind is greater than sizeof array we can never make any partion due to lack of element\\n\\t\\t// if k==1 -> we need to make only one partition , we can always make a single partion with sum of all elements .\\n\\t\\t\\n\\t\\t\\n        if(k==1)\\n            return true;\\n        \\n        if(curr_ind>=n || k<=0)\\n            return false;\\n        \\n\\t\\t// if we found our required sum then we should call recursively for k-1 ... \\n\\t\\t//  As we need  ( in this problem k is always 4)  k equal partitions after geeting first partion we should check for the rest of k-1 partion .\\n\\t\\t\\n        if(curr_sum==req_sum)\\n            return solve(nums,0,n,k-1,req_sum,0,vis);\\n        \\n        for(int i=curr_ind;i<n;i++){\\n            \\n            if(!vis[i]){\\n                vis[i]=1; // mark that index visited \\n                if(solve(nums,i+1,n,k,req_sum,curr_sum+nums[i],vis)){\\n                    return true;\\n                }\\n                \\n                vis[i]=0; // if prev track not returned as true unmark that index  \\n\\t\\t\\t\\t\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        \\n        int n = matchsticks.size();\\n        \\n        int s=0;\\n        for(int i=0;i<n;i++){\\n            s+=matchsticks[i];\\n        }\\n        \\n        if(s%4!=0)         // we can never form square  here\\n            return false;\\n        \\n        vector<int>vis(20,0);\\n        \\n\\t\\tint curr_ind =0, int req_sum = s/4 ,curr_sum =0;\\n\\t\\t\\n        return solve(matchsticks,curr_ind,n,4,req_sum,curr_sum,vis); \\n    }\\n};\\n```\\n\\n*Time Complexity* -> O(N*2^N) \\nSpace Complexity-> O(N)  \\n\\n\\nSimilar Problems : 1.https://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\n                             2. https://leetcode.com/problems/partition-equal-subset-sum/\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(vector<int>& nums,int curr_ind,int n,int k,int req_sum,int curr_sum,vector<int>& vis){\\n        \\n\\t\\t// base case \\n\\t\\t//  if my curr_ind is greater than sizeof array we can never make any partion due to lack of element\\n\\t\\t// if k==1 -> we need to make only one partition , we can always make a single partion with sum of all elements .\\n\\t\\t\\n\\t\\t\\n        if(k==1)\\n            return true;\\n        \\n        if(curr_ind>=n || k<=0)\\n            return false;\\n        \\n\\t\\t// if we found our required sum then we should call recursively for k-1 ... \\n\\t\\t//  As we need  ( in this problem k is always 4)  k equal partitions after geeting first partion we should check for the rest of k-1 partion .\\n\\t\\t\\n        if(curr_sum==req_sum)\\n            return solve(nums,0,n,k-1,req_sum,0,vis);\\n        \\n        for(int i=curr_ind;i<n;i++){\\n            \\n            if(!vis[i]){\\n                vis[i]=1; // mark that index visited \\n                if(solve(nums,i+1,n,k,req_sum,curr_sum+nums[i],vis)){\\n                    return true;\\n                }\\n                \\n                vis[i]=0; // if prev track not returned as true unmark that index  \\n\\t\\t\\t\\t\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        \\n        int n = matchsticks.size();\\n        \\n        int s=0;\\n        for(int i=0;i<n;i++){\\n            s+=matchsticks[i];\\n        }\\n        \\n        if(s%4!=0)         // we can never form square  here\\n            return false;\\n        \\n        vector<int>vis(20,0);\\n        \\n\\t\\tint curr_ind =0, int req_sum = s/4 ,curr_sum =0;\\n\\t\\t\\n        return solve(matchsticks,curr_ind,n,4,req_sum,curr_sum,vis); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282352,
                "title": "cpp-code-with-comments-backtrack-dfs-partition-to-k-subset-logic",
                "content": "```\\nclass Solution {    \\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n        int len = matchsticks.size();\\n        int p = 0; //perimeter\\n        for(auto match: matchsticks){\\n            p+=match;\\n        }        \\n        if(p%4!=0){\\n            //fast exit\\n            return false;\\n        }\\n        p = p/4;        \\n        for(auto match: matchsticks){\\n            if(match>p){\\n                //fast exit\\n                return false;\\n            }\\n        }\\n        sort(matchsticks.begin(), matchsticks.end(), greater<int>());\\n        //sorting ensures that the dfs trees that begin with biggest integers are pruned quickly.\\n        //also helps for quick exit in case we aren\\'t able to make a group with the biggest value, which often could be the case for a negative test case.\\n        vector<bool>visited(len, false);\\n        return isSquarePossible(0, visited, matchsticks, 4, 0, p);\\n    }\\n    bool isSquarePossible(int idx, vector<bool>visited, vector<int>match, int k, int sumSoFar, int s){\\n        if(k==1){\\n            //reaching here implies that there is one group left, and this one group has to sum to s, since rest of them have added upto 3s\\n            return true;\\n        }\\n        if(sumSoFar==s){\\n            //this means we have obtained one group (set of matchsticks) that sum up to s, so we need to check for remaining groups\\n            return isSquarePossible(0, visited, match, k-1, 0, s);\\n        }\\n        for(int i=idx; i<visited.size(); i++){\\n            if(!visited[i] && sumSoFar+match[i]<=s){\\n                visited[i] = true;\\n                //classic back track 1.mark as true 2.recur 3.mark as false.\\n                if(isSquarePossible(idx+1, visited, match, k, sumSoFar+match[i],s)){\\n\\t\\t\\t\\t\\t//we have obtained all 4 groups that each sum to s, we can exit successfully\\n                    return true;\\n                };\\n                if(i==0){\\n                    //fast exit\\n                    //since we start with the first index, it has to be visited, marking it false implies there are no sets which include element at first index which sum up to the expected target sum.\\n                    return false;\\n                }\\n                visited[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {    \\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n        int len = matchsticks.size();\\n        int p = 0; //perimeter\\n        for(auto match: matchsticks){\\n            p+=match;\\n        }        \\n        if(p%4!=0){\\n            //fast exit\\n            return false;\\n        }\\n        p = p/4;        \\n        for(auto match: matchsticks){\\n            if(match>p){\\n                //fast exit\\n                return false;\\n            }\\n        }\\n        sort(matchsticks.begin(), matchsticks.end(), greater<int>());\\n        //sorting ensures that the dfs trees that begin with biggest integers are pruned quickly.\\n        //also helps for quick exit in case we aren\\'t able to make a group with the biggest value, which often could be the case for a negative test case.\\n        vector<bool>visited(len, false);\\n        return isSquarePossible(0, visited, matchsticks, 4, 0, p);\\n    }\\n    bool isSquarePossible(int idx, vector<bool>visited, vector<int>match, int k, int sumSoFar, int s){\\n        if(k==1){\\n            //reaching here implies that there is one group left, and this one group has to sum to s, since rest of them have added upto 3s\\n            return true;\\n        }\\n        if(sumSoFar==s){\\n            //this means we have obtained one group (set of matchsticks) that sum up to s, so we need to check for remaining groups\\n            return isSquarePossible(0, visited, match, k-1, 0, s);\\n        }\\n        for(int i=idx; i<visited.size(); i++){\\n            if(!visited[i] && sumSoFar+match[i]<=s){\\n                visited[i] = true;\\n                //classic back track 1.mark as true 2.recur 3.mark as false.\\n                if(isSquarePossible(idx+1, visited, match, k, sumSoFar+match[i],s)){\\n\\t\\t\\t\\t\\t//we have obtained all 4 groups that each sum to s, we can exit successfully\\n                    return true;\\n                };\\n                if(i==0){\\n                    //fast exit\\n                    //since we start with the first index, it has to be visited, marking it false implies there are no sets which include element at first index which sum up to the expected target sum.\\n                    return false;\\n                }\\n                visited[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280022,
                "title": "python3-dfs-with-reversed-order-tracking",
                "content": "```\\ndef makesquare(self, matchsticks: List[int]) -> bool:\\n        if sum(matchsticks) % 4 != 0:\\n            return False \\n        \\n        if not matchsticks:\\n            return False \\n        \\n        target = sum(matchsticks) // 4         \\n        visited = [False] * len(matchsticks)\\n        matchsticks = sorted(matchsticks, reverse=True)   # reversed order can trim off the large stick \\n        \\n        def dfs(sticks, i, group_id, curr_sum, tar):\\n            # break conditions \\n            if group_id == 4: # [0,1,2,3] success \\n                return True \\n            if curr_sum > tar:\\n                return False \\n            \\n            if curr_sum == tar:\\n                return dfs(sticks, 0, group_id+1, 0, tar)\\n            \\n            last = -1  # speed up picking the different value \\n            # main logic \\n            for j in range(i, len(sticks)):\\n                if visited[j] is True:\\n                    continue \\n                if (sticks[j] == last):\\n                    continue \\n                visited[j] = True                 \\n                curr_sum += sticks[j]\\n                last = sticks[j]\\n                if dfs(sticks, j+1, group_id, curr_sum, tar):\\n                    return True\\n                curr_sum -= sticks[j]\\n                visited[j] = False \\n                \\n        return dfs(matchsticks, 0, 0, 0, target)\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef makesquare(self, matchsticks: List[int]) -> bool:\\n        if sum(matchsticks) % 4 != 0:\\n            return False \\n        \\n        if not matchsticks:\\n            return False \\n        \\n        target = sum(matchsticks) // 4         \\n        visited = [False] * len(matchsticks)\\n        matchsticks = sorted(matchsticks, reverse=True)   # reversed order can trim off the large stick \\n        \\n        def dfs(sticks, i, group_id, curr_sum, tar):\\n            # break conditions \\n            if group_id == 4: # [0,1,2,3] success \\n                return True \\n            if curr_sum > tar:\\n                return False \\n            \\n            if curr_sum == tar:\\n                return dfs(sticks, 0, group_id+1, 0, tar)\\n            \\n            last = -1  # speed up picking the different value \\n            # main logic \\n            for j in range(i, len(sticks)):\\n                if visited[j] is True:\\n                    continue \\n                if (sticks[j] == last):\\n                    continue \\n                visited[j] = True                 \\n                curr_sum += sticks[j]\\n                last = sticks[j]\\n                if dfs(sticks, j+1, group_id, curr_sum, tar):\\n                    return True\\n                curr_sum -= sticks[j]\\n                visited[j] = False \\n                \\n        return dfs(matchsticks, 0, 0, 0, target)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1276815,
                "title": "python-3-dfs-with-backtracking-explained",
                "content": "```\\nclass Solution:\\n    def makesquare(self, matchsticks) -> bool:\\n        \"\"\"\\n        Given an array of match sticks (matchsticks), this program\\n        uses depth-first search with backtracking to determine\\n        whether they can be arranged into a perfect square.\\n\\n        :param matchsticks: array of matchsticks\\n        :type matchsticks: list[int]\\n        :return: True if matchsticks can be arranged into a\\n                 square, else False\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Base Cases:\\n        - If the sum of the match stick lengths (sum_matchsticks)\\n          is not an even multiple of 4, return False.\\n        - If a match stick length is greater than the side length\\n          of the square (side_length), return False\\n        \"\"\"\\n        sum_matchsticks = sum(matchsticks)\\n        if sum_matchsticks % 4:\\n            return False\\n        side_length = sum_matchsticks // 4\\n        if max(matchsticks) > side_length:\\n            return False\\n\\n        \"\"\"\\n        Initialize:\\n        - Sort matchsticks so that longer match sticks are\\n          allocated to the sides of a square first.\\n        - Initialize the remaining side lengths of the square\\n          (sides) to the side length (side_length).\\n        \"\"\"\\n        matchsticks.sort(reverse=True)\\n        sides = [side_length] * 4\\n\\n        def dfs(sticks, sides) -> bool:\\n            \"\"\"\\n            Given an array of remaining match sticks (sticks)\\n            and the current state of the sides of a square (sides),\\n            this routine uses depth-first search with backtracking\\n            to determine whether the match sticks can be arranged\\n            into a perfect square.\\n\\n            :param sticks: array of match sticks\\n            :type sticks: list[int]\\n            :param sides: remaining side lengths\\n            :type sides: list[int]\\n            :return: True if match sticks can be arranged into\\n                     a square, else False\\n            :rtype: bool\\n            \"\"\"\\n            if not sticks and sum(sides) == 0:\\n                return True\\n            stick = sticks[0]\\n            for k in range(4):\\n                if stick <= sides[k]:\\n                    sides[k] -= stick\\n                    if dfs(sticks[1:], sides):\\n                        return True\\n                    sides[k] += stick\\n\\n                    \"\"\"\\n                    If a match stick was added to an empty side\\n                    (no match sticks), stop here rather than add\\n                    it to another empty side and get the same\\n                    result.\\n                    \"\"\"\\n                    if sides[k] == side_length:\\n                        break\\n            return False\\n\\n        return dfs(matchsticks, sides)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks) -> bool:\\n        \"\"\"\\n        Given an array of match sticks (matchsticks), this program\\n        uses depth-first search with backtracking to determine\\n        whether they can be arranged into a perfect square.\\n\\n        :param matchsticks: array of matchsticks\\n        :type matchsticks: list[int]\\n        :return: True if matchsticks can be arranged into a\\n                 square, else False\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Base Cases:\\n        - If the sum of the match stick lengths (sum_matchsticks)\\n          is not an even multiple of 4, return False.\\n        - If a match stick length is greater than the side length\\n          of the square (side_length), return False\\n        \"\"\"\\n        sum_matchsticks = sum(matchsticks)\\n        if sum_matchsticks % 4:\\n            return False\\n        side_length = sum_matchsticks // 4\\n        if max(matchsticks) > side_length:\\n            return False\\n\\n        \"\"\"\\n        Initialize:\\n        - Sort matchsticks so that longer match sticks are\\n          allocated to the sides of a square first.\\n        - Initialize the remaining side lengths of the square\\n          (sides) to the side length (side_length).\\n        \"\"\"\\n        matchsticks.sort(reverse=True)\\n        sides = [side_length] * 4\\n\\n        def dfs(sticks, sides) -> bool:\\n            \"\"\"\\n            Given an array of remaining match sticks (sticks)\\n            and the current state of the sides of a square (sides),\\n            this routine uses depth-first search with backtracking\\n            to determine whether the match sticks can be arranged\\n            into a perfect square.\\n\\n            :param sticks: array of match sticks\\n            :type sticks: list[int]\\n            :param sides: remaining side lengths\\n            :type sides: list[int]\\n            :return: True if match sticks can be arranged into\\n                     a square, else False\\n            :rtype: bool\\n            \"\"\"\\n            if not sticks and sum(sides) == 0:\\n                return True\\n            stick = sticks[0]\\n            for k in range(4):\\n                if stick <= sides[k]:\\n                    sides[k] -= stick\\n                    if dfs(sticks[1:], sides):\\n                        return True\\n                    sides[k] += stick\\n\\n                    \"\"\"\\n                    If a match stick was added to an empty side\\n                    (no match sticks), stop here rather than add\\n                    it to another empty side and get the same\\n                    result.\\n                    \"\"\"\\n                    if sides[k] == side_length:\\n                        break\\n            return False\\n\\n        return dfs(matchsticks, sides)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275357,
                "title": "java-fastest-solution-using-greedy-algorithm",
                "content": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        int sum = 0;\\n        for (int i : matchsticks)\\n            sum += i;\\n        if (sum % 4 != 0)\\n            return false;\\n        int side = sum / 4;\\n        Arrays.sort(matchsticks);\\n        int len = matchsticks.length;\\n        boolean[] visited = new boolean[len];\\n        if (matchsticks[len - 1] > side)\\n            return false;\\n        \\n        // From longest matchstick to shortest, using greedy algorithm. Do not need to roll back.\\n        // This algorithm works because the granularity of numbers is getting smaller and smaller.\\n        // See, if side == 8, the longest matchstick is 5, and there are two ways to contruct one side:\\n        // 5 + 3 / 5 + 1 + 1 + 1. Because all works a 3 can do can always be substituted by three 1s,\\n        // the greedy algorithm, which always choose to visit the largest possible number works.\\n        \\n        for (int i = len - 1; i >= 0; i--) {\\n            if (!visited[i]) {\\n                visited[i] = true;\\n                if (!dfs(matchsticks, visited, i - 1, side - matchsticks[i]))\\n                    return false;\\n            }   \\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int[] matchsticks, boolean[] visited, int i, int sum) {\\n        if (sum <= 0)\\n            return sum == 0;\\n        while (i >= 0) {\\n            if (!visited[i]) {\\n                visited[i] = true;\\n                if (dfs(matchsticks, visited, i - 1, sum - matchsticks[i]))\\n                    return true;\\n                visited[i] = false;\\n            }\\n            i--;   \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        int sum = 0;\\n        for (int i : matchsticks)\\n            sum += i;\\n        if (sum % 4 != 0)\\n            return false;\\n        int side = sum / 4;\\n        Arrays.sort(matchsticks);\\n        int len = matchsticks.length;\\n        boolean[] visited = new boolean[len];\\n        if (matchsticks[len - 1] > side)\\n            return false;\\n        \\n        // From longest matchstick to shortest, using greedy algorithm. Do not need to roll back.\\n        // This algorithm works because the granularity of numbers is getting smaller and smaller.\\n        // See, if side == 8, the longest matchstick is 5, and there are two ways to contruct one side:\\n        // 5 + 3 / 5 + 1 + 1 + 1. Because all works a 3 can do can always be substituted by three 1s,\\n        // the greedy algorithm, which always choose to visit the largest possible number works.\\n        \\n        for (int i = len - 1; i >= 0; i--) {\\n            if (!visited[i]) {\\n                visited[i] = true;\\n                if (!dfs(matchsticks, visited, i - 1, side - matchsticks[i]))\\n                    return false;\\n            }   \\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int[] matchsticks, boolean[] visited, int i, int sum) {\\n        if (sum <= 0)\\n            return sum == 0;\\n        while (i >= 0) {\\n            if (!visited[i]) {\\n                visited[i] = true;\\n                if (dfs(matchsticks, visited, i - 1, sum - matchsticks[i]))\\n                    return true;\\n                visited[i] = false;\\n            }\\n            i--;   \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275234,
                "title": "c-backtracking-dfs-solution-explained-25-time-50-space",
                "content": "The core idea is to tackle this problem as a permutation problem, that is to say a graph, with specific conditions.\\n\\nTo do so, we start with a few class variables:\\n* `used` is an array of 15 boolean elements, all set to false;\\n* `side`, `part` and `len` are a few integer variables we will set in the main function and handle in the recursive calls;\\n*  `res` is a boolean variable storing partial results, as we go.\\n\\nIn our main function we will also declare:\\n* `sum`, to store the sum of our inputs, initially set to `0`.\\n\\nSorting the given input in decreasing order will avoid us to avoid \"wasting\" the precious smaller bits when not needed, instead using them only later to \"complete\" the sums of bigger matches.\\n\\nIn a first loop, we will then take the sum all the matches lengths and compute `side` as one fourth of `sum`, while also giving a proper value to `len`.\\n\\nWe will then check if said sum is divisible by `4` (using `& 3`, which is way cheaper, since a number divisible by `4` as `00` as last significant bits) and if the biggest element is bigger than `side`, returning `false` in either case.\\n\\nWe will then loop 3 times and:\\n* (re)set `res` to `false` and `part` to `0`;\\n* call `dfs` passing `matchsticks`;\\n* `break` if `res` is still `false` after the previous call.\\n\\n`dfs` is the core of our logic. It will just take our initial input vector and:\\n* if `part >= side`, meaning we should not proceed summing elements and:\\n\\t* set `res` to be `part == side` to mark if we found a perfect match;\\n\\t* `return` to leave the function;\\n* loop with `i` from `0` to `len` (excluded) and:\\n\\t* `continue` if we already used the element in position `i` before;\\n\\t* flag `used[i]` to be `true` and increase `part` by `matchsticks[i]`;\\n\\t* call recursively `dfs`;\\n\\t* `break` if we found a valid result - so that `used` will keep track of what we used before not to reuse it;\\n\\t* backtrack on `used`and `part` otherwise.\\n\\nWe can now finally `return` `res`: if we have 3 successful loops above, it will be `true`; `false` otherwise :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    bool used[15] = {};\\n    int side, part, len;\\n    bool res;\\n    void dfs(vector<int>& matchsticks) {\\n        // exit case: we have a potential full size\\n        if (part >= side) {\\n            res = part == side;\\n            return;\\n        }\\n        // general case\\n        for (int i = 0; i < len; i++) {\\n            // ignoring already used matches\\n            if (used[i]) continue;\\n            // flagging that match as used\\n            used[i] = true, part += matchsticks[i];\\n            // recursive calls\\n            dfs(matchsticks);\\n            // stopping when a match was found\\n            if (res) break;\\n            // backtracking, but only if we did not find a match so far\\n            used[i] = false, part -= matchsticks[i];\\n        }\\n    }\\npublic:\\n    bool makesquare(vector<int> &matchsticks) {\\n        // support variables\\n        int sum = 0;\\n        // sorting it in decresing order\\n        sort(begin(matchsticks), end(matchsticks), [](int a, int b){return b < a;});\\n        // parsing the provided matches range\\n        for (int m: matchsticks) {\\n            sum += m;\\n        }\\n        side = sum / 4, len = matchsticks.size();\\n        // returning false if the sum is not divisible by 4 or if one match is too big\\n        if ((sum & 3) || matchsticks[0] > side) return false;\\n        // trying to find 3 full sides\\n        for (int i = 0; i < 3; i++) {\\n            res = false;\\n            part = 0;\\n            dfs(matchsticks);\\n            if (!res) break;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, wait a moment... 15 elements, tops? Okay, we can use bitmasks here - basically the same performance, but cooler \\uD83D\\uDE0E :\\n\\n```cpp\\nclass Solution {\\n    int used = 0;\\n    int side, part, len;\\n    bool res;\\n    void dfs(vector<int>& matchsticks) {\\n        // exit case: we have a potential full size\\n        if (part >= side) {\\n            res = part == side;\\n            return;\\n        }\\n        // general case\\n        for (int i = 0, bit; i < len; i++) {\\n            bit = 1 << i;\\n            // ignoring already used matches\\n            if (used & bit) continue;\\n            // flagging that match as used\\n            used |= bit, part += matchsticks[i];\\n            // recursive calls\\n            dfs(matchsticks);\\n            // stopping when a match was found\\n            if (res) break;\\n            // backtracking, but only if we did not find a match so far\\n            used ^= bit, part -= matchsticks[i];\\n        }\\n    }\\npublic:\\n    bool makesquare(vector<int> &matchsticks) {\\n        // support variables\\n        int sum = 0, maxM = 0;\\n        // sorting it in decresing order\\n        sort(begin(matchsticks), end(matchsticks), [](int a, int b){return b < a;});\\n        // parsing the provided matches range\\n        for (int m: matchsticks) {\\n            maxM = max(maxM, m);\\n            sum += m;\\n        }\\n        side = sum / 4, len = matchsticks.size();\\n        // returning false if the sum is not divisible by 4 or if one match is too big\\n        if ((sum & 3) || maxM > side) return false;\\n        // trying to find 3 full sides\\n        for (int i = 0; i < 3; i++) {\\n            res = false;\\n            part = 0;\\n            dfs(matchsticks);\\n            if (!res) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\n    bool used[15] = {};\\n    int side, part, len;\\n    bool res;\\n    void dfs(vector<int>& matchsticks) {\\n        // exit case: we have a potential full size\\n        if (part >= side) {\\n            res = part == side;\\n            return;\\n        }\\n        // general case\\n        for (int i = 0; i < len; i++) {\\n            // ignoring already used matches\\n            if (used[i]) continue;\\n            // flagging that match as used\\n            used[i] = true, part += matchsticks[i];\\n            // recursive calls\\n            dfs(matchsticks);\\n            // stopping when a match was found\\n            if (res) break;\\n            // backtracking, but only if we did not find a match so far\\n            used[i] = false, part -= matchsticks[i];\\n        }\\n    }\\npublic:\\n    bool makesquare(vector<int> &matchsticks) {\\n        // support variables\\n        int sum = 0;\\n        // sorting it in decresing order\\n        sort(begin(matchsticks), end(matchsticks), [](int a, int b){return b < a;});\\n        // parsing the provided matches range\\n        for (int m: matchsticks) {\\n            sum += m;\\n        }\\n        side = sum / 4, len = matchsticks.size();\\n        // returning false if the sum is not divisible by 4 or if one match is too big\\n        if ((sum & 3) || matchsticks[0] > side) return false;\\n        // trying to find 3 full sides\\n        for (int i = 0; i < 3; i++) {\\n            res = false;\\n            part = 0;\\n            dfs(matchsticks);\\n            if (!res) break;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int used = 0;\\n    int side, part, len;\\n    bool res;\\n    void dfs(vector<int>& matchsticks) {\\n        // exit case: we have a potential full size\\n        if (part >= side) {\\n            res = part == side;\\n            return;\\n        }\\n        // general case\\n        for (int i = 0, bit; i < len; i++) {\\n            bit = 1 << i;\\n            // ignoring already used matches\\n            if (used & bit) continue;\\n            // flagging that match as used\\n            used |= bit, part += matchsticks[i];\\n            // recursive calls\\n            dfs(matchsticks);\\n            // stopping when a match was found\\n            if (res) break;\\n            // backtracking, but only if we did not find a match so far\\n            used ^= bit, part -= matchsticks[i];\\n        }\\n    }\\npublic:\\n    bool makesquare(vector<int> &matchsticks) {\\n        // support variables\\n        int sum = 0, maxM = 0;\\n        // sorting it in decresing order\\n        sort(begin(matchsticks), end(matchsticks), [](int a, int b){return b < a;});\\n        // parsing the provided matches range\\n        for (int m: matchsticks) {\\n            maxM = max(maxM, m);\\n            sum += m;\\n        }\\n        side = sum / 4, len = matchsticks.size();\\n        // returning false if the sum is not divisible by 4 or if one match is too big\\n        if ((sum & 3) || maxM > side) return false;\\n        // trying to find 3 full sides\\n        for (int i = 0; i < 3; i++) {\\n            res = false;\\n            part = 0;\\n            dfs(matchsticks);\\n            if (!res) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273800,
                "title": "clean-efficient-depth-first-search-solution-in-python",
                "content": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        #base case\\n        if not matchsticks:\\n            return False\\n        \\n        if sum(matchsticks) % 4:\\n            return False\\n        side = int((sum(matchsticks)/4))\\n        res = set()\\n        self.searchMatchStick(0, matchsticks, [[],0], res, side)\\n        return len(res) == len(matchsticks)\\n\\n    def searchMatchStick(self, i, matchsticks, path, res, side):\\n        if len(res) == len(matchsticks):\\n            return\\n        \\n        if path[1] == side:\\n            res.update(path[0])\\n            return\\n        \\n        if path[1] > side:\\n            return\\n        \\n        for x in range(i, len(matchsticks)):\\n            if len(res)==len(matchsticks):\\n                break\\n                \\n            self.searchMatchStick(x+1, matchsticks, [path[0]+[x],path[1]+matchsticks[x]], res, side)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        #base case\\n        if not matchsticks:\\n            return False\\n        \\n        if sum(matchsticks) % 4:\\n            return False\\n        side = int((sum(matchsticks)/4))\\n        res = set()\\n        self.searchMatchStick(0, matchsticks, [[],0], res, side)\\n        return len(res) == len(matchsticks)\\n\\n    def searchMatchStick(self, i, matchsticks, path, res, side):\\n        if len(res) == len(matchsticks):\\n            return\\n        \\n        if path[1] == side:\\n            res.update(path[0])\\n            return\\n        \\n        if path[1] > side:\\n            return\\n        \\n        for x in range(i, len(matchsticks)):\\n            if len(res)==len(matchsticks):\\n                break\\n                \\n            self.searchMatchStick(x+1, matchsticks, [path[0]+[x],path[1]+matchsticks[x]], res, side)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234994,
                "title": "c-backtracking-beats-93-15",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(int index, vector<int> &nums, bitset<32> &visited, int target){     \\n      if(target == 0){\\n        return true;\\n      }\\n      for(int i = index; i < (int)nums.size(); i++){\\n        if(!visited[i] and target - nums[i] >= 0){\\n             visited[i] = 1;\\n          if(solve(i, nums, visited, target - nums[i]))\\n              return true;\\n          visited[i] = 0;\\n        }\\n      }\\n    return false;\\n    }\\n\\n    bool makesquare(vector<int> &nums){\\n      int n = nums.size(), sum = 0;\\n      for(auto x : nums){\\n        sum += x;\\n      }\\n      if(sum % 4 != 0){\\n        return false;\\n      }\\n      bitset<32>visited;\\n      for(int i = 0; i < 32; i++){\\n          visited[i] = 0;\\n      }\\n      sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i = 0; i < 3; i++){\\n            if(!solve(0, nums, visited, sum / 4))\\n                return false;\\n        }            \\n     return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int index, vector<int> &nums, bitset<32> &visited, int target){     \\n      if(target == 0){\\n        return true;\\n      }\\n      for(int i = index; i < (int)nums.size(); i++){\\n        if(!visited[i] and target - nums[i] >= 0){\\n             visited[i] = 1;\\n          if(solve(i, nums, visited, target - nums[i]))\\n              return true;\\n          visited[i] = 0;\\n        }\\n      }\\n    return false;\\n    }\\n\\n    bool makesquare(vector<int> &nums){\\n      int n = nums.size(), sum = 0;\\n      for(auto x : nums){\\n        sum += x;\\n      }\\n      if(sum % 4 != 0){\\n        return false;\\n      }\\n      bitset<32>visited;\\n      for(int i = 0; i < 32; i++){\\n          visited[i] = 0;\\n      }\\n      sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i = 0; i < 3; i++){\\n            if(!solve(0, nums, visited, sum / 4))\\n                return false;\\n        }            \\n     return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114433,
                "title": "c-dfs-theoretically-o-n-n-but-just-16ms",
                "content": "```\\nclass Solution {\\n    bool dfs(vector<int>& nums, vector<int>& sums, vector<bool>& vis, int cur, int edge){\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > sums[cur]) return false;\\n            if(vis[i]) continue;\\n            vis[i] = true;\\n            sums[cur] -= nums[i];\\n            if(sums[cur] == 0){\\n                if(cur == 3) return true;\\n                else cur++;\\n            }\\n            if(dfs(nums, sums, vis, cur, edge)) return true;\\n            sums[cur] += nums[i];\\n            vis[i] = false;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        int sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(), sum, plus<int>());\\n        if(sum % 4 || !sum) return false;\\n        int edge = sum/4;\\n        vector<int> sums(4, edge);\\n        vector<bool> vis(nums.size(), false);\\n        sort(nums.rbegin(), nums.rend());\\n        return dfs(nums, sums, vis, 0, edge);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool dfs(vector<int>& nums, vector<int>& sums, vector<bool>& vis, int cur, int edge){\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > sums[cur]) return false;\\n            if(vis[i]) continue;\\n            vis[i] = true;\\n            sums[cur] -= nums[i];\\n            if(sums[cur] == 0){\\n                if(cur == 3) return true;\\n                else cur++;\\n            }\\n            if(dfs(nums, sums, vis, cur, edge)) return true;\\n            sums[cur] += nums[i];\\n            vis[i] = false;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        int sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(), sum, plus<int>());\\n        if(sum % 4 || !sum) return false;\\n        int edge = sum/4;\\n        vector<int> sums(4, edge);\\n        vector<bool> vis(nums.size(), false);\\n        sort(nums.rbegin(), nums.rend());\\n        return dfs(nums, sums, vis, 0, edge);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059146,
                "title": "c-dfs-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int> &nums,int index,int side,int s1,int s2,int s3,int s4)\\n    {\\n        if(index==nums.size())\\n            return s1==side && s2==side && s3==side;\\n        if(s1+nums[index]<=side && dfs(nums,index+1,side,s1+nums[index],s2,s3,s4))\\n            return true;\\n        if(s2+nums[index]<=side && s2!=s1 && dfs(nums,index+1,side,s1,s2+nums[index],s3,s4))\\n            return true;\\n        if(s3+nums[index]<=side && s3!=s2 && s3!=s1 && dfs(nums,index+1,side,s1,s2,s3+nums[index],s4))\\n            return true;\\n        if(s4+nums[index]<=side && s4!=s3 && s4!=s2 && s4!=s1 && dfs(nums,index+1,side,s1,s2,s3,s4+nums[index]))\\n            return true;\\n        return false;\\n    }\\n    bool makesquare(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<4) return false;\\n        int perimeter=accumulate(nums.begin(),nums.end(),0);\\n        int side=perimeter/4;\\n        if(side*4!=perimeter) return false;\\n        sort(nums.rbegin(),nums.rend());\\n        return dfs(nums,0,side,0,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int> &nums,int index,int side,int s1,int s2,int s3,int s4)\\n    {\\n        if(index==nums.size())\\n            return s1==side && s2==side && s3==side;\\n        if(s1+nums[index]<=side && dfs(nums,index+1,side,s1+nums[index],s2,s3,s4))\\n            return true;\\n        if(s2+nums[index]<=side && s2!=s1 && dfs(nums,index+1,side,s1,s2+nums[index],s3,s4))\\n            return true;\\n        if(s3+nums[index]<=side && s3!=s2 && s3!=s1 && dfs(nums,index+1,side,s1,s2,s3+nums[index],s4))\\n            return true;\\n        if(s4+nums[index]<=side && s4!=s3 && s4!=s2 && s4!=s1 && dfs(nums,index+1,side,s1,s2,s3,s4+nums[index]))\\n            return true;\\n        return false;\\n    }\\n    bool makesquare(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<4) return false;\\n        int perimeter=accumulate(nums.begin(),nums.end(),0);\\n        int side=perimeter/4;\\n        if(side*4!=perimeter) return false;\\n        sort(nums.rbegin(),nums.rend());\\n        return dfs(nums,0,side,0,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011616,
                "title": "python3-dfs",
                "content": "```\\nclass Solution:\\n    def makesquare(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n        used = [0]*len(nums)\\n        t = sum(nums)\\n        if t%4 != 0:\\n            return False\\n        def dfs(k,s,cs,arr,visited,start):\\n            if k == 1:\\n                return True\\n            if cs == s:\\n                return dfs(k-1,s,0,arr,visited,0)\\n            for i in range(start,len(arr)):\\n                if not visited[i] and cs+arr[i]<=s:\\n                    visited[i] = 1 \\n                    if dfs(k,s,cs+arr[i],arr,visited,i+1):\\n                        return True\\n                    visited[i]=0\\n            return False\\n        return dfs(4,t//4,0,nums,used,0)\\n```\\n\\nthis question is the similar to [Partition to K Equal Sum Subsets](http://https://leetcode.com/problems/partition-to-k-equal-sum-subsets/) but the constraints here differ slightly.\\n\\n1)the sum of the array of matchsticks should be a multiple of 4\\n2)In respect to Partition to K Equal Sum Subsets here k=4 \\n\\n[This is a good explanation i found on medium](https://medium.com/trick-the-interviwer/partition-to-k-equal-sum-subsets-ebf49c7ae2fc)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makesquare(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n        used = [0]*len(nums)\\n        t = sum(nums)\\n        if t%4 != 0:\\n            return False\\n        def dfs(k,s,cs,arr,visited,start):\\n            if k == 1:\\n                return True\\n            if cs == s:\\n                return dfs(k-1,s,0,arr,visited,0)\\n            for i in range(start,len(arr)):\\n                if not visited[i] and cs+arr[i]<=s:\\n                    visited[i] = 1 \\n                    if dfs(k,s,cs+arr[i],arr,visited,i+1):\\n                        return True\\n                    visited[i]=0\\n            return False\\n        return dfs(4,t//4,0,nums,used,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822641,
                "title": "c-dfs-solution",
                "content": "```\\npublic class Solution {\\n    public bool Makesquare(int[] nums) {\\n        if(nums == null || nums.Length == 0)\\n            return false;\\n        \\n        var perimeter = 0;\\n        \\n        foreach(var num in nums)\\n            perimeter += num;\\n        \\n        var side = perimeter/4;\\n        \\n        if(side*4 != perimeter)\\n            return false;\\n        \\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        var sum = new int[4];\\n        \\n        return Dfs(0, side, sum, nums);\\n    }\\n    \\n    private bool Dfs(int index, int side, int[] sum, int[] nums)\\n    {\\n        if(index == nums.Length)\\n        {\\n            return sum[0] == sum[1] && sum[1] == sum[2] && sum[2] == sum[3];\\n        }\\n        \\n        var element = nums[index];\\n        for(var i = 0; i < 4; i++)\\n        {\\n            if(sum[i] + element <= side)\\n            {\\n                sum[i] += element;\\n            \\n                if(Dfs(index+1, side, sum, nums))\\n                    return true;\\n\\n                sum[i] -=element;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public bool Makesquare(int[] nums) {\\n        if(nums == null || nums.Length == 0)\\n            return false;\\n        \\n        var perimeter = 0;\\n        \\n        foreach(var num in nums)\\n            perimeter += num;\\n        \\n        var side = perimeter/4;\\n        \\n        if(side*4 != perimeter)\\n            return false;\\n        \\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        var sum = new int[4];\\n        \\n        return Dfs(0, side, sum, nums);\\n    }\\n    \\n    private bool Dfs(int index, int side, int[] sum, int[] nums)\\n    {\\n        if(index == nums.Length)\\n        {\\n            return sum[0] == sum[1] && sum[1] == sum[2] && sum[2] == sum[3];\\n        }\\n        \\n        var element = nums[index];\\n        for(var i = 0; i < 4; i++)\\n        {\\n            if(sum[i] + element <= side)\\n            {\\n                sum[i] += element;\\n            \\n                if(Dfs(index+1, side, sum, nums))\\n                    return true;\\n\\n                sum[i] -=element;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755558,
                "title": "java-sort-and-dfs-beat-100",
                "content": "Sort will lead early quit, which makes it beat 100%\\n\\n```\\nclass Solution {\\n    boolean[] vs;\\n    int m = 0, sum = 0, max = 0, e = 0;\\n    public boolean makesquare(int[] nums) {\\n        m = nums.length;\\n        if (m < 4) return false;\\n        for (int n : nums) {\\n            sum += n;\\n            max = Math.max(max, n);\\n        }\\n        if (sum % 4 != 0 || max > sum / 4) return false;\\n        Arrays.sort(nums);\\n        e = sum / 4;\\n        vs = new boolean[m];\\n        vs[0] = true;\\n        return dfs(nums, 1, nums[0], 4);\\n    }\\n    \\n    private boolean dfs(int[] nums, int idx, int tot, int cnt) {\\n        if (tot == e) {\\n            if (--cnt == 1) return true;\\n            for (int i = 0; i < m; i++) {\\n                if (vs[i]) continue;\\n                vs[i] = true;\\n                boolean res = dfs(nums, i + 1, nums[i], cnt);\\n                vs[i] = false;\\n                return res;\\n            }\\n        }\\n        for (int i = idx; i < m; i++) {\\n            if (vs[i]) continue;\\n            if (nums[i] + tot > e) return false;\\n            vs[i] = true;\\n            if (dfs(nums, i + 1, tot + nums[i], cnt)) return true;\\n            vs[i] = false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean[] vs;\\n    int m = 0, sum = 0, max = 0, e = 0;\\n    public boolean makesquare(int[] nums) {\\n        m = nums.length;\\n        if (m < 4) return false;\\n        for (int n : nums) {\\n            sum += n;\\n            max = Math.max(max, n);\\n        }\\n        if (sum % 4 != 0 || max > sum / 4) return false;\\n        Arrays.sort(nums);\\n        e = sum / 4;\\n        vs = new boolean[m];\\n        vs[0] = true;\\n        return dfs(nums, 1, nums[0], 4);\\n    }\\n    \\n    private boolean dfs(int[] nums, int idx, int tot, int cnt) {\\n        if (tot == e) {\\n            if (--cnt == 1) return true;\\n            for (int i = 0; i < m; i++) {\\n                if (vs[i]) continue;\\n                vs[i] = true;\\n                boolean res = dfs(nums, i + 1, nums[i], cnt);\\n                vs[i] = false;\\n                return res;\\n            }\\n        }\\n        for (int i = idx; i < m; i++) {\\n            if (vs[i]) continue;\\n            if (nums[i] + tot > e) return false;\\n            vs[i] = true;\\n            if (dfs(nums, i + 1, tot + nums[i], cnt)) return true;\\n            vs[i] = false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741662,
                "title": "c-code-using-recursion-similar-to-partitioning-into-k-subset-of-equal-sum-here-k-4",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(int start, vector<int> &nums, vector<bool> &visit, int k, long long sum, long long target){\\n        if(k==1)\\n            return true;\\n        if(sum>target)\\n            return false;\\n        if(sum==target)\\n            return dfs(0,nums,visit,k-1,0,target);\\n        for(int i=start;i<nums.size();i++){\\n            if(visit[i]==false){\\n                visit[i]=true;\\n                if(dfs(i+1,nums,visit,k,sum+nums[i],target))\\n                    return true;\\n                visit[i]=false;\\n            }\\n        }\\n        return false;\\n    }\\n    bool makesquare(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==0)\\n            return false;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        if(sum%4!=0)\\n            return false;\\n        vector<bool> visit(n+1,false);\\n        return dfs(0,nums,visit,4,0,sum/4);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int start, vector<int> &nums, vector<bool> &visit, int k, long long sum, long long target){\\n        if(k==1)\\n            return true;\\n        if(sum>target)\\n            return false;\\n        if(sum==target)\\n            return dfs(0,nums,visit,k-1,0,target);\\n        for(int i=start;i<nums.size();i++){\\n            if(visit[i]==false){\\n                visit[i]=true;\\n                if(dfs(i+1,nums,visit,k,sum+nums[i],target))\\n                    return true;\\n                visit[i]=false;\\n            }\\n        }\\n        return false;\\n    }\\n    bool makesquare(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==0)\\n            return false;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        if(sum%4!=0)\\n            return false;\\n        vector<bool> visit(n+1,false);\\n        return dfs(0,nums,visit,4,0,sum/4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456731,
                "title": "javascript-solution-68-ms",
                "content": "This is almost 100% copy of ```698. Partition to K Equal Sum Subsets``` (```4``` should be replaced with ```k```)\\n```\\nvar makesquare = function(nums) {\\n    var sum = nums.reduce((a, b) => a + b, 0);\\n    if (sum === 0 || sum % 4 !== 0) {\\n        return false;\\n    }\\n    \\n    var seen = new Array(nums.length);\\n    var canPartition = function(start, blocks, sum, target) {\\n        if (blocks === 1) {\\n            return true;\\n        }\\n        \\n        if (sum === target) {\\n            return canPartition(0, blocks - 1, 0, target);\\n        } else if (sum > target) {\\n            return false;\\n        }\\n        \\n        for (var i = start; i < nums.length; i++) {\\n            if (!seen[i]) {\\n                seen[i] = true;\\n                if (canPartition(i + 1, blocks, sum + nums[i], target)) {\\n                    return true;\\n                }\\n                seen[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n            \\n    return canPartition(0, 4, 0, sum / 4);\\n};\\n```",
                "solutionTags": [],
                "code": "```698. Partition to K Equal Sum Subsets```\n```4```\n```k```\n```\\nvar makesquare = function(nums) {\\n    var sum = nums.reduce((a, b) => a + b, 0);\\n    if (sum === 0 || sum % 4 !== 0) {\\n        return false;\\n    }\\n    \\n    var seen = new Array(nums.length);\\n    var canPartition = function(start, blocks, sum, target) {\\n        if (blocks === 1) {\\n            return true;\\n        }\\n        \\n        if (sum === target) {\\n            return canPartition(0, blocks - 1, 0, target);\\n        } else if (sum > target) {\\n            return false;\\n        }\\n        \\n        for (var i = start; i < nums.length; i++) {\\n            if (!seen[i]) {\\n                seen[i] = true;\\n                if (canPartition(i + 1, blocks, sum + nums[i], target)) {\\n                    return true;\\n                }\\n                seen[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n            \\n    return canPartition(0, 4, 0, sum / 4);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 411251,
                "title": "c-dfs-and-backtracking",
                "content": "```\\nbool makesquare(vector<int>& nums) {\\n        int sum = 0;\\n        for(auto i : nums) sum += i;\\n        if(sum % 4 != 0 || sum == 0) return false;\\n        vector<int> used(nums.size(),0);\\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n        if(!dfs(nums, 0, sum/4, used)) return false;\\n        if(!dfs(nums, 0, sum/4, used)) return false;\\n        if(!dfs(nums, 0, sum/4, used)) return false;\\n        return true;\\n        \\n    }\\n    bool dfs(vector<int> &nums, int i, int target, vector<int> &used) {\\n        if(i >= nums.size()) return false;\\n        if(used[i]==1) return dfs(nums,i+1,target,used);\\n        if(target == nums[i]) {\\n            used[i] = 1;\\n            return true;\\n        } else if(target > nums[i]) {\\n            used[i] = 1;\\n            if(dfs(nums, i+1, target-nums[i], used)) return true;\\n            used[i] = 0;\\n        }\\n        return dfs(nums, i+1, target, used);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool makesquare(vector<int>& nums) {\\n        int sum = 0;\\n        for(auto i : nums) sum += i;\\n        if(sum % 4 != 0 || sum == 0) return false;\\n        vector<int> used(nums.size(),0);\\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n        if(!dfs(nums, 0, sum/4, used)) return false;\\n        if(!dfs(nums, 0, sum/4, used)) return false;\\n        if(!dfs(nums, 0, sum/4, used)) return false;\\n        return true;\\n        \\n    }\\n    bool dfs(vector<int> &nums, int i, int target, vector<int> &used) {\\n        if(i >= nums.size()) return false;\\n        if(used[i]==1) return dfs(nums,i+1,target,used);\\n        if(target == nums[i]) {\\n            used[i] = 1;\\n            return true;\\n        } else if(target > nums[i]) {\\n            used[i] = 1;\\n            if(dfs(nums, i+1, target-nums[i], used)) return true;\\n            used[i] = 0;\\n        }\\n        return dfs(nums, i+1, target, used);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135569,
                "title": "my-solution-is-wrong-but-accepted-and-beats-97",
                "content": "The idea is just try to find whether thses numbers can add up to 1*target, 2*target, 3*target and 4*target separately. Since 4*target==sum(nums), so we do not need to test anymore. We only test the first 3 cases. For input like  [1,1,99,99,50,70,80], target = sum(nums)/4 =100, then 100 can be added by 1+99, 200 can be added by 50+70+80, 300 can be added by 1+99+50+70+80. My program will return true, but this should be False, since that 200 cannot be separated into two 100s. \\n\\nFor the max(nums), assume it is x, we specially test whether x>target and whether (target-x) can be added up by remaining numbers. That\\'s why it passes all the tests. But for the above example I give myself, it is wrong!\\n\\n```\\nclass Solution(object):\\n    # Solution 1: DFS with memory\\n    def findTargetLength(self, d, memory, target):\\n        if target==0:\\n            return True\\n        \\n        for x in d.keys():\\n            if target>=x and (x, target-x) not in memory:\\n                d[x]-=1\\n                if d[x]==0:\\n                    del d[x]\\n                \\n                # now we visit target-x, if it leads to true, then we directly return; else we never go back\\n                memory[(x, target-x)]=1  \\n                if self.findTargetLength(d, memory, target-x):\\n                    return True\\n                \\n                # if that route fails to find, then recover x back to d, try another\\n                d[x]=d.get(x, 0)+1\\n                # if we arrive here, then we have already visited target-x but not get true\\n        \\n        return False\\n        \\n    \\n    def makesquare(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)<4:\\n            return False\\n        \\n        # firstly, sum(nums)%4==0, otherwise, you always have extra matchsticks\\n        sam=sum(nums)\\n        if sam%4!=0:\\n            return False\\n        \\n        # then sum/4 is the target_length for each side, we need to use all matchsticks to add up to 4 target_length.\\n        target_length=sam/4\\n        large=max(nums)\\n        if large>target_length:\\n            return False\\n        \\n        d={}\\n        for x in nums:\\n            d[x]=d.get(x, 0)+1\\n        \\n        if not self.findTargetLength(d, {}, target_length-large):\\n            return False\\n        \\n        out=True\\n        # since all numbers sum up to 4*target_length, we only test for 1,2,3\\n        for i in xrange(3):\\n            d={}    # d is a dict that have the count for each number, each time when we find target, d is updated\\n            for x in nums:\\n                d[x]=d.get(x, 0)+1\\n            \\n            out=out and self.findTargetLength(d, {}, target_length*(i+1))\\n                \\n        return out\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    # Solution 1: DFS with memory\\n    def findTargetLength(self, d, memory, target):\\n        if target==0:\\n            return True\\n        \\n        for x in d.keys():\\n            if target>=x and (x, target-x) not in memory:\\n                d[x]-=1\\n                if d[x]==0:\\n                    del d[x]\\n                \\n                # now we visit target-x, if it leads to true, then we directly return; else we never go back\\n                memory[(x, target-x)]=1  \\n                if self.findTargetLength(d, memory, target-x):\\n                    return True\\n                \\n                # if that route fails to find, then recover x back to d, try another\\n                d[x]=d.get(x, 0)+1\\n                # if we arrive here, then we have already visited target-x but not get true\\n        \\n        return False\\n        \\n    \\n    def makesquare(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)<4:\\n            return False\\n        \\n        # firstly, sum(nums)%4==0, otherwise, you always have extra matchsticks\\n        sam=sum(nums)\\n        if sam%4!=0:\\n            return False\\n        \\n        # then sum/4 is the target_length for each side, we need to use all matchsticks to add up to 4 target_length.\\n        target_length=sam/4\\n        large=max(nums)\\n        if large>target_length:\\n            return False\\n        \\n        d={}\\n        for x in nums:\\n            d[x]=d.get(x, 0)+1\\n        \\n        if not self.findTargetLength(d, {}, target_length-large):\\n            return False\\n        \\n        out=True\\n        # since all numbers sum up to 4*target_length, we only test for 1,2,3\\n        for i in xrange(3):\\n            d={}    # d is a dict that have the count for each number, each time when we find target, d is updated\\n            for x in nums:\\n                d[x]=d.get(x, 0)+1\\n            \\n            out=out and self.findTargetLength(d, {}, target_length*(i+1))\\n                \\n        return out\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 95757,
                "title": "why-tle-if-not-sorted",
                "content": "```\\nclass Solution(object):\\n    def makesquare(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        totalLen, N = sum(nums), len(nums)\\n        if totalLen%4!=0 or totalLen==0 or N<=3: return False\\n        \\n        lens, L = [0, 0, 0, 0], totalLen//4\\n        nums.sort(reverse=True)\\n        def DFS(lens, ind):\\n            #if ind==N and all( map(lambda x: x==L, lens) ):\\n            if ind==N and lens[0]==L and lens[1]==L and lens[2]==L and lens[3]==L:\\n                return True\\n                \\n            for i in range(0, 4):\\n                if nums[ind]+lens[i] <= L:\\n                    lens[i] += nums[ind]\\n                    if DFS(lens, ind+1): return True\\n                    lens[i] -= nums[ind]\\n                    \\n            return False\\n            \\n        return DFS(lens, 0)\\n```\\nIf ```nums.sort(reverse=True)``` removed or changed to ```nums.sort()```, it will TLE. Why?",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def makesquare(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        totalLen, N = sum(nums), len(nums)\\n        if totalLen%4!=0 or totalLen==0 or N<=3: return False\\n        \\n        lens, L = [0, 0, 0, 0], totalLen//4\\n        nums.sort(reverse=True)\\n        def DFS(lens, ind):\\n            #if ind==N and all( map(lambda x: x==L, lens) ):\\n            if ind==N and lens[0]==L and lens[1]==L and lens[2]==L and lens[3]==L:\\n                return True\\n                \\n            for i in range(0, 4):\\n                if nums[ind]+lens[i] <= L:\\n                    lens[i] += nums[ind]\\n                    if DFS(lens, ind+1): return True\\n                    lens[i] -= nums[ind]\\n                    \\n            return False\\n            \\n        return DFS(lens, 0)\\n```\n```nums.sort(reverse=True)```\n```nums.sort()```",
                "codeTag": "Java"
            },
            {
                "id": 95756,
                "title": "python-dfs",
                "content": "    class Solution(object):\\n        def makesquare(self, nums):\\n            if not nums:\\n                return False\\n            sumn = sum(nums)\\n            nums.sort(reverse=True)\\n            if sumn % 4:\\n                return False\\n            return self.dfs(nums, [0,0,0,0], 0, sumn/4)\\n        \\n        def dfs(self, nums, t, pos, target):\\n            if pos == len(nums):\\n                if t[0] == t[1] == t[2]:\\n                    return True\\n                return False\\n            for i in range(4):\\n                if t[i] + nums[pos] > target:\\n                    continue\\n                t[i] += nums[pos]\\n                if self.dfs(nums, t, pos+1, target):\\n                    return True\\n                t[i] -= nums[pos]\\n            return False",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def makesquare(self, nums):\\n            if not nums:\\n                return False\\n            sumn = sum(nums)\\n            nums.sort(reverse=True)\\n            if sumn % 4:\\n                return False\\n            return self.dfs(nums, [0,0,0,0], 0, sumn/4)\\n        \\n        def dfs(self, nums, t, pos, target):\\n            if pos == len(nums):\\n                if t[0] == t[1] == t[2]:\\n                    return True\\n                return False\\n            for i in range(4):\\n                if t[i] + nums[pos] > target:\\n                    continue\\n                t[i] += nums[pos]\\n                if self.dfs(nums, t, pos+1, target):\\n                    return True\\n                t[i] -= nums[pos]\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 95765,
                "title": "simple-golang-solution-using-dfs-with-explanation",
                "content": "Based off of solution from pooja_kanchan@hotmail.com, I translated this to Golang. Basic DFS where we start with each side at 0. Then we iterate through the nums array and try to see if they can add up to s1. If its less than or adds up perfectly to the side length, then we add that side and go into another recursion to check the next index of the array. We try s1 again... if it doesnt fit, we go on next to s2, s3, and s4. If it doesnt fit at all, we return false, which will go all the way back to the original makesquare function as false.\\n\\n```\\nfunc makesquare(nums []int) bool {\\n    if len(nums) < 4 { return false }\\n    sum:= 0\\n    for i:=0; i < len(nums); i++ {\\n        sum+=nums[i]\\n    }\\n    if(sum%4 != 0) {return false}\\n    return findCombo(sum, 0, 0, 0, 0, 0, nums)\\n}\\n\\nfunc findCombo(sum int, s1 int, s2 int, s3 int, s4 int, ind int, nums []int) bool {\\n    if ind == len(nums) {\\n        if s1 == s2 && s2 == s3 && s3 == s4 {return true}\\n        return false\\n    }    \\n    if nums[ind] + s1 <= sum/4 {\\n        if findCombo(sum, s1+nums[ind], s2, s3, s4, ind+1, nums) == true {\\n            return true\\n        }\\n    }\\n    if nums[ind] + s2 <= sum/4 {\\n        if findCombo(sum, s1, s2 + nums[ind], s3, s4, ind+1, nums) == true {\\n            return true\\n        }\\n    }\\n    if nums[ind] + s3 <= sum/4 {\\n        if findCombo(sum, s1, s2, s3 + nums[ind], s4, ind+1, nums) == true {\\n            return true\\n        }\\n    }\\n    if nums[ind] + s4 <= sum/4 {\\n        if findCombo(sum, s1, s2, s3, s4+nums[ind], ind+1, nums) == true {\\n            return true\\n        }\\n    }\\n    return false\\n    \\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc makesquare(nums []int) bool {\\n    if len(nums) < 4 { return false }\\n    sum:= 0\\n    for i:=0; i < len(nums); i++ {\\n        sum+=nums[i]\\n    }\\n    if(sum%4 != 0) {return false}\\n    return findCombo(sum, 0, 0, 0, 0, 0, nums)\\n}\\n\\nfunc findCombo(sum int, s1 int, s2 int, s3 int, s4 int, ind int, nums []int) bool {\\n    if ind == len(nums) {\\n        if s1 == s2 && s2 == s3 && s3 == s4 {return true}\\n        return false\\n    }    \\n    if nums[ind] + s1 <= sum/4 {\\n        if findCombo(sum, s1+nums[ind], s2, s3, s4, ind+1, nums) == true {\\n            return true\\n        }\\n    }\\n    if nums[ind] + s2 <= sum/4 {\\n        if findCombo(sum, s1, s2 + nums[ind], s3, s4, ind+1, nums) == true {\\n            return true\\n        }\\n    }\\n    if nums[ind] + s3 <= sum/4 {\\n        if findCombo(sum, s1, s2, s3 + nums[ind], s4, ind+1, nums) == true {\\n            return true\\n        }\\n    }\\n    if nums[ind] + s4 <= sum/4 {\\n        if findCombo(sum, s1, s2, s3, s4+nums[ind], ind+1, nums) == true {\\n            return true\\n        }\\n    }\\n    return false\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702626,
                "title": "one-line-in-backtracking-changed-from-2020ms-to-50ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makesquare(int[] m) {\\n        int n=m.length;\\n        if(n<4)return false;\\n        int sum=0;\\n        for(int i:m)sum+=i;\\n        if(sum%4!=0)return false;\\n        sum/=4;\\n        Arrays.sort(m);\\n        reverse(m,n);\\n        return backtrack(new int[4],m,0,n,sum);\\n    }\\n    private boolean backtrack(int[] arr,int[] m,int idx,int n,int target) {\\n        if(idx==n){\\n            return arr[0]==target && arr[1]==target && arr[2]==target && arr[3]==target;\\n        }\\n        for(int i=0;i<4;i++){\\n            if(arr[i]>target)return false;\\n            arr[i]+=m[idx];\\n            if(backtrack(arr,m,idx+1,n,target))return true;\\n            arr[i]-=m[idx];\\n            if(arr[i]==0)break;// reduces the efficiency from 2020ms to 50ms\\n        }\\n        return false;\\n    }\\n    public void reverse(int[] arr,int n){\\n        for(int i=0;i<n/2;i++)\\n        {\\n            int temp=arr[i];\\n            arr[i]=arr[n-i-1];\\n            arr[n-i-1]=temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] m) {\\n        int n=m.length;\\n        if(n<4)return false;\\n        int sum=0;\\n        for(int i:m)sum+=i;\\n        if(sum%4!=0)return false;\\n        sum/=4;\\n        Arrays.sort(m);\\n        reverse(m,n);\\n        return backtrack(new int[4],m,0,n,sum);\\n    }\\n    private boolean backtrack(int[] arr,int[] m,int idx,int n,int target) {\\n        if(idx==n){\\n            return arr[0]==target && arr[1]==target && arr[2]==target && arr[3]==target;\\n        }\\n        for(int i=0;i<4;i++){\\n            if(arr[i]>target)return false;\\n            arr[i]+=m[idx];\\n            if(backtrack(arr,m,idx+1,n,target))return true;\\n            arr[i]-=m[idx];\\n            if(arr[i]==0)break;// reduces the efficiency from 2020ms to 50ms\\n        }\\n        return false;\\n    }\\n    public void reverse(int[] arr,int n){\\n        for(int i=0;i<n/2;i++)\\n        {\\n            int temp=arr[i];\\n            arr[i]=arr[n-i-1];\\n            arr[n-i-1]=temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594572,
                "title": "c-sort-then-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>& matchsticks, int v[], int k, int target) {\\n        if (k == matchsticks.size()) return true;\\n        for (int i = 0; i < 4; ++ i) {\\n            if (v[i] + matchsticks[k] <= target) {\\n                v[i] += matchsticks[k];\\n                if (helper(matchsticks, v, k + 1, target)) return true;\\n                v[i] -= matchsticks[k]; \\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool makesquare(vector<int>& matchsticks) {\\n        sort(matchsticks.rbegin(), matchsticks.rend());\\n        int v[4] = {0, 0, 0, 0};\\n        int sum = 0;\\n        for (int l : matchsticks) sum += l;\\n        if (sum % 4 != 0) return false;  \\n        return helper(matchsticks, v, 0, sum / 4);\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>& matchsticks, int v[], int k, int target) {\\n        if (k == matchsticks.size()) return true;\\n        for (int i = 0; i < 4; ++ i) {\\n            if (v[i] + matchsticks[k] <= target) {\\n                v[i] += matchsticks[k];\\n                if (helper(matchsticks, v, k + 1, target)) return true;\\n                v[i] -= matchsticks[k]; \\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool makesquare(vector<int>& matchsticks) {\\n        sort(matchsticks.rbegin(), matchsticks.rend());\\n        int v[4] = {0, 0, 0, 0};\\n        int sum = 0;\\n        for (int l : matchsticks) sum += l;\\n        if (sum % 4 != 0) return false;  \\n        return helper(matchsticks, v, 0, sum / 4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574227,
                "title": "c-implementation-recursion-dp-idea",
                "content": "```\\nclass Solution {\\npublic:\\n    int totsum = 0;\\n    map<string, bool> mp;\\n    \\n    string encode(int a, int b, int c, int d)\\n    {\\n        vector<int> vec = {a, b, c, d};\\n        sort(vec.begin(), vec.end());\\n        string ans = \"\";\\n        for(auto i:vec)\\n        {\\n            ans += to_string(i);   \\n        }\\n        return ans;\\n    }\\n    bool func(int ind, int s1, int s2, int s3, int s4, vector<int>& matchsticks)\\n    {\\n        if(ind==matchsticks.size())\\n        {\\n            if(s1==s2 && s2==s3 && s3==s4)\\n            {\\n                return true;\\n            }else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        if(s1>totsum/4 || s2>totsum/4 || s3>totsum/4 || s4>totsum/4 )\\n        {\\n            return false;\\n        }\\n        \\n        string str = encode(s1, s2, s3, s4);\\n        if(mp.find(str)!=mp.end())\\n        {\\n            return mp[str];\\n        }\\n        \\n        \\n        return mp[str] = \\n            func(ind+1, s1+matchsticks[ind], s2, s3, s4, matchsticks) ||\\n            func(ind+1, s1, s2+matchsticks[ind], s3, s4, matchsticks) ||\\n            func(ind+1, s1, s2, s3+matchsticks[ind], s4, matchsticks) ||\\n            func(ind+1, s1, s2, s3, s4+matchsticks[ind], matchsticks);\\n    }\\n    bool makesquare(vector<int>& matchsticks) {\\n        sort(matchsticks.rbegin(), matchsticks.rend());\\n        for(auto i:matchsticks)\\n        {\\n            totsum+=i;\\n        }\\n        return func(0, 0, 0, 0, 0, matchsticks);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totsum = 0;\\n    map<string, bool> mp;\\n    \\n    string encode(int a, int b, int c, int d)\\n    {\\n        vector<int> vec = {a, b, c, d};\\n        sort(vec.begin(), vec.end());\\n        string ans = \"\";\\n        for(auto i:vec)\\n        {\\n            ans += to_string(i);   \\n        }\\n        return ans;\\n    }\\n    bool func(int ind, int s1, int s2, int s3, int s4, vector<int>& matchsticks)\\n    {\\n        if(ind==matchsticks.size())\\n        {\\n            if(s1==s2 && s2==s3 && s3==s4)\\n            {\\n                return true;\\n            }else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        if(s1>totsum/4 || s2>totsum/4 || s3>totsum/4 || s4>totsum/4 )\\n        {\\n            return false;\\n        }\\n        \\n        string str = encode(s1, s2, s3, s4);\\n        if(mp.find(str)!=mp.end())\\n        {\\n            return mp[str];\\n        }\\n        \\n        \\n        return mp[str] = \\n            func(ind+1, s1+matchsticks[ind], s2, s3, s4, matchsticks) ||\\n            func(ind+1, s1, s2+matchsticks[ind], s3, s4, matchsticks) ||\\n            func(ind+1, s1, s2, s3+matchsticks[ind], s4, matchsticks) ||\\n            func(ind+1, s1, s2, s3, s4+matchsticks[ind], matchsticks);\\n    }\\n    bool makesquare(vector<int>& matchsticks) {\\n        sort(matchsticks.rbegin(), matchsticks.rend());\\n        for(auto i:matchsticks)\\n        {\\n            totsum+=i;\\n        }\\n        return func(0, 0, 0, 0, 0, matchsticks);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433709,
                "title": "c-backtracking-simple",
                "content": "```\\nclass Solution {\\n    bool solve(vector<int>& m, int ind, vector<int> &sidelength, int target){\\n        if(ind == m.size()){\\n            return true; \\n        }\\n        for(int i=0; i<4; i++){\\n            if(sidelength[i]+m[ind]<= target){\\n                sidelength[i]+=m[ind];\\n                if(solve(m , ind+1, sidelength, target)) return true;\\n                sidelength[i]-=m[ind];\\n            }\\n        }                       \\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& m) {\\n        int sum=0;\\n        for(int i=0; i<m.size(); i++){\\n            sum+=m[i];\\n        }\\n        if(m.size()<4 || sum%4)return false;\\n        \\n        sort(m.begin(), m.end(), greater());\\n        vector<int> sidelength(4,0);\\n        if(solve(m , 0, sidelength, sum/4) == true) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(vector<int>& m, int ind, vector<int> &sidelength, int target){\\n        if(ind == m.size()){\\n            return true; \\n        }\\n        for(int i=0; i<4; i++){\\n            if(sidelength[i]+m[ind]<= target){\\n                sidelength[i]+=m[ind];\\n                if(solve(m , ind+1, sidelength, target)) return true;\\n                sidelength[i]-=m[ind];\\n            }\\n        }                       \\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& m) {\\n        int sum=0;\\n        for(int i=0; i<m.size(); i++){\\n            sum+=m[i];\\n        }\\n        if(m.size()<4 || sum%4)return false;\\n        \\n        sort(m.begin(), m.end(), greater());\\n        vector<int> sidelength(4,0);\\n        if(solve(m , 0, sidelength, sum/4) == true) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368362,
                "title": "python-using-backtracking-faster-than-99",
                "content": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        target,m=divmod(sum(matchsticks),4)\\n        if m:return False\\n        targetLst=[0]*4\\n        length=len(matchsticks)\\n        matchsticks.sort(reverse=True)\\n        def bt(i):\\n            if i==length:\\n                return len(set(targetLst))==1\\n            for j in range(4):\\n                if matchsticks[i]+targetLst[j]>target:\\n                    continue\\n                targetLst[j]+=matchsticks[i]\\n                if bt(i+1):\\n                    return True\\n                targetLst[j]-=matchsticks[i]\\n                if not targetLst[j]:break\\n            return False\\n        return matchsticks[0]<=target and bt(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        target,m=divmod(sum(matchsticks),4)\\n        if m:return False\\n        targetLst=[0]*4\\n        length=len(matchsticks)\\n        matchsticks.sort(reverse=True)\\n        def bt(i):\\n            if i==length:\\n                return len(set(targetLst))==1\\n            for j in range(4):\\n                if matchsticks[i]+targetLst[j]>target:\\n                    continue\\n                targetLst[j]+=matchsticks[i]\\n                if bt(i+1):\\n                    return True\\n                targetLst[j]-=matchsticks[i]\\n                if not targetLst[j]:break\\n            return False\\n        return matchsticks[0]<=target and bt(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282372,
                "title": "backtracking-java-solution-no-need-to-reverse-sort-40-3mb-147ms",
                "content": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        int p = 0;//perimeter;\\n        for(int i: matchsticks){\\n            p+=i;\\n        }\\n        if(p%4!=0) return false;\\n        int side = p/4;\\n        \\n        Arrays.sort(matchsticks);\\n        \\n        int[] sq = new int[4];\\n        \\n        int l = matchsticks.length;\\n        \\n        return backtrack(matchsticks, l-1, sq, side);\\n    }\\n    private static boolean backtrack(int[] sticks, int ind, int[] sq, int side){\\n        if(ind==-1) return true;\\n        for(int i=0; i<4; i++){\\n            if(sq[i]+sticks[ind]<=side){\\n                sq[i]+=sticks[ind];\\n                if(backtrack(sticks, ind-1, sq, side)) return true;\\n                sq[i]-=sticks[ind];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] matchsticks) {\\n        int p = 0;//perimeter;\\n        for(int i: matchsticks){\\n            p+=i;\\n        }\\n        if(p%4!=0) return false;\\n        int side = p/4;\\n        \\n        Arrays.sort(matchsticks);\\n        \\n        int[] sq = new int[4];\\n        \\n        int l = matchsticks.length;\\n        \\n        return backtrack(matchsticks, l-1, sq, side);\\n    }\\n    private static boolean backtrack(int[] sticks, int ind, int[] sq, int side){\\n        if(ind==-1) return true;\\n        for(int i=0; i<4; i++){\\n            if(sq[i]+sticks[ind]<=side){\\n                sq[i]+=sticks[ind];\\n                if(backtrack(sticks, ind-1, sq, side)) return true;\\n                sq[i]-=sticks[ind];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279195,
                "title": "c-short-dp-o-n-2-n-space-o-2-n",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum = accumulate(matchsticks.begin(), matchsticks.end(), 0);\\n        if (sum % 4) return false;\\n\\t\\t\\n        auto n = size(matchsticks); auto side = sum / 4; auto dp = vector<int>(1<<n, -1); dp[0] = 0;\\n        for(int i = 0; i < (1<<n); i++) {\\n            if (dp[i] == -1) continue;\\n            for(int j = 0; j < n; j++)\\n                if ( !(i & (1<<j)) && dp[i] + matchsticks[j] <= side)\\n                    dp[i | (1<<j)] = (dp[i] + matchsticks[j]) % side;\\n        }\\n        return dp.back() == 0;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum = accumulate(matchsticks.begin(), matchsticks.end(), 0);\\n        if (sum % 4) return false;\\n\\t\\t\\n        auto n = size(matchsticks); auto side = sum / 4; auto dp = vector<int>(1<<n, -1); dp[0] = 0;\\n        for(int i = 0; i < (1<<n); i++) {\\n            if (dp[i] == -1) continue;\\n            for(int j = 0; j < n; j++)\\n                if ( !(i & (1<<j)) && dp[i] + matchsticks[j] <= side)\\n                    dp[i | (1<<j)] = (dp[i] + matchsticks[j]) % side;\\n        }\\n        return dp.back() == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277965,
                "title": "no-backtracking-needed-recursive-solution",
                "content": "```\\nclass Solution {\\n    \\n    bool solve(vector<int> &m, int &s, int i, int a, int b, int c, int d)\\n    {\\n        if(i==m.size()-1) return (a==b && b==c && c==s);\\n        if(i>=m.size() || a>s || b>s || c>s || d>s) return false;\\n        return solve(m,s,i+1,a+m[i],b,c,d) | solve(m,s,i+1,a,b+m[i],c,d) | solve(m,s,i+1,a,b,c+m[i],d) | solve(m,s,i+1,a,b,c,d+m[i]);\\n    }\\n    \\npublic:\\n    bool makesquare(vector<int>& m) {\\n        \\n        int s = accumulate(m.begin(),m.end(),0);\\n        if(s%4!=0) return false;\\n        int side = s/4;\\n        sort(m.rbegin(),m.rend());\\n        return solve(m,side,0,0,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool solve(vector<int> &m, int &s, int i, int a, int b, int c, int d)\\n    {\\n        if(i==m.size()-1) return (a==b && b==c && c==s);\\n        if(i>=m.size() || a>s || b>s || c>s || d>s) return false;\\n        return solve(m,s,i+1,a+m[i],b,c,d) | solve(m,s,i+1,a,b+m[i],c,d) | solve(m,s,i+1,a,b,c+m[i],d) | solve(m,s,i+1,a,b,c,d+m[i]);\\n    }\\n    \\npublic:\\n    bool makesquare(vector<int>& m) {\\n        \\n        int s = accumulate(m.begin(),m.end(),0);\\n        if(s%4!=0) return false;\\n        int side = s/4;\\n        sort(m.rbegin(),m.rend());\\n        return solve(m,side,0,0,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277742,
                "title": "c-simple-backtracking",
                "content": "```\\n    bool solveRec(int ind,vector<int>&arr,vector<int>&sides){\\n        if(ind==-1 && sides[0]==0 && sides[1]==0 && sides[2]==0 && sides[3]==0) return true;\\n                   \\n        if(ind==-1) return false;\\n        \\n        for(int i=0;i<4;i++){\\n             if(sides[i]-arr[ind]>=0){\\n                sides[i]-=arr[ind];\\n                if(solveRec(ind-1,arr,sides)) return true;\\n                sides[i]+=arr[ind];\\n            }\\n        }   \\n        return false;\\n    }\\n\\n    bool makesquare(vector<int>& arr) {\\n        int n=arr.size();\\n        int sum=0;\\n        for(auto it:arr) sum+=it;\\n        if(sum%4!=0) return false;\\n\\t\\t\\n        sort(arr.begin(),arr.end());\\n        vector<int>sides(4,sum/4);\\n        return solveRec(n-1,arr,sides);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n    bool solveRec(int ind,vector<int>&arr,vector<int>&sides){\\n        if(ind==-1 && sides[0]==0 && sides[1]==0 && sides[2]==0 && sides[3]==0) return true;\\n                   \\n        if(ind==-1) return false;\\n        \\n        for(int i=0;i<4;i++){\\n             if(sides[i]-arr[ind]>=0){\\n                sides[i]-=arr[ind];\\n                if(solveRec(ind-1,arr,sides)) return true;\\n                sides[i]+=arr[ind];\\n            }\\n        }   \\n        return false;\\n    }\\n\\n    bool makesquare(vector<int>& arr) {\\n        int n=arr.size();\\n        int sum=0;\\n        for(auto it:arr) sum+=it;\\n        if(sum%4!=0) return false;\\n\\t\\t\\n        sort(arr.begin(),arr.end());\\n        vector<int>sides(4,sum/4);\\n        return solveRec(n-1,arr,sides);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273920,
                "title": "a-very-easy-and-understandable-code-javascript-backtracking",
                "content": "```\\n\\nvar makesquare = function(matchsticks) {\\n    var sum=0 \\n    for(var x of matchsticks)\\n        sum+=x\\n    if(matchsticks.length < 4 || sum%4 != 0)\\n        return false\\n    \\n    matchsticks.sort((a, b) => b - a);\\n    \\n    var sides = new Array(4).fill(0);\\n    \\n    return solve(0);\\n    \\n    function solve(x) {\\n        if(x == matchsticks.length) \\n            return sides[0] == sides[1] && sides[1]==sides[2] && sides[2] == sides[3]\\n        \\n        for(let i = 0; i < 4; i++) {\\n            if(sides[i] + matchsticks[x]> sum/4) \\n                continue\\n            sides[i] += matchsticks[x];\\n            if(solve(x + 1))\\n                return true;\\n            sides[i] -= matchsticks[x];\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n\\nvar makesquare = function(matchsticks) {\\n    var sum=0 \\n    for(var x of matchsticks)\\n        sum+=x\\n    if(matchsticks.length < 4 || sum%4 != 0)\\n        return false\\n    \\n    matchsticks.sort((a, b) => b - a);\\n    \\n    var sides = new Array(4).fill(0);\\n    \\n    return solve(0);\\n    \\n    function solve(x) {\\n        if(x == matchsticks.length) \\n            return sides[0] == sides[1] && sides[1]==sides[2] && sides[2] == sides[3]\\n        \\n        for(let i = 0; i < 4; i++) {\\n            if(sides[i] + matchsticks[x]> sum/4) \\n                continue\\n            sides[i] += matchsticks[x];\\n            if(solve(x + 1))\\n                return true;\\n            sides[i] -= matchsticks[x];\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273895,
                "title": "python-recursion-with-memoization",
                "content": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        if n < 4:\\n            return False\\n\\n        memo = {}\\n        \\n        groups = [0] * 4\\n        circumference = sum(matchsticks)\\n        group_sum = circumference // 4\\n        \\n        # Optimization\\n        if circumference % 4 != 0:\\n            return False\\n        \\n        # To optimize recursion, take the longest stick first\\n        matchsticks.sort(reverse=True)\\n        \\n        return self.helper(0, n, matchsticks, groups, group_sum, memo)\\n    \\n    def helper(self, index, n, matchsticks, groups, group_sum, memo):\\n        if index == n and groups[0] == groups[1] and groups[1] == groups[2] and groups[2] == groups[3]:\\n            return True\\n        \\n        if (index, groups[0], groups[1], groups[2], groups[3]) in memo:\\n            return memo[(index, groups[0], groups[1], groups[2], groups[3])]\\n        \\n        answer = False\\n        for group_index in range(4):\\n            # Assign current matchstick to current group\\n            next_group_sum = groups[group_index] + matchsticks[index]\\n            if next_group_sum > group_sum:\\n                continue\\n            groups[group_index] = next_group_sum\\n            \\n            # Recursively call next step\\n            has_square_found = self.helper(index + 1, n, matchsticks, groups, group_sum, memo)\\n            \\n            # Reassign/Backtrack current matchstick from the recent group\\n            groups[group_index] -= matchsticks[index]\\n            \\n            # Early termination, no need to continue if we\\'ve already found the answer True\\n            if has_square_found:\\n                answer = True\\n                break\\n            \\n        memo[(index, groups[0], groups[1], groups[2], groups[3])] = answer\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n = len(matchsticks)\\n        if n < 4:\\n            return False\\n\\n        memo = {}\\n        \\n        groups = [0] * 4\\n        circumference = sum(matchsticks)\\n        group_sum = circumference // 4\\n        \\n        # Optimization\\n        if circumference % 4 != 0:\\n            return False\\n        \\n        # To optimize recursion, take the longest stick first\\n        matchsticks.sort(reverse=True)\\n        \\n        return self.helper(0, n, matchsticks, groups, group_sum, memo)\\n    \\n    def helper(self, index, n, matchsticks, groups, group_sum, memo):\\n        if index == n and groups[0] == groups[1] and groups[1] == groups[2] and groups[2] == groups[3]:\\n            return True\\n        \\n        if (index, groups[0], groups[1], groups[2], groups[3]) in memo:\\n            return memo[(index, groups[0], groups[1], groups[2], groups[3])]\\n        \\n        answer = False\\n        for group_index in range(4):\\n            # Assign current matchstick to current group\\n            next_group_sum = groups[group_index] + matchsticks[index]\\n            if next_group_sum > group_sum:\\n                continue\\n            groups[group_index] = next_group_sum\\n            \\n            # Recursively call next step\\n            has_square_found = self.helper(index + 1, n, matchsticks, groups, group_sum, memo)\\n            \\n            # Reassign/Backtrack current matchstick from the recent group\\n            groups[group_index] -= matchsticks[index]\\n            \\n            # Early termination, no need to continue if we\\'ve already found the answer True\\n            if has_square_found:\\n                answer = True\\n                break\\n            \\n        memo[(index, groups[0], groups[1], groups[2], groups[3])] = answer\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273723,
                "title": "ditto-same-question-partition-to-k-equal-sum-subsets",
                "content": "I just used the first hint and I concluded that if we can partition this array into 4 parts such that their sum is equal and total Sum is divisible by 4, then it becomes exactly the same problem -> **Partition to K Equal Sum Subsets** , where K = 4.\\nYou can refer to that problem for much more understanding [https://leetcode.com/problems/partition-to-k-equal-sum-subsets/](http://)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool f(int ind, int tar, int curSum, int k, vector<int> &arr, vector<int> &vis){\\n        if(k==1) return true;\\n        \\n        if(ind >= arr.size()) return false;\\n        \\n        if(tar == curSum) return f(0, tar, 0, k-1, arr, vis);\\n        \\n        for(int i=ind; i<arr.size(); i++){\\n            if(vis[i] || curSum + arr[i] > tar) continue;\\n            \\n            vis[i] = 1;\\n            if(f(i+1, tar, curSum + arr[i], k, arr, vis)) return true;\\n            vis[i] = 0;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        int n = matchsticks.size();\\n        int totSum = accumulate(matchsticks.begin(), matchsticks.end(), 0);\\n        if(totSum %4 != 0) return false;\\n        int tar = totSum/4;\\n        vector<int> vis(n, 0);\\n        return f(0, tar, 0, 4, matchsticks, vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool f(int ind, int tar, int curSum, int k, vector<int> &arr, vector<int> &vis){\\n        if(k==1) return true;\\n        \\n        if(ind >= arr.size()) return false;\\n        \\n        if(tar == curSum) return f(0, tar, 0, k-1, arr, vis);\\n        \\n        for(int i=ind; i<arr.size(); i++){\\n            if(vis[i] || curSum + arr[i] > tar) continue;\\n            \\n            vis[i] = 1;\\n            if(f(i+1, tar, curSum + arr[i], k, arr, vis)) return true;\\n            vis[i] = 0;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        int n = matchsticks.size();\\n        int totSum = accumulate(matchsticks.begin(), matchsticks.end(), 0);\\n        if(totSum %4 != 0) return false;\\n        int tar = totSum/4;\\n        vector<int> vis(n, 0);\\n        return f(0, tar, 0, 4, matchsticks, vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273636,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        sizeOfSquare = sum(matchsticks)\\n        eachSide = sizeOfSquare / 4\\n        if int(eachSide) != eachSide:\\n            # This means it cannot create a square\\n            return False\\n        \\n        if max(matchsticks) > eachSide:\\n            # This means the longest stick is too long\\n            return False\\n        \\n        self.found=False\\n        # Reframe the question: Can you create 4 groups of size eachSide\\n        matchsticks.sort(reverse=True)\\n        def test(valuesLeft, l=0, r=0, u=0, d=0):\\n            \\n            if self.found:\\n                return\\n            # print(l, r, u, d)\\n            if l > eachSide or r > eachSide or u > eachSide or d > eachSide:\\n                # print(\"return\")\\n                return\\n            \\n            if l + r + u + d == sizeOfSquare:\\n                self.found = True\\n                return\\n                \\n            if len(valuesLeft) == 0:\\n                return\\n            \\n            if min([eachSide-x for x in [l,r,u,d] if eachSide-x > 0]) < valuesLeft[-1]:\\n                return\\n            test(valuesLeft[1:], r=r, d=d, u=u, l=l+valuesLeft[0])\\n            test(valuesLeft[1:], l=l, d=d, u=u, r=r+valuesLeft[0])\\n            test(valuesLeft[1:], l=l, r=r, d=d, u=u+valuesLeft[0])\\n            test(valuesLeft[1:], l=l, r=r, u=u, d=d+valuesLeft[0])\\n            \\n        \\n        test(matchsticks)\\n        return self.found\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        sizeOfSquare = sum(matchsticks)\\n        eachSide = sizeOfSquare / 4\\n        if int(eachSide) != eachSide:\\n            # This means it cannot create a square\\n            return False\\n        \\n        if max(matchsticks) > eachSide:\\n            # This means the longest stick is too long\\n            return False\\n        \\n        self.found=False\\n        # Reframe the question: Can you create 4 groups of size eachSide\\n        matchsticks.sort(reverse=True)\\n        def test(valuesLeft, l=0, r=0, u=0, d=0):\\n            \\n            if self.found:\\n                return\\n            # print(l, r, u, d)\\n            if l > eachSide or r > eachSide or u > eachSide or d > eachSide:\\n                # print(\"return\")\\n                return\\n            \\n            if l + r + u + d == sizeOfSquare:\\n                self.found = True\\n                return\\n                \\n            if len(valuesLeft) == 0:\\n                return\\n            \\n            if min([eachSide-x for x in [l,r,u,d] if eachSide-x > 0]) < valuesLeft[-1]:\\n                return\\n            test(valuesLeft[1:], r=r, d=d, u=u, l=l+valuesLeft[0])\\n            test(valuesLeft[1:], l=l, d=d, u=u, r=r+valuesLeft[0])\\n            test(valuesLeft[1:], l=l, r=r, d=d, u=u+valuesLeft[0])\\n            test(valuesLeft[1:], l=l, r=r, u=u, d=d+valuesLeft[0])\\n            \\n        \\n        test(matchsticks)\\n        return self.found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273595,
                "title": "java-clean-code-backtracking",
                "content": "```\\npublic boolean makesquare(int[] matchsticks) {\\n\\n\\t\\tint sum=0;\\n        for(int i:matchsticks){\\n            sum+=i;\\n        }\\n\\t\\t\\n\\t\\t\\n        if(sum%4!=0){\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t\\n        Arrays.sort(matchsticks);\\n        int[] side=new int[4];\\n        return dfs(matchsticks,side,matchsticks.length-1,sum/4);\\n    }\\n\\t\\n\\t\\n\\tboolean dfs(int[] matchsticks,int[] side,int idx,int tar){\\n        if(idx==-1 && side[0]==side[1]&& side[1]==side[2]&& side[2]==side[3]){\\n            return true;\\n        }\\n        for(int i=0;i<side.length;i++){\\n              if(side[i]+matchsticks[idx]<=tar){\\n                side[i]+=matchsticks[idx];\\n                if(dfs(matchsticks,side,idx-1,tar)){\\n                    return true;\\n                }\\n                side[i]-=matchsticks[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    \\n```\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\npublic boolean makesquare(int[] matchsticks) {\\n\\n\\t\\tint sum=0;\\n        for(int i:matchsticks){\\n            sum+=i;\\n        }\\n\\t\\t\\n\\t\\t\\n        if(sum%4!=0){\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t\\n        Arrays.sort(matchsticks);\\n        int[] side=new int[4];\\n        return dfs(matchsticks,side,matchsticks.length-1,sum/4);\\n    }\\n\\t\\n\\t\\n\\tboolean dfs(int[] matchsticks,int[] side,int idx,int tar){\\n        if(idx==-1 && side[0]==side[1]&& side[1]==side[2]&& side[2]==side[3]){\\n            return true;\\n        }\\n        for(int i=0;i<side.length;i++){\\n              if(side[i]+matchsticks[idx]<=tar){\\n                side[i]+=matchsticks[idx];\\n                if(dfs(matchsticks,side,idx-1,tar)){\\n                    return true;\\n                }\\n                side[i]-=matchsticks[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273569,
                "title": "c-short-code-with-explanation",
                "content": "Take 4 sides a,b,c,d and keep on adding each length to each side and try all ways.\\n```\\nclass Solution {\\npublic:\\n    bool rec(int i, int a, int b,int c,int d, vector<int>& matchsticks, int sum)\\n    {\\n        if (i==matchsticks.size()) return a==sum && b==sum && c==sum && d==sum;\\n        if (a+matchsticks[i] <= sum && rec(i+1,a+matchsticks[i],b,c,d,matchsticks,sum)) return 1;\\n        if (b+matchsticks[i] <= sum && rec(i+1,a,b+matchsticks[i],c,d,matchsticks,sum)) return 1;\\n        if (c+matchsticks[i] <= sum && rec(i+1,a,b,c+matchsticks[i],d,matchsticks,sum)) return 1;\\n        if (d+matchsticks[i] <= sum && rec(i+1,a,b,c,d+matchsticks[i],matchsticks,sum)) return 1;\\n        return false;\\n    }\\n    bool makesquare(vector<int>& matchsticks) {\\n\\t\\t// sum of length must be % 4 [sum%4==0]\\n        int sum = 0;\\n        for (auto i : matchsticks) sum+= i;\\n        if(sum % 4 != 0) return false;\\n\\t\\t// This sort & reverse is important to avoid TLE\\n        sort(matchsticks.rbegin(), matchsticks.rend());\\n        return rec(0,0,0,0,0,matchsticks,sum/4);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool rec(int i, int a, int b,int c,int d, vector<int>& matchsticks, int sum)\\n    {\\n        if (i==matchsticks.size()) return a==sum && b==sum && c==sum && d==sum;\\n        if (a+matchsticks[i] <= sum && rec(i+1,a+matchsticks[i],b,c,d,matchsticks,sum)) return 1;\\n        if (b+matchsticks[i] <= sum && rec(i+1,a,b+matchsticks[i],c,d,matchsticks,sum)) return 1;\\n        if (c+matchsticks[i] <= sum && rec(i+1,a,b,c+matchsticks[i],d,matchsticks,sum)) return 1;\\n        if (d+matchsticks[i] <= sum && rec(i+1,a,b,c,d+matchsticks[i],matchsticks,sum)) return 1;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2273488,
                "title": "python-code",
                "content": "class Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n, side = len(matchsticks), sum(matchsticks) / 4\\n        matchsticks.sort(reverse=True)\\n        if side != int(side) or matchsticks[0] > side:\\n            return False\\n        def btrack(i, space, done): \\n            if done == 3:\\n                return True\\n            while i < n:\\n                num = matchsticks[i]\\n                if num > space:\\n                    i += 1\\n                    continue\\n                matchsticks[i] = side + 1\\n                if num == space:\\n                    res = btrack(1, side, done+1)\\n                else:\\n                    res = btrack(i+1, space-num, done)\\n                if res:\\n                    return True\\n                matchsticks[i] = num\\n                while i < n and matchsticks[i] == num:\\n                    i += 1\\n            return False\\n        return btrack(0, side, 0)\\n\\t\\t\\n\\t\\t\\n\\t\\t##just let me know if u have any doubt\\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def makesquare(self, matchsticks: List[int]) -> bool:\\n        n, side = len(matchsticks), sum(matchsticks) / 4\\n        matchsticks.sort(reverse=True)\\n        if side != int(side) or matchsticks[0] > side:\\n            return False\\n        def btrack(i, space, done): \\n            if done == 3:\\n                return True\\n            while i < n:\\n                num = matchsticks[i]\\n                if num > space:\\n                    i += 1\\n                    continue\\n                matchsticks[i] = side + 1\\n                if num == space:\\n                    res = btrack(1, side, done+1)\\n                else:\\n                    res = btrack(i+1, space-num, done)\\n                if res:\\n                    return True\\n                matchsticks[i] = num\\n                while i < n and matchsticks[i] == num:\\n                    i += 1\\n            return False\\n        return btrack(0, side, 0)\\n\\t\\t\\n\\t\\t\\n\\t\\t##just let me know if u have any doubt\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 2273443,
                "title": "c-strange-optimized-solution",
                "content": "```cs\\npublic class Solution\\n{\\n    public bool Makesquare(int[] sticks)\\n    {\\n        int sum = sticks.Sum();\\n        if (sum % 4 != 0) return false;\\n        int l = sum / 4;\\n        Array.Sort(sticks);\\n        Array.Reverse(sticks);\\n        \\n        bool Travers(int i, int a, int b, int c, int d)\\n        {\\n            if (a > l || b > l || c > l || d > l) return false;\\n            if (i >= sticks.Length) return a == b && a == c && a == d;\\n            return \\n                Travers(i + 1, a + sticks[i], b, c, d) ||\\n                Travers(i + 1, a, b + sticks[i], c, d) ||\\n                Travers(i + 1, a, b, c + sticks[i], d) ||\\n                Travers(i + 1, a, b, c, d + sticks[i]);\\n        }\\n        \\n        return Travers(0,0,0,0,0);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public bool Makesquare(int[] sticks)\\n    {\\n        int sum = sticks.Sum();\\n        if (sum % 4 != 0) return false;\\n        int l = sum / 4;\\n        Array.Sort(sticks);\\n        Array.Reverse(sticks);\\n        \\n        bool Travers(int i, int a, int b, int c, int d)\\n        {\\n            if (a > l || b > l || c > l || d > l) return false;\\n            if (i >= sticks.Length) return a == b && a == c && a == d;\\n            return \\n                Travers(i + 1, a + sticks[i], b, c, d) ||\\n                Travers(i + 1, a, b + sticks[i], c, d) ||\\n                Travers(i + 1, a, b, c + sticks[i], d) ||\\n                Travers(i + 1, a, b, c, d + sticks[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2273230,
                "title": "c-code-faster-than-96-simple-code-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>& matchsticks, vector<int>& sides, int index, int target){\\n        if(index == -1){\\n            return true;\\n        }\\n        for(int i = 0; i < 4; i++){\\n            if(((sides[i] + matchsticks[index]) > target) or (i > 0 and sides[i] == sides[i - 1])){\\n                continue;\\n            }\\n            sides[i] += matchsticks[index];\\n            if(dfs(matchsticks, sides, index - 1, target)){\\n                return true;\\n            } \\n            sides[i] -= matchsticks[index];\\n        }\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum = 0;\\n        for(int i : matchsticks){\\n            sum += i;\\n        }\\n        if(sum%4 != 0 or matchsticks.size() < 3){\\n            return false;\\n        }\\n        sort(matchsticks.begin(), matchsticks.end());\\n        vector<int> sides(4, 0);\\n        return dfs(matchsticks, sides, matchsticks.size() - 1, sum/4);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>& matchsticks, vector<int>& sides, int index, int target){\\n        if(index == -1){\\n            return true;\\n        }\\n        for(int i = 0; i < 4; i++){\\n            if(((sides[i] + matchsticks[index]) > target) or (i > 0 and sides[i] == sides[i - 1])){\\n                continue;\\n            }\\n            sides[i] += matchsticks[index];\\n            if(dfs(matchsticks, sides, index - 1, target)){\\n                return true;\\n            } \\n            sides[i] -= matchsticks[index];\\n        }\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& matchsticks) {\\n        int sum = 0;\\n        for(int i : matchsticks){\\n            sum += i;\\n        }\\n        if(sum%4 != 0 or matchsticks.size() < 3){\\n            return false;\\n        }\\n        sort(matchsticks.begin(), matchsticks.end());\\n        vector<int> sides(4, 0);\\n        return dfs(matchsticks, sides, matchsticks.size() - 1, sum/4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273190,
                "title": "c-bottom-up-dp-solution",
                "content": "\\nConsider i as a bitset for matchsticks, f(i, j) = use sticks in i to get j sides finished.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& matchsticks) { \\n        int n = matchsticks.size();\\n        int matchsticks_sum = accumulate(matchsticks.begin(), matchsticks.end(), 0);\\n        if (matchsticks_sum % 4 != 0) return false;\\n        int target = matchsticks_sum / 4;\\n        vector<vector<int>> dp(1 << n, vector<int>(4));\\n        vector<int> sum(1 << n);\\n        for (int i = 0; i < (1 << n); i++) {\\n            for (int k = 0; k < n; k++) {\\n                if (i & (1 << k)) sum[i] += matchsticks[k];\\n            }\\n        }\\n        dp[0][0] = 1;\\n        for (int j = 0; j < 4; j++) {\\n            for (int i = 0; i < (1 << n); i++) {\\n                int partial_sum = -j * target + sum[i];\\n                if (partial_sum > target) continue;\\n                for (int k = 0; k < n && !dp[i][j]; k++) {\\n                    if (i & (1 << k)) {\\n                        if (partial_sum >= matchsticks[k]) {\\n                            dp[i][j] |= dp[i ^ (1 << k)][j];\\n                        } else if (j > 0 && partial_sum == 0) {\\n                            dp[i][j] |= dp[i ^ (1 << k)][j - 1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[(1 << n) - 1][3];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& matchsticks) { \\n        int n = matchsticks.size();\\n        int matchsticks_sum = accumulate(matchsticks.begin(), matchsticks.end(), 0);\\n        if (matchsticks_sum % 4 != 0) return false;\\n        int target = matchsticks_sum / 4;\\n        vector<vector<int>> dp(1 << n, vector<int>(4));\\n        vector<int> sum(1 << n);\\n        for (int i = 0; i < (1 << n); i++) {\\n            for (int k = 0; k < n; k++) {\\n                if (i & (1 << k)) sum[i] += matchsticks[k];\\n            }\\n        }\\n        dp[0][0] = 1;\\n        for (int j = 0; j < 4; j++) {\\n            for (int i = 0; i < (1 << n); i++) {\\n                int partial_sum = -j * target + sum[i];\\n                if (partial_sum > target) continue;\\n                for (int k = 0; k < n && !dp[i][j]; k++) {\\n                    if (i & (1 << k)) {\\n                        if (partial_sum >= matchsticks[k]) {\\n                            dp[i][j] |= dp[i ^ (1 << k)][j];\\n                        } else if (j > 0 && partial_sum == 0) {\\n                            dp[i][j] |= dp[i ^ (1 << k)][j - 1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[(1 << n) - 1][3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273097,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        int k=4;\\n        int n=nums.size();\\n        int mask=(1<<n);\\n        int sum=0;\\n        for(auto i: nums) {\\n            sum+=i;\\n        }\\n        if(sum%k!=0) return false;\\n        sum/=k;\\n        int dp[mask];\\n        dp[0]=0;\\n        int temp;\\n        for(mask=1;mask<(1<<n);mask++){\\n            dp[mask]=-1;\\n            for(int i=0;i<n;i++){\\n                temp=dp[mask^(1<<i)];\\n                if(temp>=0 && ((mask&(1<<i))>=1)){\\n                    if((nums[i]+temp)<=sum){\\n                        dp[mask]=((nums[i]+temp))%sum;\\n                    }\\n                }\\n            }\\n        }\\n        return (dp[mask-1]==-1?false:true);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        int k=4;\\n        int n=nums.size();\\n        int mask=(1<<n);\\n        int sum=0;\\n        for(auto i: nums) {\\n            sum+=i;\\n        }\\n        if(sum%k!=0) return false;\\n        sum/=k;\\n        int dp[mask];\\n        dp[0]=0;\\n        int temp;\\n        for(mask=1;mask<(1<<n);mask++){\\n            dp[mask]=-1;\\n            for(int i=0;i<n;i++){\\n                temp=dp[mask^(1<<i)];\\n                if(temp>=0 && ((mask&(1<<i))>=1)){\\n                    if((nums[i]+temp)<=sum){\\n                        dp[mask]=((nums[i]+temp))%sum;\\n                    }\\n                }\\n            }\\n        }\\n        return (dp[mask-1]==-1?false:true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273070,
                "title": "java-7ms-easy-dfs-solution",
                "content": "# please Upvote guys\\n\\n```\\npublic boolean makesquare(int[] nums) {\\n        if(nums == null || nums.length == 0) return false;\\n        int sum = 0;\\n        for(int num : nums) sum += num;\\n        if(sum % 4 != 0) return false;\\n        Arrays.sort(nums);\\n        return dfs(nums, new int[4], nums.length-1, sum/4);\\n    }\\n    boolean dfs(int[] nums, int[] sums, int index, int target){\\n        if(index == -1) return true;\\n        for(int i = 0; i < 4; i++){\\n            if((sums[i] + nums[index] > target) || (i > 0 && sums[i] == sums[i - 1])) continue;\\n            sums[i] += nums[index];\\n            if(dfs(nums, sums, index - 1, target)) return true;\\n            sums[i] -= nums[index];\\n        }\\n        return false;\\n    }    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean makesquare(int[] nums) {\\n        if(nums == null || nums.length == 0) return false;\\n        int sum = 0;\\n        for(int num : nums) sum += num;\\n        if(sum % 4 != 0) return false;\\n        Arrays.sort(nums);\\n        return dfs(nums, new int[4], nums.length-1, sum/4);\\n    }\\n    boolean dfs(int[] nums, int[] sums, int index, int target){\\n        if(index == -1) return true;\\n        for(int i = 0; i < 4; i++){\\n            if((sums[i] + nums[index] > target) || (i > 0 && sums[i] == sums[i - 1])) continue;\\n            sums[i] += nums[index];\\n            if(dfs(nums, sums, index - 1, target)) return true;\\n            sums[i] -= nums[index];\\n        }\\n        return false;\\n    }    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273017,
                "title": "c-backtracking-faster-than-92-easy-recursive-memorized-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool seenBefore(vector<int>&sides , int index){\\n     for(int i=0;i<index;i++){\\n         if(sides[i]==sides[index]){\\n             return true;\\n         }\\n     } \\n        return false;\\n    }\\n    \\n    bool solve(vector<int>&sides ,int index, int sum,vector<int>&m){\\n     if(index==m.size()){\\n         return sides[0]==sum && sides[1]==sum && sides[2]==sum && sides[3]==sum ;\\n     }\\n     for(int i=0;i<4;i++){\\n         if(sides[i]+m[index]>sum || seenBefore(sides , i)){\\n             continue;\\n         }\\n         sides[i] += m[index];\\n         if(solve(sides,index+1,sum,m)){\\n             return true;\\n         }\\n         sides[i] -= m[index];\\n     }\\n        return false;\\n    }\\n    \\n    bool makesquare(vector<int>& m) {\\n     int sum = accumulate(m.begin() , m.end() , 0); \\n     vector<int>sides(4,0);\\n     if(m.size()<4 || sum%4){\\n         return false;\\n     }\\n     sort(m.rbegin() , m.rend());\\n     sum=sum/4;\\n     if(m[0]>sum){\\n         return false;\\n     }\\n     return solve(sides,0,sum,m);   \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool seenBefore(vector<int>&sides , int index){\\n     for(int i=0;i<index;i++){\\n         if(sides[i]==sides[index]){\\n             return true;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2272638,
                "title": "c-bit-masking-solution-with-detailed-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n        int n = matchsticks.size();\\n        \\n        // First check if the sum of all the matchsticks is divisible by 4\\n        // If it is not, then that means we can\\'t split matchsticks into 4 equal sides\\n        // which is required for a square, so we return false\\n        long long sum = 0;\\n        for (int matchstick: matchsticks)\\n            sum += matchstick;\\n        if (sum%4 != 0)\\n            return false;\\n        \\n        // Now we find which all groups of matchsticks (subsets) have a sum of sum/4\\n        // The reason we are finding this is because since it has a sum of sum/4, it means\\n        // that we can use this subset as one side of the square\\n        vector<int> subsets;\\n        for (int i = 1; i < (1<<n); ++i) // Iterating through all subsets of matchsticks\\n        {\\n            // Finding sum of the subsets\\n            long long subset_sum = 0;\\n            for (int j = 0; j < n; ++j)\\n                if ((i&(1<<j)) != 0)\\n                    subset_sum += matchsticks[j];\\n            \\n            // Adding it to vector, if its sum is sum/4\\n            if (subset_sum == sum/4)\\n                subsets.push_back(i);\\n        }\\n        \\n        // Now we make pairs of subsets i.e we want to pick 2 subsets so that we can use\\n        // them as 2 sides of the square\\n        vector<int> pair_of_subsets;\\n        for (int i = 0; i < subsets.size(); ++i)\\n            for (int j = i+1; j < subsets.size(); ++j)\\n                // One very important thing we have to make sure while making pairs, is that\\n                // we don\\'t make a pair out of subsets which use the same element. So to prevent this\\n                // we use the \\'&\\' operator. For the ith element (ith bit) we have to make sure, that the element\\n                // isn\\'t present in both pairs (ith bit isn\\'t set in both subsets -> AND should be zero)\\n                if ((subsets[i]&subsets[j]) == 0)\\n                    pair_of_subsets.push_back(subsets[i]|subsets[j]);\\n        \\n        // Now we add all the pairs we generated into a set, the reason we are doing this is to make\\n        // lookup operations faster. The necessity for lookup operations will be known below.\\n        unordered_set<int> pair_is_present;\\n        for (int pair_of_subset: pair_of_subsets)\\n            pair_is_present.insert(pair_of_subset);\\n        \\n        // The question asks us to check whether we can form a square using ALL matchsticks.\\n        // Right now we have subsets which make up 2 sides of a square. Which means that if we find 2 such subsets\\n        // Then it can make 4 sides i.e a square. However, we have to make sure that both these subsets comprise of all\\n        // the matchsticks\\n        for (int pair_of_subset: pair_of_subsets)\\n        {\\n            // For a subset, if the ith element exists in it, then we don\\'t want the other subset to have the ith element\\n            // Similarly, if the subset doesn\\'t have the ith element, we want the other subset to have the ith element.\\n            // So basically, we want the other subset to be the exact opposite of the current subset i.e all the bits should be\\n            // flipped\\n            int req_pair_of_subset = pair_of_subset;\\n            for (int j = 0; j < n; ++j)\\n                req_pair_of_subset ^= (1<<j);\\n            \\n            // If we are able to find such a subset, then we are able to make a square, so we return true\\n            if (pair_is_present.find(req_pair_of_subset) != pair_is_present.end())\\n                return true;   \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& matchsticks) {\\n        int n = matchsticks.size();\\n        \\n        // First check if the sum of all the matchsticks is divisible by 4\\n        // If it is not, then that means we can\\'t split matchsticks into 4 equal sides\\n        // which is required for a square, so we return false\\n        long long sum = 0;\\n        for (int matchstick: matchsticks)\\n            sum += matchstick;\\n        if (sum%4 != 0)\\n            return false;\\n        \\n        // Now we find which all groups of matchsticks (subsets) have a sum of sum/4\\n        // The reason we are finding this is because since it has a sum of sum/4, it means\\n        // that we can use this subset as one side of the square\\n        vector<int> subsets;\\n        for (int i = 1; i < (1<<n); ++i) // Iterating through all subsets of matchsticks\\n        {\\n            // Finding sum of the subsets\\n            long long subset_sum = 0;\\n            for (int j = 0; j < n; ++j)\\n                if ((i&(1<<j)) != 0)\\n                    subset_sum += matchsticks[j];\\n            \\n            // Adding it to vector, if its sum is sum/4\\n            if (subset_sum == sum/4)\\n                subsets.push_back(i);\\n        }\\n        \\n        // Now we make pairs of subsets i.e we want to pick 2 subsets so that we can use\\n        // them as 2 sides of the square\\n        vector<int> pair_of_subsets;\\n        for (int i = 0; i < subsets.size(); ++i)\\n            for (int j = i+1; j < subsets.size(); ++j)\\n                // One very important thing we have to make sure while making pairs, is that\\n                // we don\\'t make a pair out of subsets which use the same element. So to prevent this\\n                // we use the \\'&\\' operator. For the ith element (ith bit) we have to make sure, that the element\\n                // isn\\'t present in both pairs (ith bit isn\\'t set in both subsets -> AND should be zero)\\n                if ((subsets[i]&subsets[j]) == 0)\\n                    pair_of_subsets.push_back(subsets[i]|subsets[j]);\\n        \\n        // Now we add all the pairs we generated into a set, the reason we are doing this is to make\\n        // lookup operations faster. The necessity for lookup operations will be known below.\\n        unordered_set<int> pair_is_present;\\n        for (int pair_of_subset: pair_of_subsets)\\n            pair_is_present.insert(pair_of_subset);\\n        \\n        // The question asks us to check whether we can form a square using ALL matchsticks.\\n        // Right now we have subsets which make up 2 sides of a square. Which means that if we find 2 such subsets\\n        // Then it can make 4 sides i.e a square. However, we have to make sure that both these subsets comprise of all\\n        // the matchsticks\\n        for (int pair_of_subset: pair_of_subsets)\\n        {\\n            // For a subset, if the ith element exists in it, then we don\\'t want the other subset to have the ith element\\n            // Similarly, if the subset doesn\\'t have the ith element, we want the other subset to have the ith element.\\n            // So basically, we want the other subset to be the exact opposite of the current subset i.e all the bits should be\\n            // flipped\\n            int req_pair_of_subset = pair_of_subset;\\n            for (int j = 0; j < n; ++j)\\n                req_pair_of_subset ^= (1<<j);\\n            \\n            // If we are able to find such a subset, then we are able to make a square, so we return true\\n            if (pair_is_present.find(req_pair_of_subset) != pair_is_present.end())\\n                return true;   \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272598,
                "title": "python-backtracking-328-ms",
                "content": "My first try of backtracking ended up TLE, so I added some conditions to speed up and finally pass it.\\n```\\nclass Solution:\\n    def makesquare(self, ms: List[int]) -> bool:\\n        S, l = sum(ms), len(ms)\\n        sl = S // 4\\n        if l < 4 or S%4 != 0 or max(ms) > sl:\\n            return False\\n        sides = [0]*4\\n        ms.sort(reverse=True)\\n        \\n        def dfs(idx, sides):\\n            if idx == l:\\n                return True\\n            m = ms[idx]\\n            used = set()\\n            for i in range(4):\\n                if sides[i] + m > sl:\\n                    continue\\n                else:\\n                    if sides[i] in used: continue\\n                    used.add(sides[i])\\n                    sides[i] += m\\n                    if dfs(idx+1, sides): return True\\n                    sides[i] -= m\\n            return False\\n        \\n        return dfs(0, sides)\\n",
                "solutionTags": [],
                "code": "My first try of backtracking ended up TLE, so I added some conditions to speed up and finally pass it.\\n```\\nclass Solution:\\n    def makesquare(self, ms: List[int]) -> bool:\\n        S, l = sum(ms), len(ms)\\n        sl = S // 4\\n        if l < 4 or S%4 != 0 or max(ms) > sl:\\n            return False\\n        sides = [0]*4\\n        ms.sort(reverse=True)\\n        \\n        def dfs(idx, sides):\\n            if idx == l:\\n                return True\\n            m = ms[idx]\\n            used = set()\\n            for i in range(4):\\n                if sides[i] + m > sl:\\n                    continue\\n                else:\\n                    if sides[i] in used: continue\\n                    used.add(sides[i])\\n                    sides[i] += m\\n                    if dfs(idx+1, sides): return True\\n                    sides[i] -= m\\n            return False\\n        \\n        return dfs(0, sides)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2272526,
                "title": "c-a-two-stage-solution-collecting-feasible-subsets-and-then-doing-dfs",
                "content": "Like others\\' solutions, mine is also based on DFS. A difference is in that I enumerate all subsets of matchsticks and collect feasible subsets (feasible: sum of length is the desired square length) first. After collecting feasible subsets, I use DFS to check whether it is possible to find 4 non-overlapping subsets.\\n\\n```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& sticks) \\n    {\\n\\t    // -----------------------------------------------------------\\n\\t    // Making a quick decision for some \\'false\\' conditions\\n\\t\\t// -----------------------------------------------------------\\n        const int N = sticks.size();\\n        int total = accumulate(sticks.begin(), sticks.end(), 0);\\n        if (total%4!=0) return false;\\n        int target = total/4;\\n        for (auto e: sticks) if (e>target) return false;\\n        \\n\\t\\t// ---------------------------------------------------------------------------------------------------\\n        // Finding all subsets of matchsticks whose sum of length meets the square length\\n\\t\\t// Given \\'sticks\\' as [3, 3, 3, 1, 2], possible subsets (i.e. \\'combo\\') would be [1, 2, 4, 24], which correspond to [00001, 00010, 00100, 11000]\\n\\t\\t// [00001] means selecting the first matchstick (length 3), [11000] means selecting the 4th and 5th matchstick (length 1+2=3)\\n\\t\\t// ---------------------------------------------------------------------------------------------------\\n        const int ComboSize = (1 << N);\\n        vector<int> combo;\\n        for (int i=0; i<ComboSize; i+=1)\\n        {\\n            int tmp = i, sum = 0;\\n            for (int t=0; t<N; t+=1)\\n            {\\n                if (tmp%2) sum += sticks[t];\\n                tmp /= 2;\\n            }\\n            if (sum == target) combo.push_back(i);\\n        }\\n\\n        // ---------------------------------------------------------------------------------------------------\\n\\t\\t// Checking whether it is possible to find 4 subsets from combo that do not overlap with each other.\\n\\t\\t// ---------------------------------------------------------------------------------------------------\\n        return dfs(0, 0, combo, 0);\\n    }\\n    \\nprivate:\\n    bool dfs(int used_combo, int start, const vector<int> &combo, int num_grp)\\n    {\\n        if (num_grp==4) return true;\\n        \\n        for (int i=start; i<combo.size(); i+=1)\\n        {\\n            if (used_combo & combo[i]) continue; // overlap\\n            \\n            int tmp = used_combo;\\n            used_combo = used_combo | combo[i];\\n            bool flag = dfs(used_combo, i+1, combo, num_grp+1);\\n            used_combo = tmp;\\n            \\n            if (flag) return true;            \\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& sticks) \\n    {\\n\\t    // -----------------------------------------------------------\\n\\t    // Making a quick decision for some \\'false\\' conditions\\n\\t\\t// -----------------------------------------------------------\\n        const int N = sticks.size();\\n        int total = accumulate(sticks.begin(), sticks.end(), 0);\\n        if (total%4!=0) return false;\\n        int target = total/4;\\n        for (auto e: sticks) if (e>target) return false;\\n        \\n\\t\\t// ---------------------------------------------------------------------------------------------------\\n        // Finding all subsets of matchsticks whose sum of length meets the square length\\n\\t\\t// Given \\'sticks\\' as [3, 3, 3, 1, 2], possible subsets (i.e. \\'combo\\') would be [1, 2, 4, 24], which correspond to [00001, 00010, 00100, 11000]\\n\\t\\t// [00001] means selecting the first matchstick (length 3), [11000] means selecting the 4th and 5th matchstick (length 1+2=3)\\n\\t\\t// ---------------------------------------------------------------------------------------------------\\n        const int ComboSize = (1 << N);\\n        vector<int> combo;\\n        for (int i=0; i<ComboSize; i+=1)\\n        {\\n            int tmp = i, sum = 0;\\n            for (int t=0; t<N; t+=1)\\n            {\\n                if (tmp%2) sum += sticks[t];\\n                tmp /= 2;\\n            }\\n            if (sum == target) combo.push_back(i);\\n        }\\n\\n        // ---------------------------------------------------------------------------------------------------\\n\\t\\t// Checking whether it is possible to find 4 subsets from combo that do not overlap with each other.\\n\\t\\t// ---------------------------------------------------------------------------------------------------\\n        return dfs(0, 0, combo, 0);\\n    }\\n    \\nprivate:\\n    bool dfs(int used_combo, int start, const vector<int> &combo, int num_grp)\\n    {\\n        if (num_grp==4) return true;\\n        \\n        for (int i=start; i<combo.size(); i+=1)\\n        {\\n            if (used_combo & combo[i]) continue; // overlap\\n            \\n            int tmp = used_combo;\\n            used_combo = used_combo | combo[i];\\n            bool flag = dfs(used_combo, i+1, combo, num_grp+1);\\n            used_combo = tmp;\\n            \\n            if (flag) return true;            \\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272457,
                "title": "simple-c-solution-backtracking",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n\\n    bool dfs(vector<int>& mat,int ind,int side,vector<int>&s)\\n    {\\n        if( ind >= mat.size() )\\n            return s[0] == s[1] && s[2] == s[3] ;\\n            \\n        \\n        for(int i=0;i<4;i++)\\n        {\\n            if( s[i]+mat[ind] <= side )\\n            {\\n                s[i]+=mat[ind] ;\\n                if(dfs(mat,ind+1,side,s))\\n                    return true ;\\n                s[i]-=mat[ind] ;\\n            }\\n        }\\n        \\n        return false ;\\n    }\\n        \\n    bool makesquare(vector<int>& mat ) {\\n        \\n        if(mat.size()<4)\\n            return false ;\\n        \\n        int sum = accumulate(mat.begin(),mat.end(),0) ;\\n        vector<int>s(4,0) ;\\n\\n        if(sum%4)\\n            return false ;\\n        \\n        sort(mat.begin(),mat.end(),[](const int &a, const int &b){\\n            return a > b;\\n        });\\n        \\n        int side = sum/4 ;\\n        \\n        return dfs(mat,0,side,s);\\n        \\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n\\n    bool dfs(vector<int>& mat,int ind,int side,vector<int>&s)\\n    {\\n        if( ind >= mat.size() )\\n            return s[0] == s[1] && s[2] == s[3] ;\\n            \\n        \\n        for(int i=0;i<4;i++)\\n        {\\n            if( s[i]+mat[ind] <= side )\\n            {\\n                s[i]+=mat[ind] ;\\n                if(dfs(mat,ind+1,side,s))\\n                    return true ;\\n                s[i]-=mat[ind] ;\\n            }\\n        }\\n        \\n        return false ;\\n    }\\n        \\n    bool makesquare(vector<int>& mat ) {\\n        \\n        if(mat.size()<4)\\n            return false ;\\n        \\n        int sum = accumulate(mat.begin(),mat.end(),0) ;\\n        vector<int>s(4,0) ;\\n\\n        if(sum%4)\\n            return false ;\\n        \\n        sort(mat.begin(),mat.end(),[](const int &a, const int &b){\\n            return a > b;\\n        });\\n        \\n        int side = sum/4 ;\\n        \\n        return dfs(mat,0,side,s);\\n        \\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272451,
                "title": "c-backtracking-well-commented-solution-accepted",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        bool makesquare(vector<int> &match)\\n        {\\n            int n = match.size();\\n\\n            int sum = accumulate(match.begin(), match.end(), 0); // sum of all the matchsticks together would form the perimeter of the square\\n            \\n            if(sum % 4 !=0)\\n            {\\n                return false; // if it cannot be divided into 4 sides\\n            }\\n\\n            int k = sum / 4;\\n\\n            vector<int> sq(4, k); // 4 sides, all of equal length, we will trY all combinations to make all 4 of them 0, if possible then we\\'ll return true else we\\'ll return false\\n\\n            sort(match.rbegin(), match.rend()); // sorting in reverse order to eliminate some cases\\n\\n            return f(match, 0, sq, n);\\n        }\\n    bool f(vector<int> &match, int index, vector<int> &sq, int n)\\n    {\\n        if (index == n)\\n        {\\n            for(int i=0;i<4;i++)\\n            {\\n                if(sq[i]!=0)\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n\\n        bool k = false;\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (sq[i] >= match[index]) // cannot let a side become negative\\n            {\\n\\n                sq[i] -= match[index]; // picking the side\\n\\n                k = f(match, index + 1, sq, n); // moving on to the next match stick\\n                if (k)\\n                {\\n                    return true; // if that returned true just return it\\n                }\\n\\n                sq[i] += match[index]; // backtrack\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        bool makesquare(vector<int> &match)\\n        {\\n            int n = match.size();\\n\\n            int sum = accumulate(match.begin(), match.end(), 0); // sum of all the matchsticks together would form the perimeter of the square\\n            \\n            if(sum % 4 !=0)\\n            {\\n                return false; // if it cannot be divided into 4 sides\\n            }\\n\\n            int k = sum / 4;\\n\\n            vector<int> sq(4, k); // 4 sides, all of equal length, we will trY all combinations to make all 4 of them 0, if possible then we\\'ll return true else we\\'ll return false\\n\\n            sort(match.rbegin(), match.rend()); // sorting in reverse order to eliminate some cases\\n\\n            return f(match, 0, sq, n);\\n        }\\n    bool f(vector<int> &match, int index, vector<int> &sq, int n)\\n    {\\n        if (index == n)\\n        {\\n            for(int i=0;i<4;i++)\\n            {\\n                if(sq[i]!=0)\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n\\n        bool k = false;\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (sq[i] >= match[index]) // cannot let a side become negative\\n            {\\n\\n                sq[i] -= match[index]; // picking the side\\n\\n                k = f(match, index + 1, sq, n); // moving on to the next match stick\\n                if (k)\\n                {\\n                    return true; // if that returned true just return it\\n                }\\n\\n                sq[i] += match[index]; // backtrack\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272196,
                "title": "need-help-in-this-unusual-behaviour-c-backtrack-code",
                "content": "# Error Or what?\\nWhen I submit my code with solve_small2big() it Accepted, but when I\\u2019m using solve_big2small() it gives TLE in some test cases (Random all the time) , but when I copy that failed test-case and run with custom-test cases it won\\'t give TLE, but same while submit \\nIs this a glitch of leetcode or There is some logical error due to the high complexity of my code?\\nPlease help !!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    #define all(v) (v).begin(), (v).end()\\n    int N = 4;\\n    int length; //length of square/ N sided shape \\n    \\n    \\n    bool solve_small2big(vector<int> &m,vector<int> &sides, int ind){\\n        \\n        // what is the base\\n        // base case :- smallest valid input to the function \\n        //or\\n        // base case :- largest valid input to the function\\n        // depend on which way we are working in \\n        \\n        if(ind == m.size()) return true;\\n        \\n        \\n        bool answerFromDepth;\\n        \\n        for(int i = 0;i<N;i++){\\n            if(m[ind] + sides[i] <= length){\\n                sides[i] += m[ind];\\n                answerFromDepth = solve_small2big(m,sides,ind+1);\\n                sides[i] -= m[ind];\\n                if (answerFromDepth) return true; // not to check for other squares\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool solve_big2small(vector<int> &m,vector<int> &sides, int ind){\\n        \\n        // what is the base\\n        // base case :- smallest valid input to the function \\n        //or\\n        // base case :- largest valid input to the function\\n        // depend on which way we are working in \\n        \\n        if(ind < 0) return true;\\n        \\n        \\n        bool answerFromDepth;\\n        \\n        for(int i = 0;i<N;i++){\\n            if(m[ind] + sides[i] <= length){\\n                sides[i] += m[ind];\\n                answerFromDepth = solve_big2small(m,sides,ind-1);\\n                sides[i] -= m[ind];\\n                if (answerFromDepth) return true; // not to check for other squares\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    static bool cmp (int a , int b){return a> b;}\\n    bool makesquare(vector<int>& stick) {\\n        int sum = 0;\\n        sort(all(stick),cmp);\\n        sum = accumulate(all(stick),0); // 4a\\n        if(sum%N != 0 ) return false;\\n        else{\\n            length = sum / N;\\n            int n = size(stick);\\n            vector<int> sides(N,0);\\n            // return solve_small2big(stick,sides,0); // small to big (index : 0 ->n)\\n            \\n            return solve_big2small(stick,sides,n-1); // big to small (index : n-1-> -1)\\n        }\\n    }\\n};\\n\\n```\\n\\n\\nhow to resolve this ??",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define all(v) (v).begin(), (v).end()\\n    int N = 4;\\n    int length; //length of square/ N sided shape \\n    \\n    \\n    bool solve_small2big(vector<int> &m,vector<int> &sides, int ind){\\n        \\n        // what is the base\\n        // base case :- smallest valid input to the function \\n        //or\\n        // base case :- largest valid input to the function\\n        // depend on which way we are working in \\n        \\n        if(ind == m.size()) return true;\\n        \\n        \\n        bool answerFromDepth;\\n        \\n        for(int i = 0;i<N;i++){\\n            if(m[ind] + sides[i] <= length){\\n                sides[i] += m[ind];\\n                answerFromDepth = solve_small2big(m,sides,ind+1);\\n                sides[i] -= m[ind];\\n                if (answerFromDepth) return true; // not to check for other squares\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool solve_big2small(vector<int> &m,vector<int> &sides, int ind){\\n        \\n        // what is the base\\n        // base case :- smallest valid input to the function \\n        //or\\n        // base case :- largest valid input to the function\\n        // depend on which way we are working in \\n        \\n        if(ind < 0) return true;\\n        \\n        \\n        bool answerFromDepth;\\n        \\n        for(int i = 0;i<N;i++){\\n            if(m[ind] + sides[i] <= length){\\n                sides[i] += m[ind];\\n                answerFromDepth = solve_big2small(m,sides,ind-1);\\n                sides[i] -= m[ind];\\n                if (answerFromDepth) return true; // not to check for other squares\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    static bool cmp (int a , int b){return a> b;}\\n    bool makesquare(vector<int>& stick) {\\n        int sum = 0;\\n        sort(all(stick),cmp);\\n        sum = accumulate(all(stick),0); // 4a\\n        if(sum%N != 0 ) return false;\\n        else{\\n            length = sum / N;\\n            int n = size(stick);\\n            vector<int> sides(N,0);\\n            // return solve_small2big(stick,sides,0); // small to big (index : 0 ->n)\\n            \\n            return solve_big2small(stick,sides,n-1); // big to small (index : n-1-> -1)\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272092,
                "title": "c-easiest-code-using-simple-backtracking-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& arr) {\\n        int sum=0;\\n        for(auto x : arr) sum+=x;\\n        if(sum%4!=0) return false;\\n        sort(arr.begin(),arr.end(),greater<int>());\\n        int target=sum/4;\\n        vector<int>sides(4,target);\\n        return dfs(arr,0,sides);\\n    }\\n    \\n    bool dfs(vector<int>&arr, int idx, vector<int>&sides){\\n        if(idx==arr.size() && allZero(sides)) return true;\\n        \\n        if(sides[0]>=arr[idx]){\\n            sides[0]-=arr[idx];\\n            if(dfs(arr,idx+1,sides)) return true;\\n             else sides[0]+=arr[idx];\\n        }\\n        if(sides[1]>=arr[idx]){\\n            sides[1]-=arr[idx];\\n            if(dfs(arr,idx+1,sides)) return true;\\n            else sides[1]+=arr[idx];\\n        }\\n        if(sides[2]>=arr[idx]){\\n            sides[2]-=arr[idx];\\n            if(dfs(arr,idx+1,sides)) return true;\\n            else sides[2]+=arr[idx];\\n        }\\n        if(sides[3]>=arr[idx]){\\n            sides[3]-=arr[idx];\\n            if(dfs(arr,idx+1,sides)) return true;\\n            else sides[3]+=arr[idx];\\n        }\\n        return false;\\n   }\\n    \\n    bool allZero(vector<int>&sides){\\n        for(auto x : sides){\\n            if(x!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makesquare(vector<int>& arr) {\\n        int sum=0;\\n        for(auto x : arr) sum+=x;\\n        if(sum%4!=0) return false;\\n        sort(arr.begin(),arr.end(),greater<int>());\\n        int target=sum/4;\\n        vector<int>sides(4,target);\\n        return dfs(arr,0,sides);\\n    }\\n    \\n    bool dfs(vector<int>&arr, int idx, vector<int>&sides){\\n        if(idx==arr.size() && allZero(sides)) return true;\\n        \\n        if(sides[0]>=arr[idx]){\\n            sides[0]-=arr[idx];\\n            if(dfs(arr,idx+1,sides)) return true;\\n             else sides[0]+=arr[idx];\\n        }\\n        if(sides[1]>=arr[idx]){\\n            sides[1]-=arr[idx];\\n            if(dfs(arr,idx+1,sides)) return true;\\n            else sides[1]+=arr[idx];\\n        }\\n        if(sides[2]>=arr[idx]){\\n            sides[2]-=arr[idx];\\n            if(dfs(arr,idx+1,sides)) return true;\\n            else sides[2]+=arr[idx];\\n        }\\n        if(sides[3]>=arr[idx]){\\n            sides[3]-=arr[idx];\\n            if(dfs(arr,idx+1,sides)) return true;\\n            else sides[3]+=arr[idx];\\n        }\\n        return false;\\n   }\\n    \\n    bool allZero(vector<int>&sides){\\n        for(auto x : sides){\\n            if(x!=0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271966,
                "title": "java-dp-bitmask-solution",
                "content": "We will create a Mask (Basically a Decimal Number to represent which bits are Set or available & each bit will represent the Number Item). In this problem, since we need to Identify whether we can place a sequence of numbers in each square, we will Iterate over all Possibilities & likewise Identify if we can place the current Number.\\n\\nCreate a Mask of length == n (for each Matchstick if we can place it in a Side length of Sum/4)\\nIterate over all Possibilities & check `if(nums[j] <= (sum - (total[i]%sum))) ` through which we can place that given nums[i] in a square side\\n\\n```\\nclass Solution {\\n    public boolean makesquare(int[] nums) {\\n        if(nums == null || nums.length == 0)\\n\\t\\t\\treturn false;\\n\\t\\tint k = 4;\\n\\t\\tint n = nums.length;\\n\\t\\t\\n\\t\\tboolean dp[] = new boolean[1<<n];\\n\\t\\tint total[] = new int[1<<n];\\n\\t\\tdp[0] = true;\\n\\t\\t\\n\\t\\tint sum = 0;\\n\\t\\tfor(int num : nums)\\n\\t\\t\\tsum += num;\\n\\t\\tArrays.sort(nums);\\n\\t\\t\\n\\t\\tif(sum%k != 0) \\n\\t\\t\\treturn false;\\n\\t\\tsum /= k;\\n\\t\\tif(nums[n-1] > sum)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < (1<<n); i++) \\n        {\\n\\t\\t\\tif(dp[i]) \\n            {\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) \\n                { \\n\\t\\t\\t\\t\\tint temp = i | (1 << j);\\n\\t\\t\\t\\t\\tif(temp != i) \\n                    {\\n\\t\\t\\t\\t\\t\\tif(nums[j] <= (sum - (total[i]%sum))) \\n                        {\\n\\t\\t\\t\\t\\t\\t\\tdp[temp] = true;\\n\\t\\t\\t\\t\\t\\t\\ttotal[temp] = nums[j] + total[i];\\n\\t\\t\\t\\t\\t\\t} \\n                        else\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[(1<<n) - 1];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makesquare(int[] nums) {\\n        if(nums == null || nums.length == 0)\\n\\t\\t\\treturn false;\\n\\t\\tint k = 4;\\n\\t\\tint n = nums.length;\\n\\t\\t\\n\\t\\tboolean dp[] = new boolean[1<<n];\\n\\t\\tint total[] = new int[1<<n];\\n\\t\\tdp[0] = true;\\n\\t\\t\\n\\t\\tint sum = 0;\\n\\t\\tfor(int num : nums)\\n\\t\\t\\tsum += num;\\n\\t\\tArrays.sort(nums);\\n\\t\\t\\n\\t\\tif(sum%k != 0) \\n\\t\\t\\treturn false;\\n\\t\\tsum /= k;\\n\\t\\tif(nums[n-1] > sum)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < (1<<n); i++) \\n        {\\n\\t\\t\\tif(dp[i]) \\n            {\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) \\n                { \\n\\t\\t\\t\\t\\tint temp = i | (1 << j);\\n\\t\\t\\t\\t\\tif(temp != i) \\n                    {\\n\\t\\t\\t\\t\\t\\tif(nums[j] <= (sum - (total[i]%sum))) \\n                        {\\n\\t\\t\\t\\t\\t\\t\\tdp[temp] = true;\\n\\t\\t\\t\\t\\t\\t\\ttotal[temp] = nums[j] + total[i];\\n\\t\\t\\t\\t\\t\\t} \\n                        else\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[(1<<n) - 1];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271947,
                "title": "java-backtracking-optimized-dp-solution",
                "content": "class Solution {\\n    \\n    public boolean dfs(int[] arr, int idx, int[] sides, int target){\\n        if(idx == arr.length ){\\n            if(sides[0]==sides[1] && sides[1]==sides[2] && sides[2]==sides[3]){\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n        for(int i = 0; i<sides.length; i++){\\n            if(sides[i]+arr[idx]>target){\\n                continue;\\n            }\\n            int j = i-1;\\n            while(j>=0){\\n                if(sides[j]==sides[i]){           //optimization checking if the current pattern in i has already been calculated then skip it\\n                    break;\\n                }\\n                j--;\\n            }\\n            if(j!=-1){\\n                continue;\\n            }\\n            sides[i] += arr[idx];\\n            if(dfs(arr,idx+1,sides,target)){\\n                return true;\\n            }\\n            sides[i] -= arr[idx];\\n        }\\n        return false;\\n    }\\n    \\n    public boolean makesquare(int[] arr) {\\n        int n = arr.length;\\n        int[] sides = new int[4];\\n        int sum = 0;\\n        for(int i = 0; i<n; i++){\\n            sum += arr[i];\\n            arr[i] = -arr[i];\\n        }\\n        \\n        Arrays.sort(arr);\\n        \\n        for(int i = 0; i<n; i++){\\n            arr[i] = -arr[i];\\n        }\\n        \\n        int oneside = sum/4;\\n        if(arr[0]>oneside){\\n            return false;\\n        }\\n        \\n        return dfs(arr,0,sides,oneside);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    \\n    public boolean dfs(int[] arr, int idx, int[] sides, int target){\\n        if(idx == arr.length ){\\n            if(sides[0]==sides[1] && sides[1]==sides[2] && sides[2]==sides[3]){\\n                return true;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1767331,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "this is hard"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time limit is too hard for this one."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "Should be a hard problem indeed"
                    },
                    {
                        "username": "puzzle_machine",
                        "content": "This problem is a fine example why requirements engineering is so important. If any part of a specification allows wierd things, then it must also permit consequences of those oddities. In our case, it is suspicious that a matchstick can be of zero length. For all practical purposes we may regard this as *nonsense*. But this is not the worst issue. What irritates is that a square with zero side length is not accepeted as a valid shape.\\n\\nTry to enter the following test case `[0,0,0,0]`. It will be regarded as `False` by the official solution, although nothing more strange is entered here than what is already allowed. Namely, we have 4 zero length matchsticks that can nicely form a square of zero side length. All matchsticks would be used exactly once and all sides of the square would be equal."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "Well you should see the constraints of the question first"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "This problem should be in hard category"
                    },
                    {
                        "username": "autodino",
                        "content": "When I checked some of the fastest Python solutions, I see several wrong solutions -- Please just try case [2,3,3,3,3,3,3,3,3,4,4,5,13]!!! This case should be included in the test!"
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "This is should return a True"
                    },
                    {
                        "username": "122001034",
                        "content": "smaller version of partition to k equal sum subset problem; try it out"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "This is a crucial line!!! I used backtracking asusual. But it gave more than 2000ms. But putting a if condition optimised it to 46ms and gave me a 99.98% space. \nfor(int i=0;i<4;i++){\n            if(arr[i]>target)return false;\n            arr[i]+=m[idx];\n            if(backtrack(arr,m,idx+1,n,target))return true;\n            arr[i]-=m[idx];\n            if(arr[i]==0)break; // helps a lot in optimization\n}"
                    },
                    {
                        "username": "CodeJesus",
                        "content": "Are the matchsticks sorted? "
                    },
                    {
                        "username": "TheDictator11",
                        "content": "No. But if it helps you can always sort the matchsticks as the initial order doesn\\'t matter."
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello guys,\\nI am not able to figure out why the below solution gives TLE for the problem\\nPLease help if possible\\nThank you \\n \\n `class Solution {`\\n`public:`\\n`typedef long long int ll;`\\n\\n`int res;`\\n`vector<int> arr;`\\n`int n;`\\n`ll a,b,c,d;`\\n\\n    `int ways(int i)`\\n    `{`\\n     `   if(a>res || b>res ||c>res || d>res)`\\n        `return 0;`\\n\\n`if(i==n)`\\n`{`\\n `   if(a==b and b==c and c==d)`\\n`    {`\\n       ` return 1;`\\n    `}`\\n   ` else return 0;`\\n`}`\\n\\n`if(a+arr[i]<=res){`\\n`a+=arr[i];`\\n`int c1=ways(i+1);`\\n`if(c1)`\\n`return 1;`\\n`a-=arr[i];`\\n`}`\\n\\n`if(b+arr[i]<=res){\\nb+=arr[i];\\nint c2=ways(i+1);\\nif(c2)\\nreturn 1;\\nb-=arr[i];}\\n`\\n`if(c+arr[i]<=res){\\nc+=arr[i];\\nint c3=ways(i+1);\\nif(c3)\\nreturn 1;\\nc-=arr[i];\\n}\\n`\\n`if(d+arr[i]<=res){\\nd+=arr[i];\\nint c4=ways(i+1);\\nif(c4)\\nreturn 1;\\nd-=arr[i];}\\n`\\n\\n`return 0;`\\n        \\n `   }`\\n    `bool makesquare(vector<int>& m) {`\\n\\n\\n`  ll sum=0;`\\n  `arr=m;`\\n  `for(int i:m)`\\n  `{`\\n   `   sum+=i;`\\n\\n  `}`\\n  \\n  `if(sum%4!=0)`\\n  `return 0;`\\n   `res=sum/4;`\\n  `a=0;b=0;c=0;d=0;`\\n  `n=m.size();`\\n  `return ways(0);`\\n   ` }`\\n`};`\\n`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@tejasX](/tejasX) Hey I tried and this works.  Please explain why this works !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Sort it in DESC."
                    },
                    {
                        "username": "Suraj_20",
                        "content": "[10,6,5,5,5,3,3,3,2,2,2,2] \\nWhy this test case return true. Please make a square this test case..."
                    },
                    {
                        "username": "vinaysaini2284",
                        "content": "[10,2],[5,5,2],[5,3,2,2],[6,3,3]"
                    }
                ]
            },
            {
                "id": 1570479,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "this is hard"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time limit is too hard for this one."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "Should be a hard problem indeed"
                    },
                    {
                        "username": "puzzle_machine",
                        "content": "This problem is a fine example why requirements engineering is so important. If any part of a specification allows wierd things, then it must also permit consequences of those oddities. In our case, it is suspicious that a matchstick can be of zero length. For all practical purposes we may regard this as *nonsense*. But this is not the worst issue. What irritates is that a square with zero side length is not accepeted as a valid shape.\\n\\nTry to enter the following test case `[0,0,0,0]`. It will be regarded as `False` by the official solution, although nothing more strange is entered here than what is already allowed. Namely, we have 4 zero length matchsticks that can nicely form a square of zero side length. All matchsticks would be used exactly once and all sides of the square would be equal."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "Well you should see the constraints of the question first"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "This problem should be in hard category"
                    },
                    {
                        "username": "autodino",
                        "content": "When I checked some of the fastest Python solutions, I see several wrong solutions -- Please just try case [2,3,3,3,3,3,3,3,3,4,4,5,13]!!! This case should be included in the test!"
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "This is should return a True"
                    },
                    {
                        "username": "122001034",
                        "content": "smaller version of partition to k equal sum subset problem; try it out"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "This is a crucial line!!! I used backtracking asusual. But it gave more than 2000ms. But putting a if condition optimised it to 46ms and gave me a 99.98% space. \nfor(int i=0;i<4;i++){\n            if(arr[i]>target)return false;\n            arr[i]+=m[idx];\n            if(backtrack(arr,m,idx+1,n,target))return true;\n            arr[i]-=m[idx];\n            if(arr[i]==0)break; // helps a lot in optimization\n}"
                    },
                    {
                        "username": "CodeJesus",
                        "content": "Are the matchsticks sorted? "
                    },
                    {
                        "username": "TheDictator11",
                        "content": "No. But if it helps you can always sort the matchsticks as the initial order doesn\\'t matter."
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello guys,\\nI am not able to figure out why the below solution gives TLE for the problem\\nPLease help if possible\\nThank you \\n \\n `class Solution {`\\n`public:`\\n`typedef long long int ll;`\\n\\n`int res;`\\n`vector<int> arr;`\\n`int n;`\\n`ll a,b,c,d;`\\n\\n    `int ways(int i)`\\n    `{`\\n     `   if(a>res || b>res ||c>res || d>res)`\\n        `return 0;`\\n\\n`if(i==n)`\\n`{`\\n `   if(a==b and b==c and c==d)`\\n`    {`\\n       ` return 1;`\\n    `}`\\n   ` else return 0;`\\n`}`\\n\\n`if(a+arr[i]<=res){`\\n`a+=arr[i];`\\n`int c1=ways(i+1);`\\n`if(c1)`\\n`return 1;`\\n`a-=arr[i];`\\n`}`\\n\\n`if(b+arr[i]<=res){\\nb+=arr[i];\\nint c2=ways(i+1);\\nif(c2)\\nreturn 1;\\nb-=arr[i];}\\n`\\n`if(c+arr[i]<=res){\\nc+=arr[i];\\nint c3=ways(i+1);\\nif(c3)\\nreturn 1;\\nc-=arr[i];\\n}\\n`\\n`if(d+arr[i]<=res){\\nd+=arr[i];\\nint c4=ways(i+1);\\nif(c4)\\nreturn 1;\\nd-=arr[i];}\\n`\\n\\n`return 0;`\\n        \\n `   }`\\n    `bool makesquare(vector<int>& m) {`\\n\\n\\n`  ll sum=0;`\\n  `arr=m;`\\n  `for(int i:m)`\\n  `{`\\n   `   sum+=i;`\\n\\n  `}`\\n  \\n  `if(sum%4!=0)`\\n  `return 0;`\\n   `res=sum/4;`\\n  `a=0;b=0;c=0;d=0;`\\n  `n=m.size();`\\n  `return ways(0);`\\n   ` }`\\n`};`\\n`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@tejasX](/tejasX) Hey I tried and this works.  Please explain why this works !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Sort it in DESC."
                    },
                    {
                        "username": "Suraj_20",
                        "content": "[10,6,5,5,5,3,3,3,2,2,2,2] \\nWhy this test case return true. Please make a square this test case..."
                    },
                    {
                        "username": "vinaysaini2284",
                        "content": "[10,2],[5,5,2],[5,3,2,2],[6,3,3]"
                    }
                ]
            },
            {
                "id": 1973295,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "this is hard"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time limit is too hard for this one."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "Should be a hard problem indeed"
                    },
                    {
                        "username": "puzzle_machine",
                        "content": "This problem is a fine example why requirements engineering is so important. If any part of a specification allows wierd things, then it must also permit consequences of those oddities. In our case, it is suspicious that a matchstick can be of zero length. For all practical purposes we may regard this as *nonsense*. But this is not the worst issue. What irritates is that a square with zero side length is not accepeted as a valid shape.\\n\\nTry to enter the following test case `[0,0,0,0]`. It will be regarded as `False` by the official solution, although nothing more strange is entered here than what is already allowed. Namely, we have 4 zero length matchsticks that can nicely form a square of zero side length. All matchsticks would be used exactly once and all sides of the square would be equal."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "Well you should see the constraints of the question first"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "This problem should be in hard category"
                    },
                    {
                        "username": "autodino",
                        "content": "When I checked some of the fastest Python solutions, I see several wrong solutions -- Please just try case [2,3,3,3,3,3,3,3,3,4,4,5,13]!!! This case should be included in the test!"
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "This is should return a True"
                    },
                    {
                        "username": "122001034",
                        "content": "smaller version of partition to k equal sum subset problem; try it out"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "This is a crucial line!!! I used backtracking asusual. But it gave more than 2000ms. But putting a if condition optimised it to 46ms and gave me a 99.98% space. \nfor(int i=0;i<4;i++){\n            if(arr[i]>target)return false;\n            arr[i]+=m[idx];\n            if(backtrack(arr,m,idx+1,n,target))return true;\n            arr[i]-=m[idx];\n            if(arr[i]==0)break; // helps a lot in optimization\n}"
                    },
                    {
                        "username": "CodeJesus",
                        "content": "Are the matchsticks sorted? "
                    },
                    {
                        "username": "TheDictator11",
                        "content": "No. But if it helps you can always sort the matchsticks as the initial order doesn\\'t matter."
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello guys,\\nI am not able to figure out why the below solution gives TLE for the problem\\nPLease help if possible\\nThank you \\n \\n `class Solution {`\\n`public:`\\n`typedef long long int ll;`\\n\\n`int res;`\\n`vector<int> arr;`\\n`int n;`\\n`ll a,b,c,d;`\\n\\n    `int ways(int i)`\\n    `{`\\n     `   if(a>res || b>res ||c>res || d>res)`\\n        `return 0;`\\n\\n`if(i==n)`\\n`{`\\n `   if(a==b and b==c and c==d)`\\n`    {`\\n       ` return 1;`\\n    `}`\\n   ` else return 0;`\\n`}`\\n\\n`if(a+arr[i]<=res){`\\n`a+=arr[i];`\\n`int c1=ways(i+1);`\\n`if(c1)`\\n`return 1;`\\n`a-=arr[i];`\\n`}`\\n\\n`if(b+arr[i]<=res){\\nb+=arr[i];\\nint c2=ways(i+1);\\nif(c2)\\nreturn 1;\\nb-=arr[i];}\\n`\\n`if(c+arr[i]<=res){\\nc+=arr[i];\\nint c3=ways(i+1);\\nif(c3)\\nreturn 1;\\nc-=arr[i];\\n}\\n`\\n`if(d+arr[i]<=res){\\nd+=arr[i];\\nint c4=ways(i+1);\\nif(c4)\\nreturn 1;\\nd-=arr[i];}\\n`\\n\\n`return 0;`\\n        \\n `   }`\\n    `bool makesquare(vector<int>& m) {`\\n\\n\\n`  ll sum=0;`\\n  `arr=m;`\\n  `for(int i:m)`\\n  `{`\\n   `   sum+=i;`\\n\\n  `}`\\n  \\n  `if(sum%4!=0)`\\n  `return 0;`\\n   `res=sum/4;`\\n  `a=0;b=0;c=0;d=0;`\\n  `n=m.size();`\\n  `return ways(0);`\\n   ` }`\\n`};`\\n`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@tejasX](/tejasX) Hey I tried and this works.  Please explain why this works !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Sort it in DESC."
                    },
                    {
                        "username": "Suraj_20",
                        "content": "[10,6,5,5,5,3,3,3,2,2,2,2] \\nWhy this test case return true. Please make a square this test case..."
                    },
                    {
                        "username": "vinaysaini2284",
                        "content": "[10,2],[5,5,2],[5,3,2,2],[6,3,3]"
                    }
                ]
            },
            {
                "id": 1571893,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "this is hard"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time limit is too hard for this one."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "Should be a hard problem indeed"
                    },
                    {
                        "username": "puzzle_machine",
                        "content": "This problem is a fine example why requirements engineering is so important. If any part of a specification allows wierd things, then it must also permit consequences of those oddities. In our case, it is suspicious that a matchstick can be of zero length. For all practical purposes we may regard this as *nonsense*. But this is not the worst issue. What irritates is that a square with zero side length is not accepeted as a valid shape.\\n\\nTry to enter the following test case `[0,0,0,0]`. It will be regarded as `False` by the official solution, although nothing more strange is entered here than what is already allowed. Namely, we have 4 zero length matchsticks that can nicely form a square of zero side length. All matchsticks would be used exactly once and all sides of the square would be equal."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "Well you should see the constraints of the question first"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "This problem should be in hard category"
                    },
                    {
                        "username": "autodino",
                        "content": "When I checked some of the fastest Python solutions, I see several wrong solutions -- Please just try case [2,3,3,3,3,3,3,3,3,4,4,5,13]!!! This case should be included in the test!"
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "This is should return a True"
                    },
                    {
                        "username": "122001034",
                        "content": "smaller version of partition to k equal sum subset problem; try it out"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "This is a crucial line!!! I used backtracking asusual. But it gave more than 2000ms. But putting a if condition optimised it to 46ms and gave me a 99.98% space. \nfor(int i=0;i<4;i++){\n            if(arr[i]>target)return false;\n            arr[i]+=m[idx];\n            if(backtrack(arr,m,idx+1,n,target))return true;\n            arr[i]-=m[idx];\n            if(arr[i]==0)break; // helps a lot in optimization\n}"
                    },
                    {
                        "username": "CodeJesus",
                        "content": "Are the matchsticks sorted? "
                    },
                    {
                        "username": "TheDictator11",
                        "content": "No. But if it helps you can always sort the matchsticks as the initial order doesn\\'t matter."
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello guys,\\nI am not able to figure out why the below solution gives TLE for the problem\\nPLease help if possible\\nThank you \\n \\n `class Solution {`\\n`public:`\\n`typedef long long int ll;`\\n\\n`int res;`\\n`vector<int> arr;`\\n`int n;`\\n`ll a,b,c,d;`\\n\\n    `int ways(int i)`\\n    `{`\\n     `   if(a>res || b>res ||c>res || d>res)`\\n        `return 0;`\\n\\n`if(i==n)`\\n`{`\\n `   if(a==b and b==c and c==d)`\\n`    {`\\n       ` return 1;`\\n    `}`\\n   ` else return 0;`\\n`}`\\n\\n`if(a+arr[i]<=res){`\\n`a+=arr[i];`\\n`int c1=ways(i+1);`\\n`if(c1)`\\n`return 1;`\\n`a-=arr[i];`\\n`}`\\n\\n`if(b+arr[i]<=res){\\nb+=arr[i];\\nint c2=ways(i+1);\\nif(c2)\\nreturn 1;\\nb-=arr[i];}\\n`\\n`if(c+arr[i]<=res){\\nc+=arr[i];\\nint c3=ways(i+1);\\nif(c3)\\nreturn 1;\\nc-=arr[i];\\n}\\n`\\n`if(d+arr[i]<=res){\\nd+=arr[i];\\nint c4=ways(i+1);\\nif(c4)\\nreturn 1;\\nd-=arr[i];}\\n`\\n\\n`return 0;`\\n        \\n `   }`\\n    `bool makesquare(vector<int>& m) {`\\n\\n\\n`  ll sum=0;`\\n  `arr=m;`\\n  `for(int i:m)`\\n  `{`\\n   `   sum+=i;`\\n\\n  `}`\\n  \\n  `if(sum%4!=0)`\\n  `return 0;`\\n   `res=sum/4;`\\n  `a=0;b=0;c=0;d=0;`\\n  `n=m.size();`\\n  `return ways(0);`\\n   ` }`\\n`};`\\n`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@tejasX](/tejasX) Hey I tried and this works.  Please explain why this works !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Sort it in DESC."
                    },
                    {
                        "username": "Suraj_20",
                        "content": "[10,6,5,5,5,3,3,3,2,2,2,2] \\nWhy this test case return true. Please make a square this test case..."
                    },
                    {
                        "username": "vinaysaini2284",
                        "content": "[10,2],[5,5,2],[5,3,2,2],[6,3,3]"
                    }
                ]
            },
            {
                "id": 1980780,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "this is hard"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time limit is too hard for this one."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "Should be a hard problem indeed"
                    },
                    {
                        "username": "puzzle_machine",
                        "content": "This problem is a fine example why requirements engineering is so important. If any part of a specification allows wierd things, then it must also permit consequences of those oddities. In our case, it is suspicious that a matchstick can be of zero length. For all practical purposes we may regard this as *nonsense*. But this is not the worst issue. What irritates is that a square with zero side length is not accepeted as a valid shape.\\n\\nTry to enter the following test case `[0,0,0,0]`. It will be regarded as `False` by the official solution, although nothing more strange is entered here than what is already allowed. Namely, we have 4 zero length matchsticks that can nicely form a square of zero side length. All matchsticks would be used exactly once and all sides of the square would be equal."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "Well you should see the constraints of the question first"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "This problem should be in hard category"
                    },
                    {
                        "username": "autodino",
                        "content": "When I checked some of the fastest Python solutions, I see several wrong solutions -- Please just try case [2,3,3,3,3,3,3,3,3,4,4,5,13]!!! This case should be included in the test!"
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "This is should return a True"
                    },
                    {
                        "username": "122001034",
                        "content": "smaller version of partition to k equal sum subset problem; try it out"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "This is a crucial line!!! I used backtracking asusual. But it gave more than 2000ms. But putting a if condition optimised it to 46ms and gave me a 99.98% space. \nfor(int i=0;i<4;i++){\n            if(arr[i]>target)return false;\n            arr[i]+=m[idx];\n            if(backtrack(arr,m,idx+1,n,target))return true;\n            arr[i]-=m[idx];\n            if(arr[i]==0)break; // helps a lot in optimization\n}"
                    },
                    {
                        "username": "CodeJesus",
                        "content": "Are the matchsticks sorted? "
                    },
                    {
                        "username": "TheDictator11",
                        "content": "No. But if it helps you can always sort the matchsticks as the initial order doesn\\'t matter."
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello guys,\\nI am not able to figure out why the below solution gives TLE for the problem\\nPLease help if possible\\nThank you \\n \\n `class Solution {`\\n`public:`\\n`typedef long long int ll;`\\n\\n`int res;`\\n`vector<int> arr;`\\n`int n;`\\n`ll a,b,c,d;`\\n\\n    `int ways(int i)`\\n    `{`\\n     `   if(a>res || b>res ||c>res || d>res)`\\n        `return 0;`\\n\\n`if(i==n)`\\n`{`\\n `   if(a==b and b==c and c==d)`\\n`    {`\\n       ` return 1;`\\n    `}`\\n   ` else return 0;`\\n`}`\\n\\n`if(a+arr[i]<=res){`\\n`a+=arr[i];`\\n`int c1=ways(i+1);`\\n`if(c1)`\\n`return 1;`\\n`a-=arr[i];`\\n`}`\\n\\n`if(b+arr[i]<=res){\\nb+=arr[i];\\nint c2=ways(i+1);\\nif(c2)\\nreturn 1;\\nb-=arr[i];}\\n`\\n`if(c+arr[i]<=res){\\nc+=arr[i];\\nint c3=ways(i+1);\\nif(c3)\\nreturn 1;\\nc-=arr[i];\\n}\\n`\\n`if(d+arr[i]<=res){\\nd+=arr[i];\\nint c4=ways(i+1);\\nif(c4)\\nreturn 1;\\nd-=arr[i];}\\n`\\n\\n`return 0;`\\n        \\n `   }`\\n    `bool makesquare(vector<int>& m) {`\\n\\n\\n`  ll sum=0;`\\n  `arr=m;`\\n  `for(int i:m)`\\n  `{`\\n   `   sum+=i;`\\n\\n  `}`\\n  \\n  `if(sum%4!=0)`\\n  `return 0;`\\n   `res=sum/4;`\\n  `a=0;b=0;c=0;d=0;`\\n  `n=m.size();`\\n  `return ways(0);`\\n   ` }`\\n`};`\\n`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@tejasX](/tejasX) Hey I tried and this works.  Please explain why this works !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Sort it in DESC."
                    },
                    {
                        "username": "Suraj_20",
                        "content": "[10,6,5,5,5,3,3,3,2,2,2,2] \\nWhy this test case return true. Please make a square this test case..."
                    },
                    {
                        "username": "vinaysaini2284",
                        "content": "[10,2],[5,5,2],[5,3,2,2],[6,3,3]"
                    }
                ]
            },
            {
                "id": 1951200,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "this is hard"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time limit is too hard for this one."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "Should be a hard problem indeed"
                    },
                    {
                        "username": "puzzle_machine",
                        "content": "This problem is a fine example why requirements engineering is so important. If any part of a specification allows wierd things, then it must also permit consequences of those oddities. In our case, it is suspicious that a matchstick can be of zero length. For all practical purposes we may regard this as *nonsense*. But this is not the worst issue. What irritates is that a square with zero side length is not accepeted as a valid shape.\\n\\nTry to enter the following test case `[0,0,0,0]`. It will be regarded as `False` by the official solution, although nothing more strange is entered here than what is already allowed. Namely, we have 4 zero length matchsticks that can nicely form a square of zero side length. All matchsticks would be used exactly once and all sides of the square would be equal."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "Well you should see the constraints of the question first"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "This problem should be in hard category"
                    },
                    {
                        "username": "autodino",
                        "content": "When I checked some of the fastest Python solutions, I see several wrong solutions -- Please just try case [2,3,3,3,3,3,3,3,3,4,4,5,13]!!! This case should be included in the test!"
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "This is should return a True"
                    },
                    {
                        "username": "122001034",
                        "content": "smaller version of partition to k equal sum subset problem; try it out"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "This is a crucial line!!! I used backtracking asusual. But it gave more than 2000ms. But putting a if condition optimised it to 46ms and gave me a 99.98% space. \nfor(int i=0;i<4;i++){\n            if(arr[i]>target)return false;\n            arr[i]+=m[idx];\n            if(backtrack(arr,m,idx+1,n,target))return true;\n            arr[i]-=m[idx];\n            if(arr[i]==0)break; // helps a lot in optimization\n}"
                    },
                    {
                        "username": "CodeJesus",
                        "content": "Are the matchsticks sorted? "
                    },
                    {
                        "username": "TheDictator11",
                        "content": "No. But if it helps you can always sort the matchsticks as the initial order doesn\\'t matter."
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello guys,\\nI am not able to figure out why the below solution gives TLE for the problem\\nPLease help if possible\\nThank you \\n \\n `class Solution {`\\n`public:`\\n`typedef long long int ll;`\\n\\n`int res;`\\n`vector<int> arr;`\\n`int n;`\\n`ll a,b,c,d;`\\n\\n    `int ways(int i)`\\n    `{`\\n     `   if(a>res || b>res ||c>res || d>res)`\\n        `return 0;`\\n\\n`if(i==n)`\\n`{`\\n `   if(a==b and b==c and c==d)`\\n`    {`\\n       ` return 1;`\\n    `}`\\n   ` else return 0;`\\n`}`\\n\\n`if(a+arr[i]<=res){`\\n`a+=arr[i];`\\n`int c1=ways(i+1);`\\n`if(c1)`\\n`return 1;`\\n`a-=arr[i];`\\n`}`\\n\\n`if(b+arr[i]<=res){\\nb+=arr[i];\\nint c2=ways(i+1);\\nif(c2)\\nreturn 1;\\nb-=arr[i];}\\n`\\n`if(c+arr[i]<=res){\\nc+=arr[i];\\nint c3=ways(i+1);\\nif(c3)\\nreturn 1;\\nc-=arr[i];\\n}\\n`\\n`if(d+arr[i]<=res){\\nd+=arr[i];\\nint c4=ways(i+1);\\nif(c4)\\nreturn 1;\\nd-=arr[i];}\\n`\\n\\n`return 0;`\\n        \\n `   }`\\n    `bool makesquare(vector<int>& m) {`\\n\\n\\n`  ll sum=0;`\\n  `arr=m;`\\n  `for(int i:m)`\\n  `{`\\n   `   sum+=i;`\\n\\n  `}`\\n  \\n  `if(sum%4!=0)`\\n  `return 0;`\\n   `res=sum/4;`\\n  `a=0;b=0;c=0;d=0;`\\n  `n=m.size();`\\n  `return ways(0);`\\n   ` }`\\n`};`\\n`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@tejasX](/tejasX) Hey I tried and this works.  Please explain why this works !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Sort it in DESC."
                    },
                    {
                        "username": "Suraj_20",
                        "content": "[10,6,5,5,5,3,3,3,2,2,2,2] \\nWhy this test case return true. Please make a square this test case..."
                    },
                    {
                        "username": "vinaysaini2284",
                        "content": "[10,2],[5,5,2],[5,3,2,2],[6,3,3]"
                    }
                ]
            },
            {
                "id": 2013985,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "this is hard"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time limit is too hard for this one."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "Should be a hard problem indeed"
                    },
                    {
                        "username": "puzzle_machine",
                        "content": "This problem is a fine example why requirements engineering is so important. If any part of a specification allows wierd things, then it must also permit consequences of those oddities. In our case, it is suspicious that a matchstick can be of zero length. For all practical purposes we may regard this as *nonsense*. But this is not the worst issue. What irritates is that a square with zero side length is not accepeted as a valid shape.\\n\\nTry to enter the following test case `[0,0,0,0]`. It will be regarded as `False` by the official solution, although nothing more strange is entered here than what is already allowed. Namely, we have 4 zero length matchsticks that can nicely form a square of zero side length. All matchsticks would be used exactly once and all sides of the square would be equal."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "Well you should see the constraints of the question first"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "This problem should be in hard category"
                    },
                    {
                        "username": "autodino",
                        "content": "When I checked some of the fastest Python solutions, I see several wrong solutions -- Please just try case [2,3,3,3,3,3,3,3,3,4,4,5,13]!!! This case should be included in the test!"
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "This is should return a True"
                    },
                    {
                        "username": "122001034",
                        "content": "smaller version of partition to k equal sum subset problem; try it out"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "This is a crucial line!!! I used backtracking asusual. But it gave more than 2000ms. But putting a if condition optimised it to 46ms and gave me a 99.98% space. \nfor(int i=0;i<4;i++){\n            if(arr[i]>target)return false;\n            arr[i]+=m[idx];\n            if(backtrack(arr,m,idx+1,n,target))return true;\n            arr[i]-=m[idx];\n            if(arr[i]==0)break; // helps a lot in optimization\n}"
                    },
                    {
                        "username": "CodeJesus",
                        "content": "Are the matchsticks sorted? "
                    },
                    {
                        "username": "TheDictator11",
                        "content": "No. But if it helps you can always sort the matchsticks as the initial order doesn\\'t matter."
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello guys,\\nI am not able to figure out why the below solution gives TLE for the problem\\nPLease help if possible\\nThank you \\n \\n `class Solution {`\\n`public:`\\n`typedef long long int ll;`\\n\\n`int res;`\\n`vector<int> arr;`\\n`int n;`\\n`ll a,b,c,d;`\\n\\n    `int ways(int i)`\\n    `{`\\n     `   if(a>res || b>res ||c>res || d>res)`\\n        `return 0;`\\n\\n`if(i==n)`\\n`{`\\n `   if(a==b and b==c and c==d)`\\n`    {`\\n       ` return 1;`\\n    `}`\\n   ` else return 0;`\\n`}`\\n\\n`if(a+arr[i]<=res){`\\n`a+=arr[i];`\\n`int c1=ways(i+1);`\\n`if(c1)`\\n`return 1;`\\n`a-=arr[i];`\\n`}`\\n\\n`if(b+arr[i]<=res){\\nb+=arr[i];\\nint c2=ways(i+1);\\nif(c2)\\nreturn 1;\\nb-=arr[i];}\\n`\\n`if(c+arr[i]<=res){\\nc+=arr[i];\\nint c3=ways(i+1);\\nif(c3)\\nreturn 1;\\nc-=arr[i];\\n}\\n`\\n`if(d+arr[i]<=res){\\nd+=arr[i];\\nint c4=ways(i+1);\\nif(c4)\\nreturn 1;\\nd-=arr[i];}\\n`\\n\\n`return 0;`\\n        \\n `   }`\\n    `bool makesquare(vector<int>& m) {`\\n\\n\\n`  ll sum=0;`\\n  `arr=m;`\\n  `for(int i:m)`\\n  `{`\\n   `   sum+=i;`\\n\\n  `}`\\n  \\n  `if(sum%4!=0)`\\n  `return 0;`\\n   `res=sum/4;`\\n  `a=0;b=0;c=0;d=0;`\\n  `n=m.size();`\\n  `return ways(0);`\\n   ` }`\\n`};`\\n`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@tejasX](/tejasX) Hey I tried and this works.  Please explain why this works !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Sort it in DESC."
                    },
                    {
                        "username": "Suraj_20",
                        "content": "[10,6,5,5,5,3,3,3,2,2,2,2] \\nWhy this test case return true. Please make a square this test case..."
                    },
                    {
                        "username": "vinaysaini2284",
                        "content": "[10,2],[5,5,2],[5,3,2,2],[6,3,3]"
                    }
                ]
            },
            {
                "id": 1777515,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "this is hard"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time limit is too hard for this one."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "Should be a hard problem indeed"
                    },
                    {
                        "username": "puzzle_machine",
                        "content": "This problem is a fine example why requirements engineering is so important. If any part of a specification allows wierd things, then it must also permit consequences of those oddities. In our case, it is suspicious that a matchstick can be of zero length. For all practical purposes we may regard this as *nonsense*. But this is not the worst issue. What irritates is that a square with zero side length is not accepeted as a valid shape.\\n\\nTry to enter the following test case `[0,0,0,0]`. It will be regarded as `False` by the official solution, although nothing more strange is entered here than what is already allowed. Namely, we have 4 zero length matchsticks that can nicely form a square of zero side length. All matchsticks would be used exactly once and all sides of the square would be equal."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "Well you should see the constraints of the question first"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "This problem should be in hard category"
                    },
                    {
                        "username": "autodino",
                        "content": "When I checked some of the fastest Python solutions, I see several wrong solutions -- Please just try case [2,3,3,3,3,3,3,3,3,4,4,5,13]!!! This case should be included in the test!"
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "This is should return a True"
                    },
                    {
                        "username": "122001034",
                        "content": "smaller version of partition to k equal sum subset problem; try it out"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "This is a crucial line!!! I used backtracking asusual. But it gave more than 2000ms. But putting a if condition optimised it to 46ms and gave me a 99.98% space. \nfor(int i=0;i<4;i++){\n            if(arr[i]>target)return false;\n            arr[i]+=m[idx];\n            if(backtrack(arr,m,idx+1,n,target))return true;\n            arr[i]-=m[idx];\n            if(arr[i]==0)break; // helps a lot in optimization\n}"
                    },
                    {
                        "username": "CodeJesus",
                        "content": "Are the matchsticks sorted? "
                    },
                    {
                        "username": "TheDictator11",
                        "content": "No. But if it helps you can always sort the matchsticks as the initial order doesn\\'t matter."
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello guys,\\nI am not able to figure out why the below solution gives TLE for the problem\\nPLease help if possible\\nThank you \\n \\n `class Solution {`\\n`public:`\\n`typedef long long int ll;`\\n\\n`int res;`\\n`vector<int> arr;`\\n`int n;`\\n`ll a,b,c,d;`\\n\\n    `int ways(int i)`\\n    `{`\\n     `   if(a>res || b>res ||c>res || d>res)`\\n        `return 0;`\\n\\n`if(i==n)`\\n`{`\\n `   if(a==b and b==c and c==d)`\\n`    {`\\n       ` return 1;`\\n    `}`\\n   ` else return 0;`\\n`}`\\n\\n`if(a+arr[i]<=res){`\\n`a+=arr[i];`\\n`int c1=ways(i+1);`\\n`if(c1)`\\n`return 1;`\\n`a-=arr[i];`\\n`}`\\n\\n`if(b+arr[i]<=res){\\nb+=arr[i];\\nint c2=ways(i+1);\\nif(c2)\\nreturn 1;\\nb-=arr[i];}\\n`\\n`if(c+arr[i]<=res){\\nc+=arr[i];\\nint c3=ways(i+1);\\nif(c3)\\nreturn 1;\\nc-=arr[i];\\n}\\n`\\n`if(d+arr[i]<=res){\\nd+=arr[i];\\nint c4=ways(i+1);\\nif(c4)\\nreturn 1;\\nd-=arr[i];}\\n`\\n\\n`return 0;`\\n        \\n `   }`\\n    `bool makesquare(vector<int>& m) {`\\n\\n\\n`  ll sum=0;`\\n  `arr=m;`\\n  `for(int i:m)`\\n  `{`\\n   `   sum+=i;`\\n\\n  `}`\\n  \\n  `if(sum%4!=0)`\\n  `return 0;`\\n   `res=sum/4;`\\n  `a=0;b=0;c=0;d=0;`\\n  `n=m.size();`\\n  `return ways(0);`\\n   ` }`\\n`};`\\n`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@tejasX](/tejasX) Hey I tried and this works.  Please explain why this works !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Sort it in DESC."
                    },
                    {
                        "username": "Suraj_20",
                        "content": "[10,6,5,5,5,3,3,3,2,2,2,2] \\nWhy this test case return true. Please make a square this test case..."
                    },
                    {
                        "username": "vinaysaini2284",
                        "content": "[10,2],[5,5,2],[5,3,2,2],[6,3,3]"
                    }
                ]
            },
            {
                "id": 1759112,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "this is hard"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time limit is too hard for this one."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "Should be a hard problem indeed"
                    },
                    {
                        "username": "puzzle_machine",
                        "content": "This problem is a fine example why requirements engineering is so important. If any part of a specification allows wierd things, then it must also permit consequences of those oddities. In our case, it is suspicious that a matchstick can be of zero length. For all practical purposes we may regard this as *nonsense*. But this is not the worst issue. What irritates is that a square with zero side length is not accepeted as a valid shape.\\n\\nTry to enter the following test case `[0,0,0,0]`. It will be regarded as `False` by the official solution, although nothing more strange is entered here than what is already allowed. Namely, we have 4 zero length matchsticks that can nicely form a square of zero side length. All matchsticks would be used exactly once and all sides of the square would be equal."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "Well you should see the constraints of the question first"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "This problem should be in hard category"
                    },
                    {
                        "username": "autodino",
                        "content": "When I checked some of the fastest Python solutions, I see several wrong solutions -- Please just try case [2,3,3,3,3,3,3,3,3,4,4,5,13]!!! This case should be included in the test!"
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "This is should return a True"
                    },
                    {
                        "username": "122001034",
                        "content": "smaller version of partition to k equal sum subset problem; try it out"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "This is a crucial line!!! I used backtracking asusual. But it gave more than 2000ms. But putting a if condition optimised it to 46ms and gave me a 99.98% space. \nfor(int i=0;i<4;i++){\n            if(arr[i]>target)return false;\n            arr[i]+=m[idx];\n            if(backtrack(arr,m,idx+1,n,target))return true;\n            arr[i]-=m[idx];\n            if(arr[i]==0)break; // helps a lot in optimization\n}"
                    },
                    {
                        "username": "CodeJesus",
                        "content": "Are the matchsticks sorted? "
                    },
                    {
                        "username": "TheDictator11",
                        "content": "No. But if it helps you can always sort the matchsticks as the initial order doesn\\'t matter."
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello guys,\\nI am not able to figure out why the below solution gives TLE for the problem\\nPLease help if possible\\nThank you \\n \\n `class Solution {`\\n`public:`\\n`typedef long long int ll;`\\n\\n`int res;`\\n`vector<int> arr;`\\n`int n;`\\n`ll a,b,c,d;`\\n\\n    `int ways(int i)`\\n    `{`\\n     `   if(a>res || b>res ||c>res || d>res)`\\n        `return 0;`\\n\\n`if(i==n)`\\n`{`\\n `   if(a==b and b==c and c==d)`\\n`    {`\\n       ` return 1;`\\n    `}`\\n   ` else return 0;`\\n`}`\\n\\n`if(a+arr[i]<=res){`\\n`a+=arr[i];`\\n`int c1=ways(i+1);`\\n`if(c1)`\\n`return 1;`\\n`a-=arr[i];`\\n`}`\\n\\n`if(b+arr[i]<=res){\\nb+=arr[i];\\nint c2=ways(i+1);\\nif(c2)\\nreturn 1;\\nb-=arr[i];}\\n`\\n`if(c+arr[i]<=res){\\nc+=arr[i];\\nint c3=ways(i+1);\\nif(c3)\\nreturn 1;\\nc-=arr[i];\\n}\\n`\\n`if(d+arr[i]<=res){\\nd+=arr[i];\\nint c4=ways(i+1);\\nif(c4)\\nreturn 1;\\nd-=arr[i];}\\n`\\n\\n`return 0;`\\n        \\n `   }`\\n    `bool makesquare(vector<int>& m) {`\\n\\n\\n`  ll sum=0;`\\n  `arr=m;`\\n  `for(int i:m)`\\n  `{`\\n   `   sum+=i;`\\n\\n  `}`\\n  \\n  `if(sum%4!=0)`\\n  `return 0;`\\n   `res=sum/4;`\\n  `a=0;b=0;c=0;d=0;`\\n  `n=m.size();`\\n  `return ways(0);`\\n   ` }`\\n`};`\\n`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@tejasX](/tejasX) Hey I tried and this works.  Please explain why this works !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Sort it in DESC."
                    },
                    {
                        "username": "Suraj_20",
                        "content": "[10,6,5,5,5,3,3,3,2,2,2,2] \\nWhy this test case return true. Please make a square this test case..."
                    },
                    {
                        "username": "vinaysaini2284",
                        "content": "[10,2],[5,5,2],[5,3,2,2],[6,3,3]"
                    }
                ]
            }
        ]
    }
]