[
    {
        "title": "Set Matrix Zeroes",
        "question_content": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.\n&nbsp;\nExample 1:\n\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n\nExample 2:\n\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n&nbsp;\nConstraints:\n\n\tm == matrix.length\n\tn == matrix[0].length\n\t1 <= m, n <= 200\n\t-231 <= matrix[i][j] <= 231 - 1\n\n&nbsp;\nFollow up:\n\n\tA straightforward solution using O(mn) space is probably a bad idea.\n\tA simple improvement uses O(m + n) space, but still not the best solution.\n\tCould you devise a constant space solution?",
        "solutions": [
            {
                "id": 26014,
                "title": "any-shorter-o-1-space-solution",
                "content": "My idea is simple: store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable \"col0\" for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way.\\n\\n    void setZeroes(vector<vector<int> > &matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n    \\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) col0 = 0;\\n            for (int j = 1; j < cols; j++)\\n                if (matrix[i][j] == 0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n    \\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "My idea is simple: store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable \"col0\" for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way.\\n\\n    void setZeroes(vector<vector<int> > &matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n    \\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) col0 = 0;\\n            for (int j = 1; j < cols; j++)\\n                if (matrix[i][j] == 0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n    \\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26008,
                "title": "my-ac-java-o-1-solution-easy-to-read",
                "content": "    public class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean fr = false,fc = false;\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                if(matrix[i][j] == 0) {\\n                    if(i == 0) fr = true;\\n                    if(j == 0) fc = true;\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 1; i < matrix.length; i++) {\\n            for(int j = 1; j < matrix[0].length; j++) {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(fr) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                matrix[0][j] = 0;\\n            }\\n        }\\n        if(fc) {\\n            for(int i = 0; i < matrix.length; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean fr = false,fc = false;\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                if(matrix[i][j] == 0) {\\n                    if(i == 0) fr = true;\\n                    if(j == 0) fc = true;\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3172908,
                "title": "best-c-4-solution-hash-table-matrix-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Four approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Matrix with Extra space.  TC : O((N*M)*(N+M)),  SC : O(N*M).\\n2. Solved using Matrix with Constant space.  TC : O((N*M)*(N+M)),  SC : O(1).\\n3. Solved using Array + Hash Table (Unordered set).  TC : O(N*M),  SC : O(N+M).\\n4. Solved using Matrix with Constant space.  Optimized Approaches.  TC : O(N*M),  SC : O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M) for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(N*M), visited matrix space.\\n\\n    Solved using Matrix with Extra space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> visited = matrix;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        visited[i][k] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        visited[k][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = visited[i][j];\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M)for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        if(matrix[i][k] != 0){\\n                            matrix[i][k] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        if(matrix[k][j] != 0){\\n                            matrix[k][j] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == -9999){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(N+M), Here Unordered set(setRows and setColumn) creates the space complexity. O(N) for\\n    storing the row indexs and O(M) for storing the column indexs.\\n\\n    Solved using Matrix + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        unordered_set<int> setRows; \\n        unordered_set<int> setColumns; \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    setRows.insert(i);\\n                    setColumns.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(setRows.count(i) > 0 || setColumns.count(j) > 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        bool flag1 = false, flag2 = false;\\n        for(int i=0; i<n; i++){\\n            if(matrix[i][0] == 0){\\n                flag1 = true;\\n            }\\n        }\\n        for(int j=0; j<m; j++){\\n            if(matrix[0][j] == 0){\\n                flag2 = true;\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(flag1 == true){\\n            for(int i=0; i<n; i++){\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        if(flag2 == true){\\n            for(int j=0; j<m; j++){\\n                matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n};\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M) for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(N*M), visited matrix space.\\n\\n    Solved using Matrix with Extra space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> visited = matrix;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        visited[i][k] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        visited[k][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = visited[i][j];\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M)for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        if(matrix[i][k] != 0){\\n                            matrix[i][k] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        if(matrix[k][j] != 0){\\n                            matrix[k][j] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == -9999){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(N+M), Here Unordered set(setRows and setColumn) creates the space complexity. O(N) for\\n    storing the row indexs and O(M) for storing the column indexs.\\n\\n    Solved using Matrix + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        unordered_set<int> setRows; \\n        unordered_set<int> setColumns; \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    setRows.insert(i);\\n                    setColumns.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(setRows.count(i) > 0 || setColumns.count(j) > 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        bool flag1 = false, flag2 = false;\\n        for(int i=0; i<n; i++){\\n            if(matrix[i][0] == 0){\\n                flag1 = true;\\n            }\\n        }\\n        for(int j=0; j<m; j++){\\n            if(matrix[0][j] == 0){\\n                flag2 = true;\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(flag1 == true){\\n            for(int i=0; i<n; i++){\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        if(flag2 == true){\\n            for(int j=0; j<m; j++){\\n                matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525398,
                "title": "all-approaches-from-brute-force-to-optimal-with-easy-explanation",
                "content": "**Method 1:** (Brute force)\\n-using another matrix (let\\'s say it matrix2)\\n1. we can copy all the elements of given matrix to matrix2\\n2. while traversing given matrix whenever we encounter 0, we will make the entire row and column of the matrix2 to 0\\n3. finally we can again copy all the elements of matrix2 to given matrix\\n-**Time:** $$O((mn)*(m+n))$$, **Space:** $$O(mn)$$\\n\\n![image](https://assets.leetcode.com/users/images/edb17693-61dd-424b-88e7-f37b79c602f1_1662224098.764936.png)\\n\\n\\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m= matrix.length, n= matrix[0].length;\\n        int matrix2[][]= new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix2[i][j]=matrix[i][j];\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    for(int k=0;k<n;k++)\\n                        matrix2[i][k]=0;\\n\\n                    for(int k=0;k<m;k++)\\n                        matrix2[k][j]=0;\\n                }\\n            }\\n        }\\n    \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix[i][j]=matrix2[i][j];\\n        }\\n    }\\n```\\n\\n\\n**Method 2:** (Better)\\n1. we can use two separate arrays one for rows (rowsArray) and one for columns (colsArray) and initialize them to 1\\n2. while traversing the given matrix whenever we encounter 0 at (i,j), we will set rowsArray[i]=0 and colsArray[j]=0\\n3. After completion of step 2, again iterate through the matrix and for any (i,j), if rowsArray[i] or colsArray[j] is 0 then update matrix[i][j] to 0.\\n-**Time:** $$O(mn)$$, **Space:** $$O(m+n)$$\\n\\n![image](https://assets.leetcode.com/users/images/985c05ee-ba5b-43ec-a7c2-41983d8bdae1_1662224319.5420349.png)\\n\\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        int rowsArray[]= new int[m];\\n        int colsArray[]= new int[n];\\n        \\n        Arrays.fill(rowsArray,1);\\n        Arrays.fill(colsArray,1);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    rowsArray[i]=0;\\n                    colsArray[j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(rowsArray[i]==0 || colsArray[j]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n    }\\n```\\n\\n**Method 3:** (Optimal)\\n-we can use the 0th row and 0th column of the given matrix itself instead of using two separate arrays\\n1. first we will traverse the 0th row and 0th column of the given matrix and if we encounter any 0 then we will set the isRow0/isCol0 variable to true which indicates that the 0th row/0th column of the given matrix will become 0\\n2. next we will traverse the remaining matrix except 0th row and 0th column and if we encounter any 0, we will make the corresponding row no. and column no. equal to 0 in the 0th column and 0th row respectively\\n3. Now we will update the values of the matrix except first row and first column to 0 if matrix[i][0]=0 or matrix[0][j]=0 for any (i,j).\\n4. finally we will traverse the 0th row and 0th column and if we find any 0, we will make the whole row and whole column equal to 0\\n-**Time:** $$O(mn)$$, **Space:** $$O(1)$$\\n\\n![image](https://assets.leetcode.com/users/images/75193089-d14a-4cf9-aacf-5f97cc935f02_1662224420.9994516.png)\\n\\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        boolean isRow0=false, isCol0=false;\\n        \\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0)\\n                isRow0=true;\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0)\\n                isCol0=true;\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[0][j]==0 || matrix[i][0]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n        if(isRow0){\\n            for(int j=0;j<n;j++)\\n                matrix[0][j]=0;\\n        }\\n        \\n        if(isCol0){\\n            for(int i=0;i<m;i++)\\n                matrix[i][0]=0;\\n        }\\n    }\\n```\\n\\nDon\\'t forget to upvote if you find it helpful! \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m= matrix.length, n= matrix[0].length;\\n        int matrix2[][]= new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix2[i][j]=matrix[i][j];\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    for(int k=0;k<n;k++)\\n                        matrix2[i][k]=0;\\n\\n                    for(int k=0;k<m;k++)\\n                        matrix2[k][j]=0;\\n                }\\n            }\\n        }\\n    \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix[i][j]=matrix2[i][j];\\n        }\\n    }\\n```\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        int rowsArray[]= new int[m];\\n        int colsArray[]= new int[n];\\n        \\n        Arrays.fill(rowsArray,1);\\n        Arrays.fill(colsArray,1);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    rowsArray[i]=0;\\n                    colsArray[j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(rowsArray[i]==0 || colsArray[j]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n    }\\n```\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        boolean isRow0=false, isCol0=false;\\n        \\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0)\\n                isRow0=true;\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0)\\n                isCol0=true;\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[0][j]==0 || matrix[i][0]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n        if(isRow0){\\n            for(int j=0;j<n;j++)\\n                matrix[0][j]=0;\\n        }\\n        \\n        if(isCol0){\\n            for(int i=0;i<m;i++)\\n                matrix[i][0]=0;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3472518,
                "title": "full-explanation-super-easy-constant-space",
                "content": "# Intuition\\nIn this approach, we can just improve the space complexity. So, instead of using two extra matrices row and col, we will use the 1st row and 1st column of the given matrix to keep a track of the cells that need to be marked with 0. But here comes a problem. If we try to use the 1st row and 1st column to serve the purpose, the cell matrix[0][0] is taken twice. To solve this problem we will take an extra variable col0 initialized with 1. Now the entire 1st row of the matrix will serve the purpose of the row array. And the 1st column from (0,1) to (0,m-1) with the col0 variable will serve the purpose of the col array\\n\\n![image.png](https://assets.leetcode.com/users/images/5e4c94b5-ea1e-4ca5-a166-9a014d49e001_1682924194.5173662.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe steps are as follows:\\n\\nFirst, we will traverse the matrix and mark the proper cells of 1st row and 1st column with 0 accordingly. The marking will be like this: if cell(i, j) contains 0, we will mark the i-th row i.e. matrix[i][0] with 0 and we will mark j-th column i.e. matrix[0][j] with 0.\\nIf i is 0, we will mark matrix[0][0] with 0 but if j is 0, we will mark the col0 variable with 0 instead of marking matrix[0][0] again.\\n\\nAfter step 1 is completed, we will modify the cells from (1,1) to (n-1, m-1) using the values from the 1st row, 1st column, and col0 variable.\\n\\nWe will not modify the 1st row and 1st column of the matrix here as the modification of the rest of the matrix(i.e. From (1,1) to (n-1, m-1)) is dependent on that row and column.\\n\\nFinally, we will change the 1st row and column using the values from matrix[0][0] and col0 variable. Here also we will change the row first and then the column.\\n\\nIf matrix[0][0] = 0, we will change all the elements from the cell (0,1) to (0, m-1), to 0.\\nIf col0 = 0, we will change all the elements from the cell (0,0) to (n-1, 0), to 0. Note that the above approach is provided by Striver on youtube.\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/e3a4d44d-7ade-4acb-8e2e-6cdc257505f3_1682924171.8253722.png)\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\npublic void setZeroes(int[][] matrix) {\\n    boolean fr = false,fc = false;\\n    for(int i = 0; i < matrix.length; i++) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            if(matrix[i][j] == 0) {\\n                if(i == 0) fr = true;\\n                if(j == 0) fc = true;\\n                matrix[0][j] = 0;\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n    for(int i = 1; i < matrix.length; i++) {\\n        for(int j = 1; j < matrix[0].length; j++) {\\n            if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                matrix[i][j] = 0;\\n        }}\\n    }\\n    if(fr) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if(fc) {\\n        for(int i = 0; i < matrix.length; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n}}  \\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/43fc6382-7684-43ad-91e9-cea1908663b6_1682924250.7315671.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\npublic void setZeroes(int[][] matrix) {\\n    boolean fr = false,fc = false;\\n    for(int i = 0; i < matrix.length; i++) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            if(matrix[i][j] == 0) {\\n                if(i == 0) fr = true;\\n                if(j == 0) fc = true;\\n                matrix[0][j] = 0;\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n    for(int i = 1; i < matrix.length; i++) {\\n        for(int j = 1; j < matrix[0].length; j++) {\\n            if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                matrix[i][j] = 0;\\n        }}\\n    }\\n    if(fr) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if(fc) {\\n        for(int i = 0; i < matrix.length; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n}}  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657430,
                "title": "python-solution-w-approach-explanation-readable-with-space-progression-from-o-m-n-o-1",
                "content": "Note: m = number of rows, n = number of cols\\n\\n**Brute force using O(m*n) space:** The initial approach is to start with creating another matrix to store the result. From doing that, you\\'ll notice that we want a way to know when each row and col should be changed to zero. We don\\'t want to prematurely change the values in the matrix to zero because as we go through it, we might change a row to 0 because of the new value. \\n\\n**More optimized using O(m + n) space:** To do better, we want O(m + n). How do we go about that? Well, we really just need a way to track if any row or any col has a zero, because then that means the entire row or col has to be zero. Ok, well, then we can use an array to track the zeroes for the row and zeros for the col. Whenever we see a zero, just set that row or col to be True.\\n\\nSpace: O(m + n) for the zeroes_row and zeroes_col array \\n``` Python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        # input validation\\n        if not matrix:\\n            return []\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n         zeroes_row = [False] * m\\n         zeroes_col = [False] * n\\n         for row in range(m):\\n             for col in range(n):\\n                 if matrix[row][col] == 0:\\n                     zeroes_row[row] = True\\n                     zeroes_col[col] = True\\n\\n         for row in range(m):\\n             for col in range(n):\\n                 if zeroes_row[row] or zeroes_col[col]:\\n                     matrix[row][col] = 0\\n```\\n\\n**Most optimized using O(1) space:** But, we can do even better, O(1) - initial ask of the problem. What if instead of having a separate array to track the zeroes, we simply use the first row or col to track them and then go back to update the first row and col with zeroes after we\\'re done replacing it? The approach to get constant space is to use first row and first col of the matrix as a tracker. \\n* At each row or col, if you see a zero, then mark the first row or first col as zero with the current row and col. \\n* Then iterate through the array again to see where the first row and col were marked as zero and then set that row/col as 0. \\n* After doing that, you\\'ll need to traverse through the first row and/or first col if there were any zeroes there to begin with and set everything to be equal to 0 in the first row and/or first col. \\n\\nTime complexity for all three progression is O(m * n).\\n\\n\\n\\n**Space:** O(1) for modification in place and using the first row and first col to keep track of zeros instead of zeroes_row and zeroes_col\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\t\\t\\n        first_row_has_zero = False\\n        first_col_has_zero = False\\n        \\n        # iterate through matrix to mark the zero row and cols\\n        for row in range(m):\\n            for col in range(n):\\n                if matrix[row][col] == 0:\\n                    if row == 0:\\n                        first_row_has_zero = True\\n                    if col == 0:\\n                        first_col_has_zero = True\\n                    matrix[row][0] = matrix[0][col] = 0\\n    \\n        # iterate through matrix to update the cell to be zero if it\\'s in a zero row or col\\n        for row in range(1, m):\\n            for col in range(1, n):\\n                matrix[row][col] = 0 if matrix[0][col] == 0 or matrix[row][0] == 0 else matrix[row][col]\\n        \\n        # update the first row and col if they\\'re zero\\n        if first_row_has_zero:\\n            for col in range(n):\\n                matrix[0][col] = 0\\n        \\n        if first_col_has_zero:\\n            for row in range(m):\\n                matrix[row][0] = 0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` Python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        # input validation\\n        if not matrix:\\n            return []\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n         zeroes_row = [False] * m\\n         zeroes_col = [False] * n\\n         for row in range(m):\\n             for col in range(n):\\n                 if matrix[row][col] == 0:\\n                     zeroes_row[row] = True\\n                     zeroes_col[col] = True\\n\\n         for row in range(m):\\n             for col in range(n):\\n                 if zeroes_row[row] or zeroes_col[col]:\\n                     matrix[row][col] = 0\\n```\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\t\\t\\n        first_row_has_zero = False\\n        first_col_has_zero = False\\n        \\n        # iterate through matrix to mark the zero row and cols\\n        for row in range(m):\\n            for col in range(n):\\n                if matrix[row][col] == 0:\\n                    if row == 0:\\n                        first_row_has_zero = True\\n                    if col == 0:\\n                        first_col_has_zero = True\\n                    matrix[row][0] = matrix[0][col] = 0\\n    \\n        # iterate through matrix to update the cell to be zero if it\\'s in a zero row or col\\n        for row in range(1, m):\\n            for col in range(1, n):\\n                matrix[row][col] = 0 if matrix[0][col] == 0 or matrix[row][0] == 0 else matrix[row][col]\\n        \\n        # update the first row and col if they\\'re zero\\n        if first_row_has_zero:\\n            for col in range(n):\\n                matrix[0][col] = 0\\n        \\n        if first_col_has_zero:\\n            for row in range(m):\\n                matrix[row][0] = 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 26113,
                "title": "21-lines-concise-and-easy-understand-c-solution-o-1-space-three-steps",
                "content": "    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            bool row = false, col = false;\\n            for(int i = 0; i < matrix.size(); i++){\\n                for(int j = 0; j < matrix[0].size(); j++){\\n                    if(matrix[i][j] == 0) {\\n                        if(i == 0) row = true;\\n                        if(j == 0) col = true;\\n                        matrix[0][j] = matrix[i][0] = 0;\\n                    }\\n                }\\n            }\\n            for(int i = 1; i < matrix.size(); i++){\\n                for(int j = 1; j < matrix[0].size(); j++){\\n                    if(matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;\\n                }\\n            }\\n            if(col){\\n                for(int i = 0; i < matrix.size(); i++) matrix[i][0] = 0;\\n            }\\n            if(row){\\n                for(int j = 0; j < matrix[0].size(); j++) matrix[0][j] = 0;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            bool row = false, col = false;\\n            for(int i = 0; i < matrix.size(); i++){\\n                for(int j = 0; j < matrix[0].size(); j++){\\n                    if(matrix[i][j] == 0) {\\n                        if(i == 0) row = true;\\n                        if(j == 0) col = true;\\n                        matrix[0][j] = matrix[i][0] = 0;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1400849,
                "title": "set-matrix-zeroes-2-approach-w-explanation-c-python-java",
                "content": "**OBSERVATION:**\\nThe time complexity of this problem remains `O(M*N)`, the only improvement we can do is of the space complexity. So we will have 2 approaches here\\n\\n# **APPROACH I:**\\n*Additional Memory Approach-*\\nIf any cell of the matrix has a zero we can record its row and column number. All the cells of this recorded row and column can be marked zero in the next iteration.\\n\\n**Algorithm**\\n* We iterate over the original array and look for zero entries.\\n* If we find that an entry at `[i, j]` is `0`, then we need to record somewhere the row `i` and column `j`.\\n* So, we use two sets, one for the rows and one for the columns.\\n```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\\n*  We iterate over the array once again, and check each cell.\\n\\t*  If the row **Or** column is marked, we set the value of the cell as 0.\\n\\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(M+N)**\\n\\n# **APPROACH II**\\nWe handle cases seperately. \\n* Check the first row and column for pre-existing `0`. \\n\\t* If found we mark that row or column as true\\n* Now we work upon the remaining matrix.\\n\\t* First we look for the cell that has `0` in it.\\n\\t* Then proceed with the working i.e. marking the cell as 0. \\n*  Now work upon the checked first row and column and update their values.\\n\\t*  Note: Updating before hand gives WA\\n \\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(1)**",
                "solutionTags": [],
                "code": "```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276330,
                "title": "c-simple-99-faster-o-1-space-upvote",
                "content": "```\\n    void setZeroes(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        bool firstRow = false;  // do we need to set first row zero\\n        bool firstCol = false;  // do we need to ser first col zero\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n\\t\\t\\t\\t\\tif(a[i][j] == 0){   // store rows and cols state in first row and col\\n                    if(i==0) firstRow = true;\\n                    if(j==0) firstCol = true;\\n                    a[i][0] = 0;\\n                    a[0][j] = 0;\\n                }\\n            }\\n        }\\n        // cout<<firstRow<<\" \"<<firstCol<<endl;\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(a[i][0] == 0 || a[0][j] == 0){\\n                    a[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(firstRow){\\n            for(int i=0;i<m;i++) a[0][i] = 0;\\n        }\\n        \\n        if(firstCol){\\n            for(int i=0;i<n;i++) a[i][0] = 0;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    void setZeroes(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        bool firstRow = false;  // do we need to set first row zero\\n        bool firstCol = false;  // do we need to ser first col zero\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n\\t\\t\\t\\t\\tif(a[i][j] == 0){   // store rows and cols state in first row and col\\n                    if(i==0) firstRow = true;\\n                    if(j==0) firstCol = true;\\n                    a[i][0] = 0;\\n                    a[0][j] = 0;\\n                }\\n            }\\n        }\\n        // cout<<firstRow<<\" \"<<firstCol<<endl;\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(a[i][0] == 0 || a[0][j] == 0){\\n                    a[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(firstRow){\\n            for(int i=0;i<m;i++) a[0][i] = 0;\\n        }\\n        \\n        if(firstCol){\\n            for(int i=0;i<n;i++) a[i][0] = 0;\\n        }\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 717535,
                "title": "cpp-c-99-23-google-amazon",
                "content": "Approach-First of all create two vectors rowmarker and columnmarker to store the positions of column and row where the element is zero. \\nIf element in either row marker or columnmarker is 0.Then make the element in the whole matrix 0. \\n```\\n void setZeroes(vector<vector<int>>& matrix) {     \\n        int rowsize=matrix.size(); \\n        int columnsize=matrix[0].size(); \\n        vector<int>rowmarker(rowsize,1);\\n        vector<int>columnmarker(columnsize,1); \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    rowmarker[i]=0; \\n                    columnmarker[j]=0;\\n                }\\n            }\\n        } \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(rowmarker[i]==0 or columnmarker[j]==0)\\n                    matrix[i][j]=0;\\n             }\\n        }\\n        \\n    }\\n\\t```\\n\\t Please Upvote if you like my solution.Jai Hind.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n void setZeroes(vector<vector<int>>& matrix) {     \\n        int rowsize=matrix.size(); \\n        int columnsize=matrix[0].size(); \\n        vector<int>rowmarker(rowsize,1);\\n        vector<int>columnmarker(columnsize,1); \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    rowmarker[i]=0; \\n                    columnmarker[j]=0;\\n                }\\n            }\\n        } \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(rowmarker[i]==0 or columnmarker[j]==0)\\n                    matrix[i][j]=0;\\n             }\\n        }\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 26038,
                "title": "my-c-o-1-yoooooo",
                "content": "I find the last row which has 0, and use it to store the 0-collumns.\\nThen go row by row set them to 0.\\nThen go column by column set them to 0.\\nFinally set the last row which has 0. It's long but hey it's O(1) \\n\\n\\n    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int> > &matrix) {\\n            \\n            int H = matrix.size();\\n            int W = matrix[0].size();\\n            \\n            // find the last 0 row\\n            int last_0_row = -1;\\n            for (int y = H - 1; y >= 0 && last_0_row == -1; y--)\\n                for (int x = 0; x < W; x++)\\n                    if (matrix[y][x] == 0)\\n                    {\\n                        last_0_row = y;\\n                        break;\\n                    }\\n            if (last_0_row == -1)\\n                return;\\n            \\n            // go row by row\\n            for (int y = 0; y < last_0_row; y++)\\n            {\\n                bool this_is_a_0_row = false;\\n                \\n                for (int x = 0; x < W; x++)\\n                {\\n                    if (matrix[y][x] == 0)\\n                    {\\n                        this_is_a_0_row = true;\\n                        matrix[last_0_row][x] = 0;\\n                    }\\n                }\\n                \\n                if (this_is_a_0_row)\\n                for (int x = 0; x < W; x++)\\n                {\\n                    matrix[y][x] = 0;\\n                }\\n            }\\n            \\n            // set collums to 0\\n            for (int y = 0; y < H; y++)\\n            for (int x = 0; x < W; x++)\\n            {\\n                if (matrix[last_0_row][x] == 0)\\n                    matrix[y][x] = 0;\\n            }\\n            \\n            // set the last 0 row \\n            for (int x = 0; x < W; x++)\\n            {\\n                matrix[last_0_row][x] = 0;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int> > &matrix) {\\n            \\n            int H = matrix.size();\\n            int W = matrix[0].size();\\n            \\n            // find the last 0 row\\n            int last_0_row = -1;\\n            for (int y = H - 1; y >= 0 && last_0_row == -1; y--)\\n                for (int x = 0; x < W; x++)\\n                    if (matrix[y][x] == 0)\\n                    {\\n                        last_0_row = y;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 26026,
                "title": "o-1-space-solution-in-python",
                "content": "    class Solution:\\n    # @param {integer[][]} matrix\\n    # @return {void} Do not return anything, modify matrix in-place instead.\\n    def setZeroes(self, matrix):\\n        m = len(matrix)\\n        if m == 0:\\n            return\\n        n = len(matrix[0])\\n        \\n        row_zero = False\\n        for i in range(m):\\n            if matrix[i][0] == 0:\\n                row_zero = True\\n        col_zero = False\\n        for j in range(n):\\n            if matrix[0][j] == 0:\\n                col_zero = True\\n                \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = 0\\n                    matrix[0][j] = 0\\n        \\n        for i in range(1, m):\\n            if matrix[i][0] == 0:\\n                for j in range(1, n):\\n                    matrix[i][j] = 0\\n                    \\n        for j in range(1, n):\\n            if matrix[0][j] == 0:\\n                for i in range(1, m):\\n                    matrix[i][j] = 0\\n        \\n        if col_zero:\\n            for j in range(n):\\n                matrix[0][j] = 0\\n        if row_zero:\\n            for i in range(m):\\n                matrix[i][0] = 0",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer[][]}",
                "codeTag": "Java"
            },
            {
                "id": 1400861,
                "title": "python-o-mn-o-1-time-space-solution-explained",
                "content": "The idea is to use first row and first column as indicator, if we need to set the whole corresponding column or row to zeros. We also keep `r1 and `c1` variables: do we need to update first column and/or first row in the end. So, we have the following steps:\\n\\n1. Create `r1` and `c1`.\\n2. Iterate through our matrix and if we see that for if element `M[i][j]` is equal to `0`, we put both elements `M[i][0]` and `M[0][j]` to `0`.\\n3. Now, we updated all elements in first row and column, so we iterate our matrix once again: and if we see that one of elements `M[i][0]` or `M[0][j]` equal to `0`, we make `M[i][j] equal to `0`.\\n4. Finally, we need to update first row and column, so we make them `0`, if we have indicator `r1` for row and `c1` for column.\\n\\n#### Complexity\\nTime complexity is `O(mn)`, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def setZeroes(self, M):\\n        m, n = len(M[0]), len(M)\\n        r1 = any(M[0][j] == 0 for j in range(m))\\n        c1 = any(M[i][0] == 0 for i in range(n))\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][j] == 0: M[i][0] = M[0][j] = 0\\n                \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][0] * M[0][j] == 0: M[i][j] = 0\\n                \\n        if r1:\\n            for i in range(m): M[0][i] = 0\\n                \\n        if c1:\\n            for j in range(n): M[j][0] = 0\\n```\\n\\t\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def setZeroes(self, M):\\n        m, n = len(M[0]), len(M)\\n        r1 = any(M[0][j] == 0 for j in range(m))\\n        c1 = any(M[i][0] == 0 for i in range(n))\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][j] == 0: M[i][0] = M[0][j] = 0\\n                \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][0] * M[0][j] == 0: M[i][j] = 0\\n                \\n        if r1:\\n            for i in range(m): M[0][i] = 0\\n                \\n        if c1:\\n            for j in range(n): M[j][0] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469077,
                "title": "python-from-o-m-n-space-to-o-1-space-with-picture-clean-concise",
                "content": "**Solution 1: Additional Memory Space**\\n- Let `zeroRow[r] = True` denote all the cells in row `r` must have value 0.\\n- Let `zeroCol[c] = True` denote all the cells in column `c` must have value 0.\\n```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        zeroRow = [False] * m\\n        zeroCol = [False] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == 0:\\n                    zeroRow[r] = zeroCol[c] = True\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if zeroRow[r] or zeroCol[c]:\\n                    matrix[r][c] = 0\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(M + N)`\\n\\n---\\n**Solution 2: In-space Solution**\\n- We re-use the first row as the meaning of `zeroCol`. It means `matrix[r][0] = 0` is the same meaning with `zeroRow[r] = True`. \\n- We re-use the first column as the meaning of `zeroRow`. It means `matrix[0][c] = 0` is the same meaning with `zeroCol[c] = True`.\\n- While processing to set `matrix[r][0] = 0` or `matrix[0][c] = 0`, we iterate cells with `r` in `[1...m-1]`, `c` in `[1..n-1]`. \\n\\t- We skip cells in the first row `r = 0` and cells in the first column `c = 0`. \\n\\t- Otherwise, we will get WRONG ANSWER, can check following example:\\n\\t![image](https://assets.leetcode.com/users/images/dc1a5e2f-615e-409c-bdb5-a153fe66c955_1631898869.821589.png)\\n- Before, we need to use 2 additional flag:\\n\\t- `zeroFirstRow`: To check if all elements in the first row should be set into zero\\n\\t- `zeroFirstCol`: To check if all elements in the first column should be set into zero.\\n```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        zeroFirstRow = any(matrix[0][c] == 0 for c in range(n))\\n        zeroFirstCol = any(matrix[r][0] == 0 for r in range(m))\\n        \\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][c] == 0: matrix[0][c] = matrix[r][0] = 0\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][0] == 0 or matrix[0][c] == 0: matrix[r][c] = 0\\n                    \\n        if zeroFirstRow:\\n            for c in range(n): matrix[0][c] = 0\\n        \\n        if zeroFirstCol:\\n            for r in range(m): matrix[r][0] = 0\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(1)`\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        zeroRow = [False] * m\\n        zeroCol = [False] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == 0:\\n                    zeroRow[r] = zeroCol[c] = True\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if zeroRow[r] or zeroCol[c]:\\n                    matrix[r][c] = 0\\n```\n```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        zeroFirstRow = any(matrix[0][c] == 0 for c in range(n))\\n        zeroFirstCol = any(matrix[r][0] == 0 for r in range(m))\\n        \\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][c] == 0: matrix[0][c] = matrix[r][0] = 0\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][0] == 0 or matrix[0][c] == 0: matrix[r][c] = 0\\n                    \\n        if zeroFirstRow:\\n            for c in range(n): matrix[0][c] = 0\\n        \\n        if zeroFirstCol:\\n            for r in range(m): matrix[r][0] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26115,
                "title": "java-python-o-1-space-11-lines-solution",
                "content": "**Java**\\n\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length, k = 0;\\n        // First row has zero?\\n        while (k < n && matrix[0][k] != 0) ++k;\\n        // Use first row/column as marker, scan the matrix\\n        for (int i = 1; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (matrix[i][j] == 0)\\n                    matrix[0][j] = matrix[i][0] = 0;\\n        // Set the zeros\\n        for (int i = 1; i < m; ++i)\\n            for (int j = n - 1; j >= 0; --j)\\n                if (matrix[0][j] == 0 || matrix[i][0] == 0)\\n                    matrix[i][j] = 0;\\n        // Set the zeros for the first row\\n        if (k < n) Arrays.fill(matrix[0], 0);\\n    }\\n\\n**Python**\\n\\n    def setZeroes(self, matrix):\\n        # First row has zero?\\n        m, n, firstRowHasZero = len(matrix), len(matrix[0]), not all(matrix[0])\\n        # Use first row/column as marker, scan the matrix\\n        for i in xrange(1, m):\\n            for j in xrange(n):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = matrix[i][0] = 0\\n        # Set the zeros\\n        for i in xrange(1, m):\\n            for j in xrange(n - 1, -1, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n        # Set the zeros for the first row\\n        if firstRowHasZero:\\n            matrix[0] = [0] * n",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "**Java**\\n\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length, k = 0;\\n        // First row has zero?\\n        while (k < n && matrix[0][k] != 0) ++k;\\n        // Use first row/column as marker, scan the matrix\\n        for (int i = 1; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (matrix[i][j] == 0)\\n                    matrix[0][j] = matrix[i][0] = 0;\\n        // Set the zeros\\n        for (int i = 1; i < m; ++i)\\n            for (int j = n - 1; j >= 0; --j)\\n                if (matrix[0][j] == 0 || matrix[i][0] == 0)\\n                    matrix[i][j] = 0;\\n        // Set the zeros for the first row\\n        if (k < n) Arrays.fill(matrix[0], 0);\\n    }\\n\\n**Python**\\n\\n    def setZeroes(self, matrix):\\n        # First row has zero?\\n        m, n, firstRowHasZero = len(matrix), len(matrix[0]), not all(matrix[0])\\n        # Use first row/column as marker, scan the matrix\\n        for i in xrange(1, m):\\n            for j in xrange(n):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = matrix[i][0] = 0\\n        # Set the zeros\\n        for i in xrange(1, m):\\n            for j in xrange(n - 1, -1, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n        # Set the zeros for the first row\\n        if firstRowHasZero:\\n            matrix[0] = [0] * n",
                "codeTag": "Python3"
            },
            {
                "id": 26037,
                "title": "o-1-java-straightforward-idea",
                "content": "Use the first column and the first row as marker:\\n1. first scan through the whole matrix, and if one row i has zero, label matrix[i][0] = 0, if column j has zero, then label matrix[0][j] = 0.\\nif we find the first row has zero, then mark a boolean row = true, if the first column has zeros, mark a boolean col = true;\\n\\n2. By the markers on the first row and first col, set the other columns and rows to zeros. (first row and first column already contain zeros)\\n\\n3. According to booleans row and col, decide whether to set first row and column to zeros.\\n\\n        public class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;\\n            int m = matrix.length, n = matrix[0].length;\\n            boolean row = false, col = false;\\n            for (int i = 0; i < m; i++)\\n                for (int j = 0; j < n; j++){\\n                    if (matrix[i][j] == 0) {\\n                        matrix[0][j] = 0;\\n                        matrix[i][0] = 0;\\n                        if (i == 0) row = true;\\n                        if (j == 0) col = true;\\n                    }\\n                }\\n            for (int i = 1; i < m; i++){\\n                if (matrix[i][0] == 0){\\n                    for (int j = 1; j < n;j++)\\n                        matrix[i][j] = 0;\\n                }\\n            }\\n            for (int j = 1; j < n; j++){\\n                if (matrix[0][j] == 0){\\n                    for (int i = 1; i < m; i++)\\n                        matrix[i][j] = 0;\\n                }\\n            }\\n            if (row){\\n                for (int j = 0; j < n; j++)\\n                    matrix[0][j] = 0;\\n            }\\n            if (col){\\n                for(int i = 0; i < m; i++)\\n                    matrix[i][0] = 0;\\n            }\\n        }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;\\n            int m = matrix.length, n = matrix[0].length;\\n            boolean row = false, col = false;\\n            for (int i = 0; i < m; i++)\\n                for (int j = 0; j < n; j++){\\n                    if (matrix[i][j] == 0) {\\n                        matrix[0][j] = 0;\\n                        matrix[i][0] = 0;\\n                        if (i == 0) row = true;\\n                        if (j == 0) col = true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 26020,
                "title": "my-java-solution-easy-to-understand",
                "content": "    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(row[i]==1||col[j]==1){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(row[i]==1||col[j]==1){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26087,
                "title": "java-easy-to-understand-o-1-space-solution-with-2-passes",
                "content": "    public class Solution {\\n    \\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null || matrix.length==0){\\n            return;\\n        }\\n        \\n        boolean setFirstRowToZeroes = false;\\n        boolean setFirstColumnToZeroes = false;\\n        \\n        //check if first column needs to be set to zero\\n        for(int row=0;row<matrix.length;row++){\\n            if(matrix[row][0] == 0){\\n                setFirstColumnToZeroes=true;\\n                break;\\n            }\\n        }\\n        \\n        //check if first row needs to be set to zero\\n        for(int col=0;col<matrix[0].length;col++){\\n            if(matrix[0][col] == 0){\\n                setFirstRowToZeroes=true;\\n                break;\\n            }\\n        }\\n        \\n        //mark columns and rows to be set to zero\\n        for(int row=1;row<matrix.length;row++){\\n            for(int col=1;col<matrix[0].length;col++){\\n                if(matrix[row][col]==0){\\n                    matrix[row][0]=0;\\n                    matrix[0][col]=0;\\n                }\\n            }\\n        }\\n        \\n        // make rows zero\\n        for(int row=1;row<matrix.length;row++){\\n            if(matrix[row][0]==0){\\n                for(int col=1;col<matrix[0].length;col++){\\n                    matrix[row][col]=0;\\n                }\\n            }\\n        }\\n        \\n        // make columns zero\\n        for(int col=1;col<matrix[0].length;col++){\\n            if(matrix[0][col]==0){\\n                for(int row=1;row<matrix.length;row++){\\n                    matrix[row][col]=0;\\n                }\\n            }\\n        }\\n        \\n        // zero out first row (if needed)\\n        if(setFirstRowToZeroes){\\n            for(int col=0;col<matrix[0].length;col++){\\n                matrix[0][col]=0;\\n            }\\n        }\\n        \\n        // zero out first column (if needed)\\n        if(setFirstColumnToZeroes){\\n            for(int row=0;row<matrix.length;row++){\\n                matrix[row][0]=0;\\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null || matrix.length==0){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 26166,
                "title": "my-java-o-1-solution-easy-to-understand",
                "content": "    public class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if(matrix==null){\\n                return;\\n            }\\n            \\n            int m = matrix.length;\\n            int n = matrix[0].length;\\n            \\n            boolean rowHasZero = false;\\n            boolean colHasZero = false;\\n            \\n            for(int i=0; i<n; i++){\\n                if(matrix[0][i]==0){\\n                    rowHasZero = true;\\n                    break;\\n                }\\n            }\\n            \\n            for(int i=0; i<m; i++){\\n                if(matrix[i][0]==0){\\n                    colHasZero = true;\\n                    break;\\n                }\\n            }\\n            \\n            for(int i=1; i<m; i++){\\n                for(int j=1; j<n; j++){\\n                    if(matrix[i][j]==0){\\n                        matrix[i][0] = 0;\\n                        matrix[0][j] = 0;\\n                    }\\n                }\\n            }\\n            \\n    \\n            \\n            for(int j=1;j<n; j++){\\n                if(matrix[0][j]==0){\\n                    nullifyCol(matrix, j, m, n);\\n                }\\n            }\\n            \\n            for(int i=1; i<m; i++){\\n                if(matrix[i][0]==0){\\n                    nullifyRow(matrix, i, m, n);\\n                }\\n            }\\n            \\n            if(rowHasZero){\\n                nullifyRow(matrix, 0, m, n);\\n            }\\n            if(colHasZero){\\n                nullifyCol(matrix, 0, m, n);\\n            }\\n            \\n        }\\n        \\n        public void nullifyRow(int[][] matrix, int i, int m, int n){\\n            for(int col=0; col<n; col++){\\n                matrix[i][col] = 0;\\n            }\\n        }\\n        \\n        public void nullifyCol(int[][] matrix, int j, int m, int n){\\n            for(int row=0; row<m; row++){\\n                matrix[row][j] = 0;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if(matrix==null){\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 588969,
                "title": "python-solution-using-set-beats-100",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        row = set()\\n        column = set()\\n        \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    row.add(i)\\n                    column.add(j)          \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j] = 0\\n        for i in column:\\n            for j in range(len(matrix)):\\n                matrix[j][i] = 0 \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        row = set()\\n        column = set()\\n        \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    row.add(i)\\n                    column.add(j)          \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j] = 0\\n        for i in column:\\n            for j in range(len(matrix)):\\n                matrix[j][i] = 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515437,
                "title": "java-tc-o-r-c-sc-o-1-optimized-in-place-solution",
                "content": "```java\\n/**\\n * Optimized In-Place solution\\n *\\n * We can use the first cell of every row and column as a flag. This flag will\\n * determine whether a row or a column has to be set to zero.\\n *\\n * Time Complexity: O(2 * R * C)\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return;\\n        }\\n\\n        boolean isFirstColZero = false;\\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                isFirstColZero = true;\\n            }\\n            for (int j = 1; j < cols; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--) {\\n                if (matrix[i][0] == 0 | matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n            if (isFirstColZero) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Optimized In-Place solution\\n *\\n * We can use the first cell of every row and column as a flag. This flag will\\n * determine whether a row or a column has to be set to zero.\\n *\\n * Time Complexity: O(2 * R * C)\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return;\\n        }\\n\\n        boolean isFirstColZero = false;\\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                isFirstColZero = true;\\n            }\\n            for (int j = 1; j < cols; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--) {\\n                if (matrix[i][0] == 0 | matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n            if (isFirstColZero) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383492,
                "title": "simple-c-solution-using-extra-space",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<pair<int,int>> cor;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   cor.push_back({i,j});\\n                }\\n            }\\n        }\\n        for(int i=0;i<cor.size();i++)\\n        {\\n            int x=cor[i].first;\\n            int y=cor[i].second;\\n            int row=0;\\n            int col=0;\\n            while(row<m)\\n            {\\n                matrix[row][y]=0;\\n                row++;\\n            }\\n            while(col<n)\\n            {\\n                matrix[x][col]=0;\\n                col++;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<pair<int,int>> cor;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   cor.push_back({i,j});\\n                }\\n            }\\n        }\\n        for(int i=0;i<cor.size();i++)\\n        {\\n            int x=cor[i].first;\\n            int y=cor[i].second;\\n            int row=0;\\n            int col=0;\\n            while(row<m)\\n            {\\n                matrix[row][y]=0;\\n                row++;\\n            }\\n            while(col<n)\\n            {\\n                matrix[x][col]=0;\\n                col++;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280740,
                "title": "3-sweet-and-simple-approach-brute-force-optimal-pro-optimal",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& v) {\\n        int x,y;\\n        \\n        /*-------------BRUTE FORCE APPROACH-----------------*/\\n/*        \\n        \\n      int m=v.size();\\n        int n=v[0].size();\\n        int temp[m][n];\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                temp[i][j]=1;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                {\\n                for(int k=0;k<m;k++)\\n                    temp[k][j]=0;\\n                    \\n                    for(int k=0;k<n;k++)\\n                        temp[i][k]=0;\\n                }\\n               \\n            }\\n            \\n            \\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               if(temp[i][j]==0)\\n                   v[i][j]=temp[i][j];\\n                else\\n                    v[i][j]=v[i][j];\\n            }\\n        }\\n        T.C =O(M*N*(M+N))    S.C=O(MN)\\n    */    \\n        \\n        /*-----------OPTIMAL APPROACH MAKE DUMMY ROW AND COLUMN---------*/\\n     \\n        \\n      /*  \\n        int m=v.size();\\n        int n=v[0].size();\\n        int row[m];\\n        int col[n];\\n        \\n        for(int i=0;i<m;i++)\\n            row[i]=false;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n            col[i]=false;\\n        \\n         for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                {\\n                    row[i]=true;\\n                    col[j]=true;\\n                }\\n            }\\n         }\\n        \\n         for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( row[i]==true  ||  col[j]==true)\\n                {\\n                    v[i][j]=0;\\n                }\\n            }\\n         }\\n        \\n     time complexity   = O(N*M)\\n\\nSpace Complexity: O(M + N), for storing hash tables.\\n\\n*/\\n        \\n        /*--------------------- PRO -OPTIMAL APPROACH-----------------------*/\\n          int col0 = 1, rows = v.size(), cols = v[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (v[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (v[i][j] == 0)\\n                v[i][0] = v[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (v[i][0] == 0 || v[0][j] == 0)\\n                v[i][j] = 0;\\n        if (col0 == 0) v[i][0] = 0;\\n        \\n    }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& v) {\\n        int x,y;\\n        \\n        /*-------------BRUTE FORCE APPROACH-----------------*/\\n/*        \\n        \\n      int m=v.size();\\n        int n=v[0].size();\\n        int temp[m][n];\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                temp[i][j]=1;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                {\\n                for(int k=0;k<m;k++)\\n                    temp[k][j]=0;\\n                    \\n                    for(int k=0;k<n;k++)\\n                        temp[i][k]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2170667,
                "title": "c-easy-solution-optimized",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = true;\\n        // int rows = sizeof(matrix)/sizeof(matrix[0]);\\n        int rows = matrix.size();\\n        // int cols = sizeof(matrix[0]/sizeof(matrix[0][0]));\\n        int cols = matrix[0].size();\\n        \\n        \\n        // iterate from forward\\n        for(int i = 0; i < rows; i++)\\n        {\\n            if(matrix[i][0]==0) col0 = false;\\n            for(int j = 1; j < cols; j++)\\n                if(matrix[i][j]==0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        // iterate from backward\\n        for(int i = rows-1; i >= 0; i--){\\n            for(int j = cols-1; j >= 1; j--)\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if(col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = true;\\n        // int rows = sizeof(matrix)/sizeof(matrix[0]);\\n        int rows = matrix.size();\\n        // int cols = sizeof(matrix[0]/sizeof(matrix[0][0]));\\n        int cols = matrix[0].size();\\n        \\n        \\n        // iterate from forward\\n        for(int i = 0; i < rows; i++)\\n        {\\n            if(matrix[i][0]==0) col0 = false;\\n            for(int j = 1; j < cols; j++)\\n                if(matrix[i][j]==0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        // iterate from backward\\n        for(int i = rows-1; i >= 0; i--){\\n            for(int j = cols-1; j >= 1; j--)\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if(col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495421,
                "title": "javascript-fast-and-simple",
                "content": "```\\nvar setZeroes = function(matrix) {\\n\\n    var track = []\\n    \\n    // find zeros\\n    for(var i = 0; i < matrix.length; i++){\\n      for(var j = 0; j < matrix[0].length; j++){\\n        if(matrix[i][j] === 0) track.push([i, j])                \\n      }\\n    }\\n\\n    for(var i = 0; i < track.length; i++){\\n      var [x, y] = track[i]\\n      \\n      // update row\\n      for(var j = 0; j < matrix[0].length; j++){\\n        matrix[x][j] = 0\\n      }\\n      \\n      // udpate column\\n      for(var j = 0; j < matrix.length; j++){\\n        matrix[j][y] = 0\\n      }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n\\n    var track = []\\n    \\n    // find zeros\\n    for(var i = 0; i < matrix.length; i++){\\n      for(var j = 0; j < matrix[0].length; j++){\\n        if(matrix[i][j] === 0) track.push([i, j])                \\n      }\\n    }\\n\\n    for(var i = 0; i < track.length; i++){\\n      var [x, y] = track[i]\\n      \\n      // update row\\n      for(var j = 0; j < matrix[0].length; j++){\\n        matrix[x][j] = 0\\n      }\\n      \\n      // udpate column\\n      for(var j = 0; j < matrix.length; j++){\\n        matrix[j][y] = 0\\n      }\\n\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519959,
                "title": "c-java-python-javascript-using-matrix-and-array-with-full-explanation",
                "content": "# Intuition:\\nWe need to modify the matrix in-place, so we can\\'t use an auxiliary matrix or hash table. We can instead use the first row and first column of the original matrix as a replacement for the auxiliary array. This way, we can save the extra space required for the auxiliary arrays and also set the values in the first row and column to zero if any element in the corresponding row or column is zero.\\n\\n# Approach:\\n1. First, the code initializes two dummy vectors, `dummyRow` and `dummyCol`, with initial values of -1. These vectors will be used to mark the rows and columns that need to be set to zero.\\n2. The code then iterates through each element of the matrix and checks if it is zero. If an element is zero, it updates the corresponding indices in `dummyRow` and `dummyCol` to 0.\\n3. After marking the rows and columns, the code iterates through the matrix again. For each element, it checks if the corresponding row index or column index in `dummyRow` or `dummyCol` is zero. If either of them is zero, it sets the current element to zero.\\n4. Finally, the matrix will have rows and columns set to zero based on the values in `dummyRow` and `dummyCol`.\\n\\n# Complexity:\\n- Time complexity: O(mn), where m and n are the number of rows and columns in the matrix, respectively. We have to traverse the matrix twice.\\n- Space complexity: O(m+n), where m and n are the number of rows and columns in the matrix, respectively. We are using two auxiliary vectors of size m and n to keep track of the rows and columns that contain zero elements.\\n\\n---\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        vector <int> dummyRow(row,-1);\\n        vector<int> dummyCol(col,-1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n         for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```java\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[] dummyRow = new int[row];\\n        int[] dummyCol = new int[col];\\n        Arrays.fill(dummyRow, -1);\\n        Arrays.fill(dummyCol, -1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```py\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        row = len(matrix)\\n        col = len(matrix[0])\\n        dummyRow = [-1] * row\\n        dummyCol = [-1] * col\\n        for i in range(row):\\n            for j in range(col):\\n                if matrix[i][j] == 0:\\n                    dummyRow[i] = 0\\n                    dummyCol[j] = 0\\n        for i in range(row):\\n            for j in range(col):\\n                if dummyRow[i] == 0 or dummyCol[j] == 0:\\n                    matrix[i][j] = 0\\n\\n```\\n---\\n# JavaScript\\n```js\\nvar setZeroes = function(matrix) {\\n    const row = matrix.length;\\n    const col = matrix[0].length;\\n    const dummyRow = new Array(row).fill(-1);\\n    const dummyCol = new Array(col).fill(-1);\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(matrix[i][j]==0){\\n                dummyRow[i] = 0;\\n                dummyCol[j] = 0;\\n            }\\n        }\\n    }\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        vector <int> dummyRow(row,-1);\\n        vector<int> dummyCol(col,-1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n         for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[] dummyRow = new int[row];\\n        int[] dummyCol = new int[col];\\n        Arrays.fill(dummyRow, -1);\\n        Arrays.fill(dummyCol, -1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n```\n```py\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        row = len(matrix)\\n        col = len(matrix[0])\\n        dummyRow = [-1] * row\\n        dummyCol = [-1] * col\\n        for i in range(row):\\n            for j in range(col):\\n                if matrix[i][j] == 0:\\n                    dummyRow[i] = 0\\n                    dummyCol[j] = 0\\n        for i in range(row):\\n            for j in range(col):\\n                if dummyRow[i] == 0 or dummyCol[j] == 0:\\n                    matrix[i][j] = 0\\n\\n```\n```js\\nvar setZeroes = function(matrix) {\\n    const row = matrix.length;\\n    const col = matrix[0].length;\\n    const dummyRow = new Array(row).fill(-1);\\n    const dummyCol = new Array(col).fill(-1);\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(matrix[i][j]==0){\\n                dummyRow[i] = 0;\\n                dummyCol[j] = 0;\\n            }\\n        }\\n    }\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26151,
                "title": "constant-space-java-solution",
                "content": " a b b \\n\\n   b c c\\n\\n   b c c\\n\\nStep1: Determine row1 and col1. Need to go through the first col and first row. Use two vars to store that information.\\nStep2: Use \"c\" to determine \"b\". Need to go through the entire matrix. Once \"c\" is zero, set its corresponding two \"b\"s to zero.\\nStep3: Use \"b\" to set \"c\". If \"b\" is zero, its corresponding row or col are set to all zero.\\nStep4: Use previous row1 and col1 information to set col1 and row1.\\n\\n    public class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstColZero = false, firstRowZero = false;\\n            for(int i = 0;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    firstColZero = true;\\n            for(int j = 0;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    firstRowZero = true;\\n            for(int i = 1;i < matrix.length;i++)\\n                for(int j = 1;j < matrix[0].length;j++)\\n                    if(matrix[i][j] == 0)\\n                        matrix[i][0] = matrix[0][j] = 0;\\n            for(int i = 1;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    for(int j = 0;j < matrix[0].length;j++)\\n                        matrix[i][j] = 0;\\n            for(int j = 1;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    for(int i = 0;i < matrix.length;i++)\\n                        matrix[i][j] = 0;\\n            if(firstColZero)\\n                for(int i = 0;i < matrix.length;i++)\\n                    matrix[i][0] = 0;\\n            if(firstRowZero)\\n                for(int j = 0;j < matrix[0].length;j++)\\n                    matrix[0][j] = 0;\\n                    \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstColZero = false, firstRowZero = false;\\n            for(int i = 0;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    firstColZero = true;\\n            for(int j = 0;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    firstRowZero = true;\\n            for(int i = 1;i < matrix.length;i++)\\n                for(int j = 1;j < matrix[0].length;j++)\\n                    if(matrix[i][j] == 0)\\n                        matrix[i][0] = matrix[0][j] = 0;\\n            for(int i = 1;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    for(int j = 0;j < matrix[0].length;j++)\\n                        matrix[i][j] = 0;\\n            for(int j = 1;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    for(int i = 0;i < matrix.length;i++)\\n                        matrix[i][j] = 0;\\n            if(firstColZero)\\n                for(int i = 0;i < matrix.length;i++)\\n                    matrix[i][0] = 0;\\n            if(firstRowZero)\\n                for(int j = 0;j < matrix[0].length;j++)\\n                    matrix[0][j] = 0;\\n                    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1477825,
                "title": "javascript-three-solutions-one-is-suggested-transcribed-to-js-100",
                "content": "![image](https://assets.leetcode.com/users/images/45384296-f1fe-4288-9759-058e94dde2c9_1632272059.2179272.png)\\n\\n\\nDoing the Blind 75 and posting all solutions.\\n\\nHere is the \\'Suggested Solution\\' transcribed to JS.  Cool solution if you Have to keep constant space.  A little convoluted otherwise imo.\\n```\\nvar setZeroes = function(matrix) {\\n  let isCol = false, r = matrix.length, c = matrix[0].length;\\n  for (let i = 0; i < r; i++) {\\n    if (!matrix[i][0]) isCol = true;\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][j]) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      };\\n    }\\n  }\\n  for (let i = 1; i < r; i++) {\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;\\n    }\\n  }\\n  if (!matrix[0][0]) {\\n    for (let j = 0; j < c; j++) matrix[0][j] = 0;\\n  }\\n  if (isCol) {\\n    for (let i = 0; i < r; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n};\\n```\\n\\nHere is a version where we use Sets to track 0\\'s.  A little extra space, but not a ton.  Won\\'t work if interviewer challenges you to constant space though.\\n```\\nvar setZeroes = function(matrix) {\\n  const rowSet = new Set(), colSet = new Set()\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!matrix[i][j]) {\\n        rowSet.add(i);\\n        colSet.add(j);\\n      };\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (rowSet.has(i) || colSet.has(j)) matrix[i][j] = 0\\n    }\\n  }\\n};\\n```\\n\\nHere is a version where we just deep copy the array and go to town.  This is the easiest imo and gets solid time complexity (Maybe slight redoing of the recursive calls if 0\\'s overwrite cells more than once.).  It Is the worst on space complexity though.  Just depends what they\\'re looking for and if Constant Space is make or break.\\n```\\nvar setZeroes = function(matrix) {\\n  const copy = JSON.parse(JSON.stringify(matrix));\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!copy[i][j]) traverse(i, j);\\n    }\\n  }\\n  \\n  function traverse(row, col, dir = \\'all\\') {\\n    matrix[row][col] = 0;\\n    if (row - 1 >= 0 && (dir === \\'all\\' || dir === \\'up\\')) traverse(row - 1, col, \\'up\\');\\n    if (row + 1 <= matrix.length - 1 && (dir === \\'all\\' || dir === \\'down\\')) traverse(row + 1, col, \\'down\\');\\n    if (col - 1 >= 0 && (dir === \\'all\\' || dir === \\'left\\')) traverse(row, col - 1, \\'left\\');\\n    if (col + 1 <= matrix[row].length - 1 && (dir === \\'all\\' || dir === \\'right\\')) traverse(row, col + 1, \\'right\\');\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n  let isCol = false, r = matrix.length, c = matrix[0].length;\\n  for (let i = 0; i < r; i++) {\\n    if (!matrix[i][0]) isCol = true;\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][j]) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      };\\n    }\\n  }\\n  for (let i = 1; i < r; i++) {\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;\\n    }\\n  }\\n  if (!matrix[0][0]) {\\n    for (let j = 0; j < c; j++) matrix[0][j] = 0;\\n  }\\n  if (isCol) {\\n    for (let i = 0; i < r; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n};\\n```\n```\\nvar setZeroes = function(matrix) {\\n  const rowSet = new Set(), colSet = new Set()\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!matrix[i][j]) {\\n        rowSet.add(i);\\n        colSet.add(j);\\n      };\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (rowSet.has(i) || colSet.has(j)) matrix[i][j] = 0\\n    }\\n  }\\n};\\n```\n```\\nvar setZeroes = function(matrix) {\\n  const copy = JSON.parse(JSON.stringify(matrix));\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!copy[i][j]) traverse(i, j);\\n    }\\n  }\\n  \\n  function traverse(row, col, dir = \\'all\\') {\\n    matrix[row][col] = 0;\\n    if (row - 1 >= 0 && (dir === \\'all\\' || dir === \\'up\\')) traverse(row - 1, col, \\'up\\');\\n    if (row + 1 <= matrix.length - 1 && (dir === \\'all\\' || dir === \\'down\\')) traverse(row + 1, col, \\'down\\');\\n    if (col - 1 >= 0 && (dir === \\'all\\' || dir === \\'left\\')) traverse(row, col - 1, \\'left\\');\\n    if (col + 1 <= matrix[row].length - 1 && (dir === \\'all\\' || dir === \\'right\\')) traverse(row, col + 1, \\'right\\');\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26047,
                "title": "quiet-simple-answer-u2018hacking-u2019-with-javascript",
                "content": "var setZeroes = function(matrix) {\\n\\n    var r = matrix.length;\\n    var l = matrix[0].length;\\n    for (var i = 0; i < r; i++) {\\n        for (var j = 0; j < l; j++) {\\n            if (matrix[i][j] === 0 && 1 / matrix[i][j] === Infinity) {\\n                for (var x = 0; x < r; x++) {\\n                    matrix[x][j] = matrix[x][j] && -0;\\n                }\\n                for (var y = 0; y < l; y++) {\\n                    matrix[i][y] = matrix[i][y] && -0;\\n                }\\n            }\\n        }\\n    }\\n\\n};",
                "solutionTags": [],
                "code": "var setZeroes = function(matrix) {\\n\\n    var r = matrix.length;\\n    var l = matrix[0].length;\\n    for (var i = 0; i < r; i++) {\\n        for (var j = 0; j < l; j++) {\\n            if (matrix[i][j] === 0 && 1 / matrix[i][j] === Infinity) {\\n                for (var x = 0; x < r; x++) {\\n                    matrix[x][j] = matrix[x][j] && -0;\\n                }\\n                for (var y = 0; y < l; y++) {\\n                    matrix[i][y] = matrix[i][y] && -0;\\n                }\\n            }\\n        }\\n    }\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1918838,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func setZeroes(_ matrix: inout [[Int]]) {\\n        let row = matrix.count\\n        let col = matrix[0].count\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] == 0 {\\n                    setMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] != 0 {\\n                    resetMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n    }\\n\\n    \\n    func setMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        for i in 0..<matrix.count { \\n            let val = matrix[i][col]\\n            matrix[i][col] = val == 0 ? 0 : Int.max\\n        }\\n        \\n        for j in 0..<matrix[0].count {\\n            let val = matrix[row][j]\\n            matrix[row][j] = val == 0 ? 0 : Int.max\\n        }\\n    }\\n    \\n    \\n    func resetMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        let val = matrix[row][col]\\n        if val == Int.max { matrix[row][col] = 0 }\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func setZeroes(_ matrix: inout [[Int]]) {\\n        let row = matrix.count\\n        let col = matrix[0].count\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] == 0 {\\n                    setMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] != 0 {\\n                    resetMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n    }\\n\\n    \\n    func setMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        for i in 0..<matrix.count { \\n            let val = matrix[i][col]\\n            matrix[i][col] = val == 0 ? 0 : Int.max\\n        }\\n        \\n        for j in 0..<matrix[0].count {\\n            let val = matrix[row][j]\\n            matrix[row][j] = val == 0 ? 0 : Int.max\\n        }\\n    }\\n    \\n    \\n    func resetMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        let val = matrix[row][col]\\n        if val == Int.max { matrix[row][col] = 0 }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26176,
                "title": "is-there-a-better-constant-space-solution",
                "content": "My solution is kind of hackish - accpeted. So, I want to know if there is a better constant space solution?\\n\\nI traverse the matrix and if I find a zero, I replace all the elements, except the 0 elements, of the corresponding row and column with -1. Finally I make all the -1 to 0.\\n\\nThis algorithm would fail if the matrix has -1s. \\n\\n        void setZeroes(vector<vector<int> > &matrix) {\\n        \\n        int i,j,k,m,n;\\n        \\n        m = matrix.size();\\n        n = matrix[0].size();\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==0)\\n                {\\n                    for(k=0;k<n;k++)\\n                        if(matrix[i][k]!=0)\\n                            matrix[i][k] = -1;\\n                    for(k=0;k<m;k++)\\n                        if(matrix[k][j]!=0)\\n                            matrix[k][j] = -1;\\n                }\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==-1)\\n                   matrix[i][j]=0; \\n    }",
                "solutionTags": [],
                "code": "My solution is kind of hackish - accpeted. So, I want to know if there is a better constant space solution?\\n\\nI traverse the matrix and if I find a zero, I replace all the elements, except the 0 elements, of the corresponding row and column with -1. Finally I make all the -1 to 0.\\n\\nThis algorithm would fail if the matrix has -1s. \\n\\n        void setZeroes(vector<vector<int> > &matrix) {\\n        \\n        int i,j,k,m,n;\\n        \\n        m = matrix.size();\\n        n = matrix[0].size();\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==0)\\n                {\\n                    for(k=0;k<n;k++)\\n                        if(matrix[i][k]!=0)\\n                            matrix[i][k] = -1;\\n                    for(k=0;k<m;k++)\\n                        if(matrix[k][j]!=0)\\n                            matrix[k][j] = -1;\\n                }\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==-1)\\n                   matrix[i][j]=0; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3513736,
                "title": "python3-o-1-with-reverse-traversal",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        firstRowVal, R, C = 1, len(matrix), len(matrix[0])\\n\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0 # mark column\\n                    if i != 0:       \\n                        matrix[i][0] = 0\\n                    else:\\n                        firstRowVal = 0\\n        \\n        for i in reversed(range(R)):\\n            for j in reversed(range(C)):\\n                if i == 0:\\n                    matrix[i][j] *= firstRowVal\\n                elif matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        firstRowVal, R, C = 1, len(matrix), len(matrix[0])\\n\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0 # mark column\\n                    if i != 0:       \\n                        matrix[i][0] = 0\\n                    else:\\n                        firstRowVal = 0\\n        \\n        for i in reversed(range(R)):\\n            for j in reversed(range(C)):\\n                if i == 0:\\n                    matrix[i][j] *= firstRowVal\\n                elif matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367506,
                "title": "easy-c-o-1-faang-optimal-approach",
                "content": "# **Solution 1:**\\n \\n# **Approach: Using brute force**\\n\\nAssuming all the elements in the matrix are non-negative. Traverse through the matrix and if you find an element with value 0, then change all the elements in its row and column to -1, except when an element is 0. The reason for not changing other elements to 0, but -1, is because that might affect other columns and rows. Now traverse through the matrix again and if an element is -1 change it to 0, which will be the answer.\\n\\n```\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout << \"The Final Matrix is \" << endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\\n# Time Complexity:O((N*M)*(N + M)). O(N*M) for traversing through each element and (N+M)for traversing to row and column of elements having value 0.\\n\\n# Space Complexity:O(1)\\n# **Solution 2: Better approach**\\n\\n**Intuition:** Instead of traversing through each row and column, we can use dummy arrays to check if the particular row or column has an element 0 or not, which will improve the time complexity.\\n\\n**Approach:** Take two dummy array one of size of row and other of size of column.Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout<<\"The Final Matrix is \"<<endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\\n# **Time Complexity: O(N*M + N*M)**\\n\\n# **Space Complexity: O(N)**\\n# **Solution 3: Optimizing the better approach.**\\n\\n**Intuition:** Instead of taking two dummy arrays we can use the first row and column of the matrix for the same work. This will help to reduce the space complexity of the problem. While traversing for the second time the first row and column will be computed first, which will affect the values of further elements that\\u2019s why we traversing in the reverse direction.\\n\\n**Approach:** Instead of taking two separate dummy array,take first row and column of the matrix as the array for checking whether the particular column or row has the value 0 or not.Since matrix[0][0] are overlapping.Therefore take separate variable col0(say) to check if the 0th column has 0 or not and use matrix[0][0] to check if the 0th row has 0 or not.Now traverse from last element to the first element and check if matrix[i][0]==0 || matrix[0][j]==0 and if true set matrix[i][j]=0,else continue.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix){\\n        int col0=1, rows=matrix.size(), columns=matrix[0].size();\\n        for(int i=0 ; i<rows ; i++){\\n            if(matrix[i][0]==0) col0=0;\\n            for(int j=1 ; j<columns ; j++){\\n                if(matrix[i][j]==0)\\n                    matrix[i][0]=matrix[0][j]=0;\\n            }\\n        }\\n        for(int i=rows-1 ; i>=0 ; i--){\\n            for(int j=columns-1 ; j>=1 ; j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(col0==0)\\n                matrix[i][0]=0;\\n        }\\n    }\\n};\\n\\n// Total TC: O(2(m*n)) SC: O(1)\\n```\\n# **Time Complexity: O(2*(N*M)), as we are traversing two times in a matrix.**\\n\\n# **Space Complexity: O(1).**\\n\\nI found This video really useful. \\n[https://www.youtube.com/watch?v=M65xBewcqcI&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=10](http://)\\n\\n# **Please UPVOTE if it helped you !   \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout << \"The Final Matrix is \" << endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout<<\"The Final Matrix is \"<<endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix){\\n        int col0=1, rows=matrix.size(), columns=matrix[0].size();\\n        for(int i=0 ; i<rows ; i++){\\n            if(matrix[i][0]==0) col0=0;\\n            for(int j=1 ; j<columns ; j++){\\n                if(matrix[i][j]==0)\\n                    matrix[i][0]=matrix[0][j]=0;\\n            }\\n        }\\n        for(int i=rows-1 ; i>=0 ; i--){\\n            for(int j=columns-1 ; j>=1 ; j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(col0==0)\\n                matrix[i][0]=0;\\n        }\\n    }\\n};\\n\\n// Total TC: O(2(m*n)) SC: O(1)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 715132,
                "title": "java-best-explained-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //if we do normal approach whole matrix becomes 0\\n        // Basic explanation:\\n        // we are using the first row and column as a memory to keep track of all the 0\\'s in the entire matrix.\\n        \\n        if(matrix==null || matrix.length==0 || matrix[0].length==0){\\n            return;\\n        }\\n        \\n        \\n        //first we have to check is there any need to make first row and first column\\n        //so that at last we make tham 0\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        boolean first_row=false;\\n        boolean first_col=false;\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0){\\n                first_col=true;\\n                break;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0){\\n                first_row=true;\\n                break;\\n            }\\n        }\\n        //now find 0 inside matrix (except first row and col)\\n        //make 0 at the corresponding pos of first row and first col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //Now it\\'s time to make them 0 based to first row and col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        //At last convert first row 0 if first_row is true\\n        if(first_row){\\n            for(int j=0;j<n;j++){\\n                matrix[0][j]=0;\\n            }\\n        }\\n        //same for first col\\n        if(first_col){\\n            for(int i=0;i<m;i++){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //if we do normal approach whole matrix becomes 0\\n        // Basic explanation:\\n        // we are using the first row and column as a memory to keep track of all the 0\\'s in the entire matrix.\\n        \\n        if(matrix==null || matrix.length==0 || matrix[0].length==0){\\n            return;\\n        }\\n        \\n        \\n        //first we have to check is there any need to make first row and first column\\n        //so that at last we make tham 0\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        boolean first_row=false;\\n        boolean first_col=false;\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0){\\n                first_col=true;\\n                break;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0){\\n                first_row=true;\\n                break;\\n            }\\n        }\\n        //now find 0 inside matrix (except first row and col)\\n        //make 0 at the corresponding pos of first row and first col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //Now it\\'s time to make them 0 based to first row and col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        //At last convert first row 0 if first_row is true\\n        if(first_row){\\n            for(int j=0;j<n;j++){\\n                matrix[0][j]=0;\\n            }\\n        }\\n        //same for first col\\n        if(first_col){\\n            for(int i=0;i<m;i++){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961783,
                "title": "c-3-approaches-easy-to-understand",
                "content": "It is a frequently asked problem in interviews and a really good example of how to reduce time and space complexity for matrices using certain observations.\\n\\n**1st approach: Brute Force**\\n\\nSo, this approach would cross everyone\\'s mind and goes as following-\\nFirst we\\'ll check for cells with zero and then create a new matrix and traverse the given matrix and reflect all the changes in the new matrix itself.\\n\\n**Code-**\\n\\n```\\nvector<vector<int>> v( matrix.size(), vector<int>(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){\\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t       for(int k=0; k<matrix.size(); k++){\\n\\t\\t\\t       v[k][j]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int k=0; k<matrix[0].size(); k++){\\n\\t\\t\\t       v[i][k]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv[i][j]=matrix[i][j];\\n\\t\\t}\\n    }\\n```\\n\\n*Time complexity= O((rowsize * columsize) *  (rowsize+columnsize))\\nSpace Complexity= O(rowsize  columnsize)*\\n\\n**2nd approach: Using Hash Table**\\n\\nNow, we can get rid of the third loop by simply using two hash tables. The intuition to use two hash tables comes from observing the problem and what it requires, and that is we just want to keep track of 0 of any matrix cell and want to change the whole column or whole row accordingly, thus the idea of using hashing generates.\\n\\nIn this approach, we\\'ll use two hash tables-\\n\\n1)For tracking which row will contain 0\\'s\\n2)For tracking which column will contain 0\\'s\\n\\nand will update the row or column index in the matrix to 0. Then we\\'ll iterate through the whole matrix again and check the values in the hash table, so when we\\'ll encounter a 0 in either of the hash tables we\\'ll update 0 in the matrix.\\n\\n**Code-**\\n\\n```\\nvector<int> rows(matrix.size()), cols(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t      rows[i] = cols[j] = 0;       //updating hash tables\\n\\t\\t\\t }\\n\\t   }\\n}\\n//Now updating the matrix in 2nd traversal\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(rows[i] == 0 || cols[j] == 0){\\n\\t\\t      matrix[i][j] = 0;       \\n\\t\\t\\t }\\n\\t   }\\n}\\n\\n```\\n\\n*Time complexity= O(rowsize * columnsize)\\nSpace Complexity= O(rowsize + columnsize)*\\n\\n**3rd approach: Using In-place Hashing**\\n\\nNow this can be done by an amazing observation and using the 2nd approch but with O(1) space complexity, that is we know that we are required to update 0 in place of a particular column or row whenever a zero is encountered, that means ultimately the first/last column and row are going to reflect changes accordingly and can act as suitable hash tables. Voila! You got that right, in this question we can use the first/last column and row as hash tables and thus reduced space complexity.\\n\\nBut!! There is one problem that is if we use the first or last column and row, the first/last cell will result in clashing as it is common to both the dummy hash tables. So, can we resolve this issue? Well, yes this issue can be resolved.\\n\\nHow?\\nWe can reserve the first/last cell for dummy row hash table and whether to reflect changes in the column hash table we can use a separate variable. And this way, we can avoid any sort of clashing.\\n\\n**Code-**\\n\\n```\\nint n=matrix.size(), m=matrix[0].size(), col=1; //the col variable is defined so as to avoid the clash on the first cell of the matrix as it is commom to both dummy in-place hash tables \\n        for(int i=0;i<n;i++){\\n            if(matrix[i][0]==0)col=0; //it will only be set to zero when a 0 is encountered corresponding to a column\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //The first matrix traversal was to create the hash tables and the second one below is to update the values in the matrix according to the hash table\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=1;j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n            }\\n            if(col==0)matrix[i][0]=0; //clash avoided as column that particular column will only be updated when col is 0 otherwise values will remain intact \\n        }\\n        //the reason we were able to use in-place hashing in this question was because ultimately 0 in a cell will make that particular row or column 0. Hence we could use the first row and column as dummy hash tables and also didn\\'t have to store the values elsewhere\\n```\\n\\n*Time complexity= O(rowsize * columnsize)\\nSpace Complexity= O(1)*\\n\\nIf this helped you, please consider upvoting! \\nHappy coding!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> v( matrix.size(), vector<int>(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){\\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t       for(int k=0; k<matrix.size(); k++){\\n\\t\\t\\t       v[k][j]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int k=0; k<matrix[0].size(); k++){\\n\\t\\t\\t       v[i][k]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv[i][j]=matrix[i][j];\\n\\t\\t}\\n    }\\n```\n```\\nvector<int> rows(matrix.size()), cols(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t      rows[i] = cols[j] = 0;       //updating hash tables\\n\\t\\t\\t }\\n\\t   }\\n}\\n//Now updating the matrix in 2nd traversal\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(rows[i] == 0 || cols[j] == 0){\\n\\t\\t      matrix[i][j] = 0;       \\n\\t\\t\\t }\\n\\t   }\\n}\\n\\n```\n```\\nint n=matrix.size(), m=matrix[0].size(), col=1; //the col variable is defined so as to avoid the clash on the first cell of the matrix as it is commom to both dummy in-place hash tables \\n        for(int i=0;i<n;i++){\\n            if(matrix[i][0]==0)col=0; //it will only be set to zero when a 0 is encountered corresponding to a column\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //The first matrix traversal was to create the hash tables and the second one below is to update the values in the matrix according to the hash table\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=1;j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n            }\\n            if(col==0)matrix[i][0]=0; //clash avoided as column that particular column will only be updated when col is 0 otherwise values will remain intact \\n        }\\n        //the reason we were able to use in-place hashing in this question was because ultimately 0 in a cell will make that particular row or column 0. Hence we could use the first row and column as dummy hash tables and also didn\\'t have to store the values elsewhere\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009282,
                "title": "with-explanation-0-1-space-0-m-n-space",
                "content": "```\\n\\n//O(m+n) space, O(m+n) time\\n//keep two sets, one for row indexes than should be marked 0, and one for col indexes that should be marked 0\\n//loop through matrix once, populating the sets\\n//loop through a second time, setting items to 0, if their indexes are in either set\\n\\nconst setZeroes = (matrix) => {\\n    let rowsZero = new Set()\\n    let colsZero = new Set()\\n    for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n                rowsZero.add(i)\\n                colsZero.add(j)\\n            }\\n        }\\n    }\\n  for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (rowsZero.has(i) || colsZero.has(j)){\\n                matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\n//O(1) space, O(m+n) time\\n//we do the same as above, except we use the matrix itself to keep track of which rows and cols should be 0, instead of using sets\\n//we go through matrix and if we find a 0, we mark all items in row and all items in col\\n//we can\\'t simply set all items in row and col to zero, because we don\\'t want to change rows and columns with newly formed zeroes...just original zeroes\\n//if our \\'mark\\' function changed all items in selected row and col to be zero, it would mess up future iterations\\n//so we mark them as something else...null...and then we loop through the matrix a second time, making null items 0\\nconst setZeroes = (matrix) =>{\\n      for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n              mark(matrix,i,j)\\n            }\\n        }\\n    }\\n       for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === null){\\n              matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\nconst mark = (matrix, row, col)=>{\\n    for (let j = 0; j < matrix[0].length; j++){\\n        //preserve original 0, mark items that should zero as null\\n        if (matrix[row][j] !== 0){\\n           matrix[row][j] = null         \\n        }\\n    }\\n    for (let i = 0; i < matrix.length; i++){\\n        //preserve original 0, mark items that should be zero as null\\n        if (matrix[i][col] !== 0){\\n            matrix[i][col] = null\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n//O(m+n) space, O(m+n) time\\n//keep two sets, one for row indexes than should be marked 0, and one for col indexes that should be marked 0\\n//loop through matrix once, populating the sets\\n//loop through a second time, setting items to 0, if their indexes are in either set\\n\\nconst setZeroes = (matrix) => {\\n    let rowsZero = new Set()\\n    let colsZero = new Set()\\n    for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n                rowsZero.add(i)\\n                colsZero.add(j)\\n            }\\n        }\\n    }\\n  for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (rowsZero.has(i) || colsZero.has(j)){\\n                matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\n//O(1) space, O(m+n) time\\n//we do the same as above, except we use the matrix itself to keep track of which rows and cols should be 0, instead of using sets\\n//we go through matrix and if we find a 0, we mark all items in row and all items in col\\n//we can\\'t simply set all items in row and col to zero, because we don\\'t want to change rows and columns with newly formed zeroes...just original zeroes\\n//if our \\'mark\\' function changed all items in selected row and col to be zero, it would mess up future iterations\\n//so we mark them as something else...null...and then we loop through the matrix a second time, making null items 0\\nconst setZeroes = (matrix) =>{\\n      for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n              mark(matrix,i,j)\\n            }\\n        }\\n    }\\n       for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === null){\\n              matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\nconst mark = (matrix, row, col)=>{\\n    for (let j = 0; j < matrix[0].length; j++){\\n        //preserve original 0, mark items that should zero as null\\n        if (matrix[row][j] !== 0){\\n           matrix[row][j] = null         \\n        }\\n    }\\n    for (let i = 0; i < matrix.length; i++){\\n        //preserve original 0, mark items that should be zero as null\\n        if (matrix[i][col] !== 0){\\n            matrix[i][col] = null\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689227,
                "title": "java-striver-easy-understanding",
                "content": "```\\n# 1. Brute force Approach\\nComplexity\\nTime complexity:O((NM)(N + M)) + O(N*M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(1)\\n\\n# Code\\n\\nclass Solution {\\n    \\n    // making rows negative excluding 0\\'s\\n    public static void makeRow(int matrix[][],int n,int m,int i){\\n        for(int j=0;j<n;j++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n            \\n        }\\n    }\\n    \\n      // making cols negative excluding 0\\'s\\n    public static void makeCol(int matrix[][],int n,int m,int j){\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n        }\\n    }\\n    \\n    // main function\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix[0].length;\\n        int m = matrix.length;\\n       \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    makeRow(matrix,n,m,i);\\n                    makeCol(matrix,n,m,j);\\n                }\\n            }\\n        }\\n        \\n        // itterate through the matrix and mark 0\\'s where negative is present \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]== -1){\\n                    matrix[i][j]=0;\\n                }\\n                \\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\n#2. Better Approach\\nComplexity\\nTime complexity:O(2*(N*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(N) + O(M)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int row [] = new int[m];\\n        int col[] = new int[n];\\n\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                   \\n                   row [i] = 1;\\n                   col [j] = 1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(row[i]==1 ||col[j]==1){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\n\\n#3. Optimal Approach\\nComplexity\\nTime complexity:O(2*(N*M))\\nSpace complexity:O(1)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){  \\n                    matrix[i][0] = 0;\\n                if(j != 0){\\n                    matrix[0][j] = 0;\\n                }else col0 = 0;\\n                }\\n            }\\n        }\\n\\t\\t\\n        for(int i = 1;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[i][0]==0 ||matrix[0][j]==0){\\n                    matrix[i][j] = 0;\\n                }\\n                } \\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            if(matrix[0][0]==0){\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        for(int i = 0;i<m;i++){\\n            if(col0 == 0){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n# 1. Brute force Approach\\nComplexity\\nTime complexity:O((NM)(N + M)) + O(N*M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(1)\\n\\n# Code\\n\\nclass Solution {\\n    \\n    // making rows negative excluding 0\\'s\\n    public static void makeRow(int matrix[][],int n,int m,int i){\\n        for(int j=0;j<n;j++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n            \\n        }\\n    }\\n    \\n      // making cols negative excluding 0\\'s\\n    public static void makeCol(int matrix[][],int n,int m,int j){\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n        }\\n    }\\n    \\n    // main function\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix[0].length;\\n        int m = matrix.length;\\n       \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    makeRow(matrix,n,m,i);\\n                    makeCol(matrix,n,m,j);\\n                }\\n            }\\n        }\\n        \\n        // itterate through the matrix and mark 0\\'s where negative is present \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]== -1){\\n                    matrix[i][j]=0;\\n                }\\n                \\n            }\\n        }\\n    }\\n}\\n```\n```\\n#2. Better Approach\\nComplexity\\nTime complexity:O(2*(N*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(N) + O(M)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int row [] = new int[m];\\n        int col[] = new int[n];\\n\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                   \\n                   row [i] = 1;\\n                   col [j] = 1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(row[i]==1 ||col[j]==1){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\n```\\n\\n#3. Optimal Approach\\nComplexity\\nTime complexity:O(2*(N*M))\\nSpace complexity:O(1)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){  \\n                    matrix[i][0] = 0;\\n                if(j != 0){\\n                    matrix[0][j] = 0;\\n                }else col0 = 0;\\n                }\\n            }\\n        }\\n\\t\\t\\n        for(int i = 1;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[i][0]==0 ||matrix[0][j]==0){\\n                    matrix[i][j] = 0;\\n                }\\n                } \\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            if(matrix[0][0]==0){\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        for(int i = 0;i<m;i++){\\n            if(col0 == 0){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316512,
                "title": "java-solution-for-beginners",
                "content": "*** Please upvote if helpful!**\\n```\\npublic void setZeroes(int[][] matrix) {\\n        int[] row = new int[matrix.length];\\n        int[] col = new int[matrix[0].length];\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    row[i] = -1;\\n                    col[j] = -1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (row[i] == -1 || col[j] == -1) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void setZeroes(int[][] matrix) {\\n        int[] row = new int[matrix.length];\\n        int[] col = new int[matrix[0].length];\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    row[i] = -1;\\n                    col[j] = -1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (row[i] == -1 || col[j] == -1) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512927,
                "title": "python-o-1-aux-space-sol-by-bit-masking-72-with-explanation",
                "content": "Python O(1) aux space sol by bit masking\\n\\nLet *m*, *n* denote as the dimension of matrix height and width.\\n\\n---\\n\\n**Hint**:\\nWhat we need to know is **index of row** and **index column** for **zero element**.\\n\\nUsually, first idea pop into our head is to to store those indices in a set, which is up to O( m + n )\\n\\nActually, we can be more memory-space saving by using bit masking, reduce aux space cost to O(1).\\n\\n---\\n\\n**Algorithm**:\\n\\nStep_#1.\\n\\nScan each element in matrix.\\n**Setup bit masking for zero element**, store them in integer.\\n\\nFor example, if masking row is row_#**0**, row_#**1**, and row_**#3**, then\\n**row_mask** = (1<<**0**) + (1<<**1**) + (1<<**3**) = 2^**0** + 2^**1** + 2^**3**\\n= 0b **1011**\\n\\nSimilarly, masking column is setup in the same way.\\n\\n---\\n\\nStep_#2.\\n\\nIterate each position in matrix,\\n**Clean specified position to 0** by **row mask** and **column mask**.\\n\\n---\\n\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        h, w = len( matrix), len( matrix[0])\\n        \\n        row_mask, col_mask = 0, 0\\n        \\n        ## Step_#1\\n        #\\n        # Setup masking for zero element\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if matrix[y][x] == 0:\\n                    \\n                    row_mask |= (1<<y)\\n                    col_mask |= (1<<x)\\n        \\n        \\n        ## Step_#2\\n        #\\n        # Clear by row mask and column mask\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if row_mask & (1<<y) or col_mask & (1<<x):\\n                    matrix[y][x] = 0\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #1252 Cells with Odd Values in a Matrix](https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/)",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        h, w = len( matrix), len( matrix[0])\\n        \\n        row_mask, col_mask = 0, 0\\n        \\n        ## Step_#1\\n        #\\n        # Setup masking for zero element\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if matrix[y][x] == 0:\\n                    \\n                    row_mask |= (1<<y)\\n                    col_mask |= (1<<x)\\n        \\n        \\n        ## Step_#2\\n        #\\n        # Clear by row mask and column mask\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if row_mask & (1<<y) or col_mask & (1<<x):\\n                    matrix[y][x] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597295,
                "title": "3-approaches-from-brute-to-optimal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo traverse through thw whole matrix and if a zero is found then set whole row and column to 0\\n# Approach 1:\\n<!-- Describe your approach to solving the problem. -->\\nTraversing the matrix and if 0 is found then setting it to a negative number cause setting it to zero can hamper values of other row and columns where initially 0 was not present after setting with negative number traversing again through matrix and setting to zero wherever negative number is found. This approach works only if no negative numbers are present in the matrix.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*M)*O(N+M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setRowColumn(vector<vector<int>>& matrix,int m,int n,int r,int c)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(matrix[r][i]!=0)\\n                matrix[r][i]=-1;\\n        }\\n        for(int j=0;j<m;j++)\\n        {\\tif(matrix[j][c]!=0)\\n                matrix[j][c]=-1;\\n        }\\n    }\\n    void setZeroes(vector<vector<int>> &matrix)\\n    {\\n        // Write your code here.\\n        int m=matrix.size(), n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    setRowColumn(matrix,m,n,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]<0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```\\n\\n# Approach 2:\\n<!-- Describe your approach to solving the problem. -->\\nUsing dummy arrays to keep track of zeroes. Setting that particular row to 0 in dummy row as well as dummy column arrays wherever zero is found in the cell. Again traversing through the matrix and replacing current value by 0 if current cell dummy row index or dummy column index is set to 0.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*M + N*M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)+O(M)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size(),n=matrix[0].size();\\n\\tvector<int> rows(m,1),cols(n,1);\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\trows[i]=0;\\n\\t\\t\\t\\tcols[j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(rows[i]==0 || cols[j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n  }\\n};\\n```\\n# Approach 3:\\n<!-- Describe your approach to solving the problem. -->\\nUsing dummy arrays increases space complexity to O(N) so trying to reduce space complexity.\\nWe use the 1st row and 1st column of given array as dummy array but matrix[0][0] coincides so to resolve this we use dummy column from 1 to n and dummy row from 0 to m. so for keeping track of whether dummy row contains any 0 we use a variable col and set it to 0 if a 0 is found in dummy row.\\nWe again traverse the array apart from dummy row and dummy column i.e from i-> 1 to m and j-> 1 to n to find if matrix cell contains any zero if it does then we check whether dummy column or row is set if it is set then we set the matrix cell to zero.\\nNow we again need to perform similar operation for dummy row as well as dummy column. dummy row depends on matrix [0][0] whereas as dummy column depends on cols variable so we set it accordingly.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*M + N*M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n    bool cols=1;\\n\\tint m=matrix.size(),n=matrix[0].size();\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][0]=0;\\n\\t\\t\\t\\tif(j!=0)\\n\\t\\t\\t\\t\\tmatrix[0][j]=0;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcols=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=1;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=1;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]!=0)\\n\\t\\t\\t{\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) \\n\\t\\t\\t\\t{\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\tif(matrix[0][0]==0)\\n\\t{\\n\\t\\tfor (int i = 0; i < n; i++) \\n\\t\\t{\\n\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n    }\\n\\tif(cols==0)\\n\\t{\\n\\t\\tfor (int j = 0; j < m; j++) \\n\\t\\t{\\n\\t\\t\\tmatrix[j][0] = 0;\\n\\t\\t}\\n    }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setRowColumn(vector<vector<int>>& matrix,int m,int n,int r,int c)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(matrix[r][i]!=0)\\n                matrix[r][i]=-1;\\n        }\\n        for(int j=0;j<m;j++)\\n        {\\tif(matrix[j][c]!=0)\\n                matrix[j][c]=-1;\\n        }\\n    }\\n    void setZeroes(vector<vector<int>> &matrix)\\n    {\\n        // Write your code here.\\n        int m=matrix.size(), n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    setRowColumn(matrix,m,n,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]<0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size(),n=matrix[0].size();\\n\\tvector<int> rows(m,1),cols(n,1);\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\trows[i]=0;\\n\\t\\t\\t\\tcols[j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(rows[i]==0 || cols[j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n    bool cols=1;\\n\\tint m=matrix.size(),n=matrix[0].size();\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][0]=0;\\n\\t\\t\\t\\tif(j!=0)\\n\\t\\t\\t\\t\\tmatrix[0][j]=0;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcols=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=1;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=1;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]!=0)\\n\\t\\t\\t{\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) \\n\\t\\t\\t\\t{\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\tif(matrix[0][0]==0)\\n\\t{\\n\\t\\tfor (int i = 0; i < n; i++) \\n\\t\\t{\\n\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n    }\\n\\tif(cols==0)\\n\\t{\\n\\t\\tfor (int j = 0; j < m; j++) \\n\\t\\t{\\n\\t\\t\\tmatrix[j][0] = 0;\\n\\t\\t}\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243163,
                "title": "python-easy-solution",
                "content": "I have initialize the coordinate list for row and col. If we found zero we append its row and col coordinates to respective list....Easy??\\n\\nFor the next steps I\\'m simply adding zero to (0-R, 1-R, 2-R, ...upto no. of rows) indexes. Similarly for the column I\\'m adding zero to (C-0, C-1, C-2, ...upto no of columns) indexes. Easy..!!\\n\\nEasy and Helpful ?? **Make sure to Upvote** \\n\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        row, col = [], []\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c] == 0:\\n                    row.append(r)\\n                    col.append(c)\\n        \\n        for r in row:\\n            for i in range(len(matrix[0])):\\n                matrix[r][i] = 0\\n        \\n        for c in col:\\n            for i in range(len(matrix)):\\n                matrix[i][c] = 0\\n```\\n\\n![image](https://assets.leetcode.com/users/images/bcd31b28-9137-4b52-ba0c-3019cb6db3dd_1657052349.8345335.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        row, col = [], []\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c] == 0:\\n                    row.append(r)\\n                    col.append(c)\\n        \\n        for r in row:\\n            for i in range(len(matrix[0])):\\n                matrix[r][i] = 0\\n        \\n        for c in col:\\n            for i in range(len(matrix)):\\n                matrix[i][c] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944059,
                "title": "two-different-approaches",
                "content": "# without Space ---->O(1)\\n# Time complexity ------>O(N^3)\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    for row in range(n):\\n                        if matrix[i][row]!=0:\\n                            matrix[i][row]=-2**32\\n                    for col in range(m):\\n                        if matrix[col][j]!=0:\\n                            matrix[col][j]=-2**32\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==(-2**32):\\n                    matrix[i][j]=0\\n```\\n# with space Complexity:O(2*k) \\n# Time Complexity--->O(N^2)\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        arr=[]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    arr.append([i,j])\\n                \\n        for k,l in arr:\\n            for row in range(n):\\n                matrix[k][row]=0\\n            for col in range(m):\\n                matrix[col][l]=0\\n  ```\\n  # please upvote me it would encourage me alot\\n\\n\\n            \\n\\n\\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    for row in range(n):\\n                        if matrix[i][row]!=0:\\n                            matrix[i][row]=-2**32\\n                    for col in range(m):\\n                        if matrix[col][j]!=0:\\n                            matrix[col][j]=-2**32\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==(-2**32):\\n                    matrix[i][j]=0\\n```\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        arr=[]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    arr.append([i,j])\\n                \\n        for k,l in arr:\\n            for row in range(n):\\n                matrix[k][row]=0\\n            for col in range(m):\\n                matrix[col][l]=0\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3155961,
                "title": "simplest-c-solution-using-set-and-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        set<int>r,c;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n\\n            }\\n        }\\n    for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(r.count(i) || c.count(j))\\n                matrix[i][j]=0;\\n                }\\n            \\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\nDo upvote if it helped\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        set<int>r,c;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n\\n            }\\n        }\\n    for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(r.count(i) || c.count(j))\\n                matrix[i][j]=0;\\n                }\\n            \\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\nDo upvote if it helped\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802535,
                "title": "striver-s-solution-upvote-if-you-like",
                "content": "# Intuition\\nusing striver approach\\n\\n# Approach\\nstore states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable \"colm\" for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way.\\n\\n# Complexity\\nO(m*n)\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1,rows=matrix.size(),col=matrix[0].size();\\n        for(int i=0;i<rows;i++)\\n        {\\n        if(matrix[i][0]==0) colm=0;\\n          for(int j=1;j<col;j++)\\n         {\\n            if(matrix[i][j]==0)\\n                matrix[i][0]=matrix[0][j]=0;\\n            \\n         }\\n        }\\n        for(int i=rows-1;i>=0;i--)\\n        {\\n            for(int j=col-1;j>=1;j--)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n                \\n                \\n            }\\n            if(colm==0) matrix[i][0]=0;\\n            \\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1,rows=matrix.size(),col=matrix[0].size();\\n        for(int i=0;i<rows;i++)\\n        {\\n        if(matrix[i][0]==0) colm=0;\\n          for(int j=1;j<col;j++)\\n         {\\n            if(matrix[i][j]==0)\\n                matrix[i][0]=matrix[0][j]=0;\\n            \\n         }\\n        }\\n        for(int i=rows-1;i>=0;i--)\\n        {\\n            for(int j=col-1;j>=1;j--)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n                \\n                \\n            }\\n            if(colm==0) matrix[i][0]=0;\\n            \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628269,
                "title": "set-matrix-zeroes-c-easy-and-clear-cut-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    //Just keep it very simple \\n    //if any row or col containing zeros that means we have to set that row or col to zero.\\n    void setZeroes(vector<vector<int>>& matrix){\\n        bool isrow = false, iscol = false;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j] == 0){\\n                    if(i == 0) isrow = true;\\n                    if(j == 0) iscol = true;\\n                    //for further memorization we set the first element of that col and row to zero.\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<matrix.size();i++){\\n            for(int j=1;j<matrix[0].size();j++){\\n                if(matrix[i][0] == 0 or matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(iscol) for(int i=0;i<matrix.size();i++) matrix[i][0] = 0;\\n        if(isrow) for(int j=0;j<matrix[0].size();j++) matrix[0][j] = 0;\\n    }\\n};\\n```\\n**Guys Don\\'t forget to upvote me.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Just keep it very simple \\n    //if any row or col containing zeros that means we have to set that row or col to zero.\\n    void setZeroes(vector<vector<int>>& matrix){\\n        bool isrow = false, iscol = false;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j] == 0){\\n                    if(i == 0) isrow = true;\\n                    if(j == 0) iscol = true;\\n                    //for further memorization we set the first element of that col and row to zero.\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<matrix.size();i++){\\n            for(int j=1;j<matrix[0].size();j++){\\n                if(matrix[i][0] == 0 or matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(iscol) for(int i=0;i<matrix.size();i++) matrix[i][0] = 0;\\n        if(isrow) for(int j=0;j<matrix[0].size();j++) matrix[0][j] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968645,
                "title": "o-1-space-easily-explained-faster-than-100",
                "content": "**Code :**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) \\n{\\n        int m = matrix.size(), n = matrix[0].size();\\n        bool isRowZero = false, isColZero = false;\\n        \\n\\t\\t// Check the first Column, zero is present or not...\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                isColZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check the First Row, zero is present or not\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                isRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check all elements except first row & first Column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// process all elements except first row & first column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        \\n\\t\\t// process first column\\n        if(isColZero)\\n        {\\n            for(int i = 0; i < m; i++)\\n                matrix[i][0] = 0;\\n        }\\n        \\n\\t\\t// process first row\\n        if(isRowZero)\\n        {\\n            for(int i = 0; i < n; i++)\\n                matrix[0][i] = 0;\\n        }\\n}\\n```\\n\\n**Time Complexity : O(m + n)**\\n**Space Complexity : O(1)**\\n\\n**If you find it useful please upvote.\\nIf you have any question feel free to ask in comment section.**\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvoid setZeroes(vector<vector<int>>& matrix) \\n{\\n        int m = matrix.size(), n = matrix[0].size();\\n        bool isRowZero = false, isColZero = false;\\n        \\n\\t\\t// Check the first Column, zero is present or not...\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                isColZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check the First Row, zero is present or not\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                isRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check all elements except first row & first Column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// process all elements except first row & first column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        \\n\\t\\t// process first column\\n        if(isColZero)\\n        {\\n            for(int i = 0; i < m; i++)\\n                matrix[i][0] = 0;\\n        }\\n        \\n\\t\\t// process first row\\n        if(isRowZero)\\n        {\\n            for(int i = 0; i < n; i++)\\n                matrix[0][i] = 0;\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1443892,
                "title": "m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& A) {\\n        const int m = A.size(), n = A[0].size();\\n        vector<int> row(m, 1), col(n,1);\\n        for(int i =0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(A[i][j] == 0){\\n                    col[j] = 0;\\n                    row[i] = 0;\\n                }\\n        \\n        for(int i =0; i < m; i++)                        \\n            for(int j = 0; j < n; j++) \\n                if(row[i] == 0 || col[j] == 0) \\n                    A[i][j] = 0;            \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& A) {\\n        const int m = A.size(), n = A[0].size();\\n        vector<int> row(m, 1), col(n,1);\\n        for(int i =0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(A[i][j] == 0){\\n                    col[j] = 0;\\n                    row[i] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1400851,
                "title": "2-approach-w-explanation-o-m-n-o-1-c-python-java",
                "content": "**OBSERVATION:**\\nThe time complexity of this problem remains `O(M*N)`, the only improvement we can do is of the space complexity. So we will have 2 approaches here\\n\\n# **APPROACH I:**\\n*Additional Memory Approach-*\\nIf any cell of the matrix has a zero we can record its row and column number. All the cells of this recorded row and column can be marked zero in the next iteration.\\n\\n**Algorithm**\\n* We iterate over the original array and look for zero entries.\\n* If we find that an entry at `[i, j]` is `0`, then we need to record somewhere the row `i` and column `j`.\\n* So, we use two sets, one for the rows and one for the columns.\\n```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\\n*  We iterate over the array once again, and check each cell.\\n\\t*  If the row **Or** column is marked, we set the value of the cell as 0.\\n\\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(M+N)**\\n\\n# **APPROACH II**\\nWe handle cases seperately. \\n* Check the first row and column for pre-existing `0`. \\n\\t* If found we mark that row or column as true\\n* Now we work upon the remaining matrix.\\n\\t* First we look for the cell that has `0` in it.\\n\\t* Then proceed with the working i.e. marking the cell as 0. \\n*  Now work upon the checked first row and column and update their values.\\n\\t*  Note: Updating before hand gives WA\\n \\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(1)**",
                "solutionTags": [],
                "code": "```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383088,
                "title": "three-solutions-in-python-3-o-1-o-m-n-and-o-mn-space",
                "content": "_O(1) space:_\\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N = len(m), len(m[0])\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j]: continue\\n    \\t\\tfor k in range(N):\\n    \\t\\t\\tif m[i][k] != 0: m[i][k] = \\' \\'\\n    \\t\\tfor k in range(M):\\n    \\t\\t\\tif m[k][j] != 0: m[k][j] = \\' \\'\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j] == \\' \\': m[i][j] = 0\\n\\t\\t\\t\\n\\t\\t\\t\\n```\\n_O(M+N) space:_\\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N, = len(m), len(m[0])\\n    \\tR, C = [i for i,j in enumerate(m) if 0 in j], [i for i,j in enumerate(zip(*m)) if 0 in j]\\n    \\tfor i,j in itertools.product(R,range(N)): m[i][j] = 0\\n    \\tfor i,j in itertools.product(C,range(M)): m[j][i] = 0\\n\\n\\n```\\n_O(MN) space:_\\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N, n = len(m), len(m[0]), [list(i) for i in m]\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif n[i][j]: continue\\n    \\t\\tfor k in range(N): m[i][k] = 0\\n    \\t\\tfor k in range(M): m[k][j] = 0\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N = len(m), len(m[0])\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j]: continue\\n    \\t\\tfor k in range(N):\\n    \\t\\t\\tif m[i][k] != 0: m[i][k] = \\' \\'\\n    \\t\\tfor k in range(M):\\n    \\t\\t\\tif m[k][j] != 0: m[k][j] = \\' \\'\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j] == \\' \\': m[i][j] = 0\\n\\t\\t\\t\\n\\t\\t\\t\\n```\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N, = len(m), len(m[0])\\n    \\tR, C = [i for i,j in enumerate(m) if 0 in j], [i for i,j in enumerate(zip(*m)) if 0 in j]\\n    \\tfor i,j in itertools.product(R,range(N)): m[i][j] = 0\\n    \\tfor i,j in itertools.product(C,range(M)): m[j][i] = 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208830,
                "title": "javascript-o-n-m-time-o-1-space-first-row-col-flags",
                "content": "```javascript\\n/**\\n * Time: O(n * m)\\n * Space: O(1)\\n * n - number of rows in matrix\\n * m - number of cols in matrix\\n */\\n\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nfunction setZeroes(matrix) {\\n  let firstColHasZero = false;\\n  let firstRowHasZero = false;\\n\\n  // Check if first col has zero\\n  for (let i = 0; i < matrix.length; i++) {\\n    if (matrix[i][0] === 0) {\\n      firstColHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Check if first row has zero\\n  for (let j = 0; j < matrix[0].length; j++) {\\n    if (matrix[0][j] === 0) {\\n      firstRowHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Use first row and col as flags, set matrix[i][0] and matrix[0][j] to 0 if matrix[i][j] is 0\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out cells based on flags in first row and col\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][0] === 0 || matrix[0][j] === 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out first col\\n  if (firstColHasZero) {\\n    for (let i = 0; i < matrix.length; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n\\n  // Zero out first row\\n  if (firstRowHasZero) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      matrix[0][j] = 0;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(n * m)\\n * Space: O(1)\\n * n - number of rows in matrix\\n * m - number of cols in matrix\\n */\\n\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nfunction setZeroes(matrix) {\\n  let firstColHasZero = false;\\n  let firstRowHasZero = false;\\n\\n  // Check if first col has zero\\n  for (let i = 0; i < matrix.length; i++) {\\n    if (matrix[i][0] === 0) {\\n      firstColHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Check if first row has zero\\n  for (let j = 0; j < matrix[0].length; j++) {\\n    if (matrix[0][j] === 0) {\\n      firstRowHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Use first row and col as flags, set matrix[i][0] and matrix[0][j] to 0 if matrix[i][j] is 0\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out cells based on flags in first row and col\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][0] === 0 || matrix[0][j] === 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out first col\\n  if (firstColHasZero) {\\n    for (let i = 0; i < matrix.length; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n\\n  // Zero out first row\\n  if (firstRowHasZero) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      matrix[0][j] = 0;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26039,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Set Matrix Zeroes** https://leetcode.com/problems/set-matrix-zeroes/\\n\\n**Algorithm**\\n1. Encode the state of each row in matrix[i,0].\\n2. Encode the state of each col in matrix[0,j].\\n3. During steps 1 and 2, maintain two boolean variables to keep status of row 0 and column 0. Why do we need these variables? Imagine we have matrix[3,4] = 0. We will mark matrix[3,0] and matrix[0,4] as 0. This does not mean we should strike row 0 as zero since no element in row 0 were zero. Hence the two variables.\\n4. While filling, first fill all sections of the matrix except zero row and zero col. Fill zero row and col only if zero_row or zero_col are marked true.\\n\\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n = len(matrix),len(matrix[0])\\n        zero_row, zero_col = False, False\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n                    zero_row = True if i == 0 else zero_row\\n                    zero_col = True if j == 0 else zero_col\\n\\n        for j in range(1,n):\\n            if matrix[0][j] == 0:\\n                for i in range(1, m):\\n                    matrix[i][j] = 0\\n        \\n        for i in range(1,m):\\n            if matrix[i][0] == 0:\\n                for j in range(1, n):\\n                    matrix[i][j] = 0\\n        \\n        if zero_row:\\n            for j in range(n):\\n                matrix[0][j] = 0\\n                \\n        if zero_col:\\n            for i in range(m):\\n                matrix[i][0] = 0\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n = len(matrix),len(matrix[0])\\n        zero_row, zero_col = False, False\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n                    zero_row = True if i == 0 else zero_row\\n                    zero_col = True if j == 0 else zero_col\\n\\n        for j in range(1,n):\\n            if matrix[0][j] == 0:\\n                for i in range(1, m):\\n                    matrix[i][j] = 0\\n        \\n        for i in range(1,m):\\n            if matrix[i][0] == 0:\\n                for j in range(1, n):\\n                    matrix[i][j] = 0\\n        \\n        if zero_row:\\n            for j in range(n):\\n                matrix[0][j] = 0\\n                \\n        if zero_col:\\n            for i in range(m):\\n                matrix[i][0] = 0\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400855,
                "title": "c-easy-clean-solution-o-1-implementation",
                "content": "**Solution:**\\n\\nApproach\\n1. First check if there is any `0` in the first row or column and set the respective flag(`row, col`) to `1`.\\n2. Now, iterate from `row 2` and `column 2` and check if there is any zero present; fill the first row index `ar[0][j] = 0` and first column index `ar[i][0] = 0`.\\n3. Our first row and first column determine which rows and columns should be fully set to `0`.\\n4. Now, check if flag `row == 1`, means our first row itself should be made `0`.\\n5. Finally, check if flag `col == 1`, means our first column itself should be made `0`.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& ar) {\\n        int n = ar.size();\\n        int m = ar[0].size();\\n        int row = 0, col = 0;\\n        for(int i = 0; i < m; i++){\\n            if(ar[0][i] == 0){\\n                row = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(ar[i][0] == 0){\\n                col = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                if(ar[i][j] == 0){\\n                    ar[i][0] = 0;\\n                    ar[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 1; i < n; i++){\\n            if(ar[i][0] == 0)\\n                for(int j = 0; j < m; j++)\\n                    ar[i][j] = 0;\\n        }\\n        for(int i = 1; i < m; i++){\\n            if(ar[0][i] == 0)\\n                for(int j = 0; j < n; j++)\\n                    ar[j][i] = 0;\\n        }\\n        if(row == 1){\\n            for(int i = 0; i < m; i++)\\n                ar[0][i] = 0;\\n        }\\n        if(col == 1){\\n            for(int i = 0; i < n; i++)\\n                ar[i][0] = 0;\\n        }\\n    }\\n};\\n```\\n**Feel free to share your ideas or any improvements as well.**\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& ar) {\\n        int n = ar.size();\\n        int m = ar[0].size();\\n        int row = 0, col = 0;\\n        for(int i = 0; i < m; i++){\\n            if(ar[0][i] == 0){\\n                row = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(ar[i][0] == 0){\\n                col = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                if(ar[i][j] == 0){\\n                    ar[i][0] = 0;\\n                    ar[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 1; i < n; i++){\\n            if(ar[i][0] == 0)\\n                for(int j = 0; j < m; j++)\\n                    ar[i][j] = 0;\\n        }\\n        for(int i = 1; i < m; i++){\\n            if(ar[0][i] == 0)\\n                for(int j = 0; j < n; j++)\\n                    ar[j][i] = 0;\\n        }\\n        if(row == 1){\\n            for(int i = 0; i < m; i++)\\n                ar[0][i] = 0;\\n        }\\n        if(col == 1){\\n            for(int i = 0; i < n; i++)\\n                ar[i][0] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370007,
                "title": "o-n-space-solution-to-o-1-space-solution-in-c-diagram-included",
                "content": "**We can have a simple trivial solution by maintaining 2 arrays(1 for rows and 1 for columns)**\\n\\nWe traverse the Matrix and if we find a 0 we mark the row and column arrays as 1(in those index), then after traversing the whole array we again traverse the whole array to set the matrix as 0.\\n\\nTry dry running with this example\\n<img src=\"https://assets.leetcode.com/users/images/624d7294-3ebd-4ec4-8987-f8050e3d8ce6_1627550828.8580964.png\" alt=\"drawing\" width=\"500\"/>\\n\\nCode : \\n```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\tint row[n],col[m]; //This is the matrix where we maintain if 0th row or 3rd column has to be set to 0\\n\\tmemset(row,0,sizeof(row));\\n\\tmemset(col,0,sizeof(col));\\n\\n\\t//if row[index] is set a 1 means we have to set the entire row\\n\\tfor(int i = 0;i<n;i++)\\n\\t{   \\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) row[i] = 1,col[j] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t//after find which rows and columns have to be set to 0\\n\\t//We just traverse the matrix again and set them as 0;\\n\\tfor(int i = 0;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t\\tif(row[i] == 1 || col[j] == 1)\\n\\t\\t\\t\\tmat[i][j] = 0;\\n\\t}\\n```\\n\\n**Optimal solution  (Read the above solution first)**\\n\\nTo Optimize this we use the top row and first column as marked in the diagram, We use top row to store if a column has to be set to 0 and first column to store if we have to set a row to 0\\n\\nTry dry running with this example\\n<img src=\"https://assets.leetcode.com/users/images/cc4db96e-07b1-43f6-bfcc-623f94acb9c6_1627552363.9453866.png\" alt=\"drawing\" width=\"500\"/>\\n\\nCode:\\n```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\n\\t//Rzero is used to check if the top row has to be set to 0\\n\\tint Rzero = 0,Czero = 0;\\n\\n\\t//Rzero is set to 1 if we have a 0 in the top row\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(mat[i][0] == 0) Rzero = 1;\\n\\n\\t//Same logic is applied for the first column\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(mat[0][i] == 0) Czero = 1;\\n\\n\\t//same the previous solution we store we have to set a row or column to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) mat[i][0]=mat[0][j]=0;\\n\\t\\t}\\n\\t}\\n\\n\\t//we then actually then set them to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 1;j<m;j++)\\n\\t\\t\\tif(mat[i][0] == 0 || mat[0][j] == 0) mat[i][j] = 0;\\n\\t}\\n\\n\\t//top row and first col are set to 0 \\n\\t//if there was a 0 in them\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(Rzero) mat[i][0] = 0;\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(Czero) mat[0][i] = 0;\\n```\\n\\nIf you have any doubts hit me in the comments below.\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\tint row[n],col[m]; //This is the matrix where we maintain if 0th row or 3rd column has to be set to 0\\n\\tmemset(row,0,sizeof(row));\\n\\tmemset(col,0,sizeof(col));\\n\\n\\t//if row[index] is set a 1 means we have to set the entire row\\n\\tfor(int i = 0;i<n;i++)\\n\\t{   \\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) row[i] = 1,col[j] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t//after find which rows and columns have to be set to 0\\n\\t//We just traverse the matrix again and set them as 0;\\n\\tfor(int i = 0;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t\\tif(row[i] == 1 || col[j] == 1)\\n\\t\\t\\t\\tmat[i][j] = 0;\\n\\t}\\n```\n```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\n\\t//Rzero is used to check if the top row has to be set to 0\\n\\tint Rzero = 0,Czero = 0;\\n\\n\\t//Rzero is set to 1 if we have a 0 in the top row\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(mat[i][0] == 0) Rzero = 1;\\n\\n\\t//Same logic is applied for the first column\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(mat[0][i] == 0) Czero = 1;\\n\\n\\t//same the previous solution we store we have to set a row or column to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) mat[i][0]=mat[0][j]=0;\\n\\t\\t}\\n\\t}\\n\\n\\t//we then actually then set them to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 1;j<m;j++)\\n\\t\\t\\tif(mat[i][0] == 0 || mat[0][j] == 0) mat[i][j] = 0;\\n\\t}\\n\\n\\t//top row and first col are set to 0 \\n\\t//if there was a 0 in them\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(Rzero) mat[i][0] = 0;\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(Czero) mat[0][i] = 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124948,
                "title": "c-clean-o-1-space-sol-detailed-explanation",
                "content": "```\\n/*\\n    \\n    https://leetcode.com/problems/set-matrix-zeroes/solution/\\n    \\n    Idea is to use 1st row and 1st col to save the 0 reset status\\n    for the rows and cols. Now since position [0][0] will overlap\\n    between the row and col status vector, we use 2 separate variables \\n    just to save whether 1st row/col needs a reset or not.\\n    \\n    TC: O(MN)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // saves the reset status of row and col resp.\\n        int first_row = matrix[0][0], first_col = matrix[0][0];\\n        // check the first col and row, if either needs a reset to 0\\n        // col check\\n        for(int i = 0; first_col && i < matrix.size(); i++)\\n            if(!matrix[i][0]) \\n                first_col = 0; \\n            \\n        // row check\\n        for(int i = 0; first_row && i < matrix[0].size(); i++)\\n            if(!matrix[0][i]) \\n                first_row = 0; \\n        \\n        // We will use the first row to save all the col status, first \\n        // col to save all the row status\\n        // If some col/row needs a reset, the info will be saved there\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(!matrix[i][j]) \\n                    matrix[0][j] = matrix[i][0] = 0;\\n            }\\n        \\n        // set the 0 values\\n        for(int i = 1; i < matrix.size(); i++)\\n            for(int j = 1; j < matrix[0].size(); j++)\\n                if(!matrix[0][j] || !matrix[i][0])\\n                    matrix[i][j] = 0;\\n        // check if the first row and col needs a reset\\n        if(!first_col) \\n            for(int i = 0; i < matrix.size(); i++)\\n                matrix[i][0] = 0;  \\n        if(!first_row)\\n            for(int i = 0; i < matrix[0].size(); i++)\\n                matrix[0][i] = 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    \\n    https://leetcode.com/problems/set-matrix-zeroes/solution/\\n    \\n    Idea is to use 1st row and 1st col to save the 0 reset status\\n    for the rows and cols. Now since position [0][0] will overlap\\n    between the row and col status vector, we use 2 separate variables \\n    just to save whether 1st row/col needs a reset or not.\\n    \\n    TC: O(MN)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // saves the reset status of row and col resp.\\n        int first_row = matrix[0][0], first_col = matrix[0][0];\\n        // check the first col and row, if either needs a reset to 0\\n        // col check\\n        for(int i = 0; first_col && i < matrix.size(); i++)\\n            if(!matrix[i][0]) \\n                first_col = 0; \\n            \\n        // row check\\n        for(int i = 0; first_row && i < matrix[0].size(); i++)\\n            if(!matrix[0][i]) \\n                first_row = 0; \\n        \\n        // We will use the first row to save all the col status, first \\n        // col to save all the row status\\n        // If some col/row needs a reset, the info will be saved there\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(!matrix[i][j]) \\n                    matrix[0][j] = matrix[i][0] = 0;\\n            }\\n        \\n        // set the 0 values\\n        for(int i = 1; i < matrix.size(); i++)\\n            for(int j = 1; j < matrix[0].size(); j++)\\n                if(!matrix[0][j] || !matrix[i][0])\\n                    matrix[i][j] = 0;\\n        // check if the first row and col needs a reset\\n        if(!first_col) \\n            for(int i = 0; i < matrix.size(); i++)\\n                matrix[i][0] = 0;  \\n        if(!first_row)\\n            for(int i = 0; i < matrix[0].size(); i++)\\n                matrix[0][i] = 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26040,
                "title": "very-short-python-solution-with-o-1-space-complexity-13-lines-of-code",
                "content": "Idea is as follow:\\nIts only necessary to find out which row and column contains 0. After this step, change all elements in certain row and column to 0. If no 0 exists, do nothing.\\n\\n```\\n# Two sets that record which row and column has 0\\nrowSet = set()\\ncolSet = set()\\n# Iterate each element. \\n# If it is 0, record row and column number\\nfor r in range(len(matrix)):\\n    for c in range(len(matrix[0])):\\n        if matrix[r][c] == 0:\\n            rowSet.add(r)\\n            colSet.add(c)\\n# Change all rows containing 0 to 0\\nfor r in rowSet:\\n    for c in range(len(matrix[0])):\\n        matrix[r][c] = 0\\n# Change all columns containing 0 to 0\\nfor c in colSet:\\n    for r in range(len(matrix)):\\n        matrix[r][c] = 0\\n```",
                "solutionTags": [],
                "code": "```\\n# Two sets that record which row and column has 0\\nrowSet = set()\\ncolSet = set()\\n# Iterate each element. \\n# If it is 0, record row and column number\\nfor r in range(len(matrix)):\\n    for c in range(len(matrix[0])):\\n        if matrix[r][c] == 0:\\n            rowSet.add(r)\\n            colSet.add(c)\\n# Change all rows containing 0 to 0\\nfor r in rowSet:\\n    for c in range(len(matrix[0])):\\n        matrix[r][c] = 0\\n# Change all columns containing 0 to 0\\nfor c in colSet:\\n    for r in range(len(matrix)):\\n        matrix[r][c] = 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26181,
                "title": "java-constant-space-solution-hint-use-space-inside-the-matrix",
                "content": "An easy way to solve this problem is to use extra O(m + n) space, storing the zero row and column indices. \\n\\nWe can improve it by not using the extra O(m + n) space, instead, we can use the space inside that input matrix (inspired by **Shangrila**'s solution, which use the first row and column for storage).\\n\\nIn this solution, at the beginning, I find the first zero element, and use that row and column as the temp place for storing the other zero element indices. After we get all the zero indices, then set the corresponding row and columns to zero. Please see the code below.\\n\\n    public void setZeroes(int[][] matrix) {\\n        int rowTemp = -1;   // select a row to store the column indices for the zero element\\n        int colTemp = -1;   // select a column to store the row indices for the zero element\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    // find the first zero element\\n                    if (rowTemp == -1) {\\n                        rowTemp = i;\\n                        colTemp = j;\\n                    }\\n                    // update indice in the row and column temp\\n                    else {\\n                        matrix[rowTemp][j] = 0;\\n                        matrix[i][colTemp] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        // no zero in the matrix\\n        if (rowTemp == -1)\\n            return;\\n        // set rows to zero\\n        for (int i = 0; i < matrix.length; i++) {\\n            if (i == rowTemp)   // skip the temp row\\n                continue;\\n            if (matrix[i][colTemp] == 0) {\\n                for (int j = 0; j < matrix[0].length; j++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set columns to zero\\n        for (int j = 0; j < matrix[0].length; j++) {\\n            if (matrix[rowTemp][j] == 0) {\\n                for (int i = 0; i < matrix.length; i++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set the final temp row to zero\\n        for (int j = 0; j < matrix[0].length; j++)\\n            matrix[rowTemp][j] = 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "An easy way to solve this problem is to use extra O(m + n) space, storing the zero row and column indices. \\n\\nWe can improve it by not using the extra O(m + n) space, instead, we can use the space inside that input matrix (inspired by **Shangrila**'s solution, which use the first row and column for storage).\\n\\nIn this solution, at the beginning, I find the first zero element, and use that row and column as the temp place for storing the other zero element indices. After we get all the zero indices, then set the corresponding row and columns to zero. Please see the code below.\\n\\n    public void setZeroes(int[][] matrix) {\\n        int rowTemp = -1;   // select a row to store the column indices for the zero element\\n        int colTemp = -1;   // select a column to store the row indices for the zero element\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    // find the first zero element\\n                    if (rowTemp == -1) {\\n                        rowTemp = i;\\n                        colTemp = j;\\n                    }\\n                    // update indice in the row and column temp\\n                    else {\\n                        matrix[rowTemp][j] = 0;\\n                        matrix[i][colTemp] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        // no zero in the matrix\\n        if (rowTemp == -1)\\n            return;\\n        // set rows to zero\\n        for (int i = 0; i < matrix.length; i++) {\\n            if (i == rowTemp)   // skip the temp row\\n                continue;\\n            if (matrix[i][colTemp] == 0) {\\n                for (int j = 0; j < matrix[0].length; j++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set columns to zero\\n        for (int j = 0; j < matrix[0].length; j++) {\\n            if (matrix[rowTemp][j] == 0) {\\n                for (int i = 0; i < matrix.length; i++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set the final temp row to zero\\n        for (int j = 0; j < matrix[0].length; j++)\\n            matrix[rowTemp][j] = 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3807640,
                "title": "c-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this approach,I have initialsed 2 unordered maps(one for rows and one for columns) for keeping the record weather a row or column contains a zero in it or not.For it I just traversed through the 2D array and once I get a zero, updated the value of that row and column to 1 in map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversed through the array, if arr[i][j] == 0 then I just set map[i] = 1 and map2[j] = 1.\\nIn second iteration, if any one i and j in matrix is found to be 1, I\\'m updating the value in the original array as 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor this code we\\'re just interating the array twice hence the complexity is : O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe\\'re using two maps which are of length N and M.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_map<int,int>ump;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    ump[i]=1;\\n                    mp[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(ump[i] || mp[j]){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n\\n        \\n        \\n    }\\n};\\n```\\nYour valuable suggestions and even minor optimizations in the code will be warmly welcomed and greatly appreciated.\\n\\nPlease upvote if you like the solution. :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_map<int,int>ump;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    ump[i]=1;\\n                    mp[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(ump[i] || mp[j]){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596062,
                "title": "shortest-solution-using-hashset-o-m-n-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Here whenever we find the 0 element in the matrix we add its row and column to the  relative set.\\n- Since its a set data structure , no two same row or column will be added.\\n- Then we iterate through each row and column in the set and fill the matrix with 0\\'s.\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n        for(int r : row){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[r][i] = 0;\\n            }\\n        }\\n        for(int c : col){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][c] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n        for(int r : row){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[r][i] = 0;\\n            }\\n        }\\n        for(int c : col){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][c] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276573,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O ( m*n )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O( Math.max( n , m ))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int row[] = new int[n];\\n        int col[] = new int[m];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if( arr[i][j] ==0 )\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if( row[i]==1 )\\n            {\\n                for (int j = 0; j < m; j++) {\\n                    arr[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if( col[j]==1 )\\n            {\\n                for (int i = 0; i < n; i++) {\\n                    arr[i][j] = 0 ;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int row[] = new int[n];\\n        int col[] = new int[m];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if( arr[i][j] ==0 )\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if( row[i]==1 )\\n            {\\n                for (int j = 0; j < m; j++) {\\n                    arr[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if( col[j]==1 )\\n            {\\n                for (int i = 0; i < n; i++) {\\n                    arr[i][j] = 0 ;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840148,
                "title": "c-easy-fast-and-short-9-lines-solution",
                "content": "This solution is very short, simple.\\nThe process is divided into three parts.\\n\\n1. Traverse the matrix and finds 0. If it finds 0, it insert row and column in set `rows`, `cols`.\\n2. Iterate through the row(`rows`) and fill in zeros.\\n3. Iterate through the column(`cols`), fill in zeros.\\n\\n```\\n// origin - https://github.com/o-oppang/lets-solve-algorithm\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows, cols;\\n        for( auto i = 0; i < matrix.size(); ++i ) // row\\n            for( auto j = 0; j < matrix[0].size(); ++j ) // col\\n                if( matrix[i][j] == 0 )  { rows.insert(i); cols.insert(j); }\\n        \\n        for( auto row : rows ) // fill rows to zero\\n            std::fill(matrix[row].begin(), matrix[row].end(), 0);\\n        \\n        for( auto col : cols ) // fill cols to zero\\n            for( auto row = 0; row < matrix.size(); ++row )\\n                std::fill(matrix[row].begin() + col, matrix[row].begin() + col + 1, 0);\\n    }\\n};\\n// Runtime: 24 ms, faster than 94.25% of C++ online submissions for Set Matrix Zeroes.\\n// Memory Usage: 13.3 MB, less than 49.73% of C++ online submissions for Set Matrix Zeroes.\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// origin - https://github.com/o-oppang/lets-solve-algorithm\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows, cols;\\n        for( auto i = 0; i < matrix.size(); ++i ) // row\\n            for( auto j = 0; j < matrix[0].size(); ++j ) // col\\n                if( matrix[i][j] == 0 )  { rows.insert(i); cols.insert(j); }\\n        \\n        for( auto row : rows ) // fill rows to zero\\n            std::fill(matrix[row].begin(), matrix[row].end(), 0);\\n        \\n        for( auto col : cols ) // fill cols to zero\\n            for( auto row = 0; row < matrix.size(); ++row )\\n                std::fill(matrix[row].begin() + col, matrix[row].begin() + col + 1, 0);\\n    }\\n};\\n// Runtime: 24 ms, faster than 94.25% of C++ online submissions for Set Matrix Zeroes.\\n// Memory Usage: 13.3 MB, less than 49.73% of C++ online submissions for Set Matrix Zeroes.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522715,
                "title": "java-o-1-space-with-explanation",
                "content": "Thinking Processing: \\n1. First, Let\\'s come out O(m+n) Space solution, which is very directly. We need two arrays to store rows and columns status. It looks like a head of a line to check its line\\'s status. When we loop each point, we just need to update its two headers\\' status. If current point\\'s value is 0, we set its headers to true. After finishing all points\\' loop, we loop the matrix again to update the matrix by checking this two arrays\\' info. When we reach a point, we check its x-coordinate and y-coordinate\\'s arrays status, if true, set current point value to 0. \\nHere I draw a picture to show the idea.\\n![image](https://assets.leetcode.com/users/haimei2/image_1582846410.png)\\nHere are the code: \\n```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean[] rows = new boolean[m];\\n        boolean[] cols = new boolean[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]&&cols[j]) continue;\\n                if (matrix[i][j]==0) {\\n                    rows[i] = true;\\n                    cols[j] = true;\\n                }\\n            }\\n        }\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]||cols[j]) matrix[i][j] = 0;\\n            }\\n        }\\n    }\\n```\\n2. In order to reduce space, we can apply rows[] and cols[]\\'s role to matrix\\'s first row and first column. When we loop the matrix, we update matrix[i][0] and matrix[0][j] status, like rows and cols array. And then when we need to update the whole matrix, we can udpate point(i,j) value according to matrix[i][0] and matrix[0][j], here i and j are starting from 1!!! So how about the first row and first column point\\'s update? We just need additional two variables to help: two boolean varaibles: firstrow and firstcol. \\n![image](https://assets.leetcode.com/users/haimei2/image_1582847354.png)\\n\\nTest Cases:\\n1. []\\n2. [1]\\n3. [[1,1,1],\\n  [1,0,1],\\n  [1,1,1]]  // without firstrow and firstcol help\\n4. [[0,1,2,0],\\n      [3,4,5,2],\\n      [1,3,1,5]] // with firstrow and firstcol help\\n\\t  \\nTime Complexity is O(m\\\\*n)\\n\\nSpace Complexity is O(1)\\n\\n```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean firstrow = false;\\n        boolean firstcol = false;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                    if (i==0) firstrow = true;\\n                    if (j==0) firstcol = true;\\n                }\\n            }\\n        }\\n        for (int i=1; i<m; i++) {\\n            for (int j=1; j<n; j++) {\\n                if (matrix[i][0]==0||matrix[0][j]==0) \\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        if (firstrow) {\\n            for (int j=0; j<n; j++) matrix[0][j] = 0;\\n        }\\n        if (firstcol) {\\n            for (int i=0; i<m; i++) matrix[i][0] = 0;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean[] rows = new boolean[m];\\n        boolean[] cols = new boolean[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]&&cols[j]) continue;\\n                if (matrix[i][j]==0) {\\n                    rows[i] = true;\\n                    cols[j] = true;\\n                }\\n            }\\n        }\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]||cols[j]) matrix[i][j] = 0;\\n            }\\n        }\\n    }\\n```\n```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean firstrow = false;\\n        boolean firstcol = false;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                    if (i==0) firstrow = true;\\n                    if (j==0) firstcol = true;\\n                }\\n            }\\n        }\\n        for (int i=1; i<m; i++) {\\n            for (int j=1; j<n; j++) {\\n                if (matrix[i][0]==0||matrix[0][j]==0) \\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        if (firstrow) {\\n            for (int j=0; j<n; j++) matrix[0][j] = 0;\\n        }\\n        if (firstcol) {\\n            for (int i=0; i<m; i++) matrix[i][0] = 0;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490917,
                "title": "java-easy-and-short-solution-with-explanation",
                "content": "We plan to use the firstRow and firstCol of the matrix to store the state of entire row and matrix. \\n\\n**BUT**\\n\\nDoing this, we might loose the state of the firstRow and firstCol. So we use two variables isFirstRowZero and isFirstColZero to store the state of irstRow and firstCol and later use it to restore them to their correct state. \\n\\nBelow is the solution is with comments for better understanding :)\\n```\\npublic void setZeroes(int[][] matrix) {\\n        \\n\\t// The below two vars store the state of first row and first col\\n\\tboolean isFirstRowZero = false , isFirstColZero = false;\\n\\n\\tfor(int i=0; i<matrix.length; i++) \\n\\t\\tfor(int j=0; j<matrix[0].length; j++) \\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tif(i == 0) isFirstRowZero = true;       // Store state of firstRow\\n\\t\\t\\t\\tif(j == 0) isFirstColZero = true;       // Store state of firstCol\\n\\t\\t\\t\\tmatrix[0][j] = 0;                       // Store state of other row in firstRow\\n\\t\\t\\t\\tmatrix[i][0] = 0;                       // Store state of other col in firstCol\\n\\t\\t\\t}\\n\\n\\tfor(int i=1; i<matrix.length; i++) \\n\\t\\tfor(int j=1; j<matrix[0].length; j++)\\n\\t\\t\\tif(matrix[i][0] == 0 || matrix[0][j] == 0)  // If the first cell of row or col is zero \\n\\t\\t\\t\\tmatrix[i][j] = 0;                       // Mark the current cell as 0\\n\\n\\tif(isFirstRowZero)                                  // if entire firstRow is to be zero\\n\\t\\tfor(int i=0; i<matrix[0].length; i++)\\n\\t\\t\\tmatrix[0][i] = 0;                           // make them all zero\\n\\n\\tif(isFirstColZero)                                  // if entire firstCol is to be zero\\n\\t\\tfor(int i=0; i<matrix.length; i++)\\n\\t\\t\\tmatrix[i][0] = 0;                           // make them all zero\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void setZeroes(int[][] matrix) {\\n        \\n\\t// The below two vars store the state of first row and first col\\n\\tboolean isFirstRowZero = false , isFirstColZero = false;\\n\\n\\tfor(int i=0; i<matrix.length; i++) \\n\\t\\tfor(int j=0; j<matrix[0].length; j++) \\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tif(i == 0) isFirstRowZero = true;       // Store state of firstRow\\n\\t\\t\\t\\tif(j == 0) isFirstColZero = true;       // Store state of firstCol\\n\\t\\t\\t\\tmatrix[0][j] = 0;                       // Store state of other row in firstRow\\n\\t\\t\\t\\tmatrix[i][0] = 0;                       // Store state of other col in firstCol\\n\\t\\t\\t}\\n\\n\\tfor(int i=1; i<matrix.length; i++) \\n\\t\\tfor(int j=1; j<matrix[0].length; j++)\\n\\t\\t\\tif(matrix[i][0] == 0 || matrix[0][j] == 0)  // If the first cell of row or col is zero \\n\\t\\t\\t\\tmatrix[i][j] = 0;                       // Mark the current cell as 0\\n\\n\\tif(isFirstRowZero)                                  // if entire firstRow is to be zero\\n\\t\\tfor(int i=0; i<matrix[0].length; i++)\\n\\t\\t\\tmatrix[0][i] = 0;                           // make them all zero\\n\\n\\tif(isFirstColZero)                                  // if entire firstCol is to be zero\\n\\t\\tfor(int i=0; i<matrix.length; i++)\\n\\t\\t\\tmatrix[i][0] = 0;                           // make them all zero\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390800,
                "title": "javascript-solution-memory-usage-beats-90",
                "content": "```\\nvar setZeroes = function(matrix) {\\n  let xs = new Set();\\n  let ys = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j]) {\\n        continue;\\n      } else {\\n        xs.add(i);\\n        ys.add(j);\\n      }\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (xs.has(i) || ys.has(j)) {\\n        matrix[i][j] = 0;\\n      } else {\\n        continue;\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n  let xs = new Set();\\n  let ys = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j]) {\\n        continue;\\n      } else {\\n        xs.add(i);\\n        ys.add(j);\\n      }\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (xs.has(i) || ys.has(j)) {\\n        matrix[i][j] = 0;\\n      } else {\\n        continue;\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213817,
                "title": "my-4-line-code-for-python",
                "content": "```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        points = [[i,j] for i in range(len(matrix)) for j in range(len(matrix[i])) if matrix[i][j] == 0]\\n        for i, a in enumerate(points):\\n            matrix[a[0]] = [0 for k in range(len(matrix[0]))]\\n            for k in range(len(matrix)): matrix[k][a[1]] = 0        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        points = [[i,j] for i in range(len(matrix)) for j in range(len(matrix[i])) if matrix[i][j] == 0]\\n        for i, a in enumerate(points):\\n            matrix[a[0]] = [0 for k in range(len(matrix[0]))]\\n            for k in range(len(matrix)): matrix[k][a[1]] = 0        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554878,
                "title": "best-o-1-space-solution",
                "content": "# Approach \\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void makeRowZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int j = 0; j < col; j++)\\n            matrix[row][j] = 0;    \\n    }  \\n    void makeColZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int i = 0; i < row; i++)\\n            matrix[i][col] = 0;    \\n    }    \\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        int col0 = 1;\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    if (j != 0)\\n                        matrix[0][j] = 0;\\n                    else\\n                        col0 = 0;      \\n                }\\n            }\\n        }\\n        for (int j = 1; j < c; j++) {\\n            if (matrix[0][j] == 0) \\n                makeColZero(matrix, r, j);\\n        }\\n        for (int i = 0; i < r; i++) {\\n            if (matrix[i][0] == 0) \\n                makeRowZero(matrix, i, c);\\n        }\\n        if (col0 == 0)\\n            makeColZero(matrix, r, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void makeRowZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int j = 0; j < col; j++)\\n            matrix[row][j] = 0;    \\n    }  \\n    void makeColZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int i = 0; i < row; i++)\\n            matrix[i][col] = 0;    \\n    }    \\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        int col0 = 1;\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    if (j != 0)\\n                        matrix[0][j] = 0;\\n                    else\\n                        col0 = 0;      \\n                }\\n            }\\n        }\\n        for (int j = 1; j < c; j++) {\\n            if (matrix[0][j] == 0) \\n                makeColZero(matrix, r, j);\\n        }\\n        for (int i = 0; i < r; i++) {\\n            if (matrix[i][0] == 0) \\n                makeRowZero(matrix, i, c);\\n        }\\n        if (col0 == 0)\\n            makeColZero(matrix, r, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365254,
                "title": "using-same-matrix-o-m-n-easy-to-understand-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'ll use 0th column and 0th row to set all other rows and column to zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.First we\\'ll traverse thorugh first row and first column of the matrix(0th row and 0th column).\\nWhenever we find 0 in this row we\\'ll set isrow0 to true.\\nSimilarly, whenever we find 0 in this column we\\'ll set iscol0 to true.\\nThis will be used later.\\n2.Now we\\'ll go through the entire matrix(Except the 0th row and 0th column).\\nWhenever 0 is encountered we\\'ll set that row\\'s first column\\'s element to 0.\\nSimilarly, we\\'ll set that column\\'s first row\\'s element to 0.\\n3.After that, we go through the matrix one more time and for any row or column where the first element is zero, we set all of the other elements in that row or column to zero as well.\\n4.lastly, we\\'ll set the entire 0th row and 0th column to zero if isrow0 and iscol0 is true respectively.\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length,n=matrix[0].length;\\n        boolean isrow0=false,iscol0=false;\\n        int i,j;\\n        for(i=0;i<m;i++)\\n        {\\n          if(matrix[i][0]==0)\\n          {\\n            isrow0=true;\\n          }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n          if(matrix[0][i]==0)\\n          {\\n            iscol0=true;\\n          }\\n        }\\n        for(i=1;i<m;i++)\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][j]==0)\\n            {\\n              matrix[0][j]=0;//0th row of column j\\n              matrix[i][0]=0;//0th column of row i\\n            }\\n          }\\n        }\\n        for(i=1;i<m;i++)//traversing again\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][0]==0 || matrix[0][j]==0)\\n            {\\n              matrix[i][j]=0;\\n            }\\n          }\\n        }\\n        if(isrow0)\\n        {\\n          for(i=0;i<m;i++)\\n          {\\n            matrix[i][0]=0;\\n          }\\n        }\\n        if(iscol0)\\n        {\\n          for(j=0;j<n;j++)\\n          {\\n            matrix[0][j]=0;\\n          }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length,n=matrix[0].length;\\n        boolean isrow0=false,iscol0=false;\\n        int i,j;\\n        for(i=0;i<m;i++)\\n        {\\n          if(matrix[i][0]==0)\\n          {\\n            isrow0=true;\\n          }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n          if(matrix[0][i]==0)\\n          {\\n            iscol0=true;\\n          }\\n        }\\n        for(i=1;i<m;i++)\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][j]==0)\\n            {\\n              matrix[0][j]=0;//0th row of column j\\n              matrix[i][0]=0;//0th column of row i\\n            }\\n          }\\n        }\\n        for(i=1;i<m;i++)//traversing again\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][0]==0 || matrix[0][j]==0)\\n            {\\n              matrix[i][j]=0;\\n            }\\n          }\\n        }\\n        if(isrow0)\\n        {\\n          for(i=0;i<m;i++)\\n          {\\n            matrix[i][0]=0;\\n          }\\n        }\\n        if(iscol0)\\n        {\\n          for(j=0;j<n;j++)\\n          {\\n            matrix[0][j]=0;\\n          }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289339,
                "title": "short-easy-very-clearly-explained-step-by-step-python",
                "content": "# SOLUTION\\n\\n```\\nclass Solution:\\n  def setZeroes(self, matrix):\\n    zero_rows, zero_cols = set(), set()\\n    for i in range(len(matrix)):\\n        for j in range(len(matrix[0])):\\n            if matrix[i][j] == 0:\\n                zero_rows.add(i)\\n                zero_cols.add(j)\\n    for i in zero_rows:\\n        matrix[i] = [0] * len(matrix[0])\\n    for j in zero_cols:\\n        for i in range(len(matrix)):\\n            matrix[i][j] = 0\\n\\n\\n```\\n# STEP-BY-STEP EXPLANATION\\n    zero_rows, zero_cols = set(), set()\\nTwo empty sets, zero_rows and zero_cols, are created to store the indices of the rows and columns with a zero value.\\n\\n    for i in range(len(matrix)):\\n        for j in range(len(matrix[0])):\\n            if matrix[i][j] == 0:\\n                zero_rows.add(i)\\n                zero_cols.add(j)\\n\\nLoops through the entire matrix and checks each element to see if it is zero. If it is, the index of the row and column are added to their respective sets, zero_rows and zero_cols.\\n\\n    for i in zero_rows:\\n        matrix[i] = [0] * len(matrix[0])\\n\\nNext loop goes through each index in zero_rows and sets the entire row to zero by creating a new list of zeros with the same length as the row and assigning it to the row.\\n\\n    for j in zero_cols:\\n        for i in range(len(matrix)):\\n            matrix[i][j] = 0\\n\\nLast loop goes through each index in zero_cols and sets the entire column to zero by looping through each row and setting the value at that column index to zero.\\n\\nThat\\'s it!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def setZeroes(self, matrix):\\n    zero_rows, zero_cols = set(), set()\\n    for i in range(len(matrix)):\\n        for j in range(len(matrix[0])):\\n            if matrix[i][j] == 0:\\n                zero_rows.add(i)\\n                zero_cols.add(j)\\n    for i in zero_rows:\\n        matrix[i] = [0] * len(matrix[0])\\n    for j in zero_cols:\\n        for i in range(len(matrix)):\\n            matrix[i][j] = 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970925,
                "title": "c-easy-to-understand-using-two-vectors",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n        \\n        int r = arr.size();\\n        int c = arr[0].size();\\n\\n        vector<int> xr,yc;\\n\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j =0;j<c;j++)\\n            {\\n                if(arr[i][j] == 0)\\n                {\\n                    xr.push_back(i);\\n                    yc.push_back(j);\\n                }\\n            }\\n        }\\n\\n        for(auto row : xr)\\n        {\\n            for(int col = 0;col<c;col++)\\n            arr[row][col] = 0;\\n        }\\n\\n        for(auto col : yc)\\n        {\\n            for(int row = 0;row<r;row++)\\n            arr[row][col] = 0;\\n        }\\n        \\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n        \\n        int r = arr.size();\\n        int c = arr[0].size();\\n\\n        vector<int> xr,yc;\\n\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j =0;j<c;j++)\\n            {\\n                if(arr[i][j] == 0)\\n                {\\n                    xr.push_back(i);\\n                    yc.push_back(j);\\n                }\\n            }\\n        }\\n\\n        for(auto row : xr)\\n        {\\n            for(int col = 0;col<c;col++)\\n            arr[row][col] = 0;\\n        }\\n\\n        for(auto col : yc)\\n        {\\n            for(int row = 0;row<r;row++)\\n            arr[row][col] = 0;\\n        }\\n        \\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933016,
                "title": "java-brute-better-optimised-3-approaches-added-explanation-for-3rd",
                "content": "### **1. Naive Approach**\\n\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        boolean[][] arr = new boolean[m][n];\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0)\\n                    arr[row][col] = true;\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(arr[row][col] == true){\\n                    helperRow(matrix, row, n);\\n                    helperCol(matrix, col, m);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void helperRow(int[][] matrix, int row, int n){\\n        for(int col = 0; col < n; ++col)\\n            matrix[row][col] = 0;\\n    }\\n    \\n    public void helperCol(int[][] matrix, int col, int m){\\n        for(int row = 0; row < m; ++row)\\n            matrix[row][col] = 0;\\n    }\\n}\\n```\\n\\n**TC = O(N^3) in worst case if matrix is of order N x N.**\\n**SC = O(N^2) in worst case if matrix is of order N x N.**\\n**Runtime 3ms, faster than 25%.**\\n\\n### **2. Better Approach**\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0){\\n                    rows.add(row);\\n                    cols.add(col);\\n                }\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(rows.contains(row) || cols.contains(col))\\n                    matrix[row][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```\\n**TC = O(M x N), since all set operations used above take O(1) time.**\\n**SC = O(M + N).**\\n**Runtime 4ms, faster than 18%.**\\n\\n### **3. Optimised approach**\\n\\nHere we will consider the dummy row array and dummy column array (as used in approach 2) as row 0 and column 0 of the matrix, for checking whether the particular column or row has the value 0 or not.\\nSince matrix[0][0] are overlapping, therefore take separate variable col0(say) to check if the 0th column has 0 or not and use matrix[0][0] to check if the 0th row has 0 or not.\\nNow traverse from last element to the first element and check if matrix[i][0]==0 || matrix[0][j]==0 and if true set matrix[i][j]=0, else continue.\\n\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n        \\n        for(int row = 0; row < m; ++row){\\n            if(matrix[row][0] == 0)\\n                col0 = 0;\\n            \\n            for(int col = 1; col < n; ++col)\\n                if(matrix[row][col] == 0)\\n                    matrix[row][0] = matrix[0][col] = 0;\\n        }\\n        \\n        for(int row = m - 1; row >= 0; --row){\\n            for(int col = n - 1; col >= 1; --col)\\n                if(matrix[row][0] == 0 || matrix[0][col] == 0)\\n                    matrix[row][col] = 0;\\n            \\n            if(col0 == 0)\\n                matrix[row][0] = 0;\\n        }\\n    }\\n}\\n```\\n\\n**TC = O(M x N).**\\n**SC = O(1).**\\n**Runtime 1ms, faster than 89%.**\\n\\n**Plz upvote if you find it helpful.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        boolean[][] arr = new boolean[m][n];\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0)\\n                    arr[row][col] = true;\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(arr[row][col] == true){\\n                    helperRow(matrix, row, n);\\n                    helperCol(matrix, col, m);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void helperRow(int[][] matrix, int row, int n){\\n        for(int col = 0; col < n; ++col)\\n            matrix[row][col] = 0;\\n    }\\n    \\n    public void helperCol(int[][] matrix, int col, int m){\\n        for(int row = 0; row < m; ++row)\\n            matrix[row][col] = 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0){\\n                    rows.add(row);\\n                    cols.add(col);\\n                }\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(rows.contains(row) || cols.contains(col))\\n                    matrix[row][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n        \\n        for(int row = 0; row < m; ++row){\\n            if(matrix[row][0] == 0)\\n                col0 = 0;\\n            \\n            for(int col = 1; col < n; ++col)\\n                if(matrix[row][col] == 0)\\n                    matrix[row][0] = matrix[0][col] = 0;\\n        }\\n        \\n        for(int row = m - 1; row >= 0; --row){\\n            for(int col = n - 1; col >= 1; --col)\\n                if(matrix[row][0] == 0 || matrix[0][col] == 0)\\n                    matrix[row][col] = 0;\\n            \\n            if(col0 == 0)\\n                matrix[row][0] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790756,
                "title": "c-solution-using-set-easy-fast-simple-91-38-12ms-13-4-mb",
                "content": "![image](https://assets.leetcode.com/users/images/ce857028-f902-4df8-b7c2-f9a4c5b72bde_1645509329.445337.png)\\n\\nSteps involved\\n1. Iterate once to store all rows and columns containing a `0` in two separate sets.\\n2. Iterate through set `rows` to make all elements with given row, making all elements 0\\n3. Iterare through set `cols` to make all element with given column, making all elements 0\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows;\\n        set<int> cols;\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size();j++)\\n                if(matrix[i][j] == 0) {\\n                    rows.insert(i);\\n                    cols.insert(j);\\n                }\\n\\n        for(auto x: rows) \\n            for(int j = 0; j < matrix[0].size();j++) \\n                    matrix[x][j] = 0;\\n\\n        for(auto x: cols) \\n            for(int i = 0; i < matrix.size(); i++) \\n                matrix[i][x] = 0;\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows;\\n        set<int> cols;\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size();j++)\\n                if(matrix[i][j] == 0) {\\n                    rows.insert(i);\\n                    cols.insert(j);\\n                }\\n\\n        for(auto x: rows) \\n            for(int j = 0; j < matrix[0].size();j++) \\n                    matrix[x][j] = 0;\\n\\n        for(auto x: cols) \\n            for(int i = 0; i < matrix.size(); i++) \\n                matrix[i][x] = 0;\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205739,
                "title": "java-array-1ms-beats-93-t-c-o-m-n-s-c-o-1",
                "content": "\\n    // O(m*n) O(1)\\n\\tpublic void setZeroes(int[][] matrix) {\\n\\n\\t\\tint m = matrix.length, n = matrix[0].length;\\n\\t\\tboolean row = false, col = false;\\n\\n        for (int i = 0; i < m; i++) {\\n\\t\\t\\tif (matrix[i][0] == 0) {\\n\\t\\t\\t\\tcol = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (matrix[0][i] == 0) {\\n\\t\\t\\t\\trow = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t\\t\\t\\tmatrix[0][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < m; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][0] == 0 || matrix[0][j] == 0)\\n\\t\\t\\t\\t\\tmatrix[i][j] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (row == true) {\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n\\n\\t\\tif (col == true) {\\n\\t\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(m*n) O(1)\\n\\tpublic void setZeroes(int[][] matrix) {\\n\\n\\t\\tint m = matrix.length, n = matrix[0].length;\\n\\t\\tboolean row = false, col = false;\\n\\n        for (int i = 0; i < m; i++) {\\n\\t\\t\\tif (matrix[i][0] == 0) {\\n\\t\\t\\t\\tcol = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (matrix[0][i] == 0) {\\n\\t\\t\\t\\trow = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t\\t\\t\\tmatrix[0][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < m; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][0] == 0 || matrix[0][j] == 0)\\n\\t\\t\\t\\t\\tmatrix[i][j] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (row == true) {\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n\\n\\t\\tif (col == true) {\\n\\t\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t}\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 917943,
                "title": "my-very-simple-python-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        def changeRC(r,c):\\n            \\n            for col in range(len(matrix[0])):\\n                matrix[r][col]=\\'X\\' if matrix[r][col]!=0 else 0\\n            for row in range(len(matrix)):\\n                matrix[row][c]=\\'X\\' if matrix[row][c]!=0 else 0\\n\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==0:\\n                    changeRC(r,c)\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==\\'X\\':\\n                    matrix[r][c]=0\\n                    \\n        #return matrix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        def changeRC(r,c):\\n            \\n            for col in range(len(matrix[0])):\\n                matrix[r][col]=\\'X\\' if matrix[r][col]!=0 else 0\\n            for row in range(len(matrix)):\\n                matrix[row][c]=\\'X\\' if matrix[row][c]!=0 else 0\\n\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==0:\\n                    changeRC(r,c)\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==\\'X\\':\\n                    matrix[r][c]=0\\n                    \\n        #return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691293,
                "title": "javascript-human-readable-solution",
                "content": "```javascript\\nvar setZeroes = function(matrix) {\\n    const zeroRow = new Set();\\n    const zeroCol = new Set();\\n    \\n    for(let i = 0; i < matrix.length; i++) {\\n        \\n        for(let j = 0; j < matrix[0].length; j++) {\\n            \\n            if(matrix[i][j] === 0) {\\n                zeroRow.add(i);\\n                zeroCol.add(j);\\n            }\\n        }\\n    }\\n    \\n    for(let r of zeroRow) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            matrix[r][j] = 0;\\n        }\\n    }\\n    \\n    for(let c of zeroCol) {\\n        for(let i = 0; i < matrix.length; i++) {\\n            matrix[i][c] = 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar setZeroes = function(matrix) {\\n    const zeroRow = new Set();\\n    const zeroCol = new Set();\\n    \\n    for(let i = 0; i < matrix.length; i++) {\\n        \\n        for(let j = 0; j < matrix[0].length; j++) {\\n            \\n            if(matrix[i][j] === 0) {\\n                zeroRow.add(i);\\n                zeroCol.add(j);\\n            }\\n        }\\n    }\\n    \\n    for(let r of zeroRow) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            matrix[r][j] = 0;\\n        }\\n    }\\n    \\n    for(let c of zeroCol) {\\n        for(let i = 0; i < matrix.length; i++) {\\n            matrix[i][c] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26056,
                "title": "java-2-solutions-space-o-1-and-o-m-n-with-explaination",
                "content": "space O(1), time O(mn)\\nUse the top row and the left column to record which rows and columns need to be set 0. topZero and leftZero to record whether we need to set  the top row and the left column to zero before finished.\\n```\\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        boolean topZero=false, leftZero=false;\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    if(i==0) topZero = true;\\n                    if(j==0) leftZero = true;\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<M; i++){\\n            if(matrix[i][0]==0){\\n                for(int q=1; q<N; q++) matrix[i][q] = 0;\\n            }\\n        }\\n        for(int j=1; j<N; j++){\\n            if(matrix[0][j]==0){\\n                for(int p=1; p<M; p++)  matrix[p][j] = 0;\\n            }\\n        }\\n        if(topZero){\\n            for(int q=0; q<N; q++) matrix[0][q] = 0;\\n        }\\n        if(leftZero){\\n            for(int p=0; p<M; p++) matrix[p][0] = 0;\\n        }\\n    }\\n```\\nspace O(m+n), time O(mn)\\n```    \\n    public void setZeroes_Set(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        Set<Integer> rowSet = new HashSet<>();\\n        Set<Integer> colSet = new HashSet<>();\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    rowSet.add(i);\\n                    colSet.add(j);\\n                }\\n            }\\n        }\\n        for(int row : rowSet)\\n            for(int j=0; j<N; j++)\\n                matrix[row][j] = 0;\\n        for(int col : colSet)\\n            for(int i=0; i<M; i++)\\n                matrix[i][col] = 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        boolean topZero=false, leftZero=false;\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    if(i==0) topZero = true;\\n                    if(j==0) leftZero = true;\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<M; i++){\\n            if(matrix[i][0]==0){\\n                for(int q=1; q<N; q++) matrix[i][q] = 0;\\n            }\\n        }\\n        for(int j=1; j<N; j++){\\n            if(matrix[0][j]==0){\\n                for(int p=1; p<M; p++)  matrix[p][j] = 0;\\n            }\\n        }\\n        if(topZero){\\n            for(int q=0; q<N; q++) matrix[0][q] = 0;\\n        }\\n        if(leftZero){\\n            for(int p=0; p<M; p++) matrix[p][0] = 0;\\n        }\\n    }\\n```\n```    \\n    public void setZeroes_Set(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        Set<Integer> rowSet = new HashSet<>();\\n        Set<Integer> colSet = new HashSet<>();\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    rowSet.add(i);\\n                    colSet.add(j);\\n                }\\n            }\\n        }\\n        for(int row : rowSet)\\n            for(int j=0; j<N; j++)\\n                matrix[row][j] = 0;\\n        for(int col : colSet)\\n            for(int i=0; i<M; i++)\\n                matrix[i][col] = 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26070,
                "title": "simple-in-place-solution-yet-still-best-submission-in-c",
                "content": "    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) \\n        {\\n            if(matrix.empty()) return ;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            bool firstRow = false, firstCol = false;\\n            for(int c = 0; c < colSize; ++c) if(matrix[0][c] == 0) firstRow = true;\\n            for(int r = 0; r < rowSize; ++r) if(matrix[r][0] == 0) firstCol = true;\\n            for(int r = 1; r < rowSize; ++r)\\n                for(int c = 1; c < colSize; ++c)\\n                    if(matrix[r][c] == 0) matrix[0][c] = matrix[r][0] = 0;\\n            for(int c = 1; c < colSize; ++c) \\n                if(matrix[0][c] == 0)\\n                    for(int r = 1; r < rowSize; ++r)\\n                        matrix[r][c] = 0;\\n            for(int r = 1; r < rowSize; ++r) \\n                if(matrix[r][0] == 0)\\n                    for(int c = 1; c < colSize; ++c)\\n                        matrix[r][c] = 0;\\n            if(firstRow) for(int c = 0; c < colSize; ++c) matrix[0][c] = 0;\\n            if(firstCol) for(int r = 0; r < rowSize; ++r) matrix[r][0] = 0;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) \\n        {\\n            if(matrix.empty()) return ;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            bool firstRow = false, firstCol = false;\\n            for(int c = 0; c < colSize; ++c) if(matrix[0][c] == 0) firstRow = true;\\n            for(int r = 0; r < rowSize; ++r) if(matrix[r][0] == 0) firstCol = true;\\n            for(int r = 1; r < rowSize; ++r)\\n                for(int c = 1; c < colSize; ++c)\\n                    if(matrix[r][c] == 0) matrix[0][c] = matrix[r][0] = 0;\\n            for(int c = 1; c < colSize; ++c) \\n                if(matrix[0][c] == 0)\\n                    for(int r = 1; r < rowSize; ++r)\\n                        matrix[r][c] = 0;\\n            for(int r = 1; r < rowSize; ++r) \\n                if(matrix[r][0] == 0)\\n                    for(int c = 1; c < colSize; ++c)\\n                        matrix[r][c] = 0;\\n            if(firstRow) for(int c = 0; c < colSize; ++c) matrix[0][c] = 0;\\n            if(firstCol) for(int r = 0; r < rowSize; ++r) matrix[r][0] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 26111,
                "title": "python-easy-inplace-solution",
                "content": "Make first row and first column to mark which row and column should be zero before filling them out, then fill the matrix from right to left, and make the first row zero in the last if first row has any zero.\\n\\n    def setZeroes(self, matrix):\\n        firstRowHasZero = not all(matrix[0])\\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0\\n                    matrix[i][0] = 0\\n        \\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])-1,-1,-1):\\n                if matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n        \\n        if firstRowHasZero:\\n            matrix[0] = [0]*len(matrix[0])",
                "solutionTags": [
                    "Python"
                ],
                "code": "Make first row and first column to mark which row and column should be zero before filling them out, then fill the matrix from right to left, and make the first row zero in the last if first row has any zero.\\n\\n    def setZeroes(self, matrix):\\n        firstRowHasZero = not all(matrix[0])\\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0\\n                    matrix[i][0] = 0\\n        \\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])-1,-1,-1):\\n                if matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n        \\n        if firstRowHasZero:\\n            matrix[0] = [0]*len(matrix[0])",
                "codeTag": "Python3"
            },
            {
                "id": 3881749,
                "title": "easy-to-understand-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<pair<int,int>> temp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    temp.push_back(make_pair(i,j));\\n                }\\n            }\\n        }\\n        for(int i=0; i<temp.size();i++){\\n            int row=temp[i].first;\\n            int col=temp[i].second;\\n            for(int j=0;j<matrix.size();j++){\\n                for(int k=0;k<matrix[j].size();k++){\\n                    if(j==row)\\n                    matrix[j][k]=0;\\n                    if(k==col)\\n                    matrix[j][k]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<pair<int,int>> temp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    temp.push_back(make_pair(i,j));\\n                }\\n            }\\n        }\\n        for(int i=0; i<temp.size();i++){\\n            int row=temp[i].first;\\n            int col=temp[i].second;\\n            for(int j=0;j<matrix.size();j++){\\n                for(int k=0;k<matrix[j].size();k++){\\n                    if(j==row)\\n                    matrix[j][k]=0;\\n                    if(k==col)\\n                    matrix[j][k]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742996,
                "title": "simple-solution-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // we will keep the rows and col of 0 value \\n        set<int>r;\\n        set<int>c;\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n\\n        //now comes the part of making rows and col = 0\\n        //for rows\\n        for(auto i:r){\\n            for(int j=0;j<cols;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n\\n        // for cols\\n        for(auto j:c){\\n            for(int i=0;i<rows;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```\\n![leetcode.jpeg](https://assets.leetcode.com/users/images/b3c5af72-8a7d-4763-a72c-8a2242a871cd_1688997851.1284735.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // we will keep the rows and col of 0 value \\n        set<int>r;\\n        set<int>c;\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n\\n        //now comes the part of making rows and col = 0\\n        //for rows\\n        for(auto i:r){\\n            for(int j=0;j<cols;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n\\n        // for cols\\n        for(auto j:c){\\n            for(int i=0;i<rows;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713783,
                "title": "python-easy-solution-with-clear-explanation-with-example",
                "content": "# Intuition\\nHere, our intuition is to make every row and column zero if there is a zero present in that row. To accomplish this, we need to follow these steps:\\n\\n# Approach\\n\\nStep 1: Append the indices to a list where there is a zero.\\nFor example, given the list [[0,1,2,0],[3,4,5,2],[1,3,1,5]], the list of indices would be [0, 3].\\n\\nThis list is created because:\\ni) If there is a zero in a nested list, we make the entire list zero.\\nii) If a zero is not present in a row, but it is present in another row in the same column, we make that column zero for every nested list.\\n\\nTo perform this, we use two separate for loops:\\n- The first loop is used to get the indices of the zeros in the nested list and store them in `zero_cols`.\\n- The second loop is used to update the values to zero based on the conditions mentioned above.\\n\\n![WhatsApp Image 2023-07-05 at 9.36.31 AM.jpeg](https://assets.leetcode.com/users/images/7a38df5b-365f-4c72-b52f-ff7a570791c5_1688530121.9454794.jpeg)\\n\\n# **Kindly do a upvote if you find it usefull and a comment if found any mistake\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83E\\uDEC2**\\n\\n# Code\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        l_c = []\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if matrix[i][j] == 0:\\n                    l_c.append(j)\\n\\n        for i in range(len(matrix)):\\n            if 0 in matrix[i]:\\n                for ii in range(len(matrix[i])):\\n                    matrix[i][ii] = 0\\n            else:\\n                for _ in l_c:\\n                    matrix[i][_] = 0\\n        return matrix\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        l_c = []\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if matrix[i][j] == 0:\\n                    l_c.append(j)\\n\\n        for i in range(len(matrix)):\\n            if 0 in matrix[i]:\\n                for ii in range(len(matrix[i])):\\n                    matrix[i][ii] = 0\\n            else:\\n                for _ in l_c:\\n                    matrix[i][_] = 0\\n        return matrix\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663211,
                "title": "c-beats-91-30-runtime-beats-99-23-memory-2-methods-brute-force-optimal-solution",
                "content": "# Code\\n```\\n// OPTIMAL SOLUTION\\n/*\\nTC : O(n*m)\\nSC : O(1)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool firstRowZero = false;\\n        bool firstColZero = false;\\n        \\n        // Check if the first row and first column need to be set to zero\\n        for (int j = 0; j < m; j++) { // TC: O(m)\\n            if (matrix[0][j] == 0) {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) { // TC: O(n)\\n            if (matrix[i][0] == 0) {\\n                firstColZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // Mark the corresponding entry in the first row and first column as zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the elements in rows and columns (excluding the first row and first column) to zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the first row to zero if necessary\\n        if (firstRowZero) { // TC: O(m)\\n            for (int j = 0; j < m; j++) {\\n                matrix[0][j] = 0;\\n            }\\n        }\\n        \\n        // Set the first column to zero if necessary\\n        if (firstColZero) { // TC: O(n)\\n            for (int i = 0; i < n; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n\\n\\n# Code\\n```\\n// BRUTE FORCE\\n/*\\nTC : O(n*m)\\nSC : O(n + m)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        vector<int> row(n, 0); // SC: O(n)\\n        vector<int> col(m, 0); // SC: O(m)\\n\\n        // mark the row and col corresponding to element 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(matrix[i][j] == 0) {\\n                    row[i] = 1;\\n                    col[j] = 1;\\n                }\\n            }\\n        }\\n\\n        // set all row and col as 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(row[i] || col[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// OPTIMAL SOLUTION\\n/*\\nTC : O(n*m)\\nSC : O(1)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool firstRowZero = false;\\n        bool firstColZero = false;\\n        \\n        // Check if the first row and first column need to be set to zero\\n        for (int j = 0; j < m; j++) { // TC: O(m)\\n            if (matrix[0][j] == 0) {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) { // TC: O(n)\\n            if (matrix[i][0] == 0) {\\n                firstColZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // Mark the corresponding entry in the first row and first column as zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the elements in rows and columns (excluding the first row and first column) to zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the first row to zero if necessary\\n        if (firstRowZero) { // TC: O(m)\\n            for (int j = 0; j < m; j++) {\\n                matrix[0][j] = 0;\\n            }\\n        }\\n        \\n        // Set the first column to zero if necessary\\n        if (firstColZero) { // TC: O(n)\\n            for (int i = 0; i < n; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\n```\\n// BRUTE FORCE\\n/*\\nTC : O(n*m)\\nSC : O(n + m)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        vector<int> row(n, 0); // SC: O(n)\\n        vector<int> col(m, 0); // SC: O(m)\\n\\n        // mark the row and col corresponding to element 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(matrix[i][j] == 0) {\\n                    row[i] = 1;\\n                    col[j] = 1;\\n                }\\n            }\\n        }\\n\\n        // set all row and col as 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(row[i] || col[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610821,
                "title": "java-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Step 1\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 3 | 4 | 5 | 2 |\\n| 1 | 3 | 1 | 5 |\\n\\nrow = false\\ncol = true\\n\\n## Step 2\\n\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 3 | 4 | 5 | 2 |\\n| 1 | 3 | 1 | 5 |\\n\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 3 | 4 | 5 | 2 |\\n| 1 | 3 | 1 | 5 |\\n\\nrow = true\\ncol = true\\n\\n## Step 3 and so on\\n\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 0 | 4 | 5 | 2 |\\n| 0 | 3 | 1 | 5 |\\n\\n| 0 | 0 | 0 | 0 |\\n|---|---|---|---|\\n| 0 | 4 | 5 | 2 |\\n| 0 | 3 | 1 | 5 |\\n\\n| 0 | 0 | 0 | 0 |\\n|---|---|---|---|\\n| 0 | 4 | 5 | 2 |\\n| 0 | 3 | 1 | 5 |\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        boolean row = false;\\n        boolean col = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                col = true;\\n                break;\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                row = true;\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[0][j] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[i][0] = 0;\\n                    matrix[i][0] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j = 1; j < m; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                for (int i = 1; i < n; i++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        if (col) {\\n            cleanZeroCol(matrix, n);\\n        }\\n\\n        if (row) {\\n            cleanZeroRow(matrix, m);\\n        }\\n    }\\n\\n    private void cleanZeroCol(int[][] matrix, int n) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n    private void cleanZeroRow(int[][] matrix, int m) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        boolean row = false;\\n        boolean col = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                col = true;\\n                break;\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                row = true;\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[0][j] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[i][0] = 0;\\n                    matrix[i][0] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j = 1; j < m; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                for (int i = 1; i < n; i++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        if (col) {\\n            cleanZeroCol(matrix, n);\\n        }\\n\\n        if (row) {\\n            cleanZeroRow(matrix, m);\\n        }\\n    }\\n\\n    private void cleanZeroCol(int[][] matrix, int n) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n    private void cleanZeroRow(int[][] matrix, int m) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554849,
                "title": "most-optimal-solution-using-in-place-or-constant-space-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  void setZeroes(vector<vector<int>> &matrix)\\n  {\\n    int n = matrix.size();\\n    int m = matrix[0].size();\\n    int col0 = 1;\\n    for (int i = 0; i < n; i++)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        if (matrix[i][j] == 0)\\n        {\\n\\n          matrix[i][0] = 0;\\n\\n          if (j != 0)\\n            matrix[0][j] = 0;\\n          else\\n            col0 = 0;\\n        }\\n      }\\n    }\\n\\n    for (int i = 1; i < n; i++)\\n    {\\n      for (int j = 1; j < m; j++)\\n      {\\n        if (matrix[i][j] != 0)\\n        {\\n\\n          if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n          {\\n            matrix[i][j] = 0;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (matrix[0][0] == 0)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        matrix[0][j] = 0;\\n      }\\n    }\\n    if (col0 == 0)\\n    {\\n      for (int i = 0; i < n; i++)\\n      {\\n        matrix[i][0] = 0;\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  void setZeroes(vector<vector<int>> &matrix)\\n  {\\n    int n = matrix.size();\\n    int m = matrix[0].size();\\n    int col0 = 1;\\n    for (int i = 0; i < n; i++)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        if (matrix[i][j] == 0)\\n        {\\n\\n          matrix[i][0] = 0;\\n\\n          if (j != 0)\\n            matrix[0][j] = 0;\\n          else\\n            col0 = 0;\\n        }\\n      }\\n    }\\n\\n    for (int i = 1; i < n; i++)\\n    {\\n      for (int j = 1; j < m; j++)\\n      {\\n        if (matrix[i][j] != 0)\\n        {\\n\\n          if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n          {\\n            matrix[i][j] = 0;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (matrix[0][0] == 0)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        matrix[0][j] = 0;\\n      }\\n    }\\n    if (col0 == 0)\\n    {\\n      for (int i = 0; i < n; i++)\\n      {\\n        matrix[i][0] = 0;\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306062,
                "title": "optimize-solution-in-constant-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean isRow0Zero = false, isCol0Zero =false;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        // check if first column need to set zero\\n        for(int i =0; i< m; i++) {\\n            if(matrix[i][0] == 0) {\\n                isCol0Zero = true;\\n                break;\\n            }\\n        }\\n\\n      // check if first row need to set zero\\n        for(int i =0; i< n; i++) {\\n            if(matrix[0][i] == 0) {\\n                isRow0Zero = true;\\n                break;\\n            }\\n        }\\n\\n\\n       for(int i=1; i<m; i++) {\\n           for(int j=1;j<n;j++) {\\n               if(matrix[i][j] == 0) {\\n                   matrix[i][0] = 0;\\n                   matrix[0][j] = 0;\\n               }\\n           }\\n       }\\n\\n\\n        for(int i=1; i<m; i++) {\\n            for(int j=1;j<n;j++) {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                  matrix[i][j] = 0;\\n                }\\n           }\\n        }\\n\\n        if(isRow0Zero) {\\n            for(int i=0;i <n; i++) \\n                 matrix[0][i] = 0;\\n        }\\n\\n        if(isCol0Zero) {\\n            for(int i=0;i <m; i++) \\n                 matrix[i][0] = 0;\\n        }\\n    \\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean isRow0Zero = false, isCol0Zero =false;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        // check if first column need to set zero\\n        for(int i =0; i< m; i++) {\\n            if(matrix[i][0] == 0) {\\n                isCol0Zero = true;\\n                break;\\n            }\\n        }\\n\\n      // check if first row need to set zero\\n        for(int i =0; i< n; i++) {\\n            if(matrix[0][i] == 0) {\\n                isRow0Zero = true;\\n                break;\\n            }\\n        }\\n\\n\\n       for(int i=1; i<m; i++) {\\n           for(int j=1;j<n;j++) {\\n               if(matrix[i][j] == 0) {\\n                   matrix[i][0] = 0;\\n                   matrix[0][j] = 0;\\n               }\\n           }\\n       }\\n\\n\\n        for(int i=1; i<m; i++) {\\n            for(int j=1;j<n;j++) {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                  matrix[i][j] = 0;\\n                }\\n           }\\n        }\\n\\n        if(isRow0Zero) {\\n            for(int i=0;i <n; i++) \\n                 matrix[0][i] = 0;\\n        }\\n\\n        if(isCol0Zero) {\\n            for(int i=0;i <m; i++) \\n                 matrix[i][0] = 0;\\n        }\\n    \\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217274,
                "title": "python-easy-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, mat: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n=len(mat),len(mat[0])\\n        r=c=0\\n#Storing the index of 0th element in first row and column\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]==0:\\n                    if i==0:\\n                        r=1\\n                    if j==0:\\n                        c=1   \\n                    mat[i][0]=mat[0][j]=0\\n        \\n#If first row or column is marked with 0 the then marking all the elements in that row or column as 0\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                if mat[i][0]==0 or mat[0][j]==0:\\n                    mat[i][j]=0\\n#If first row or column as 0 then making all elements in first row or column as 0\\n        if r==1:\\n            for j in range(n):\\n                mat[0][j]=0\\n        if c==1:\\n            for i in range(m):\\n                mat[i][0]=0\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, mat: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n=len(mat),len(mat[0])\\n        r=c=0\\n#Storing the index of 0th element in first row and column\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]==0:\\n                    if i==0:\\n                        r=1\\n                    if j==0:\\n                        c=1   \\n                    mat[i][0]=mat[0][j]=0\\n        \\n#If first row or column is marked with 0 the then marking all the elements in that row or column as 0\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                if mat[i][0]==0 or mat[0][j]==0:\\n                    mat[i][j]=0\\n#If first row or column as 0 then making all elements in first row or column as 0\\n        if r==1:\\n            for j in range(n):\\n                mat[0][j]=0\\n        if c==1:\\n            for i in range(m):\\n                mat[i][0]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182406,
                "title": "store-indices",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int> r,c;\\n        int i,j,m = matrix.size(),n = matrix[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(!matrix[i][j]){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n        for(auto &i: r){\\n            for(j = 0; j < n; j++){\\n                matrix[i][j] = 0;\\n            }\\n        }for(auto &i: c){\\n            for(j = 0; j < m; j++){\\n                matrix[j][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int> r,c;\\n        int i,j,m = matrix.size(),n = matrix[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(!matrix[i][j]){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n        for(auto &i: r){\\n            for(j = 0; j < n; j++){\\n                matrix[i][j] = 0;\\n            }\\n        }for(auto &i: c){\\n            for(j = 0; j < m; j++){\\n                matrix[j][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164326,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size();\\n        int c=1;\\n        for(int i=0;i<row;i++){\\n             if(mat[i][0]==0)\\n             c=0;\\n            for(int j=1;j<col;j++){\\n                if(mat[i][j]==0){\\n                    mat[0][j]=0;\\n                    mat[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1;j>0;j--)\\n            if(mat[i][0]==0||mat[0][j]==0)\\n            mat[i][j]=0;\\n            if(c==0)\\n            mat[i][0]=0;\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        zeroRowIndexes = set()\\n        zeroColIndexes = set()\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    zeroRowIndexes.add(i)\\n                    zeroColIndexes.add(j)\\n        for i in range(m):\\n            for j in range(n):\\n                if i in zeroRowIndexes or j in zeroColIndexes:\\n                    matrix[i][j] = 0\\n```\\n\\n```Java []\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n        \\n        for(int i = 0; i < rows; i++){\\n            if(matrix[i][0] == 0) col0 = 0;\\n            for(int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        \\n        for(int i = rows - 1; i >= 0; i--){\\n            for(int j = cols - 1; j >= 1; j --)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size();\\n        int c=1;\\n        for(int i=0;i<row;i++){\\n             if(mat[i][0]==0)\\n             c=0;\\n            for(int j=1;j<col;j++){\\n                if(mat[i][j]==0){\\n                    mat[0][j]=0;\\n                    mat[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1;j>0;j--)\\n            if(mat[i][0]==0||mat[0][j]==0)\\n            mat[i][j]=0;\\n            if(c==0)\\n            mat[i][0]=0;\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        zeroRowIndexes = set()\\n        zeroColIndexes = set()\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    zeroRowIndexes.add(i)\\n                    zeroColIndexes.add(j)\\n        for i in range(m):\\n            for j in range(n):\\n                if i in zeroRowIndexes or j in zeroColIndexes:\\n                    matrix[i][j] = 0\\n```\n```Java []\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n        \\n        for(int i = 0; i < rows; i++){\\n            if(matrix[i][0] == 0) col0 = 0;\\n            for(int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        \\n        for(int i = rows - 1; i >= 0; i--){\\n            for(int j = cols - 1; j >= 1; j --)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091387,
                "title": "1000-views-best-solution-concise-precise-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n       vector<pair<int,int>> mp;\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<cols;j++)\\n                if(matrix[i][j]==0) mp.push_back(make_pair(i,j));\\n\\n        for(auto i:mp){\\n            int j=0;\\n            while(j<cols){\\n                matrix[i.first][j]=0;\\n                j++;\\n            }\\n            j=0;\\n              while(j<rows){\\n                matrix[j][i.second]=0;\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n       vector<pair<int,int>> mp;\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<cols;j++)\\n                if(matrix[i][j]==0) mp.push_back(make_pair(i,j));\\n\\n        for(auto i:mp){\\n            int j=0;\\n            while(j<cols){\\n                matrix[i.first][j]=0;\\n                j++;\\n            }\\n            j=0;\\n              while(j<rows){\\n                matrix[j][i.second]=0;\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986079,
                "title": "simple-python-solution-easy",
                "content": "# Approach\\n* Create 2 sets to track which column and row needs to be updated\\n* Update original matrix using the sets\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m+n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        col = set()\\n        row = set()\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]==0:\\n                    col.add(j)\\n                    row.add(i)\\n        \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j]=0\\n        for i in range(len(matrix)):\\n            for j in col:\\n                matrix[i][j]=0\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        col = set()\\n        row = set()\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]==0:\\n                    col.add(j)\\n                    row.add(i)\\n        \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j]=0\\n        for i in range(len(matrix)):\\n            for j in col:\\n                matrix[i][j]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939166,
                "title": "beginner-s-solutions",
                "content": "# Intuition\\nSo, you might think that this question must have some optimized solution but believe me the brute force is the only approach which will give you minimum time complexity ..\\n\\n# Approach\\nWe will declare two vectors if you don\\'t know about vectors you can declare two arrays too. First of all we will traverse entire matrix (using two for loops) and then find which row and column has a 0. We will note that in our arrays/vectors which were keeping track of 0\\'s.\\nThen we will again use two for loops to assign the 0\\'s to respective index with help of our two arrays/vectors which were keeping track of 0\\'s. And yup this is it ..\\n\\n# Complexity\\n- Time complexity:\\nO(2 x n x m) \\nWhere n is number of rows and m is number of columns and we traversed the entire matrix twice hence 2 in multiplication.\\n\\n- Space complexity:\\nO(n+m)\\nWhere n is number of rows and m is number of columns as we declared two arrays/vectors of this size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> row(n,0);\\n        vector<int> col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]>0){\\n                    matrix[i][j]=0;\\n                }\\n                if(col[j]>0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> row(n,0);\\n        vector<int> col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]>0){\\n                    matrix[i][j]=0;\\n                }\\n                if(col[j]>0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804366,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row;\\n        vector<int> col;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row.push_back(i);\\n                    col.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<row.size();i++){\\n            for(int j=0;j<n;j++){\\n                matrix[row[i]][j]=0;\\n            }\\n        }\\n        for(int i=0;i<col.size();i++){\\n            for(int j=0;j<m;j++){\\n                matrix[j][col[i]]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row;\\n        vector<int> col;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row.push_back(i);\\n                    col.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<row.size();i++){\\n            for(int j=0;j<n;j++){\\n                matrix[row[i]][j]=0;\\n            }\\n        }\\n        for(int i=0;i<col.size();i++){\\n            for(int j=0;j<m;j++){\\n                matrix[j][col[i]]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596094,
                "title": "python-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        col = True\\n        \\n        for i in range(n):\\n            if matrix[i][0] == 0:\\n                col = False\\n            for j in range(1, m):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0  \\n\\t\\t\\t\\t\\t\\n        for i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        col = True\\n        \\n        for i in range(n):\\n            if matrix[i][0] == 0:\\n                col = False\\n            for j in range(1, m):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0  \\n\\t\\t\\t\\t\\t\\n        for i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320399,
                "title": "all-the-approach-for-this-question",
                "content": "![image](https://assets.leetcode.com/users/images/b97eba51-d299-4817-86b2-fef17ba46fe8_1658557435.2364733.png)\\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/b97eba51-d299-4817-86b2-fef17ba46fe8_1658557435.2364733.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2310610,
                "title": "c-brutforce-to-optimal",
                "content": "Approach: Using brute force\\n\\nAssuming all the elements in the matrix are non-negative. Traverse through the matrix and if you find an element with value 0, then change all the elements in its row and column to -1, except when an element is 0. The reason for not changing other elements to 0, but -1, is because that might affect other columns and rows. Now traverse through the matrix again and if an element is -1 change it to 0, which will be the answer.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\\n\\nBetter approach\\n\\nIntuition: Instead of traversing through each row and column, we can use dummy arrays to check if the particular row or column has an element 0 or not, which will improve the time complexity.\\n\\nApproach:Take two dummy array one of size of row and other of size of column.Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\n```\\n\\nOptimizing the better approach.\\n\\nIntuition: Instead of taking two dummy arrays we can use the first row and column of the matrix for the same work. This will help to reduce the space complexity of the problem. While traversing for the second time the first row and column will be computed first, which will affect the values of further elements that\\u2019s why we traversing in the reverse direction.\\n\\nApproach:Instead of taking two separate dummy array,take first row and column of the matrix as the array for checking whether the particular column or row has the value 0 or not.Since matrix[0][0] are overlapping.Therefore take separate variable col0(say) to check if the 0th column has 0 or not and use matrix[0][0] to check if the 0th row has 0 or not.Now traverse from last element to the first element and check if matrix[i][0]==0 || matrix[0][j]==0 and if true set matrix[i][j]=0,else continue.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    //checking if 0 is present in the 0th column or not\\n    if (matrix[i][0] == 0) col0 = 0;\\n    for (int j = 1; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n  //traversing in the reverse direction and\\n  //checking if the row or col has 0 or not\\n  //and setting values of matrix accordingly.\\n  for (int i = rows - 1; i >= 0; i--) {\\n    for (int j = cols - 1; j >= 1; j--) {\\n      if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n    if (col0 == 0) {\\n      matrix[i][0] = 0;\\n    }\\n\\n  }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\n```\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    //checking if 0 is present in the 0th column or not\\n    if (matrix[i][0] == 0) col0 = 0;\\n    for (int j = 1; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n  //traversing in the reverse direction and\\n  //checking if the row or col has 0 or not\\n  //and setting values of matrix accordingly.\\n  for (int i = rows - 1; i >= 0; i--) {\\n    for (int j = cols - 1; j >= 1; j--) {\\n      if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n    if (col0 == 0) {\\n      matrix[i][0] = 0;\\n    }\\n\\n  }\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281086,
                "title": "c-solution-2-approaches-with-explanation",
                "content": "**Approach 1 (using extra space)**\\n\\nThis Approach will use two boolean 1 dimensional matrices, named rowZero and colZero.\\n- rowZero[i] and colZero[j] will indicate if matrix[i][j] == 0. That is, for each column and row we are storing if it contains a 0 or not in the first traversal. If it contains a 0, mark it as true.\\n- In the second traversal, for each matrix[i][j], if rowZero[i] is true OR colZero[j] is true, then we place a 0 at matrix[i][j]. \\n- Else keep matrix[i][j] as it is.\\n- Time Complexity: 2 * O(M*N)\\n- Space Complexity: O(M) + O(N)\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        vector<bool> rowZero(rowSize);\\n        vector<bool> colZero(colSize);\\n        \\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(matrix[i][j] == 0) {\\n                    rowZero[i] = true;\\n                    colZero[j] = true;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(rowZero[i] == true || colZero[j] == true) matrix[i][j] = 0;\\n            }\\n        }        \\n    }\\n```\\n**Approach 2 (O(1) SPACE)**\\nWe will use two bool variables rowZero and colZero to store whether first row or col has a 0 or not. Then we use first row and first col itself to store whether the remaining rows/cols has zero or not. That is, instead of creating two separate arrays like in first approach, we will instead use the first row and first column of the given matrix itself. This will reduce space complexity to constant space **O(1)**. \\n**Time Complexity will remain O(M*N)**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        \\n        bool rowZero = false, colZero = false;\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        \\n        // check for first col\\n        for(int i=0;i<rowSize;i++){\\n            if(matrix[i][0] == 0){\\n                colZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // check for first row \\n        for(int j=0;j<colSize;j++){\\n            if(matrix[0][j] == 0){\\n                rowZero = true;\\n                break;\\n            }\\n        }\\n        // mark 0 in first row/col where the remaining part of matrix has zero or not.\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        // setting the matrix as 0 wherever required except the first row or col\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[0][j] == 0|| matrix[i][0] == 0) matrix[i][j] = 0;\\n            }\\n        }\\n        \\n        if(rowZero){\\n            for(int j=0;j<colSize;j++) matrix[0][j] = 0;\\n        }\\n        if(colZero){\\n            for(int i=0;i<rowSize;i++) matrix[i][0] = 0;\\n        }\\n               \\n    }\\n```\\n\\nPLEASE UPVOTE\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        vector<bool> rowZero(rowSize);\\n        vector<bool> colZero(colSize);\\n        \\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(matrix[i][j] == 0) {\\n                    rowZero[i] = true;\\n                    colZero[j] = true;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(rowZero[i] == true || colZero[j] == true) matrix[i][j] = 0;\\n            }\\n        }        \\n    }\\n```\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        \\n        bool rowZero = false, colZero = false;\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        \\n        // check for first col\\n        for(int i=0;i<rowSize;i++){\\n            if(matrix[i][0] == 0){\\n                colZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // check for first row \\n        for(int j=0;j<colSize;j++){\\n            if(matrix[0][j] == 0){\\n                rowZero = true;\\n                break;\\n            }\\n        }\\n        // mark 0 in first row/col where the remaining part of matrix has zero or not.\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        // setting the matrix as 0 wherever required except the first row or col\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[0][j] == 0|| matrix[i][0] == 0) matrix[i][j] = 0;\\n            }\\n        }\\n        \\n        if(rowZero){\\n            for(int j=0;j<colSize;j++) matrix[0][j] = 0;\\n        }\\n        if(colZero){\\n            for(int i=0;i<rowSize;i++) matrix[i][0] = 0;\\n        }\\n               \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2224337,
                "title": "c-solution-easy",
                "content": "Hope this helps : )\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<vector<int>> temp = matrix;\\n        for(int i = 0; i<matrix.size();i++){\\n            for(int j = 0;j<matrix[0].size();j++){\\n                if(temp[i][j] == 0){\\n                    for(int row = 0;row<matrix[0].size();row++){\\n                        matrix[i][row] = 0;\\n                    }\\n                    for(int col = 0;col<matrix.size();col++){\\n                        matrix[col][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\nMake sure to upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<vector<int>> temp = matrix;\\n        for(int i = 0; i<matrix.size();i++){\\n            for(int j = 0;j<matrix[0].size();j++){\\n                if(temp[i][j] == 0){\\n                    for(int row = 0;row<matrix[0].size();row++){\\n                        matrix[i][row] = 0;\\n                    }\\n                    for(int col = 0;col<matrix.size();col++){\\n                        matrix[col][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191071,
                "title": "java-solution-using-hashset",
                "content": "**Algorithm**\\n* Make two hashset which will store row index and col index of 0s.\\n* First iterate through row hashset, and make all the elements of that particular row as 0.\\n* Similarly, repeat the process with col hashset for col rows.\\n\\nTime Complexity: O(mn)\\n\\n**Code**\\n```\\npublic void setZeroes(int[][] matrix) {\\n        HashSet<Integer> row = new HashSet<>();\\n        HashSet<Integer> col = new HashSet<>();\\n        for(int i=0; i<matrix[0].length; i++){\\n            for(int j=0; j<matrix.length; j++){\\n                if(matrix[j][i] == 0) {\\n                    col.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0) {\\n                    row.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for (int ele : row) {\\n            for(int j=0; j<matrix[0].length; j++){\\n                matrix[ele][j] = 0;\\n            }\\n        }\\n        for (int ele : col) {\\n            for(int j=0; j<matrix.length; j++){\\n                matrix[j][ele] = 0;\\n            }\\n        }\\n    }\\n```\\n**Please upvote if you appreciate the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void setZeroes(int[][] matrix) {\\n        HashSet<Integer> row = new HashSet<>();\\n        HashSet<Integer> col = new HashSet<>();\\n        for(int i=0; i<matrix[0].length; i++){\\n            for(int j=0; j<matrix.length; j++){\\n                if(matrix[j][i] == 0) {\\n                    col.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0) {\\n                    row.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for (int ele : row) {\\n            for(int j=0; j<matrix[0].length; j++){\\n                matrix[ele][j] = 0;\\n            }\\n        }\\n        for (int ele : col) {\\n            for(int j=0; j<matrix.length; j++){\\n                matrix[j][ele] = 0;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2189679,
                "title": "c-10ms-using-unordered-sets",
                "content": "void setZeroes(vector<vector<int>>& matrix) {\\n    unordered_set<int> rows, cols;\\n        \\n    for(int i = 0; i < matrix.size(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            if(!matrix[i][j]){\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n        }\\n    }\\n        \\n    for(auto i = rows.begin(); i != rows.end(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            matrix[*i][j] = 0;\\n        }\\n    }\\n        \\n    for(auto i = cols.begin(); i != cols.end(); i++){\\n        for(int j = 0; j < matrix.size(); j++){\\n            matrix[j][*i] = 0;\\n        }\\n    }\\n}\\t\\n\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "void setZeroes(vector<vector<int>>& matrix) {\\n    unordered_set<int> rows, cols;\\n        \\n    for(int i = 0; i < matrix.size(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            if(!matrix[i][j]){\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n        }\\n    }\\n        \\n    for(auto i = rows.begin(); i != rows.end(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            matrix[*i][j] = 0;\\n        }\\n    }\\n        \\n    for(auto i = cols.begin(); i != cols.end(); i++){\\n        for(int j = 0; j < matrix.size(); j++){\\n            matrix[j][*i] = 0;\\n        }\\n    }\\n}\\t\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2076696,
                "title": "o-m-n-solution-in-cpp-o-1-space-complexity",
                "content": "Here, instead of using an extra space, we use the first column and first row of corresponding matrix to mark our zeros. Once that is done we will just go through the first row and first column and mark all the elements in their respective columns and row as zero...\\nThis would have a corner case of first row or first column or first element being zero. For that we will use three flags to mark them and adust our matrix after the previous operation is done with...\\n\\n**Pls Upvote this thread if you found the explanation helpful**\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix[0].size(), n=matrix.size();\\n        bool row=false, col=false, first=!(matrix[0][0]);\\n        \\n        //Checking if first row contains any zeros\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                row=true;\\n                break;\\n            }\\n        }\\n        \\n        //Checking if first column contains any zeros\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                col=true;\\n                break;\\n            }\\n        }\\n        \\n        /**Going through the rest of matrix to find 0s,\\n        If 0 exist, we update its first row and first column*/\\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++) {\\n                if(matrix[i][j]==0) {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        //Converting a particular column to 0 if the first row correspoding is 0\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                for(int j=1;j<n;j++) matrix[j][i]=0;\\n            }\\n        }\\n        \\n        //Converting a particular row to 0 if the first column corresponding is 0\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                for(int j=1;j<m;j++) matrix[i][j]=0;\\n            }\\n        }\\n        \\n        //Converting a row or column zero if corresponding flag is zero\\n        if(row || first) for(int i=0;i<m;i++) matrix[0][i]=0;\\n        if(col || first) for(int i=0;i<n;i++) matrix[i][0]=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix[0].size(), n=matrix.size();\\n        bool row=false, col=false, first=!(matrix[0][0]);\\n        \\n        //Checking if first row contains any zeros\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                row=true;\\n                break;\\n            }\\n        }\\n        \\n        //Checking if first column contains any zeros\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                col=true;\\n                break;\\n            }\\n        }\\n        \\n        /**Going through the rest of matrix to find 0s,\\n        If 0 exist, we update its first row and first column*/\\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++) {\\n                if(matrix[i][j]==0) {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        //Converting a particular column to 0 if the first row correspoding is 0\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                for(int j=1;j<n;j++) matrix[j][i]=0;\\n            }\\n        }\\n        \\n        //Converting a particular row to 0 if the first column corresponding is 0\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                for(int j=1;j<m;j++) matrix[i][j]=0;\\n            }\\n        }\\n        \\n        //Converting a row or column zero if corresponding flag is zero\\n        if(row || first) for(int i=0;i<m;i++) matrix[0][i]=0;\\n        if(col || first) for(int i=0;i<n;i++) matrix[i][0]=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031661,
                "title": "3-approaches",
                "content": "1st approach:\\nConsidering non-negative numbers in the matrix, we are changing non-zero elements in rows and columns containg 0 to -1. In next step cahnging those -1 to 0.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    //make row elements 0\\n                    for(int k=0;k<cols;k++)\\n                        if(a[i][k]!=0)\\n                            a[i][k]=-1;\\n                    //make col elements 0\\n                    for(int l=0;l<rows;l++)\\n                        if(a[l][j]!=0)\\n                            a[l][j]=-1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==-1)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n2nd approach:\\nWe are creating 2 dummy arrays where we store whhich row and column contains 0. In next step we chang all elems to 0 according to dummy arrays.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        vector<int> dummyRow(rows,-1), dummyCol(cols,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    dummyRow[i]=0;\\n                    dummyCol[j]=0;\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummyRow[i]==0 || dummyCol[j] ==0)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n3rd approach:\\nInstead of creating dummy arrays we consider 0th row and column as the same. But here matrix[0][0]\\ngets overlapped by both row and column. So for 0th column we consider a varaible col . If any elem of 0th column has 0 then we change col\\'s value. Next we traverse from the last of array.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int col=1;\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            if(a[i][0]==0)\\n                col=0;\\n            for( int j=1;j<cols;j++){\\n                \\n                if(a[i][j]==0){\\n                    a[0][j]=0;\\n                    a[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=rows-1;i>=0;i--){\\n            for(int j=cols-1;j>=1;j--){\\n                if(a[0][j] == 0 || a[i][0]==0)\\n                    a[i][j]=0; \\n            }\\n            if(col==0)\\n                a[i][0]=0;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    //make row elements 0\\n                    for(int k=0;k<cols;k++)\\n                        if(a[i][k]!=0)\\n                            a[i][k]=-1;\\n                    //make col elements 0\\n                    for(int l=0;l<rows;l++)\\n                        if(a[l][j]!=0)\\n                            a[l][j]=-1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==-1)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        vector<int> dummyRow(rows,-1), dummyCol(cols,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    dummyRow[i]=0;\\n                    dummyCol[j]=0;\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummyRow[i]==0 || dummyCol[j] ==0)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int col=1;\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            if(a[i][0]==0)\\n                col=0;\\n            for( int j=1;j<cols;j++){\\n                \\n                if(a[i][j]==0){\\n                    a[0][j]=0;\\n                    a[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=rows-1;i>=0;i--){\\n            for(int j=cols-1;j>=1;j--){\\n                if(a[0][j] == 0 || a[i][0]==0)\\n                    a[i][j]=0; \\n            }\\n            if(col==0)\\n                a[i][0]=0;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005761,
                "title": "go-clear-solution",
                "content": "```\\nfunc setZeroes(matrix [][]int)  {\\n    m, n := len(matrix), len(matrix[0])\\n    zeroColumn, zeroRow := false, false\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            if matrix[r][c] == 0 {\\n                if c == 0 { zeroColumn = true } else { matrix [0][c] = 0 }\\n                if r == 0 { zeroRow = true } else { matrix [r][0] = 0 }\\n            }\\n        }\\n    }\\n    for r := 1; r < m; r++ {\\n        for c := 1; c < n; c++ {\\n            if matrix[0][c] == 0 || matrix[r][0] == 0 {\\n                matrix[r][c] = 0\\n            }\\n        }\\n    }\\n    if zeroColumn { for r := 0; r < m; r++ { matrix[r][0] = 0 } }\\n    if zeroRow { for c := 0; c < n; c++ { matrix[0][c] = 0 } }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc setZeroes(matrix [][]int)  {\\n    m, n := len(matrix), len(matrix[0])\\n    zeroColumn, zeroRow := false, false\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            if matrix[r][c] == 0 {\\n                if c == 0 { zeroColumn = true } else { matrix [0][c] = 0 }\\n                if r == 0 { zeroRow = true } else { matrix [r][0] = 0 }\\n            }\\n        }\\n    }\\n    for r := 1; r < m; r++ {\\n        for c := 1; c < n; c++ {\\n            if matrix[0][c] == 0 || matrix[r][0] == 0 {\\n                matrix[r][c] = 0\\n            }\\n        }\\n    }\\n    if zeroColumn { for r := 0; r < m; r++ { matrix[r][0] = 0 } }\\n    if zeroRow { for c := 0; c < n; c++ { matrix[0][c] = 0 } }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737433,
                "title": "java-solution-using-two-sets",
                "content": "``` \\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> rows=new HashSet<>();\\n        Set<Integer> cols=new HashSet<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    rows.add(i);\\n                    cols.add(j);\\n                }\\n            }\\n        }\\n        for(int i : rows){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        for(int j: cols){\\n            for(int i=0;i<matrix.length;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n\\nTime Comp:- O(rows*cols)\\nSpace :- O(rows+cols)",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> rows=new HashSet<>();\\n        Set<Integer> cols=new HashSet<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    rows.add(i);\\n                    cols.add(j);\\n                }\\n            }\\n        }\\n        for(int i : rows){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        for(int j: cols){\\n            for(int i=0;i<matrix.length;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683206,
                "title": "python-easy-and-concise-solution-with-hashmap-python",
                "content": "* Store 0 valued indexes in hashmap\\n* Traverse the matrix and update according to hashmap\\n\\n# PYTHON\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        n, m = len(matrix), len(matrix[0])\\n        rows, cols = {}, {}\\n        for i in range(n):\\n            for j in range(m):\\n                if matrix[i][j] == 0:\\n                    rows[i] = 1\\n                    cols[j] = 1\\n        for i in range(n):\\n            for j in range(m):\\n                if i in rows:\\n                    matrix[i][j] = 0\\n                if j in cols:\\n                    matrix[i][j] = 0\\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        n, m = len(matrix), len(matrix[0])\\n        rows, cols = {}, {}\\n        for i in range(n):\\n            for j in range(m):\\n                if matrix[i][j] == 0:\\n                    rows[i] = 1\\n                    cols[j] = 1\\n        for i in range(n):\\n            for j in range(m):\\n                if i in rows:\\n                    matrix[i][j] = 0\\n                if j in cols:\\n                    matrix[i][j] = 0\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558946,
                "title": "c-three-levels-of-solution",
                "content": "**1. O(mn) space** \\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<vector<int>>res(m, vector<int>(n, -1));\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) res[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) res[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(res[i][j] == 0) matrix[i][j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n```\\n**2. O(m+n) space**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<pair<int,int>>index;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tindex.push_back({i,j});\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\tvector<pair<int,int>>::iterator it;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tit = find (index.begin(), index.end(), make_pair(i, j));\\n\\t\\t\\tif(it != index.end()) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) matrix[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) matrix[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n}\\n```\\n**3. O(1) space**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tbool zeroCol = false;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tif(matrix[i][0] == 0) {\\n\\t\\t\\tzeroCol = true;\\n\\t\\t}\\n\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tmatrix[0][j] = 0;\\n\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 1; i < m; i++) {\\n\\t\\tfor(int j = 1; j < n; j++) {\\n\\t\\t\\tif(!matrix[i][0] || !matrix[0][j])\\n\\t\\t\\t\\tmatrix[i][j] = 0;\\n\\t\\t}\\n\\t} \\n\\tif(matrix[0][0] == 0) {\\n\\t\\tfor(int j = 0; j < n; j++) matrix[0][j] = 0;\\n\\t}\\n\\tif(zeroCol) {\\n\\t\\tfor(int i = 0; i < m; i++) matrix[i][0] = 0;\\n\\t}\\n}\\n\\t",
                "solutionTags": [],
                "code": "```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<vector<int>>res(m, vector<int>(n, -1));\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) res[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) res[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(res[i][j] == 0) matrix[i][j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<pair<int,int>>index;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tindex.push_back({i,j});\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\tvector<pair<int,int>>::iterator it;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tit = find (index.begin(), index.end(), make_pair(i, j));\\n\\t\\t\\tif(it != index.end()) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) matrix[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) matrix[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402036,
                "title": "java-easy-solution-o-1-space",
                "content": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n      for(int i=0;i<rows;i++){\\n        if(matrix[i][0]==0) \\n            col0=0;\\n        for(int j=1;j<cols;j++){\\n          if(matrix[i][j]==0)\\n            matrix[i][0]=matrix[0][j]=0;\\n        }\\n      }\\n      \\n      for(int i=rows-1;i>=0;i--){\\n        for(int j = cols-1;j>=1;j--)\\n          if(matrix[0][j]==0 || matrix[i][0]==0)\\n            matrix[i][j]=0;\\n        \\n        if(col0==0) matrix[i][0]=0;\\n\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n      for(int i=0;i<rows;i++){\\n        if(matrix[i][0]==0) \\n            col0=0;\\n        for(int j=1;j<cols;j++){\\n          if(matrix[i][j]==0)\\n            matrix[i][0]=matrix[0][j]=0;\\n        }\\n      }\\n      \\n      for(int i=rows-1;i>=0;i--){\\n        for(int j = cols-1;j>=1;j--)\\n          if(matrix[0][j]==0 || matrix[i][0]==0)\\n            matrix[i][j]=0;\\n        \\n        if(col0==0) matrix[i][0]=0;\\n\\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823987,
                "title": "wrong-test-case",
                "content": "The problem statement has a constraint:\\n\\n```-10^9 <= matrix[i][j] <= 10^9```\\n\\nyet one of the test cases that my code failed to process looks like this:\\n\\n```[[-4,-2147483648,6,-7,0],[-8,6,-8,-6,0],[2147483647,2,-9,-6,-10]]```\\n\\nI know how to solve the problem without that constraint, but the problem statement shouldn\\'t have included it in the first place. How do we fix the problem statement?",
                "solutionTags": [],
                "code": "```-10^9 <= matrix[i][j] <= 10^9```\n```[[-4,-2147483648,6,-7,0],[-8,6,-8,-6,0],[2147483647,2,-9,-6,-10]]```",
                "codeTag": "Unknown"
            },
            {
                "id": 744750,
                "title": "3-different-solutions-in-c",
                "content": "Solution 1 using queue\\n\\nIn worst case,\\nTime Complexity : O(nm*(n+m))\\nSpace Complexity : O(n*m)\\n\\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n                if(A[i][j] == 0)\\n                    q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            int f = q.front().first;\\n            int s = q.front().second;\\n            q.pop();\\n            \\n            for(int i=0; i<n; i++)\\n                A[i][s] = 0;\\n            \\n            for(int j=0; j<m; j++)\\n                A[f][j] = 0;\\n        }\\n    }\\n```\\n\\nSolution 2 with O(1) space:\\n\\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    for(int x=0; x<n; x++)\\n                        if(A[x][j] != 0)\\n                            A[x][j] = -1000000;\\n\\n                    for(int y=0; y<m; y++)\\n                        if(A[i][y] != 0)\\n                            A[i][y] = -1000000;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == -1000000)\\n                    A[i][j] = 0;\\n            }\\n        }\\n        \\n    }\\n```\\n\\nSolution 3 with O(1) space :\\n\\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        bool col = false;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(A[i][0] == 0)\\n                col = true;\\n            for(int j=1; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1; i<n; i++)\\n            for(int j=1; j<m; j++)\\n                if(A[i][0] == 0 || A[0][j] == 0)\\n                    A[i][j] = 0;\\n        \\n        //first row\\n        if(A[0][0] == 0)\\n            for(int j=1; j<m; j++)\\n                A[0][j] = 0;\\n        \\n        //first column\\n        if(col)\\n            for(int i=0; i<n; i++)\\n                A[i][0] = 0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n                if(A[i][j] == 0)\\n                    q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            int f = q.front().first;\\n            int s = q.front().second;\\n            q.pop();\\n            \\n            for(int i=0; i<n; i++)\\n                A[i][s] = 0;\\n            \\n            for(int j=0; j<m; j++)\\n                A[f][j] = 0;\\n        }\\n    }\\n```\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    for(int x=0; x<n; x++)\\n                        if(A[x][j] != 0)\\n                            A[x][j] = -1000000;\\n\\n                    for(int y=0; y<m; y++)\\n                        if(A[i][y] != 0)\\n                            A[i][y] = -1000000;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == -1000000)\\n                    A[i][j] = 0;\\n            }\\n        }\\n        \\n    }\\n```\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        bool col = false;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(A[i][0] == 0)\\n                col = true;\\n            for(int j=1; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1; i<n; i++)\\n            for(int j=1; j<m; j++)\\n                if(A[i][0] == 0 || A[0][j] == 0)\\n                    A[i][j] = 0;\\n        \\n        //first row\\n        if(A[0][0] == 0)\\n            for(int j=1; j<m; j++)\\n                A[0][j] = 0;\\n        \\n        //first column\\n        if(col)\\n            for(int i=0; i<n; i++)\\n                A[i][0] = 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656346,
                "title": "javascript-short-o-1-space-solution",
                "content": "```\\nvar setZeroes = function(matrix) {\\n    let col0 = 1, row = matrix.length, col = matrix[0].length;\\n    \\n    for(let i = 0; i < row; i++) {\\n        if(matrix[i][0] === 0) col0 = 0;\\n        for(let j = 1; j < col; j++) {\\n            if(matrix[i][j] === 0) {\\n                matrix[i][0] =  matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    for(let i = row-1; i >= 0; i--) {\\n        for(let j = col-1; j > 0; j--) {\\n            if(matrix[i][0] === 0 || matrix[0][j] === 0) matrix[i][j] = 0;\\n        }\\n        if(col0 === 0) matrix[i][0] = 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n    let col0 = 1, row = matrix.length, col = matrix[0].length;\\n    \\n    for(let i = 0; i < row; i++) {\\n        if(matrix[i][0] === 0) col0 = 0;\\n        for(let j = 1; j < col; j++) {\\n            if(matrix[i][j] === 0) {\\n                matrix[i][0] =  matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    for(let i = row-1; i >= 0; i--) {\\n        for(let j = col-1; j > 0; j--) {\\n            if(matrix[i][0] === 0 || matrix[0][j] === 0) matrix[i][j] = 0;\\n        }\\n        if(col0 === 0) matrix[i][0] = 0;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358555,
                "title": "java-solution-o-1-space-beats-100-in-time-with-explanation",
                "content": "We can reduce the space to O(1) by using the first row as a replacement for the row array and the first column as a replacement for the column array.This works as follows:\\n\\n1. Check if the first row and first column have any zeroes, and set variables rowHasZero and columnHasZero.(We\\'ll nullify the first row and first column later, if necessary.)\\n\\n2. Iterate through the rest of matrix, setting A[i][0] and A[0][j] to zero whenever there\\'s a zero in A[i][j].\\n\\n3. Iterate through rest of matrix, nullifying row i if there\\'s a zero in A[i][0].\\n\\n4. Iterate through rest of matrix, nullifying column j if there\\'s a zero in A[0][j].\\n\\n5. Nullify the first row and first column, if necessary(based on values from step 1).\\n\\nThe explanation is taken from the book \"Cracking The Coding Interview\" by Gayle Laakmann Mcdowell.\\n\\n```\\nclass Solution \\n{\\n    public void nullifyRow(int[][] A, int r)\\n    {\\n        int col = A[r].length;\\n        for(int i = 0; i < col; i++)\\n            A[r][i] = 0;\\n    }\\n    public void nullifyCol(int[][] A, int c)\\n    {\\n        int row = A.length;\\n        for(int i = 0; i < row; i++)\\n            A[i][c] = 0;\\n    }\\n    public void setZeroes(int[][] A) \\n    {\\n        if(A == null)\\n            return;\\n        \\n        boolean rowHasZero = false;\\n        boolean colHasZero = false;\\n        \\n        int row = A.length;\\n        int col = A[0].length;\\n        \\n        for(int i = 0; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n            {\\n                colHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int j = 0; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n            {\\n                rowHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            for(int j = 1; j < col; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n                nullifyRow(A, i);\\n        }\\n        \\n        for(int j = 1; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n                nullifyCol(A, j);\\n        }\\n        \\n        if(colHasZero)\\n        {\\n            nullifyCol(A, 0);\\n        }\\n        \\n        if(rowHasZero)\\n        {\\n            nullifyRow(A, 0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public void nullifyRow(int[][] A, int r)\\n    {\\n        int col = A[r].length;\\n        for(int i = 0; i < col; i++)\\n            A[r][i] = 0;\\n    }\\n    public void nullifyCol(int[][] A, int c)\\n    {\\n        int row = A.length;\\n        for(int i = 0; i < row; i++)\\n            A[i][c] = 0;\\n    }\\n    public void setZeroes(int[][] A) \\n    {\\n        if(A == null)\\n            return;\\n        \\n        boolean rowHasZero = false;\\n        boolean colHasZero = false;\\n        \\n        int row = A.length;\\n        int col = A[0].length;\\n        \\n        for(int i = 0; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n            {\\n                colHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int j = 0; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n            {\\n                rowHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            for(int j = 1; j < col; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n                nullifyRow(A, i);\\n        }\\n        \\n        for(int j = 1; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n                nullifyCol(A, j);\\n        }\\n        \\n        if(colHasZero)\\n        {\\n            nullifyCol(A, 0);\\n        }\\n        \\n        if(rowHasZero)\\n        {\\n            nullifyRow(A, 0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181671,
                "title": "simple-java-solution",
                "content": "```\\n    public void setZeroes(int[][] matrix) {\\n        boolean[] zeroRows = new boolean[matrix.length];\\n        boolean[] zeroColumns= new boolean[matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    zeroRows[i] = true;\\n                    zeroColumns[j] = true;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (zeroRows[i] || zeroColumns[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public void setZeroes(int[][] matrix) {\\n        boolean[] zeroRows = new boolean[matrix.length];\\n        boolean[] zeroColumns= new boolean[matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    zeroRows[i] = true;\\n                    zeroColumns[j] = true;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (zeroRows[i] || zeroColumns[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26141,
                "title": "my-c-solution-use-o-1-space-and-84ms",
                "content": "    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            int m = matrix.size();\\n            int n = matrix[0].size();\\n            \\n            if(m==0 || n==0) return;\\n            int row = -1, col = -1;\\n            for(int i=0; i<m; i++){\\n                if(row != -1) break;\\n                for(int j=0; j<n; j++){\\n                    if(matrix[i][j] == 0){\\n                        row = i;\\n                        col = j;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(row == -1) return;\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    if(matrix[i][j] == 0){\\n                        matrix[i][col] = 0;\\n                        matrix[row][j] = 0;\\n                    }\\n                }\\n            }\\n            for(int i=0; i<m; i++){\\n                if(i == row) continue;\\n                if(matrix[i][col] == 0){\\n                    for(int j=0; j<n; j++) matrix[i][j] = 0;\\n                }\\n            }\\n            for(int j=0; j<n; j++){\\n                if(j == col) continue;\\n                if(matrix[row][j] == 0){\\n                    for(int i=0; i<m; i++) matrix[i][j] = 0;\\n                }\\n            }\\n            for(int i=0; i<m; i++) matrix[i][col] = 0;\\n            for(int j=0; j<n; j++) matrix[row][j] = 0;\\n        }\\n    };`enter code here`",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            int m = matrix.size();\\n            int n = matrix[0].size();\\n            \\n            if(m==0 || n==0) return;\\n            int row = -1, col = -1;\\n            for(int i=0; i<m; i++){\\n                if(row != -1) break;\\n                for(int j=0; j<n; j++){\\n                    if(matrix[i][j] == 0){\\n                        row = i;\\n                        col = j;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3958297,
                "title": "easy-c-solution-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n     int m=matrix.size();\\n     int n=matrix[0].size();\\n     bool isRow=false;\\n     bool isCol=false;\\n     for(int i=0;i<m;i++)\\n     {\\n         if(matrix[i][0]==0)\\n         isCol=true;\\n     }\\n     for(int j=0;j<n;j++)\\n     {\\n         if(matrix[0][j]==0)\\n         isRow=true;\\n     } \\n     for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][j]==0)\\n            {\\n                matrix[0][j]=0;\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n    for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][0]==0||matrix[0][j]==0)\\n            {\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }  \\n    if(isRow)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            matrix[0][i]=0;\\n        }\\n    }\\n    if(isCol)\\n    {\\n        for(int i=0;i<m;i++)\\n        {\\n            matrix[i][0]=0;\\n        }\\n    }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n     int m=matrix.size();\\n     int n=matrix[0].size();\\n     bool isRow=false;\\n     bool isCol=false;\\n     for(int i=0;i<m;i++)\\n     {\\n         if(matrix[i][0]==0)\\n         isCol=true;\\n     }\\n     for(int j=0;j<n;j++)\\n     {\\n         if(matrix[0][j]==0)\\n         isRow=true;\\n     } \\n     for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][j]==0)\\n            {\\n                matrix[0][j]=0;\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n    for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][0]==0||matrix[0][j]==0)\\n            {\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }  \\n    if(isRow)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            matrix[0][i]=0;\\n        }\\n    }\\n    if(isCol)\\n    {\\n        for(int i=0;i<m;i++)\\n        {\\n            matrix[i][0]=0;\\n        }\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697836,
                "title": "easy-cpp-solution-with-stepwise-detailed-explanation",
                "content": "# Intuition\\n To form a vector storing the index of 0 element\\'s row and column.\\n\\n# Approach\\n1. The function `setZeroes` takes a 2D vector `matrix` as input and does not return any value.\\n\\n2. It initializes two empty vectors `x` and `y`. These vectors will store the row and column indices of the cells that contain zeros in the matrix.\\n\\n3. It uses nested loops to iterate through each element of the matrix. If an element is equal to 0, it means we need to set the entire row and column containing that element to zero.\\n\\n4. If an element is found to be zero, its row index (`i`) is appended to the vector `x`, and its column index (`j`) is appended to the vector `y`.\\n\\n5. After iterating through the entire matrix, we have two vectors `x` and `y` that contain the row and column indices of the cells with zeros.\\n\\n6. The next step is to set the rows to zero. It iterates over the vector `x` and takes each index value. For each index, it sets all the elements of that row to zero by iterating through the columns (`m`).\\n\\n7. After setting the rows to zero, it moves on to setting the columns to zero. It iterates over the vector `y` and takes each index value. For each index, it sets all the elements of that column to zero by iterating through the rows (`n`).\\n\\n8. Once both the row and column modifications are completed, the function exits.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int>x,y;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    x.push_back(i);\\n                    y.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<x.size();i++)\\n        {\\n            int index=x[i];\\n            for(int j=0;j<m;j++)\\n            {\\n                matrix[index][j]=0;\\n            }\\n        }\\n         for(int i=0;i<y.size();i++)\\n        {\\n            int index=y[i];\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[j][index]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n# Please upvote for better reach!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int>x,y;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    x.push_back(i);\\n                    y.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<x.size();i++)\\n        {\\n            int index=x[i];\\n            for(int j=0;j<m;j++)\\n            {\\n                matrix[index][j]=0;\\n            }\\n        }\\n         for(int i=0;i<y.size();i++)\\n        {\\n            int index=y[i];\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[j][index]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692413,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->https://takeuforward.org/data-structure/set-matrix-zero/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(2(N*M))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++ ){\\n            if(matrix[i][0]==0)colm=0;\\n\\n            for(int j=1;j<col;j++ ){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n        }\\n        }\\n\\n        for(int i=row-1;i>=0;i--){\\n\\n            for(int j=col-1;j>=1;j--){\\n                if( matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(colm==0)matrix[i][0]=0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++ ){\\n            if(matrix[i][0]==0)colm=0;\\n\\n            for(int j=1;j<col;j++ ){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n        }\\n        }\\n\\n        for(int i=row-1;i>=0;i--){\\n\\n            for(int j=col-1;j>=1;j--){\\n                if( matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(colm==0)matrix[i][0]=0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648965,
                "title": "java-11-liner-solution-0ms-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n      int m = matrix.length, n = matrix[0].length, k = 0;\\n      // First row has zeroes ?\\n      while(k < n && matrix[0][k] != 0)  ++ k;\\n      // Use first row/column as marker, scan the matrix\\n      for(int i = 1; i < m; i ++) \\n        for(int j = 0; j < n; j ++)\\n         if(matrix[i][j] == 0)\\n          matrix[0][j] = matrix[i][0] = 0;\\n      // Set the zeros\\n      for(int i = 1; i < m; i ++)\\n        for(int j = n - 1; j >=0; j --)\\n         if(matrix[0][j] == 0 || matrix[i][0] == 0)\\n          matrix[i][j] = 0;\\n      // Set the zeros for the first row\\n      if(k < n) Arrays.fill(matrix[0], 0);\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n      int m = matrix.length, n = matrix[0].length, k = 0;\\n      // First row has zeroes ?\\n      while(k < n && matrix[0][k] != 0)  ++ k;\\n      // Use first row/column as marker, scan the matrix\\n      for(int i = 1; i < m; i ++) \\n        for(int j = 0; j < n; j ++)\\n         if(matrix[i][j] == 0)\\n          matrix[0][j] = matrix[i][0] = 0;\\n      // Set the zeros\\n      for(int i = 1; i < m; i ++)\\n        for(int j = n - 1; j >=0; j --)\\n         if(matrix[0][j] == 0 || matrix[i][0] == 0)\\n          matrix[i][j] = 0;\\n      // Set the zeros for the first row\\n      if(k < n) Arrays.fill(matrix[0], 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632582,
                "title": "striver-approach-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n\\n        vector<int>row(n,0);\\n        vector<int>col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]==1|col[j]==1)\\n                {\\n                   matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n\\n        vector<int>row(n,0);\\n        vector<int>col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]==1|col[j]==1)\\n                {\\n                   matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612506,
                "title": "easiest-approach-brute-better-optimal-o-n-2-no-extra-space-fully-explained-beats-100",
                "content": "# BRUTE FORCE METHOD\\n## Approach:\\nThe steps are the following:\\n1. First, we will use two loops(nested loops) to traverse all the cells of the matrix.\\n2. If any cell (i,j) contains the value 0, we will mark all cells in row i and column j with -1 except those which contain 0.\\n3. We will perform step 2 for every cell containing 0.\\n4. Finally, we will mark all the cells containing -1 with 0.\\n5. Thus the given matrix will be modified according to the question.\\n\\n**Note:** *Here, we are assuming that the matrix does not contain any negative numbers. But if it contains negatives, we need to find some other ways to mark the cells instead of marking them with -1.*\\n\\n## Intuition:\\n\\nThis approach is very straightforward and we are just following the process stated in the question. But the following two questions need to be clarified to understand the algorithm further.\\n\\n## Complexity Analysis\\n**Time Complexity:** O((N\\\\*M)\\\\*(N + M)) + O(N\\\\*M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** Firstly, we are traversing the matrix to find the cells with the value 0. It takes O(N\\\\*M). Now, whenever we find any such cell we mark that row and column with -1. This process takes O(N+M). So, combining this the whole process, finding and marking, takes O((N\\\\*M)\\\\*(N + M)).\\nAnother O(N*M) is taken to mark all the cells with -1 as 0 finally.\\n\\n**Space Complexity:** O(1) as we are not using any extra space.\\n\\n# BETTER METHOD\\n## Approach (Using two extra arrays):\\n\\nThe steps are as follows:\\n\\n1. First, we will declare two arrays: a row array of size N and a col array of size M and both are initialized with 0.\\n2. Then, we will use two loops(nested loops) to traverse all the cells of the matrix.\\n3. If any cell (i,j) contains the value 0, we will mark ith index of row array i.e. row[i] and jth index of col array col[j] as 1. It signifies that all the elements in the ith row and jth column will be 0 in the final matrix.\\n4. We will perform step 3 for every cell containing 0.\\n5. Finally, we will again traverse the entire matrix and we will put 0 into all the cells (i, j) for which either row[i] or col[j] is marked as 1.\\n6. Thus we will get our final matrix.\\n\\n## Intuition:\\n\\nIn the previous approach, we were marking the cells with -1 while traversing the matrix. But in this approach, we are not marking the entire row and column instead, we are marking the ith index of **row** array i.e. row[i], and jth index of **col** array i.e. col[j] with 1. These marked indices of the two arrays, row and col will tell us for which rows and columns we need to change the values to 0. For any cell (i, j), if the row[i] or col[j] is marked with 1, we will change the value of cell(i, j) to 0.\\n\\nHere we are marking the cells after traversal whereas in the previous case, we were marking the cells while traversal. That is how the time complexity reduces in this case.\\n\\n## Complexity Analysis\\n**Time Complexity:** O(2\\\\*(N\\\\*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** We are traversing the entire matrix 2 times and each traversal is taking O(N*M) time complexity.\\n\\n**Space Complexity:** O(N) + O(M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** O(N) is for using the row array and O(M) is for using the col array.\\n\\n# OPTIMAL METHOD\\n## Intuition:\\nIn the previous approach, the time complexity is minimal as the traversal of a matrix takes at least O(N\\\\*M)(*where N = row and M = column*). In this approach, we can just improve the space complexity. So, instead of using two extra matrices row and col, we will use the 1st row and 1st column of the given matrix to keep a track of the cells that need to be marked with 0. But here comes a problem. If we try to use the 1st row and 1st column to serve the purpose, the cell matrix[0][0] is taken twice. To solve this problem we will take an extra variable col0 initialized with 1. Now the entire 1st row of the matrix will serve the purpose of the **row array**. And the 1st column from (0,1) to (0,m-1) with the col0 variable will serve the purpose of the **col array**.\\n\\nIf any cell in the 0th row contains 0, we will mark matrix[0][0] as 0 and if any cell in the 0th column contains 0, we will mark the col0 variable as 0.\\n\\nThus we can optimize the space complexity.\\n\\n## Approach: \\n\\nThe steps are as follows:\\n\\n1. First, we will traverse the matrix and mark the proper cells of 1st row and 1st column with 0 accordingly. The marking will be like this: if cell(i, j) contains 0, we will mark the i-th row i.e. matrix[i][0] with 0 and we will mark j-th column i.e. matrix[0][j] with 0.\\nIf i is 0, we will mark matrix[0][0] with 0 but if j is 0, we will mark the col0 variable with 0 instead of marking matrix[0][0] again.\\n2. After step 1 is completed, we will modify the cells from (1,1) to (n-1, m-1) using the values from the 1st row, 1st column, and col0 variable.\\n*We will not modify the 1st row and 1st column of the matrix here as the modification of the rest of the matrix(i.e. From (1,1) to (n-1, m-1)) is dependent on that row and column.*\\n3. Finally, we will change the 1st row and column using the values from matrix[0][0] and col0 variable. Here also we will change the row first and then the column.\\nIf matrix[0][0] = 0, we will change all the elements from the cell (0,1) to (0, m-1), to 0.\\nIf col0 = 0, we will change all the elements from the cell (0,0) to (n-1, 0), to 0.\\n\\n## Complexity Analysis\\n**Time Complexity:** O(2\\\\*(N\\\\*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** In this approach, we are also traversing the entire matrix 2 times and each traversal is taking O(N\\\\*M) time complexity.\\n\\n**Space Complexity:** O(1) as we are not using any extra space.\\n\\n# CODE\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        std::ios::sync_with_stdio(0); std::cin.tie(0);\\n        int n=matrix.size(), m=matrix[0].size(), col0=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0] = 0;\\n                    if(j!=0) matrix[0][j] = 0;\\n                    else col0 = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[0][j] == 0 || matrix[i][0] == 0) matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(matrix[0][0]==0){\\n            for(int j=0;j<m;j++) matrix[0][j] = 0;\\n        }\\n        if(col0 == 0){\\n            for(int i=0;i<n;i++) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/82c15abe-fec8-4e99-bbc1-e59479c122ab_1690651460.5963545.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        std::ios::sync_with_stdio(0); std::cin.tie(0);\\n        int n=matrix.size(), m=matrix[0].size(), col0=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0] = 0;\\n                    if(j!=0) matrix[0][j] = 0;\\n                    else col0 = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[0][j] == 0 || matrix[i][0] == 0) matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(matrix[0][0]==0){\\n            for(int j=0;j<m;j++) matrix[0][j] = 0;\\n        }\\n        if(col0 == 0){\\n            for(int i=0;i<n;i++) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497187,
                "title": "easy-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        keep track of rows and columns when ever we encounter 0\\n\\n        and then using stored info we will set all rows and col to 0\\n\\n        if set contains i and j we will set all the element to 0\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //keep track of rows and columns when ever we encounter 0\\n\\n        //and then using stored info we will set all rows and col to 0\\n\\n        HashSet<Integer> row= new HashSet<>();\\n        HashSet<Integer> col= new HashSet<>();\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n\\n        // if set contains i and j we will set all the element to 0\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++)\\n                if(row.contains(i) || col.contains(j)) matrix[i][j]=0;\\n        }\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //keep track of rows and columns when ever we encounter 0\\n\\n        //and then using stored info we will set all rows and col to 0\\n\\n        HashSet<Integer> row= new HashSet<>();\\n        HashSet<Integer> col= new HashSet<>();\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n\\n        // if set contains i and j we will set all the element to 0\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++)\\n                if(row.contains(i) || col.contains(j)) matrix[i][j]=0;\\n        }\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476709,
                "title": "c-better-approach-t-c-o-n-m-striver",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing extra row and col with initializes with 0\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate through every element in matrix and if 0 found then mark extra row and col equals to 1.\\nNow iterate through matrix and if row and col contains 1 then update matrix[i][j] to 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<int> row(r,0);\\n        vector<int> col(c,0);\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(row[i] || col[j])\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<int> row(r,0);\\n        vector<int> col(c,0);\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(row[i] || col[j])\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463953,
                "title": "java-solution-for-set-matrix-zeros-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution aims to set all the elements in a row or column of an input matrix to zero if any element in that row or column is zero. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is to first check if the first row and the first column have any zeros, as they will be used later to mark the remaining rows and columns that need to be set to zero. The algorithm then iterates over the input matrix, starting from the second row and the second column. For each element, if it is zero, it sets the corresponding elements in the first row and first column to zero. After marking the rows and columns that need to be set to zero, the algorithm then iterates over the input matrix again and sets the elements in marked rows and columns to zero. Finally, the algorithm checks if the first row and the first column need to be set to zero and sets them accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn), where m is the number of rows and n is the number of columns in the input matrix, as the algorithm needs to iterate over all elements in the matrix twice. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(1), as the algorithm uses only a constant amount of extra space to store the boolean variables used to track the presence of zeros in the first row and the first column.\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean firstRowZero = false;\\n        boolean firstColumnZero = false;\\n        //set first row and column zero or not\\n        for(int i=0; i<matrix.length; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                firstColumnZero = true;\\n                break;\\n            }\\n        }\\n        for(int i=0; i<matrix[0].length; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        //mark zeros on first row and column\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        //use mark to set elements\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        //set first column and row\\n        if(firstColumnZero)\\n        {\\n            for(int i=0; i<matrix.length; i++)\\n                matrix[i][0] = 0;\\n        }\\n        if(firstRowZero)\\n        {\\n            for(int i=0; i<matrix[0].length; i++)\\n                matrix[0][i] = 0;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean firstRowZero = false;\\n        boolean firstColumnZero = false;\\n        //set first row and column zero or not\\n        for(int i=0; i<matrix.length; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                firstColumnZero = true;\\n                break;\\n            }\\n        }\\n        for(int i=0; i<matrix[0].length; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        //mark zeros on first row and column\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        //use mark to set elements\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        //set first column and row\\n        if(firstColumnZero)\\n        {\\n            for(int i=0; i<matrix.length; i++)\\n                matrix[i][0] = 0;\\n        }\\n        if(firstRowZero)\\n        {\\n            for(int i=0; i<matrix[0].length; i++)\\n                matrix[0][i] = 0;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456258,
                "title": "optimal-solution-o-1-space-comp-c-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst row and First column is going to be marked to reduce Space complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int col0=1; // To ignore collision of the row and column,\\n                    // we can use this variable to indicate the first coloumn\\n        for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[i][j] == 0) {\\n                // mark i-th row:\\n                matrix[i][0] = 0;\\n\\n                // mark j-th column:\\n                if (j != 0)\\n                    matrix[0][j] = 0;\\n                else\\n                    col0 = 0;\\n            }\\n        }\\n    }\\n\\n    // Step 2: Mark with 0 from (1,1) to (n-1, m-1):\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[i][j] != 0) {\\n                // check for col & row:\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\n    //step 3: Finally mark the 1st col & then 1st row:\\n    if (matrix[0][0] == 0) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if (col0 == 0) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n\\n    }\\n};\\n```\\n# Upvote if it was helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int col0=1; // To ignore collision of the row and column,\\n                    // we can use this variable to indicate the first coloumn\\n        for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[i][j] == 0) {\\n                // mark i-th row:\\n                matrix[i][0] = 0;\\n\\n                // mark j-th column:\\n                if (j != 0)\\n                    matrix[0][j] = 0;\\n                else\\n                    col0 = 0;\\n            }\\n        }\\n    }\\n\\n    // Step 2: Mark with 0 from (1,1) to (n-1, m-1):\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[i][j] != 0) {\\n                // check for col & row:\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\n    //step 3: Finally mark the 1st col & then 1st row:\\n    if (matrix[0][0] == 0) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if (col0 == 0) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314911,
                "title": "1ms-optimised-java-solution-using-arrays",
                "content": "# Intuition\\n Instead of traversing through each row and column, we can use dummy arrays to check if the particular row or column has an element 0 or not, which will improve the time complexity.\\n\\n# Approach\\n   Take two dummy arrays one of size of the row and the other of size of column. Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n\\n# Complexity\\n- Time complexity:\\nO(N*M + N*M)\\n\\n- Space complexity:\\n O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int rows=matrix.length;\\n        int cols=matrix[0].length;\\n        int []dummy1=new int[rows];\\n        int []dummy2=new int[cols];\\n        Arrays.fill(dummy1,-1);\\n        Arrays.fill(dummy2,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0)\\n                    {dummy1[i]=0;\\n                   dummy2[j]=0;\\n            }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummy1[i]==0 || dummy2[j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int rows=matrix.length;\\n        int cols=matrix[0].length;\\n        int []dummy1=new int[rows];\\n        int []dummy2=new int[cols];\\n        Arrays.fill(dummy1,-1);\\n        Arrays.fill(dummy2,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0)\\n                    {dummy1[i]=0;\\n                   dummy2[j]=0;\\n            }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummy1[i]==0 || dummy2[j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181635,
                "title": "73-set-matrix-zeroes-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We use the first row and first column to store information about the rest of the matrix.\\n- If matrix[i][j] is 0, set matrix[i][0] and matrix[0][j] to 0.\\n- Use a variable called col0 to store information about the first column.\\n- Use the information stored in the first row and first column to set the rest of the matrix to 0s.\\n- We need to traverse the matrix in reverse order, so that we do not overwrite information that we need to use later.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # Use the first row and first column to store information about the rest of the matrix\\n        # If matrix[i][j] is 0, set matrix[i][0] and matrix[0][j] to 0\\n        # Use a variable called col0 to store information about the first column\\n        m, n = len(matrix), len(matrix[0])\\n        col0 = 1\\n        for i in range(m):\\n            if matrix[i][0] == 0:\\n                col0 = 0\\n            for j in range(1, n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n        # Use the information stored in the first row and first column to set the rest of the matrix to 0s\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, 0, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col0 == 0:\\n                matrix[i][0] = 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # Use the first row and first column to store information about the rest of the matrix\\n        # If matrix[i][j] is 0, set matrix[i][0] and matrix[0][j] to 0\\n        # Use a variable called col0 to store information about the first column\\n        m, n = len(matrix), len(matrix[0])\\n        col0 = 1\\n        for i in range(m):\\n            if matrix[i][0] == 0:\\n                col0 = 0\\n            for j in range(1, n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n        # Use the information stored in the first row and first column to set the rest of the matrix to 0s\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, 0, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col0 == 0:\\n                matrix[i][0] = 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902011,
                "title": "set-matrix-zeroes",
                "content": "class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int i,j;\\nint m=matrix.length;\\n //m indicates row\\nint n=matrix[0].length;\\n //n indicates column \\nint[][] arr=new int[m][n];\\n        for (i=0;i<m;i++)\\n            {\\n            for(j=0;j<n;j++){\\n  /* two loops required one for row traversal one for column traversal  */ \\n  arr[i][j]=matrix[i][j];\\n                }\\n            }\\n        for(i=0;i<m;i++)\\n            {\\n  for (j=0;j<n;j++)\\n      {\\n   if(arr[i][j]==0)\\n     func(i,j,matrix); \\n      } \\n    }\\n}\\npublic void func(int a,int b,int[][] matrix)\\n {                   for(int k=0;k<matrix\\n[0].length;k++)\\n     {\\n    matrix[a][k]=0; \\n    }\\nfor(int l=0;l<matrix. length;l++)\\n    {\\n    matrix[l][b]=0;\\n}\\n  }\\n   }                   \\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int i,j;\\nint m=matrix.length;\\n //m indicates row\\nint n=matrix[0].length;\\n //n indicates column \\nint[][] arr=new int[m][n];\\n        for (i=0;i<m;i++)\\n            {\\n            for(j=0;j<n;j++){\\n  /* two loops required one for row traversal one for column traversal  */ \\n  arr[i][j]=matrix[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2821742,
                "title": "my-o-mn-java-code-beats-100-submissions",
                "content": "# Intuition\\nThought of storing that zero in something then change all rows and column to zero accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public void makeRowZero(int[][] matrix, int row) {\\n        for (int i = 0; i < matrix[row].length; i++) {\\n            matrix[row][i] = 0;\\n        }\\n    }\\n\\n    public void makeColumnZero(int[][] matrix, int col) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            matrix[i][col] = 0;\\n        }\\n    }\\n\\n    public void setZeroes(int[][] matrix) {\\n        boolean[][] isZero = new boolean[matrix.length][matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    isZero[i][j] = true;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (isZero[i][j]) {\\n                    makeRowZero(matrix, i);\\n                    makeColumnZero(matrix, j);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n     public void makeRowZero(int[][] matrix, int row) {\\n        for (int i = 0; i < matrix[row].length; i++) {\\n            matrix[row][i] = 0;\\n        }\\n    }\\n\\n    public void makeColumnZero(int[][] matrix, int col) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            matrix[i][col] = 0;\\n        }\\n    }\\n\\n    public void setZeroes(int[][] matrix) {\\n        boolean[][] isZero = new boolean[matrix.length][matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    isZero[i][j] = true;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (isZero[i][j]) {\\n                    makeRowZero(matrix, i);\\n                    makeColumnZero(matrix, j);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818142,
                "title": "easy-java-solution-hashset",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> setRow = new HashSet<>();\\n        Set<Integer> setCol = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    setRow.add(i);\\n                    setCol.add(j);\\n                }\\n            }\\n        }\\n        for(int row : setRow){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[row][i] = 0;\\n            }\\n        }\\n        for(int col: setCol){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> setRow = new HashSet<>();\\n        Set<Integer> setCol = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    setRow.add(i);\\n                    setCol.add(j);\\n                }\\n            }\\n        }\\n        for(int row : setRow){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[row][i] = 0;\\n            }\\n        }\\n        for(int col: setCol){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807583,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tqueue<pair<int, int>>q;\\n\\t\\t\\t//vector<vector<int>>v(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\t\\t\\tfor(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<matrix[0].size(); j++){\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0){\\n\\t\\t\\t\\t\\t\\t//v[i][j]=1;\\n\\t\\t\\t\\t\\t\\tq.push({i, j});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint x=q.front().first, y=q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tint x1=x, x2=x, x3=x, x4=x, y1=y, y2=y, y3=y, y4=y;\\n\\t\\t\\t\\t//cout<<x<<\" \"<<y<<endl;\\n\\t\\t\\t\\tif(x1>0){\\n\\t\\t\\t\\t\\twhile(x1>0){\\n\\t\\t\\t\\t\\t\\t//v[x1-1][y1]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x1-1][y1]=0;\\n\\t\\t\\t\\t\\t\\tx1--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(x2<matrix.size()-1){\\n\\t\\t\\t\\t\\twhile(x2<matrix.size()-1){\\n\\t\\t\\t\\t\\t\\t//v[x2+1][y]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x2+1][y2]=0;\\n\\t\\t\\t\\t\\t\\tx2++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(y3>0){\\n\\t\\t\\t\\t\\twhile(y3>0){\\n\\t\\t\\t\\t\\t\\t//v[x3][y3-1]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x3][y3-1]=0;\\n\\t\\t\\t\\t\\t\\ty3--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(y4<matrix[0].size()-1){\\n\\t\\t\\t\\t\\twhile(y4<matrix[0].size()-1){\\n\\t\\t\\t\\t\\t\\t//v[x4][y4+1]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x4][y4+1]=0;\\n\\t\\t\\t\\t\\t\\ty4++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tqueue<pair<int, int>>q;\\n\\t\\t\\t//vector<vector<int>>v(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\t\\t\\tfor(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<matrix[0].size(); j++){\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0){\\n\\t\\t\\t\\t\\t\\t//v[i][j]=1;\\n\\t\\t\\t\\t\\t\\tq.push({i, j}",
                "codeTag": "Java"
            },
            {
                "id": 2689157,
                "title": "1-ms-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstRowZero = false;\\n            boolean firstColumnZero = false;\\n            for(int i=0; i<matrix.length; i++){\\n                if(matrix[i][0] == 0){\\n                    firstColumnZero = true;\\n                    break;\\n                }\\n            }\\n            for(int i=0; i<matrix[0].length; i++){\\n                if(matrix[0][i] == 0){\\n                    firstRowZero = true;\\n                    break;\\n                }\\n\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][j] == 0){\\n                        matrix[i][0] = 0;\\n                        matrix[0][j] = 0;\\n                    }\\n                }\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                        matrix[i][j] = 0;\\n                    }\\n                }\\n            }\\n            if(firstColumnZero){\\n                for(int i=0; i<matrix.length; i++)\\n                    matrix[i][0] = 0;\\n            }\\n            if(firstRowZero){\\n                for(int i=0; i<matrix[0].length; i++)\\n                    matrix[0][i] = 0;\\n            }\\n        }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstRowZero = false;\\n            boolean firstColumnZero = false;\\n            for(int i=0; i<matrix.length; i++){\\n                if(matrix[i][0] == 0){\\n                    firstColumnZero = true;\\n                    break;\\n                }\\n            }\\n            for(int i=0; i<matrix[0].length; i++){\\n                if(matrix[0][i] == 0){\\n                    firstRowZero = true;\\n                    break;\\n                }\\n\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][j] == 0){\\n                        matrix[i][0] = 0;\\n                        matrix[0][j] = 0;\\n                    }\\n                }\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                        matrix[i][j] = 0;\\n                    }\\n                }\\n            }\\n            if(firstColumnZero){\\n                for(int i=0; i<matrix.length; i++)\\n                    matrix[i][0] = 0;\\n            }\\n            if(firstRowZero){\\n                for(int i=0; i<matrix[0].length; i++)\\n                    matrix[0][i] = 0;\\n            }\\n        }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653405,
                "title": "java-solution-easy",
                "content": "```\\n\\t\\tArrayList<Integer>l1=new ArrayList<>();\\n        ArrayList<Integer>l2=new ArrayList<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    l1.add(i);\\n                    l2.add(j);\\n                }\\n            }\\n        }\\n        \\n        for(int i:l1){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i:l2){\\n            for(int j=0;j<matrix.length;j++){\\n                matrix[j][i]=0;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tArrayList<Integer>l1=new ArrayList<>();\\n        ArrayList<Integer>l2=new ArrayList<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    l1.add(i);\\n                    l2.add(j);\\n                }\\n            }\\n        }\\n        \\n        for(int i:l1){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i:l2){\\n            for(int j=0;j<matrix.length;j++){\\n                matrix[j][i]=0;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2562319,
                "title": "java-solution-brute-force",
                "content": "it is the brute force which is easy to understand \\n\\n\\t\\tclass Solution {\\n\\t\\t  public void setZeroes(int[][] matrix) {\\n\\t\\t\\tint R = matrix.length;\\n\\t\\t\\tint C = matrix[0].length;\\n\\t\\t\\tSet<Integer> rows = new HashSet<Integer>();\\n\\t\\t\\tSet<Integer> cols = new HashSet<Integer>();\\n\\n\\t\\t\\t// Essentially, we mark the rows and columns that are to be made zero\\n\\t\\t\\tfor (int i = 0; i < R; i++) {\\n\\t\\t\\t  for (int j = 0; j < C; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t  rows.add(i);\\n\\t\\t\\t\\t  cols.add(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Iterate over the array once again and using the rows and cols sets, update the elements.\\n\\t\\t\\tfor (int i = 0; i < R; i++) {\\n\\t\\t\\t  for (int j = 0; j < C; j++) {\\n\\t\\t\\t\\tif (rows.contains(i) || cols.contains(j)) {\\n\\t\\t\\t\\t  matrix[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\t\\t\\nif its relevant solution then plz upvote it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t  public void setZeroes(int[][] matrix) {\\n\\t\\t\\tint R = matrix.length;\\n\\t\\t\\tint C = matrix[0].length;\\n\\t\\t\\tSet<Integer> rows = new HashSet<Integer>();\\n\\t\\t\\tSet<Integer> cols = new HashSet<Integer>();\\n\\n\\t\\t\\t// Essentially, we mark the rows and columns that are to be made zero\\n\\t\\t\\tfor (int i = 0; i < R; i++) {\\n\\t\\t\\t  for (int j = 0; j < C; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t  rows.add(i);\\n\\t\\t\\t\\t  cols.add(j);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2437385,
                "title": "o-m-n-m-n-and-o-1-space-solution-using-randomization-approach",
                "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n           \\n      int k;\\n        bool ok=true;\\n        while(ok){\\n            \\n            ok=false;\\n            long long int p=(1LL<<32);\\n            \\n            k=(rand()%p)-(1<<31);\\n            \\n              for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==k){\\n                     \\n                     ok=true;\\n                     break;\\n                      \\n                 }\\n                \\n            }\\n                  \\n          }\\n            \\n        }\\n        \\n             for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==0){\\n                     \\n                     for(int jj=0;jj<arr[0].size();jj++){\\n                          if(arr[i][jj]){\\n                               arr[i][jj]=k; \\n                          }\\n                       \\n                     }\\n                     \\n                     for(int ii=0;ii<arr.size();ii++){\\n                              if(arr[ii][j]){\\n                               arr[ii][j]=k; \\n                          }\\n                     }\\n                      \\n                 }\\n                \\n            }\\n                  \\n          }\\n        \\n        \\n          for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==k){\\n                     \\n                    arr[i][j]=0;\\n                      \\n                 }\\n                \\n            }\\n                  \\n          }\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n           \\n      int k;\\n        bool ok=true;\\n        while(ok){\\n            \\n            ok=false;\\n            long long int p=(1LL<<32);\\n            \\n            k=(rand()%p)-(1<<31);\\n            \\n              for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==k){\\n                     \\n                     ok=true;\\n                     break;\\n                      \\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2399205,
                "title": "c-easy-explantion-set-matrix-zero",
                "content": "\\t// Traverse the matrix \\n\\t// Take two vector to mark the rows and column in which the entry is 0\\n\\t// finally mark matrix[i][j] is 0 if either of the row[i] or column[i] is 0  \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tint n=matrix.size();\\n\\t\\t\\tint m=matrix[0].size();\\n\\t\\t\\tvector<int>row(n,-1);\\n\\t\\t\\tvector<int>col(m,-1);\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\trow[i]=0; // marking that row in which element is zero\\n\\t\\t\\t\\t\\t\\tcol[j]=0; // marking that col in which element is x=zero\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(row[i]==0||col[j]==0)\\n\\t\\t\\t\\t\\t\\tmatrix[i][j]=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tint n=matrix.size();\\n\\t\\t\\tint m=matrix[0].size();\\n\\t\\t\\tvector<int>row(n,-1);\\n\\t\\t\\tvector<int>col(m,-1);\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\trow[i]=0; // marking that row in which element is zero\\n\\t\\t\\t\\t\\t\\tcol[j]=0; // marking that col in which element is x=zero\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2315182,
                "title": "c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rowZero;\\n        set<int> colZero;\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    rowZero.insert(i);\\n                    colZero.insert(j);\\n                }\\n            }\\n        }\\n        for(int rowIndex: rowZero){\\n            makeRowZero(matrix, rowIndex);\\n        }\\n        for(int colIndex: colZero){\\n           makeColZero(matrix, colIndex); \\n        }\\n        return;\\n        \\n    }\\n    private: void makeRowZero(vector<vector<int>>& matrix, int rindex){\\n        for(int i=0;i<matrix[0].size();i++){\\n          matrix[rindex][i]= 0;  \\n        }\\n    }\\n    private: void makeColZero(vector<vector<int>>& matrix, int cindex){\\n        for(int j=0;j<matrix.size();j++){\\n            matrix[j][cindex]=0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rowZero;\\n        set<int> colZero;\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    rowZero.insert(i);\\n                    colZero.insert(j);\\n                }\\n            }\\n        }\\n        for(int rowIndex: rowZero){\\n            makeRowZero(matrix, rowIndex);\\n        }\\n        for(int colIndex: colZero){\\n           makeColZero(matrix, colIndex); \\n        }\\n        return;\\n        \\n    }\\n    private: void makeRowZero(vector<vector<int>>& matrix, int rindex){\\n        for(int i=0;i<matrix[0].size();i++){\\n          matrix[rindex][i]= 0;  \\n        }\\n    }\\n    private: void makeColZero(vector<vector<int>>& matrix, int cindex){\\n        for(int j=0;j<matrix.size();j++){\\n            matrix[j][cindex]=0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250531,
                "title": "python-o-m-n-and-o-1-space-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n            \\n        n,m=len(matrix),len(matrix[0])\\n        col,row=False,False\\n        \\n    #check if first row and col has zero \\n    \\n        for i in range(n):\\n            if matrix[i][0]==0:col=True\\n        for i in range(m):\\n            if matrix[0][i]==0:row=True\\n                \\n    #if position has zero set first col and first row zero for that \\n    \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                if matrix[i][j]==0:\\n                    matrix[0][j]=matrix[i][0]=0\\n                    \\n    #for every zero in first col set zero for every postion on that row\\n    \\n        for i in range(1,n):\\n            if matrix[i][0]==0:\\n                for j in range(1,m):\\n                    matrix[i][j]=0\\n                \\n    #for every zero in first row set zero for every postion on that col\\n    \\n        for j in range(1,m):\\n            if matrix[0][j]==0:\\n                for i in range(1,n):\\n                     matrix[i][j]=0\\n                        \\n    # if any of the check is true change all postions to zero\\n\\n        if col:\\n            for i in range(n):\\n                matrix[i][0]=0\\n\\n        if row:\\n            for j in range(m):\\n                matrix[0][j]=0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n            \\n        n,m=len(matrix),len(matrix[0])\\n        col,row=False,False\\n        \\n    #check if first row and col has zero \\n    \\n        for i in range(n):\\n            if matrix[i][0]==0:col=True\\n        for i in range(m):\\n            if matrix[0][i]==0:row=True\\n                \\n    #if position has zero set first col and first row zero for that \\n    \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                if matrix[i][j]==0:\\n                    matrix[0][j]=matrix[i][0]=0\\n                    \\n    #for every zero in first col set zero for every postion on that row\\n    \\n        for i in range(1,n):\\n            if matrix[i][0]==0:\\n                for j in range(1,m):\\n                    matrix[i][j]=0\\n                \\n    #for every zero in first row set zero for every postion on that col\\n    \\n        for j in range(1,m):\\n            if matrix[0][j]==0:\\n                for i in range(1,n):\\n                     matrix[i][j]=0\\n                        \\n    # if any of the check is true change all postions to zero\\n\\n        if col:\\n            for i in range(n):\\n                matrix[i][0]=0\\n\\n        if row:\\n            for j in range(m):\\n                matrix[0][j]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197878,
                "title": "striversdesheet-set-matrix-zero-brute-better-optimal",
                "content": "**Brute Force**\\nT.C = O(n * m) * O(n * m) + O(n*m)\\nS.C = O(1)\\n```\\n#define INF 1e9\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            if(matrix[i][j]==0){\\n                for(int k=0;k<cols;k++){\\n                   if(matrix[i][k]!=0){\\n                       matrix[i][k]=INF;\\n                   }\\n                }\\n            }\\n             if(matrix[i][j]==0){\\n                for(int k=0;k<rows;k++){\\n                   if(matrix[k][j]!=0){\\n                       matrix[k][j]=INF;\\n                   }\\n                }\\n            }\\n           \\n        }\\n    }\\n        for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            \\n            if(matrix[i][j]==INF){\\n                matrix[i][j]=0;\\n            }\\n            \\n        }}\\n        \\n\\n    }\\n};\\n```\\n\\n**BETTER**\\nT.C = O(n * m) + 2 * O(n * m)\\nS.C =O(n) + O(m)\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> u;\\n        vector<int> v;\\n        int rowsize=matrix.size();\\n        int colsize=matrix[0].size();\\n        for(int i=0;i<rowsize;i++){\\n            for(int j=0;j<colsize;j++){\\n                if(matrix[i][j]==0){\\n                    u.push_back(i);\\n                    v.push_back(j);\\n                }\\n            }\\n        }\\n        for(int m=0;m<u.size();m++){\\n            for(int p=0;p<colsize;p++){\\n            matrix[u[m]][p]=0;\\n        }\\n        }\\n        for(int n=0;n<v.size();n++){\\n          for(int q=0;q<rowsize;q++){\\n            matrix[q][v[n]]=0;\\n        }\\n        }\\n        \\n    }\\n};\\n```\\n\\n**OPTIMAL**\\nT.C = O(n * m) + O(n * m)\\nS.C =O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                matrix[i][j] = 0;\\n        if (col0 == 0) matrix[i][0] = 0;\\n    }\\n    }\\n};\\n\\n```\\nDo Upvote if this is helpful.\\nIf you have any query,DM me on this instagram id (usually active there) - \"__asif18  (https://www.instagram.com/__asif18/?hl=en)\"\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\n#define INF 1e9\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            if(matrix[i][j]==0){\\n                for(int k=0;k<cols;k++){\\n                   if(matrix[i][k]!=0){\\n                       matrix[i][k]=INF;\\n                   }\\n                }\\n            }\\n             if(matrix[i][j]==0){\\n                for(int k=0;k<rows;k++){\\n                   if(matrix[k][j]!=0){\\n                       matrix[k][j]=INF;\\n                   }\\n                }\\n            }\\n           \\n        }\\n    }\\n        for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            \\n            if(matrix[i][j]==INF){\\n                matrix[i][j]=0;\\n            }\\n            \\n        }}\\n        \\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> u;\\n        vector<int> v;\\n        int rowsize=matrix.size();\\n        int colsize=matrix[0].size();\\n        for(int i=0;i<rowsize;i++){\\n            for(int j=0;j<colsize;j++){\\n                if(matrix[i][j]==0){\\n                    u.push_back(i);\\n                    v.push_back(j);\\n                }\\n            }\\n        }\\n        for(int m=0;m<u.size();m++){\\n            for(int p=0;p<colsize;p++){\\n            matrix[u[m]][p]=0;\\n        }\\n        }\\n        for(int n=0;n<v.size();n++){\\n          for(int q=0;q<rowsize;q++){\\n            matrix[q][v[n]]=0;\\n        }\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                matrix[i][j] = 0;\\n        if (col0 == 0) matrix[i][0] = 0;\\n    }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195609,
                "title": "100-optimal-solution-explained",
                "content": "Easy to understand, detailed solution with step by step explanation with all approaches Brute-Better-Optimal and code in multiple languages:\\n\\nhttps://codewithkartik.com/2022/05/16/set-matrix-zeroes-leetcode-73-solution\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you find the solution useful, means a lot.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2108834,
                "title": "c-solution-faster-than-100-with-o-1-space-complexity",
                "content": "**Please up vote if you like the solution**\\n#### **Brute Force**\\nAssuming all the elements in the matrix are non-negative. Traverse through the matrix and if you find an element with value 0, then change all the elements in its row and column to -1, except when an element is 0. The reason for not changing other elements to 0, but -1, is because that might affect other columns and rows. Now traverse through the matrix again and if an element is -1 change it to 0, which will be the answer.\\n\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\\nTime Complexity : O ((N * M) * (N + M))\\nSpace Complexity:O (1)\\n.\\n.\\n.\\n\\n#### **Better Approach**\\nTake two dummy array one of size of row and other of size of column.Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\\n\\nTime Complexity: O(N * M + N * M)\\nSpace Complexity: O(N)\\nP.S : Credit for code of brute force and bette approach goes to take you forward now you can see my optimal solution.\\n.\\n.\\n.\\n#### **Optimal Solution**\\nInstead of taking two separate dummy array,take first row and column of the matrix as the array for checking whether the particular column or row has the value 0 or not.\\n\\n```\\nclass Solution {\\npublic:\\n    // use first col and first row as extra array \\n    void setZeroes(vector<vector<int>>& m) {\\n        // make 2 variable for row and collumns\\n        int a = m.size(), b = m[0].size();\\n        // 2 variables to store if we need to mark first row and first column as zero also at the end\\n        int f1 = 1, f2 = 1;\\n        for(int i = 0; i < a; i++)\\n        {\\n            for(int j = 0; j < b; j++)\\n            {\\n                if(m[i][j] == 0)\\n                {\\n                    // if index=0 and it is in first row and first column than f1=0 and f2=0\\n                    if(i == 0) f1 = 0;\\n                    if(j == 0) f2 = 0;\\n                    // if m[i][j]=0 than mark ith index of first col 0 and jth index of first row 0\\n                    if(i != 0 and j != 0)\\n                    {\\n                        m[0][j] = 0;\\n                        m[i][0] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 1; i < a; i++)\\n        {\\n            // check in the first column if any elemnt mark as zero and if yes than mark that full row zero\\n            if(m[i][0] == 0)\\n            {\\n                for(int j = 1; j < b; j++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        for(int j = 1; j < b; j++)\\n        {\\n            // check in the first row if any elemnt mark as zero and if yes than mark that full column zero\\n            if(m[0][j] == 0)\\n            {\\n                for(int i = 1; i < a; i++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check if first row need to be mark as fully by zeros\\n        if(f1 == 0)\\n        {\\n            for(int j = 0; j < b; j++)\\n                {\\n                    m[0][j] = 0;\\n                }\\n        }\\n        // check if first colmn need to be mark as fully by zeros\\n        if(f2 == 0)\\n        {\\n            for(int j = 0; j < a; j++)\\n                {\\n                    m[j][0] = 0;\\n                }\\n        }\\n    }\\n};\\n```\\nTime Complexity: O(N * M )\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    // use first col and first row as extra array \\n    void setZeroes(vector<vector<int>>& m) {\\n        // make 2 variable for row and collumns\\n        int a = m.size(), b = m[0].size();\\n        // 2 variables to store if we need to mark first row and first column as zero also at the end\\n        int f1 = 1, f2 = 1;\\n        for(int i = 0; i < a; i++)\\n        {\\n            for(int j = 0; j < b; j++)\\n            {\\n                if(m[i][j] == 0)\\n                {\\n                    // if index=0 and it is in first row and first column than f1=0 and f2=0\\n                    if(i == 0) f1 = 0;\\n                    if(j == 0) f2 = 0;\\n                    // if m[i][j]=0 than mark ith index of first col 0 and jth index of first row 0\\n                    if(i != 0 and j != 0)\\n                    {\\n                        m[0][j] = 0;\\n                        m[i][0] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 1; i < a; i++)\\n        {\\n            // check in the first column if any elemnt mark as zero and if yes than mark that full row zero\\n            if(m[i][0] == 0)\\n            {\\n                for(int j = 1; j < b; j++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        for(int j = 1; j < b; j++)\\n        {\\n            // check in the first row if any elemnt mark as zero and if yes than mark that full column zero\\n            if(m[0][j] == 0)\\n            {\\n                for(int i = 1; i < a; i++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check if first row need to be mark as fully by zeros\\n        if(f1 == 0)\\n        {\\n            for(int j = 0; j < b; j++)\\n                {\\n                    m[0][j] = 0;\\n                }\\n        }\\n        // check if first colmn need to be mark as fully by zeros\\n        if(f2 == 0)\\n        {\\n            for(int j = 0; j < a; j++)\\n                {\\n                    m[j][0] = 0;\\n                }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103145,
                "title": "simple-python-solution",
                "content": "\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        a,b=len(matrix),len(matrix[0])\\n        first_col,first_row=False,False\\n        for i in range(a):\\n            if matrix[i][0]==0:\\n                first_col=True\\n        for j in range(b):\\n            if matrix[0][j]==0:\\n                first_row=True\\n        for i in range(1,a):\\n            for j in range(1,b):\\n                if matrix[i][j]==0:\\n                    matrix[i][0]=0\\n                    matrix[0][j]=0\\n        for i in range(1,a):\\n            if matrix[i][0]==0:\\n                for j in range(1,b):\\n                    matrix[i][j]=0\\n        for i in range(1,b):\\n            if matrix[0][i]==0:\\n                for j in range(1,a):\\n                    matrix[j][i]=0\\n        if first_col:\\n            for i in range(a):\\n                matrix[i][0]=0\\n        if first_row:\\n            for i in range(b):\\n                matrix[0][i]=0\\n        return matrix\\n                \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        a,b=len(matrix),len(matrix[0])\\n        first_col,first_row=False,False\\n        for i in range(a):\\n            if matrix[i][0]==0:\\n                first_col=True\\n        for j in range(b):\\n            if matrix[0][j]==0:\\n                first_row=True\\n        for i in range(1,a):\\n            for j in range(1,b):\\n                if matrix[i][j]==0:\\n                    matrix[i][0]=0\\n                    matrix[0][j]=0\\n        for i in range(1,a):\\n            if matrix[i][0]==0:\\n                for j in range(1,b):\\n                    matrix[i][j]=0\\n        for i in range(1,b):\\n            if matrix[0][i]==0:\\n                for j in range(1,a):\\n                    matrix[j][i]=0\\n        if first_col:\\n            for i in range(a):\\n                matrix[i][0]=0\\n        if first_row:\\n            for i in range(b):\\n                matrix[0][i]=0\\n        return matrix\\n                \\n        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1967511,
                "title": "c-optimized-solution-o-n-x-m-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                matrix[i][j] = 0;\\n        if (col0 == 0) matrix[i][0] = 0;\\n    }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1921825,
                "title": "o-n-2-solution-for-absolute-beginners",
                "content": "Here\\'s my solution, which is not the optimal but it will help you build the foundation of the problem statement. \\n\\nSo, in this solution I keep two Sets [rol and col ] this sets stores - **while traversing the entire matrix have I ever encountered a 0 in either the row or the col**. \\nIf yes, then store the index in the SET.\\n\\nNow, iterate again through the matrix and check if either the row or col has ever encountered a 0 in the past: \\n\\t- if yes\\n\\t\\t- Set the [i][j] to 0\\n\\n\\nPretty straight forward right. \\n\\nGetting this result from LC\\n\\nRuntime: 91 ms, faster than 77.97% of JavaScript online submissions for Set Matrix Zeroes.\\nMemory Usage: 44.4 MB, less than 90.74% of JavaScript online submissions for Set Matrix Zeroes.\\n\\nHere\\'s the code.\\n\\n```\\nvar setZeroes = function (matrix) {\\n  const row = new Set();\\n  const col = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        row.add(i);\\n        col.add(j);\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (row.has(i) || col.has(j)) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  return matrix;\\n};\\n```\\n\\nHope you can optimize this on your own and do upvote it helped.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar setZeroes = function (matrix) {\\n  const row = new Set();\\n  const col = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        row.add(i);\\n        col.add(j);\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (row.has(i) || col.has(j)) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893250,
                "title": "an-easy-approach-to-solve-set-matrix-zeroes-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int x=1;\\n        int y=1;\\n        \\n        for(int i=0; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                x=0;\\n        }\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                y=0;\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            for(int j=1; j<col; j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                for(int j=0; j<col; j++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        for(int j=1; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                for(int i=0; i<row; i++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        if(x==0)\\n        {\\n            for(int i=0; i<row; i++)\\n                matrix[i][0]=0;\\n        }\\n        \\n        if(y==0)\\n        {\\n            for(int j=0; j<col; j++)\\n                matrix[0][j]=0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int x=1;\\n        int y=1;\\n        \\n        for(int i=0; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                x=0;\\n        }\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                y=0;\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            for(int j=1; j<col; j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                for(int j=0; j<col; j++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        for(int j=1; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                for(int i=0; i<row; i++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        if(x==0)\\n        {\\n            for(int i=0; i<row; i++)\\n                matrix[i][0]=0;\\n        }\\n        \\n        if(y==0)\\n        {\\n            for(int j=0; j<col; j++)\\n                matrix[0][j]=0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860587,
                "title": "c-solution-by-using-o-n-space-to-record-indexes",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<pair<int,int>> v;\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(nums[i][j]==0){\\n                    v.push_back({i,j});\\n                    \\n                }\\n            }\\n        }\\n        for(auto it: v){\\n            int a=it.first;\\n            int b=it.second;\\n            for(int i=0;i<n;++i){\\n                nums[i][b]=0;\\n            }\\n            for(int i=0;i<m;++i){\\n                nums[a][i]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<pair<int,int>> v;\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(nums[i][j]==0){\\n                    v.push_back({i,j});\\n                    \\n                }\\n            }\\n        }\\n        for(auto it: v){\\n            int a=it.first;\\n            int b=it.second;\\n            for(int i=0;i<n;++i){\\n                nums[i][b]=0;\\n            }\\n            for(int i=0;i<m;++i){\\n                nums[a][i]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765705,
                "title": "set-matrix-to-zero-striver-s-sde-sheet-problem-no-1-brute-force",
                "content": "Python Solution \\nThis is a brute force based solution very helpful for beginners to understand\\nBasic Approach : \\n* **First**, checking the positions of zero and saving it in a new list\\n* **Second**, Just multiplying with 0 to update the values\\n\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        l=[]\\n        k=len(matrix)\\n        d=len(matrix[0])\\n        #LOOP FOR CHECKING THE POSITIONS OF ZERO\\n        for i in range(k):\\n            for j in range(d):\\n                if (matrix[i][j]==0):\\n                    l.append([i,j])\\n                    \\n        #LOOP FOR UPDATING THE MATRIX \\n        for h in range(len(l)):\\n            for p in range(d):\\n                matrix[l[h][0]][p]=matrix[l[h][0]][p] * 0 \\n            for g in range(k):\\n                matrix[g][l[h][1]]=matrix[g][l[h][1]]* 0 \\n        return matrix\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        l=[]\\n        k=len(matrix)\\n        d=len(matrix[0])\\n        #LOOP FOR CHECKING THE POSITIONS OF ZERO\\n        for i in range(k):\\n            for j in range(d):\\n                if (matrix[i][j]==0):\\n                    l.append([i,j])\\n                    \\n        #LOOP FOR UPDATING THE MATRIX \\n        for h in range(len(l)):\\n            for p in range(d):\\n                matrix[l[h][0]][p]=matrix[l[h][0]][p] * 0 \\n            for g in range(k):\\n                matrix[g][l[h][1]]=matrix[g][l[h][1]]* 0 \\n        return matrix\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727833,
                "title": "c-8ms-o-1-space-o-mn-time",
                "content": "# Gist of the solution\\n* Check if the 1st row and col contain any 0 or not if it does mark them zero.\\n* Iterate from 2nd row and col and mark all the top row/col element 0 if that row/col contains 0.\\n* now iterate over 1st col/row and mark all the elements in that row/col zero accordingly.\\n* now in the 1st step you stored the bool values of if the zero is present or not so according to that make the 1st row/col zero.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool row = false, col = false;\\n        \\n        for(int i=0; i<n; i++)\\n            if(matrix[i][0] == 0)\\n                col = true;\\n        \\n        for(int j=0; j<m; j++)\\n            if(matrix[0][j] == 0)\\n                row = true;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=1; j<m; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                //make the row zero\\n                for(int j=1;j<m;j++)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                for(int j=1; j<n; j++)\\n                {\\n                    matrix[j][i] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(col)\\n        {\\n            for(int i=0; i<n; i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0; i<m; i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool row = false, col = false;\\n        \\n        for(int i=0; i<n; i++)\\n            if(matrix[i][0] == 0)\\n                col = true;\\n        \\n        for(int j=0; j<m; j++)\\n            if(matrix[0][j] == 0)\\n                row = true;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=1; j<m; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                //make the row zero\\n                for(int j=1;j<m;j++)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                for(int j=1; j<n; j++)\\n                {\\n                    matrix[j][i] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(col)\\n        {\\n            for(int i=0; i<n; i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0; i<m; i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699059,
                "title": "easy-to-understand-in-c-matrix",
                "content": "class Solution {\\npublic:\\n\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<bool> row(m,false);\\n        vector<bool> col(n,false);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=true;\\n                    col[j]=true;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(row[i] || col[j]){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<bool> row(m,false);\\n        vector<bool> col(n,false);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=true;\\n                    col[j]=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1668009,
                "title": "brute-better-optimal-java-with-comments-0ms-faster-than-100-striver",
                "content": "1.BRUTE FORCE APPROACH\\nLINEARLY TRAVERSING CHECKING IF THERE IS A ZERO IF YES THEN MARKING WHOLE ROW AND COL ZERO\\n```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n            int n = arr.length;\\n            int m = arr[0].length;\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == 0) {\\n                              //FOR MARKING WHOLE ROW 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < m; a++) {\\n                                    if (arr[i][a] != 0) {\\n                                          arr[i][a] = Integer.MIN_VALUE;\\n                                    }\\n\\n                              }\\n                              //FOR MARKING WHOLE COLUMN 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < n; a++) {\\n                                    if (arr[a][j] != 0) {\\n                                          arr[a][j] = Integer.MIN_VALUE;\\n                                    }\\n                              }\\n                        }\\n                  }\\n            }\\n            //THEN AT LAST MARKING ZERO AT PLACES OF Integer.MIN_VALUE\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == Integer.MIN_VALUE) {\\n                              arr[i][j] = 0;\\n                        }\\n                  }\\n            }\\n      }\\n}\\n```\\n2.BETTER APPROACH\\nBY TAKING TWO DUMMY ARRAYS.\\n```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          //making two dummy array\\n          int row[] = new int[n];\\n          int col[] = new int[m];\\n          for(int i=0;i<n;i++)\\n          {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                     row[i]=-1;\\n                     col[j]=-1;\\n                  }\\n              }   \\n          }\\n          //upto this point we filled our dummy array with zero.\\n          //i.e. 2 1D dummay array bnae then traverse kra given array ko ,, then as soon as we encounter 0 then we will mark 0 at i index of dummay array row and mark 0 at jth index of dummay array col->> after traversing the whole array we will know if there is a zero in given row or col or not.\\n      \\n          //again traverse through given array and with help of 1D dummy arrays check for the particular index that if in any one of row or col arrays there is a zero marked if yes then mark that particular index zero in the given array and so on.\\n           for(int i=0;i<n;i++)\\n           {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(row[i]==-1 || col[j]==-1)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n           }\\n      }\\n  }\\n  ```\\n 3.OPTIMAL APPROACH \\nTHIS APPROACH IS SAME AS BETTER APPROACH BUT INSTEAD OF TAKING TWO DUMMY ARRAYS WE USE FIRST ROW AND COL OF GIVEN MATRIX FOR CALCULATING ANSWER.\\n```\\n  class Solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          \\n          int colo=1;\\n          //THIS VARIABLE IS FOR ENSURING THAT WE WILL NOT MARK A WHOLE ROW OR COL ZERO BCZ OF PRESENCE OF A ZERO IN DUMMY PART OF ARRAY AS IT WILL RUIN OUR ANSWER SO WE ARE ASSUMING THAT WE HAVE CHECKED FOR FIRST ROW AND COL AND THEN STARTED TRAVERSING FROM  INDEX (1,1).\\n          for(int i=0;i<n;i++)\\n          {\\n              if(arr[i][0]==0)\\n              {\\n                  colo=0;\\n              }\\n              for(int j=1;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                      //IF FOUND ZERO THEN MARKING 0 IN THE UPPERMOST AND LEFTMOST PART ZERO i.e. MARKING 0 IN DUMMY ARRAY WHICH IS PRESENT IN OUR GIVEN ARRAY.\\n                      arr[i][0]=arr[0][j]=0; \\n                  }\\n              }   \\n          }\\n\\n          //STARTING FROM BACK AS WE WOULD NOT THEN WE WILL UPDATE OUR DUMMY ARRAY FIRST WHICH WHICH RUIN OUR ANSWER\\n          //EVERYTHING ELSE IS SAME LIKE BETTER APPROACH.\\n          //ONLY COLO IS THERE WHICH ENSURES THAT WE WILL NOT MARK OUR A WHOLE ROW ZERO BCZ OF PRESENCE OF A ZERO IN OUR DUMMY ARRAY.\\n          for(int i=n-1;i>=0;i--)\\n          {\\n            //TRAVESING FROM BACK\\n              for(int j=m-1;j>=1;j--)\\n              {\\n                  if(arr[i][0]==0 || arr[0][j]==0)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n              //IF WE FOUNF ZERO IN OU FIRST COL THEN WE WILL WHOLE COL ZERO.\\n              if(colo==0)\\n              {\\n                  arr[i][0]=0;\\n              }\\n          }\\n      }\\n  }\\n  ```\\n  Give it a upvote if you like it :)",
                "solutionTags": [],
                "code": "```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n            int n = arr.length;\\n            int m = arr[0].length;\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == 0) {\\n                              //FOR MARKING WHOLE ROW 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < m; a++) {\\n                                    if (arr[i][a] != 0) {\\n                                          arr[i][a] = Integer.MIN_VALUE;\\n                                    }\\n\\n                              }\\n                              //FOR MARKING WHOLE COLUMN 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < n; a++) {\\n                                    if (arr[a][j] != 0) {\\n                                          arr[a][j] = Integer.MIN_VALUE;\\n                                    }\\n                              }\\n                        }\\n                  }\\n            }\\n            //THEN AT LAST MARKING ZERO AT PLACES OF Integer.MIN_VALUE\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == Integer.MIN_VALUE) {\\n                              arr[i][j] = 0;\\n                        }\\n                  }\\n            }\\n      }\\n}\\n```\n```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          //making two dummy array\\n          int row[] = new int[n];\\n          int col[] = new int[m];\\n          for(int i=0;i<n;i++)\\n          {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                     row[i]=-1;\\n                     col[j]=-1;\\n                  }\\n              }   \\n          }\\n          //upto this point we filled our dummy array with zero.\\n          //i.e. 2 1D dummay array bnae then traverse kra given array ko ,, then as soon as we encounter 0 then we will mark 0 at i index of dummay array row and mark 0 at jth index of dummay array col->> after traversing the whole array we will know if there is a zero in given row or col or not.\\n      \\n          //again traverse through given array and with help of 1D dummy arrays check for the particular index that if in any one of row or col arrays there is a zero marked if yes then mark that particular index zero in the given array and so on.\\n           for(int i=0;i<n;i++)\\n           {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(row[i]==-1 || col[j]==-1)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n           }\\n      }\\n  }\\n  ```\n```\\n  class Solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          \\n          int colo=1;\\n          //THIS VARIABLE IS FOR ENSURING THAT WE WILL NOT MARK A WHOLE ROW OR COL ZERO BCZ OF PRESENCE OF A ZERO IN DUMMY PART OF ARRAY AS IT WILL RUIN OUR ANSWER SO WE ARE ASSUMING THAT WE HAVE CHECKED FOR FIRST ROW AND COL AND THEN STARTED TRAVERSING FROM  INDEX (1,1).\\n          for(int i=0;i<n;i++)\\n          {\\n              if(arr[i][0]==0)\\n              {\\n                  colo=0;\\n              }\\n              for(int j=1;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                      //IF FOUND ZERO THEN MARKING 0 IN THE UPPERMOST AND LEFTMOST PART ZERO i.e. MARKING 0 IN DUMMY ARRAY WHICH IS PRESENT IN OUR GIVEN ARRAY.\\n                      arr[i][0]=arr[0][j]=0; \\n                  }\\n              }   \\n          }\\n\\n          //STARTING FROM BACK AS WE WOULD NOT THEN WE WILL UPDATE OUR DUMMY ARRAY FIRST WHICH WHICH RUIN OUR ANSWER\\n          //EVERYTHING ELSE IS SAME LIKE BETTER APPROACH.\\n          //ONLY COLO IS THERE WHICH ENSURES THAT WE WILL NOT MARK OUR A WHOLE ROW ZERO BCZ OF PRESENCE OF A ZERO IN OUR DUMMY ARRAY.\\n          for(int i=n-1;i>=0;i--)\\n          {\\n            //TRAVESING FROM BACK\\n              for(int j=m-1;j>=1;j--)\\n              {\\n                  if(arr[i][0]==0 || arr[0][j]==0)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n              //IF WE FOUNF ZERO IN OU FIRST COL THEN WE WILL WHOLE COL ZERO.\\n              if(colo==0)\\n              {\\n                  arr[i][0]=0;\\n              }\\n          }\\n      }\\n  }\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1607797,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        \\n        boolean ispresent = false;\\n        for(int i=0; i<matrix.length; i++){\\n            if (matrix[i][0] == 0) ispresent = true;\\n            for(int j=1; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        for(int i=matrix.length-1; i>=0; i--){\\n            for(int j = matrix[0].length-1; j>=1; j--){\\n                if(matrix[0][j] == 0 || matrix[i][0] == 0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if (ispresent) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        \\n        boolean ispresent = false;\\n        for(int i=0; i<matrix.length; i++){\\n            if (matrix[i][0] == 0) ispresent = true;\\n            for(int j=1; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        for(int i=matrix.length-1; i>=0; i--){\\n            for(int j = matrix[0].length-1; j>=1; j--){\\n                if(matrix[0][j] == 0 || matrix[i][0] == 0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if (ispresent) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603669,
                "title": "easy-cpp-solution-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row (matrix.size(), -1) ; \\n        vector<int> col (matrix[0].size(), -1); \\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0; j< matrix[0].size(); j ++){\\n                if(matrix[i][j] == 0){\\n                    row[i] = 0; \\n                    col[j] = 0; \\n                }\\n            }\\n        }\\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0 ; j < matrix[0].size(); j ++){\\n                if(row[i]  ==0 || col[j] ==0){\\n                      matrix[i][j] = 0 ; \\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row (matrix.size(), -1) ; \\n        vector<int> col (matrix[0].size(), -1); \\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0; j< matrix[0].size(); j ++){\\n                if(matrix[i][j] == 0){\\n                    row[i] = 0; \\n                    col[j] = 0; \\n                }\\n            }\\n        }\\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0 ; j < matrix[0].size(); j ++){\\n                if(row[i]  ==0 || col[j] ==0){\\n                      matrix[i][j] = 0 ; \\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585200,
                "title": "c-2-approaches-clean-self-explanatory-with-comments",
                "content": "Here I have discussed 2 Different approaches. The first one uses sets instead of maps and the Second one uses Constant Space.\\n___\\n**Approach 1: Two pass algo Using Set\\nTime: O(n^2logn), Space: O(max(n, m))**\\n**Runtime: 16ms\\nMemory: 13.5MB**\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return;\\n        int cols = matrix[0].size();\\n        set<int> row; // to keep track of row index with 0\\n        set<int> col; // to keep track of column index with 0\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row.insert(i); // insert row and column index to be set to zero in the respective sets\\n                    col.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(row.count(i) || col.count(j)) // if the current index is present in row or column, set it to zero\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }  \\n    }\\n};\\n```\\n____\\n**Approach 2: Constant space**\\n**Runtime: 4ms\\nMemory: 13.1MB**\\nLogic: Use the first column and first row, as an indicator.\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return ;\\n        int cols = matrix[0].size();\\n        bool FirstRow = false;\\n        bool FirstCol = false;\\n\\n        for(int i=0 ; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                if(matrix[i][j]==0) // set indicators of first row and col to 0\\n                {\\n                    if(i==0) FirstRow = true;\\n                    if(j==0) FirstCol = true;\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<rows; i++)\\n        {\\n            for(int j=1; j<cols; j++)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0) // if indicator was set to 0, set matrix[i][j] to 0\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(FirstRow) // if first row had a zero, reset the first col to 0\\n        {\\n            for(int i=0 ;i<cols;i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if(FirstCol) // if first column had a zero, reset the first row to 0\\n        {\\n            for(int i=0;i<rows;i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n____\\nPlease comment down if you find any mistakes/ improvements \\u270C.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return;\\n        int cols = matrix[0].size();\\n        set<int> row; // to keep track of row index with 0\\n        set<int> col; // to keep track of column index with 0\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row.insert(i); // insert row and column index to be set to zero in the respective sets\\n                    col.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(row.count(i) || col.count(j)) // if the current index is present in row or column, set it to zero\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return ;\\n        int cols = matrix[0].size();\\n        bool FirstRow = false;\\n        bool FirstCol = false;\\n\\n        for(int i=0 ; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                if(matrix[i][j]==0) // set indicators of first row and col to 0\\n                {\\n                    if(i==0) FirstRow = true;\\n                    if(j==0) FirstCol = true;\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<rows; i++)\\n        {\\n            for(int j=1; j<cols; j++)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0) // if indicator was set to 0, set matrix[i][j] to 0\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(FirstRow) // if first row had a zero, reset the first col to 0\\n        {\\n            for(int i=0 ;i<cols;i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if(FirstCol) // if first column had a zero, reset the first row to 0\\n        {\\n            for(int i=0;i<rows;i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538988,
                "title": "c-approach-with-0-n-and0-1-space-complexity",
                "content": "O(N) space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        unordered_map<int,int>row;\\n        unordered_map<int,int>col;\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(row.count(i)==1||col.count(j)==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\nO(1) space complexity\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        \\n        bool row=false;\\n        bool col=false;\\n       for(int i=0;i<matrix.size();i++)\\n        {\\n            if(matrix[i][0]==0)\\n            {\\n               col=true;\\n            \\n            }\\n         }   \\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[0][j]==0)\\n                {\\n                   \\n                    row=true;\\n                }\\n            }\\n        \\n        \\n        for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][j]==0) \\n               {\\n                   matrix[0][j]=0;\\n                   matrix[i][0]=0;\\n                  \\n                 \\n                   \\n               }\\n            }\\n        }\\n         for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][0]==0||matrix[0][j]==0)\\n               {\\n                  matrix[i][j]=0;\\n                 \\n               }\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0;i<matrix[0].size();i++)\\n            {\\n                matrix[0][i]=0;\\n            }\\n        }\\n        if(col)\\n        {\\n         for(int i=0;i<matrix.size();i++)\\n            {\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        unordered_map<int,int>row;\\n        unordered_map<int,int>col;\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(row.count(i)==1||col.count(j)==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        \\n        bool row=false;\\n        bool col=false;\\n       for(int i=0;i<matrix.size();i++)\\n        {\\n            if(matrix[i][0]==0)\\n            {\\n               col=true;\\n            \\n            }\\n         }   \\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[0][j]==0)\\n                {\\n                   \\n                    row=true;\\n                }\\n            }\\n        \\n        \\n        for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][j]==0) \\n               {\\n                   matrix[0][j]=0;\\n                   matrix[i][0]=0;\\n                  \\n                 \\n                   \\n               }\\n            }\\n        }\\n         for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][0]==0||matrix[0][j]==0)\\n               {\\n                  matrix[i][j]=0;\\n                 \\n               }\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0;i<matrix[0].size();i++)\\n            {\\n                matrix[0][i]=0;\\n            }\\n        }\\n        if(col)\\n        {\\n         for(int i=0;i<matrix.size();i++)\\n            {\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443826,
                "title": "python-o-1-space-two-pass-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        first_row = 0\\n        first_col = 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for row_i in range(m):\\n            for col_j in range(n):\\n                if matrix[row_i][col_j] == 0:\\n                    if row_i == 0:\\n                        first_row = 1\\n                    if col_j == 0:\\n                        first_col = 1\\n                    if row_i != 0 and col_j != 0:\\n                        # mark col_j has a zero\\n                        matrix[0][col_j] = 0\\n                        # mark row_i has a zero\\n                        matrix[row_i][0] = 0\\n        \\n        # set zero to rows         \\n        for row_i in range(1, m):\\n            if matrix[row_i][0] == 0:\\n                for col_j in range(n):\\n                    matrix[row_i][col_j] = 0\\n                    \\n        # set zero to columns         \\n        for col_j in range(1, n):\\n            if matrix[0][col_j] == 0:\\n                for row_i in range(m):\\n                    matrix[row_i][col_j] = 0\\n\\n        # set zero to first row\\n        if first_row == 1:\\n            for col_j in range(n):\\n                matrix[0][col_j] = 0\\n                \\n        # set zero to first column\\n        if first_col == 1:\\n            for row_i in range(m):\\n                matrix[row_i][0] = 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        first_row = 0\\n        first_col = 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for row_i in range(m):\\n            for col_j in range(n):\\n                if matrix[row_i][col_j] == 0:\\n                    if row_i == 0:\\n                        first_row = 1\\n                    if col_j == 0:\\n                        first_col = 1\\n                    if row_i != 0 and col_j != 0:\\n                        # mark col_j has a zero\\n                        matrix[0][col_j] = 0\\n                        # mark row_i has a zero\\n                        matrix[row_i][0] = 0\\n        \\n        # set zero to rows         \\n        for row_i in range(1, m):\\n            if matrix[row_i][0] == 0:\\n                for col_j in range(n):\\n                    matrix[row_i][col_j] = 0\\n                    \\n        # set zero to columns         \\n        for col_j in range(1, n):\\n            if matrix[0][col_j] == 0:\\n                for row_i in range(m):\\n                    matrix[row_i][col_j] = 0\\n\\n        # set zero to first row\\n        if first_row == 1:\\n            for col_j in range(n):\\n                matrix[0][col_j] = 0\\n                \\n        # set zero to first column\\n        if first_col == 1:\\n            for row_i in range(m):\\n                matrix[row_i][0] = 0\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568894,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1568426,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1717997,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1567435,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1910323,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1896295,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 2072155,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1957833,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1723363,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1880578,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1568894,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1568426,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1717997,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1567435,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1910323,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1896295,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 2072155,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1957833,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1723363,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1880578,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1722130,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 1751220,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2070767,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2049456,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2048904,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2045278,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2035724,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2022710,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2016559,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2006780,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 1977879,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1973443,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1970018,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1968123,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1968121,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1959245,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1941395,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1931791,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1930988,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1878406,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1832037,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1832036,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1830790,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1754123,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1753767,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1746384,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1743408,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1724739,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1710064,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1710042,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    }
]