[
    {
        "title": "Count Number of Maximum Bitwise-OR Subsets",
        "question_content": "Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\nThe bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).\n&nbsp;\nExample 1:\n\nInput: nums = [3,1]\nOutput: 2\nExplanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n- [3]\n- [3,1]\n\nExample 2:\n\nInput: nums = [2,2,2]\nOutput: 7\nExplanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.\n\nExample 3:\n\nInput: nums = [3,2,1,5]\nOutput: 6\nExplanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 16\n\t1 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 1525309,
                "title": "java-c-python-dp-solution",
                "content": "# **Intuition**\\nSimilar to knapsack problem,\\nbut use bitwise-or sum instead of math sum.\\n\\n# **Explanation**\\n`dp[sum]` means the number of subsets with bitwise-or `sum`.\\n<br>\\n\\n# **Complexity**\\nTime `O(mn)`, where `m = max(A)`\\nSpace `O(m)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countMaxOrSubsets(int[] A) {\\n        int max = 0, dp[] = new int[1 << 17];\\n        dp[0] = 1;\\n        for (int a : A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int max = 0, dp[1 << 17] = {1};\\n        for (int a: A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countMaxOrSubsets(self, A):\\n        dp = collections.Counter([0])\\n        for a in A:\\n            for k, v in dp.items():\\n                dp[k | a] += v\\n        return dp[max(dp)]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int countMaxOrSubsets(int[] A) {\\n        int max = 0, dp[] = new int[1 << 17];\\n        dp[0] = 1;\\n        for (int a : A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```\n```cpp\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int max = 0, dp[1 << 17] = {1};\\n        for (int a: A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```\n```py\\n    def countMaxOrSubsets(self, A):\\n        dp = collections.Counter([0])\\n        for a in A:\\n            for k, v in dp.items():\\n                dp[k | a] += v\\n        return dp[max(dp)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1525216,
                "title": "c-bitmask-dp",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Bitmask\\n\\n1. Compute `goal` which is the maximum possible bitwise OR of a subset of `nums`, i.e. the bitwise OR of all the numbers in `nums`. \\n2. Enumerate all non-empty subsets of `nums` using bitmask and compute the bitwise OR of each of them. Increment answer if the subset\\'s bitwise OR is the same as `goal`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N * N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int goal = 0, N = A.size(), ans = 0;\\n        for (int n : A) goal |= n;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            int x = 0;\\n            for (int i = 0; i < N; ++i) {\\n                if (m >> i & 1) x |= A[i];\\n            }\\n            if (x == goal) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nWe can use DP to reduce the time complexity at the cost of space complexity\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(2^N)\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int goal = 0, N = A.size(), ans = 0;\\n        vector<int> dp(1 << N);\\n        for (int n : A) goal |= n;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            int lowbit = m & -m;\\n            dp[m] = dp[m - lowbit] | A[__builtin_ctz(lowbit)];\\n            if (dp[m] == goal) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N * N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int goal = 0, N = A.size(), ans = 0;\\n        for (int n : A) goal |= n;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            int x = 0;\\n            for (int i = 0; i < N; ++i) {\\n                if (m >> i & 1) x |= A[i];\\n            }\\n            if (x == goal) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(2^N)\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int goal = 0, N = A.size(), ans = 0;\\n        vector<int> dp(1 << N);\\n        for (int n : A) goal |= n;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            int lowbit = m & -m;\\n            dp[m] = dp[m - lowbit] | A[__builtin_ctz(lowbit)];\\n            if (dp[m] == goal) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525211,
                "title": "java-beats-100",
                "content": "Intuition: Accumulate the maximum bitwise value from the array then apply the subset formula to accumulate all subsets that have that value.\\n\\n```\\nclass Solution {\\n    \\n    int res = 0, target = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        for (int num : nums)\\n            target |= num;\\n        \\n        dfs(nums, 0, 0);\\n        return res;\\n    }\\n    \\n    public void dfs(int[] nums, int idx, int mask) {\\n        if (mask == target) res++;\\n        \\n        for (int i = idx; i < nums.length; i++)\\n            dfs(nums, i + 1, mask | nums[i]);\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int res = 0, target = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        for (int num : nums)\\n            target |= num;\\n        \\n        dfs(nums, 0, 0);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1525215,
                "title": "java-subset-problem-beats-100",
                "content": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        \\n        subsets(nums, 0, 0);\\n        return count;\\n    }\\n    \\n    int count = 0;\\n    int maxOR = 0;\\n    \\n    private void subsets(int[] arr, int vidx, int OR){\\n        \\n        if(vidx == arr.length){\\n            \\n            if(OR == maxOR){\\n                count ++;\\n            }else if(OR > maxOR){\\n                count = 1;\\n                maxOR = OR;\\n            }\\n            \\n            return;\\n        }\\n        \\n        // include\\n        subsets(arr, vidx+1, OR | arr[vidx]);\\n        \\n        // exclude\\n        subsets(arr, vidx+1, OR);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        \\n        subsets(nums, 0, 0);\\n        return count;\\n    }\\n    \\n    int count = 0;\\n    int maxOR = 0;\\n    \\n    private void subsets(int[] arr, int vidx, int OR){\\n        \\n        if(vidx == arr.length){\\n            \\n            if(OR == maxOR){\\n                count ++;\\n            }else if(OR > maxOR){\\n                count = 1;\\n                maxOR = OR;\\n            }\\n            \\n            return;\\n        }\\n        \\n        // include\\n        subsets(arr, vidx+1, OR | arr[vidx]);\\n        \\n        // exclude\\n        subsets(arr, vidx+1, OR);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525206,
                "title": "simple-recursive-solution",
                "content": "**Maximum Bitwise-OR** is possible when we take **bitwise-or of all the numbers.**\\n\\nStep 1: Calculate the bitwise of all the numbers.\\nStep 2: Find all bitwise of all the possible subsets recursively.\\nStep 3: Simply compare the values of step 2 with step 1\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    int subset(vector<int> &nums, int i, int a,int b)\\n    {\\n        int ans =0;\\n        if(i<0)\\n            return 0;\\n        if(a == (b|nums[i]))\\n            ans =1;\\n        return ans + subset(nums,i-1,a,b) + subset(nums,i-1,a,b|nums[i]);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int a=0;\\n        \\n        for(auto i:nums)\\n        {\\n            a = a|i;\\n        }\\n        \\n        int ans = subset(nums,nums.size()-1,a,0);\\n            \\n        return ans ;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int subset(vector<int> &nums, int i, int a,int b)\\n    {\\n        int ans =0;\\n        if(i<0)\\n            return 0;\\n        if(a == (b|nums[i]))\\n            ans =1;\\n        return ans + subset(nums,i-1,a,b) + subset(nums,i-1,a,b|nums[i]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1525200,
                "title": "c-beginner-friendly-bitmask-checking-all-subsets",
                "content": "Feel free to comment \\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int i,j,max_possible_or=0,n=nums.size(),ans=0;\\n        \\n        //maximum possible or=or of all number in array\\n        for(i=0;i<n;i++)\\n        {\\n            max_possible_or=nums[i]|max_possible_or;\\n        }\\n        \\n        //checking all subset \\n        \\n        \\n        for(i=1;i<(1<<n);i++)\\n        {\\n            int p=0;\\n            for(j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    p=p|nums[j];\\n                }\\n            }\\n            //if xor of given subset is equal to maximum possible or\\n\\t\\t\\t\\n            if(p==max_possible_or)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int i,j,max_possible_or=0,n=nums.size(),ans=0;\\n        \\n        //maximum possible or=or of all number in array\\n        for(i=0;i<n;i++)\\n        {\\n            max_possible_or=nums[i]|max_possible_or;\\n        }\\n        \\n        //checking all subset \\n        \\n        \\n        for(i=1;i<(1<<n);i++)\\n        {\\n            int p=0;\\n            for(j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    p=p|nums[j];\\n                }\\n            }\\n            //if xor of given subset is equal to maximum possible or\\n\\t\\t\\t\\n            if(p==max_possible_or)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525225,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        target = reduce(or_, nums)\\n        \\n        @cache\\n        def fn(i, mask): \\n            \"\"\"Return number of subsets to get target.\"\"\"\\n            if mask == target: return 2**(len(nums)-i)\\n            if i == len(nums): return 0 \\n            return fn(i+1, mask | nums[i]) + fn(i+1, mask)\\n        \\n        return fn(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        target = reduce(or_, nums)\\n        \\n        @cache\\n        def fn(i, mask): \\n            \"\"\"Return number of subsets to get target.\"\"\"\\n            if mask == target: return 2**(len(nums)-i)\\n            if i == len(nums): return 0 \\n            return fn(i+1, mask | nums[i]) + fn(i+1, mask)\\n        \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525274,
                "title": "easy-c-solution-dp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    #define maxN 17\\n    #define maxM (1<<17)\\n\\n    int dp[maxN][maxM];\\n    bool v[maxN][maxM];\\n    int findCnt(vector<int> arr, int start, int curr, int n, int maxor)\\n{\\n    // Base case\\n    if (start == n) {\\n        return (curr == maxor);\\n    }\\n \\n    if (v[start][curr])\\n        return dp[start][curr];\\n \\n    // Setting the state as visited\\n    v[start][curr] = 1;\\n \\n    // adding the counts of including the current element and excluding the current element\\n    dp[start][curr]\\n        = findCnt(arr, start + 1, curr, n, maxor)\\n          + findCnt(arr, start + 1, (curr | arr[start]), n, maxor);\\n \\n    return dp[start][curr];\\n}\\n    \\nint OR(vector<int> data){\\n    int n = data.size();\\n    int mOR = 0;\\n    for (int i = 0; i < n; ++i) {\\n        mOR |= data[i];\\n    }\\n\\n    return mOR;\\n}\\n    \\n    int countMaxOrSubsets(vector<int>& arr) {\\n        int mor = OR(arr);\\n        return findCnt(arr,0,0,arr.size(),mor);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define maxN 17\\n    #define maxM (1<<17)\\n\\n    int dp[maxN][maxM];\\n    bool v[maxN][maxM];\\n    int findCnt(vector<int> arr, int start, int curr, int n, int maxor)\\n{\\n    // Base case\\n    if (start == n) {\\n        return (curr == maxor);\\n    }\\n \\n    if (v[start][curr])\\n        return dp[start][curr];\\n \\n    // Setting the state as visited\\n    v[start][curr] = 1;\\n \\n    // adding the counts of including the current element and excluding the current element\\n    dp[start][curr]\\n        = findCnt(arr, start + 1, curr, n, maxor)\\n          + findCnt(arr, start + 1, (curr | arr[start]), n, maxor);\\n \\n    return dp[start][curr];\\n}\\n    \\nint OR(vector<int> data){\\n    int n = data.size();\\n    int mOR = 0;\\n    for (int i = 0; i < n; ++i) {\\n        mOR |= data[i];\\n    }\\n\\n    return mOR;\\n}\\n    \\n    int countMaxOrSubsets(vector<int>& arr) {\\n        int mor = OR(arr);\\n        return findCnt(arr,0,0,arr.size(),mor);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659354,
                "title": "easiest-best-solution-in-c-o-1-sc",
                "content": "# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int count=0;\\n    void calculate(int ind, vector<int>& nums, int size, int bitOR, int x){\\n        if(ind==size){\\n            if(x==bitOR)\\n                count++;\\n            return;\\n        }\\n        calculate(ind+1, nums, size, bitOR, x | nums[ind]);\\n        calculate(ind+1, nums, size, bitOR, x);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int size=nums.size(),bitOR=0;\\n        for(auto it:nums)\\n            bitOR |= it;\\n        calculate(0, nums, size, bitOR, 0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    void calculate(int ind, vector<int>& nums, int size, int bitOR, int x){\\n        if(ind==size){\\n            if(x==bitOR)\\n                count++;\\n            return;\\n        }\\n        calculate(ind+1, nums, size, bitOR, x | nums[ind]);\\n        calculate(ind+1, nums, size, bitOR, x);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int size=nums.size(),bitOR=0;\\n        for(auto it:nums)\\n            bitOR |= it;\\n        calculate(0, nums, size, bitOR, 0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681134,
                "title": "optimized-c-approach-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe bitwise OR operation\\'s result always has ith bit set, whenever any one of the bits is set. Thus, the maximum possible value of the bitwise OR of any subset of array a is the bitwise OR of array a itself!\\nNow the question boils down to the simpler question of \\n\"Given a target t, find the number of subsets in array a whose bitwise OR is equal to t.\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the number of subsets, we can simply follow a two step approach.\\n1. Find the maximum bitwise OR of the array by simply traversing through the array and taking bitwise OR of every element. Store the result in target variable.\\n2. Now we use a Backtracking approach of finding the number of subsets by following the principle of  **\"Take and Not Take\"**.\\n\\n##### RECURSIVE FORMULATION:\\n **DEFINITION :** The function **f(idx, target)** denotes the count of **subsets ranging from index i to n-1** having bitwise OR equal to target\\n1. **Take** : f(idx+1,(curr | nums[idx]));\\n2. **Not Take** : f(idx+1,curr);\\n\\nWe have to take every possible subset into our consideration, therefore,\\n`return f(idx + 1,(curr | nums[idx])) + f(idx + 1,curr));`\\n\\n##### BASE CASE:\\nWe only have a single base case wherein, if we ever reach out of bound i.e., idx == n, then we are simply going to check one thing.\\n> if(curr == target)   return 1;\\n> else return 0;\\n\\nAlthough not in code, but we can simplify the code even further by replacing with a single line:\\n> return (target == curr);\\n\\nHowever, i am suspicious that replacing it might end up using some extra time but anyway :-)\\n\\n# Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n# EXPLANATION FOR TIME AND SPACE COMPLEXITY\\n\\n> **TIME COMPLEXITY** : At every index, we have two options, either to take it or not take it. Overall we have n indices (ranging from 0 to n-1), so the overall time taken would be [2 * 2 * ....... * 2] (for n times) => $$O(2^n)$$ \\n\\n\\n> **SPACE COMPLEXITY** : We are not using any extra space, just few variables and further more we have passed almost everything by reference (even target variable). The only thing left is the internal memory used in Stack Space of Recursion. Thus,  linear space complexity!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubsetsTarget(int idx,int curr,int const &target,vector<int> const &nums){\\n        if(idx == nums.size()){\\n            if(target == curr)\\n                return 1;\\n            return 0;\\n        }\\n        return (countSubsetsTarget(idx+1,(curr | nums[idx]),target,nums) + countSubsetsTarget(idx+1,curr,target,nums));\\n    }\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int target = 0;\\n        for(auto &x:nums)\\n            target |= x;\\n        return countSubsetsTarget(0,0,target,nums);\\n    }\\n};\\n```\\n\\n**Please Upvote if you liked it!**",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubsetsTarget(int idx,int curr,int const &target,vector<int> const &nums){\\n        if(idx == nums.size()){\\n            if(target == curr)\\n                return 1;\\n            return 0;\\n        }\\n        return (countSubsetsTarget(idx+1,(curr | nums[idx]),target,nums) + countSubsetsTarget(idx+1,curr,target,nums));\\n    }\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int target = 0;\\n        for(auto &x:nums)\\n            target |= x;\\n        return countSubsetsTarget(0,0,target,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795558,
                "title": "c-recursion",
                "content": "The **maximum OR value possible for any subset of an array is the OR of all values in the array!**\\nAfter calculating the maximum OR possible, we\\'ll find OR of all subsets & check if it is equal to maximum OR :\\n```\\nint recur(vector<int>&nums,int idx,int currOr,int maxOr){\\n        if(idx < 0){\\n            return currOr == maxOr;\\n        }\\n        return (\\n            recur(nums,idx-1,currOr,maxOr)                  // not-including element at \\'idx\\' in subset\\n            + recur(nums,idx-1,currOr | nums[idx],maxOr)    // including element at \\'idx\\' in subset\\n        );\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int maxOr = 0;\\n        for(auto num:nums){\\n            maxOr |= num;\\n        }\\n        \\n        return recur(nums,nums.size()-1,0,maxOr);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint recur(vector<int>&nums,int idx,int currOr,int maxOr){\\n        if(idx < 0){\\n            return currOr == maxOr;\\n        }\\n        return (\\n            recur(nums,idx-1,currOr,maxOr)                  // not-including element at \\'idx\\' in subset\\n            + recur(nums,idx-1,currOr | nums[idx],maxOr)    // including element at \\'idx\\' in subset\\n        );\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int maxOr = 0;\\n        for(auto num:nums){\\n            maxOr |= num;\\n        }\\n        \\n        return recur(nums,nums.size()-1,0,maxOr);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525389,
                "title": "c-easy-solution-with-explanation-beats-100-cpp-submission",
                "content": "The problem is another version of subset sum. Here, we need to calculate OR of every non empty subset instead of sum.\\n\\n*To generate all possible subset, each step we need to make two decisons. We will take this number to result or leave it. At the end, if at least one number is taken ( no empty subset ), we will check the sum.*\\n\\n**Time Complexity**: O(2^n) ( **Subset Sum problem using a backtracking approach which will take O(2^n)** ).\\n**Space Complexity**: O(1)\\n\\n\\n```\\nclass Solution {\\n    int maxSum;\\n    int maxSumCount;\\n    int length;\\n    \\n    void find(vector<int>& nums, int sum, int taken, int s) {\\n        if (s == length) {\\n            if (taken) {\\n                if (sum == maxSum) maxSumCount++;\\n                else if (sum > maxSum) {\\n                    maxSum = sum;\\n                    maxSumCount = 1;\\n                }\\n            }\\n            return;\\n        }\\n        find(nums, sum | nums[s], taken + 1, s + 1);\\n        find(nums, sum, taken, s + 1);\\n    }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        length = nums.size();\\n        maxSum = INT_MIN;\\n        maxSumCount = 0;\\n        \\n        find(nums, 0, 0, 0);\\n        return maxSumCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int maxSum;\\n    int maxSumCount;\\n    int length;\\n    \\n    void find(vector<int>& nums, int sum, int taken, int s) {\\n        if (s == length) {\\n            if (taken) {\\n                if (sum == maxSum) maxSumCount++;\\n                else if (sum > maxSum) {\\n                    maxSum = sum;\\n                    maxSumCount = 1;\\n                }\\n            }\\n            return;\\n        }\\n        find(nums, sum | nums[s], taken + 1, s + 1);\\n        find(nums, sum, taken, s + 1);\\n    }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        length = nums.size();\\n        maxSum = INT_MIN;\\n        maxSumCount = 0;\\n        \\n        find(nums, 0, 0, 0);\\n        return maxSumCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525311,
                "title": "c-simple-recursion-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        long long bitOr=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            bitOr|=nums[i];\\n        subsets(nums,0,0,bitOr);\\n        return count;\\n    }\\n    void subsets(vector<int>& nums,int i,int now,int bitOr)\\n    {\\n        if(i==nums.size())\\n            return;\\n       \\n        int t=now|nums[i];\\n        if(t==bitOr)\\n            count++;\\n        subsets(nums,i+1,t,bitOr);\\n        subsets(nums,i+1,now,bitOr);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        long long bitOr=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            bitOr|=nums[i];\\n        subsets(nums,0,0,bitOr);\\n        return count;\\n    }\\n    void subsets(vector<int>& nums,int i,int now,int bitOr)\\n    {\\n        if(i==nums.size())\\n            return;\\n       \\n        int t=now|nums[i];\\n        if(t==bitOr)\\n            count++;\\n        subsets(nums,i+1,t,bitOr);\\n        subsets(nums,i+1,now,bitOr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631165,
                "title": "brute-force-2-n-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int x,int k,vector<int> &v,int &ans){\\n        // if(x==k)ans++;\\n        if(i>=v.size()){ans += (x==k);return;}\\n        solve(i+1,x,k|v[i],v,ans);\\n        solve(i+1,x,k,v,ans);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n         int x = 0;\\n         for(auto &i: nums){\\n             x |= i;\\n         }\\n         int ans = 0;\\n         solve(0,x,0,nums,ans);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int x,int k,vector<int> &v,int &ans){\\n        // if(x==k)ans++;\\n        if(i>=v.size()){ans += (x==k);return;}\\n        solve(i+1,x,k|v[i],v,ans);\\n        solve(i+1,x,k,v,ans);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n         int x = 0;\\n         for(auto &i: nums){\\n             x |= i;\\n         }\\n         int ans = 0;\\n         solve(0,x,0,nums,ans);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768108,
                "title": "simple-solution-in-java",
                "content": "**Hints**\\n- The maximum bitwise-OR is the bitwise-OR of the whole array (max)\\n- Use bitwise operation to find all the possible subset of given array\\n- If max==the OR of subset, count++\\n```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0,tmp=0,count=0;\\n        //The maximum bitwise-OR is the bitwise-OR of the whole array\\n        for(int i=0;i<nums.length;i++){\\n            max=max|nums[i];\\n        }\\n        \\n        for(int i=0;i<(1<<nums.length);i++){\\n            tmp=0;\\n            for(int j=0;j<nums.length;j++){\\n                if((i&(1<<j))>0){\\n                    tmp=tmp|nums[j];\\n                }\\n            }\\n            if(tmp==max){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0,tmp=0,count=0;\\n        //The maximum bitwise-OR is the bitwise-OR of the whole array\\n        for(int i=0;i<nums.length;i++){\\n            max=max|nums[i];\\n        }\\n        \\n        for(int i=0;i<(1<<nums.length);i++){\\n            tmp=0;\\n            for(int j=0;j<nums.length;j++){\\n                if((i&(1<<j))>0){\\n                    tmp=tmp|nums[j];\\n                }\\n            }\\n            if(tmp==max){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532642,
                "title": "c-recursive-dp-solution",
                "content": "This Problem is similar to number of subset with given sum.\\nSo the basic approch is that pick one by one element and calculate the OR and check if it equal to resultant OR.\\nFirst try to write recursive code and then do the memorization to reduce the time complexity.\\n\\n``` \\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(int i, vector<int> a, int oor, int xoor) {\\n        if(i == a.size()) {\\n            if(oor == xoor) return 1;\\n            return 0;\\n        }\\n        if(dp[i][oor] != -1)    return dp[i][oor];\\n        dp[i][oor] = solve(i + 1, a, oor | a[i], xoor) + solve(i + 1, a, oor, xoor);\\n        return dp[i][oor];\\n    }\\n    int countMaxOrSubsets(vector<int>& a) {\\n        int all_or = 0;\\n        for(auto i : a) all_or |= i;\\n        dp = vector<vector<int>> (a.size() + 1, vector<int>(all_or + 1, -1));\\n        return solve(0, a, 0, all_or);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(int i, vector<int> a, int oor, int xoor) {\\n        if(i == a.size()) {\\n            if(oor == xoor) return 1;\\n            return 0;\\n        }\\n        if(dp[i][oor] != -1)    return dp[i][oor];\\n        dp[i][oor] = solve(i + 1, a, oor | a[i], xoor) + solve(i + 1, a, oor, xoor);\\n        return dp[i][oor];\\n    }\\n    int countMaxOrSubsets(vector<int>& a) {\\n        int all_or = 0;\\n        for(auto i : a) all_or |= i;\\n        dp = vector<vector<int>> (a.size() + 1, vector<int>(all_or + 1, -1));\\n        return solve(0, a, 0, all_or);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531090,
                "title": "java-dfs-with-pruning-beats-100",
                "content": "A simple DFS solution with prunig. Whenever `preSum` equals `sum`, there\\'s no need to do further recursion calls as all remaining combinations will satisfy the condition. So we can simply add `2^remainCount` will do.\\n\\n```java\\nclass Solution {\\n  int result;\\n  int sum;\\n  public int countMaxOrSubsets(int[] nums) {\\n    result = 0;\\n    sum = 0;\\n    for (int i : nums)\\n      sum |= i;\\n    dfs(0, nums, 0);\\n    return result;\\n  }\\n\\n  private void dfs(int presum, int[] nums, int idx) {\\n    if (presum == sum) {\\n      result += 1 << (nums.length - idx);\\n      return;\\n    }\\n    if (idx == nums.length)\\n      return;\\n    dfs(presum | nums[idx], nums, idx+1);\\n    dfs(presum, nums, idx+1);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  int result;\\n  int sum;\\n  public int countMaxOrSubsets(int[] nums) {\\n    result = 0;\\n    sum = 0;\\n    for (int i : nums)\\n      sum |= i;\\n    dfs(0, nums, 0);\\n    return result;\\n  }\\n\\n  private void dfs(int presum, int[] nums, int idx) {\\n    if (presum == sum) {\\n      result += 1 << (nums.length - idx);\\n      return;\\n    }\\n    if (idx == nums.length)\\n      return;\\n    dfs(presum | nums[idx], nums, idx+1);\\n    dfs(presum, nums, idx+1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525411,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(),ans=0,m = nums[0];\\n        for(int i=1;i<n;i++) m |= nums[i]; // Max-OR : OR of all elements\\n        int k = 1 << n;\\n        for(int i=0;i<k;i++){\\n            int j = i,c=0,l=0;\\n            while(j > 0){\\n                if(j&1){\\n                    c |= nums[l];\\n                }\\n                l++;\\n                j = j>>1;\\n            }\\n            if(c==m) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(),ans=0,m = nums[0];\\n        for(int i=1;i<n;i++) m |= nums[i]; // Max-OR : OR of all elements\\n        int k = 1 << n;\\n        for(int i=0;i<k;i++){\\n            int j = i,c=0,l=0;\\n            while(j > 0){\\n                if(j&1){\\n                    c |= nums[l];\\n                }\\n                l++;\\n                j = j>>1;\\n            }\\n            if(c==m) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307244,
                "title": "c-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int reach=0,res=0;\\n        for(auto x:nums){\\n            reach|=x;\\n        }\\n        auto Solve=[&](auto Solve,int ind,int val){\\n            if(val>67108864){\\n                return ;\\n            }\\n            if(val==reach){\\n                res++;\\n            }\\n            for(int i=ind;i<(int)nums.size();i++){\\n                Solve(Solve,i+1,val|nums[i]);\\n            }\\n        };\\n        Solve(Solve,0,0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int reach=0,res=0;\\n        for(auto x:nums){\\n            reach|=x;\\n        }\\n        auto Solve=[&](auto Solve,int ind,int val){\\n            if(val>67108864){\\n                return ;\\n            }\\n            if(val==reach){\\n                res++;\\n            }\\n            for(int i=ind;i<(int)nums.size();i++){\\n                Solve(Solve,i+1,val|nums[i]);\\n            }\\n        };\\n        Solve(Solve,0,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023645,
                "title": "java-solution-well-explained-easy-to-understand",
                "content": "Hi there ! \\nIdea of this solution could be devided on two parts \\n1. Using backtracking algorithm find all possible subsets. I would highly suggest to solve [```78. Subsets``` ](https://leetcode.com/problems/subsets/)first. \\n2. Use ArrayList to store current betwise OR of subset \\n\\n## Let\\'s take a look at this example\\n**Intput** : ```nums = [1,2,3]```\\nThis is what subsets of nums we will calculate on iteration if we just use the backtracking part\\n```[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]```\\nWhat we also want is to check on each iteration if subset bitwise or is matching maximum possible bitwise-OR\\n1. The maximum bitwise-OR is the bitwise-OR of the whole array. Store that value in ```max```\\n2. We also want to know what is current bitwise-OR of our subset . To do that I\\'m using arrayList ```curr``` Which is kind of like a mapping between subset and betwise-OR of that subset \\nExample: using this ```nums = [1,2,3]``` \\n```[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]``` -  all possible subsets\\n```[[],[1], [3], [3], [2], [3], [3]]``` - ```curr``` will look like that \\n```\\nclass Solution {\\n    int n; // length of nums\\n    int max; // max of betwise-OR of nums\\n    int result = 0; // result\\n    public int countMaxOrSubsets(int[] nums) {\\n        n = nums.length;\\n        max = nums[0]; \\n        for(int i = 1; i < nums.length; i++) //going through nums to find betwise-OR\\n            max = max | nums[i];\\n        backtrack(0,new ArrayList<>(),nums); // call magic function which go over all possible subsets of nums \\n        return result;\\n    }\\n        public void backtrack(int first, ArrayList<Integer> curr, int [] nums){\\n        if(curr.size() > 0 && curr.get(curr.size() - 1) == max) // checking if current betwise-OR  equal the maximum \\n            result++;\\n        for(int i = first; i < n; i++){\\n            if(curr.size() > 0) \\n                curr.add(nums[i] | curr.get(curr.size() - 1)); \\n            else\\n                curr.add(nums[i]);\\n            backtrack(i + 1, curr, nums);\\n\\t//I would highly suggest debug this code to understand how this \"remove\" part works \\n            curr.remove(curr.size() - 1); //important step we removing last element to maintain correct subset on the next iteration\\n        }\\n    }\\n\\n}\\n```\\n\\n## Optimized solution\\nOnce we nailed backtracking and how this useless ArrayList works we can come up with better solution (after looking at defferent solution at Discuss section)\\nIdea: \\n1. We could pass betwise-OR of subset as an argument in backtrack fucntion \\n```\\npublic class Solution {\\n    int count=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for(int i:nums)\\n            max = max | i;\\n        backtrack(nums,0,max, 0);\\n        return count;\\n    }\\n\\n    private void backtrack(int[] nums,int first,int max, int curr){\\n        if(max == curr)\\n            count++;\\n        if(first>=nums.length) return;\\n\\n        for(int i = first;i<nums.length;i++){\\n            backtrack(nums,i+1,max,curr|nums[i]);\\n        }\\n    }\\n}\\n```\\n**Please upvote if you find this solution helpfull.\\nThank you !**",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```78. Subsets```\n```nums = [1,2,3]```\n```[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]```\n```max```\n```curr```\n```nums = [1,2,3]```\n```[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]```\n```[[],[1], [3], [3], [2], [3], [3]]```\n```curr```\n```\\nclass Solution {\\n    int n; // length of nums\\n    int max; // max of betwise-OR of nums\\n    int result = 0; // result\\n    public int countMaxOrSubsets(int[] nums) {\\n        n = nums.length;\\n        max = nums[0]; \\n        for(int i = 1; i < nums.length; i++) //going through nums to find betwise-OR\\n            max = max | nums[i];\\n        backtrack(0,new ArrayList<>(),nums); // call magic function which go over all possible subsets of nums \\n        return result;\\n    }\\n        public void backtrack(int first, ArrayList<Integer> curr, int [] nums){\\n        if(curr.size() > 0 && curr.get(curr.size() - 1) == max) // checking if current betwise-OR  equal the maximum \\n            result++;\\n        for(int i = first; i < n; i++){\\n            if(curr.size() > 0) \\n                curr.add(nums[i] | curr.get(curr.size() - 1)); \\n            else\\n                curr.add(nums[i]);\\n            backtrack(i + 1, curr, nums);\\n\\t//I would highly suggest debug this code to understand how this \"remove\" part works \\n            curr.remove(curr.size() - 1); //important step we removing last element to maintain correct subset on the next iteration\\n        }\\n    }\\n\\n}\\n```\n```\\npublic class Solution {\\n    int count=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for(int i:nums)\\n            max = max | i;\\n        backtrack(nums,0,max, 0);\\n        return count;\\n    }\\n\\n    private void backtrack(int[] nums,int first,int max, int curr){\\n        if(max == curr)\\n            count++;\\n        if(first>=nums.length) return;\\n\\n        for(int i = first;i<nums.length;i++){\\n            backtrack(nums,i+1,max,curr|nums[i]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701379,
                "title": "c-2-solution-backtracking-dp-soln",
                "content": "# Backtracking Soln\\n```\\n\\tint res = 0;\\n    void back(vector<int>nums, int a, int idx, int curr) {\\n        if(curr==a) res+=1;\\n        for(int i=idx; i<nums.size(); i++) {\\n            back(nums, a, i+1, curr|nums[i]);\\n        }\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        long long a = nums[0];\\n        for(int i=1; i<nums.size(); i++) a |= nums[i];\\n        back(nums, a, 0, 0);\\n        return res;\\n    }\\n```\\n\\n# DP Soln\\n```\\n\\tint countMaxOrSubsets(vector<int>& A) {\\n        int max = 0;\\n\\t\\tint dp[1 << 17] = {1};\\n        for (int a: A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\n\\tint res = 0;\\n    void back(vector<int>nums, int a, int idx, int curr) {\\n        if(curr==a) res+=1;\\n        for(int i=idx; i<nums.size(); i++) {\\n            back(nums, a, i+1, curr|nums[i]);\\n        }\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        long long a = nums[0];\\n        for(int i=1; i<nums.size(); i++) a |= nums[i];\\n        back(nums, a, 0, 0);\\n        return res;\\n    }\\n```\n```\\n\\tint countMaxOrSubsets(vector<int>& A) {\\n        int max = 0;\\n\\t\\tint dp[1 << 17] = {1};\\n        for (int a: A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575826,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        def dfs(i,val):\\n            if maxBit == val : return 1<<(len(nums)-i)\\n            if i == len(nums): return 0\\n            return dfs(i+1,val|nums[i]) + dfs(i+1,val)\\n        maxBit = 0\\n        for i in nums: maxBit |= i\\n        return dfs(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        def dfs(i,val):\\n            if maxBit == val : return 1<<(len(nums)-i)\\n            if i == len(nums): return 0\\n            return dfs(i+1,val|nums[i]) + dfs(i+1,val)\\n        maxBit = 0\\n        for i in nums: maxBit |= i\\n        return dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525390,
                "title": "java-math-modified-backtracking-3ms-beat-100-after-sort-array-with-detailed-explanation",
                "content": "1. Find the maxOR num \\n2. Sort array for more efficient backtracking latter\\n3. Backtrack the array from the biggest number to smallest one(because the maxOR must be from the biggest one)\\n4. Say the sorted array is `[1,2,3,5]` and we start from the last element 5. when it goes to 2, the `existingOR` is already the maxOR (7 = 5 | 3). So the `remainingElementsNum`  is 2([1,2]).  Combination is C2-0(choose nothing from 2 elements) + C2-1 (choose 1 element from 2 elements) + C2-2(choose 2 from 2 elements) = `Math.pow(2, remainingElementsNum)` The result is `[5,3], [5,3,1], [5,3,2], [5,3,1,2]` . Backtracking(starts with 5) ends. Next round (starts with 3) starts..\\n\\nNotes (Math): Cn0 + Cn1 + Cn2 + ... CnN = 2^n, for n >= 1;\\n\\n\\n```\\n\\nclass Solution {\\n    private int result = 0;\\n    private int maxOR;\\n    private int[] nums;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        if(nums.length == 1){\\n            return 1;\\n        }\\n        \\n        this.nums = nums;\\n\\n\\t\\t// get maxOR \\n        maxOR = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            maxOR = maxOR | nums[i];\\n        }\\n        \\n        Arrays.sort(nums);\\n\\t\\t// Start from the biggest number\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            backtracking(nums[i], i - 1);\\n        }\\n\\t\\t\\n        return result;\\n    }\\n    \\n    private void backtracking(int existingOR, int index){\\n\\n\\t\\t// it means we can choose (0, 1, ... index + 1) number from the first (index + 1) elements\\n        if(existingOR == maxOR){\\n            int remainingElementsNum = index + 1;\\n            result += Math.pow(2, remainingElementsNum);\\n\\t\\t\\t// Backtracking ends here as we only need to know the combination size instead of the actual combination array\\n            return;\\n        }\\n\\t\\t\\n        for(int i = index; i >= 0; i--){\\n            backtracking(existingOR | nums[i], i - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution {\\n    private int result = 0;\\n    private int maxOR;\\n    private int[] nums;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        if(nums.length == 1){\\n            return 1;\\n        }\\n        \\n        this.nums = nums;\\n\\n\\t\\t// get maxOR \\n        maxOR = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            maxOR = maxOR | nums[i];\\n        }\\n        \\n        Arrays.sort(nums);\\n\\t\\t// Start from the biggest number\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            backtracking(nums[i], i - 1);\\n        }\\n\\t\\t\\n        return result;\\n    }\\n    \\n    private void backtracking(int existingOR, int index){\\n\\n\\t\\t// it means we can choose (0, 1, ... index + 1) number from the first (index + 1) elements\\n        if(existingOR == maxOR){\\n            int remainingElementsNum = index + 1;\\n            result += Math.pow(2, remainingElementsNum);\\n\\t\\t\\t// Backtracking ends here as we only need to know the combination size instead of the actual combination array\\n            return;\\n        }\\n\\t\\t\\n        for(int i = index; i >= 0; i--){\\n            backtracking(existingOR | nums[i], i - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525352,
                "title": "c-failed-approach-working-one",
                "content": "Code is correct but time complexity is high so below approach failed at last test case :(\\nHere we are generating every possible sub array and doing its OR in base condition.\\n```\\nclass Solution {\\npublic:\\n    int res=0, ans=INT_MIN;\\n    void solve(vector<int> input, vector<int> output)\\n    {\\n        if(input.size() == 0)\\n        {\\n            if(output.size() != 0)\\n            {\\n                int temp_ans = output[0];\\n                for(int i=0; i<output.size(); i++)  \\n                    temp_ans = (temp_ans|output[i]);            \\n                if(temp_ans == ans)\\n                    res++;\\n                if(temp_ans > ans)\\n                    ans = temp_ans;\\n            }\\n            return;\\n        }\\n        \\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);\\n    }\\n    int countMaxOrSubsets(vector<int>& arr) \\n    {\\n        solve(arr, {});\\n        return res+1;\\n    }\\n};\\n```\\nWorking Approach :\\nDoing the OR of entire array first that gives maximum OR and backtracking the array to check current OR == maximum OR\\n```\\nclass Solution {\\n    public:\\n\\tint res = 0;\\n\\tvoid solve(vector<int> &nums, int ind, int max, int curr)\\n\\t{\\n\\t\\tif(ind == nums.size())\\n\\t\\t{\\n\\t\\t\\tif(curr == max)\\n\\t\\t\\t\\tres++;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsolve(nums, ind+1, max,curr);\\n\\t\\tsolve(nums, ind+1, max, curr|nums[ind]);\\n\\t}\\n\\t\\n    int countMaxOrSubsets(vector<int> arr) \\n    {    \\n    \\tint max=0;\\n        for(int i=0; i<arr.size(); i++)\\n    \\t\\tmax = max|arr[i];\\n    \\tsolve(arr, 0, max, 0);\\n    \\treturn res;\\n    }\\n};\\n```\\n**Upvote if you like it**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0, ans=INT_MIN;\\n    void solve(vector<int> input, vector<int> output)\\n    {\\n        if(input.size() == 0)\\n        {\\n            if(output.size() != 0)\\n            {\\n                int temp_ans = output[0];\\n                for(int i=0; i<output.size(); i++)  \\n                    temp_ans = (temp_ans|output[i]);            \\n                if(temp_ans == ans)\\n                    res++;\\n                if(temp_ans > ans)\\n                    ans = temp_ans;\\n            }\\n            return;\\n        }\\n        \\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);\\n    }\\n    int countMaxOrSubsets(vector<int>& arr) \\n    {\\n        solve(arr, {});\\n        return res+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n\\tint res = 0;\\n\\tvoid solve(vector<int> &nums, int ind, int max, int curr)\\n\\t{\\n\\t\\tif(ind == nums.size())\\n\\t\\t{\\n\\t\\t\\tif(curr == max)\\n\\t\\t\\t\\tres++;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsolve(nums, ind+1, max,curr);\\n\\t\\tsolve(nums, ind+1, max, curr|nums[ind]);\\n\\t}\\n\\t\\n    int countMaxOrSubsets(vector<int> arr) \\n    {    \\n    \\tint max=0;\\n        for(int i=0; i<arr.size(); i++)\\n    \\t\\tmax = max|arr[i];\\n    \\tsolve(arr, 0, max, 0);\\n    \\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362662,
                "title": "easy-bit-manipulation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0;\\n        int n=nums.size();\\n        for(auto it:nums){\\n            x|=it;\\n        }\\n        int count=0;\\n        vector<int>arr;\\n        for(int i=0;i<(1<<n);i++){\\n            int y=0;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)){\\n                    y|=nums[j];\\n                }\\n            }\\n            if(y==x){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0;\\n        int n=nums.size();\\n        for(auto it:nums){\\n            x|=it;\\n        }\\n        int count=0;\\n        vector<int>arr;\\n        for(int i=0;i<(1<<n);i++){\\n            int y=0;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)){\\n                    y|=nums[j];\\n                }\\n            }\\n            if(y==x){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351532,
                "title": "bruter-force-2-n-solution-c-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    int x = 0;\\n    void solve(int s,int k,int &ans,vector<int> &nums){\\n        if(s>=nums.size()){\\n            if(k==x)\\n                ans++;\\n            return;\\n        }\\n        solve(s+1,k|nums[s],ans,nums);\\n        solve(s+1,k,ans,nums);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int ans = 0;\\n        x = 0;\\n        for(auto &i: nums)x |= i;\\n        solve(0,0,ans,nums);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int x = 0;\\n    void solve(int s,int k,int &ans,vector<int> &nums){\\n        if(s>=nums.size()){\\n            if(k==x)\\n                ans++;\\n            return;\\n        }\\n        solve(s+1,k|nums[s],ans,nums);\\n        solve(s+1,k,ans,nums);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int ans = 0;\\n        x = 0;\\n        for(auto &i: nums)x |= i;\\n        solve(0,0,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270953,
                "title": "c-backtracking-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void backtrack(vector<int> &nums,int target,int idx,int curr_xor)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            if(curr_xor==target)\\n            {\\n                ans++;\\n            }\\n            return ;\\n        }\\n        \\n        backtrack(nums,target,idx+1,curr_xor);\\n        backtrack(nums,target,idx+1,nums[idx]|curr_xor);\\n        \\n    }\\n    int countMaxOrSubsets(vector<int>& nums)\\n    {\\n        int target=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            target|=nums[i];\\n        }\\n        backtrack(nums,target,0,0);\\n        return ans;\\n\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    void backtrack(vector<int> &nums,int target,int idx,int curr_xor)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            if(curr_xor==target)\\n            {\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1676190,
                "title": "c-subsets-approach",
                "content": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n        int ans = 0, maxOr = INT_MIN;\\n        int limit = pow(2, nums.size());\\n        for(int i = 0; i < limit; i++) {\\n            int Or = 0;\\n            for(int j = 0; j < nums.size(); j++) { \\n\\t\\t\\t\\tif((i & (1 << j)) == 0) Or |= nums[j];\\n\\t\\t\\t}\\n            if(Or > maxOr) { maxOr = Or; ans = 1; } \\n\\t\\t\\telse if(Or == maxOr) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n        int ans = 0, maxOr = INT_MIN;\\n        int limit = pow(2, nums.size());\\n        for(int i = 0; i < limit; i++) {\\n            int Or = 0;\\n            for(int j = 0; j < nums.size(); j++) { \\n\\t\\t\\t\\tif((i & (1 << j)) == 0) Or |= nums[j];\\n\\t\\t\\t}\\n            if(Or > maxOr) { maxOr = Or; ans = 1; } \\n\\t\\t\\telse if(Or == maxOr) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1526221,
                "title": "c-simple-and-short-solution-no-recursion-faster-than-100",
                "content": "Very similar to https://leetcode.com/problems/subsets/discuss/1333022/C%2B%2B-Simple-and-Short-Solution-No-Recursion-0-ms-Faster-than-100\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int res = 0, mx_or = 0, curr, sz;\\n        vector<int> ors = {0};\\n        \\n        for (auto n : nums) mx_or |= n;\\n        \\n        for (auto num : nums) {\\n            sz = ors.size();\\n            \\n            for (int i = 0; i < sz; i++) {\\n                curr = ors[i] | num;\\n                ors.push_back(curr);\\n                if (curr == mx_or) res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int res = 0, mx_or = 0, curr, sz;\\n        vector<int> ors = {0};\\n        \\n        for (auto n : nums) mx_or |= n;\\n        \\n        for (auto num : nums) {\\n            sz = ors.size();\\n            \\n            for (int i = 0; i < sz; i++) {\\n                curr = ors[i] | num;\\n                ors.push_back(curr);\\n                if (curr == mx_or) res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525839,
                "title": "easy-c-solution-o-2-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int cnt[300005];\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int len=(1<<(int)nums.size());\\n        int ans=0;\\n        for(int i=0; i<len; i++) {\\n             int z=i,pos=0,orr=0;\\n             while(z) {\\n                if((z&1)==1) {\\n                    orr|=nums[pos]; \\n                }\\n                 pos++;\\n                 z>>=1;\\n             }\\n              cnt[orr]++;\\n              ans=max(ans,cnt[orr]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt[300005];\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int len=(1<<(int)nums.size());\\n        int ans=0;\\n        for(int i=0; i<len; i++) {\\n             int z=i,pos=0,orr=0;\\n             while(z) {\\n                if((z&1)==1) {\\n                    orr|=nums[pos]; \\n                }\\n                 pos++;\\n                 z>>=1;\\n             }\\n              cnt[orr]++;\\n              ans=max(ans,cnt[orr]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525686,
                "title": "python3-bitmask-dp",
                "content": "See more similar `bitmask dp` type questions here:  https://leetcode.com/discuss/general-discussion/1125779/Dynamic-programming-on-subsets-with-examples-explained\\n\\n``` py\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        dp = [-1] * (1<<N)\\n        dp[0] = 0\\n        for mask in range(1<<N):\\n            for j in range(N):\\n                if mask & (1<<j):\\n                    neib = dp[mask ^ (1<<j)]\\n                    dp[mask] = neib|nums[j]\\n        return dp.count(max(dp))\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "``` py\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        dp = [-1] * (1<<N)\\n        dp[0] = 0\\n        for mask in range(1<<N):\\n            for j in range(N):\\n                if mask & (1<<j):\\n                    neib = dp[mask ^ (1<<j)]\\n                    dp[mask] = neib|nums[j]\\n        return dp.count(max(dp))\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525361,
                "title": "100-fast-easy-python-solution-using-combinations-from-itertools",
                "content": "Combination returns tuples as output thats why make sure to convert it to list before append in a array because tuples does not supports OR Operation.\\n```\\nclass Solution:\\n    from itertools import combinations \\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        d = {}\\n        o = 0\\n        arr = []\\n        for i in range(1,len(nums)+1):\\n            comb = combinations(nums,i)\\n            for i in comb:\\n                arr.append(list(i))\\n        for i in arr:\\n            x = o|i[0]\\n            for j in i:\\n                x = x|j\\n            if x not in d:\\n                d[x] = 1\\n            else:\\n                d[x] += 1\\n        return d[max(d)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    from itertools import combinations \\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 1525249,
                "title": "c-2044-count-number-of-maximum-bitwise-or-subsets",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int target = 0, n = nums.size(); \\n        for (auto& x : nums) target |= x; \\n        \\n        map<pair<int, int>, int> memo; \\n        function<int(int, int)> fn = [&](int i, int mask) -> int {\\n            if (mask == target) return pow(2, n-i); \\n            if (i == n) return 0; \\n            if (memo.count({i, mask}) == 0) \\n                memo[{i, mask}] = fn(i+1, mask | nums[i]) + fn(i+1, mask); \\n            return memo[{i, mask}]; \\n        }; \\n        \\n        return fn(0, 0); \\n    }\\n};\\n```\\n\\nAdding a solution inspired by @lee215\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int most = 0; \\n        unordered_map<int, int> mp = {{0, 1}}; \\n        for (int x : nums) {\\n            most |= x; \\n            unordered_map<int, int> tmp = mp; \\n            for (auto& [k, v] : tmp) mp[x | k] += v; \\n        }\\n        return mp[most]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int target = 0, n = nums.size(); \\n        for (auto& x : nums) target |= x; \\n        \\n        map<pair<int, int>, int> memo; \\n        function<int(int, int)> fn = [&](int i, int mask) -> int {\\n            if (mask == target) return pow(2, n-i); \\n            if (i == n) return 0; \\n            if (memo.count({i, mask}) == 0) \\n                memo[{i, mask}] = fn(i+1, mask | nums[i]) + fn(i+1, mask); \\n            return memo[{i, mask}]; \\n        }; \\n        \\n        return fn(0, 0); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int most = 0; \\n        unordered_map<int, int> mp = {{0, 1}}; \\n        for (int x : nums) {\\n            most |= x; \\n            unordered_map<int, int> tmp = mp; \\n            for (auto& [k, v] : tmp) mp[x | k] += v; \\n        }\\n        return mp[most]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525155,
                "title": "c-dp-bitwise-o-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(), mx = 0, ans = 0;\\n        int dp[1 << 17]{};\\n        for (auto t : nums) mx |= t;\\n        for (int i = 1, j = 1; i < (1 << n); i++) {\\n            j += (i == (1 << j));\\n            dp[i] = dp[i ^ (1 << (j - 1))] | nums[j - 1];\\n            ans += dp[i] == mx;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(), mx = 0, ans = 0;\\n        int dp[1 << 17]{};\\n        for (auto t : nums) mx |= t;\\n        for (int i = 1, j = 1; i < (1 << n); i++) {\\n            j += (i == (1 << j));\\n            dp[i] = dp[i ^ (1 << (j - 1))] | nums[j - 1];\\n            ans += dp[i] == mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859702,
                "title": "similar-to-subset-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& a, int ind, int s, int t, vector<vector<int>> &v)\\n    {\\n        int n  = a.size();\\n        if(ind == n)\\n        {\\n           if(t == s)\\n               return 1;\\n            return 0;\\n        }\\n        \\n        if(v[ind][s] != -1)\\n            return v[ind][s];\\n        \\n        int in = solve(a,ind+1, s|a[ind],t,v);\\n        int out = solve(a,ind+1, s,t,v);\\n        \\n        return v[ind][s] = in+out;\\n        \\n        \\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& a) {\\n        \\n        int t = 0;\\n        for(auto h : a)\\n        {\\n            t|=h;\\n        }\\n        \\n        int n = a.size();\\n        \\n        vector<vector<int>> v(n, vector<int>(1000000,-1));\\n        \\n        int ans = solve(a,0,0,t,v);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& a, int ind, int s, int t, vector<vector<int>> &v)\\n    {\\n        int n  = a.size();\\n        if(ind == n)\\n        {\\n           if(t == s)\\n               return 1;\\n            return 0;\\n        }\\n        \\n        if(v[ind][s] != -1)\\n            return v[ind][s];\\n        \\n        int in = solve(a,ind+1, s|a[ind],t,v);\\n        int out = solve(a,ind+1, s,t,v);\\n        \\n        return v[ind][s] = in+out;\\n        \\n        \\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& a) {\\n        \\n        int t = 0;\\n        for(auto h : a)\\n        {\\n            t|=h;\\n        }\\n        \\n        int n = a.size();\\n        \\n        vector<vector<int>> v(n, vector<int>(1000000,-1));\\n        \\n        int ans = solve(a,0,0,t,v);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644425,
                "title": "simple-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet every possible sub sequence calculate frequency of each sequence, return freq of max value \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse through vector of int, at each position add and not add the number at position, when it reaches the end increase frequency of that value, and maintain a var to store max value. return the frequency of max value\\n\\n# Complexity\\n- Time complexity:O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you like it \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m; int ml = -1; \\n    void fun( vector<int> &nums, int val, int pos){\\n        if(nums.size() == pos) {if(ml < val) ml = val;   m[val]++; return; }\\n        fun(nums, val, pos+1); \\n       val  = val | nums[pos]; \\n        fun(nums, val, pos+1); \\n    }\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        fun(nums,0, 0 ); \\n\\n        return m[ml]; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m; int ml = -1; \\n    void fun( vector<int> &nums, int val, int pos){\\n        if(nums.size() == pos) {if(ml < val) ml = val;   m[val]++; return; }\\n        fun(nums, val, pos+1); \\n       val  = val | nums[pos]; \\n        fun(nums, val, pos+1); \\n    }\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        fun(nums,0, 0 ); \\n\\n        return m[ml]; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465235,
                "title": "count-number-of-maximum-bitwise-or-subsets-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void subsetsUtil(vector<int>& A, vector<vector<int> >& res,vector<int>& subset, int index)\\n    {\\n        res.push_back(subset);\\n        for (int i = index; i < A.size(); i++) {\\n            subset.push_back(A[i]);\\n            subsetsUtil(A, res, subset, i + 1);\\n            subset.pop_back();\\n        }\\n    \\n        return;\\n    }\\n\\n    vector<vector<int> > subsets(vector<int>& A)\\n    {\\n        vector<int> subset;\\n        vector<vector<int> > res;\\n        int index = 0;\\n        subsetsUtil(A, res, subset, index);\\n    \\n        return res;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int i, j, x_or=0, max=0, count=0;\\n        vector<vector<int> > res = subsets(nums);\\n        for(i=0 ; i<res.size() ; i++)\\n        {\\n            x_or = 0;\\n            for(j=0 ; j<res[i].size() ; j++)\\n            {\\n                x_or |=res[i][j];\\n            }\\n            if(x_or>max)\\n            {\\n                max = x_or;\\n                count=1;\\n            }\\n            else if(x_or==max)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n![upvote new.jpg](https://assets.leetcode.com/users/images/60790a23-b1a7-4d9f-9dc6-e76135ef408d_1682746923.505644.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subsetsUtil(vector<int>& A, vector<vector<int> >& res,vector<int>& subset, int index)\\n    {\\n        res.push_back(subset);\\n        for (int i = index; i < A.size(); i++) {\\n            subset.push_back(A[i]);\\n            subsetsUtil(A, res, subset, i + 1);\\n            subset.pop_back();\\n        }\\n    \\n        return;\\n    }\\n\\n    vector<vector<int> > subsets(vector<int>& A)\\n    {\\n        vector<int> subset;\\n        vector<vector<int> > res;\\n        int index = 0;\\n        subsetsUtil(A, res, subset, index);\\n    \\n        return res;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int i, j, x_or=0, max=0, count=0;\\n        vector<vector<int> > res = subsets(nums);\\n        for(i=0 ; i<res.size() ; i++)\\n        {\\n            x_or = 0;\\n            for(j=0 ; j<res[i].size() ; j++)\\n            {\\n                x_or |=res[i][j];\\n            }\\n            if(x_or>max)\\n            {\\n                max = x_or;\\n                count=1;\\n            }\\n            else if(x_or==max)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438499,
                "title": "easy-python-solution-using-recursion-and-backtracking",
                "content": "# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        def subs(idx,nums,N,lst,l):\\n            if idx>=N:\\n                val=0\\n                for i in lst:\\n                    val |= i\\n                l.append(val)\\n                return\\n            lst.append(nums[idx])\\n            subs(idx+1,nums,N,lst,l)\\n            lst.pop()\\n            subs(idx+1,nums,N,lst,l)\\n            return \\n            \\n        lst=[]\\n        l=[]\\n        subs(0,nums,len(nums),lst,l)\\n        cnt=Counter(l)\\n        return max([i for i in cnt.values()])\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        def subs(idx,nums,N,lst,l):\\n            if idx>=N:\\n                val=0\\n                for i in lst:\\n                    val |= i\\n                l.append(val)\\n                return\\n            lst.append(nums[idx])\\n            subs(idx+1,nums,N,lst,l)\\n            lst.pop()\\n            subs(idx+1,nums,N,lst,l)\\n            return \\n            \\n        lst=[]\\n        l=[]\\n        subs(0,nums,len(nums),lst,l)\\n        cnt=Counter(l)\\n        return max([i for i in cnt.values()])\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394402,
                "title": "hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport functools\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(int)\\n        for count in range(1,len(nums)+1):\\n            subsets = list(itertools.combinations(nums,count))\\n            for ele in subsets:\\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\\n        return mapping[max(mapping.keys())]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport functools\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(int)\\n        for count in range(1,len(nums)+1):\\n            subsets = list(itertools.combinations(nums,count))\\n            for ele in subsets:\\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\\n        return mapping[max(mapping.keys())]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254101,
                "title": "simple-recursion-solution-analogy-to-subsets-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere the intution is to caluclate ***OR*** val of each subset while generating them , and storing these values into a list.\\nAfter storing these values and finding out largest or value.\\n\\n# Code\\n```\\nclass Solution {\\n    List<Integer> or = new ArrayList<>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        helper(0,nums,0);\\n        Collections.sort(or,Collections.reverseOrder());\\n        int max = or.get(0);\\n        int answer = 0;\\n        for(Integer i:or){\\n            if(max==i) answer++;\\n            else break;\\n        }\\n        return answer;\\n    }\\n    public void helper(int index,int[] nums,int sum){\\n        if(index==nums.length){\\n            or.add(sum);\\n            return;\\n        }\\n        int val = (sum|nums[index]);\\n        helper(index+1,nums,val);\\n        helper(index+1,nums,sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> or = new ArrayList<>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        helper(0,nums,0);\\n        Collections.sort(or,Collections.reverseOrder());\\n        int max = or.get(0);\\n        int answer = 0;\\n        for(Integer i:or){\\n            if(max==i) answer++;\\n            else break;\\n        }\\n        return answer;\\n    }\\n    public void helper(int index,int[] nums,int sum){\\n        if(index==nums.length){\\n            or.add(sum);\\n            return;\\n        }\\n        int val = (sum|nums[index]);\\n        helper(index+1,nums,val);\\n        helper(index+1,nums,sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969014,
                "title": "efficient-javascript-backtracking-built-on-90-subsets-problem",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst countMaxOrSubsets = (nums) => {\\n  // Calculate the maximum bitwise OR of nums\\n  const maxOR = nums.reduce((a, b) => a | b, 0);\\n\\n  let result = 0;\\n\\n  // generate all subsets of nums\\n  const backtrack = (nums, start, subset) => {\\n    // If the current subset has a bitwise OR equal to the maximum bitwise OR, increment the result\\n    if (subset.length) {\\n        const subsetOR = subset.reduce((a, b) => a | b, 0);\\n        if (subsetOR === maxOR) {\\n            result++;\\n        }\\n    }\\n\\n    for (let i = start; i < nums.length; i++) {\\n      subset.push(nums[i]);\\n      backtrack(nums, i + 1, subset);\\n      subset.pop();\\n    }\\n  }\\n\\n  // Start the backtracking with an empty subset\\n  backtrack(nums, 0, []);\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst countMaxOrSubsets = (nums) => {\\n  // Calculate the maximum bitwise OR of nums\\n  const maxOR = nums.reduce((a, b) => a | b, 0);\\n\\n  let result = 0;\\n\\n  // generate all subsets of nums\\n  const backtrack = (nums, start, subset) => {\\n    // If the current subset has a bitwise OR equal to the maximum bitwise OR, increment the result\\n    if (subset.length) {\\n        const subsetOR = subset.reduce((a, b) => a | b, 0);\\n        if (subsetOR === maxOR) {\\n            result++;\\n        }\\n    }\\n\\n    for (let i = start; i < nums.length; i++) {\\n      subset.push(nums[i]);\\n      backtrack(nums, i + 1, subset);\\n      subset.pop();\\n    }\\n  }\\n\\n  // Start the backtracking with an empty subset\\n  backtrack(nums, 0, []);\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715609,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int val;\\n    map<int,int>mp;\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {   \\n         val=INT_MIN;\\n         int idx=0;\\n         fun(nums,idx,0);\\n         return mp[val];\\n    }\\n    void fun(vector<int>&nums,int idx,int ele)\\n    {\\n        if(idx >= nums.size())\\n        {\\n            val=max(val,ele);\\n            mp[ele]++;\\n            return;\\n        }\\n        fun(nums,idx+1,ele|nums[idx]);\\n        fun(nums,idx+1,ele);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int val;\\n    map<int,int>mp;\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {   \\n         val=INT_MIN;\\n         int idx=0;\\n         fun(nums,idx,0);\\n         return mp[val];\\n    }\\n    void fun(vector<int>&nums,int idx,int ele)\\n    {\\n        if(idx >= nums.size())\\n        {\\n            val=max(val,ele);\\n            mp[ele]++;\\n            return;\\n        }\\n        fun(nums,idx+1,ele|nums[idx]);\\n        fun(nums,idx+1,ele);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583743,
                "title": "c-bit-manipulation-backtracking-recursion",
                "content": "\\n__Algorithm__\\n\\n- Here we will first find the max OR => which is the OR of the whole array( maxOr)\\n\\n- Now in an subarray with OR of that array == maxOr an element with index i may or may not be present so we will use recursion \\n\\n- Here we will run recursion for when an element is in that subarray and then when that element is not in that subarray \\n\\n- At the end when all elements have been covered we will check is the OR == maxOR and increment answer accordingly\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(int currIndex , vector<int>& nums , int maxOr , int currOr , int& ans){\\n        if(currIndex == nums.size()){\\n            if(currOr == maxOr) ans++;\\n            return;\\n        }\\n        \\n        helper(currIndex+1 , nums , maxOr , currOr , ans);\\n        helper(currIndex+1 , nums , maxOr , currOr|nums[currIndex] , ans);\\n\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0 , ans = 0 ; for(auto a : nums) maxOr |= a;\\n        helper(0 , nums , maxOr , 0 , ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int currIndex , vector<int>& nums , int maxOr , int currOr , int& ans){\\n        if(currIndex == nums.size()){\\n            if(currOr == maxOr) ans++;\\n            return;\\n        }\\n        \\n        helper(currIndex+1 , nums , maxOr , currOr , ans);\\n        helper(currIndex+1 , nums , maxOr , currOr|nums[currIndex] , ans);\\n\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0 , ans = 0 ; for(auto a : nums) maxOr |= a;\\n        helper(0 , nums , maxOr , 0 , ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562376,
                "title": "java-solution-o-n-memory-87-better-no-extra-arrays-lists-used-explanation",
                "content": "\\n\\n```\\nclass Solution {\\n    \\n    static int count;\\n    static int max;\\n    static int[] arr;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        count = 0;\\n        max = 0;\\n        arr = nums;\\n\\t\\t//find max OR value\\n        for (int i = 0; i < nums.length; i++) {\\n            max |= nums[i];\\n        }\\n\\t\\t//starting calculating OR from different numbers\\n        for (int i = 0; i < nums.length; i++) {\\n            findCount(i, 0);\\n        }\\n        return count;\\n    }\\n    \\n    private void findCount(int idxStart, int orResult) {\\n\\t\\t//base condition\\n        if (idxStart >= arr.length) return;\\n\\t\\t\\n        orResult |= arr[idxStart];\\n\\t\\t\\n        if (orResult == max) {\\n            count++;\\n        }\\n        //recursively calculating OR for a sequence until we reach idx\\n        for (int i = idxStart + 1; i < arr.length; i++) {\\n            findCount(i, orResult);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    static int count;\\n    static int max;\\n    static int[] arr;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        count = 0;\\n        max = 0;\\n        arr = nums;\\n\\t\\t//find max OR value\\n        for (int i = 0; i < nums.length; i++) {\\n            max |= nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2446761,
                "title": "python3-solved-using-recursion-backtracking",
                "content": "```\\nclass Solution:\\n    #Let n = len(nums) array!\\n    #Time-Complexity: O(n * 2^n), since we make 2^n rec. calls to generate\\n    #all 2^n different subsets and for each rec. call, we call helper function that\\n    #computes Bitwise Or Lienarly!\\n    #Space-Complexity: O(n), since max stack depth is n!\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        \\n        \\n        #helper function!\\n        def calculate_BWOR(arr):\\n            if(len(arr) == 1):\\n                return arr[0]\\n            else:\\n                n = len(arr)\\n                res = arr[0]\\n                for i in range(1, n):\\n                    #take the bitwise or operation on two integers: ans and i!\\n                    res = res | arr[i]\\n                return res\\n                    \\n        \\n        \\n        \\n        \\n        #Approach: Utilize backtracking to generate all possible subsets!\\n        #Even if two sets contain same elements, it can be considered different\\n        #if we choose elements of differing indices!\\n        \\n        #I can keep track in answer all of the subset(s) that posseses the maximum\\n        #bitwise or!\\n        \\n        #At the end, I simply have to return number of subsets in answer!\\n        \\n        ans = []\\n        n = len(nums)\\n        #since the range of integers in input array nums is at least 1,\\n        #I will initialize maximum bitwise or value to 1!\\n        maximum = 1\\n        #parameters: i -> index that we are considering from\\n        #cur -> array of elements in current subset we built up so far!\\n        def helper(i, cur):\\n            nonlocal nums, ans, maximum, n\\n            #base case -> if index i == n and current subset is not None, we know we made             #decision to include or not include for each and every of the n elements!\\n            if(i == n):\\n                if(not cur):\\n                    return\\n                #once we hit base case, get the bitwise or of cur and compare\\n                #against max!\\n                #1. If it matches max, add it to ans!\\n                #2. If it beats current max, update maximum and update ans to\\n                #have only cur element!\\n                #3. Otherwise, ignore!\\n                current = calculate_BWOR(cur)\\n                if(current > maximum):\\n                    maximum = current\\n                    #make sure to add deep copy!\\n                    ans = [cur[::]]\\n                    return\\n                elif(current == maximum):\\n                    #make sure to add deep copy! Contents of cur might change\\n                    #as we return to parent rec. call from current call to helper!\\n                    ans.append(cur[::])\\n                    return\\n                else:\\n                    return\\n            #if it\\'s not the base case, we have to make 2 rec. calls!\\n            cur.append(nums[i])\\n            helper(i+1, cur)\\n            #once the prev. rec.call finishes, we generated all subsets that\\n            #does contain nums[i]!\\n            \\n            cur.pop()\\n            #this rec. call generates all subsets that do not contain nums[i]\\n            helper(i+1, cur)\\n        \\n        helper(0, [])\\n        return len(ans)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    #Let n = len(nums) array!\\n    #Time-Complexity: O(n * 2^n), since we make 2^n rec. calls to generate\\n    #all 2^n different subsets and for each rec. call, we call helper function that\\n    #computes Bitwise Or Lienarly!\\n    #Space-Complexity: O(n), since max stack depth is n!\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        \\n        \\n        #helper function!\\n        def calculate_BWOR(arr):\\n            if(len(arr) == 1):\\n                return arr[0]\\n            else:\\n                n = len(arr)\\n                res = arr[0]\\n                for i in range(1, n):\\n                    #take the bitwise or operation on two integers: ans and i!\\n                    res = res | arr[i]\\n                return res\\n                    \\n        \\n        \\n        \\n        \\n        #Approach: Utilize backtracking to generate all possible subsets!\\n        #Even if two sets contain same elements, it can be considered different\\n        #if we choose elements of differing indices!\\n        \\n        #I can keep track in answer all of the subset(s) that posseses the maximum\\n        #bitwise or!\\n        \\n        #At the end, I simply have to return number of subsets in answer!\\n        \\n        ans = []\\n        n = len(nums)\\n        #since the range of integers in input array nums is at least 1,\\n        #I will initialize maximum bitwise or value to 1!\\n        maximum = 1\\n        #parameters: i -> index that we are considering from\\n        #cur -> array of elements in current subset we built up so far!\\n        def helper(i, cur):\\n            nonlocal nums, ans, maximum, n\\n            #base case -> if index i == n and current subset is not None, we know we made             #decision to include or not include for each and every of the n elements!\\n            if(i == n):\\n                if(not cur):\\n                    return\\n                #once we hit base case, get the bitwise or of cur and compare\\n                #against max!\\n                #1. If it matches max, add it to ans!\\n                #2. If it beats current max, update maximum and update ans to\\n                #have only cur element!\\n                #3. Otherwise, ignore!\\n                current = calculate_BWOR(cur)\\n                if(current > maximum):\\n                    maximum = current\\n                    #make sure to add deep copy!\\n                    ans = [cur[::]]\\n                    return\\n                elif(current == maximum):\\n                    #make sure to add deep copy! Contents of cur might change\\n                    #as we return to parent rec. call from current call to helper!\\n                    ans.append(cur[::])\\n                    return\\n                else:\\n                    return\\n            #if it\\'s not the base case, we have to make 2 rec. calls!\\n            cur.append(nums[i])\\n            helper(i+1, cur)\\n            #once the prev. rec.call finishes, we generated all subsets that\\n            #does contain nums[i]!\\n            \\n            cur.pop()\\n            #this rec. call generates all subsets that do not contain nums[i]\\n            helper(i+1, cur)\\n        \\n        helper(0, [])\\n        return len(ans)",
                "codeTag": "Java"
            },
            {
                "id": 2405609,
                "title": "java-simple-recursive-solution",
                "content": "```\\nclass Solution \\n{\\n    int count=0;\\n    int MaxOR=0;\\n    private void findSubsets(int ind,List<Integer> ds,int[] arr,int currentOR)\\n    {\\n        if(ind==arr.length)\\n        {\\n            if(currentOR>MaxOR)\\n            {\\n                MaxOR=currentOR;\\n                count=0;\\n            }\\n            else if(currentOR==MaxOR)\\n                count++;\\n            return;\\n        }\\n        ds.add(arr[ind]);\\n        findSubsets(ind+1,ds,arr,currentOR|arr[ind]);\\n        ds.remove(ds.size()-1);\\n        findSubsets(ind+1,ds,arr,currentOR);\\n    }\\n    public int countMaxOrSubsets(int[] nums) \\n    {\\n        findSubsets(0,new ArrayList<>(),nums,0);\\n        return count+1;//+1 for first element\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    int count=0;\\n    int MaxOR=0;\\n    private void findSubsets(int ind,List<Integer> ds,int[] arr,int currentOR)\\n    {\\n        if(ind==arr.length)\\n        {\\n            if(currentOR>MaxOR)\\n            {\\n                MaxOR=currentOR;\\n                count=0;\\n            }\\n            else if(currentOR==MaxOR)\\n                count++;\\n            return;\\n        }\\n        ds.add(arr[ind]);\\n        findSubsets(ind+1,ds,arr,currentOR|arr[ind]);\\n        ds.remove(ds.size()-1);\\n        findSubsets(ind+1,ds,arr,currentOR);\\n    }\\n    public int countMaxOrSubsets(int[] nums) \\n    {\\n        findSubsets(0,new ArrayList<>(),nums,0);\\n        return count+1;//+1 for first element\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299623,
                "title": "or-subset-generation-backtracking-clean-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> &nums, int index, int &maxi, int val ,int &count)\\n    {\\n        if(index == nums.size()){\\n            if(val >= maxi){\\n                maxi = val;\\n                count++;\\n            }\\n            return;\\n        }\\n        dfs(nums, index + 1, maxi, val | nums[index], count);\\n        dfs(nums, index + 1, maxi, val, count);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        int count = 0;\\n        dfs(nums, 0 , maxi, 0, count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> &nums, int index, int &maxi, int val ,int &count)\\n    {\\n        if(index == nums.size()){\\n            if(val >= maxi){\\n                maxi = val;\\n                count++;\\n            }\\n            return;\\n        }\\n        dfs(nums, index + 1, maxi, val | nums[index], count);\\n        dfs(nums, index + 1, maxi, val, count);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        int count = 0;\\n        dfs(nums, 0 , maxi, 0, count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241861,
                "title": "easy-to-read-c-brute-force-bit-masking",
                "content": "\\t\\t// Basically if there is any way, such we can generate every possible subset of the given array\\n\\t\\t//then  we can solve this question easily\\n\\t\\t// also maximum or for any given no. of elements can be obtained by doing bitwise or of all the elements\\n\\t\\t// Time - Complexity O(2^n * nums.size())\\n\\t\\t// Space-Complexity O(1)\\n\\t\\tint total_subset = 1 << nums.size(), subset(0);\\n        int max_r(0);\\n        for(auto i : nums){max_r |= i; } // now max_r stores maximum bitwise or of all elements\\n        \\n        for(int i = 1; i <= total_subset; i++) // total subsets would be 2^nums.size()\\n        {\\n            int running_r(0);\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(i >> j & 1){running_r  |= nums[j]; }\\n            }\\n            \\n            if(running_r == max_r){subset++;}\\n        }\\n        \\n        return subset;\\n\\t\\t\\n\\t\\t//  \\uD83D\\uDE04 \\uD83D\\uDE04 \\uD83D\\uDE04PLEASE DO UPVOTE IF YOU UNDERSTOOD THE CODE AND THE EXPLANATION \\uD83D\\uDE04 \\uD83D\\uDE04 \\uD83D\\uDE04",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "\\t\\t// Basically if there is any way, such we can generate every possible subset of the given array\\n\\t\\t//then  we can solve this question easily\\n\\t\\t// also maximum or for any given no. of elements can be obtained by doing bitwise or of all the elements\\n\\t\\t// Time - Complexity O(2^n * nums.size())\\n\\t\\t// Space-Complexity O(1)\\n\\t\\tint total_subset = 1 << nums.size(), subset(0);\\n        int max_r(0);\\n        for(auto i : nums){max_r |= i; } // now max_r stores maximum bitwise or of all elements\\n        \\n        for(int i = 1; i <= total_subset; i++) // total subsets would be 2^nums.size()\\n        {\\n            int running_r(0);\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(i >> j & 1){running_r  |= nums[j]; }\\n            }\\n            \\n            if(running_r == max_r){subset++;}\\n        }\\n        \\n        return subset;\\n\\t\\t\\n\\t\\t//  \\uD83D\\uDE04 \\uD83D\\uDE04 \\uD83D\\uDE04PLEASE DO UPVOTE IF YOU UNDERSTOOD THE CODE AND THE EXPLANATION \\uD83D\\uDE04 \\uD83D\\uDE04 \\uD83D\\uDE04",
                "codeTag": "Unknown"
            },
            {
                "id": 2175662,
                "title": "c-recursion",
                "content": "class Solution {\\npublic:\\n    int maxor=0, res=0;\\n    \\n    void f(vector<int>&n, int i, int s){\\n        if(s == maxor and i==n.size())res++;\\n        if(i == n.size()) return;\\n        \\n        f(n, i+1, s|n[i]);\\n        // cout<<s;\\n        f(n, i+1, s);\\n        return;\\n    }\\n    int countMaxOrSubsets(vector<int>& n) {\\n        for(auto i : n)maxor |= i;\\n        f(n, 0, 0);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxor=0, res=0;\\n    \\n    void f(vector<int>&n, int i, int s){\\n        if(s == maxor and i==n.size())res++;\\n        if(i == n.size()) return;\\n        \\n        f(n, i+1, s|n[i]);\\n        // cout<<s;\\n        f(n, i+1, s);\\n        return;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2083222,
                "title": "easy-recursive-approach-take-or-not-take",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0, mxorGlobal;\\n    void solve(vector<int> &nums, int n, int mxor) {\\n        if(n == 0) {\\n            if(mxorGlobal == mxor) ans++;\\n            else if(mxorGlobal < mxor) {\\n                mxorGlobal = mxor;\\n                ans = 1;\\n            }\\n            return;\\n        }\\n        //or\\n        solve(nums, n-1, mxor|nums[n-1]);\\n        // skip\\n        solve(nums, n-1, mxor);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        solve(nums, nums.size(), 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0, mxorGlobal;\\n    void solve(vector<int> &nums, int n, int mxor) {\\n        if(n == 0) {\\n            if(mxorGlobal == mxor) ans++;\\n            else if(mxorGlobal < mxor) {\\n                mxorGlobal = mxor;\\n                ans = 1;\\n            }\\n            return;\\n        }\\n        //or\\n        solve(nums, n-1, mxor|nums[n-1]);\\n        // skip\\n        solve(nums, n-1, mxor);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        solve(nums, nums.size(), 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069996,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n     void f(vector<int>&nums,int i,vector<int>&v,int xr)\\n    { \\n        if(i>=nums.size())\\n        { \\n            v.push_back(xr);\\n            return ;\\n        }\\n        int k=xr;\\n        xr=xr|nums[i];\\n        f(nums,i+1,v,xr);\\n        xr=k;\\n        f(nums,i+1,v,xr);\\n        \\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vector<int>v;\\n        int xr=nums[0];\\n        f(nums,0,v,0);\\n        int ans=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        return count(v.begin(),v.end(),v[0]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void f(vector<int>&nums,int i,vector<int>&v,int xr)\\n    { \\n        if(i>=nums.size())\\n        { \\n            v.push_back(xr);\\n            return ;\\n        }\\n        int k=xr;\\n        xr=xr|nums[i];\\n        f(nums,i+1,v,xr);\\n        xr=k;\\n        f(nums,i+1,v,xr);\\n        \\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vector<int>v;\\n        int xr=nums[0];\\n        f(nums,0,v,0);\\n        int ans=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        return count(v.begin(),v.end(),v[0]);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958671,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    int result = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int num: nums) max |= num;\\n        dfs(nums, 0, max, 0);\\n        return result;\\n    }\\n    \\n    private void dfs(int[] nums, int start, int max, int curOr) {\\n        if (start == nums.length && curOr == max) {\\n            result++;\\n            return;\\n        }\\n        \\n        if(start < nums.length) {\\n            dfs(nums, start + 1, max, curOr | nums[start]);\\n            dfs(nums, start + 1, max, curOr);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int num: nums) max |= num;\\n        dfs(nums, 0, max, 0);\\n        return result;\\n    }\\n    \\n    private void dfs(int[] nums, int start, int max, int curOr) {\\n        if (start == nums.length && curOr == max) {\\n            result++;\\n            return;\\n        }\\n        \\n        if(start < nums.length) {\\n            dfs(nums, start + 1, max, curOr | nums[start]);\\n            dfs(nums, start + 1, max, curOr);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870018,
                "title": "java-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution {\\n    int key=0,val=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        \\n        int or = 0;\\n        recursion(nums,0,or);\\n        \\n        return val;\\n    }\\n    void recursion(int[] nums,int curr,int total)\\n    {\\n        if(curr == nums.length)\\n        {\\n            if(key == 0 || total > key)\\n            {\\n                key = total;\\n                val =1;\\n            }\\n            else if(total == key)   val++;\\n            return;\\n        }\\n        recursion(nums,curr+1,total|nums[curr]);\\n        recursion(nums,curr+1,total);\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int key=0,val=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        \\n        int or = 0;\\n        recursion(nums,0,or);\\n        \\n        return val;\\n    }\\n    void recursion(int[] nums,int curr,int total)\\n    {\\n        if(curr == nums.length)\\n        {\\n            if(key == 0 || total > key)\\n            {\\n                key = total;\\n                val =1;\\n            }\\n            else if(total == key)   val++;\\n            return;\\n        }\\n        recursion(nums,curr+1,total|nums[curr]);\\n        recursion(nums,curr+1,total);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742852,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mx;\\n    int res;\\n    int n;\\n    void solve(vector<int>& nums, int i, int oR){\\n        //base case\\n        if(i==n){\\n            if(oR == mx) res++;\\n            return;\\n        }\\n        //recursive case\\n        solve(nums, i+1, oR|nums[i]);\\n        solve(nums, i+1, oR);\\n        return;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        // int n=nums.size();\\n        // int a=0,mx=0;\\n        // for(int &x:nums) mx|=x;\\n        // // //subset generation using bitmask\\n        // int res = 0;\\n        // int s_ct=(1<<n);//no of subsets\\n        // for(int i=0;i<s_ct;i++){\\n        //     int oR=0;\\n        //     for(int j=0;j<n;j++){\\n        //         if(i&(1<<j))//means bit is set\\n        //             oR|=nums[j];\\n        //     }\\n        //     if(mx == oR) res++;   \\n        // }\\n        // return res;\\n        mx = 0;\\n        res = 0;\\n        n = nums.size();\\n        for(int &x:nums) mx|=x;\\n        solve(nums, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx;\\n    int res;\\n    int n;\\n    void solve(vector<int>& nums, int i, int oR){\\n        //base case\\n        if(i==n){\\n            if(oR == mx) res++;\\n            return;\\n        }\\n        //recursive case\\n        solve(nums, i+1, oR|nums[i]);\\n        solve(nums, i+1, oR);\\n        return;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        // int n=nums.size();\\n        // int a=0,mx=0;\\n        // for(int &x:nums) mx|=x;\\n        // // //subset generation using bitmask\\n        // int res = 0;\\n        // int s_ct=(1<<n);//no of subsets\\n        // for(int i=0;i<s_ct;i++){\\n        //     int oR=0;\\n        //     for(int j=0;j<n;j++){\\n        //         if(i&(1<<j))//means bit is set\\n        //             oR|=nums[j];\\n        //     }\\n        //     if(mx == oR) res++;   \\n        // }\\n        // return res;\\n        mx = 0;\\n        res = 0;\\n        n = nums.size();\\n        for(int &x:nums) mx|=x;\\n        solve(nums, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742300,
                "title": "another-worst-solution",
                "content": "```\\n\\nclass Solution {\\n    public int countMaxOrSubsets(int[] arr) {\\n        int mxOr = Integer.MIN_VALUE;\\n    \\tint limit = 1<<arr.length ;\\n    \\tint temp =0 ;\\n    \\tfor(int i =0 ;i<arr.length ;i++) {\\n    \\t\\ttemp|=arr[i] ;\\n    \\t\\tmxOr = Math.max(mxOr,temp) ;\\n    \\t}\\n    \\tint cnt = 0 ;\\n    \\tfor(int i=0 ;i<limit ;i++) {\\n    \\t\\tint  num = i ;\\n    \\t\\tint sum = 0 ;\\n    \\t\\tfor(int j=arr.length-1 ;j>=0 ;j--) {\\n    \\t\\t\\tif((num% 2)==1) {\\n    \\t\\t\\t\\tsum|=arr[j] ;\\n    \\t\\t\\t}\\n    \\t\\t\\tnum/=2 ;\\n    \\t\\t}\\n    \\t\\tif(sum==mxOr)cnt++ ;\\n    \\t}\\n    \\treturn cnt ;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int countMaxOrSubsets(int[] arr) {\\n        int mxOr = Integer.MIN_VALUE;\\n    \\tint limit = 1<<arr.length ;\\n    \\tint temp =0 ;\\n    \\tfor(int i =0 ;i<arr.length ;i++) {\\n    \\t\\ttemp|=arr[i] ;\\n    \\t\\tmxOr = Math.max(mxOr,temp) ;\\n    \\t}\\n    \\tint cnt = 0 ;\\n    \\tfor(int i=0 ;i<limit ;i++) {\\n    \\t\\tint  num = i ;\\n    \\t\\tint sum = 0 ;\\n    \\t\\tfor(int j=arr.length-1 ;j>=0 ;j--) {\\n    \\t\\t\\tif((num% 2)==1) {\\n    \\t\\t\\t\\tsum|=arr[j] ;\\n    \\t\\t\\t}\\n    \\t\\t\\tnum/=2 ;\\n    \\t\\t}\\n    \\t\\tif(sum==mxOr)cnt++ ;\\n    \\t}\\n    \\treturn cnt ;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726013,
                "title": "c-bitmask-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,ans;\\n        // //subset generation using bitmask\\n        map<int,int>mp;\\n        int s_ct=(1<<n);//no of subsets\\n        for(int i=0;i<s_ct;i++){\\n            \\n            int oR=0;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j))//means bit is set\\n                {\\n                    \\n                    oR|=nums[j];\\n                }\\n            }\\n            mp[oR]++;\\n           \\n        }\\n        return mp.rbegin()->second;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,ans;\\n        // //subset generation using bitmask\\n        map<int,int>mp;\\n        int s_ct=(1<<n);//no of subsets\\n        for(int i=0;i<s_ct;i++){\\n            \\n            int oR=0;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j))//means bit is set\\n                {\\n                    \\n                    oR|=nums[j];\\n                }\\n            }\\n            mp[oR]++;\\n           \\n        }\\n        return mp.rbegin()->second;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628507,
                "title": "java-dfs-or-dp",
                "content": "DFS with backtracking by checking all possible subsets for OR mask (beats 85%)\\n```\\n    public int countMaxOrSubsets(int[] nums) {\\n        int or = 0;\\n        for(int i=0;i<nums.length;i++)\\n            or |= nums[i];\\n        return dfs(nums, or, 0,0);\\n    }\\n    private int dfs(int[] nums, int or, int currOr, int pos){\\n        if(pos==nums.length)\\n            return or==currOr ? 1 : 0;\\n        return dfs(nums, or, currOr, pos+1) + dfs(nums, or, currOr|nums[pos],pos+1);\\n    }\\n```\\n\\nDP with buffer of OR-size and checking in  how many ways we can reach OR value (beats 52%)\\n```\\n    public int countMaxOrSubsets(int[] nums) {\\n        int or = 0;\\n        for(int i=0;i<nums.length;i++)\\n            or |= nums[i];\\n\\n        int[] dp = new int[or];\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=or-1;j>=0;j--){\\n                if(dp[j] != 0){\\n                    int nextOr = (j+1) | nums[i];\\n                    dp[nextOr-1] += dp[j];\\n                }\\n            }\\n            dp[nums[i]-1]++;\\n        }\\n        return dp[or-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countMaxOrSubsets(int[] nums) {\\n        int or = 0;\\n        for(int i=0;i<nums.length;i++)\\n            or |= nums[i];\\n        return dfs(nums, or, 0,0);\\n    }\\n    private int dfs(int[] nums, int or, int currOr, int pos){\\n        if(pos==nums.length)\\n            return or==currOr ? 1 : 0;\\n        return dfs(nums, or, currOr, pos+1) + dfs(nums, or, currOr|nums[pos],pos+1);\\n    }\\n```\n```\\n    public int countMaxOrSubsets(int[] nums) {\\n        int or = 0;\\n        for(int i=0;i<nums.length;i++)\\n            or |= nums[i];\\n\\n        int[] dp = new int[or];\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=or-1;j>=0;j--){\\n                if(dp[j] != 0){\\n                    int nextOr = (j+1) | nums[i];\\n                    dp[nextOr-1] += dp[j];\\n                }\\n            }\\n            dp[nums[i]-1]++;\\n        }\\n        return dp[or-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546909,
                "title": "c-similar-to-subset-problem",
                "content": "Extremely similar to subset problem !!!\\n\\nOne big difference is that backtrack is needed if dfs call is adding new item to a list/collector during each level, we need to remove last item from the list/collector while exiting the previous dfs call (leetcode 78)\\n\\nHowever, if the dfs argument is a value, then no backtrack is needed (current problem, leetcode 2044)\\n```\\npublic class Solution {\\n    public int CountMaxOrSubsets(int[] nums) {\\n        int target = 0, count = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0foreach(var num in nums) \\xA0target |= num;\\n\\t\\t\\n \\xA0 \\xA0 \\xA0 \\xA0dfs(nums, 0, 0, target, ref count);\\n        return count;\\n    }\\n    \\n    private void dfs(int[] nums, int idx, int xor, int target, ref int count) {\\n        if(target == xor) count++;\\n        \\n        for(int i = idx; i < nums.Length; i++)\\n            dfs(nums, i + 1, xor | nums[i], target, ref count);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int CountMaxOrSubsets(int[] nums) {\\n        int target = 0, count = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0foreach(var num in nums) \\xA0target |= num;\\n\\t\\t\\n \\xA0 \\xA0 \\xA0 \\xA0dfs(nums, 0, 0, target, ref count);\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1530535,
                "title": "simple-dfs-like-backtrack-without-back",
                "content": "```\\nclass Solution {\\n    int cnt = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int num : nums) {\\n            max = max | num;\\n        }\\n        dfs(max, 0, 0, nums);\\n        return cnt;\\n    }\\n    \\n    private void dfs(int max, int start, int curr, int[] nums) {\\n        if (curr == max) {\\n            cnt++;\\n        }\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            dfs(max, i + 1, curr | nums[i], nums);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int cnt = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int num : nums) {\\n            max = max | num;\\n        }\\n        dfs(max, 0, 0, nums);\\n        return cnt;\\n    }\\n    \\n    private void dfs(int max, int start, int curr, int[] nums) {\\n        if (curr == max) {\\n            cnt++;\\n        }\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            dfs(max, i + 1, curr | nums[i], nums);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529695,
                "title": "java-short-solution-with-dfs-and-pruning-beats-100",
                "content": "The idea is simple - generate all subsets from the beginning of the array. When the bitwise sum gets max, dont enumerate sybsets further, just count all subsets of the remaining elements.\\n\\n```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int x: nums) max |= x;\\n        return checkSubsets(nums, 0, 0, max);\\n    }\\n    \\n    private int checkSubsets(int[] nums, int idx, int curr, int target) {\\n        if (curr == target) return 1 << (nums.length - idx);\\n        if (idx >= nums.length) return 0;\\n        return checkSubsets(nums, idx + 1, curr, target) + checkSubsets(nums, idx + 1, curr | nums[idx], target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int x: nums) max |= x;\\n        return checkSubsets(nums, 0, 0, max);\\n    }\\n    \\n    private int checkSubsets(int[] nums, int idx, int curr, int target) {\\n        if (curr == target) return 1 << (nums.length - idx);\\n        if (idx >= nums.length) return 0;\\n        return checkSubsets(nums, idx + 1, curr, target) + checkSubsets(nums, idx + 1, curr | nums[idx], target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529060,
                "title": "brute-force-c-solution",
                "content": "```\\nvoid subsetsUtil(vector<int>& A, vector<vector<int> >& res,vector<int>& subset, int index)\\n    {\\n        res.push_back(subset);\\n        for (int i = index; i < A.size(); i++) {\\n\\n            // include the A[i] in subset.\\n            subset.push_back(A[i]);\\n\\n            // move onto the next element.\\n            subsetsUtil(A, res, subset, i + 1);\\n\\n            // exclude the A[i] from subset and triggers\\n            // backtracking.\\n            subset.pop_back();\\n        }\\n\\n        return;\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) \\n    {\\n         vector<int> subset;\\n         vector<vector<int> > res;\\n         int index = 0;\\n         subsetsUtil(nums, res, subset, index);\\n         int maxi=0; \\n         unordered_map<int,int>m;\\n         for(int i=0;i<res.size();++i)\\n         {\\n             int ans=0;\\n            for(int j=0;j<res[i].size();++j)\\n            {\\n                ans|=res[i][j];\\n            }\\n             maxi=max(maxi,ans);\\n             m[ans]++;\\n         }\\n         return m[maxi];\\n         \\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvoid subsetsUtil(vector<int>& A, vector<vector<int> >& res,vector<int>& subset, int index)\\n    {\\n        res.push_back(subset);\\n        for (int i = index; i < A.size(); i++) {\\n\\n            // include the A[i] in subset.\\n            subset.push_back(A[i]);\\n\\n            // move onto the next element.\\n            subsetsUtil(A, res, subset, i + 1);\\n\\n            // exclude the A[i] from subset and triggers\\n            // backtracking.\\n            subset.pop_back();\\n        }\\n\\n        return;\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) \\n    {\\n         vector<int> subset;\\n         vector<vector<int> > res;\\n         int index = 0;\\n         subsetsUtil(nums, res, subset, index);\\n         int maxi=0; \\n         unordered_map<int,int>m;\\n         for(int i=0;i<res.size();++i)\\n         {\\n             int ans=0;\\n            for(int j=0;j<res[i].size();++j)\\n            {\\n                ans|=res[i][j];\\n            }\\n             maxi=max(maxi,ans);\\n             m[ans]++;\\n         }\\n         return m[maxi];\\n         \\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1528335,
                "title": "python-easy-solution-with-7-lines-beats-100",
                "content": "We can compute the target sum first. Then we need to compute all the separate subsets and check if we obtain a sum that is equal to the target. So we need to keep track of the sum during the recursion. We sum all the possible subsets. O(N\\\\*2^N) time complexity.\\n```\\ndef countMaxOrSubsets(self, nums: List[int]) -> int:\\n    @lru_cache(None)\\n    def dfs(i, csum=0):\\n        if i < 0: return 1 if csum == self.target else 0\\n        return dfs(i-1, csum) + dfs(i-1, csum | nums[i])\\n    self.target = 0\\n    for n in nums: self.target |= n\\n    return dfs(len(nums)-1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef countMaxOrSubsets(self, nums: List[int]) -> int:\\n    @lru_cache(None)\\n    def dfs(i, csum=0):\\n        if i < 0: return 1 if csum == self.target else 0\\n        return dfs(i-1, csum) + dfs(i-1, csum | nums[i])\\n    self.target = 0\\n    for n in nums: self.target |= n\\n    return dfs(len(nums)-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1526544,
                "title": "c-using-subsets",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxBit=0;\\n        int counter=0;\\n        for(int i=0;i<nums.size();++i)\\n            maxBit=maxBit | nums[i]; \\n        vector<vector<int>> v;\\n        for(int x=0;x<nums.size();++x){\\n            int len=v.size();\\n            for(int i=0;i<len;++i){\\n                vector<int> t;\\n                t=v[i];\\n                t.push_back(nums[x]);\\n                v.push_back(t);\\n            }\\n            vector<int> t2;t2.push_back(nums[x]);\\n            v.push_back(t2);\\n        }\\n        \\n                for(int i=0;i<v.size();++i){\\n                    int temp=0;\\n                    for(int j=0;j<v[i].size();++j)\\n                        temp = temp | v[i][j];\\n                    if(temp == maxBit) counter++;\\n                }   \\n        return counter;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxBit=0;\\n        int counter=0;\\n        for(int i=0;i<nums.size();++i)\\n            maxBit=maxBit | nums[i]; \\n        vector<vector<int>> v;\\n        for(int x=0;x<nums.size();++x){\\n            int len=v.size();\\n            for(int i=0;i<len;++i){\\n                vector<int> t;\\n                t=v[i];\\n                t.push_back(nums[x]);\\n                v.push_back(t);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1526478,
                "title": "c-simple-solution-recursion-map",
                "content": "**Find or of all the subsets and store them in a map;\\nreturn last value of map**\\n\\n```\\nclass Solution {\\n    map <int, int> m;\\npublic:\\n    \\n    void subsets(vector<int>& nums, int i, int value) {\\n        \\n        m[value]++;\\n        for (int j=i; j<nums.size(); j++)\\n            subsets(nums, j+1, value | nums[j]);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        subsets(nums, 0, 0);\\n        return m.rbegin()->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    map <int, int> m;\\npublic:\\n    \\n    void subsets(vector<int>& nums, int i, int value) {\\n        \\n        m[value]++;\\n        for (int j=i; j<nums.size(); j++)\\n            subsets(nums, j+1, value | nums[j]);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        subsets(nums, 0, 0);\\n        return m.rbegin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525991,
                "title": "python-100-faster",
                "content": "```\\ndef countMaxOrSubsets(self, nums: List[int]) -> int:\\n        target=0\\n        for n in nums:\\n            target|=n\\n        self.ans=set()\\n        def helper(i,curr,arr):\\n            if curr==target:\\n                self.ans.add(tuple(arr.copy()))\\n            if i==len(nums):\\n                return\\n            helper(i+1,curr,arr)\\n            helper(i+1,curr|nums[i],arr+[i])\\n            \\n        helper(0,0,[])\\n        return len(self.ans)",
                "solutionTags": [],
                "code": "```\\ndef countMaxOrSubsets(self, nums: List[int]) -> int:\\n        target=0\\n        for n in nums:\\n            target|=n\\n        self.ans=set()\\n        def helper(i,curr,arr):\\n            if curr==target:\\n                self.ans.add(tuple(arr.copy()))\\n            if i==len(nums):\\n                return\\n            helper(i+1,curr,arr)\\n            helper(i+1,curr|nums[i],arr+[i])\\n            \\n        helper(0,0,[])\\n        return len(self.ans)",
                "codeTag": "Python3"
            },
            {
                "id": 1525767,
                "title": "java-simple-solution",
                "content": "```\\nimport java.util.stream.Collectors;\\nclass Solution {\\n    \\n    static List<Integer> list = new ArrayList<Integer>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        list = new ArrayList<Integer>();\\n        int max = 0;\\n        for(int p : nums) max = max | p;\\n        go(nums,0,max);\\n       // System.out.println(list.toString());\\n        return Collections.frequency(list,max);\\n    }\\n    \\n    private void go(int[] nums,int idx,int max){\\n        if(idx == nums.length-1){\\n            list.add(nums[idx]);\\n            return;\\n        }\\n        \\n        go(nums,idx+1,max);\\n        int curr = nums[idx];\\n        List<Integer> buffer = new ArrayList<>();\\n        for(int p : list) buffer.add(p);\\n        \\n        List<Integer> sups = new ArrayList<Integer>();\\n        \\n        sups = list.stream().map(x -> {\\n            if(x < max) return x | curr;\\n            else return x;\\n        }).collect(Collectors.toList());\\n        \\n        for(int p : buffer) sups.add(p);\\n        sups.add(curr);\\n        \\n        list.clear();\\n        for(int p : sups) list.add(p);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.stream.Collectors;\\nclass Solution {\\n    \\n    static List<Integer> list = new ArrayList<Integer>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        list = new ArrayList<Integer>();\\n        int max = 0;\\n        for(int p : nums) max = max | p;\\n        go(nums,0,max);\\n       // System.out.println(list.toString());\\n        return Collections.frequency(list,max);\\n    }\\n    \\n    private void go(int[] nums,int idx,int max){\\n        if(idx == nums.length-1){\\n            list.add(nums[idx]);\\n            return;\\n        }\\n        \\n        go(nums,idx+1,max);\\n        int curr = nums[idx];\\n        List<Integer> buffer = new ArrayList<>();\\n        for(int p : list) buffer.add(p);\\n        \\n        List<Integer> sups = new ArrayList<Integer>();\\n        \\n        sups = list.stream().map(x -> {\\n            if(x < max) return x | curr;\\n            else return x;\\n        }).collect(Collectors.toList());\\n        \\n        for(int p : buffer) sups.add(p);\\n        sups.add(curr);\\n        \\n        list.clear();\\n        for(int p : sups) list.add(p);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525592,
                "title": "c-simple-recursive-solution",
                "content": "\\tclass Solution {\\n\\t\\tint target = 0;\\n\\tpublic:\\n\\t\\tint  help(vector<int>& nums,int i, int curr){\\n\\t\\t\\tif(i==nums.size()){\\n\\t\\t\\t\\tif(curr==target) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn help(nums,i+1,curr|nums[i]) + help(nums,i+1,curr);\\n\\t\\t}\\n\\t\\tint countMaxOrSubsets(vector<int>& nums) {\\n\\t\\t\\tint val = 0;\\n\\t\\t\\tfor(auto x:nums) target = max(target,val|=x);\\n\\t\\t\\treturn help(nums,0,0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint target = 0;\\n\\tpublic:\\n\\t\\tint  help(vector<int>& nums,int i, int curr){\\n\\t\\t\\tif(i==nums.size()){\\n\\t\\t\\t\\tif(curr==target) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1525455,
                "title": "python3-beats-100-solution-easy-to-understand",
                "content": "```python\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        ans = {}\\n        subSet = [[]]\\n        max_or = 0\\n        for i in range(len(nums)):\\n            for j in range(len(subSet)):\\n                new = [nums[i]] + subSet[j]\\n                # print(new)\\n                x = new[0]\\n                for k in range(1, len(new)):\\n                    x |= new[k]\\n                x = max(max_or, x)\\n                if x in ans:\\n                    ans[x] += 1\\n                else:\\n                    ans[x] = 1\\n                subSet.append(new)\\n        return ans[x]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        ans = {}\\n        subSet = [[]]\\n        max_or = 0\\n        for i in range(len(nums)):\\n            for j in range(len(subSet)):\\n                new = [nums[i]] + subSet[j]\\n                # print(new)\\n                x = new[0]\\n                for k in range(1, len(new)):\\n                    x |= new[k]\\n                x = max(max_or, x)\\n                if x in ans:\\n                    ans[x] += 1\\n                else:\\n                    ans[x] = 1\\n                subSet.append(new)\\n        return ans[x]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525391,
                "title": "easy-swift-solution",
                "content": "My swift solution \\n\\n```\\nclass Solution {\\nvar dict = [Int: Int]()\\n\\nfunc OR(_ arr: [Int]) -> Int\\n{\\n    var mOR = 0;\\n    for i in 0...arr.count - 1 {\\n         mOR |= arr[i]\\n    }\\n    return mOR\\n}\\n\\nfunc addtoDict(_ arr: [Int]) {\\n    let xOR = OR(arr)\\n       if dict[xOR] != nil {\\n           dict[xOR]! += 1\\n       } else {\\n           dict[xOR] = 1\\n       }\\n   }\\n\\n    func countMaxOrSubsets(_ nums: [Int]) -> Int {\\n        var result = [[Int]]()\\n        for elem in nums {\\n            for subarray in result {\\n                result.append(subarray + [elem])\\n                addtoDict(subarray + [elem])\\n            }\\n            result.append([elem])\\n            addtoDict([elem])\\n        }\\n        result.append([])\\n        \\n        var maxKey = -1\\n        var maxValue = -1\\n        \\n        for (key, value) in dict {\\n            if key > maxKey {\\n                maxKey = key\\n                maxValue = value\\n            }\\n        }\\n        return maxValue\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nvar dict = [Int: Int]()\\n\\nfunc OR(_ arr: [Int]) -> Int\\n{\\n    var mOR = 0;\\n    for i in 0...arr.count - 1 {\\n         mOR |= arr[i]\\n    }\\n    return mOR\\n}\\n\\nfunc addtoDict(_ arr: [Int]) {\\n    let xOR = OR(arr)\\n       if dict[xOR] != nil {\\n           dict[xOR]! += 1\\n       } else {\\n           dict[xOR] = 1\\n       }\\n   }\\n\\n    func countMaxOrSubsets(_ nums: [Int]) -> Int {\\n        var result = [[Int]]()\\n        for elem in nums {\\n            for subarray in result {\\n                result.append(subarray + [elem])\\n                addtoDict(subarray + [elem])\\n            }\\n            result.append([elem])\\n            addtoDict([elem])\\n        }\\n        result.append([])\\n        \\n        var maxKey = -1\\n        var maxValue = -1\\n        \\n        for (key, value) in dict {\\n            if key > maxKey {\\n                maxKey = key\\n                maxValue = value\\n            }\\n        }\\n        return maxValue\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525332,
                "title": "simple-backtrack-100",
                "content": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxVal = reduce(lambda a, b: a | b, nums)\\n        nums.sort(reverse = True)\\n        n = len(nums)\\n        self.ans = 0\\n        def backtrack(curr, i):\\n            if curr==maxVal:\\n                self.ans+=2**(n-i)\\n                return\\n            if i==n:\\n                return\\n            backtrack(curr, i+1)\\n            backtrack(curr | nums[i],i+1)\\n        backtrack(0,0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxVal = reduce(lambda a, b: a | b, nums)\\n        nums.sort(reverse = True)\\n        n = len(nums)\\n        self.ans = 0\\n        def backtrack(curr, i):\\n            if curr==maxVal:\\n                self.ans+=2**(n-i)\\n                return\\n            if i==n:\\n                return\\n            backtrack(curr, i+1)\\n            backtrack(curr | nums[i],i+1)\\n        backtrack(0,0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525275,
                "title": "c-subsets-unordered-map-tc-o-2-n-sc-o-n-aux-o-n",
                "content": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n        unordered_map<int,int> bORfreq;\\n        int maxOR = INT_MIN;\\n        for (int i = 0; i < (int) pow(2, nums.size()); i++) {\\n            int tempOR = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n                if ((i & (1 << j)) != 0)\\n                    tempOR |= nums[j];\\n            bORfreq[tempOR]++;\\n            if(tempOR != 0)\\n                maxOR = max(maxOR,tempOR);\\n        }    \\n        return bORfreq[maxOR];\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n        unordered_map<int,int> bORfreq;\\n        int maxOR = INT_MIN;\\n        for (int i = 0; i < (int) pow(2, nums.size()); i++) {\\n            int tempOR = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n                if ((i & (1 << j)) != 0)\\n                    tempOR |= nums[j];\\n            bORfreq[tempOR]++;\\n            if(tempOR != 0)\\n                maxOR = max(maxOR,tempOR);\\n        }    \\n        return bORfreq[maxOR];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525214,
                "title": "simple-recursive-solution-c-with-diagram",
                "content": "**Inital Thought:**\\nSeeing the problem statement the initial thought was this being a dp problem. But looking at the constraints figured that it could be done via recursion itself.\\n\\n**Algorithm:**\\n1) for generating subsets each element has a choice, if it wants to be part of current subset or not.\\n\\n2) So two recursive calls for each element:\\n\\t2.1) include it as a part of current subset (so include it in the **\"or\"** result of current subset).\\n\\t2.2) exclude it (so don\\'t add it in **\"or\"** result of current subset).\\n\\n3) at base cases we have all generated subsets.  \\n\\n**Pictorial Representation Of Subset Genration**\\n\\n![image](https://assets.leetcode.com/users/images/ffc5f497-4f9a-4a88-8de1-effe820b6924_1634444916.133533.jpeg)\\n\\nwhere arrow on element\\'s top indicates decision is being taken for it.\\nelements in square bracket represent current subset.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int max_or=-1;\\n    void count_helper(vector<int> & nums,int curr_or,int idx,unordered_map <int,int> & freq){\\n        \\n        int size=nums.size();\\n        \\n        // one subset has been created\\n        if(idx==size){\\n            // maximum bitwise or we can create\\n            max_or=max(max_or,curr_or);\\n            // updating how many times we saw this \"or\" result\\n            freq[curr_or]++;\\n            return;\\n        }    \\n        \\n        // exclude current element\\n        count_helper(nums,curr_or,idx+1,freq);\\n        // include current element\\n        count_helper(nums,curr_or | nums[idx],idx+1,freq);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        unordered_map <int,int> freq;\\n        count_helper(nums,0,0,freq);\\n        \\n        // max or contains the maximum or value we can get\\n       // freq contains the frequency of every or result\\n        return freq[max_or];\\n    }\\n};\\n```\\n\\n**Time Complexity** : O(2^n)\\n**Space Complexity** : O(n)\\n\\nwhere n -> number of elements in array\\n\\nI hope this was helpful!\\nIf there are any suggestions or optimisations do tell. If this helped somehow do consider upvoting :) .",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int max_or=-1;\\n    void count_helper(vector<int> & nums,int curr_or,int idx,unordered_map <int,int> & freq){\\n        \\n        int size=nums.size();\\n        \\n        // one subset has been created\\n        if(idx==size){\\n            // maximum bitwise or we can create\\n            max_or=max(max_or,curr_or);\\n            // updating how many times we saw this \"or\" result\\n            freq[curr_or]++;\\n            return;\\n        }    \\n        \\n        // exclude current element\\n        count_helper(nums,curr_or,idx+1,freq);\\n        // include current element\\n        count_helper(nums,curr_or | nums[idx],idx+1,freq);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        unordered_map <int,int> freq;\\n        count_helper(nums,0,0,freq);\\n        \\n        // max or contains the maximum or value we can get\\n       // freq contains the frequency of every or result\\n        return freq[max_or];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525179,
                "title": "simple-search",
                "content": "We can add memoisation, but it is easy to verify that we do not need it. The runtime is just a few ms already.\\n\\n**C++**\\n```cpp\\nint dfs(vector<int>& n, int i, int cur_or, int max_or) {\\n    if (i >= n.size())\\n        return max_or == cur_or;\\n    else\\n        return dfs(n, i + 1, cur_or, max_or) + dfs(n, i + 1, cur_or | n[i], max_or);\\n}\\nint countMaxOrSubsets(vector<int>& n) {\\n    return dfs(n, 0, 0, accumulate(begin(n), end(n), 0, bit_or<int>()));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dfs(vector<int>& n, int i, int cur_or, int max_or) {\\n    if (i >= n.size())\\n        return max_or == cur_or;\\n    else\\n        return dfs(n, i + 1, cur_or, max_or) + dfs(n, i + 1, cur_or | n[i], max_or);\\n}\\nint countMaxOrSubsets(vector<int>& n) {\\n    return dfs(n, 0, 0, accumulate(begin(n), end(n), 0, bit_or<int>()));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525157,
                "title": "c-bitmask-solution-brute-force",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        int all = 1 << n;\\n        int ans = 0;\\n        int mx = 0;\\n        for(int i = 1; i < all; i++) {\\n            int val = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((1 << j) & i) {\\n                    val |= nums[j];\\n                }\\n            }\\n            if(val >= mx) {\\n                if(val == mx) {\\n                    ++ans;\\n                } else {\\n                    ans = 1;\\n                    mx = val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        int all = 1 << n;\\n        int ans = 0;\\n        int mx = 0;\\n        for(int i = 1; i < all; i++) {\\n            int val = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((1 << j) & i) {\\n                    val |= nums[j];\\n                }\\n            }\\n            if(val >= mx) {\\n                if(val == mx) {\\n                    ++ans;\\n                } else {\\n                    ans = 1;\\n                    mx = val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084820,
                "title": "backtrack-simple-python",
                "content": "just use backtrack as constraint is so small\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        max_or = 0\\n        for num in nums:max_or |= num\\n        self.res = 0\\n        def backtrack(ind,pref):\\n            if pref == max_or:self.res += 1\\n            if ind >= len(nums):return \\n            for i in range(ind,len(nums)):backtrack(i+1,pref|nums[i])\\n        backtrack(0,0)\\n        return self.res",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "just use backtrack as constraint is so small\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        max_or = 0\\n        for num in nums:max_or |= num\\n        self.res = 0\\n        def backtrack(ind,pref):\\n            if pref == max_or:self.res += 1\\n            if ind >= len(nums):return \\n            for i in range(ind,len(nums)):backtrack(i+1,pref|nums[i])\\n        backtrack(0,0)\\n        return self.res",
                "codeTag": "Java"
            },
            {
                "id": 4081631,
                "title": "from-78-subsets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all subsets possible using [78. Subsets](https://leetcode.com/problems/subsets/description/).\\n\\nThen find the number of subsets with max OR\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2^n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```python []\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxor=0\\n        subset,res=[],[]\\n        for n in nums:\\n          maxor|=n\\n        \\n        def subsets(nums: List[int]):\\n\\n          def backtrack(i):\\n              if i>=len(nums):\\n                  res.append(subset.copy())\\n                  return\\n              subset.append(nums[i])\\n              backtrack(i+1)\\n              subset.pop()\\n              backtrack(i+1)\\n          \\n          backtrack(0)\\n\\n        subsets(nums)\\n        ans=0\\n        for subset in res:\\n          m=0\\n          for l in subset:\\n            m|=l\\n          if m==maxor:\\n            ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxor=0\\n        subset,res=[],[]\\n        for n in nums:\\n          maxor|=n\\n        \\n        def subsets(nums: List[int]):\\n\\n          def backtrack(i):\\n              if i>=len(nums):\\n                  res.append(subset.copy())\\n                  return\\n              subset.append(nums[i])\\n              backtrack(i+1)\\n              subset.pop()\\n              backtrack(i+1)\\n          \\n          backtrack(0)\\n\\n        subsets(nums)\\n        ans=0\\n        for subset in res:\\n          m=0\\n          for l in subset:\\n            m|=l\\n          if m==maxor:\\n            ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037086,
                "title": "backtracking-c-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int> nums ,int index, int temp,int& count,int& maxi){\\n        if(index >=nums.size()){\\n            if(temp == maxi)\\n                count++;\\n            else if(temp>maxi){\\n                maxi = temp;\\n                count = 1;\\n            }\\n            return;\\n        }\\n        solve(nums,index+1,temp,count,maxi);\\n        temp = temp|nums[index];\\n        solve(nums,index+1,temp,count,maxi);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int count = 0;\\n        int maxi = INT_MIN;\\n        solve(nums,0,0,count,maxi);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> nums ,int index, int temp,int& count,int& maxi){\\n        if(index >=nums.size()){\\n            if(temp == maxi)\\n                count++;\\n            else if(temp>maxi){\\n                maxi = temp;\\n                count = 1;\\n            }\\n            return;\\n        }\\n        solve(nums,index+1,temp,count,maxi);\\n        temp = temp|nums[index];\\n        solve(nums,index+1,temp,count,maxi);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int count = 0;\\n        int maxi = INT_MIN;\\n        solve(nums,0,0,count,maxi);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010410,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    int res=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        //By using Backtracking\\n        int p=0;\\n        for(int i=0;i<nums.length;i++){\\n            p|=nums[i];\\n        }\\n        ArrayList<Integer> list=new ArrayList<>();\\n        Met(0,list,nums,p);\\n        return res;\\n    }\\n    public void Met(int index,ArrayList<Integer> list,int[] nums,int p){\\n        if(index==nums.length){\\n            int t=0;\\n            for(int i=0;i<list.size();i++){\\n                t|=list.get(i);\\n            }\\n            if(t==p){\\n                res++;\\n            }\\n            return;\\n        }\\n        list.add(nums[index]);\\n        Met(index+1,list,nums,p);\\n        list.remove(list.size()-1);\\n        Met(index+1,list,nums,p);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        //By using Backtracking\\n        int p=0;\\n        for(int i=0;i<nums.length;i++){\\n            p|=nums[i];\\n        }\\n        ArrayList<Integer> list=new ArrayList<>();\\n        Met(0,list,nums,p);\\n        return res;\\n    }\\n    public void Met(int index,ArrayList<Integer> list,int[] nums,int p){\\n        if(index==nums.length){\\n            int t=0;\\n            for(int i=0;i<list.size();i++){\\n                t|=list.get(i);\\n            }\\n            if(t==p){\\n                res++;\\n            }\\n            return;\\n        }\\n        list.add(nums[index]);\\n        Met(index+1,list,nums,p);\\n        list.remove(list.size()-1);\\n        Met(index+1,list,nums,p);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007828,
                "title": "2-approaches-i-using-simple-backtracking-ii-backtracking-hashmap",
                "content": "# Intuition\\n1- Problem is similer to subset sum problem, so we can solve it using backtracking.\\n2- We can use the hashmap for storing subset or\\'s.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    - For solution 1 : O(2^n)\\n    - For solution 2 : O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - For solution 1 : O(1)\\n    - For solution 2 : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n__Solution : 1__\\n```\\nclass Solution {\\npublic:\\nint maxor=0;\\nint cnt=0;\\nvoid recursion(vector<int>&nums, int i, int oor){\\n        if(i>=nums.size()){\\n            if(oor>maxor){\\n                cnt=1;\\n                maxor = oor;\\n            }else if(oor==maxor){\\n                cnt++;\\n            }\\n            return;\\n        }\\n        recursion(nums, i+1, oor | nums[i]);\\n        recursion(nums, i+1, oor);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int oor = 0;\\n        recursion(nums, 0, oor);\\n        return cnt;\\n    }\\n};\\n```\\n__Solution : 2__\\n```\\nclass Solution {\\npublic:\\nunordered_map<int, int>umap;\\nvoid recursion(vector<int>&nums, int i, int oor){\\n        if(i>=nums.size()){\\n            umap[oor]++;\\n            return;\\n        }\\n        recursion(nums, i+1, oor | nums[i]);\\n        recursion(nums, i+1, oor);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int oor = 0;\\n        recursion(nums, 0, oor);\\n        int ans=0;\\n        int maxor=0;\\n        for(auto i = umap.begin();i!=umap.end();i++){\\n            if(i->first>maxor){\\n                maxor = i->first;\\n                ans = i->second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxor=0;\\nint cnt=0;\\nvoid recursion(vector<int>&nums, int i, int oor){\\n        if(i>=nums.size()){\\n            if(oor>maxor){\\n                cnt=1;\\n                maxor = oor;\\n            }else if(oor==maxor){\\n                cnt++;\\n            }\\n            return;\\n        }\\n        recursion(nums, i+1, oor | nums[i]);\\n        recursion(nums, i+1, oor);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int oor = 0;\\n        recursion(nums, 0, oor);\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nunordered_map<int, int>umap;\\nvoid recursion(vector<int>&nums, int i, int oor){\\n        if(i>=nums.size()){\\n            umap[oor]++;\\n            return;\\n        }\\n        recursion(nums, i+1, oor | nums[i]);\\n        recursion(nums, i+1, oor);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int oor = 0;\\n        recursion(nums, 0, oor);\\n        int ans=0;\\n        int maxor=0;\\n        for(auto i = umap.begin();i!=umap.end();i++){\\n            if(i->first>maxor){\\n                maxor = i->first;\\n                ans = i->second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933960,
                "title": "easy-recursion",
                "content": "class Solution {\\npublic:\\n    \\n    int rec1(vector<int>& nums,int n,int i)\\n    {\\n        if(i<0)\\n            return 0;\\n        \\n        int notpick= rec1(nums,n,i-1);\\n        int pick= nums[i] | rec1(nums,n,i-1);\\n        \\n        return max(pick,notpick);\\n    }\\n    \\n    int rec(vector<int>& nums,int n, int i,int maxor,int curror)\\n    {\\n        if(i<0)\\n        {\\n            if(curror==maxor)\\n                return 1;\\n            \\n            return 0;\\n        }\\n        \\n        int notpick= rec(nums,n,i-1,maxor,curror);\\n        int pick= rec(nums,n,i-1,maxor,curror|nums[i]);\\n        \\n        return pick+notpick;\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n= nums.size();\\n        \\n        int maxor= rec1(nums,n,n-1);\\n        \\n        return rec(nums,n,n-1,maxor,0);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int rec1(vector<int>& nums,int n,int i)\\n    {\\n        if(i<0)\\n            return 0;\\n        \\n        int notpick= rec1(nums,n,i-1);\\n        int pick= nums[i] | rec1(nums,n,i-1);\\n        \\n        return max(pick,notpick);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3927880,
                "title": "short-solution-100",
                "content": "\\n```\\npublic class Solution {\\n    public int run(int val, int i, int[] nums, int max)\\n    {\\n        if (i >= nums.Length)        \\n            return val == max ? 1 : 0;\\n        else\\n            return run(val          , i + 1, nums, max) + \\n                   run(val | nums[i], i + 1, nums, max);\\n    }\\n\\n    public int CountMaxOrSubsets(int[] nums) {       \\n        return run(0, 0, nums, nums.Aggregate(0, (t, n) => t | n));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int run(int val, int i, int[] nums, int max)\\n    {\\n        if (i >= nums.Length)        \\n            return val == max ? 1 : 0;\\n        else\\n            return run(val          , i + 1, nums, max) + \\n                   run(val | nums[i], i + 1, nums, max);\\n    }\\n\\n    public int CountMaxOrSubsets(int[] nums) {       \\n        return run(0, 0, nums, nums.Aggregate(0, (t, n) => t | n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909680,
                "title": "optimal-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&n , int t , int idx , int curr){\\n        if(idx==n.size()){\\n            if(t==curr){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int in = solve(n , t , idx+1 , curr|n[idx]);\\n        int nin = solve(n , t , idx+1 , curr);\\n        return in+nin;\\n    }\\n    int countMaxOrSubsets(vector<int>&n){\\n        int t=0;\\n        for(auto i:n){\\n            t|=i;\\n        }\\n        return solve(n , t , 0 , 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&n , int t , int idx , int curr){\\n        if(idx==n.size()){\\n            if(t==curr){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int in = solve(n , t , idx+1 , curr|n[idx]);\\n        int nin = solve(n , t , idx+1 , curr);\\n        return in+nin;\\n    }\\n    int countMaxOrSubsets(vector<int>&n){\\n        int t=0;\\n        for(auto i:n){\\n            t|=i;\\n        }\\n        return solve(n , t , 0 , 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866560,
                "title": "easy-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\n    void f(int ind,int orr,int& count,int maxi,int n,vector<int>& nums){\\n        if(ind>=n){\\n            if(maxi==orr) count++;\\n            return ;\\n        }\\n\\n        //pick\\n        int org=orr;\\n        orr|=nums[ind];\\n        f(ind+1,orr,count,maxi,n,nums);\\n        orr=org;\\n\\n        //not pick\\n        f(ind+1,orr,count,maxi,n,nums);\\n\\n    }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi=0;\\n        int count=0;\\n        for(auto i:nums){\\n            maxi|=i;\\n        }\\n        f(0,0,count,maxi,nums.size(),nums);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void f(int ind,int orr,int& count,int maxi,int n,vector<int>& nums){\\n        if(ind>=n){\\n            if(maxi==orr) count++;\\n            return ;\\n        }\\n\\n        //pick\\n        int org=orr;\\n        orr|=nums[ind];\\n        f(ind+1,orr,count,maxi,n,nums);\\n        orr=org;\\n\\n        //not pick\\n        f(ind+1,orr,count,maxi,n,nums);\\n\\n    }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi=0;\\n        int count=0;\\n        for(auto i:nums){\\n            maxi|=i;\\n        }\\n        f(0,0,count,maxi,nums.size(),nums);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864851,
                "title": "backtracking-solution-with-slight-optimization",
                "content": "# Code\\n```\\n\\nfunction countMaxOrSubsets(nums: number[]): number {\\n    let max = nums.reduce((a,b)=>a|b,0);\\n    let count=0;\\n    let subset=[];\\n    dfs(0,0)\\n    return count;\\n\\n    function dfs(idx,bor){\\n        if(bor===max) {\\n            count+=(2**(nums.length-idx)); // here if at any point bitwise OR (bor) is max then all the rest possibilities will also be added to count\\n// all the possible arrays are counted (2**(nums.length-idx)\\n// note this will reduce the runtime in some cases not all\\n//but those particular cases can even cut down runtime to o(n) as in case of [2,2,2,2,2] (best case)\\n            return;\\n            }\\n        for(let i=idx;i<nums.length;i++){\\n           subset.push(nums[i]);\\n            dfs(i+1,bor|nums[i]);\\n            subset.pop();\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nfunction countMaxOrSubsets(nums: number[]): number {\\n    let max = nums.reduce((a,b)=>a|b,0);\\n    let count=0;\\n    let subset=[];\\n    dfs(0,0)\\n    return count;\\n\\n    function dfs(idx,bor){\\n        if(bor===max) {\\n            count+=(2**(nums.length-idx)); // here if at any point bitwise OR (bor) is max then all the rest possibilities will also be added to count\\n// all the possible arrays are counted (2**(nums.length-idx)\\n// note this will reduce the runtime in some cases not all\\n//but those particular cases can even cut down runtime to o(n) as in case of [2,2,2,2,2] (best case)\\n            return;\\n            }\\n        for(let i=idx;i<nums.length;i++){\\n           subset.push(nums[i]);\\n            dfs(i+1,bor|nums[i]);\\n            subset.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851462,
                "title": "solution-in-go-using-backtracking",
                "content": "# Code\\n```\\nfunc countMaxOrSubsets(nums []int) int {\\n    max := findMax(nums)\\n    cnt := 0\\n\\n    var bt func([]int, int, int)\\n    bt = func(nums []int, cur int, index int) {\\n        if index > len(nums) {\\n            return\\n        }\\n        \\n        for i := index; i < len(nums); i ++ {\\n            temp := cur | nums[i]\\n            if temp == max {\\n                cnt ++\\n            }\\n            bt(nums, temp, i+1)\\n        }\\n    }\\n\\n    bt(nums, 0, 0) \\n    return cnt  \\n}\\n\\nfunc findMax(nums []int) int {\\n    max := nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        max |= nums[i]\\n    }\\n    return max\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc countMaxOrSubsets(nums []int) int {\\n    max := findMax(nums)\\n    cnt := 0\\n\\n    var bt func([]int, int, int)\\n    bt = func(nums []int, cur int, index int) {\\n        if index > len(nums) {\\n            return\\n        }\\n        \\n        for i := index; i < len(nums); i ++ {\\n            temp := cur | nums[i]\\n            if temp == max {\\n                cnt ++\\n            }\\n            bt(nums, temp, i+1)\\n        }\\n    }\\n\\n    bt(nums, 0, 0) \\n    return cnt  \\n}\\n\\nfunc findMax(nums []int) int {\\n    max := nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        max |= nums[i]\\n    }\\n    return max\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3838955,
                "title": "recursion-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\uD83D\\uDD39 The problem requires counting the number of subsets whose bitwise OR is maximum among all subsets of the given array.\\n\\uD83D\\uDD39 The bitwise OR operation combines bits from different numbers, setting each bit in the result to 1 if it exists in any of the numbers.\\n\\uD83D\\uDD39 We need to explore all possible subsets of the given array to find the maximum OR value and count how many subsets have this maximum value\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD83D\\uDD39 We can use a backtracking algorithm to explore all possible subsets of the array.\\n\\uD83D\\uDD39 The backtracking function helper is used to generate subsets and calculate their bitwise OR.\\n\\uD83D\\uDD39 At each step of the recursion, we have two choices: include the current element in the subset or skip it.\\n\\uD83D\\uDD39 The function keeps track of the current OR value (Total_OR) while generating subsets.\\n\\uD83D\\uDD39 The backtracking function uses a map (MyMap) to store the count of different OR values encountered during exploration.\\n\\uD83D\\uDD39 Finally, we find the maximum OR value and return its count as the answer.\\n# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &nums, int index, int Total_OR, unordered_map<int,int> &MyMap){\\n        // Base Case\\n        if(index >= nums.size()){\\n            MyMap[Total_OR]++;\\n            return ;\\n        }\\n\\n        // Don\\'t Choose current\\n        helper(nums, index + 1, Total_OR, MyMap);\\n\\n        // Choose current\\n        if(Total_OR == INT_MIN){\\n            helper(nums, index + 1, nums[index] , MyMap);\\n        }\\n        else{\\n            helper(nums, index + 1 , Total_OR | nums[index] , MyMap);\\n        }\\n\\n        return ;\\n    };\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        unordered_map<int,int> MyMap;\\n        helper(nums, 0,INT_MIN, MyMap);\\n\\n        int max_output = INT_MIN;\\n        for(auto it = MyMap.begin() ; it != MyMap.end() ; ++it){\\n            max_output = max(max_output , it->first);\\n        }\\n\\n        return MyMap[max_output];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &nums, int index, int Total_OR, unordered_map<int,int> &MyMap){\\n        // Base Case\\n        if(index >= nums.size()){\\n            MyMap[Total_OR]++;\\n            return ;\\n        }\\n\\n        // Don\\'t Choose current\\n        helper(nums, index + 1, Total_OR, MyMap);\\n\\n        // Choose current\\n        if(Total_OR == INT_MIN){\\n            helper(nums, index + 1, nums[index] , MyMap);\\n        }\\n        else{\\n            helper(nums, index + 1 , Total_OR | nums[index] , MyMap);\\n        }\\n\\n        return ;\\n    };\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        unordered_map<int,int> MyMap;\\n        helper(nums, 0,INT_MIN, MyMap);\\n\\n        int max_output = INT_MIN;\\n        for(auto it = MyMap.begin() ; it != MyMap.end() ; ++it){\\n            max_output = max(max_output , it->first);\\n        }\\n\\n        return MyMap[max_output];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823476,
                "title": "c-backtracking-solution",
                "content": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n\\tint res = 0, maxOR = 0;\\n\\tfor (const int& n : nums)\\n\\t\\tmaxOR |= n;\\n\\n\\tvector<int> subs { 0 };\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tint sz = subs.size();\\n\\t\\tfor (int j = 0; j < sz; j++) {\\n\\t\\t\\tsubs.push_back(subs[j]);\\n\\t\\t\\tsubs.back() |= nums[i];\\n\\t\\t\\tres += subs.back() == maxOR ? 1 : 0;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Iterator"
                ],
                "code": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n\\tint res = 0, maxOR = 0;\\n\\tfor (const int& n : nums)\\n\\t\\tmaxOR |= n;\\n\\n\\tvector<int> subs { 0 };\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tint sz = subs.size();\\n\\t\\tfor (int j = 0; j < sz; j++) {\\n\\t\\t\\tsubs.push_back(subs[j]);\\n\\t\\t\\tsubs.back() |= nums[i];\\n\\t\\t\\tres += subs.back() == maxOR ? 1 : 0;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3800609,
                "title": "easy-to-understand-backtracking-with-optimisation-beats-86-on-time",
                "content": "# Intuition\\nNotice a few things:\\n1. The max xor of any subset is the xor of all numbers in input array\\n2. There can be one or more subsets where its xor equals the max xor. If we find such a subset, we can use math to calculate number of possible subsets from the remaining elements.\\n\\ne.g [7 (bits 111), 1, 2, 4]\\n[7] has max xor. Number of subsets including 7 is all ways of choosing [1, 2, 4]\\nNumber = 2 ^ 3\\n\\n# Approach\\nWe use the usual  backtracking approach, passing the current xor down to each recursive call. \\nIf the current xor is not the max xor yet, we try 2 cases:\\n1) Include current number in xor\\n2) Don\\'t include current number in xor\\n\\nIf the current xor is the max, we use math like above to calculate the number of subsets from here, saving time.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nO(2^n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxor = 0\\n        for num in nums:\\n            maxor = maxor | num\\n\\n        return self.helper(nums, 0, maxor, 0)\\n\\n    def helper(self, nums: List[int], i: int, maxor: int, curxor: int) -> int:\\n        if curxor == maxor:\\n            remaining = len(nums) - i\\n            return 2 ** remaining\\n\\n        if i == len(nums):\\n            return 0\\n\\n        return self.helper(nums, i+1, maxor, curxor | nums[i]) + self.helper(nums, i+1, maxor, curxor)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxor = 0\\n        for num in nums:\\n            maxor = maxor | num\\n\\n        return self.helper(nums, 0, maxor, 0)\\n\\n    def helper(self, nums: List[int], i: int, maxor: int, curxor: int) -> int:\\n        if curxor == maxor:\\n            remaining = len(nums) - i\\n            return 2 ** remaining\\n\\n        if i == len(nums):\\n            return 0\\n\\n        return self.helper(nums, i+1, maxor, curxor | nums[i]) + self.helper(nums, i+1, maxor, curxor)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789638,
                "title": "simple-beginner-friendly-recursiom",
                "content": "# Approach\\ncheck the maximum or of nums array\\nfind all subsets\\ncompare each subset with maximum or\\n\\n# Complexity\\n- Time complexity:\\nO(2^n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0,ans=0;\\n        for(auto &num:nums) x|=num;\\n        vector<int> curr;\\n        solve(0,curr,nums,ans,x);\\n        return ans;\\n    }\\n    void solve(int ind,vector<int> &curr,vector<int> &nums,int &ans,int x){\\n        if(isPossible(curr,x)) ans++;\\n        for(int i=ind;i<nums.size();i++){\\n            curr.push_back(nums[i]);\\n            solve(i+1,curr,nums,ans,x);\\n            curr.pop_back();\\n        }\\n    }\\n    bool isPossible(vector<int> &arr,int x){\\n        int y=0;\\n        for(auto &num:arr)y|=num;\\n        return x==y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0,ans=0;\\n        for(auto &num:nums) x|=num;\\n        vector<int> curr;\\n        solve(0,curr,nums,ans,x);\\n        return ans;\\n    }\\n    void solve(int ind,vector<int> &curr,vector<int> &nums,int &ans,int x){\\n        if(isPossible(curr,x)) ans++;\\n        for(int i=ind;i<nums.size();i++){\\n            curr.push_back(nums[i]);\\n            solve(i+1,curr,nums,ans,x);\\n            curr.pop_back();\\n        }\\n    }\\n    bool isPossible(vector<int> &arr,int x){\\n        int y=0;\\n        for(auto &num:arr)y|=num;\\n        return x==y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771874,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        List<Integer> ds = new ArrayList<>();\\n        List<Integer> OR = new ArrayList<>();\\n        DFS(0,nums,ds,OR);\\n        return maxcount(OR);\\n\\n        \\n    }\\n    public static void DFS(int ind,int[] nums,List<Integer> ds,List<Integer> OR){\\n        if(ind==nums.length){\\n            int a = ListOr(ds);\\n            OR.add(a);\\n            return;\\n        }\\n        ds.add(nums[ind]);\\n        DFS(ind+1,nums,ds,OR);\\n        ds.remove(ds.size()-1);\\n        DFS(ind+1,nums,ds,OR);\\n    }\\n    public static int maxcount(List<Integer> ds){\\n        if(ds == null || ds.isEmpty()){\\n            return 0;\\n        }\\n         int maxElement = ds.get(0);\\n        int maxCount = 1;\\n\\n         for (int i = 1; i < ds.size(); i++) {\\n            int currentElement = ds.get(i);\\n            if (currentElement > maxElement) {\\n                maxElement = currentElement;\\n                maxCount = 1;\\n            } else if (currentElement == maxElement) {\\n                maxCount++;\\n            }\\n        }\\n\\n        return maxCount;\\n    }\\n    public static int ListOr(List<Integer> OR){\\n         if(OR == null || OR.isEmpty()){\\n            return 0;\\n        \\n        }\\n         int result = OR.get(0);\\n        for (int i = 1; i < OR.size(); i++) {\\n            result |= OR.get(i);\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        List<Integer> ds = new ArrayList<>();\\n        List<Integer> OR = new ArrayList<>();\\n        DFS(0,nums,ds,OR);\\n        return maxcount(OR);\\n\\n        \\n    }\\n    public static void DFS(int ind,int[] nums,List<Integer> ds,List<Integer> OR){\\n        if(ind==nums.length){\\n            int a = ListOr(ds);\\n            OR.add(a);\\n            return;\\n        }\\n        ds.add(nums[ind]);\\n        DFS(ind+1,nums,ds,OR);\\n        ds.remove(ds.size()-1);\\n        DFS(ind+1,nums,ds,OR);\\n    }\\n    public static int maxcount(List<Integer> ds){\\n        if(ds == null || ds.isEmpty()){\\n            return 0;\\n        }\\n         int maxElement = ds.get(0);\\n        int maxCount = 1;\\n\\n         for (int i = 1; i < ds.size(); i++) {\\n            int currentElement = ds.get(i);\\n            if (currentElement > maxElement) {\\n                maxElement = currentElement;\\n                maxCount = 1;\\n            } else if (currentElement == maxElement) {\\n                maxCount++;\\n            }\\n        }\\n\\n        return maxCount;\\n    }\\n    public static int ListOr(List<Integer> OR){\\n         if(OR == null || OR.isEmpty()){\\n            return 0;\\n        \\n        }\\n         int result = OR.get(0);\\n        for (int i = 1; i < OR.size(); i++) {\\n            result |= OR.get(i);\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742119,
                "title": "c-target-or-take-nottake-dp-solution-easy-to-understand",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*(OR of array))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n*(OR of array))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int func(int ind,int mask,int tar,vector<int>&v){\\n        if(ind<0){\\n            if(mask==tar){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[ind][mask]!=-1) return dp[ind][mask];\\n        int nt=func(ind-1,mask,tar,v);\\n        int t=func(ind-1,mask|v[ind],tar,v);\\n        return dp[ind][mask]= t+nt;\\n    }\\n    int countMaxOrSubsets(vector<int>& v) {\\n        int tar=0;\\n        for(auto it:v) tar|=it;\\n        int n=v.size();\\n        dp=vector<vector<int>>(n,vector<int>(tar+1,-1));\\n        return func(n-1,0,tar,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int func(int ind,int mask,int tar,vector<int>&v){\\n        if(ind<0){\\n            if(mask==tar){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[ind][mask]!=-1) return dp[ind][mask];\\n        int nt=func(ind-1,mask,tar,v);\\n        int t=func(ind-1,mask|v[ind],tar,v);\\n        return dp[ind][mask]= t+nt;\\n    }\\n    int countMaxOrSubsets(vector<int>& v) {\\n        int tar=0;\\n        for(auto it:v) tar|=it;\\n        int n=v.size();\\n        dp=vector<vector<int>>(n,vector<int>(tar+1,-1));\\n        return func(n-1,0,tar,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735453,
                "title": "c-subset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\n    bool isBitSet(int iteration, int bit)\\n    {\\n        int temp  = 1<<bit;\\n        if((temp & iteration))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {\\n        int n = pow(2, nums.size());\\n        unordered_map<int, int> uniqueSum;\\n        int maxCount = INT_MIN;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(isBitSet(i,j))\\n                {\\n                    sum = sum | nums[j];\\n                }\\n            }\\n            uniqueSum[sum]++;\\n            if(maxCount<uniqueSum[sum])\\n            {\\n                maxCount=uniqueSum[sum];\\n            }\\n        }\\n\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    bool isBitSet(int iteration, int bit)\\n    {\\n        int temp  = 1<<bit;\\n        if((temp & iteration))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {\\n        int n = pow(2, nums.size());\\n        unordered_map<int, int> uniqueSum;\\n        int maxCount = INT_MIN;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(isBitSet(i,j))\\n                {\\n                    sum = sum | nums[j];\\n                }\\n            }\\n            uniqueSum[sum]++;\\n            if(maxCount<uniqueSum[sum])\\n            {\\n                maxCount=uniqueSum[sum];\\n            }\\n        }\\n\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722527,
                "title": "simple-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&v, int i, int &mx, int&cnt, int r){\\n        if(i>=v.size()){\\n            if(r>mx){\\n                mx=r;\\n                cnt = 1;\\n            }\\n            else if(r==mx){\\n                cnt++;\\n            }\\n            return;\\n        }\\n        solve(v, i+1, mx, cnt, r|v[i]);\\n        solve(v, i+1, mx, cnt, r);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {   \\n         int mx=0,cnt=0,r=0;\\n         solve(nums, 0, mx, cnt, r);\\n         return cnt;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&v, int i, int &mx, int&cnt, int r){\\n        if(i>=v.size()){\\n            if(r>mx){\\n                mx=r;\\n                cnt = 1;\\n            }\\n            else if(r==mx){\\n                cnt++;\\n            }\\n            return;\\n        }\\n        solve(v, i+1, mx, cnt, r|v[i]);\\n        solve(v, i+1, mx, cnt, r);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {   \\n         int mx=0,cnt=0,r=0;\\n         solve(nums, 0, mx, cnt, r);\\n         return cnt;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720514,
                "title": "simple-approach-backtracking",
                "content": "# Intuition\\nfirst we calculate the maximum or possible and then we will find all the possible candidate which can give that or and at the end store the count of them\\n\\n# Approach\\nwe will iterate through all possible subsequences of nums and check which all can give maximun or and store the count\\n\\n# Complexity\\n- Time complexity:\\nO(n*2^n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maxi |=nums[i];\\n        }\\n        int n=nums.size();\\n        int tot=(1<<n);\\n        int count=0;\\n        for(int i=0; i<tot; i++){\\n            int temp=0;\\n            for(int j=0; j<n; j++){\\n                if(i & (1<<j)){\\n                    temp |=nums[j];\\n                }\\n            }\\n            if(temp==maxi){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maxi |=nums[i];\\n        }\\n        int n=nums.size();\\n        int tot=(1<<n);\\n        int count=0;\\n        for(int i=0; i<tot; i++){\\n            int temp=0;\\n            for(int j=0; j<n; j++){\\n                if(i & (1<<j)){\\n                    temp |=nums[j];\\n                }\\n            }\\n            if(temp==maxi){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719067,
                "title": "short-naive-solution-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res;\\n    void solve(vector<int>&v,int target,int count,int temp){\\n        if(count==v.size()){\\n            if(target==temp) res++;\\n            return ;\\n        }\\n        solve(v,target,count+1,temp|v[count]);\\n        solve(v,target,count+1,temp);\\n    }\\n    int countMaxOrSubsets(vector<int>& v) {\\n        int target=0;\\n        int n=v.size();\\n        for(int i=0;i<n;i++) target=target|v[i];\\n        int count=0;\\n        int temp=0;\\n        res=0;\\n        solve(v,target,count,temp);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res;\\n    void solve(vector<int>&v,int target,int count,int temp){\\n        if(count==v.size()){\\n            if(target==temp) res++;\\n            return ;\\n        }\\n        solve(v,target,count+1,temp|v[count]);\\n        solve(v,target,count+1,temp);\\n    }\\n    int countMaxOrSubsets(vector<int>& v) {\\n        int target=0;\\n        int n=v.size();\\n        for(int i=0;i<n;i++) target=target|v[i];\\n        int count=0;\\n        int temp=0;\\n        res=0;\\n        solve(v,target,count,temp);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714158,
                "title": "c-implementation-using-recursion-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int num,vector<int> &nums,vector<int> &tmp){\\n        if(i==nums.size()){\\n            int c=0;\\n            for(auto x:tmp){\\n                c=c|x;\\n            }\\n            return c==num?1:0;\\n        }\\n        int ans=f(i+1,num,nums,tmp);\\n        tmp.push_back(nums[i]);\\n        int ans2=f(i+1,num,nums,tmp);\\n        tmp.pop_back();\\n        return ans+ans2;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int num=0;\\n        for(auto x:nums){\\n            num=num|x;\\n        }\\n        vector<int>tmp;\\n        return f(0,num,nums,tmp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int num,vector<int> &nums,vector<int> &tmp){\\n        if(i==nums.size()){\\n            int c=0;\\n            for(auto x:tmp){\\n                c=c|x;\\n            }\\n            return c==num?1:0;\\n        }\\n        int ans=f(i+1,num,nums,tmp);\\n        tmp.push_back(nums[i]);\\n        int ans2=f(i+1,num,nums,tmp);\\n        tmp.pop_back();\\n        return ans+ans2;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int num=0;\\n        for(auto x:nums){\\n            num=num|x;\\n        }\\n        vector<int>tmp;\\n        return f(0,num,nums,tmp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709907,
                "title": "easiest-solution-with-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        int findans(int target, vector<int> &nums, int i, int n, int cal_or)\\n        {\\n            if (i == n)\\n            {\\n                if (cal_or == target)\\n                {\\n                    return 1;\\n                }\\n                else return 0;\\n            }\\n            int take=findans(target, nums, i+1, n, cal_or|nums[i]);\\n         \\n            int nontake=findans(target, nums, i+1, n, cal_or);\\n            return take+nontake;\\n        }\\n    int countMaxOrSubsets(vector<int> &nums)\\n    {\\n        int orred = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            orred |= nums[i];\\n        }\\n        int cal_or = 0;\\n        return findans(orred, nums, 0, nums.size(), cal_or);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int findans(int target, vector<int> &nums, int i, int n, int cal_or)\\n        {\\n            if (i == n)\\n            {\\n                if (cal_or == target)\\n                {\\n                    return 1;\\n                }\\n                else return 0;\\n            }\\n            int take=findans(target, nums, i+1, n, cal_or|nums[i]);\\n         \\n            int nontake=findans(target, nums, i+1, n, cal_or);\\n            return take+nontake;\\n        }\\n    int countMaxOrSubsets(vector<int> &nums)\\n    {\\n        int orred = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            orred |= nums[i];\\n        }\\n        int cal_or = 0;\\n        return findans(orred, nums, 0, nums.size(), cal_or);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695045,
                "title": "java-backtracking-memo-beats-95",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    \\n    public int countMaxOrSubsets(int[] arr) {\\n        var max = 0;\\n        for (var num:arr) max|=num;\\n        return traverse(arr,0,0,max);\\n    }\\n    \\n    public int traverse(int[] arr, int idx, int or, int max){\\n        if (idx==arr.length) return or==max?1:0;\\n        var key = key(idx,or);\\n        if (map.containsKey(key)) return map.get(key);\\n        var res = traverse(arr,idx+1,or|arr[idx],max) + traverse(arr,idx+1,or,max);\\n        map.put(key,res);\\n        return res;\\n    }\\n    \\n    public int key(int idx, int or){\\n        return idx*10_000_000+or;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    \\n    public int countMaxOrSubsets(int[] arr) {\\n        var max = 0;\\n        for (var num:arr) max|=num;\\n        return traverse(arr,0,0,max);\\n    }\\n    \\n    public int traverse(int[] arr, int idx, int or, int max){\\n        if (idx==arr.length) return or==max?1:0;\\n        var key = key(idx,or);\\n        if (map.containsKey(key)) return map.get(key);\\n        var res = traverse(arr,idx+1,or|arr[idx],max) + traverse(arr,idx+1,or,max);\\n        map.put(key,res);\\n        return res;\\n    }\\n    \\n    public int key(int idx, int or){\\n        return idx*10_000_000+or;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684646,
                "title": "simple-java-solution-using-backtracking-brute-force",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe calculate the XOR of subsets as we create subsets and when we reach at the leaf node we compare it with max result. If we get result greater than max then we update max and reset result to 1 otherwise if max is equal to the value we increase the result by one else if the value is less than max we don\\'t do anything. \\n\\n# Code\\n```\\nclass Solution {\\n    int max=0;\\n    int res=0;\\n    private void solve(int[] nums,int curr,int v){\\n        if(curr==nums.length){\\n            if(v>max){\\n                max=v;\\n                res=1;\\n            }\\n            else if(v==max)\\n            {\\n                res++;\\n            }\\n            return;\\n        }\\n        solve(nums,curr+1,v);\\n        solve(nums,curr+1,(v|nums[curr]));\\n    }\\n    public int countMaxOrSubsets(int[] nums) {\\n        solve(nums,0,0);\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    int res=0;\\n    private void solve(int[] nums,int curr,int v){\\n        if(curr==nums.length){\\n            if(v>max){\\n                max=v;\\n                res=1;\\n            }\\n            else if(v==max)\\n            {\\n                res++;\\n            }\\n            return;\\n        }\\n        solve(nums,curr+1,v);\\n        solve(nums,curr+1,(v|nums[curr]));\\n    }\\n    public int countMaxOrSubsets(int[] nums) {\\n        solve(nums,0,0);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673689,
                "title": "counting-subsets-with-maximum-bitwise-or-value-using-backtracking",
                "content": "\\n# Approach\\n\\nTo count the number of subsets from the given array `nums` such that the bitwise OR of all the elements in the subset is maximum, we can use a backtracking algorithm. The backtracking approach allows us to explore all possible subsets without explicitly storing them.\\n\\nThe algorithm follows these steps:\\n\\n1. Initialize a variable `maxVal` to store the maximum OR value among all elements in `nums`. We can calculate `maxVal` by performing a bitwise OR operation on all the elements in `nums`.\\n\\n2. Initialize a count variable `count` to keep track of the number of subsets with the maximum OR value.\\n\\n3. Implement a backtracking function, `backTrack`, that takes two parameters: `start` and `curOr`.\\n\\n4. In the `backTrack` function:\\n   - Check if `curOr` is equal to `maxVal`. If it is, increment `count` by 1 to signify that a subset with the maximum OR value has been found.\\n   - Iterate over the elements in `nums` starting from the `start` index:\\n     - Recursively call the `backTrack` function with the next index (`j + 1`) and the updated `curOr` obtained by performing a bitwise OR operation between `curOr` and `nums[j]`.\\n\\n5. Return the value of `count` as the result.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) Auxiliary space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countMaxOrSubsets = function(nums) {\\n    \\n    let maxVal = nums.reduce((cur, pre)=> cur|pre, 0);\\n    let count = 0\\n    \\n    function backTrack(start, curOr) {\\n        if(curOr === maxVal) count++\\n\\n        for (let j = start; j < n; j++)  backTrack(j + 1, curOr  | nums[j]);\\n    }\\n\\n    const n = nums.length;\\n\\n    backTrack(0, 0);\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countMaxOrSubsets = function(nums) {\\n    \\n    let maxVal = nums.reduce((cur, pre)=> cur|pre, 0);\\n    let count = 0\\n    \\n    function backTrack(start, curOr) {\\n        if(curOr === maxVal) count++\\n\\n        for (let j = start; j < n; j++)  backTrack(j + 1, curOr  | nums[j]);\\n    }\\n\\n    const n = nums.length;\\n\\n    backTrack(0, 0);\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657860,
                "title": "java-solution-recursive-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    int res=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        List<Integer> l=new ArrayList<>();\\n        subset(0,nums,l);\\n        return res;\\n    }\\n    void subset(int i,int nums[],List<Integer> l){\\n        if(i==nums.length){\\n            int s=0;\\n            for(int j:l){\\n                s|=j;\\n            }\\n            if(s>max){\\n                res=1;\\n                max=s;\\n            }\\n            else if(s==max){\\n                res++;\\n            }\\n            return;\\n        }\\n        l.add(nums[i]);\\n        subset(i+1,nums,l);\\n        l.remove(l.size()-1);\\n        subset(i+1,nums,l);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    int res=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        List<Integer> l=new ArrayList<>();\\n        subset(0,nums,l);\\n        return res;\\n    }\\n    void subset(int i,int nums[],List<Integer> l){\\n        if(i==nums.length){\\n            int s=0;\\n            for(int j:l){\\n                s|=j;\\n            }\\n            if(s>max){\\n                res=1;\\n                max=s;\\n            }\\n            else if(s==max){\\n                res++;\\n            }\\n            return;\\n        }\\n        l.add(nums[i]);\\n        subset(i+1,nums,l);\\n        l.remove(l.size()-1);\\n        subset(i+1,nums,l);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651709,
                "title": "easiest-c-solution",
                "content": "\\n# Complexity\\n- Time complexity: *O(2^n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(2^n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxor = INT_MIN, ans=0; \\n    void helper(vector<int>& v){\\n        int n =0;\\n        for(int i=0; i<v.size(); i++){\\n            n = n | v[i];\\n        }\\n        if(n == maxor) ans++;\\n        else if(n>maxor){\\n            maxor = n;\\n            ans=1;\\n        }\\n    }\\n    void solve(vector<int>& nums,vector<int>& v,int i){\\n        for(; i<nums.size(); i++){\\n            v.push_back(nums[i]);\\n            helper(v);\\n            solve(nums, v, i+1);\\n            v.pop_back();\\n        }\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vector<int> v;\\n        solve(nums, v, 0);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxor = INT_MIN, ans=0; \\n    void helper(vector<int>& v){\\n        int n =0;\\n        for(int i=0; i<v.size(); i++){\\n            n = n | v[i];\\n        }\\n        if(n == maxor) ans++;\\n        else if(n>maxor){\\n            maxor = n;\\n            ans=1;\\n        }\\n    }\\n    void solve(vector<int>& nums,vector<int>& v,int i){\\n        for(; i<nums.size(); i++){\\n            v.push_back(nums[i]);\\n            helper(v);\\n            solve(nums, v, i+1);\\n            v.pop_back();\\n        }\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vector<int> v;\\n        solve(nums, v, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616613,
                "title": "simple-recursive-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>& nums ,int crnt ,int idx ,int goal ){\\n\\n        //base case\\n        if(idx>=nums.size()) return 0;\\n        \\n        int ans = 0;\\n        if((crnt | nums[idx])==goal){\\n            ans=1;\\n        }\\n\\n        return ans + solve(nums ,crnt ,idx+1 ,goal )+solve(nums ,crnt|nums[idx] ,idx+1 ,goal);\\n\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int goal =  0;\\n        for(auto x: nums){\\n            goal|=x;\\n        }\\n\\n        return solve(nums ,0 , 0 ,goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>& nums ,int crnt ,int idx ,int goal ){\\n\\n        //base case\\n        if(idx>=nums.size()) return 0;\\n        \\n        int ans = 0;\\n        if((crnt | nums[idx])==goal){\\n            ans=1;\\n        }\\n\\n        return ans + solve(nums ,crnt ,idx+1 ,goal )+solve(nums ,crnt|nums[idx] ,idx+1 ,goal);\\n\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int goal =  0;\\n        for(auto x: nums){\\n            goal|=x;\\n        }\\n\\n        return solve(nums ,0 , 0 ,goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575171,
                "title": "python-very-easy-bactracing-4-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        ans = []\\n        def bac(start , path , s):\\n            ans.append(path)\\n            for i in range(start , len(s)):\\n                bac(i+1 , path|s[i] , s)\\n        bac(0,0,nums)\\n        ans = Counter(ans)\\n        return max(ans.values())\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        ans = []\\n        def bac(start , path , s):\\n            ans.append(path)\\n            for i in range(start , len(s)):\\n                bac(i+1 , path|s[i] , s)\\n        bac(0,0,nums)\\n        ans = Counter(ans)\\n        return max(ans.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573811,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:         \\n    def countMaxOrSubsets(self, nums):\\n        n = len(nums)\\n\\n        def backtrack(idx,path):\\n            if path:\\n                dict1[path] += 1\\n\\n            for i in range(idx,n):\\n                backtrack(i+1,path|nums[i])\\n\\n        dict1 = defaultdict(int)\\n\\n        backtrack(0,0)\\n\\n        return dict1[max(dict1.keys())]\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:         \\n    def countMaxOrSubsets(self, nums):\\n        n = len(nums)\\n\\n        def backtrack(idx,path):\\n            if path:\\n                dict1[path] += 1\\n\\n            for i in range(idx,n):\\n                backtrack(i+1,path|nums[i])\\n\\n        dict1 = defaultdict(int)\\n\\n        backtrack(0,0)\\n\\n        return dict1[max(dict1.keys())]\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567789,
                "title": "bits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n=nums.size(),bit_orr=0;\\n        for(int x=0;x<n;x++)bit_orr|=nums[x];\\n        int ans=0;\\n        bitset<17>mask;mask=0;\\n        while(mask.to_ulong()<(1<<n)){\\n            int or_b=0;\\n            for(int x=0;x<n;x++){\\n                if(mask[x])or_b|=nums[x];\\n            }\\n            if(or_b==bit_orr)ans++;\\n            mask=mask.to_ulong()+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n=nums.size(),bit_orr=0;\\n        for(int x=0;x<n;x++)bit_orr|=nums[x];\\n        int ans=0;\\n        bitset<17>mask;mask=0;\\n        while(mask.to_ulong()<(1<<n)){\\n            int or_b=0;\\n            for(int x=0;x<n;x++){\\n                if(mask[x])or_b|=nums[x];\\n            }\\n            if(or_b==bit_orr)ans++;\\n            mask=mask.to_ulong()+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544332,
                "title": "java-backtracking-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int[]arr = new int[2];\\n    public int k =0;\\n    public void helper(int[]nums,int index,int or,int count){\\n        if(k == count){\\n            if(or == arr[0]){\\n                arr[1]++;\\n            }\\n            else if(or > arr[0]){\\n                arr[1] = 1;\\n                arr[0] = or;\\n            }\\n            return;\\n        }\\n        for(int i = index;i < nums.length;i++){\\n            count++;\\n            helper(nums,i+1,or | nums[i],count);\\n            count--;\\n        }\\n    }\\n    public int countMaxOrSubsets(int[] nums) {\\n        for(k = 1;k <= nums.length;k++){\\n            helper(nums,0,0,0);\\n        }\\n        return arr[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[]arr = new int[2];\\n    public int k =0;\\n    public void helper(int[]nums,int index,int or,int count){\\n        if(k == count){\\n            if(or == arr[0]){\\n                arr[1]++;\\n            }\\n            else if(or > arr[0]){\\n                arr[1] = 1;\\n                arr[0] = or;\\n            }\\n            return;\\n        }\\n        for(int i = index;i < nums.length;i++){\\n            count++;\\n            helper(nums,i+1,or | nums[i],count);\\n            count--;\\n        }\\n    }\\n    public int countMaxOrSubsets(int[] nums) {\\n        for(k = 1;k <= nums.length;k++){\\n            helper(nums,0,0,0);\\n        }\\n        return arr[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536776,
                "title": "go-find-all-subset-prefixsum-or",
                "content": "# Complexity\\n- Time complexity:  $$O(2^n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunc countMaxOrSubsets(nums []int) int {\\n\\tn := len(nums)\\n\\tpre := make([]int, n+1)\\n\\tpre[0] = 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tpre[i+1] = pre[i] | nums[i]\\n\\t}\\n\\n\\tmaxOr, res := pre[n], 0\\n\\tcountMaxOrSubsetsBacktrack(nums, &res, 0, maxOr, 0)\\n\\treturn res\\n}\\n\\nfunc countMaxOrSubsetsBacktrack(nums []int, res *int, current int, maxOr int, i int) {\\n\\tif current == maxOr {\\n\\t\\t*res++\\n\\t}\\n\\n\\ttemp := current\\n\\tfor j := i; j < len(nums); j++ {\\n\\t\\tcurrent = current | nums[j]\\n\\t\\tcountMaxOrSubsetsBacktrack(nums, res, current, maxOr, j+1)\\n\\t\\tcurrent = temp\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countMaxOrSubsets(nums []int) int {\\n\\tn := len(nums)\\n\\tpre := make([]int, n+1)\\n\\tpre[0] = 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tpre[i+1] = pre[i] | nums[i]\\n\\t}\\n\\n\\tmaxOr, res := pre[n], 0\\n\\tcountMaxOrSubsetsBacktrack(nums, &res, 0, maxOr, 0)\\n\\treturn res\\n}\\n\\nfunc countMaxOrSubsetsBacktrack(nums []int, res *int, current int, maxOr int, i int) {\\n\\tif current == maxOr {\\n\\t\\t*res++\\n\\t}\\n\\n\\ttemp := current\\n\\tfor j := i; j < len(nums); j++ {\\n\\t\\tcurrent = current | nums[j]\\n\\t\\tcountMaxOrSubsetsBacktrack(nums, res, current, maxOr, j+1)\\n\\t\\tcurrent = temp\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528388,
                "title": "explained-every-single-thing-in-easy-way-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        // to calculate maximum orr we have to take or of whole array\\n        int morr = 0;\\n        for(int i=0 ; i < nums.size(); i++){\\n            morr = morr | nums[i];\\n        }\\n\\n        int orr = 0;\\n        int ans=0;\\n\\n        // total possible subsets\\n        int total = pow(2 , nums.size());\\n        \\n        for(int i = 0 ; i < total ; i++){\\n            int orr = 0;\\n            // we will iterate over each array and check if ith element in \\n            // set bit or not if it is set that means we have to take that element and  perform orr\\n            for(int j = 0 ; j < nums.size(); j++){\\n                if(i & (1 << j)){\\n                    orr  = orr | nums[j];\\n                }\\n            }\\n            if(orr == morr){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        // to calculate maximum orr we have to take or of whole array\\n        int morr = 0;\\n        for(int i=0 ; i < nums.size(); i++){\\n            morr = morr | nums[i];\\n        }\\n\\n        int orr = 0;\\n        int ans=0;\\n\\n        // total possible subsets\\n        int total = pow(2 , nums.size());\\n        \\n        for(int i = 0 ; i < total ; i++){\\n            int orr = 0;\\n            // we will iterate over each array and check if ith element in \\n            // set bit or not if it is set that means we have to take that element and  perform orr\\n            for(int j = 0 ; j < nums.size(); j++){\\n                if(i & (1 << j)){\\n                    orr  = orr | nums[j];\\n                }\\n            }\\n            if(orr == morr){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511933,
                "title": "dp-pick-nonpick",
                "content": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int n=nums.length;\\n        int a[]=new int[n];\\n        int maxOr=0;\\n        for(int x : nums)maxOr|=x;\\n        return f(0,nums,n,0,maxOr);\\n    }\\n    public int f(int i,int nums[],int n,int c,int maxOr){\\n        if(i==n){\\n            if(c==maxOr)return 1;\\n            else return 0;\\n        }\\n        int pick=f(i+1,nums,n,c|nums[i],maxOr);\\n        int notpick=f(i+1,nums,n,c,maxOr);\\n        return pick+notpick;\\n    }\\n}```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int n=nums.length;\\n        int a[]=new int[n];\\n        int maxOr=0;\\n        for(int x : nums)maxOr|=x;\\n        return f(0,nums,n,0,maxOr);\\n    }\\n    public int f(int i,int nums[],int n,int c,int maxOr){\\n        if(i==n){\\n            if(c==maxOr)return 1;\\n            else return 0;\\n        }\\n        int pick=f(i+1,nums,n,c|nums[i],maxOr);\\n        int notpick=f(i+1,nums,n,c,maxOr);\\n        return pick+notpick;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3482924,
                "title": "simplest-java-solution-beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   // int ans=1;\\n     int count=0;\\n      int max=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n       \\n     // max=nums[0]; \\n      for(int num:nums){\\n          max |=num;\\n      }\\n      System.out.print(max);  \\n      track(0,nums,0);\\n      return count;\\n    }\\n    void track(int i,int [] nums,int ans){\\n\\n        if(i==nums.length){\\n            if(ans==max)\\n              count++;\\n           return;\\n        }\\n         \\n        track(i+1,nums,ans|nums[i]);\\n        track(i+1,nums,ans);\\n    }\\n}        \\n    \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   // int ans=1;\\n     int count=0;\\n      int max=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n       \\n     // max=nums[0]; \\n      for(int num:nums){\\n          max |=num;\\n      }\\n      System.out.print(max);  \\n      track(0,nums,0);\\n      return count;\\n    }\\n    void track(int i,int [] nums,int ans){\\n\\n        if(i==nums.length){\\n            if(ans==max)\\n              count++;\\n           return;\\n        }\\n         \\n        track(i+1,nums,ans|nums[i]);\\n        track(i+1,nums,ans);\\n    }\\n}        \\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481019,
                "title": "python3-count-all-possible-or-s",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        def f(ind,ex):\\n            if ind==n:\\n                count[ex]+=1\\n                return\\n            \\n            f(ind+1,ex|nums[ind])\\n            f(ind+1,ex)\\n        \\n        count=Counter()\\n        f(0,0)\\n        \\n        mx=max(count)\\n        return count[mx]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        def f(ind,ex):\\n            if ind==n:\\n                count[ex]+=1\\n                return\\n            \\n            f(ind+1,ex|nums[ind])\\n            f(ind+1,ex)\\n        \\n        count=Counter()\\n        f(0,0)\\n        \\n        mx=max(count)\\n        return count[mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464173,
                "title": "simple-hashmap-powerset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        f(nums, 0, new ArrayList<>());\\n        int key = Collections.max(map.keySet());\\n        return map.get(key);\\n    }\\n    void f(int nums[], int start, List<Integer> temp) {\\n        int orResult = getBitwiseOR(temp);\\n        map.put(orResult, map.getOrDefault(orResult, 0)+1);\\n        for(int i=start;i<nums.length;++i) {\\n            temp.add(nums[i]);\\n            f(nums, i+1, temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n    int getBitwiseOR(List<Integer>nums) {\\n        int result = 0;\\n        for(int i: nums)\\n            result |= i;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        f(nums, 0, new ArrayList<>());\\n        int key = Collections.max(map.keySet());\\n        return map.get(key);\\n    }\\n    void f(int nums[], int start, List<Integer> temp) {\\n        int orResult = getBitwiseOR(temp);\\n        map.put(orResult, map.getOrDefault(orResult, 0)+1);\\n        for(int i=start;i<nums.length;++i) {\\n            temp.add(nums[i]);\\n            f(nums, i+1, temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n    int getBitwiseOR(List<Integer>nums) {\\n        int result = 0;\\n        for(int i: nums)\\n            result |= i;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422846,
                "title": "c-backtracking-simple-80-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)+recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>&nums,int &ans,int i,int tempans,int &maxans)\\n    {\\n        if(i==nums.size())\\n        {\\n             if(tempans>maxans)\\n             {\\n                 maxans=tempans;\\n                 ans=1;\\n             }\\n             else if(tempans==maxans)\\n             {\\n                 ans++;\\n             }\\n             return ;\\n        }\\n        int k=tempans;\\n        tempans=tempans | nums[i];\\n        helper(nums,ans,i+1,tempans,maxans);\\n        tempans=k;\\n        helper(nums,ans,i+1,tempans,maxans);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int ans=0,tempans=0,maxans=INT_MIN;\\n        helper(nums,ans,0,tempans,maxans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>&nums,int &ans,int i,int tempans,int &maxans)\\n    {\\n        if(i==nums.size())\\n        {\\n             if(tempans>maxans)\\n             {\\n                 maxans=tempans;\\n                 ans=1;\\n             }\\n             else if(tempans==maxans)\\n             {\\n                 ans++;\\n             }\\n             return ;\\n        }\\n        int k=tempans;\\n        tempans=tempans | nums[i];\\n        helper(nums,ans,i+1,tempans,maxans);\\n        tempans=k;\\n        helper(nums,ans,i+1,tempans,maxans);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int ans=0,tempans=0,maxans=INT_MIN;\\n        helper(nums,ans,0,tempans,maxans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414449,
                "title": "python3-dp-over-bitmask-approach",
                "content": "# Intuition\\nWe can notice that maximum OR of the subset from array ``num`` is OR of all its items. \\nIn order to find all such subsets, we can iterato over all of them. \\nWe can do that by iterating over all bitmasks, where bit ``i`` of the bitmask is set when given subset inludes ``nums[i]``. \\nWe can also track OR of the subsets defining it as:\\n```\\nDP(subset) = DP(subset XOR (1 << j)) OR nums[j]\\n```\\nfor subset containing nums[j]\\n\\nHere DP comes in.\\n\\n# Approach\\n1. Calculate OR of ``nums`` == ``value``, initialize ``result`` as ``0``\\n2. Initialize ``DP`` array of size ``1 << n``, where ``n`` is length of the array ``nums``\\n3. Iterate over all bitmasks from ``1`` to ``(1 << n) - 1`` and apply formulae from above. For each ``dp[i] == value`` increment ``result``\\n4. Return ``result`` \\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(2^n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        value = reduce(lambda s, t: s | t, nums)\\n        result = 0\\n        n = len(nums)\\n\\n        M = 1 << n\\n        dp = [0] * M\\n\\n        for i in range(1, M):\\n            for j in range(n):\\n                if (1 << j) & i:\\n                    dp[i] = dp[i ^ (1 << j)] | nums[j]\\n                    if dp[i] == value:\\n                        result += 1\\n                    break\\n\\n        return result\\n```\\n\\nShall you have any questions please ask and please UPVOTE if you like it!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nDP(subset) = DP(subset XOR (1 << j)) OR nums[j]\\n```\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        value = reduce(lambda s, t: s | t, nums)\\n        result = 0\\n        n = len(nums)\\n\\n        M = 1 << n\\n        dp = [0] * M\\n\\n        for i in range(1, M):\\n            for j in range(n):\\n                if (1 << j) & i:\\n                    dp[i] = dp[i ^ (1 << j)] | nums[j]\\n                    if dp[i] == value:\\n                        result += 1\\n                    break\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410665,
                "title": "2-combinations-codes-and-dynamic-programming-code",
                "content": "# Intuition\\n\\nJust wanted to share three possible solutions. Two of them are based on other peoples solution, credits are given on respective chapters.\\n\\n# Approach\\n- Combination\\n- Dynamic Programming\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Combination Code\\n![image.png](https://assets.leetcode.com/users/images/50aa7fa5-6219-47e1-ac64-5b630caf1dbf_1681346683.367062.png)\\n\\nThis code is authored by me.\\n\\n```java\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0, count=0;\\n        for(int n: nums) {\\n            max|=n;\\n        }\\n        int mask=(1<<nums.length)-1;\\n        // When iteratin like this, m will have\\n        // all possible combinations of mask\\n        for(int m=mask;m>0;m=mask&(m-1)){\\n            int g=0;\\n            for(int i=0,k=1;k<=m;k<<=1,i++) {\\n                if((m&k)==0) continue;\\n                // if g==mask we can stop\\n                if((g|=nums[i])==max) break;\\n            }\\n            if(g==max) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Combination Code 2\\n![image.png](https://assets.leetcode.com/users/images/39ca6f0c-1c25-441a-97c9-088899b04f38_1681346958.7366674.png)\\n\\nThis code is STRONGLY based on the fastest solutions submited on leetcode. Sadly I don\\'t know the owner.\\n\\n```java\\nclass Solution {\\n    int ans = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int n = nums.length, max = 0;\\n        for (int num : nums) max |= num;\\n        dfs(nums, 0, 0, max);\\n        return ans;\\n    }\\n\\n    private void dfs(int[] nums, int i, int or, int max) {\\n        if (or == max) {\\n            ans += 1 << (nums.length - i);\\n            return;\\n        }\\n        for (int j = i; j < nums.length; j++)\\n            dfs(nums, j + 1, or | nums[j], max);\\n    }\\n}\\n``` \\n# Dynamic Programing\\n![image.png](https://assets.leetcode.com/users/images/b5a7ef1f-fa5d-4a4e-bc49-e1e42abbf90b_1681347173.810235.png)\\n\\nThis code is based on the following solution, please consider upvoting it: https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/solutions/1525309/java-c-python-dp-solution/\\n\\n```java\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0, count=0, b;\\n        for(int n: nums) max|=n;\\n        int[] memo=new int[max+1];\\n        memo[0]=1;\\n        b=0;\\n        for(int n: nums) {\\n            for(int i=b;i>-1;i--) {\\n                int v=i|n;\\n                if(v>max) continue;\\n                if(v>b) b=v;\\n                memo[v]+=memo[i];\\n            }\\n        }\\n        return memo[max];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0, count=0;\\n        for(int n: nums) {\\n            max|=n;\\n        }\\n        int mask=(1<<nums.length)-1;\\n        // When iteratin like this, m will have\\n        // all possible combinations of mask\\n        for(int m=mask;m>0;m=mask&(m-1)){\\n            int g=0;\\n            for(int i=0,k=1;k<=m;k<<=1,i++) {\\n                if((m&k)==0) continue;\\n                // if g==mask we can stop\\n                if((g|=nums[i])==max) break;\\n            }\\n            if(g==max) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    int ans = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int n = nums.length, max = 0;\\n        for (int num : nums) max |= num;\\n        dfs(nums, 0, 0, max);\\n        return ans;\\n    }\\n\\n    private void dfs(int[] nums, int i, int or, int max) {\\n        if (or == max) {\\n            ans += 1 << (nums.length - i);\\n            return;\\n        }\\n        for (int j = i; j < nums.length; j++)\\n            dfs(nums, j + 1, or | nums[j], max);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0, count=0, b;\\n        for(int n: nums) max|=n;\\n        int[] memo=new int[max+1];\\n        memo[0]=1;\\n        b=0;\\n        for(int n: nums) {\\n            for(int i=b;i>-1;i--) {\\n                int v=i|n;\\n                if(v>max) continue;\\n                if(v>b) b=v;\\n                memo[v]+=memo[i];\\n            }\\n        }\\n        return memo[max];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393368,
                "title": "python-solution-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        def dfs(ind):\\n            if(ind==self.n):\\n                if(self.cumOr==self.ores):\\n                    self.ans+=1\\n                return\\n            temp=self.cumOr\\n            self.cumOr=self.cumOr|nums[ind]\\n            dfs(ind+1)\\n            self.cumOr=temp\\n            dfs(ind+1)        \\n        self.n=len(nums)\\n        self.ores=0\\n        for i in range(self.n):\\n            self.ores=self.ores|nums[i]\\n        self.ans=0\\n        self.cumOr=0\\n        for i in range(self.n):\\n            self.cumOr=nums[i]\\n            dfs(i+1)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        def dfs(ind):\\n            if(ind==self.n):\\n                if(self.cumOr==self.ores):\\n                    self.ans+=1\\n                return\\n            temp=self.cumOr\\n            self.cumOr=self.cumOr|nums[ind]\\n            dfs(ind+1)\\n            self.cumOr=temp\\n            dfs(ind+1)        \\n        self.n=len(nums)\\n        self.ores=0\\n        for i in range(self.n):\\n            self.ores=self.ores|nums[i]\\n        self.ans=0\\n        self.cumOr=0\\n        for i in range(self.n):\\n            self.cumOr=nums[i]\\n            dfs(i+1)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362218,
                "title": "javascript-backtracking-solution-81-ms-faster-than-100-00-43-1-mb-less-than-11-11",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countMaxOrSubsets = function(nums) {\\n    let res = 0;\\n    let max = 0;\\n    function backtrack(nums,start, val){   \\n        if(val === max)res++\\n        \\n        for(let i = start;i<nums.length; i++){\\n            backtrack(nums,i+1,val|nums[i])\\n        }\\n        \\n    }\\n    \\n    for(let num of nums) max |= num;\\n    backtrack(nums,0, 0)\\n    return res;\\n    \\n   \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countMaxOrSubsets = function(nums) {\\n    let res = 0;\\n    let max = 0;\\n    function backtrack(nums,start, val){   \\n        if(val === max)res++\\n        \\n        for(let i = start;i<nums.length; i++){\\n            backtrack(nums,i+1,val|nums[i])\\n        }\\n        \\n    }\\n    \\n    for(let num of nums) max |= num;\\n    backtrack(nums,0, 0)\\n    return res;\\n    \\n   \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3349936,
                "title": "c-easy-direct-enumeration",
                "content": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums)\\n    {\\n        int maxor = 0;\\n        for (int i : nums)\\n            maxor |= i;\\n        \\n        int ans = 0;\\n        for (int i = 1; i < (1 << nums.size()); i++)\\n        {\\n            int subs = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                if (i & (1 << j))\\n                    subs |= nums[j];\\n            }\\n            \\n            if (subs == maxor)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums)\\n    {\\n        int maxor = 0;\\n        for (int i : nums)\\n            maxor |= i;\\n        \\n        int ans = 0;\\n        for (int i = 1; i < (1 << nums.size()); i++)\\n        {\\n            int subs = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                if (i & (1 << j))\\n                    subs |= nums[j];\\n            }\\n            \\n            if (subs == maxor)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334815,
                "title": "dfs",
                "content": "```ruby\\ndef count_max_or_subsets a\\n    t, z, r = a.reduce(&:|), a.size, 0\\n    f = -> i, x do\\n        if i == z\\n            r += 1 if x == t\\n            return\\n        end\\n        f.(i + 1, x)\\n        f.(i + 1, x | a[i])\\n    end\\n    f.(0, 0)\\n    r\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef count_max_or_subsets a\\n    t, z, r = a.reduce(&:|), a.size, 0\\n    f = -> i, x do\\n        if i == z\\n            r += 1 if x == t\\n            return\\n        end\\n        f.(i + 1, x)\\n        f.(i + 1, x | a[i])\\n    end\\n    f.(0, 0)\\n    r\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3334771,
                "title": "c-recursion-backtracking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int idx,vector<int>& nums,int& cnt,int val,int maxi)\\n    {\\n        if(idx==nums.size())\\n        return;\\n        int tmp = val|nums[idx];\\n        if(tmp==maxi)\\n        {\\n            cnt++;\\n        }\\n        solve(idx+1,nums,cnt,tmp,maxi);\\n        solve(idx+1,nums,cnt,val,maxi);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0;\\n        for(auto &i:nums)\\n        maxOr|=i;\\n        int cnt=0;\\n        solve(0,nums,cnt,0,maxOr);\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int idx,vector<int>& nums,int& cnt,int val,int maxi)\\n    {\\n        if(idx==nums.size())\\n        return;\\n        int tmp = val|nums[idx];\\n        if(tmp==maxi)\\n        {\\n            cnt++;\\n        }\\n        solve(idx+1,nums,cnt,tmp,maxi);\\n        solve(idx+1,nums,cnt,val,maxi);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0;\\n        for(auto &i:nums)\\n        maxOr|=i;\\n        int cnt=0;\\n        solve(0,nums,cnt,0,maxOr);\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332525,
                "title": "c-easy-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int currOR, vector<int> &nums, int mxOR, vector<vector<int>> &dp){\\n        if(i > nums.size()) return 0;\\n        if(i == nums.size()) return (currOR == mxOR);\\n        if(dp[i][currOR] != -1) return dp[i][currOR];\\n\\n        int take = helper(i+1,currOR|nums[i],nums,mxOR,dp);\\n        int notTake = helper(i+1,currOR,nums,mxOR,dp);\\n\\n        return dp[i][currOR] = (take+notTake);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        int mxOR = 0;\\n        for(int i=0;i<n;i++){\\n            mxOR |= nums[i];\\n        }\\n        vector<vector<int>> dp(n+1,vector<int> (mxOR+1,-1));\\n        return helper(0,0,nums,mxOR,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i, int currOR, vector<int> &nums, int mxOR, vector<vector<int>> &dp){\\n        if(i > nums.size()) return 0;\\n        if(i == nums.size()) return (currOR == mxOR);\\n        if(dp[i][currOR] != -1) return dp[i][currOR];\\n\\n        int take = helper(i+1,currOR|nums[i],nums,mxOR,dp);\\n        int notTake = helper(i+1,currOR,nums,mxOR,dp);\\n\\n        return dp[i][currOR] = (take+notTake);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        int mxOR = 0;\\n        for(int i=0;i<n;i++){\\n            mxOR |= nums[i];\\n        }\\n        vector<vector<int>> dp(n+1,vector<int> (mxOR+1,-1));\\n        return helper(0,0,nums,mxOR,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325605,
                "title": "simple-recursive-solution-java",
                "content": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] arr) {\\n        int maxPossible = 0;\\n        for(int i = 0 ; i < arr.length ; i++){\\n            maxPossible |= arr[i];\\n        }\\n        return getCount(0 , arr , 0 , maxPossible);\\n    }\\n    private int getCount(int i , int[] arr , int xor , int max){\\n        if(i >= arr.length) return 0;\\n        int ans = 0;\\n        for(int j = i ; j < arr.length ; j++){\\n            if((xor | arr[j]) == max){\\n                ans += 1 + getCount(j+1 , arr , (xor | arr[j]) , max);\\n            }else{\\n                ans += getCount(j+1 , arr , (xor | arr[j]) , max);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Please UpVote, If found useful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] arr) {\\n        int maxPossible = 0;\\n        for(int i = 0 ; i < arr.length ; i++){\\n            maxPossible |= arr[i];\\n        }\\n        return getCount(0 , arr , 0 , maxPossible);\\n    }\\n    private int getCount(int i , int[] arr , int xor , int max){\\n        if(i >= arr.length) return 0;\\n        int ans = 0;\\n        for(int j = i ; j < arr.length ; j++){\\n            if((xor | arr[j]) == max){\\n                ans += 1 + getCount(j+1 , arr , (xor | arr[j]) , max);\\n            }else{\\n                ans += getCount(j+1 , arr , (xor | arr[j]) , max);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293669,
                "title": "python-easy-to-understand-backtracking-not-the-best-but-it-works",
                "content": "# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        # Get the max_val\\n        max_val = 0\\n        res = 0\\n        used = [False] * len(nums)\\n        for num in nums:\\n            max_val |= num\\n        def dfs(length,curr_val,idx):\\n            nonlocal res\\n            if (curr_val == max_val) and (length != 0):\\n                res += 1\\n            if length == len(nums):\\n                return\\n            for i in range(idx,len(nums)):\\n                val = nums[i]\\n                if used[i]:\\n                    continue\\n                prev = curr_val\\n                curr_val |= val\\n                used[i] = True\\n                length += 1\\n                dfs(length,curr_val,i+1)\\n                # Reset one step back...\\n                length -= 1\\n                used[i] = False\\n                curr_val = prev\\n\\n        dfs(0,0,0)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        # Get the max_val\\n        max_val = 0\\n        res = 0\\n        used = [False] * len(nums)\\n        for num in nums:\\n            max_val |= num\\n        def dfs(length,curr_val,idx):\\n            nonlocal res\\n            if (curr_val == max_val) and (length != 0):\\n                res += 1\\n            if length == len(nums):\\n                return\\n            for i in range(idx,len(nums)):\\n                val = nums[i]\\n                if used[i]:\\n                    continue\\n                prev = curr_val\\n                curr_val |= val\\n                used[i] = True\\n                length += 1\\n                dfs(length,curr_val,i+1)\\n                # Reset one step back...\\n                length -= 1\\n                used[i] = False\\n                curr_val = prev\\n\\n        dfs(0,0,0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292357,
                "title": "simple-c-solution-using-bit-manipulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(), ans=0, tt=0;\\n        unordered_map<int, int> m;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 1;i < (1 << n);i++) {\\n            int btr=0;\\n            for (int j = 0;j < n;j++) {\\n                if (i & (1 << j)) {\\n                    btr|=nums[j];\\n                }\\n            }\\n            m[btr]++;\\n        }\\n        for(auto x: m) if(x.first>tt) { ans=x.second; tt=x.first; } \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(), ans=0, tt=0;\\n        unordered_map<int, int> m;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 1;i < (1 << n);i++) {\\n            int btr=0;\\n            for (int j = 0;j < n;j++) {\\n                if (i & (1 << j)) {\\n                    btr|=nums[j];\\n                }\\n            }\\n            m[btr]++;\\n        }\\n        for(auto x: m) if(x.first>tt) { ans=x.second; tt=x.first; } \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291934,
                "title": "java-recursive",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    int count=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for(int i:nums)\\n            max = max | i;\\n        backtrack(nums,0,max, 0);\\n        return count;\\n    }\\n\\n    private void backtrack(int[] nums,int first,int max, int curr){\\n        if(max == curr)\\n            count++;\\n        if(first>=nums.length) return;\\n\\n        for(int i = first;i<nums.length;i++){\\n            backtrack(nums,i+1,max,curr|nums[i]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    int count=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for(int i:nums)\\n            max = max | i;\\n        backtrack(nums,0,max, 0);\\n        return count;\\n    }\\n\\n    private void backtrack(int[] nums,int first,int max, int curr){\\n        if(max == curr)\\n            count++;\\n        if(first>=nums.length) return;\\n\\n        for(int i = first;i<nums.length;i++){\\n            backtrack(nums,i+1,max,curr|nums[i]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288706,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func countMaxOrSubsets(_ nums: [Int]) -> Int {\\n        \\n        let t = nums.reduce(0, |)\\n        \\n        func go(_ stack: [Int] = nums) -> [[Int]] {\\n            guard stack.count > 1 else { return [stack] }              \\n            let ret = go(Array(stack.dropFirst()))\\n            return [[stack[0]]] + ret + ret.map { [stack[0]] + $0 }\\n        }\\n        \\n        return go()\\n            .filter { $0.reduce(0, |) == t }\\n            .lazy\\n            .count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countMaxOrSubsets(_ nums: [Int]) -> Int {\\n        \\n        let t = nums.reduce(0, |)\\n        \\n        func go(_ stack: [Int] = nums) -> [[Int]] {\\n            guard stack.count > 1 else { return [stack] }              \\n            let ret = go(Array(stack.dropFirst()))\\n            return [[stack[0]]] + ret + ret.map { [stack[0]] + $0 }\\n        }\\n        \\n        return go()\\n            .filter { $0.reduce(0, |) == t }\\n            .lazy\\n            .count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264625,
                "title": "python3-simplest-recursive-solution-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxBitwiseOr=0\\n        for num in nums:\\n            maxBitwiseOr|=num\\n        ans=[0]\\n        def dfs(i,maxBitwiseOr,curOrValue,ans):\\n            if i==len(nums):\\n                if maxBitwiseOr==curOrValue:\\n                    ans[0]+=1\\n                return\\n            dfs(i+1,maxBitwiseOr,curOrValue,ans)\\n            dfs(i+1,maxBitwiseOr,curOrValue|nums[i],ans)\\n        dfs(0,maxBitwiseOr,0,ans)\\n        return ans[0]\\n    ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxBitwiseOr=0\\n        for num in nums:\\n            maxBitwiseOr|=num\\n        ans=[0]\\n        def dfs(i,maxBitwiseOr,curOrValue,ans):\\n            if i==len(nums):\\n                if maxBitwiseOr==curOrValue:\\n                    ans[0]+=1\\n                return\\n            dfs(i+1,maxBitwiseOr,curOrValue,ans)\\n            dfs(i+1,maxBitwiseOr,curOrValue|nums[i],ans)\\n        dfs(0,maxBitwiseOr,0,ans)\\n        return ans[0]\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 3218397,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0, res = 0;\\n        for(auto x:nums) maxOr |= x;\\n        dfs(nums, 0, res, maxOr, 0);\\n        return res;\\n    }\\n\\n    void dfs(vector<int>& v, int i, int& res, int maxOr, int cur){\\n        if(i == v.size()){\\n            if(cur == maxOr) res++;\\n            return;\\n        }\\n        dfs(v, i+1, res, maxOr, cur);\\n        dfs(v, i+1, res, maxOr, cur|v[i]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0, res = 0;\\n        for(auto x:nums) maxOr |= x;\\n        dfs(nums, 0, res, maxOr, 0);\\n        return res;\\n    }\\n\\n    void dfs(vector<int>& v, int i, int& res, int maxOr, int cur){\\n        if(i == v.size()){\\n            if(cur == maxOr) res++;\\n            return;\\n        }\\n        dfs(v, i+1, res, maxOr, cur);\\n        dfs(v, i+1, res, maxOr, cur|v[i]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180545,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint count=0;\\nvoid f(vector<int> &nums,int i,int sum,int x)\\n{\\n    if(i==nums.size() && sum>=x)\\n    {\\n        count++;\\n        return;\\n    }\\n    else if(i==nums.size())\\n    return;\\n    int y=sum|nums[i];\\n    f(nums,i+1,y,x);\\n    f(nums,i+1,sum,x);\\n}\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x|nums[i];\\n        }\\n        f(nums,0,0,x);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint count=0;\\nvoid f(vector<int> &nums,int i,int sum,int x)\\n{\\n    if(i==nums.size() && sum>=x)\\n    {\\n        count++;\\n        return;\\n    }\\n    else if(i==nums.size())\\n    return;\\n    int y=sum|nums[i];\\n    f(nums,i+1,y,x);\\n    f(nums,i+1,sum,x);\\n}\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x|nums[i];\\n        }\\n        f(nums,0,0,x);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171185,
                "title": "very-easy-and-simple-just-simple-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int i,j,maxor=0,n=nums.size(),ans=0;\\n        for(i=0;i<n;i++)\\n        {\\n            maxor=nums[i]|maxor;\\n        }\\n        for(i=1;i<(1<<n);i++)\\n        {\\n            int p=0;\\n            for(j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    p=p|nums[j];\\n                }\\n            }\\n            if(p==maxor)\\n            {\\n                ans++;\\n           }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int i,j,maxor=0,n=nums.size(),ans=0;\\n        for(i=0;i<n;i++)\\n        {\\n            maxor=nums[i]|maxor;\\n        }\\n        for(i=1;i<(1<<n);i++)\\n        {\\n            int p=0;\\n            for(j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    p=p|nums[j];\\n                }\\n            }\\n            if(p==maxor)\\n            {\\n                ans++;\\n           }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124318,
                "title": "c-recursive-iterative",
                "content": "Recursive Solution\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums,int pos,int & ans,int & target,int curr){\\n        if(pos<0){\\n            if(curr==target) ans++;\\n            return;\\n        }\\n        helper(nums,pos-1,ans,target,curr);\\n        helper(nums,pos-1,ans,target,curr|nums[pos]);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n =nums.size(),target=0,ans=0;\\n        for(int el:nums) target|=el;\\n        helper(nums,n-1,ans,target,0);\\n        return ans;        \\n    }\\n};\\n```\\n\\nIterative Solution\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n =nums.size(),target=0,ans=0;\\n        for(int el:nums) target|=el;\\n        for(int i=0;i<(1<<n);i++){\\n            int temp=0;\\n            for(int j=0;j<n;j++)\\n                if(i&(1<<j)) temp|=nums[j];\\n            if(temp==target) ans++;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums,int pos,int & ans,int & target,int curr){\\n        if(pos<0){\\n            if(curr==target) ans++;\\n            return;\\n        }\\n        helper(nums,pos-1,ans,target,curr);\\n        helper(nums,pos-1,ans,target,curr|nums[pos]);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n =nums.size(),target=0,ans=0;\\n        for(int el:nums) target|=el;\\n        helper(nums,n-1,ans,target,0);\\n        return ans;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n =nums.size(),target=0,ans=0;\\n        for(int el:nums) target|=el;\\n        for(int i=0;i<(1<<n);i++){\\n            int temp=0;\\n            for(int j=0;j<n;j++)\\n                if(i&(1<<j)) temp|=nums[j];\\n            if(temp==target) ans++;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124285,
                "title": "naive-solution-using-recursion-only-for-begginers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever in the problem it is given that we need to try out all possible options then we might think of recursion as one of the way to solve the problem.\\n\\nThe common way of generating all possible subsequences for any given array is the PICK/NOT_PICK method. \\n\\nhttps://www.youtube.com/watch?v=AxNNVECce8c\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the pick and not pick technique to generate all subsequences and at the same time computing the maximum possible bitwise or for the given array.\\n\\nOnce all the recursion calls are over we have the value of maximum possible bitwise or and all possible sub-sequences for the given array. Now we can easily traverse and compute bitwise or for all sub-sequences, and compare it with maximum bitwise or value if any of them gives the result equal to maximum bitwise or we increment the counter by one.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince it is Naive solution the Time complexity is quite poor.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. The 2D vector ans\\n2. The temporary vector v\\n3. Recursive stack space\\n\\n# Code\\n```\\nclass Solution {\\nint maxi=-1;\\nprivate:\\n     void f(int ind, int n, vector<int>& nums, vector<int>& v, int res,\\n           vector<vector<int>>& ans){\\n         if(ind>=n){\\n           maxi=max(maxi,res);\\n           ans.push_back(v);\\n           return;\\n         }\\n       \\n        v.push_back(nums[ind]);\\n       f(ind+1,n,nums,v, res|nums[ind],ans);\\n        v.pop_back();\\n       f(ind+1,n,nums,v, res, ans);\\n\\n     }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n     int n=nums.size();\\n     vector<vector<int>> ans;\\n     vector<int> v;\\n     f(0,n,nums,v,0,ans);\\n     int count=0;\\n     for(auto it:ans){\\n         int x=0;\\n         for(int i=0;i<it.size();i++){\\n             x|=it[i];\\n         }\\n         if(x==maxi) count++;\\n     }\\n     return count;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nint maxi=-1;\\nprivate:\\n     void f(int ind, int n, vector<int>& nums, vector<int>& v, int res,\\n           vector<vector<int>>& ans){\\n         if(ind>=n){\\n           maxi=max(maxi,res);\\n           ans.push_back(v);\\n           return;\\n         }\\n       \\n        v.push_back(nums[ind]);\\n       f(ind+1,n,nums,v, res|nums[ind],ans);\\n        v.pop_back();\\n       f(ind+1,n,nums,v, res, ans);\\n\\n     }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n     int n=nums.size();\\n     vector<vector<int>> ans;\\n     vector<int> v;\\n     f(0,n,nums,v,0,ans);\\n     int count=0;\\n     for(auto it:ans){\\n         int x=0;\\n         for(int i=0;i<it.size();i++){\\n             x|=it[i];\\n         }\\n         if(x==maxi) count++;\\n     }\\n     return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113001,
                "title": "simple-java-solution-hashmap-backtracking",
                "content": "# Intuition\\nhandle the take and not take cases\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int max=0;\\n    public void fun(int i,int[] nums,int curr,HashMap<Integer,Integer> hash)\\n    {\\n        if(i==nums.length)\\n        {\\n            if(curr!=-1)  \\n            {\\n                max=Math.max(max,curr);\\n                hash.put(curr,hash.getOrDefault(curr,0)+1);\\n            }\\n            return ;\\n        }\\n        int now=0;\\n        if(curr==-1)  now=nums[i];\\n        else\\n        now=curr | nums[i];\\n        fun(i+1,nums,now,hash);\\n        fun(i+1,nums,curr,hash);\\n    }\\n    public int countMaxOrSubsets(int[] nums) \\n    {\\n        HashMap<Integer,Integer> hash=new HashMap<>();\\n        fun(0,nums,-1,hash);\\n        return hash.get(max)==null ? 0 : hash.get(max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int max=0;\\n    public void fun(int i,int[] nums,int curr,HashMap<Integer,Integer> hash)\\n    {\\n        if(i==nums.length)\\n        {\\n            if(curr!=-1)  \\n            {\\n                max=Math.max(max,curr);\\n                hash.put(curr,hash.getOrDefault(curr,0)+1);\\n            }\\n            return ;\\n        }\\n        int now=0;\\n        if(curr==-1)  now=nums[i];\\n        else\\n        now=curr | nums[i];\\n        fun(i+1,nums,now,hash);\\n        fun(i+1,nums,curr,hash);\\n    }\\n    public int countMaxOrSubsets(int[] nums) \\n    {\\n        HashMap<Integer,Integer> hash=new HashMap<>();\\n        fun(0,nums,-1,hash);\\n        return hash.get(max)==null ? 0 : hash.get(max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095240,
                "title": "c-backtracking",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int bitwise = 0;\\n        for (auto& n : nums) bitwise |= n;\\n        int res = 0;\\n        dfs(nums, 0, 0, bitwise, res);\\n        return res;\\n    }\\n\\n    void dfs(vector<int>& nums, int idx, int path, int bitwise, int& res) {\\n        if (idx == nums.size()) return;\\n\\n        int temp = path | nums[idx];\\n        if (temp == bitwise) res++;\\n        dfs(nums, idx + 1, temp, bitwise, res);\\n        dfs(nums, idx + 1, path, bitwise, res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int bitwise = 0;\\n        for (auto& n : nums) bitwise |= n;\\n        int res = 0;\\n        dfs(nums, 0, 0, bitwise, res);\\n        return res;\\n    }\\n\\n    void dfs(vector<int>& nums, int idx, int path, int bitwise, int& res) {\\n        if (idx == nums.size()) return;\\n\\n        int temp = path | nums[idx];\\n        if (temp == bitwise) res++;\\n        dfs(nums, idx + 1, temp, bitwise, res);\\n        dfs(nums, idx + 1, path, bitwise, res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076924,
                "title": "rust-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(2^n)$$\\n\\n# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn count_max_or_subsets(nums: Vec<i32>) -> i32 {\\n    let n = nums.len();\\n    let limit = 1 << n;\\n    let mut map = HashMap::new();\\n    for i in 0..limit {\\n      let mut temp = 0i32;\\n      for j in 0..n {\\n        if i>>j & 1 == 1 {\\n          temp |= nums[j];\\n        }\\n      }\\n      *map.entry(temp).or_insert(0) += 1;\\n    }\\n    let mut arr = map.into_iter().collect::<Vec<(i32,i32)>>();\\n    arr.sort();\\n    arr[arr.len()-1].1\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn count_max_or_subsets(nums: Vec<i32>) -> i32 {\\n    let n = nums.len();\\n    let limit = 1 << n;\\n    let mut map = HashMap::new();\\n    for i in 0..limit {\\n      let mut temp = 0i32;\\n      for j in 0..n {\\n        if i>>j & 1 == 1 {\\n          temp |= nums[j];\\n        }\\n      }\\n      *map.entry(temp).or_insert(0) += 1;\\n    }\\n    let mut arr = map.into_iter().collect::<Vec<(i32,i32)>>();\\n    arr.sort();\\n    arr[arr.len()-1].1\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057812,
                "title": "python-knapsack-style-dp-o-n-2-16",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        d = Counter([0])\\n        for num in nums:\\n            for k, v in list(d.items()):\\n                d[k|num] += v\\n        return d[max(d)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        d = Counter([0])\\n        for num in nums:\\n            for k, v in list(d.items()):\\n                d[k|num] += v\\n        return d[max(d)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055747,
                "title": "golang-dp",
                "content": "# Code\\n```\\nfunc countMaxOrSubsets(nums []int) int {\\n    var maxVal int = 0\\n    for _, num := range nums {\\n        maxVal = maxVal | num\\n    }\\n    DP := make([]int, maxVal + 1)\\n    DP[nums[0]] = 1;\\n    for i := 1; i < len(nums); i++ {\\n        for j := maxVal; j > 0; j-- {\\n            if DP[j] > 0 {\\n                DP[j | nums[i]] += DP[j]\\n            }\\n        }\\n        DP[nums[i]]++\\n    }\\n    return DP[maxVal]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc countMaxOrSubsets(nums []int) int {\\n    var maxVal int = 0\\n    for _, num := range nums {\\n        maxVal = maxVal | num\\n    }\\n    DP := make([]int, maxVal + 1)\\n    DP[nums[0]] = 1;\\n    for i := 1; i < len(nums); i++ {\\n        for j := maxVal; j > 0; j-- {\\n            if DP[j] > 0 {\\n                DP[j | nums[i]] += DP[j]\\n            }\\n        }\\n        DP[nums[i]]++\\n    }\\n    return DP[maxVal]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055687,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxVal = 0;\\n        for(int num: nums) {\\n            maxVal = maxVal | num;\\n        }\\n        vector<int> DP(maxVal + 1, 0);\\n        DP[nums[0]] = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            for(int j = maxVal; j > 0; j--) {\\n                if(DP[j]) {\\n                    DP[j | nums[i]] += DP[j];\\n                }\\n            }\\n            DP[nums[i]]++;\\n        }\\n        return DP[maxVal];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxVal = 0;\\n        for(int num: nums) {\\n            maxVal = maxVal | num;\\n        }\\n        vector<int> DP(maxVal + 1, 0);\\n        DP[nums[0]] = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            for(int j = maxVal; j > 0; j--) {\\n                if(DP[j]) {\\n                    DP[j | nums[i]] += DP[j];\\n                }\\n            }\\n            DP[nums[i]]++;\\n        }\\n        return DP[maxVal];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044947,
                "title": "c-faster-than-65-brute-force-subsets-using-recursion-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\nvoid func(int i,vector<int>&nums,vector<int>&st,vector<vector<int>>&vs)\\n{\\n        if(st.size() > 0)vs.push_back(st);\\n        for(;i<nums.size();i++)\\n        {\\n            st.push_back(nums[i]);\\n            func(i+1,nums,st,vs);\\n            st.pop_back();\\n        }\\n        return;\\n}\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n       \\n       int Or  = nums[0];\\n\\n       for(int i = 1; i<nums.size();++i)  Or = Or | nums[i]; \\n\\n       vector<int>st;\\n       vector<vector<int>>vs;\\n       \\n       func(0,nums,st,vs);\\n\\n       int cnt = 0;\\n\\n       for(int i = 0; i < vs.size(); ++i)\\n       {\\n          int temp = vs[i][0];\\n\\n          for(int j = 1; j < vs[i].size();++j) temp = temp | vs[i][j];\\n          \\n          if(temp == Or) cnt++;\\n\\n       }\\n\\n       return cnt;\\n \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\nvoid func(int i,vector<int>&nums,vector<int>&st,vector<vector<int>>&vs)\\n{\\n        if(st.size() > 0)vs.push_back(st);\\n        for(;i<nums.size();i++)\\n        {\\n            st.push_back(nums[i]);\\n            func(i+1,nums,st,vs);\\n            st.pop_back();\\n        }\\n        return;\\n}\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n       \\n       int Or  = nums[0];\\n\\n       for(int i = 1; i<nums.size();++i)  Or = Or | nums[i]; \\n\\n       vector<int>st;\\n       vector<vector<int>>vs;\\n       \\n       func(0,nums,st,vs);\\n\\n       int cnt = 0;\\n\\n       for(int i = 0; i < vs.size(); ++i)\\n       {\\n          int temp = vs[i][0];\\n\\n          for(int j = 1; j < vs[i].size();++j) temp = temp | vs[i][j];\\n          \\n          if(temp == Or) cnt++;\\n\\n       }\\n\\n       return cnt;\\n \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025965,
                "title": "basic-approach-using-recursion-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n#define vi vector<int>\\n#define vll vector<ll>\\n#define vvi vector<vector<int>>\\n#define pb push_back\\n#define srt(x) sort(begin(x),end(x))\\n#define rep(i,a,b) for(int i=a,i<b;i++)\\n#define REP(i,a,b) for(int i=b;i>=a;i--)\\n#define imap unordered_map<int,int>\\n#define lmap unordered_map<ll,ll>\\nclass Solution {\\npublic:\\n    //Function to get all the subsets of the given array\\n    void getSubsets(int ind,vi &nums,vi &ans,vvi &res){\\n        //if the index crosses the size of the array then insert the found subset in the\\n        //result array\\n        if(ind==nums.size()){\\n            res.pb(ans);\\n            return ;\\n        }\\n        //push the subset at that index and then call the recursive function to look for\\n        //other indices\\n        ans.pb(nums[ind]);\\n        getSubsets(ind+1,nums,ans,res);\\n        //finally backtrack\\n        ans.pop_back();\\n        getSubsets(ind+1,nums,ans,res);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vvi res;\\n        vi ans;\\n        vi store;\\n        getSubsets(0,nums,ans,res);\\n        //Here we got all the subsets\\n        int count=0;\\n        //now we can iterate over all the subsets and calculate the OR of all of them\\n        for(auto &it:res){\\n            if(it.size()>=1){\\n                int x=it[0];\\n                for(int i=1;i<it.size();i++){\\n                    x|=it[i];\\n                }\\n                store.pb(x);\\n            }\\n        }\\n        //find out the maximum OR and count the number of max XOR\\'s\\n        int maxi=*max_element(begin(store),end(store));\\n        for(auto &it:store){\\n            if(it==maxi) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nI hope you like my approach, though it is a very naive approach for beginners. Will try to optimize it and will post the solutions. \\nHappy Coding:)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long\\n#define vi vector<int>\\n#define vll vector<ll>\\n#define vvi vector<vector<int>>\\n#define pb push_back\\n#define srt(x) sort(begin(x),end(x))\\n#define rep(i,a,b) for(int i=a,i<b;i++)\\n#define REP(i,a,b) for(int i=b;i>=a;i--)\\n#define imap unordered_map<int,int>\\n#define lmap unordered_map<ll,ll>\\nclass Solution {\\npublic:\\n    //Function to get all the subsets of the given array\\n    void getSubsets(int ind,vi &nums,vi &ans,vvi &res){\\n        //if the index crosses the size of the array then insert the found subset in the\\n        //result array\\n        if(ind==nums.size()){\\n            res.pb(ans);\\n            return ;\\n        }\\n        //push the subset at that index and then call the recursive function to look for\\n        //other indices\\n        ans.pb(nums[ind]);\\n        getSubsets(ind+1,nums,ans,res);\\n        //finally backtrack\\n        ans.pop_back();\\n        getSubsets(ind+1,nums,ans,res);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vvi res;\\n        vi ans;\\n        vi store;\\n        getSubsets(0,nums,ans,res);\\n        //Here we got all the subsets\\n        int count=0;\\n        //now we can iterate over all the subsets and calculate the OR of all of them\\n        for(auto &it:res){\\n            if(it.size()>=1){\\n                int x=it[0];\\n                for(int i=1;i<it.size();i++){\\n                    x|=it[i];\\n                }\\n                store.pb(x);\\n            }\\n        }\\n        //find out the maximum OR and count the number of max XOR\\'s\\n        int maxi=*max_element(begin(store),end(store));\\n        for(auto &it:store){\\n            if(it==maxi) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011786,
                "title": "simple-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int mxOr,int& count,int curOr,int i){\\n        if(i>=nums.size()){\\n            if(mxOr==curOr){\\n             count++;\\n            }\\n            return;\\n        }\\n        //if i include ith index\\n        solve(nums,mxOr,count,curOr|nums[i],i+1);\\n        //if not include ith index\\n        solve(nums,mxOr,count,curOr,i+1);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int mxOr=0;\\n        for(auto it:nums){\\n            mxOr=mxOr|it;\\n        }\\n        int count=0;\\n        solve(nums,mxOr,count,0,0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int mxOr,int& count,int curOr,int i){\\n        if(i>=nums.size()){\\n            if(mxOr==curOr){\\n             count++;\\n            }\\n            return;\\n        }\\n        //if i include ith index\\n        solve(nums,mxOr,count,curOr|nums[i],i+1);\\n        //if not include ith index\\n        solve(nums,mxOr,count,curOr,i+1);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int mxOr=0;\\n        for(auto it:nums){\\n            mxOr=mxOr|it;\\n        }\\n        int count=0;\\n        solve(nums,mxOr,count,0,0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976787,
                "title": "go-compact-dfs",
                "content": "```\\nfunc countMaxOrSubsets(nums []int) int {\\n    bw := map[int]int{}\\n    max := -1\\n\\n    var dfs func(idx int, xor int)\\n    dfs = func(idx int, xor int) {\\n        if idx == len(nums) {\\n            bw[xor]++\\n            if xor > max { max = xor }\\n            return\\n        }\\n        dfs(idx + 1, xor | nums[idx])\\n        dfs(idx + 1, xor)\\n        return\\n    }\\n\\n    dfs(0, 0)\\n    return bw[max]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countMaxOrSubsets(nums []int) int {\\n    bw := map[int]int{}\\n    max := -1\\n\\n    var dfs func(idx int, xor int)\\n    dfs = func(idx int, xor int) {\\n        if idx == len(nums) {\\n            bw[xor]++\\n            if xor > max { max = xor }\\n            return\\n        }\\n        dfs(idx + 1, xor | nums[idx])\\n        dfs(idx + 1, xor)\\n        return\\n    }\\n\\n    dfs(0, 0)\\n    return bw[max]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2963978,
                "title": "php-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution\\n{\\n\\n    private $sum = 0;\\n    private $occurres = [];\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countMaxOrSubsets( $nums )\\n    {\\n        $this->backtrack( $nums, [], 0 );\\n        $max = 0;\\n\\n        foreach ( $this->occurres as $k => $v )\\n        {\\n            $max = max( $v, $max );\\n        }\\n\\n        return $max;\\n    }\\n\\n\\n    function backtrack( $nums, $set, $index = 0 )\\n    {\\n        $or = 0;\\n        foreach ( $set as $s )\\n        {\\n            $or |= $s;\\n        }\\n        $this->occurres[$or] = isset( $this->occurres[$or] ) ?\\n            $this->occurres[$or] + 1 : 1;\\n\\n        if ( count( $set ) === count( $nums ) )\\n        {\\n            return;\\n        }\\n\\n        for ( $i = $index; $i < count( $nums ); $i++ )\\n        {\\n            $set[] = $nums[$i];\\n            $this->backtrack( $nums, $set, $i + 1 );\\n            array_pop( $set );\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n\\nclass Solution\\n{\\n\\n    private $sum = 0;\\n    private $occurres = [];\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countMaxOrSubsets( $nums )\\n    {\\n        $this->backtrack( $nums, [], 0 );\\n        $max = 0;\\n\\n        foreach ( $this->occurres as $k => $v )\\n        {\\n            $max = max( $v, $max );\\n        }\\n\\n        return $max;\\n    }\\n\\n\\n    function backtrack( $nums, $set, $index = 0 )\\n    {\\n        $or = 0;\\n        foreach ( $set as $s )\\n        {\\n            $or |= $s;\\n        }\\n        $this->occurres[$or] = isset( $this->occurres[$or] ) ?\\n            $this->occurres[$or] + 1 : 1;\\n\\n        if ( count( $set ) === count( $nums ) )\\n        {\\n            return;\\n        }\\n\\n        for ( $i = $index; $i < count( $nums ); $i++ )\\n        {\\n            $set[] = $nums[$i];\\n            $this->backtrack( $nums, $set, $i + 1 );\\n            array_pop( $set );\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951749,
                "title": "c-recursion-backtracking-beats-100",
                "content": "# Approach\\n1.Calculate the max bitwise OR of a list, which is the ORing of all the elements in the list.\\n\\n2.Use backtracking to generate all the possible subsets and each time calculate the OR of the subset and compare with the max that we calcualte in step 1, if they are equal, then increment result counter by 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n * 2^n) where n is the length of n\\n\\n- Space complexity:\\nO(n) where n is the length of nums\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b8cec52a-c7f3-4392-a6c6-86bbd17a5807_1672023730.3167922.png)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountMaxOrSubsets(int[] nums) {\\n        int maxOrBitwiseCount = 0;\\n\\n        int maxOrBitwise = 0;\\n        foreach (int num in nums)\\n            maxOrBitwise |= num;\\n        \\n        List<int> currSol = new();\\n\\n        void Backtrack(int i)\\n        {\\n            if (CalculateOrBitwise(currSol) == maxOrBitwise)\\n                maxOrBitwiseCount++;\\n            \\n            for (int j = i; j < nums.Length; j++)\\n            {\\n                currSol.Add(nums[j]);\\n                Backtrack(j + 1);\\n                currSol.RemoveAt(currSol.Count - 1);\\n            }\\n        }\\n\\n        Backtrack(0);\\n\\n        return maxOrBitwiseCount;\\n    }\\n\\n    public int CalculateOrBitwise(List<int> list)\\n    {\\n        int res = 0;\\n        foreach (int num in list)\\n            res |= num;\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountMaxOrSubsets(int[] nums) {\\n        int maxOrBitwiseCount = 0;\\n\\n        int maxOrBitwise = 0;\\n        foreach (int num in nums)\\n            maxOrBitwise |= num;\\n        \\n        List<int> currSol = new();\\n\\n        void Backtrack(int i)\\n        {\\n            if (CalculateOrBitwise(currSol) == maxOrBitwise)\\n                maxOrBitwiseCount++;\\n            \\n            for (int j = i; j < nums.Length; j++)\\n            {\\n                currSol.Add(nums[j]);\\n                Backtrack(j + 1);\\n                currSol.RemoveAt(currSol.Count - 1);\\n            }\\n        }\\n\\n        Backtrack(0);\\n\\n        return maxOrBitwiseCount;\\n    }\\n\\n    public int CalculateOrBitwise(List<int> list)\\n    {\\n        int res = 0;\\n        foreach (int num in list)\\n            res |= num;\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949708,
                "title": "php-solution-using-subsets",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countMaxOrSubsets($nums) {\\n        $subsets=$this->subsets($nums);\\n        $ors=[];\\n        foreach($subsets as $sub){\\n            array_push($ors,array_reduce($sub,array($this,\"bitwiseOr\")));\\n        }\\n        $max=max(array_values($ors));\\n       $count=0;\\n       foreach($ors as $or){\\n           if($or==$max)\\n                $count++;\\n       }\\n        return $count;\\n    }\\n\\n    function subsets($nums) {\\n        $res=[[]];\\n        if(sizeof($nums)==1) \\n            array_push($res,[$nums[0]]);\\n        else{\\n            foreach($nums as $num){\\n                $first=array_shift($nums);\\n                $subs=$this->subsets($nums);\\n                foreach($subs as $sub){\\n                    array_push($sub,$first);\\n                    array_push($res,$sub);\\n                }\\n            }\\n        }\\n        return $res; \\n       \\n    }\\n    function bitwiseOr($a,$b){\\n        return $a|$b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countMaxOrSubsets($nums) {\\n        $subsets=$this->subsets($nums);\\n        $ors=[];\\n        foreach($subsets as $sub){\\n            array_push($ors,array_reduce($sub,array($this,\"bitwiseOr\")));\\n        }\\n        $max=max(array_values($ors));\\n       $count=0;\\n       foreach($ors as $or){\\n           if($or==$max)\\n                $count++;\\n       }\\n        return $count;\\n    }\\n\\n    function subsets($nums) {\\n        $res=[[]];\\n        if(sizeof($nums)==1) \\n            array_push($res,[$nums[0]]);\\n        else{\\n            foreach($nums as $num){\\n                $first=array_shift($nums);\\n                $subs=$this->subsets($nums);\\n                foreach($subs as $sub){\\n                    array_push($sub,$first);\\n                    array_push($res,$sub);\\n                }\\n            }\\n        }\\n        return $res; \\n       \\n    }\\n    function bitwiseOr($a,$b){\\n        return $a|$b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946488,
                "title": "java-simple-solution-using-backtracking-beats-90-solutions",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    int mx = 0;\\n\\n    public void f(int[] nums, int xr, int i) {\\n        //System.out.println(xr);\\n\\n        if (i == nums.length) {\\n            if (xr == mx) {\\n                ans++;\\n            }\\n            return;\\n        }\\n\\n        f(nums, xr | nums[i], i + 1);\\n        f(nums, xr, i + 1);\\n    }\\n\\n    public int countMaxOrSubsets(int[] nums) {\\n        int m = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            m = m | nums[i];\\n        }\\n\\n        mx = m;\\n\\n        f(nums, 0, 0);\\n\\n        //System.out.println(mx);\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    int mx = 0;\\n\\n    public void f(int[] nums, int xr, int i) {\\n        //System.out.println(xr);\\n\\n        if (i == nums.length) {\\n            if (xr == mx) {\\n                ans++;\\n            }\\n            return;\\n        }\\n\\n        f(nums, xr | nums[i], i + 1);\\n        f(nums, xr, i + 1);\\n    }\\n\\n    public int countMaxOrSubsets(int[] nums) {\\n        int m = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            m = m | nums[i];\\n        }\\n\\n        mx = m;\\n\\n        f(nums, 0, 0);\\n\\n        //System.out.println(mx);\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942159,
                "title": "c-recursion-backtracking-very-easy",
                "content": "# Intuition\\nWe will check for all the subset.\\n\\n# Approach\\nFor a subset we calculate the or of all values when we get value is maximum then we declear count = 1 and if value we get is same as maximum value then we will increase our count value by 1.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums, vector<int> v, int index, int &count,int &mx)\\n    {\\n        if(index>=nums.size())\\n        {\\n            int ans = 0;\\n            for(int i=0 ;i<v.size() ;i++)\\n            ans = ans|v[i];\\n            if(ans>mx){\\n                count=1;\\n                mx = ans;\\n            }\\n            else if(ans==mx)\\n            count++;\\n            return;\\n        }\\n        solve(nums, v, index+1, count, mx);\\n        v.push_back(nums[index]);\\n        solve(nums, v, index+1, count, mx);\\n        //v.pop_back(); no need for this because we are not passing the reference of vector.\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        int index= 0 , mx = INT_MIN;\\n        solve(nums, v, index, count, mx);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums, vector<int> v, int index, int &count,int &mx)\\n    {\\n        if(index>=nums.size())\\n        {\\n            int ans = 0;\\n            for(int i=0 ;i<v.size() ;i++)\\n            ans = ans|v[i];\\n            if(ans>mx){\\n                count=1;\\n                mx = ans;\\n            }\\n            else if(ans==mx)\\n            count++;\\n            return;\\n        }\\n        solve(nums, v, index+1, count, mx);\\n        v.push_back(nums[index]);\\n        solve(nums, v, index+1, count, mx);\\n        //v.pop_back(); no need for this because we are not passing the reference of vector.\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        int index= 0 , mx = INT_MIN;\\n        solve(nums, v, index, count, mx);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938171,
                "title": "c-beats-95-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Author : S.SARKAR\\n\\n// here we are not making subsets via vectors because it\\'s not needed to push elements into different vectors of subsets, as we need to keep count of the bitwise OR of each subset , so I removed all the push, pop operations and vectors needed, so we are not storing subsets in vectors, but we are actually going through all the subsets \\nclass Solution {\\npublic:\\n    int counter=0;  // counter stores count of subsets with maxm_bitwise_OR\\n// orr is bitwise_OR of all nos. in each subset: \\n    void subs(int index, vector<int>&nums,int orr,int maxm){ \\n        if(index>=nums.size()){  //base case\\n            if(orr==maxm) counter++;\\n            return;\\n        }\\n        subs(index+1,nums,orr,maxm);\\n        subs(index+1,nums,orr|nums[index],maxm);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxm_ORR=0;\\n        for(auto &i: nums){\\n            maxm_ORR|=i;\\n        }\\n        subs(0,nums,0,maxm_ORR); \\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n// Author : S.SARKAR\\n\\n// here we are not making subsets via vectors because it\\'s not needed to push elements into different vectors of subsets, as we need to keep count of the bitwise OR of each subset , so I removed all the push, pop operations and vectors needed, so we are not storing subsets in vectors, but we are actually going through all the subsets \\nclass Solution {\\npublic:\\n    int counter=0;  // counter stores count of subsets with maxm_bitwise_OR\\n// orr is bitwise_OR of all nos. in each subset: \\n    void subs(int index, vector<int>&nums,int orr,int maxm){ \\n        if(index>=nums.size()){  //base case\\n            if(orr==maxm) counter++;\\n            return;\\n        }\\n        subs(index+1,nums,orr,maxm);\\n        subs(index+1,nums,orr|nums[index],maxm);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxm_ORR=0;\\n        for(auto &i: nums){\\n            maxm_ORR|=i;\\n        }\\n        subs(0,nums,0,maxm_ORR); \\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937290,
                "title": "bit-manipulation-bit-masking",
                "content": "int countMaxOrSubsets(vector<int>& nums) {\\n       int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           ans|=nums[i]; \\n        }\\n         \\n        int n=nums.size();\\n\\n      vector<vector<int>>subset;\\n    \\n        for(int i=0;i<(1<<n);i++)\\n        {\\n                vector<int>v;\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                   v.push_back(nums[j]);\\n            }\\n            subset.push_back(v);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<subset.size();i++)\\n        {\\n            int orr=0;\\n          for(int j=0;j<subset[i].size();j++)\\n          {\\n             orr|=subset[i][j]; \\n          }\\n            if(orr==ans)cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "int countMaxOrSubsets(vector<int>& nums) {\\n       int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           ans|=nums[i]; \\n        }\\n         \\n        int n=nums.size();\\n\\n      vector<vector<int>>subset;\\n    \\n        for(int i=0;i<(1<<n);i++)\\n        {\\n                vector<int>v;\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                   v.push_back(nums[j]);\\n            }\\n            subset.push_back(v);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<subset.size();i++)\\n        {\\n            int orr=0;\\n          for(int j=0;j<subset[i].size();j++)\\n          {\\n             orr|=subset[i][j]; \\n          }\\n            if(orr==ans)cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570640,
                "content": [
                    {
                        "username": "LeetCodeFunker",
                        "content": "We can easily know the max value of Bitsise OR, then why we cannot apply DP here? To make it from O(2^N) -> O(N * maxval of Bitwise)"
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 2020925,
                "content": [
                    {
                        "username": "LeetCodeFunker",
                        "content": "We can easily know the max value of Bitsise OR, then why we cannot apply DP here? To make it from O(2^N) -> O(N * maxval of Bitwise)"
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            }
        ]
    }
]