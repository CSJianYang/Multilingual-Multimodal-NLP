[
    {
        "title": "Smallest Missing Non-negative Integer After Operations",
        "question_content": "You are given a 0-indexed integer array nums and an integer value.\nIn one operation, you can add or subtract value from any element of nums.\n\n\tFor example, if nums = [1,2,3] and value = 2, you can choose to subtract value from nums[0] to make nums = [-1,2,3].\n\nThe MEX (minimum excluded) of an array is the smallest missing non-negative integer in it.\n\n\tFor example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.\n\nReturn the maximum MEX of nums after applying the mentioned operation any number of times.\n&nbsp;\nExample 1:\n\nInput: nums = [1,-10,7,13,6,8], value = 5\nOutput: 4\nExplanation: One can achieve this result by applying the following operations:\n- Add value to nums[1] twice to make nums = [1,0,7,13,6,8]\n- Subtract value from nums[2] once to make nums = [1,0,2,13,6,8]\n- Subtract value from nums[3] twice to make nums = [1,0,2,3,6,8]\nThe MEX of nums is 4. It can be shown that 4 is the maximum MEX we can achieve.\n\nExample 2:\n\nInput: nums = [1,-10,7,13,6,8], value = 7\nOutput: 2\nExplanation: One can achieve this result by applying the following operation:\n- subtract value from nums[2] once to make nums = [1,-10,0,13,6,8]\nThe MEX of nums is 2. It can be shown that 2 is the maximum MEX we can achieve.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length, value <= 105\n\t-109 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3313988,
                "title": "count-moduli",
                "content": "For an element `n`, we can achieve the minimum non-negative value of `n % value`.\\n\\nWe can also transform element `n` to `n % value + k * value`. So, we first count moduli we can get from all numbers.\\n\\nThen, we iterate `i` from zero upwards, and check if we have a modulo (`i % value`) that we can tranform to `i`.\\n\\nIf so, we decrease the counter for that modulo. If the counter is zero, we cannot produce `i` and it\\'s our missing value. \\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        m = Counter([n % value for n in nums])\\n        for i in range(len(nums)):\\n            if m[i % value] == 0:\\n                return i\\n            m[i % value] -= 1\\n        return len(nums)\\n```\\n    \\n**C++**\\n```cpp\\nint findSmallestInteger(vector<int>& nums, int v) {\\n    int m[100001] = {}, sz = nums.size();\\n    for (auto n : nums)\\n        // C++ fix for negative remainder: (b + (a % b)) % b\\n        ++m[(v + n % v) % v];\\n    for (int i = 0; i < sz; ++i)\\n        if (--m[i % v] < 0)\\n            return i;\\n    return sz;\\n}\\n```\\nA different way to look at it (suggested by [Benlegend](https://leetcode.com/Benlegend/)). \\n\\nWe can find a modulo with the smalest count. That modulo and count to compute the missing value.\\n\\nThis is useful when value is much smaller than the number of elements.\\n\\n**C++**\\n```cpp\\nint findSmallestInteger(vector<int>& nums, int v) {\\n    int m[100001] = {}, sz = nums.size();\\n    for (auto n : nums)\\n        // C++ fix for negative remainder: (b + (a % b)) % b\\n        ++m[(v + n % v) % v];\\n    int i = min_element(begin(m), begin(m) + v) - begin(m);\\n    return i + m[i] * v;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        m = Counter([n % value for n in nums])\\n        for i in range(len(nums)):\\n            if m[i % value] == 0:\\n                return i\\n            m[i % value] -= 1\\n        return len(nums)\\n```\n```cpp\\nint findSmallestInteger(vector<int>& nums, int v) {\\n    int m[100001] = {}, sz = nums.size();\\n    for (auto n : nums)\\n        // C++ fix for negative remainder: (b + (a % b)) % b\\n        ++m[(v + n % v) % v];\\n    for (int i = 0; i < sz; ++i)\\n        if (--m[i % v] < 0)\\n            return i;\\n    return sz;\\n}\\n```\n```cpp\\nint findSmallestInteger(vector<int>& nums, int v) {\\n    int m[100001] = {}, sz = nums.size();\\n    for (auto n : nums)\\n        // C++ fix for negative remainder: (b + (a % b)) % b\\n        ++m[(v + n % v) % v];\\n    int i = min_element(begin(m), begin(m) + v) - begin(m);\\n    return i + m[i] * v;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314226,
                "title": "java-c-python-count-remainders",
                "content": "# **Intuition**\\nAssume remainder `r = A[i] % k`,\\nthen `A[i]` can be changed to `r, r + k, r + k * 2....`\\nSo we need to check the remainder of all `A[i]` by module `k`.\\n<br>\\n\\n# **Explanation**\\nCounts the frequence of remainders.\\nFor `A[i] >= 0`, `A[i] % k` is non-negative.\\nFor `A[i] < 0`, `A[i] % k` is negative, we need to make it non-negative by `A[i] % k + k`.\\nSo we will calculate all `(A[i] % k + k) % k`,\\nand counts the frequeny `count`.\\n\\n\\n\\nIn the round,\\nwe will try to have 0,1,2,3,...,k-1,\\nwhere every remainder appear once.\\n\\nIn the second round,\\nwe will try to have k,k+1,k+2,k+3,...,k+k-1,\\nwhere every remainder appear once.\\n\\nSo each round,\\nevery remainder appear once.\\nThe sequence will `stop` at the remainder with the minimum frequency.\\n`min[count]` is the number of complete round we can have\\n\\nFinally return `k * count[stop] + stop`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int findSmallestInteger(int[] A, int k) {\\n        int stop = 0, count[] = new int[k];\\n        for (int a : A)\\n            count[(a % k + k) % k]++;\\n        for (int i = 0; i < k; ++i)\\n            if (count[i] < count[stop])\\n                stop = i;\\n        return k * count[stop] + stop;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int findSmallestInteger(vector<int>& A, int k) {\\n        vector<int> count(k, 0);\\n        for (int& a : A)\\n            count[(a % k + k) % k]++;\\n        int stop = 0;\\n        for (int i = 0; i < k; ++i)\\n            if (count[i] < count[stop])\\n                stop = i;\\n        return k * count[stop] + stop;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def findSmallestInteger(self, A, k):\\n        count = Counter(a % k for a in A)\\n        stop = 0\\n        for i in range(k):\\n            if count[i] < count[stop]:\\n                stop = i\\n        return k * count[stop] + stop\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int findSmallestInteger(int[] A, int k) {\\n        int stop = 0, count[] = new int[k];\\n        for (int a : A)\\n            count[(a % k + k) % k]++;\\n        for (int i = 0; i < k; ++i)\\n            if (count[i] < count[stop])\\n                stop = i;\\n        return k * count[stop] + stop;\\n    }\\n```\n```cpp\\n    int findSmallestInteger(vector<int>& A, int k) {\\n        vector<int> count(k, 0);\\n        for (int& a : A)\\n            count[(a % k + k) % k]++;\\n        int stop = 0;\\n        for (int i = 0; i < k; ++i)\\n            if (count[i] < count[stop])\\n                stop = i;\\n        return k * count[stop] + stop;\\n    }\\n```\n```py\\n    def findSmallestInteger(self, A, k):\\n        count = Counter(a % k for a in A)\\n        stop = 0\\n        for i in range(k):\\n            if count[i] < count[stop]:\\n                stop = i\\n        return k * count[stop] + stop\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3315716,
                "title": "simple-and-efficient-approach-o-n-count-moduli-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA simple intuition begins with thinking of addition and subtraction operation as shifting with a scale of value.\\nA shifted number only need 1 parameter i.e. it\\'s modulus with value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs you must have already obsereved that a maximum possible MEX in an array of size N is N.\\n\\nWe will store the count of moduli in a vector.\\n\\nRun a loop from 0 to N.\\nHere iterator will denote the MEX and we will if that MEX is possible or not.\\nwe will check it by shifting it in the range of [0,value) (i.e. range of counted moduli). if its count > 0 then it is possible and we will move to next iteration after decreasing it\\'s count.\\n\\nif it is not possible to make this iterator by shifting then it is our maximum possible MEX and we will break the loop.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) where N is the size of given array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(Value) to store count of moduli.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value)\\n    {\\n        int n = nums.size();\\n\\n        vector<int> hash(value,0);\\n\\n        for(auto i : nums)\\n        {\\n            int md = i%value;\\n\\n            if(md<0)\\n            {\\n                hash[md+value]++;\\n            }\\n            else\\n            {\\n                hash[md]++;\\n            }\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(hash[i%value]>0) hash[i%value]--;\\n            else \\n            {\\n                ans = i;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value)\\n    {\\n        int n = nums.size();\\n\\n        vector<int> hash(value,0);\\n\\n        for(auto i : nums)\\n        {\\n            int md = i%value;\\n\\n            if(md<0)\\n            {\\n                hash[md+value]++;\\n            }\\n            else\\n            {\\n                hash[md]++;\\n            }\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(hash[i%value]>0) hash[i%value]--;\\n            else \\n            {\\n                ans = i;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313993,
                "title": "cpp-easy-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount the modulo with value of all the elements\\n`For Negative` : make its counterpositive then add its modulo \\n`ie` : `(x % value) + value`\\n`For Positive` : `x % value`\\nNow if modulo is 2 and your value is 5 then you can either make 2 , 7 , 12 .. and so on that means you can make `5*k + 2` `k >=0`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(value)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& v, int value) {\\n        unordered_map<int,int> moduloCounter;\\n        for(int x : v) {\\n            moduloCounter[((x % value) + value) % value] += 1;\\n        }\\n        for(int i = 0; i <= v.size(); i += 1) {\\n            int rem = i % value;\\n            if(moduloCounter.count(rem) && moduloCounter[rem] > 0) moduloCounter[rem] -= 1;\\n            else return i;\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& v, int value) {\\n        unordered_map<int,int> moduloCounter;\\n        for(int x : v) {\\n            moduloCounter[((x % value) + value) % value] += 1;\\n        }\\n        for(int i = 0; i <= v.size(); i += 1) {\\n            int rem = i % value;\\n            if(moduloCounter.count(rem) && moduloCounter[rem] > 0) moduloCounter[rem] -= 1;\\n            else return i;\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314515,
                "title": "reminder-count-very-simple-easy-to-understand-solution",
                "content": "# Approach\\nTake the reminder & count the reminder values \\nCounting reminder value is helpful to check the max number when \\nall the reminders in between 0 to value-1 are possible.\\nSo we keep track of the max number possible with each reminder count.\\nIf a particular reminder not possible then return that as the answer.\\nOterwise the min tracked ans return.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int ans = INT_MAX;\\n        vector<int> v(value, 0);\\n        for(auto n: nums) v[((n % value)+value) %value]++;\\n        for(int i = 0; i < v.size(); i++) {\\n            if(v[i] == 0) return i;\\n            ans = min(ans, value*v[i] + i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int ans = INT_MAX;\\n        vector<int> v(value, 0);\\n        for(auto n: nums) v[((n % value)+value) %value]++;\\n        for(int i = 0; i < v.size(); i++) {\\n            if(v[i] == 0) return i;\\n            ans = min(ans, value*v[i] + i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314080,
                "title": "modulo-remainder-counting-easy-and-understandable-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>&v, int x) {\\n        int i,n=v.size(),ans=0;\\n        unordered_map<int,int>m;\\n        for(i=0;i<n;i++)m[(v[i]%x+x)%x]++; \\n        for(i=0;i<n;i++){\\n            if(m[i%x])m[i%x]--;\\n            else return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>&v, int x) {\\n        int i,n=v.size(),ans=0;\\n        unordered_map<int,int>m;\\n        for(i=0;i<n;i++)m[(v[i]%x+x)%x]++; \\n        for(i=0;i<n;i++){\\n            if(m[i%x])m[i%x]--;\\n            else return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314057,
                "title": "java-hashmap-count-mod",
                "content": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        int n = nums.length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            int mod = num % value;\\n            mod = mod >= 0 ? mod : mod + value;\\n            map.put(mod, map.getOrDefault(mod, 0) + 1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int check = i % value;\\n            if (!map.containsKey(check)) {\\n                return i;\\n            }\\n            int freq = map.get(check);\\n            if (freq <= 0) {\\n                return i;\\n            }\\n            map.put(check, freq - 1);\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        int n = nums.length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            int mod = num % value;\\n            mod = mod >= 0 ? mod : mod + value;\\n            map.put(mod, map.getOrDefault(mod, 0) + 1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int check = i % value;\\n            if (!map.containsKey(check)) {\\n                return i;\\n            }\\n            int freq = map.get(check);\\n            if (freq <= 0) {\\n                return i;\\n            }\\n            map.put(check, freq - 1);\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318309,
                "title": "simple-and-concise-solution-beginner-friendly-o-n-o-n",
                "content": "# Intuition\\n- Created a map to store the count of positive remainders.\\n- Each number can be achieved by only one reaminder and that can be used forther for another numbers.\\n- Start iterating from `0` and keep going until find an element whose remainder count in `zero` in map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            int rem = nums[i]%value;\\n            while(rem<0)rem+=value;\\n            mp[rem]++;\\n        }\\n        int i=0;\\n        while(true){\\n            int rem = i%value;\\n            if(mp[rem]<=0)\\n                return i;\\n            else\\n                mp[rem]--;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Please upvote, if you find this helpful \\uD83D\\uDE4F \\n### Thank you in advance ;)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            int rem = nums[i]%value;\\n            while(rem<0)rem+=value;\\n            mp[rem]++;\\n        }\\n        int i=0;\\n        while(true){\\n            int rem = i%value;\\n            if(mp[rem]<=0)\\n                return i;\\n            else\\n                mp[rem]--;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314142,
                "title": "python-count-the-modulo",
                "content": "**Did you know that how we find the Modulo for negative numbers ?**\\n\\nIf n has a limited range, then you can get the result you want simply by adding a known constant multiple of the divisor that is greater that the absolute value of the minimum\\neg. -3 % 4 != 3 (3 % 4)\\n -3 % 4 = (-3+4)%4 =1  or   (4*-1 + 1) % 4 = 1\\n**so in this problem if number is -ve we can add the k x times and make it positive then can take the modulo that what we need i.e simply take the modulo either it is positive or negative**\\n\\nHow mod works : https://www.quora.com/What-is-29-mod-3\\nIn python for -ve number division the rounding is toward -infinity and for +ve numbers the rounding is towards 0\\n**so a % b = a - (a//b) * b   # using the remainder theorem**\\n\\t\\n\\tdef findSmallestInteger(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tn = len(nums)\\n\\n\\t\\t\\tcntMap = Counter([num%k for num in nums])   # hashMap of modulo counts\\n\\n\\t\\t\\tfor i in range(n+1):\\n\\t\\t\\t\\tif cntMap[i%k]:  # if have the modulo used it to make the i\\n\\t\\t\\t\\t\\tcntMap[i%k] -= 1  # used the modulo so remove it\\n\\t\\t\\t\\telse:   # unable to make the i \\n\\t\\t\\t\\t\\treturn i\\n",
                "solutionTags": [],
                "code": "**Did you know that how we find the Modulo for negative numbers ?**\\n\\nIf n has a limited range, then you can get the result you want simply by adding a known constant multiple of the divisor that is greater that the absolute value of the minimum\\neg. -3 % 4 != 3 (3 % 4)\\n -3 % 4 = (-3+4)%4 =1  or   (4*-1 + 1) % 4 = 1\\n**so in this problem if number is -ve we can add the k x times and make it positive then can take the modulo that what we need i.e simply take the modulo either it is positive or negative**\\n\\nHow mod works : https://www.quora.com/What-is-29-mod-3\\nIn python for -ve number division the rounding is toward -infinity and for +ve numbers the rounding is towards 0\\n**so a % b = a - (a//b) * b   # using the remainder theorem**\\n\\t\\n\\tdef findSmallestInteger(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tn = len(nums)\\n\\n\\t\\t\\tcntMap = Counter([num%k for num in nums])   # hashMap of modulo counts\\n\\n\\t\\t\\tfor i in range(n+1):\\n\\t\\t\\t\\tif cntMap[i%k]:  # if have the modulo used it to make the i\\n\\t\\t\\t\\t\\tcntMap[i%k] -= 1  # used the modulo so remove it\\n\\t\\t\\t\\telse:   # unable to make the i \\n\\t\\t\\t\\t\\treturn i\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3314830,
                "title": "c-o-n-solution-using-map-beats-100-with-explaination",
                "content": "# Intuition\\nOne can observe that the elements of the array can be increased/decreased by $k$ any number of times. We use the modular arithmetic approach to set the value to the elements to maximise the $MEX$.\\n\\n# Approach\\nCalculate the mod value of every element by $k$ and store it in a hashmap. After that, start from $0$ till $k$, once you reach k start again from $k$ every time you find the mod value can be done reduce the count in map, once you find there is no remainder value to make that number, that becomes the $MEX$. Check example: \\n\\nA=$[1,2,3,4,20,6,15]$ k=$4$\\n$hash_0$=1 (4,20)\\n$hash_1$=1 (1)\\n$hash_2$=2 (2,6)\\n$hash_3$=2 (3,15)\\n\\nFor $0$, there is a hash decrease the count, for $1$, $2$, $3$ there is a hash value decrease the count. \\nOnce again start from $0$ (this time $MEX$ is 4) there is a hash, but for 1($MEX$ is $5$ here) $hash_1$=0, which becomes the maximum $MEX$ of the array.\\n\\nThe array is internally can be modified like this, A=$[0,1,2,3,4,6,7]$\\n\\n*Note: To handle the mod of negative value, I added ($k*1e8$)+$v_i$ to obtain the positive mod value as MEX refers to smallest positive integer not present in the array.*\\n\\n# Complexity\\n- Time complexity:\\nO($n$) + O($n$) as we are making only $2$ passes.\\n\\n- Space complexity:\\nO($k$) hashmap to store the count of mods.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& v, int val) {\\n        vector<int>p(val);\\n        for(int i=0;i<v.size();i++){\\n            long long int t=v[i]+(1e8*val);\\n            p[t%val]++;\\n        }\\n        int ct=0;\\n        while(1){    \\n            for(int i=0;i<val;i++){\\n                if(p[i]==0){return ct;}\\n                ct++;\\n                p[i]--;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& v, int val) {\\n        vector<int>p(val);\\n        for(int i=0;i<v.size();i++){\\n            long long int t=v[i]+(1e8*val);\\n            p[t%val]++;\\n        }\\n        int ct=0;\\n        while(1){    \\n            for(int i=0;i<val;i++){\\n                if(p[i]==0){return ct;}\\n                ct++;\\n                p[i]--;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316992,
                "title": "python-3-3-lines-counter-w-explanation-t-m-952-ms-33-2-mb",
                "content": "For the sake of discussion let `nums = [7,7,7,4,6,8]`, `value= 5`, and in particular, `n = 7`. the rules allow us to replace any occurrence of 7 with any element of the set:\\n```\\n            {..., -13, -8, -3, 2, 7, 12, 17, ...},\\n```\\nwhich can be expressed as `{7%5 + 5*k for integer k }`.\\n\\nNow, because `nums` has three 7s and `7%5 = 2`, we can create `{ 2, 7, 12}` from those three 7s using the rules.\\n\\nHere\\'s the plan:\\n1. We construct a`Counter`of `n%value` for all`n`in `nums`.\\n2. We determine the key in the Counter that has the least value. In case of tie, we select the key with least value.\\n3. From 2) above, we determine the first non-negative integer that is not possible to create and return that integer.\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n\\n        ctr = Counter(map(lambda x: x%value,nums))  # <\\u2013\\u2013  1.\\n\\n        mn = min((n for n in range(value)),         # <\\u2013\\u2013  2.\\n                  key = lambda x: (ctr[x],x))       #\\n        \\n        return  mn+value*ctr[mn]                    # <\\u2013\\u2013  3.\\n```\\n[https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/submissions/918233952/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n            {..., -13, -8, -3, 2, 7, 12, 17, ...},\\n```\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n\\n        ctr = Counter(map(lambda x: x%value,nums))  # <\\u2013\\u2013  1.\\n\\n        mn = min((n for n in range(value)),         # <\\u2013\\u2013  2.\\n                  key = lambda x: (ctr[x],x))       #\\n        \\n        return  mn+value*ctr[mn]                    # <\\u2013\\u2013  3.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314569,
                "title": "c-quick-explanation-count-remainder-apply-math",
                "content": "Here is the explanation to the last line - `return minIdx + counts[minIdx]*value;`.\\nRead code first.\\n\\n**Code**\\n```cpp\\nint findSmallestInteger(vector<int>& nums, int value) {\\n    vector<int> counts(value);\\n    for(int num: nums){\\n        num = (num % value + value) % value;\\n        counts[num]++;\\n    }\\n\\n    int minIdx = min_element(begin(counts), end(counts)) - begin(counts);\\n    return minIdx + counts[minIdx]*value;\\n}\\n```\\n\\n\\nCase 1: We have one number which appears `count = 0` times.\\n**nums = [0,1,1,2,3,3], value = 5**\\n- The resulting smallest number would be `4` as it doesn\\'t appear.\\n```\\nidx/num -> freq\\n0 -> 1\\n1 -> 2\\n2 -> 1\\n3 -> 2\\n4 -> 0 <-- this is the lowest\\n```\\nCase 2: We have numbers that appear `count >= 1` times.\\n**nums = [0,0,1,1,2,2,3], value = 4**\\n- So the resulting smallest number out from this list. We take the lowest multiple of `lowest count` and `add value`.\\n- Now, lowest count is at `idx/num (of counts[]) = 3`.\\n- So 3 (is present).. but 3 + 1*value (**=7 is not present)**\\n```\\nidx/num -> freq\\n0 -> 2\\n1 -> 2\\n2 -> 2\\n3 -> 1 <-- this is the lowest\\n```\\nQ. How can we be sure *7 is the lowest* here?\\n- Firstly, we know 0, 1, 2, 3 numbers are present.\\n- Is 4 present? - Yes, the `0` can be made use of like - 0, (0 + value = 4). **(Keep in mind - we can use 0 only 2 times due to its freq)**\\n- Is 5 present? - Yes - 1, (1 + value = 5)\\n- Is 6 present? - Yes - 2, (2 + value = 6)\\n- Is 7 present? - Ouch, no - Only 3. **(can be taken only once due to its freq)**.\\n- So here least answer is 3 + value = 7.\\n\\n**Upvote and lets learn together :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint findSmallestInteger(vector<int>& nums, int value) {\\n    vector<int> counts(value);\\n    for(int num: nums){\\n        num = (num % value + value) % value;\\n        counts[num]++;\\n    }\\n\\n    int minIdx = min_element(begin(counts), end(counts)) - begin(counts);\\n    return minIdx + counts[minIdx]*value;\\n}\\n```\n```\\nidx/num -> freq\\n0 -> 1\\n1 -> 2\\n2 -> 1\\n3 -> 2\\n4 -> 0 <-- this is the lowest\\n```\n```\\nidx/num -> freq\\n0 -> 2\\n1 -> 2\\n2 -> 2\\n3 -> 1 <-- this is the lowest\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314414,
                "title": "counting-linear-tc-and-sc",
                "content": "# Intuition\\nJust count the modulo of all the elements with K.\\nnums[i]%value\\nFor -ve, add +k too(To make it +ve) since MEX is >= 0.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>&nums, int val) {\\n        int n=nums.size();\\n        int res=0;\\n        unordered_map<int,int>mp;\\n        set<int>st;\\n        for(int i=0;i<n;i++){\\n            nums[i]=(nums[i]%val+val)%val;\\n            if(mp[nums[i]])nums[i]=mp[nums[i]]+val-1;\\n            st.insert(nums[i]);\\n            mp[nums[i]%val]=nums[i]+1;\\n        }\\n        int mex=0;\\n        for(auto x : st){\\n            if(x==mex)mex++;\\n            else return mex;\\n        }\\n        return mex;\\n    }\\n};\\n\\n```\\n```java []\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int val) {\\n        int n = nums.length;\\n        int res = 0;\\n        Map<Integer, Integer> mp = new HashMap<>();\\n        Set<Integer> st = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = (nums[i] % val + val) % val;\\n            if (mp.containsKey(nums[i])) {\\n                nums[i] = mp.get(nums[i]) + val - 1;\\n            }\\n            st.add(nums[i]);\\n            mp.put(nums[i] % val, nums[i] + 1);\\n        }\\n        int mex = 0;\\n        for (int x : st) {\\n            if (x == mex) {\\n                mex++;\\n            } else {\\n                return mex;\\n            }\\n        }\\n        return mex;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], val: int) -> int:\\n        n = len(nums)\\n        res = 0\\n        mp = {}\\n        st = set()\\n        for i in range(n):\\n            nums[i] = (nums[i] % val + val) % val\\n            if nums[i] in mp:\\n                nums[i] = mp[nums[i]] + val - 1\\n            st.add(nums[i])\\n            mp[nums[i] % val] = nums[i] + 1\\n        mex = 0\\n        for x in sorted(st):\\n            if x == mex:\\n                mex += 1\\n            else:\\n                return mex\\n        return mex\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>&nums, int val) {\\n        int n=nums.size();\\n        int res=0;\\n        unordered_map<int,int>mp;\\n        set<int>st;\\n        for(int i=0;i<n;i++){\\n            nums[i]=(nums[i]%val+val)%val;\\n            if(mp[nums[i]])nums[i]=mp[nums[i]]+val-1;\\n            st.insert(nums[i]);\\n            mp[nums[i]%val]=nums[i]+1;\\n        }\\n        int mex=0;\\n        for(auto x : st){\\n            if(x==mex)mex++;\\n            else return mex;\\n        }\\n        return mex;\\n    }\\n};\\n\\n```\n```java []\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int val) {\\n        int n = nums.length;\\n        int res = 0;\\n        Map<Integer, Integer> mp = new HashMap<>();\\n        Set<Integer> st = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = (nums[i] % val + val) % val;\\n            if (mp.containsKey(nums[i])) {\\n                nums[i] = mp.get(nums[i]) + val - 1;\\n            }\\n            st.add(nums[i]);\\n            mp.put(nums[i] % val, nums[i] + 1);\\n        }\\n        int mex = 0;\\n        for (int x : st) {\\n            if (x == mex) {\\n                mex++;\\n            } else {\\n                return mex;\\n            }\\n        }\\n        return mex;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], val: int) -> int:\\n        n = len(nums)\\n        res = 0\\n        mp = {}\\n        st = set()\\n        for i in range(n):\\n            nums[i] = (nums[i] % val + val) % val\\n            if nums[i] in mp:\\n                nums[i] = mp[nums[i]] + val - 1\\n            st.add(nums[i])\\n            mp[nums[i] % val] = nums[i] + 1\\n        mex = 0\\n        for x in sorted(st):\\n            if x == mex:\\n                mex += 1\\n            else:\\n                return mex\\n        return mex\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314034,
                "title": "python-3-mod-greedy",
                "content": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], val: int) -> int:\\n        nums = sorted( [i % val for i in nums] )\\n        seen = set(nums)\\n        t = 1\\n        \\n        for i in range(len(nums) - 1):\\n            if nums[i] == nums[i + 1]:\\n                seen.add(nums[i] + (t * val))\\n                t += 1\\n            else:\\n                t = 1\\n        \\n        for i in range(len(seen) + 1):\\n            if i not in seen:\\n                return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], val: int) -> int:\\n        nums = sorted( [i % val for i in nums] )\\n        seen = set(nums)\\n        t = 1\\n        \\n        for i in range(len(nums) - 1):\\n            if nums[i] == nums[i + 1]:\\n                seen.add(nums[i] + (t * val))\\n                t += 1\\n            else:\\n                t = 1\\n        \\n        for i in range(len(seen) + 1):\\n            if i not in seen:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503472,
                "title": "most-optimized-c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(n+k)\\n\\n- Space complexity:\\nO(K)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int k) {\\n        // if(k==1)return nums.size();\\n        vector<int> v(k);\\n        int x = nums.size()+1,j;\\n        for(auto &i: nums){\\n            v[(i%k+k)%k]++;\\n        }\\n        for(int i = 0; i < k; i++){\\n            if(v[i]<x){\\n                x = v[i];\\n                j = i;\\n            }\\n        }\\n        return x*k+j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int k) {\\n        // if(k==1)return nums.size();\\n        vector<int> v(k);\\n        int x = nums.size()+1,j;\\n        for(auto &i: nums){\\n            v[(i%k+k)%k]++;\\n        }\\n        for(int i = 0; i < k; i++){\\n            if(v[i]<x){\\n                x = v[i];\\n                j = i;\\n            }\\n        }\\n        return x*k+j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314332,
                "title": "c-easy-hashing-based-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can convert any value to its modulus with value.So i will just count nums[i]%value in a hashmap and check from 0 til n-1.As we know MEX value can be maximum N. SO answer will be between [0,N].\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialise a pre vector of size N with value 0 to check MEX,And a ordered map of <int,int>.\\n2. Traverse through the array nums.if element is negative then add x*value to make it positive \\n3. Take nums[i]%value and store in map.\\n4. Traverse again in for loop from i=0 till i=n-1.Check mp[index%value] is gretaer then 0 or not is it is fill the pre[i] as 1.and decrease map vaue by 1.\\n5. Initialise ans as n, Check in pre array if any element is 0 then return its index.Otherwise return ans at the end.\\n\\n# Complexity\\n- Time complexity:O(N*LOG(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size();\\n        vector<int> pre(n,0);\\n       \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n                int c=nums[i]%value;\\n                if(nums[i]<0)\\n                {\\n                    int ck=abs(nums[i])/value;\\n                    if(abs(nums[i])%value>0) ck++;\\n                    nums[i]+=ck*value;\\n                    c=nums[i]%value;\\n                }\\n                mp[c]++;\\n            \\n        }\\n     \\n        for(int i=0;i<n;i++)\\n        {    \\n            pre[i]=0;\\n            int c=i%value;\\n            if(mp.count(c)==1)\\n            {\\n                pre[i]=1;\\n                mp[c]--;\\n                if(mp[c]==0) mp.erase(c);\\n            }\\n        }\\n        int ans=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre[i]==0) \\n            {\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size();\\n        vector<int> pre(n,0);\\n       \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n                int c=nums[i]%value;\\n                if(nums[i]<0)\\n                {\\n                    int ck=abs(nums[i])/value;\\n                    if(abs(nums[i])%value>0) ck++;\\n                    nums[i]+=ck*value;\\n                    c=nums[i]%value;\\n                }\\n                mp[c]++;\\n            \\n        }\\n     \\n        for(int i=0;i<n;i++)\\n        {    \\n            pre[i]=0;\\n            int c=i%value;\\n            if(mp.count(c)==1)\\n            {\\n                pre[i]=1;\\n                mp[c]--;\\n                if(mp[c]==0) mp.erase(c);\\n            }\\n        }\\n        int ans=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre[i]==0) \\n            {\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314160,
                "title": "java-o-n-log-n-time-clean-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(value)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int findSmallestInteger(int[] nums, int value) {\\n    var n = nums.length;\\n    var map = new int[value][2];\\n    \\n    for (var i=0; i < value; i++)\\n      map[i][0] = i;\\n    \\n    for (var a : nums) {\\n      if (a < 0 && a % value != 0)\\n        map[value + a % value][1]++;\\n      else\\n        map[a % value][1]++;\\n    }\\n    Arrays.sort(map, (a,b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\\n    \\n    return map[0][0] + map[0][1] * value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int findSmallestInteger(int[] nums, int value) {\\n    var n = nums.length;\\n    var map = new int[value][2];\\n    \\n    for (var i=0; i < value; i++)\\n      map[i][0] = i;\\n    \\n    for (var a : nums) {\\n      if (a < 0 && a % value != 0)\\n        map[value + a % value][1]++;\\n      else\\n        map[a % value][1]++;\\n    }\\n    Arrays.sort(map, (a,b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\\n    \\n    return map[0][0] + map[0][1] * value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314130,
                "title": "easy-code-code-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n\\n        // change all the number to nearest positive\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                nums[i]+=((abs(nums[i])/value)*value);\\n                if(nums[i]<0) nums[i]+=value;\\n            }\\n        }\\n        // make an array for storing freq of remainders\\n        vector<int>a(100001,0);\\n        // store the frequencies of all the remainders\\n        for(auto& i:nums){\\n            a[i%value]++;\\n        }\\n        // just check which remainder is not available \\n        int n=nums.size()/value +1;\\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<value;i++){\\n                if(a[i]==j) return value*j + i;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n\\n        // change all the number to nearest positive\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                nums[i]+=((abs(nums[i])/value)*value);\\n                if(nums[i]<0) nums[i]+=value;\\n            }\\n        }\\n        // make an array for storing freq of remainders\\n        vector<int>a(100001,0);\\n        // store the frequencies of all the remainders\\n        for(auto& i:nums){\\n            a[i%value]++;\\n        }\\n        // just check which remainder is not available \\n        int n=nums.size()/value +1;\\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<value;i++){\\n                if(a[i]==j) return value*j + i;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314026,
                "title": "intuition-explained-maths-video-solution-easy",
                "content": "# Intuition\\nCan you convert a number X to a number Y ? \\nYes, the condition is the value you can add/subtract any number of times (let\\u2019s say val) satisfies the equation \\n(X-Y)%val=0.\\n# Approach\\n\\n\\nAssuming 3 is the value and you\\u2019ve got v=[1,3,5,6] as the numbers. Taking mod of each number with val(3) we get v\\\\`=[1,0,2,0]. What\\u2019s the MEX? It\\u2019s 4 actually. But how? You can use construct 0 from v\\\\`[1], 1 from v\\\\`[0], 2 from v\\\\`[2], 3 from v\\\\`[3]. You can\\u2019t construct 4 now!\\nTo formalize we can say that we can convert a number X to Y (according to our explanation above (X&Y). so we need to check if we have an element i%val in the array v`. But when you utilize an element for construction you need to make sure that It\\u2019s not utilized again and hence you need to decrement it\\u2019s frequency [use hashmaps for this purpose]. The code is simple and self-explanatory.\\nYou are requested to go through the video here for more clarity:  https://www.youtube.com/watch?v=6gf3ijbYWrs\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int v) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[((nums[i]%v)+v)%v]++;\\n            \\n        }\\n        for(int i=0;i<2*n;i++){\\n            if(mp[i%v]>0){\\n                mp[i%v]--;\\n            }\\n            else return i;\\n        }\\n        return n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int v) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[((nums[i]%v)+v)%v]++;\\n            \\n        }\\n        for(int i=0;i<2*n;i++){\\n            if(mp[i%v]>0){\\n                mp[i%v]--;\\n            }\\n            else return i;\\n        }\\n        return n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735353,
                "title": "easy-greedy-hashing-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert the given array to module array in the following ways:----\\n**array = [4,2,-5,8,-9,10] value = 4**\\n\\nif **array[i]>0, then array[i] = array[i] % value**\\nelse **array[i] = value + array[i] % value**\\n\\n**Now the array becomes = [0,2,3,0,3,2]**\\nNow we see that we can handle **all cases of Array[i]+n*Value(here n = 0,1,2,3......)** .\\n\\n**For example:-\\nArray[0]=0: 0,4,8,12,16....... We can choose one position among them but we choose minimum (0) first.\\nTable[1]=2: 2,6,10,14,18,... We can choose one position among them but we choose minimum(2) first.\\nArray[2]=3: 3,7,11,15,19,... We can choose one position among them but we choose minimum(3) first.\\narray[3]=0: 0,4,8,12,16.......we can choose one position among them but we choose minimum first (4 because 0 is already taken) .\\nTable[4]=3: 3,7,11,15,19,... We can choose one position among them but we choose the minimum first (7 because 3 is already taken).\\nTable[1]=2: 2,6,10,14,18,... We can choose a position among them but we choose the minimum first (6 because 2 is already taken).**\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& arr, int val) {\\n        int n = arr.size();\\n        vector<int> v(n+1,0);\\n        if(val==1) return n;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(arr[i]<0 && arr[i]%val!=0)\\n            arr[i] = val+arr[i]%val;\\n            else arr[i] = arr[i]%val;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n           if(arr[i]<=n && v[arr[i]]==0)\\n           v[arr[i]] = 1; \\n           else if(arr[i]<=n)\\n           {\\n               int j = arr[i];\\n               while(j<=n && v[j]==1) j+=val;\\n               if(j<=n && v[j]==0) v[j] = 1;\\n           }\\n        }\\n        for(int i = 0;i<=n;i++)\\n        if(v[i]==0) return i;\\n        return n+1;     \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/faa1574d-0255-4cb6-b04a-c15349704ba8_1688802370.9684057.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& arr, int val) {\\n        int n = arr.size();\\n        vector<int> v(n+1,0);\\n        if(val==1) return n;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(arr[i]<0 && arr[i]%val!=0)\\n            arr[i] = val+arr[i]%val;\\n            else arr[i] = arr[i]%val;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n           if(arr[i]<=n && v[arr[i]]==0)\\n           v[arr[i]] = 1; \\n           else if(arr[i]<=n)\\n           {\\n               int j = arr[i];\\n               while(j<=n && v[j]==1) j+=val;\\n               if(j<=n && v[j]==0) v[j] = 1;\\n           }\\n        }\\n        for(int i = 0;i<=n;i++)\\n        if(v[i]==0) return i;\\n        return n+1;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314870,
                "title": "python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        # here in order to find the first non negative missing number \\n        # first calculate the remainder (nums[i]%value) of all element and count the no of occurences of same remainders\\n        # the maximum value of the remainder will be (value - 1) \\n\\n        # consider \\n        #    [0,3,-7,1]\\n        #    0%3=0  , 3%3=0 , -7%3=2  , 1%3=1\\n        #    so therefore ,  d = { 0 : 2 , 1 : 1  , 2 :1 }\\n        #    if any remainder less than the value is not present in the dictionary then that is the missing number\\n        #    else linearly traverse the dictionary and subtract the frequency of the rem by 1 \\n        #    if you reach 0 then that is the missing value\\n        \\n        d = {} # dictionary to store the remainders and its count \\n        l = [-1]*(value) # list to know whether the rem is found or not if it is not found then it will be -1 and that corresponding position is the missing value\\n\\n        for i in range(len(nums)) :\\n            if nums[i]%value in d :\\n               d[nums[i]%value] += 1\\n            else:\\n                d[nums[i]%value] = 1\\n                l[nums[i]%value] = 1\\n        if -1 in l:\\n            return l.index(-1)  \\n\\n        # this is for if every rem is found ie all nos from (0 to value-1) is found\\n        \\n        cnt = 0\\n        #storing the frequency of the remainders in a list\\n        lis = [d[x] for x in range(0,value)]  \\n        i = 0\\n\\n        #decrement the frequency each time\\n        #increment the count \\n        # if the frequency becomes 0 then that is the missing value\\n        while(lis[i]!=0) :\\n            if lis[i]!=0 :\\n                cnt += 1\\n                lis[i]-=1\\n                i += 1\\n                i%=value #done to avoid ovwerflow error\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        # here in order to find the first non negative missing number \\n        # first calculate the remainder (nums[i]%value) of all element and count the no of occurences of same remainders\\n        # the maximum value of the remainder will be (value - 1) \\n\\n        # consider \\n        #    [0,3,-7,1]\\n        #    0%3=0  , 3%3=0 , -7%3=2  , 1%3=1\\n        #    so therefore ,  d = { 0 : 2 , 1 : 1  , 2 :1 }\\n        #    if any remainder less than the value is not present in the dictionary then that is the missing number\\n        #    else linearly traverse the dictionary and subtract the frequency of the rem by 1 \\n        #    if you reach 0 then that is the missing value\\n        \\n        d = {} # dictionary to store the remainders and its count \\n        l = [-1]*(value) # list to know whether the rem is found or not if it is not found then it will be -1 and that corresponding position is the missing value\\n\\n        for i in range(len(nums)) :\\n            if nums[i]%value in d :\\n               d[nums[i]%value] += 1\\n            else:\\n                d[nums[i]%value] = 1\\n                l[nums[i]%value] = 1\\n        if -1 in l:\\n            return l.index(-1)  \\n\\n        # this is for if every rem is found ie all nos from (0 to value-1) is found\\n        \\n        cnt = 0\\n        #storing the frequency of the remainders in a list\\n        lis = [d[x] for x in range(0,value)]  \\n        i = 0\\n\\n        #decrement the frequency each time\\n        #increment the count \\n        # if the frequency becomes 0 then that is the missing value\\n        while(lis[i]!=0) :\\n            if lis[i]!=0 :\\n                cnt += 1\\n                lis[i]-=1\\n                i += 1\\n                i%=value #done to avoid ovwerflow error\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314698,
                "title": "simple-java-solution-explained",
                "content": "```\\n\\n\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        \\n        Set<Integer> set = new TreeSet<>();   // use treeset to store the element in sorted order\\n        Map<Integer, Integer> map = new HashMap<>();   // use map to get the freq\\n\\t\\t\\t\\t\\n        int n = nums.length;\\n        int[] arr = new int[n]; \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] % value >= 0)\\n            {\\n                map.put(nums[i] % value, map.getOrDefault(nums[i] % value, 0) + 1);\\n                if(!set.contains(nums[i] % value)){\\n                    arr[i] = (nums[i]) % value;\\n                    set.add(arr[i]);\\n                }\\n                else\\n                {\\n                    arr[i] = nums[i] % value + value*(map.get(nums[i] % value) - 1);\\n                    set.add(arr[i]);\\n                }   \\n            }\\n            else \\n            {\\n                int x = nums[i] % value;      \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// when the number is negative add the value untill it becomes positive\\n                while(x < 0){\\n                    x = x + value;\\n                }\\n                    \\n                map.put(x % value, map.getOrDefault(x, 0) + 1);\\n                if(!set.contains(x % value)){\\n                    arr[i] = x % value;\\n                    set.add(arr[i]);\\n                }\\n                else\\n                {\\n                    arr[i] = x % value + value*(map.get(x % value) - 1);\\n                    set.add(arr[i]);\\n                }\\n            }\\n        }\\n        \\n        int p = 0;\\n        \\n        for(int x : set)\\n        {\\n            if(x == p)\\n                p++;\\n            else\\n                return p;\\n        }\\n        \\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        \\n        Set<Integer> set = new TreeSet<>();   // use treeset to store the element in sorted order\\n        Map<Integer, Integer> map = new HashMap<>();   // use map to get the freq\\n\\t\\t\\t\\t\\n        int n = nums.length;\\n        int[] arr = new int[n]; \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] % value >= 0)\\n            {\\n                map.put(nums[i] % value, map.getOrDefault(nums[i] % value, 0) + 1);\\n                if(!set.contains(nums[i] % value)){\\n                    arr[i] = (nums[i]) % value;\\n                    set.add(arr[i]);\\n                }\\n                else\\n                {\\n                    arr[i] = nums[i] % value + value*(map.get(nums[i] % value) - 1);\\n                    set.add(arr[i]);\\n                }   \\n            }\\n            else \\n            {\\n                int x = nums[i] % value;      \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// when the number is negative add the value untill it becomes positive\\n                while(x < 0){\\n                    x = x + value;\\n                }\\n                    \\n                map.put(x % value, map.getOrDefault(x, 0) + 1);\\n                if(!set.contains(x % value)){\\n                    arr[i] = x % value;\\n                    set.add(arr[i]);\\n                }\\n                else\\n                {\\n                    arr[i] = x % value + value*(map.get(x % value) - 1);\\n                    set.add(arr[i]);\\n                }\\n            }\\n        }\\n        \\n        int p = 0;\\n        \\n        for(int x : set)\\n        {\\n            if(x == p)\\n                p++;\\n            else\\n                return p;\\n        }\\n        \\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314608,
                "title": "python3-solution-clean-concise",
                "content": "# Approach\\nSince we can `add or subtract` as many times, first we made all the elements in range(0, value) by taking its `modulus` (simply by adding or subtracting) and store its count in `dp`. \\n\\nNow we just need to check that `i % v` exist or not in `dp` for making a number equal to i , if it exist then by adding `(i % v) + k * v = i`, it proves that if i % v exist, i can be obtain by adding operation.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python\\nclass Solution:\\n    def findSmallestInteger(self, A: List[int], v: int) -> int:\\n        n = len(A)\\n        m = min(n, v)\\n        dp = [0] * m\\n        for i in A:\\n            if i % v < m:  \\n                dp[i % v] += 1\\n        for i in range(n):\\n            if i % v >= n or dp[i % v] == 0: return i \\n            dp[i % v] -= 1\\n        return n\\n```",
                "solutionTags": [
                    "Python3",
                    "Counting"
                ],
                "code": "```Python\\nclass Solution:\\n    def findSmallestInteger(self, A: List[int], v: int) -> int:\\n        n = len(A)\\n        m = min(n, v)\\n        dp = [0] * m\\n        for i in A:\\n            if i % v < m:  \\n                dp[i % v] += 1\\n        for i in range(n):\\n            if i % v >= n or dp[i % v] == 0: return i \\n            dp[i % v] -= 1\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314574,
                "title": "count-reminder-cpp",
                "content": "\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int  val) {\\n        map<int,int>mp;\\n        for(auto &it:nums)it=it%val;\\n        for(auto &it:nums){\\n            if(it<0)it+=val;\\n        }\\n        for(auto  it:nums)mp[it]++;\\n        int n=nums.size();\\n    \\n        for(int  i=0;i<n;i++)\\n        {   \\n            if(mp[i]>0){mp[i]--;\\n                       continue;}\\n            int rem=i%val;\\n            if(mp[rem]>0)mp[rem]--;\\n            else return i;\\n             \\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int  val) {\\n        map<int,int>mp;\\n        for(auto &it:nums)it=it%val;\\n        for(auto &it:nums){\\n            if(it<0)it+=val;\\n        }\\n        for(auto  it:nums)mp[it]++;\\n        int n=nums.size();\\n    \\n        for(int  i=0;i<n;i++)\\n        {   \\n            if(mp[i]>0){mp[i]--;\\n                       continue;}\\n            int rem=i%val;\\n            if(mp[rem]>0)mp[rem]--;\\n            else return i;\\n             \\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314322,
                "title": "c-short-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> v(value,0);\\n        // cout<<\"#\";\\n        int aaa = value;\\n        for(int i = 0; i <aaa; i++){};\\n        for(auto &i: nums){\\n            // cout<<(i%value);\\n            v[((i%value)+value)%value]++;\\n        }\\n        // cout<<\"#\";\\n        int x = 0;\\n        int mx = INT_MAX;\\n        for(auto &i: v){\\n            if(i<mx){\\n                x = 0;\\n                mx = i;\\n            }\\n            if(mx==i){\\n                x++;\\n            }\\n        }\\n        // cout<<\"#\";\\n        if(x==value){\\n            return x*mx;\\n        }\\n        for(int i = 0; i < value; i++){\\n            if(v[i]==mx){\\n                return mx*value+i;\\n            }\\n        }\\n        // cout<<\"#\";\\n        return value;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> v(value,0);\\n        // cout<<\"#\";\\n        int aaa = value;\\n        for(int i = 0; i <aaa; i++){};\\n        for(auto &i: nums){\\n            // cout<<(i%value);\\n            v[((i%value)+value)%value]++;\\n        }\\n        // cout<<\"#\";\\n        int x = 0;\\n        int mx = INT_MAX;\\n        for(auto &i: v){\\n            if(i<mx){\\n                x = 0;\\n                mx = i;\\n            }\\n            if(mx==i){\\n                x++;\\n            }\\n        }\\n        // cout<<\"#\";\\n        if(x==value){\\n            return x*mx;\\n        }\\n        for(int i = 0; i < value; i++){\\n            if(v[i]==mx){\\n                return mx*value+i;\\n            }\\n        }\\n        // cout<<\"#\";\\n        return value;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314296,
                "title": "short-concise-mod-frequency-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> mod(value);\\n        for(int i : nums) {\\n            if(i < 0) mod[(i % value) ? (i % value) + value : 0]++;\\n            else mod[i % value]++;\\n        }\\n\\n        int mn = 1e9;\\n        for(int i : mod) mn = min(mn, i);\\n\\n        for(int i=0; i<value; i++) {\\n            if(mod[i] == mn) return mn * value + i;\\n        }\\n        return mn * value;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> mod(value);\\n        for(int i : nums) {\\n            if(i < 0) mod[(i % value) ? (i % value) + value : 0]++;\\n            else mod[i % value]++;\\n        }\\n\\n        int mn = 1e9;\\n        for(int i : mod) mn = min(mn, i);\\n\\n        for(int i=0; i<value; i++) {\\n            if(mod[i] == mn) return mn * value + i;\\n        }\\n        return mn * value;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314187,
                "title": "python3-modulus-o-n-clean-concise",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(value)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        counter = Counter([x % value for x in nums])\\n        ans = 0\\n        while counter[ans % value] > 0:\\n            counter[ans % value] -= 1\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        counter = Counter([x % value for x in nums])\\n        ans = 0\\n        while counter[ans % value] > 0:\\n            counter[ans % value] -= 1\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314084,
                "title": "find-remainder-python3-simple-and-concise",
                "content": "\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        count = Counter() \\n        for i in nums:\\n            count[i%value] += 1 \\n        \\n        for i in range(len(nums)):\\n            rem = i % value \\n            if count[rem] <= 0:\\n                return i \\n            count[rem] -= 1 \\n            \\n        return i+1\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        count = Counter() \\n        for i in nums:\\n            count[i%value] += 1 \\n        \\n        for i in range(len(nums)):\\n            rem = i % value \\n            if count[rem] <= 0:\\n                return i \\n            count[rem] -= 1 \\n            \\n        return i+1\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745042,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int k) {\\n         int stop = 0, count[] = new int[k];\\n        for (int a : nums)\\n            count[(a % k + k) % k]++;\\n        for (int i = 0; i < k; ++i)\\n            if (count[i] < count[stop])\\n                stop = i;\\n        return k * count[stop] + stop;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int k) {\\n         int stop = 0, count[] = new int[k];\\n        for (int a : nums)\\n            count[(a % k + k) % k]++;\\n        for (int i = 0; i < k; ++i)\\n            if (count[i] < count[stop])\\n                stop = i;\\n        return k * count[stop] + stop;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693062,
                "title": "c-beginner-friendly-hashing",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int val) {\\n        \\n        //make positive\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                if(abs(nums[i])%val==0){\\n                    int quo=abs(nums[i])/val;\\n                    nums[i]+=(val*quo);\\n                }else{\\n                    int quo=abs(nums[i])/val;\\n                    quo+=1;\\n                    nums[i]+=(val*quo);\\n                }\\n            }\\n        }\\n        \\n        //sort, hash\\n        map<int,queue<int>> mp;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            int rem=nums[i]%val;\\n            mp[rem].push(nums[i]);\\n        }\\n        //for(auto it:nums) cout<<it<<\" \";\\n        //find\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==c){\\n                int rem=c%val;\\n                if(!mp[rem].empty()&&mp[rem].front()==nums[i]){\\n                    mp[rem].pop();\\n                }\\n            }else{\\n                int rem=c%val;\\n                if(mp[rem].empty()){\\n                    return c;\\n                }else{\\n                    mp[rem].pop();\\n                }\\n            }\\n            c++;\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int val) {\\n        \\n        //make positive\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                if(abs(nums[i])%val==0){\\n                    int quo=abs(nums[i])/val;\\n                    nums[i]+=(val*quo);\\n                }else{\\n                    int quo=abs(nums[i])/val;\\n                    quo+=1;\\n                    nums[i]+=(val*quo);\\n                }\\n            }\\n        }\\n        \\n        //sort, hash\\n        map<int,queue<int>> mp;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            int rem=nums[i]%val;\\n            mp[rem].push(nums[i]);\\n        }\\n        //for(auto it:nums) cout<<it<<\" \";\\n        //find\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==c){\\n                int rem=c%val;\\n                if(!mp[rem].empty()&&mp[rem].front()==nums[i]){\\n                    mp[rem].pop();\\n                }\\n            }else{\\n                int rem=c%val;\\n                if(mp[rem].empty()){\\n                    return c;\\n                }else{\\n                    mp[rem].pop();\\n                }\\n            }\\n            c++;\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3672472,
                "title": "c-o-n-solution-maps",
                "content": "# Intuition\\nThe basic intuition is to that we can form all the numbers by adding subtracting k and now we have to form the smaller number first\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use two maps one that will store wether we already formed the number or not and if yes then we can only form the next number is nums[i]+k. The mp will store the value of the next number we can form.\\nThe ans will just use to calculate the smallest number which is not found and store the numbers which have been found.\\nStep by Step explantion:\\n1. First we will check whether the number is negative or not if negative we have to make it positive.(Try with the code i have written in an negative number example you will surely understand)\\n2. Then we will check if the number is already formed then we will form the next possible number.\\n3. If not then we form the current number and in both the cases we will store the next possible number in mp.\\n4. At last we will just travel in the map and see the first number which is missing.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int k) {\\n        \\n        int maxi=0;\\n        unordered_map<int,int>mp;\\n       map<int,int>ans;\\n       \\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]<0){\\n                 int q=abs(nums[i]);\\n                 if(q%k==0){\\n                     nums[i]=0;    \\n                 }\\n                 else\\n                     nums[i]=k-q%k;\\n             }\\n                int a=nums[i]%k;\\n            if(ans.find(a)!=ans.end())\\n                {\\n                    \\n                   ans[mp[a]]=1;\\n                    mp[a]=mp[a]+k;\\n                    \\n                }\\n            else{\\n                ans[a]=1;\\n                mp[a]=a+k;\\n            } \\n        }\\n        int i=0;\\n       for(auto it:ans){\\n           if(it.first!=i){\\n               break;\\n           }\\n           i++;\\n       }\\n        return i;\\n    }\\n};\\n```\\nIf you like the solution then please UPVOTE!!\\nAnd in case of any query or suggestion please feel free to reach out. \\nTHANKS.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int k) {\\n        \\n        int maxi=0;\\n        unordered_map<int,int>mp;\\n       map<int,int>ans;\\n       \\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]<0){\\n                 int q=abs(nums[i]);\\n                 if(q%k==0){\\n                     nums[i]=0;    \\n                 }\\n                 else\\n                     nums[i]=k-q%k;\\n             }\\n                int a=nums[i]%k;\\n            if(ans.find(a)!=ans.end())\\n                {\\n                    \\n                   ans[mp[a]]=1;\\n                    mp[a]=mp[a]+k;\\n                    \\n                }\\n            else{\\n                ans[a]=1;\\n                mp[a]=a+k;\\n            } \\n        }\\n        int i=0;\\n       for(auto it:ans){\\n           if(it.first!=i){\\n               break;\\n           }\\n           i++;\\n       }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568397,
                "title": "easy-hash-table-implementation-in-c",
                "content": "# Intuition\\nLooking carefully we can notice that the MEX would have a range of [0,N] where N is the size of the given **nums**. \\n\\n# Approach\\nSimply put the value of the non-negative remainder obtained by dividing the number in **nums** with the variable **value**. As there is no limitation on the number of additions and subtractions needed to achieve the final array, we can run a loop of the size equivalent to the size of the array and break the look in case there is a discontinuity. That will be the answer to the question.   \\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {   \\n    int n = nums.size();\\n    sort(nums.begin(),nums.end());\\n    map<int,int> mp; \\n    for(int i = 0 ; i < nums.size(); i++){\\n        if(nums[i] < 0){\\n            if(nums[i] % value ==0) mp[0]++;\\n            else mp[(nums[i]+value*(abs(nums[i]/value)+1))%value]++;\\n        }\\n        else mp[(nums[i])%value]++;\\n    }\\n    for(int i = 0 ; i <= n ; i++){\\n        if(mp.find(i%value) != mp.end()){\\n            mp[i%value]--;\\n            if(mp[i%value] == 0) mp.erase(i%value);\\n        }\\n        else return i;\\n    }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {   \\n    int n = nums.size();\\n    sort(nums.begin(),nums.end());\\n    map<int,int> mp; \\n    for(int i = 0 ; i < nums.size(); i++){\\n        if(nums[i] < 0){\\n            if(nums[i] % value ==0) mp[0]++;\\n            else mp[(nums[i]+value*(abs(nums[i]/value)+1))%value]++;\\n        }\\n        else mp[(nums[i])%value]++;\\n    }\\n    for(int i = 0 ; i <= n ; i++){\\n        if(mp.find(i%value) != mp.end()){\\n            mp[i%value]--;\\n            if(mp[i%value] == 0) mp.erase(i%value);\\n        }\\n        else return i;\\n    }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383594,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        a=[x % value for x in nums]\\n        A=Counter(a)\\n        ans=0\\n        while A[ans % value] > 0:\\n            A[ans % value]-=1\\n            ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        a=[x % value for x in nums]\\n        A=Counter(a)\\n        ans=0\\n        while A[ans % value] > 0:\\n            A[ans % value]-=1\\n            ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338078,
                "title": "java-using-only-given-array",
                "content": "# Intuition\\nFirst, finding modulo for each number. If modulo is negative, then just add value and we\\'ll get positive number.\\n\\nSort the array. We will have arrays of remainders.\\n\\nThen depending on number of remainders we need to form numbers which give current remainder starting from the remainder itself. Example:\\n[0, 0, 0, 1, 1, 1] with value = 3 will be [0, 3, 6, 1, 4, 7]\\n\\nAfter that again sort the array: [0, 1, 3, 4, 6, 7]\\n\\nAnd, finally, find the smallest non-existing number from array. [which is 2]\\n\\n# Complexity\\n- Time complexity: O(3N + 2N*logN) => O(N * (3 + 2logN))\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            int mod = n % value;\\n            if (mod < 0) mod += value;\\n            nums[i] = mod;\\n        }\\n\\n        Arrays.sort(nums);\\n        int mem = -1, count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int curr = nums[i];\\n            if (curr != mem) {\\n                count = 0;\\n                mem = curr;\\n            } else {\\n                count++;\\n            }\\n            nums[i] = curr + count * value;\\n        }\\n\\n        Arrays.sort(nums);\\n        \\n        count = 0;\\n        for (int n : nums) if (n != count++) return count - 1;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            int mod = n % value;\\n            if (mod < 0) mod += value;\\n            nums[i] = mod;\\n        }\\n\\n        Arrays.sort(nums);\\n        int mem = -1, count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int curr = nums[i];\\n            if (curr != mem) {\\n                count = 0;\\n                mem = curr;\\n            } else {\\n                count++;\\n            }\\n            nums[i] = curr + count * value;\\n        }\\n\\n        Arrays.sort(nums);\\n        \\n        count = 0;\\n        for (int n : nums) if (n != count++) return count - 1;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330301,
                "title": "o-n-easy-to-understand-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n\\n        int n=nums.size();\\n        int p=max(n,value);\\n        if(value==1){\\n//            cout<<n<<endl;\\n            return n;\\n        }\\n        vector<int>arr(p,0);\\n        vector<int>counter(p,0);\\n\\n        int mul=1;\\n        for(int i=0;i<n;i++){\\n            int index;\\n            if(nums[i]%value==0){\\n                index=abs(nums[i])%value;\\n            }\\n            else if(nums[i]%value<0){\\n                index=nums[i]%value;\\n                index=index+value;\\n            }\\n            else{\\n                index=abs(nums[i])%value;\\n            }\\n\\n            if(arr[index]==0){\\n                arr[index]++;\\n                counter[index]++;\\n\\n//                cout<<index<<\" \";\\n            }\\n            else{\\n                int num=index+(counter[index]*value);\\n                counter[index]++;\\n                if(num<p){\\n                    arr[num]++;\\n                }\\n                \\n\\n//                cout<<num<<\" \";\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==0){\\n//                cout<<i<<endl;\\n                return i;\\n            }            \\n        }\\n\\n//        cout<<endl;\\n/*        for(auto i:arr){\\n            cout<<i<<\" \";\\n        }\\n        cout<<endl;\\n        cout<<n<<endl;\\n*/\\n\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n\\n        int n=nums.size();\\n        int p=max(n,value);\\n        if(value==1){\\n//            cout<<n<<endl;\\n            return n;\\n        }\\n        vector<int>arr(p,0);\\n        vector<int>counter(p,0);\\n\\n        int mul=1;\\n        for(int i=0;i<n;i++){\\n            int index;\\n            if(nums[i]%value==0){\\n                index=abs(nums[i])%value;\\n            }\\n            else if(nums[i]%value<0){\\n                index=nums[i]%value;\\n                index=index+value;\\n            }\\n            else{\\n                index=abs(nums[i])%value;\\n            }\\n\\n            if(arr[index]==0){\\n                arr[index]++;\\n                counter[index]++;\\n\\n//                cout<<index<<\" \";\\n            }\\n            else{\\n                int num=index+(counter[index]*value);\\n                counter[index]++;\\n                if(num<p){\\n                    arr[num]++;\\n                }\\n                \\n\\n//                cout<<num<<\" \";\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==0){\\n//                cout<<i<<endl;\\n                return i;\\n            }            \\n        }\\n\\n//        cout<<endl;\\n/*        for(auto i:arr){\\n            cout<<i<<\" \";\\n        }\\n        cout<<endl;\\n        cout<<n<<endl;\\n*/\\n\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3327926,
                "title": "count-modulus-java-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        // mod of nums[i] with value basically means we can turn it into anything we want;\\n        int l = nums.length;\\n        int [] mod = new int[value];\\n        for(int a:nums)mod[(value + a%value)%value]++;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0;i<value;i++)min = Math.min(value*(mod[i]) + i,min);\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        // mod of nums[i] with value basically means we can turn it into anything we want;\\n        int l = nums.length;\\n        int [] mod = new int[value];\\n        for(int a:nums)mod[(value + a%value)%value]++;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0;i<value;i++)min = Math.min(value*(mod[i]) + i,min);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318960,
                "title": "c-hashmap-math-faster-easy-to-understand",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        int n = nums.size();\\n        \\n        // declare an unordered map\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // store the frequency of the mod\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int mod = nums[i] % value;\\n            \\n            if(mod < 0)\\n            {\\n                mod += value;\\n            }\\n            \\n            mp[mod]++;\\n        }\\n        \\n        // declare a visited array\\n        \\n        vector<bool> vis(1e6 + 1, false);\\n        \\n        // traverse over the map and mark the possible integer as visited\\n        \\n        for(auto x : mp)\\n        {\\n            for(int i = 0; i < x.second; i++)\\n            {\\n                vis[x.first + i * value] = true;\\n            }\\n        }\\n        \\n        // find the first missing non-negative number\\n        \\n        for(int i = 0; i < vis.size(); i++)\\n        {\\n            if(vis[i] == false)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return 1e6 + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        int n = nums.size();\\n        \\n        // declare an unordered map\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // store the frequency of the mod\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int mod = nums[i] % value;\\n            \\n            if(mod < 0)\\n            {\\n                mod += value;\\n            }\\n            \\n            mp[mod]++;\\n        }\\n        \\n        // declare a visited array\\n        \\n        vector<bool> vis(1e6 + 1, false);\\n        \\n        // traverse over the map and mark the possible integer as visited\\n        \\n        for(auto x : mp)\\n        {\\n            for(int i = 0; i < x.second; i++)\\n            {\\n                vis[x.first + i * value] = true;\\n            }\\n        }\\n        \\n        // find the first missing non-negative number\\n        \\n        for(int i = 0; i < vis.size(); i++)\\n        {\\n            if(vis[i] == false)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return 1e6 + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317496,
                "title": "easy-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(VALUE)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        \\n        int vis[]=new int[value];\\n        for(int it:nums){\\n            if(it%value<0) vis[(it%value)+value]++;\\n           else vis[Math.abs(it)%value]++; \\n        }\\n        \\n        \\n        int res=0;\\n        \\n        while(true){\\n            \\n            if(vis[res%value]==0) return res;\\n            vis[res%value]--;\\n            res++;\\n        }\\n        \\n        // return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        \\n        int vis[]=new int[value];\\n        for(int it:nums){\\n            if(it%value<0) vis[(it%value)+value]++;\\n           else vis[Math.abs(it)%value]++; \\n        }\\n        \\n        \\n        int res=0;\\n        \\n        while(true){\\n            \\n            if(vis[res%value]==0) return res;\\n            vis[res%value]--;\\n            res++;\\n        }\\n        \\n        // return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316468,
                "title": "100-faster-a-new-solution-with-the-help-of-priorityqueue-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n         // convert all number to positive and find mod\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i : nums) {\\n            int val = i;\\n            if(i%value<0) {\\n                val = i%value + value;\\n            }\\n            else{\\n                val = i%value;\\n            }\\n            \\n            pq.offer(val);\\n        }\\n        \\n        \\n        // now we have all the numbers in order from 1 to value\\n        int res = 0;\\n        while(!pq.isEmpty()) {\\n            if(pq.peek() == res){\\n                pq.poll();\\n                int i = 1;\\n                // convert all number equal to res to res + value*i and increase all the same by value\\n                while(!pq.isEmpty() && pq.peek() == res) {\\n                    pq.offer(res + value*i++);\\n                    pq.poll();\\n                }\\n                res = res + 1;\\n            }\\n            else{\\n                return res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n         // convert all number to positive and find mod\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i : nums) {\\n            int val = i;\\n            if(i%value<0) {\\n                val = i%value + value;\\n            }\\n            else{\\n                val = i%value;\\n            }\\n            \\n            pq.offer(val);\\n        }\\n        \\n        \\n        // now we have all the numbers in order from 1 to value\\n        int res = 0;\\n        while(!pq.isEmpty()) {\\n            if(pq.peek() == res){\\n                pq.poll();\\n                int i = 1;\\n                // convert all number equal to res to res + value*i and increase all the same by value\\n                while(!pq.isEmpty() && pq.peek() == res) {\\n                    pq.offer(res + value*i++);\\n                    pq.poll();\\n                }\\n                res = res + 1;\\n            }\\n            else{\\n                return res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316418,
                "title": "easy-to-understand-c-map-upvote",
                "content": "# Intuition\\nIf you carefully notice any value can be achieved if the reminder of the value when % operation is performed is present,for example\\nvalue=5;\\n1)if we have to check wether 10 can be achieved  after performing operations then we can say that if 10%value==0 is present in nums or not.\\n2)for negative value operation the first positive number will be int first_positive=nums[i]%value+value.\\n\\n# Approach>\\nWe will maintain a hash map and keep on storing nums[i]%value in the map and then,when its done we will run a loop from 0 to nums.size() and check if the element is present or not.\\n\\n1)If it is present we will decrease i%value from map.\\n2)else  we will return i\\n\\n# Complexity\\n- Time complexity:\\nO(n);\\n\\n- Space complexity:\\nO(n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n      if(nums[i]<0){\\n      if(nums[i]%value==0){\\n        m[0]++;\\n   m  }\\n    else{\\n    int k=nums[i]%value;\\n    int l=value+k;\\n   m[l]++;\\n      }\\n    }\\n            else{\\n    m[nums[i]%value]++;\\n            \\n            }\\n        }\\n       for(int i=0;i<nums.size();i++){\\n     if(m[i%value]==0){\\n   return i;\\n   }\\n  else{\\n    m[i%value]--;\\n      }\\n    }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n      if(nums[i]<0){\\n      if(nums[i]%value==0){\\n        m[0]++;\\n   m  }\\n    else{\\n    int k=nums[i]%value;\\n    int l=value+k;\\n   m[l]++;\\n      }\\n    }\\n            else{\\n    m[nums[i]%value]++;\\n            \\n            }\\n        }\\n       for(int i=0;i<nums.size();i++){\\n     if(m[i%value]==0){\\n   return i;\\n   }\\n  else{\\n    m[i%value]--;\\n      }\\n    }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316051,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        count=Counter(num%value for num in nums)\\n        stop=0\\n        for i in range(value):\\n            if count[i]<count[stop]:\\n                stop=i\\n\\n        return value*count[stop]+stop        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        count=Counter(num%value for num in nums)\\n        stop=0\\n        for i in range(value):\\n            if count[i]<count[stop]:\\n                stop=i\\n\\n        return value*count[stop]+stop        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315113,
                "title": "c-beginner-friendly-tc-100-reminder-count-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size();\\n        vector<int>v(value,0);\\n        int afterComput;\\n        for( int i=0 ; i < n; i++ )\\n        {\\n            if(nums[i] >= 0)\\n            {\\n                afterComput = nums[i] % value;\\n            }\\n            else\\n            {\\n                if( (abs(nums[i]) % value ) == 0)\\n                {\\n                    afterComput = 0;\\n                }\\n                else\\n                {\\n                    afterComput = value - (abs(nums[i]) % value);\\n                }\\n            }\\n            v[afterComput]++;\\n        }\\n        int ans=INT_MAX;\\n        for(int i = 0; i < v.size(); i++) {\\n            if(v[i] == 0) return i;\\n            ans = min(ans, value*v[i] + i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size();\\n        vector<int>v(value,0);\\n        int afterComput;\\n        for( int i=0 ; i < n; i++ )\\n        {\\n            if(nums[i] >= 0)\\n            {\\n                afterComput = nums[i] % value;\\n            }\\n            else\\n            {\\n                if( (abs(nums[i]) % value ) == 0)\\n                {\\n                    afterComput = 0;\\n                }\\n                else\\n                {\\n                    afterComput = value - (abs(nums[i]) % value);\\n                }\\n            }\\n            v[afterComput]++;\\n        }\\n        int ans=INT_MAX;\\n        for(int i = 0; i < v.size(); i++) {\\n            if(v[i] == 0) return i;\\n            ans = min(ans, value*v[i] + i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314374,
                "title": "short-clean-java",
                "content": "\\n```java []\\npublic class Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        int[] remainders = new int[value];\\n        for (int num : nums) {\\n            int rem = (num % value + value) % value;\\n            remainders[rem]++;\\n        }\\n        int mssng = 0;\\n        while (remainders[mssng % value] > 0) {\\n            remainders[mssng++ % value]--;\\n        }\\n        return mssng;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\npublic class Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        int[] remainders = new int[value];\\n        for (int num : nums) {\\n            int rem = (num % value + value) % value;\\n            remainders[rem]++;\\n        }\\n        int mssng = 0;\\n        while (remainders[mssng % value] > 0) {\\n            remainders[mssng++ % value]--;\\n        }\\n        return mssng;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314216,
                "title": "c-mod",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int FindSmallestInteger(int[] nums, int value) \\n    {\\n        int[] remainCount = new int[value];\\n        foreach (int num in nums)\\n        {\\n            int remain = ((num % value)+ value) %value;\\n            remainCount[remain]++;\\n        }\\n        for (int i = 0; i < int.MaxValue; i++)\\n        {\\n            if (remainCount[i % value] > 0)\\n                remainCount[i % value]--;\\n            else\\n                return i;\\n        }\\n        return int.MaxValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int FindSmallestInteger(int[] nums, int value) \\n    {\\n        int[] remainCount = new int[value];\\n        foreach (int num in nums)\\n        {\\n            int remain = ((num % value)+ value) %value;\\n            remainCount[remain]++;\\n        }\\n        for (int i = 0; i < int.MaxValue; i++)\\n        {\\n            if (remainCount[i % value] > 0)\\n                remainCount[i % value]--;\\n            else\\n                return i;\\n        }\\n        return int.MaxValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314065,
                "title": "hashmap-solution-simply-mark-all-possible-integers-and-then-find-smallest-missing-value-from-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all mods with their frequency, if a mod has one frequency, it can be used to only create the same number. If a mod has more than one frequency then it can create the same number as well as same number plus value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind mod using hash, store frequency. Use frequency to find all possible integers that can be created.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        map<int, int> m;\\n        for(int i = 0; i < nums.size(); ++i){\\n            int currMod = nums[i] % value;\\n            if(currMod < 0) currMod = (currMod + value) % value;\\n            m[currMod]++;\\n        }\\n        map<int, int> v;\\n        for(int i = 0; i < value; ++i){\\n            if(m.find(i) == m.end())\\n                return i;\\n            int count = 0;\\n            while(m[i]-- > 0){\\n                v[value * count++ + i]++;\\n            }\\n        }\\n        for(int i = 0; i < 1e9; ++i)    if(v.find(i) == v.end())    return i;\\n        return value;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        map<int, int> m;\\n        for(int i = 0; i < nums.size(); ++i){\\n            int currMod = nums[i] % value;\\n            if(currMod < 0) currMod = (currMod + value) % value;\\n            m[currMod]++;\\n        }\\n        map<int, int> v;\\n        for(int i = 0; i < value; ++i){\\n            if(m.find(i) == m.end())\\n                return i;\\n            int count = 0;\\n            while(m[i]-- > 0){\\n                v[value * count++ + i]++;\\n            }\\n        }\\n        for(int i = 0; i < 1e9; ++i)    if(v.find(i) == v.end())    return i;\\n        return value;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313997,
                "title": "c-residue-classes",
                "content": "\\nIntuition: We can apply the operation any number of times, we what we should really care about is the frequency of numbers after taking the modulo value.\\nApproach: Change all numbers in array to n%value and put them in a frequency map, then from 0 to 100000, check if i%value is in the frequency map\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int mx = INT_MAX/value * value;\\n        for(auto & i : nums){ // i forgot how to take negative modulo the right way, quick hack/fix\\n            long long t = i;\\n            t += mx;\\n            t %= value;\\n            i = t;\\n        }\\n        map<int, int> freq;\\n        for(auto & i : nums) freq[i%value]++;\\n        for(int i = 0; i <= 100001; i++){\\n            freq[i%value]--;\\n            if(freq[i%value] == -1) return i;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int mx = INT_MAX/value * value;\\n        for(auto & i : nums){ // i forgot how to take negative modulo the right way, quick hack/fix\\n            long long t = i;\\n            t += mx;\\n            t %= value;\\n            i = t;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3313994,
                "title": "python-easy-dp-solution",
                "content": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        l = len(nums)\\n        dp = [0] * l\\n        for n in nums:\\n            curr = n % value\\n            if curr >= l: continue\\n            # the smallest non negetive number we could reach \\n            dp[curr] += 1\\n        for i in range(l):\\n            #if we couldn\\'t reach it return it\\n            if dp[i] == 0: return i\\n            #we can reach it and have extra count of that number, so we can increase this count -1 by value\\n            if dp[i] > 1 and i + value < l:\\n                dp[i + value] += dp[i] - 1\\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        l = len(nums)\\n        dp = [0] * l\\n        for n in nums:\\n            curr = n % value\\n            if curr >= l: continue\\n            # the smallest non negetive number we could reach \\n            dp[curr] += 1\\n        for i in range(l):\\n            #if we couldn\\'t reach it return it\\n            if dp[i] == 0: return i\\n            #we can reach it and have extra count of that number, so we can increase this count -1 by value\\n            if dp[i] > 1 and i + value < l:\\n                dp[i + value] += dp[i] - 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313992,
                "title": "easy-to-understand-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int, int> m;\\n        \\n        for(auto it: nums) {\\n            int times = abs(it / value);\\n            if(it < 0)\\n                it = it + times*value + value;\\n            m[it % value]++;\\n        }\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(m[i % value] == 0) {\\n                return i;\\n            }\\n            else {\\n                m[i % value]--;\\n            }\\n        }\\n        \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int, int> m;\\n        \\n        for(auto it: nums) {\\n            int times = abs(it / value);\\n            if(it < 0)\\n                it = it + times*value + value;\\n            m[it % value]++;\\n        }\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(m[i % value] == 0) {\\n                return i;\\n            }\\n            else {\\n                m[i % value]--;\\n            }\\n        }\\n        \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032154,
                "title": "find-smallest-integer-not-present-in-array-java-solution",
                "content": "**Please Upvote!!**\\n\\n# Approach\\nThis code finds the smallest integer not present in the given array nums by using a map to count the occurrences of each remainder value when dividing the elements by value. It then iterates through the array to find the smallest integer that is not present in the array based on the remainder values.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        \\n        int max = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n // Count the occurrences of each remainder value when divided by \\'value\\'\\n       \\n        for(int i=0;i<nums.length;i++){\\n            int key = nums[i]%value;\\n            if(key<0){\\n                key = key+value;\\n            }\\n           map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n // Check for the smallest integer not present in the array\\n        for(int i=0;i<nums.length;i++){\\n            int num = i;\\n            if(map.containsKey(i)){\\n               while(map.get(i)>1){\\n                 num +=value;\\n                 map.put(num,map.getOrDefault(num,0)+1);\\n                 map.put(i,map.get(i)-1);\\n               }\\n            }else return i;\\n        }\\n\\n        return nums.length;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        \\n        int max = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n // Count the occurrences of each remainder value when divided by \\'value\\'\\n       \\n        for(int i=0;i<nums.length;i++){\\n            int key = nums[i]%value;\\n            if(key<0){\\n                key = key+value;\\n            }\\n           map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n // Check for the smallest integer not present in the array\\n        for(int i=0;i<nums.length;i++){\\n            int num = i;\\n            if(map.containsKey(i)){\\n               while(map.get(i)>1){\\n                 num +=value;\\n                 map.put(num,map.getOrDefault(num,0)+1);\\n                 map.put(i,map.get(i)-1);\\n               }\\n            }else return i;\\n        }\\n\\n        return nums.length;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936908,
                "title": "golang-simple-hash-table-solution",
                "content": "# Code\\n```go\\nfunc findSmallestInteger(nums []int, value int) int {\\n\\tmagic := make(map[int]int)\\n\\tfor _, v := range nums {\\n\\t\\tmagic[(v+value*10000000000)%value]++\\n\\t}\\n\\tminSize, minValue := math.MaxInt64, math.MaxInt64\\n\\tfor i := 0; i < value; i++ {\\n\\t\\tif magic[i] == 0 {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t\\tif magic[i] < minSize {\\n\\t\\t\\tminSize, minValue = magic[i], i\\n\\t\\t}\\n\\t}\\n\\treturn value * minSize + minValue\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```go\\nfunc findSmallestInteger(nums []int, value int) int {\\n\\tmagic := make(map[int]int)\\n\\tfor _, v := range nums {\\n\\t\\tmagic[(v+value*10000000000)%value]++\\n\\t}\\n\\tminSize, minValue := math.MaxInt64, math.MaxInt64\\n\\tfor i := 0; i < value; i++ {\\n\\t\\tif magic[i] == 0 {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t\\tif magic[i] < minSize {\\n\\t\\t\\tminSize, minValue = magic[i], i\\n\\t\\t}\\n\\t}\\n\\treturn value * minSize + minValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935534,
                "title": "cache",
                "content": "```\\nbool cache[100001];\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        memset(cache, false, sizeof(cache));\\n        vector<int> freq(value, 0);\\n       \\n        \\n        for(auto x : nums)\\n        {\\n            if(x < 0)\\n            {\\n                int y = abs(x) % value;\\n                x = (-1 * y)  +value;\\n            }\\n            int md = abs(x) % value;\\n            freq[md]++;\\n        }\\n        for(int i=0; i<value; i++)\\n        {\\n            for(int j=0; j<freq[i]; j++)\\n            {\\n                if(i + j*value < 100001)\\n                cache[i + j*value] = true;\\n            }\\n        }\\n        for(int i=0; i<=100000; i++)\\n        {\\n            if(cache[i] == false)\\n                return i;\\n        }\\n        return 100000 + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool cache[100001];\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        memset(cache, false, sizeof(cache));\\n        vector<int> freq(value, 0);\\n       \\n        \\n        for(auto x : nums)\\n        {\\n            if(x < 0)\\n            {\\n                int y = abs(x) % value;\\n                x = (-1 * y)  +value;\\n            }\\n            int md = abs(x) % value;\\n            freq[md]++;\\n        }\\n        for(int i=0; i<value; i++)\\n        {\\n            for(int j=0; j<freq[i]; j++)\\n            {\\n                if(i + j*value < 100001)\\n                cache[i + j*value] = true;\\n            }\\n        }\\n        for(int i=0; i<=100000; i++)\\n        {\\n            if(cache[i] == false)\\n                return i;\\n        }\\n        return 100000 + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931524,
                "title": "c-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n * 2598. Smallest Missing Non-negative Integer After Operations\\n *\\n * You are given a 0-indexed integer array nums and an integer value.\\n * \\n * In one operation, you can add or subtract value from any element of nums.\\n * \\n * For example, if nums = [1,2,3] and value = 2, you can choose to \\n * subtract value from nums[0] to make nums = [-1,2,3].\\n * The MEX (minimum excluded) of an array is the smallest missing \\n * non-negative integer in it.\\n * \\n * For example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.\\n * Return the maximum MEX of nums after applying the mentioned operation \\n * any number of times.\\n *\\n * 1 <= nums.length, value <= 10^5\\n * -10^9 <= nums[i] <= 10^9\\n */\\n\\n#define HASH_MOD    1259\\n\\ntypedef struct item {\\n    struct item *next;\\n    int freq;\\n    int mod;\\n} item_t;\\n\\nint findSmallestInteger(int* nums, int numsSize, int value){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  value,\\n     */\\n\\n    //\\n    // The question is that is it possible to add value to any element\\n    // or sub value from any element to produce the next \"missing positive number\"\\n    // and maximum the MEX\\n    //,\\n    // E.g, nums = [-1, -2], value = 1\\n    //  => First missing positive number is 0, we want to produce 0\\n    //  => 0 can be produce by -1 + 1, or -2 + 2\\n    //  nums = [-1, 0]\\n    //  => next missing positive number is 1, we want to produce 1\\n    //  => 0 can be produce by -1 + 1,\\n    //  nums = [0, 1]   => MAX MEX is 2\\n    \\n    item_t *hash[HASH_MOD] = {0}, *item, *del;\\n    int mod, hash_mod, mex = 0;\\n\\n    /* Count the MOD frequency and store it in hash table */\\n    for (int i = 0; i < numsSize; i++) {\\n        mod = ((nums[i] % value) + value) % value;\\n        hash_mod = mod % HASH_MOD;\\n\\n        if (hash[hash_mod] == NULL) {\\n            item = (item_t *)malloc(sizeof(item_t));\\n            item->mod = mod;\\n            item->freq = 0;\\n            item->next = hash[hash_mod];\\n            hash[hash_mod] = item;\\n        }\\n\\n        for (item = hash[hash_mod]; item; item = item->next) {\\n            if (item->mod == mod) {\\n                item->freq++;\\n                break;\\n            }\\n        }\\n\\n        if (item == NULL) {\\n            item = (item_t *)malloc(sizeof(item_t));\\n            item->mod = mod;\\n            item->freq = 1;\\n            item->next = hash[hash_mod];\\n            hash[hash_mod] = item;\\n        }\\n\\n    }\\n\\n    /* Check for the largest missing positive number that can be produced */\\n    for (int i = 0; i <= 1000000000; i++) {\\n        mod = i % value;\\n        hash_mod = mod % HASH_MOD;\\n\\n        for (item = hash[hash_mod]; item; item = item->next) {\\n            if (item->mod == mod && item->freq > 0) {\\n                item->freq--;\\n                mex += 1;\\n                break;\\n            }\\n        }\\n\\n        if (mex != i + 1) {\\n            break;\\n        }\\n    }\\n\\n    /* Release hash table */\\n    for (int i = 0; i < HASH_MOD; i++) {\\n        for (item = hash[i]; item; ) {\\n            del = item;\\n            item = item->next;\\n            free(del);\\n        }\\n    }\\n    \\n    /*\\n     * Output:\\n     *  Return the maximum MEX of nums after applying the \\n     *  mentioned operation any number of times.\\n     */\\n\\n    return mex;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\n/*\\n * 2598. Smallest Missing Non-negative Integer After Operations\\n *\\n * You are given a 0-indexed integer array nums and an integer value.\\n * \\n * In one operation, you can add or subtract value from any element of nums.\\n * \\n * For example, if nums = [1,2,3] and value = 2, you can choose to \\n * subtract value from nums[0] to make nums = [-1,2,3].\\n * The MEX (minimum excluded) of an array is the smallest missing \\n * non-negative integer in it.\\n * \\n * For example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.\\n * Return the maximum MEX of nums after applying the mentioned operation \\n * any number of times.\\n *\\n * 1 <= nums.length, value <= 10^5\\n * -10^9 <= nums[i] <= 10^9\\n */\\n\\n#define HASH_MOD    1259\\n\\ntypedef struct item {\\n    struct item *next;\\n    int freq;\\n    int mod;\\n} item_t;\\n\\nint findSmallestInteger(int* nums, int numsSize, int value){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  value,\\n     */\\n\\n    //\\n    // The question is that is it possible to add value to any element\\n    // or sub value from any element to produce the next \"missing positive number\"\\n    // and maximum the MEX\\n    //,\\n    // E.g, nums = [-1, -2], value = 1\\n    //  => First missing positive number is 0, we want to produce 0\\n    //  => 0 can be produce by -1 + 1, or -2 + 2\\n    //  nums = [-1, 0]\\n    //  => next missing positive number is 1, we want to produce 1\\n    //  => 0 can be produce by -1 + 1,\\n    //  nums = [0, 1]   => MAX MEX is 2\\n    \\n    item_t *hash[HASH_MOD] = {0}, *item, *del;\\n    int mod, hash_mod, mex = 0;\\n\\n    /* Count the MOD frequency and store it in hash table */\\n    for (int i = 0; i < numsSize; i++) {\\n        mod = ((nums[i] % value) + value) % value;\\n        hash_mod = mod % HASH_MOD;\\n\\n        if (hash[hash_mod] == NULL) {\\n            item = (item_t *)malloc(sizeof(item_t));\\n            item->mod = mod;\\n            item->freq = 0;\\n            item->next = hash[hash_mod];\\n            hash[hash_mod] = item;\\n        }\\n\\n        for (item = hash[hash_mod]; item; item = item->next) {\\n            if (item->mod == mod) {\\n                item->freq++;\\n                break;\\n            }\\n        }\\n\\n        if (item == NULL) {\\n            item = (item_t *)malloc(sizeof(item_t));\\n            item->mod = mod;\\n            item->freq = 1;\\n            item->next = hash[hash_mod];\\n            hash[hash_mod] = item;\\n        }\\n\\n    }\\n\\n    /* Check for the largest missing positive number that can be produced */\\n    for (int i = 0; i <= 1000000000; i++) {\\n        mod = i % value;\\n        hash_mod = mod % HASH_MOD;\\n\\n        for (item = hash[hash_mod]; item; item = item->next) {\\n            if (item->mod == mod && item->freq > 0) {\\n                item->freq--;\\n                mex += 1;\\n                break;\\n            }\\n        }\\n\\n        if (mex != i + 1) {\\n            break;\\n        }\\n    }\\n\\n    /* Release hash table */\\n    for (int i = 0; i < HASH_MOD; i++) {\\n        for (item = hash[i]; item; ) {\\n            del = item;\\n            item = item->next;\\n            free(del);\\n        }\\n    }\\n    \\n    /*\\n     * Output:\\n     *  Return the maximum MEX of nums after applying the \\n     *  mentioned operation any number of times.\\n     */\\n\\n    return mex;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3921415,
                "title": "o-n-tc-o-value-sc-check-the-remainders-count-easy-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(VALUE)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        vector<int> rem(value,0);\\n\\n        for(auto x : nums)\\n        {\\n            if(x < 0)\\n            {\\n               int temp = (value + (x%value))%value;\\n               rem[temp]++;\\n            }\\n            else rem[x%value]++;\\n        }\\n\\n        for(int i = 0 ; i < nums.size();i++)\\n        {\\n            int temp = i%value;\\n            if(rem[temp]<=0)return i;\\n            else rem[temp]--;\\n        }\\n\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        vector<int> rem(value,0);\\n\\n        for(auto x : nums)\\n        {\\n            if(x < 0)\\n            {\\n               int temp = (value + (x%value))%value;\\n               rem[temp]++;\\n            }\\n            else rem[x%value]++;\\n        }\\n\\n        for(int i = 0 ; i < nums.size();i++)\\n        {\\n            int temp = i%value;\\n            if(rem[temp]<=0)return i;\\n            else rem[temp]--;\\n        }\\n\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882240,
                "title": "best-c-solution-well-explained",
                "content": "# Intuition: \\nThe intuition behind this approach is to adjust the array elements to have positive values by adding multiples of `value` to negative numbers. Then, we calculate the frequencies of remainders when divided by `value`. By iterating through these frequencies, we find the missing remainder, which corresponds to the MEX value that we\\'re looking for.\\n\\n# Approach:\\nThe approach involves adjusting negative numbers, calculating frequencies of remainders, and finding the missing remainder that represents the MEX value.\\n\\n# Complexity:\\n- **Time Complexity:** The time complexity of this solution is primarily dominated by the iteration through the array to adjust negative numbers and calculate frequencies of remainders. This step takes linear time, making it O(n), where n is the size of the `nums` array. The subsequent iteration through the frequencies is also linear, resulting in the same overall complexity of O(n).\\n- **Space Complexity:** The space complexity is determined by the additional space required to store the `freq` array, which holds the frequencies of remainders. The size of this array is proportional to the value of `value`, resulting in O(value) space complexity. However, since the value is typically a constant or a small number, the space complexity can be considered constant in most practical scenarios.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        // Change all negative numbers to their nearest positive multiples of value\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] < 0) {\\n                nums[i] += ((abs(nums[i]) / value) * value); // Adjust to the nearest positive multiple\\n                if (nums[i] < 0) nums[i] += value; // Ensure the number becomes positive\\n            }\\n        }\\n\\n        // Create an array to store frequencies of remainders\\n        vector<int> freq(value, 0);\\n\\n        // Store the frequencies of all the remainders\\n        for (auto& num : nums) {\\n            freq[num % value]++;\\n        }\\n\\n        int n = nums.size() / value + 1; // Estimate the possible number of remainders\\n\\n        // Iterate through frequencies and find the remainder that is missing\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < value; i++) {\\n                if (freq[i] == j) {\\n                    return value * j + i; // Return the MEX value\\n                }\\n            }\\n        }\\n\\n        return 0; // Return 0 if no valid MEX is found\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        // Change all negative numbers to their nearest positive multiples of value\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] < 0) {\\n                nums[i] += ((abs(nums[i]) / value) * value); // Adjust to the nearest positive multiple\\n                if (nums[i] < 0) nums[i] += value; // Ensure the number becomes positive\\n            }\\n        }\\n\\n        // Create an array to store frequencies of remainders\\n        vector<int> freq(value, 0);\\n\\n        // Store the frequencies of all the remainders\\n        for (auto& num : nums) {\\n            freq[num % value]++;\\n        }\\n\\n        int n = nums.size() / value + 1; // Estimate the possible number of remainders\\n\\n        // Iterate through frequencies and find the remainder that is missing\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < value; i++) {\\n                if (freq[i] == j) {\\n                    return value * j + i; // Return the MEX value\\n                }\\n            }\\n        }\\n\\n        return 0; // Return 0 if no valid MEX is found\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845052,
                "title": "o-n-python3-solution-at-859ms-using-a-hashtable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s important to remember two things about this problem:\\n\\n1. Given any number in the list (`nums[i]`), the smallest non-zero integer you can make with that number and `value` is `nums[i] % value`, also known as the remainder.\\n2. An operation mutates the original number from the list (`nums[i]`) so that the original value is no longer in the final list that must be tested for the MEX.\\n\\nItem #1 means that the *starting* list of integers that should exist in the final mutated list is the full set of integers you would get from running the modulo against every number in `nums`. But item #2 above means that we need to account for using each number in the list, **even if there are repeats**. This means that we need to augment our original set of numbers to account for each possible number in the series of `X + value * n` where X is the remainder described in item #1 and `n` ranges from 1 to the number of times that remainder was seen.\\n\\nUsing the given values from Example 1 in the description, this means:\\n```\\nnums = [1,-10,7,13,6,8]\\nvalue = 5\\nstarting list of integers = [1, 0, 2, 3, 1, 3]  # [x % value for x in nums]\\nstarting set of integers = {0, 1, 2, 3}\\nFinal set of valid integers = {0, 1, 2, 3, 6 (1 + 5*1), 8 (3 + 5*1)}\\nLowest missing integer = 4\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nArmed with this information, we essentially need a single-pass hashtable. The keys of this table are the remainders (`nums[i] % value`) and the values of this table are the counted number of times that this remainder was calculated from the original list.\\n\\nAfter populating the valid integer hashtable with the correct values, you can then fill in the the remaining required values by iterating over the keys of the hashtable and adding new keys to the hashtable based on the series `X + value * n` where `X` is the key from the hashtable and `n` ranges from 1 to the count value found at `valid_ints[X]`.\\n\\nNow you have a dictionary whose keys are all of the valid integers between 0 and infinity that you can possibly use to populate a final mutated list where you\\'ve performed any number of add/subtract operations. Find the first missing integer in the keys, and that\\'s your answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ -> It\\'s actually a bit more than that, because you also iterate over the hashtable and from 0 to the answer, but at the upper limit that would be $$O(3n)$$, and we can drop constants.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def findSmallestInteger(self, nums: list[int], value: int) -> int:\\n        # First build a dict with all of the smallest possible result values.\\n        valid_ints = defaultdict(int)  # integer -> Count of this integer.\\n        for num in nums:\\n            # Remainder is the lowest possible int you can make with this combo.\\n            valid_ints[num % value] += 1\\n        \"\"\"\\n        Now fill in the intermediate values between X and X+Value*n\\n          - X is one of the keys from valid_ints.\\n          - n is the number of times that integer can be used in the list.\\n        \"\"\"\\n        for key in list(valid_ints.keys()):\\n            n = 1\\n            while n < valid_ints[key]:\\n                intermediate = key + n * value\\n                valid_ints[intermediate] = 1\\n                n += 1\\n        # Now that we have all possible valid integers, guess from 0 until you find the gap.\\n        guess = 0\\n        while guess in valid_ints:\\n            guess += 1\\n        return guess\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nnums = [1,-10,7,13,6,8]\\nvalue = 5\\nstarting list of integers = [1, 0, 2, 3, 1, 3]  # [x % value for x in nums]\\nstarting set of integers = {0, 1, 2, 3}\\nFinal set of valid integers = {0, 1, 2, 3, 6 (1 + 5*1), 8 (3 + 5*1)}\\nLowest missing integer = 4\\n```\n```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def findSmallestInteger(self, nums: list[int], value: int) -> int:\\n        # First build a dict with all of the smallest possible result values.\\n        valid_ints = defaultdict(int)  # integer -> Count of this integer.\\n        for num in nums:\\n            # Remainder is the lowest possible int you can make with this combo.\\n            valid_ints[num % value] += 1\\n        \"\"\"\\n        Now fill in the intermediate values between X and X+Value*n\\n          - X is one of the keys from valid_ints.\\n          - n is the number of times that integer can be used in the list.\\n        \"\"\"\\n        for key in list(valid_ints.keys()):\\n            n = 1\\n            while n < valid_ints[key]:\\n                intermediate = key + n * value\\n                valid_ints[intermediate] = 1\\n                n += 1\\n        # Now that we have all possible valid integers, guess from 0 until you find the gap.\\n        guess = 0\\n        while guess in valid_ints:\\n            guess += 1\\n        return guess\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830425,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        \\'\\'\\'\\n        two cases i have to consider:\\n        one - multiple of same number\\n        \\n        \\n        \\'\\'\\'\\n        if value == 1:\\n            return len(nums)\\n        \\n\\n        for i, num in enumerate(nums):\\n            nums[i] %= value\\n\\n        seen = defaultdict(int)\\n     \\n        nums.sort()\\n\\n        for i in range(len(nums)):\\n            \\n            if not seen[nums[i]]:\\n                seen[nums[i]] += 1\\n                continue\\n\\n            l, r = 1, 10 ** 5\\n\\n            while l < r:\\n                mid = (l + r) // 2\\n\\n                if seen[nums[i] + value * mid]:\\n                    l = mid + 1\\n\\n                else:\\n                    r = mid\\n\\n            seen[nums[i] + value * l] += 1\\n                \\n\\n            \\n\\n        nums.sort()\\n\\n        for i in range(len(nums)):\\n            if not seen[i]:\\n                return i\\n\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        \\'\\'\\'\\n        two cases i have to consider:\\n        one - multiple of same number\\n        \\n        \\n        \\'\\'\\'\\n        if value == 1:\\n            return len(nums)\\n        \\n\\n        for i, num in enumerate(nums):\\n            nums[i] %= value\\n\\n        seen = defaultdict(int)\\n     \\n        nums.sort()\\n\\n        for i in range(len(nums)):\\n            \\n            if not seen[nums[i]]:\\n                seen[nums[i]] += 1\\n                continue\\n\\n            l, r = 1, 10 ** 5\\n\\n            while l < r:\\n                mid = (l + r) // 2\\n\\n                if seen[nums[i] + value * mid]:\\n                    l = mid + 1\\n\\n                else:\\n                    r = mid\\n\\n            seen[nums[i] + value * l] += 1\\n                \\n\\n            \\n\\n        nums.sort()\\n\\n        for i in range(len(nums)):\\n            if not seen[i]:\\n                return i\\n\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692324,
                "title": "golang-count-of-modulus",
                "content": "Need to do `(num % val + val) % val` to handle negative numbers.\\n# Code\\n```\\nfunc findSmallestInteger(nums []int, value int) int {\\n  candidates := make([]int, value)\\n  for i := 0; i < len(nums); i++ {\\n    // We\\'re doing (num % val + val)%val to handle negative numbers.\\n    // num%val gives the closest number <= 0. Then we add value and then take mod again.\\n    // -7 % 4 => -3 => (-3 + 4)%4 => 1\\n    candidates[(nums[i]%value+value)%value]++\\n  }\\n  for i := 0; i < len(nums); i++ {\\n    if candidates[i%value] == 0 {\\n      return i\\n    }\\n    candidates[i%value]--\\n  }\\n  return len(nums)\\n}\\n\\nfunc abs(a int) int {\\n  if a < 0 {\\n    return -a\\n  }\\n  return a\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc findSmallestInteger(nums []int, value int) int {\\n  candidates := make([]int, value)\\n  for i := 0; i < len(nums); i++ {\\n    // We\\'re doing (num % val + val)%val to handle negative numbers.\\n    // num%val gives the closest number <= 0. Then we add value and then take mod again.\\n    // -7 % 4 => -3 => (-3 + 4)%4 => 1\\n    candidates[(nums[i]%value+value)%value]++\\n  }\\n  for i := 0; i < len(nums); i++ {\\n    if candidates[i%value] == 0 {\\n      return i\\n    }\\n    candidates[i%value]--\\n  }\\n  return len(nums)\\n}\\n\\nfunc abs(a int) int {\\n  if a < 0 {\\n    return -a\\n  }\\n  return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3674331,
                "title": "ok",
                "content": "```\\nint findSmallestInteger(vector<int>& n, int v) \\n{\\n\\tunordered_map<int,int> s;\\n\\tfor(const auto & n : n)\\n\\t\\t++s[(v+(n%v))%v];\\n\\n\\tfor(int i{}; i<100001; ++i)\\n\\t\\tif((--s[i%v])==-1) return i;\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findSmallestInteger(vector<int>& n, int v) \\n{\\n\\tunordered_map<int,int> s;\\n\\tfor(const auto & n : n)\\n\\t\\t++s[(v+(n%v))%v];\\n\\n\\tfor(int i{}; i<100001; ++i)\\n\\t\\tif((--s[i%v])==-1) return i;\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3645447,
                "title": "cpp-dp-modulo-function",
                "content": "calculate modulo for each num, then select the modulo with minimum count (first modulo in case more than one), u can create all the numbers upto (modulo count*value)+modulo\\nso return (modulo count * value)+modulo\\n\\nhere for negative numbers we can\\'t get modulo directly using % so i ahve adjusted it below\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> dp(value,0);\\n        int n = nums.size();\\n\\n        for(auto i =0 ; i< n ;i++){\\n            if(nums[i]>=0)\\n                dp[nums[i]%value]++;\\n            else{\\n                int c=-1*nums[i];\\n                c= (value-(c%value))%value;\\n                dp[c]++;\\n            }\\n        }\\n        int index =0;\\n        for(int i =1; i< value ; i++){\\n            if(dp[i]<dp[index]){\\n                index=i;\\n            }\\n        }\\n        return (value*dp[index])+index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> dp(value,0);\\n        int n = nums.size();\\n\\n        for(auto i =0 ; i< n ;i++){\\n            if(nums[i]>=0)\\n                dp[nums[i]%value]++;\\n            else{\\n                int c=-1*nums[i];\\n                c= (value-(c%value))%value;\\n                dp[c]++;\\n            }\\n        }\\n        int index =0;\\n        for(int i =1; i< value ; i++){\\n            if(dp[i]<dp[index]){\\n                index=i;\\n            }\\n        }\\n        return (value*dp[index])+index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580470,
                "title": "easy-to-understand-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        // counts of remainders divided by value\\n        vector<int> counts(value, 0);\\n        for (int i = 0; i < nums.size(); i ++){\\n            int remainder = nums[i] % value;\\n            if (remainder < 0){\\n                remainder += value;\\n            }\\n            counts[remainder]++;\\n        }\\n        int place = min_element(counts.begin(), counts.end()) - counts.begin();\\n        int count = counts[place];\\n        return count * value + place;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        // counts of remainders divided by value\\n        vector<int> counts(value, 0);\\n        for (int i = 0; i < nums.size(); i ++){\\n            int remainder = nums[i] % value;\\n            if (remainder < 0){\\n                remainder += value;\\n            }\\n            counts[remainder]++;\\n        }\\n        int place = min_element(counts.begin(), counts.end()) - counts.begin();\\n        int count = counts[place];\\n        return count * value + place;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576496,
                "title": "using-mod",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) \\n    {\\n        unordered_map<int, int> m;    \\n        for(auto it: nums) \\n        {\\n            int times = abs(it / value);\\n            if(it < 0)\\n                it = it + times*value + value;\\n            m[it % value]++;\\n        }\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) \\n        {\\n            if(m[i % value] == 0) \\n            {\\n                return i;\\n            }\\n            else \\n            {\\n                m[i % value]--;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) \\n    {\\n        unordered_map<int, int> m;    \\n        for(auto it: nums) \\n        {\\n            int times = abs(it / value);\\n            if(it < 0)\\n                it = it + times*value + value;\\n            m[it % value]++;\\n        }\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) \\n        {\\n            if(m[i % value] == 0) \\n            {\\n                return i;\\n            }\\n            else \\n            {\\n                m[i % value]--;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551500,
                "title": "c-python-solution-with-explanation",
                "content": "```nums[i]``` can make operation any number of times means ```nums[i]``` can becomes any number whose remainder (mod ```value```) is the same.\\nAnd largest MEX is ```nums.size()```.\\nso according the remainder (mod ```value```), we can group the numbers. \\nwalking through the ```nums```,\\n```cnt[i]``` records number of number whose remainder (mod ```value```) is ```i``` we have seen.\\nWe can get remainder of current number first, it is group id, and find another number which current number becomes, it should be smallest of number we have not seen and it can becomes. \\ne.g., current number\\'s remander is ```3```,```cnt[3]``` is ```2``` which means we have seen ```2``` number whose remainder is ```3```, for remainder ```3```, it can becomes ```3, value + 3, 2 * value + 3, ...```, because we have seen ```2``` number, so ```3, value + 3``` we have gotten, this number should become ```2 * value + 3```, and we can use ```seen``` to record ```2 * value + 3``` we have seen.\\n\\nThen, traverse ```seen```, find first number we have not seen.\\ntc is O(n), sc is O(n)\\n\\n\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<bool> seen (nums.size() + 1, false);\\n        vector<int> cnt (value, 0);\\n        for (int& n: nums) {\\n            int t = (n % value + value) % value;\\n            int y = cnt[t] * value + t;\\n            if (y < nums.size()) seen[y] = true;\\n            cnt[t] += 1;\\n        }\\n        for (int i = 0; i <= nums.size(); i+=1) {\\n            if (! seen[i]) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n### python\\n```python\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        seen = [False] * (len(nums) + 1)\\n        cnt = [0] * value\\n        for n in nums:\\n            t = (n % value + value) % value\\n            y = cnt[t] * value + t\\n            if y < len(nums): seen[y] = True\\n            cnt[t] += 1\\n        for idx, v in enumerate(seen):\\n            if not v: return idx\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```nums[i]```\n```nums[i]```\n```value```\n```nums.size()```\n```value```\n```nums```\n```cnt[i]```\n```value```\n```i```\n```3```\n```cnt[3]```\n```2```\n```2```\n```3```\n```3```\n```3, value + 3, 2 * value + 3, ...```\n```2```\n```3, value + 3```\n```2 * value + 3```\n```seen```\n```2 * value + 3```\n```seen```\n```cpp\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<bool> seen (nums.size() + 1, false);\\n        vector<int> cnt (value, 0);\\n        for (int& n: nums) {\\n            int t = (n % value + value) % value;\\n            int y = cnt[t] * value + t;\\n            if (y < nums.size()) seen[y] = true;\\n            cnt[t] += 1;\\n        }\\n        for (int i = 0; i <= nums.size(); i+=1) {\\n            if (! seen[i]) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        seen = [False] * (len(nums) + 1)\\n        cnt = [0] * value\\n        for n in nums:\\n            t = (n % value + value) % value\\n            y = cnt[t] * value + t\\n            if y < len(nums): seen[y] = True\\n            cnt[t] += 1\\n        for idx, v in enumerate(seen):\\n            if not v: return idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541675,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can add of subtract value any number of time so we try to make it as low as possible i.e. nums[i]%value.Then we find out what is the smallest positive number by finding out what is least occuring remainder and its frequency. Then we know if its is the least occuring integer then every other remainder is more than this and we just have to multiply its frequency by value and add remainder to it.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(value)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        // sort(nums.begin(),nums.end());\\n        int range = nums[n-1];\\n        vector<int> vis(value,0);\\n        for(int i=0; i<nums.size(); i++){\\n            int ind = (nums[i]%value + value)%value;\\n            vis[ind]++;\\n        }\\n        int mn = 1e9;\\n        int val = -1;\\n        for(int i=0; i<value; i++){\\n            if(vis[i]<mn){\\n                mn = vis[i];\\n                val = i;\\n            }\\n            else if(vis[i]==mn){\\n                val = min(val,i);\\n            }\\n        }\\n        return value*mn + val;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        // sort(nums.begin(),nums.end());\\n        int range = nums[n-1];\\n        vector<int> vis(value,0);\\n        for(int i=0; i<nums.size(); i++){\\n            int ind = (nums[i]%value + value)%value;\\n            vis[ind]++;\\n        }\\n        int mn = 1e9;\\n        int val = -1;\\n        for(int i=0; i<value; i++){\\n            if(vis[i]<mn){\\n                mn = vis[i];\\n                val = i;\\n            }\\n            else if(vis[i]==mn){\\n                val = min(val,i);\\n            }\\n        }\\n        return value*mn + val;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451600,
                "title": "c-solution-easy-and-simple-o-n",
                "content": "# Intuition\\nTake the reminder of every value and count them.The value of reminder are present in between o to value-1 and their minimum occurence will help us to find our desired output. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(value)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int>dp(value,0);\\n        for(int i=0;i<nums.size();i++){\\n            int temp;\\n            if(nums[i]<0){\\n                temp=nums[i]%value;\\n                if(temp!=0)\\n                    temp=value+temp;\\n                // cout<<temp<<endl;\\n                dp[temp]+=1;\\n            }\\n            else{\\n                temp=nums[i]%value;\\n                // cout<<temp<<endl;\\n                dp[temp]+=1;\\n            }\\n        }\\n        int ind=INT_MAX,val=INT_MAX;\\n        for(int i=0;i<value;i++){\\n            if(dp[i]<val){\\n                val=dp[i];\\n                cout<<val<<\" \";\\n                ind=i;\\n            }\\n        }\\n        if(val==0)\\n            return ind;\\n        return val*value+ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int>dp(value,0);\\n        for(int i=0;i<nums.size();i++){\\n            int temp;\\n            if(nums[i]<0){\\n                temp=nums[i]%value;\\n                if(temp!=0)\\n                    temp=value+temp;\\n                // cout<<temp<<endl;\\n                dp[temp]+=1;\\n            }\\n            else{\\n                temp=nums[i]%value;\\n                // cout<<temp<<endl;\\n                dp[temp]+=1;\\n            }\\n        }\\n        int ind=INT_MAX,val=INT_MAX;\\n        for(int i=0;i<value;i++){\\n            if(dp[i]<val){\\n                val=dp[i];\\n                cout<<val<<\" \";\\n                ind=i;\\n            }\\n        }\\n        if(val==0)\\n            return ind;\\n        return val*value+ind;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3437665,
                "title": "python3-o-n-count-reminder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOperation are made to change v to (v + value), (v - value), (v + 2 * value),..., which are all have same result with v % value. In order to find the MEX, we need to fill the nums from 0, 1, 2, ..., the MEX is the reminder that has no more count than all others.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        cnt = [0] * value\\n        for v in nums: cnt[v % value] += 1\\n        ans = min(cnt)\\n        return ans * value + cnt.index(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        cnt = [0] * value\\n        for v in nums: cnt[v % value] += 1\\n        ans = min(cnt)\\n        return ans * value + cnt.index(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406327,
                "title": "easy-descriptive-cpp-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // This function calculates the modulo of the dividend and divisor,\\n    // and returns a positive result if the modulo is negative.\\n    int moduloCalculator(int dividend, int divisor) {\\n        int r = dividend % divisor;\\n        if (r < 0) {\\n            return r + divisor;\\n        } else {\\n            return r;\\n        }\\n    }\\n\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int arrSize = nums.size();\\n        map<int, int> m;\\n\\n        // Iterate over the array, and add each element to the map with its modulo value as the key.\\n        for (int i = 0; i < arrSize; i++) {\\n            if (nums[i] < 0) {\\n                m[moduloCalculator(nums[i], value)]++;\\n            } else {\\n                m[nums[i] % value]++;\\n            }\\n        }\\n\\n        // Iterate over the range of integers from 0 to arrSize-1,\\n        // and check if each integer is in the map.\\n        // If an integer is not in the map, return it as the smallest non-negative integer.\\n        // If an integer is in the map, decrement its frequency in the map.\\n        for (int i = 0; i < arrSize; i++) {\\n            cout << m[i % value] << \"\\\\n\";\\n            if (!m[i % value] || m[i % value] == 0) {\\n                return i;\\n            } else {\\n                m[i % value]--;\\n            }\\n        } \\n\\n        // If all integers from 0 to arrSize-1 are in the map, return arrSize as the smallest non-negative integer.\\n        return arrSize;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // This function calculates the modulo of the dividend and divisor,\\n    // and returns a positive result if the modulo is negative.\\n    int moduloCalculator(int dividend, int divisor) {\\n        int r = dividend % divisor;\\n        if (r < 0) {\\n            return r + divisor;\\n        } else {\\n            return r;\\n        }\\n    }\\n\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int arrSize = nums.size();\\n        map<int, int> m;\\n\\n        // Iterate over the array, and add each element to the map with its modulo value as the key.\\n        for (int i = 0; i < arrSize; i++) {\\n            if (nums[i] < 0) {\\n                m[moduloCalculator(nums[i], value)]++;\\n            } else {\\n                m[nums[i] % value]++;\\n            }\\n        }\\n\\n        // Iterate over the range of integers from 0 to arrSize-1,\\n        // and check if each integer is in the map.\\n        // If an integer is not in the map, return it as the smallest non-negative integer.\\n        // If an integer is in the map, decrement its frequency in the map.\\n        for (int i = 0; i < arrSize; i++) {\\n            cout << m[i % value] << \"\\\\n\";\\n            if (!m[i % value] || m[i % value] == 0) {\\n                return i;\\n            } else {\\n                m[i % value]--;\\n            }\\n        } \\n\\n        // If all integers from 0 to arrSize-1 are in the map, return arrSize as the smallest non-negative integer.\\n        return arrSize;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3379060,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        vector<int>mod(value) ;\\n        for(auto &x : nums){\\n            int m = (x % value + value) % value ;\\n            mod[m]++ ;\\n        }\\n        int minimum = INT_MAX ;\\n        int idx = -1 ;\\n        for(int i = 0; i < value; i++){\\n            if(mod[i] < minimum){\\n                minimum = mod[i] ;\\n                idx = i ;\\n            }\\n        }\\n        return minimum * value + idx ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        vector<int>mod(value) ;\\n        for(auto &x : nums){\\n            int m = (x % value + value) % value ;\\n            mod[m]++ ;\\n        }\\n        int minimum = INT_MAX ;\\n        int idx = -1 ;\\n        for(int i = 0; i < value; i++){\\n            if(mod[i] < minimum){\\n                minimum = mod[i] ;\\n                idx = i ;\\n            }\\n        }\\n        return minimum * value + idx ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367573,
                "title": "smallest-missing-non-negative-integer-after-operations-tricky-get-remainders-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n\\n        int []count=new int[value];\\n\\n        for(int n:nums){\\n            int rem=(value + n%value)%value;\\n            count[rem]++;\\n        }\\n\\n        int min=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<value;i++){\\n            min=Math.min(min,value*count[i]+i);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n\\n        int []count=new int[value];\\n\\n        for(int n:nums){\\n            int rem=(value + n%value)%value;\\n            count[rem]++;\\n        }\\n\\n        int min=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<value;i++){\\n            min=Math.min(min,value*count[i]+i);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366623,
                "title": "python-modulo-o-n",
                "content": "1. Group `nums` by `n % value` and get `arr`(length=`value`).\\n2. `arr[i]` = number of `i`(mod `value`) we can use. \\nWe count from `0`, `1`, ... to `value-1` (mod `value`) repeatedly, and finally stop at the answer.\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        # group nums by n % value\\n        cnt = Counter([n % value for n in nums])\\n        arr = [cnt[k] for k in range(value)]\\n        \\n        # _min = least number of cycles\\n\\t\\t# a cycle = we can count from 0, 1, ... to value-1 (mod value)\\n        _min = min(arr)\\n        ans = value * _min\\n        for a in arr:\\n            if a == _min:\\n                break\\n            ans += 1\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Group `nums` by `n % value` and get `arr`(length=`value`).\\n2. `arr[i]` = number of `i`(mod `value`) we can use. \\nWe count from `0`, `1`, ... to `value-1` (mod `value`) repeatedly, and finally stop at the answer.\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        # group nums by n % value\\n        cnt = Counter([n % value for n in nums])\\n        arr = [cnt[k] for k in range(value)]\\n        \\n        # _min = least number of cycles\\n\\t\\t# a cycle = we can count from 0, 1, ... to value-1 (mod value)\\n        _min = min(arr)\\n        ans = value * _min\\n        for a in arr:\\n            if a == _min:\\n                break\\n            ans += 1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3365089,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def findSmallestInteger(nums: Array[Int], value: Int): Int = {\\n        val count = Array.fill(value)(0)\\n        nums.foreach(n => count((n % value + value) % value) = count((n % value + value) % value) + 1)\\n        val res = count.zipWithIndex.sortBy(_._1).head\\n        res._1 * value + res._2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def findSmallestInteger(nums: Array[Int], value: Int): Int = {\\n        val count = Array.fill(value)(0)\\n        nums.foreach(n => count((n % value + value) % value) = count((n % value + value) % value) + 1)\\n        val res = count.zipWithIndex.sortBy(_._1).head\\n        res._1 * value + res._2\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3357966,
                "title": "c-simple-solution-with-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.Take a hashmap `hm` and fill it with frequency of how many times the  smallest possible non negative number i.e remainder for each number `x` in the array can be achieved .\\n2. If a remainder `r` can be acchieved more than once i.e `hm[r] > 1` than add `value` to the remainder `r` `hm[r]-1` times and since it can be achieved add it to hashmap as well i.e perform `hm[r + value * ( hm[r] -1)] = 1 `. \\n2.Keep counting from 0 whichever value that is not present in hashmap is the answer .   \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets take a test case:  nums = [1,-10,7,13,6,8], value = 5\\n\\n1. Take a hashmap. \\n```c++\\nunordered_map<int,int> hm ;\\n```\\n2. Iterate through nums and increment the occurance of remainder for current number .\\n```c++\\n    for(int &x: nums){\\n        x = (value + x % value) % value ;\\n        hm[x]++;\\n        .... rest of the operations ....\\n    }\\n\\n```\\n4. In the same loop since reminder r has been achieved `hm[r]` times . We can also achieve value `r + value * (hm[r]-1)`\\nFor example : nums = [11,-10,7,13,16,8], value = 5\\nThe remainder for numbers 11 and 16 in nums in same which is 1 and so hm[1] = 2 .  \\nSince number 1 can be already achieved from number 11 in array we can use another number 16 to achieve 1 + (2-1) * 5 which is 6 . We are trying to achieve more and more small numbers by avoiding duplicacy so that smallest number that is missing is maximum . \\n \\n```c++\\nfor(int &x: nums){\\n        x = (value + x % value) % value ;\\n        hm[x]++;\\n        hm[x + value * (hm[x]-1) ] = 1;\\n    }\\n```\\n\\n5. Now check for all numbers starting from 0 which are there in hashmap . The first number which is missing is the answer . Since there can be atmost N numbers in hashmap time complexity for this operation is O(N)\\n\\n```c++\\nint i = 0 ; \\nwhile(true){\\n    if(hm.count(i)) i++;\\n    else return i ;\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) (consider insertion in map and module operation to be in O(1) )\\n- Space complexity:\\nO(N) for hashmap\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int> hm ; \\n        for(int &x: nums){\\n            x = (value + x % value) % value ;\\n            hm[x]++ ;\\n            hm[x + value * (hm[x]-1) ] = 1; \\n        }\\n        \\n        int i = 0 ; \\n        while(true){\\n            if(hm.count(i)) i++;\\n            else return i ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```c++\\nunordered_map<int,int> hm ;\\n```\n```c++\\n    for(int &x: nums){\\n        x = (value + x % value) % value ;\\n        hm[x]++;\\n        .... rest of the operations ....\\n    }\\n\\n```\n```c++\\nfor(int &x: nums){\\n        x = (value + x % value) % value ;\\n        hm[x]++;\\n        hm[x + value * (hm[x]-1) ] = 1;\\n    }\\n```\n```c++\\nint i = 0 ; \\nwhile(true){\\n    if(hm.count(i)) i++;\\n    else return i ;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int> hm ; \\n        for(int &x: nums){\\n            x = (value + x % value) % value ;\\n            hm[x]++ ;\\n            hm[x + value * (hm[x]-1) ] = 1; \\n        }\\n        \\n        int i = 0 ; \\n        while(true){\\n            if(hm.count(i)) i++;\\n            else return i ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353388,
                "title": "a-few-solutions",
                "content": "Construct a min heap `q` from each value `x` of the input array `A` by taking the positive modulus value `x % K` given input value `K`, then perform a linear scan of each `i`<sup>th</sup> candidate from `0..1e5` inclusive and return `i` when the top of the min heap `q` does *not* equal `i`.\\n\\nNote: when duplicate values `x` exist at the top of the `q`, we enqueue `x` plus `K` multipled by an incremental `factor`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findSmallestInteger(A: IntArray, K: Int): Int {\\n        var q = PriorityQueue<Int>(A.map{ x -> if (0 <= x) x % K else x + K * Math.ceil(-x.toDouble() / K.toDouble()).toInt() }.toMutableList())\\n        for (i in 0..1e5.toInt()) {\\n            var x = if (0 < q.size) q.poll() else (1e9 + 7).toInt()\\n            if (i != x)\\n                return i\\n            var factor = 1\\n            while (0 < q.size && q.peek() == x)\\n                q.add(q.poll() + K * factor++)\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet findSmallestInteger = (A, K) => {\\n    let q = [];\\n    for (let x of A.map(x => 0 <= x ? x % K : x + K * Math.ceil(-x / K)).sort((a, b) => a - b))\\n        heappush(q, x);\\n    for (let i = 0; i <= Number(1e5); ++i) {\\n        let x = q.length ? heappop(q) : Number(1e9 + 7);\\n        if (i != x)\\n            return i;\\n        let factor = 1;\\n        while (q.length && q[0] == x)\\n            heappush(q, heappop(q) + K * factor++);\\n    }\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findSmallestInteger(self, A: List[int], K: int) -> int:\\n        q = [x % K for x in A]; heapify(q)\\n        for i in range(int(1e5 + 1)):\\n            x = heappop(q) if len(q) else int(1e9 + 7)\\n            if i != x:\\n                return i\\n            factor = 1\\n            while len(q) and q[0] == x:\\n                heappush(q, heappop(q) + K * factor); factor += 1\\n```\\n\\n*Rust*\\n```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\nimpl Solution {\\n    pub fn find_smallest_integer(A: Vec<i32>, K: i32) -> i32 {\\n        let mut q = BinaryHeap::new();\\n        for x in A {\\n            q.push(-(if 0 <= x { x % K } else { x + K * (-x as f32 / K as f32).ceil() as i32 }))\\n        }\\n        for i in 0..=1e5 as usize {\\n            let x = if 0 < q.len() { q.pop().unwrap() } else { 1e9 as i32 + 7 };\\n            if i as i32 != -x {\\n                return i as i32;\\n            }\\n            let mut factor = 1;\\n            while 0 < q.len() && *q.peek().unwrap() == x {\\n                q.pop(); q.push(x - K * factor);\\n            }\\n        }\\n        -1\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Queue = priority_queue<int, VI, ::greater<int>>;\\n    int findSmallestInteger(VI& A, int K, Queue q = {}) {\\n        for (auto x: A)\\n            q.push(0 <= x ? x % K : x + K * ceil(-x / double(K)));\\n        for (auto i{ 0 }; i <= 1e5; ++i) {\\n            auto x = q.size() ? q.top() : int(1e9 + 7); q.pop();\\n            if (i != x)\\n                return i;\\n            auto factor = 1;\\n            while (q.size() && q.top() == x)\\n                q.pop(), q.push(x + K * factor++);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findSmallestInteger(A: IntArray, K: Int): Int {\\n        var q = PriorityQueue<Int>(A.map{ x -> if (0 <= x) x % K else x + K * Math.ceil(-x.toDouble() / K.toDouble()).toInt() }.toMutableList())\\n        for (i in 0..1e5.toInt()) {\\n            var x = if (0 < q.size) q.poll() else (1e9 + 7).toInt()\\n            if (i != x)\\n                return i\\n            var factor = 1\\n            while (0 < q.size && q.peek() == x)\\n                q.add(q.poll() + K * factor++)\\n        }\\n        return -1\\n    }\\n}\\n```\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet findSmallestInteger = (A, K) => {\\n    let q = [];\\n    for (let x of A.map(x => 0 <= x ? x % K : x + K * Math.ceil(-x / K)).sort((a, b) => a - b))\\n        heappush(q, x);\\n    for (let i = 0; i <= Number(1e5); ++i) {\\n        let x = q.length ? heappop(q) : Number(1e9 + 7);\\n        if (i != x)\\n            return i;\\n        let factor = 1;\\n        while (q.length && q[0] == x)\\n            heappush(q, heappop(q) + K * factor++);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findSmallestInteger(self, A: List[int], K: int) -> int:\\n        q = [x % K for x in A]; heapify(q)\\n        for i in range(int(1e5 + 1)):\\n            x = heappop(q) if len(q) else int(1e9 + 7)\\n            if i != x:\\n                return i\\n            factor = 1\\n            while len(q) and q[0] == x:\\n                heappush(q, heappop(q) + K * factor); factor += 1\\n```\n```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\nimpl Solution {\\n    pub fn find_smallest_integer(A: Vec<i32>, K: i32) -> i32 {\\n        let mut q = BinaryHeap::new();\\n        for x in A {\\n            q.push(-(if 0 <= x { x % K } else { x + K * (-x as f32 / K as f32).ceil() as i32 }))\\n        }\\n        for i in 0..=1e5 as usize {\\n            let x = if 0 < q.len() { q.pop().unwrap() } else { 1e9 as i32 + 7 };\\n            if i as i32 != -x {\\n                return i as i32;\\n            }\\n            let mut factor = 1;\\n            while 0 < q.len() && *q.peek().unwrap() == x {\\n                q.pop(); q.push(x - K * factor);\\n            }\\n        }\\n        -1\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Queue = priority_queue<int, VI, ::greater<int>>;\\n    int findSmallestInteger(VI& A, int K, Queue q = {}) {\\n        for (auto x: A)\\n            q.push(0 <= x ? x % K : x + K * ceil(-x / double(K)));\\n        for (auto i{ 0 }; i <= 1e5; ++i) {\\n            auto x = q.size() ? q.top() : int(1e9 + 7); q.pop();\\n            if (i != x)\\n                return i;\\n            auto factor = 1;\\n            while (q.size() && q.top() == x)\\n                q.pop(), q.push(x + K * factor++);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353213,
                "title": "python-easy-understand-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        nums = [n % value for n in nums]\\n        count = Counter(nums)\\n        for i in range(value):\\n            if i not in count:\\n                return i\\n\\n        n = min(count.values())\\n        res = n * value\\n        curr = 0\\n        for i in range(value):\\n            if count[i] == n:\\n                return res\\n            res += 1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        nums = [n % value for n in nums]\\n        count = Counter(nums)\\n        for i in range(value):\\n            if i not in count:\\n                return i\\n\\n        n = min(count.values())\\n        res = n * value\\n        curr = 0\\n        for i in range(value):\\n            if count[i] == n:\\n                return res\\n            res += 1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349335,
                "title": "simple-c-linear-solution",
                "content": "# Intuition\\nSimple keep track of modulo frequency and iterate and subtract frequency , if frequency == 0 return index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& v, int value) {\\n        unordered_map<int,int> moduloCounter;\\n        for(int x : v) {\\n            moduloCounter[((x % value) + value) % value] += 1;\\n        }\\n        for(int i = 0; i <= v.size(); i += 1) {\\n            int rem = i % value;\\n            if(moduloCounter.count(rem) && moduloCounter[rem] > 0) moduloCounter[rem] -= 1;\\n            else return i;\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& v, int value) {\\n        unordered_map<int,int> moduloCounter;\\n        for(int x : v) {\\n            moduloCounter[((x % value) + value) % value] += 1;\\n        }\\n        for(int i = 0; i <= v.size(); i += 1) {\\n            int rem = i % value;\\n            if(moduloCounter.count(rem) && moduloCounter[rem] > 0) moduloCounter[rem] -= 1;\\n            else return i;\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348423,
                "title": "count-reminders",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        map<int, int> mp;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            mp[(nums[i] < 0? (nums[i] % value + value)%value: nums[i]%value)]++;\\n        }\\n        int idx = 0, mn = INT_MAX;\\n        for(int i = 0; i < value; i++) {\\n            if(mp[i] < mn) {\\n                idx = i;\\n                mn = mp[i];\\n            }\\n        }\\n        return mn * value + idx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        map<int, int> mp;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            mp[(nums[i] < 0? (nums[i] % value + value)%value: nums[i]%value)]++;\\n        }\\n        int idx = 0, mn = INT_MAX;\\n        for(int i = 0; i < value; i++) {\\n            if(mp[i] < mn) {\\n                idx = i;\\n                mn = mp[i];\\n            }\\n        }\\n        return mn * value + idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347655,
                "title": "map-modular-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int> mp;\\n        for(auto i : nums){\\n            mp[(i % value + value) % value]+=1;\\n        }\\n\\n        int ans = 0;\\n        for(int ele=0; ele < (int) nums.size(); ele++){\\n            if(mp[(ele)] > 0){\\n                mp[ele]--;\\n            }else if(mp[(ele % value)] > 0){\\n                mp[ele % value]--;\\n            }\\n            else{\\n                return ele;\\n            }\\n        }\\n        return (int)nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int> mp;\\n        for(auto i : nums){\\n            mp[(i % value + value) % value]+=1;\\n        }\\n\\n        int ans = 0;\\n        for(int ele=0; ele < (int) nums.size(); ele++){\\n            if(mp[(ele)] > 0){\\n                mp[ele]--;\\n            }else if(mp[(ele % value)] > 0){\\n                mp[ele % value]--;\\n            }\\n            else{\\n                return ele;\\n            }\\n        }\\n        return (int)nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344883,
                "title": "simple-linear-solution",
                "content": "# Intuition\\nFor $$x = 0,1,2,3,...$$, can we find unique $$i$$ such that: $$nums[i] \\\\pm k*value = x$$ where $$k$$ is some integer.\\nWe can take mod (%) value of both sides to obtain:\\n$$[(nums[i])\\\\%value \\\\pm (k*value)\\\\%value]\\\\%value = x\\\\%value$$\\nNote: $$(k*value)\\\\%value = 0$$\\nTherefore, for $$x = 0,1,2,3,...,$$ find $$i$$ such that: $$(nums[i])\\\\%value = x\\\\%value$$, otherwise, return that $$x$$.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$, \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$N = len(nums)$$ \\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        mod_value = [i%value for i in nums]\\n        remaining = Counter(mod_value)\\n        x = 0\\n        while x%value in remaining:\\n            remaining[x%value] -= 1\\n            if remaining[x%value] == 0:\\n                del remaining[x%value]\\n            x += 1\\n        return x\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        mod_value = [i%value for i in nums]\\n        remaining = Counter(mod_value)\\n        x = 0\\n        while x%value in remaining:\\n            remaining[x%value] -= 1\\n            if remaining[x%value] == 0:\\n                del remaining[x%value]\\n            x += 1\\n        return x\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343642,
                "title": "cpp-modulo-easy-5-lines-o-n",
                "content": "##### Intuition\\nCount the modulo with value of all the elements\\n**For Negative :** make its counterpositive then add its modulo\\nie : **(x % value) + value**\\nNow if number is 7 and your value is 5 then you can either make 2 , 7 , 12 .. and so on that means you can make **5 * k + 2** where **(k >= 0)**\\n\\n* Time complexity: **O(n)**\\n* Space complexity: **O(value)**\\n\\n##### Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> freq(value);\\n        for(int num : nums)\\n            freq[((num % value) + value) % value]++;\\n        int mn_pos = min_element(freq.begin(), freq.end()) - freq.begin();\\n        return freq[mn_pos] * value + mn_pos;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> freq(value);\\n        for(int num : nums)\\n            freq[((num % value) + value) % value]++;\\n        int mn_pos = min_element(freq.begin(), freq.end()) - freq.begin();\\n        return freq[mn_pos] * value + mn_pos;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339349,
                "title": "c-remainder-count-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map <int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n           if(nums[i] > 0){\\n              m[nums[i]%value]++;\\n           }\\n           else{\\n              int k=abs(nums[i])%value;\\n              if(k==0){\\n                  m[k]++;\\n              }\\n              else{\\n                 m[value-k]++;\\n              }\\n           }\\n        }\\n        int ans=INT_MAX;\\n        if(m.size()==value){\\n          for(auto &it:m){\\n             ans=min(ans,(it.second*value)+it.first);\\n          }\\n        }\\n        else{\\n          for(int i=0;i<value;i++){\\n             if(m.find(i)==m.end()){\\n                 ans= i;\\n                 break;\\n             } \\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map <int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n           if(nums[i] > 0){\\n              m[nums[i]%value]++;\\n           }\\n           else{\\n              int k=abs(nums[i])%value;\\n              if(k==0){\\n                  m[k]++;\\n              }\\n              else{\\n                 m[value-k]++;\\n              }\\n           }\\n        }\\n        int ans=INT_MAX;\\n        if(m.size()==value){\\n          for(auto &it:m){\\n             ans=min(ans,(it.second*value)+it.first);\\n          }\\n        }\\n        else{\\n          for(int i=0;i<value;i++){\\n             if(m.find(i)==m.end()){\\n                 ans= i;\\n                 break;\\n             } \\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336828,
                "title": "python-super-easy-hashtable-o-n",
                "content": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        \\n        hashtable = defaultdict(int)\\n        # store the frequency of mods\\n        for num in nums:\\n            hashtable[num%value] += 1\\n            \\n        self.ans = -1\\n        \\n        while True:\\n            self.ans += 1\\n            if self.ans % value not in hashtable:\\n                return self.ans\\n            hashtable[self.ans%value] -= 1\\n            if hashtable[self.ans%value] == 0:\\n                del hashtable[self.ans%value]\\n                \\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        \\n        hashtable = defaultdict(int)\\n        # store the frequency of mods\\n        for num in nums:\\n            hashtable[num%value] += 1\\n            \\n        self.ans = -1\\n        \\n        while True:\\n            self.ans += 1\\n            if self.ans % value not in hashtable:\\n                return self.ans\\n            hashtable[self.ans%value] -= 1\\n            if hashtable[self.ans%value] == 0:\\n                del hashtable[self.ans%value]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336036,
                "title": "simple-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                nums[i]*=-1;\\n                int mod=nums[i]%value;\\n                mod=value-mod;\\n                nums[i]=mod;\\n                nums[i]=nums[i]%value;\\n            }\\n            else{\\n                nums[i]=nums[i]%value;\\n            }\\n        }\\n        map<int,int>amap;\\n        for(int i=0;i<nums.size();i++){\\n            amap[nums[i]]++;\\n        }\\n        int count=0;\\n        for(auto i: amap){\\n            if(i.first==count){\\n                int curr=i.first;\\n                int k=1;\\n                while(amap[curr]>1){\\n                    amap[curr+(k*value)]++;\\n                    amap[curr]--;\\n                    k++;\\n                }\\n            }\\n            else{\\n                continue;\\n                // return count;\\n            }\\n            count++;\\n        }\\n        // for(auto i: amap){\\n            // cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                nums[i]*=-1;\\n                int mod=nums[i]%value;\\n                mod=value-mod;\\n                nums[i]=mod;\\n                nums[i]=nums[i]%value;\\n            }\\n            else{\\n                nums[i]=nums[i]%value;\\n            }\\n        }\\n        map<int,int>amap;\\n        for(int i=0;i<nums.size();i++){\\n            amap[nums[i]]++;\\n        }\\n        int count=0;\\n        for(auto i: amap){\\n            if(i.first==count){\\n                int curr=i.first;\\n                int k=1;\\n                while(amap[curr]>1){\\n                    amap[curr+(k*value)]++;\\n                    amap[curr]--;\\n                    k++;\\n                }\\n            }\\n            else{\\n                continue;\\n                // return count;\\n            }\\n            count++;\\n        }\\n        // for(auto i: amap){\\n            // cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3335748,
                "title": "c-hash-table-easy-solution",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int ans = 0;\\n        unordered_map<int,int> m;\\n        for(auto x:nums){\\n            int t = x%value;\\n            if(x<0){\\n                t = (-x)%value;\\n                t = value - t;\\n            }\\n            t %= value;\\n            m[t] += 1;\\n        }\\n        while(m[ans%value]>0){\\n            m[ans%value]-=1;\\n            ans += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int ans = 0;\\n        unordered_map<int,int> m;\\n        for(auto x:nums){\\n            int t = x%value;\\n            if(x<0){\\n                t = (-x)%value;\\n                t = value - t;\\n            }\\n            t %= value;\\n            m[t] += 1;\\n        }\\n        while(m[ans%value]>0){\\n            m[ans%value]-=1;\\n            ans += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335225,
                "title": "count-modulo-num",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor an element n, we can achieve the minimum non-negative value of n % value. Any element n can be transformed into (n % value + m * value). \\n\\n- Count modulo of every number.\\n- Iterate with i=0, and check if we have a modulo (i % value) that we can tranform to i.\\n- If so, we decrease the counter for that modulo. If the counter reaches zero, we cannot produce i and it\\'s our missing value.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n\\n        n = len(nums)\\n        mp = {}\\n        for i in range(n):\\n            mp[nums[i]%value] = mp.get(nums[i]%value, 0) + 1\\n        \\n        i = 0\\n        while mp.get(i%value, 0) > 0:\\n            mp[i%value] -= 1\\n            i+=1\\n        return i\\n\\n\\n            \\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n\\n        n = len(nums)\\n        mp = {}\\n        for i in range(n):\\n            mp[nums[i]%value] = mp.get(nums[i]%value, 0) + 1\\n        \\n        i = 0\\n        while mp.get(i%value, 0) > 0:\\n            mp[i%value] -= 1\\n            i+=1\\n        return i\\n\\n\\n            \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334198,
                "title": "simple-solution-with-hashmap",
                "content": "```\\nclass Solution {\\n    func findSmallestInteger(_ nums: [Int], _ value: Int) -> Int {\\n        var map = [Int: Int]()\\n        for num in nums {\\n            let val = num % value\\n            let key = val >= 0 ? val : val + value\\n            map[key, default: 0] += 1\\n        }\\n        var ans = 0\\n        while let cur = map[ans%value], cur > 0 {\\n            map[ans%value] = cur-1\\n            ans += 1\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findSmallestInteger(_ nums: [Int], _ value: Int) -> Int {\\n        var map = [Int: Int]()\\n        for num in nums {\\n            let val = num % value\\n            let key = val >= 0 ? val : val + value\\n            map[key, default: 0] += 1\\n        }\\n        var ans = 0\\n        while let cur = map[ans%value], cur > 0 {\\n            map[ans%value] = cur-1\\n            ans += 1\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332845,
                "title": "antarnab",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>&v, int x) {\\n        int i,n=v.size(),ans=0;\\n        unordered_map<int,int>m;\\n        for(i=0;i<n;i++)m[(v[i]%x+x)%x]++; \\n        for(i=0;i<n;i++){\\n            if(m[i%x])m[i%x]--;\\n            else return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>&v, int x) {\\n        int i,n=v.size(),ans=0;\\n        unordered_map<int,int>m;\\n        for(i=0;i<n;i++)m[(v[i]%x+x)%x]++; \\n        for(i=0;i<n;i++){\\n            if(m[i%x])m[i%x]--;\\n            else return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331597,
                "title": "swift-solution",
                "content": "# Approach\\n1. Create a map, where the key is the remainder of the number divided by value, and the value is the number of times that remainder appears.\\n2. Loop through the numbers in the array.\\n3. If the remainder of the number divided by value is negative, add it to the map.\\n4. Otherwise, add the remainder to the map.\\n5. Set the index to 0.\\n6. Loop through the map until the map is empty.\\n7. If the index divided by value is in the map, decrement the value by 1.\\n8. Otherwise, return the index.\\n9. Increment the index by 1.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    func findSmallestInteger(_ nums: [Int], _ value: Int) -> Int\\n    {\\n        var map = [Int: Int]()\\n        for num in nums\\n        {\\n            if num % value < 0\\n            {\\n                map[num % value + value, default: 0] += 1\\n            }\\n            else\\n            {\\n                map[num % value, default: 0] += 1\\n            }\\n        }\\n        var index = 0\\n        while true\\n        {\\n            if let count = map[index % value]\\n            {\\n                map[index % value] = count - 1\\n                if map[index % value] == 0\\n                {\\n                    map.removeValue(forKey: index % value)\\n                }\\n            }\\n            else\\n            {\\n                return index\\n            }\\n            index += 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution\\n{\\n    func findSmallestInteger(_ nums: [Int], _ value: Int) -> Int\\n    {\\n        var map = [Int: Int]()\\n        for num in nums\\n        {\\n            if num % value < 0\\n            {\\n                map[num % value + value, default: 0] += 1\\n            }\\n            else\\n            {\\n                map[num % value, default: 0] += 1\\n            }\\n        }\\n        var index = 0\\n        while true\\n        {\\n            if let count = map[index % value]\\n            {\\n                map[index % value] = count - 1\\n                if map[index % value] == 0\\n                {\\n                    map.removeValue(forKey: index % value)\\n                }\\n            }\\n            else\\n            {\\n                return index\\n            }\\n            index += 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330218,
                "title": "o-n-solution-and-o-n-space-modulo-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find out the minimum non-negative number that can\\'t be formed by doing any operation on every elements of the nums.\\n\\n`%` tells us what any number can become after `+` or `-` operation.\\nFor eg- `num = 7, and val = 3`\\n`7 % 3 == 1` \\n 7 can be converted to minimum 1 and then 4, 7, 10 ...\\n\\nby doing % we can find minimum non negative number we can obtain from each number. But key thing to note here is that one number can be converted to another but can\\'t be reconverted but rather convert all other numbers to avoid getting minimum non-negative missing number.\\n\\nSo we will store freq of numbers that gives us a particular modulo.\\n\\n- We will start from ans = 0.\\n- if `ans % value` not present in hm, means we can\\'t get this number by any number of operation so this will be our answer.\\n- if `ans % value` present in hm but freq == 0, then we get our answer\\n- else `ans % value` present in hm, reduce frequency by 1, which means ans can be obtained by converting 1 number.  \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n\\n        mod = {} # mod and freq\\n        for v in nums:\\n            k = v%value\\n            if k not in mod:\\n                mod[k] = 1\\n            else: mod[k] += 1\\n        \\n        ans = 0\\n\\n        while 1:\\n            if ans%value not in mod:\\n                return ans\\n            if ans%value in mod and mod[ans%value] == 0:\\n                return ans\\n\\n            mod[ans%value] -= 1\\n            ans += 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n\\n        mod = {} # mod and freq\\n        for v in nums:\\n            k = v%value\\n            if k not in mod:\\n                mod[k] = 1\\n            else: mod[k] += 1\\n        \\n        ans = 0\\n\\n        while 1:\\n            if ans%value not in mod:\\n                return ans\\n            if ans%value in mod and mod[ans%value] == 0:\\n                return ans\\n\\n            mod[ans%value] -= 1\\n            ans += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330151,
                "title": "leetcode-2598-smallest-missing-non-negative-integer-after-operations-solution-in-c",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(value)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int i;\\n        vector<int> hash(value);\\n        unordered_map<int, int> m;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int remainder = nums[i] % value;\\n            \\n            if (remainder >= 0) {\\n                hash[remainder]++;\\n            }\\n            else {\\n                hash[remainder + value]++;\\n            }\\n        }\\n        \\n        for (i = 0; i < nums.size(); i++) {\\n            hash[i % value]--;\\n            if (hash[i % value] < 0)\\n                return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int i;\\n        vector<int> hash(value);\\n        unordered_map<int, int> m;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int remainder = nums[i] % value;\\n            \\n            if (remainder >= 0) {\\n                hash[remainder]++;\\n            }\\n            else {\\n                hash[remainder + value]++;\\n            }\\n        }\\n        \\n        for (i = 0; i < nums.size(); i++) {\\n            hash[i % value]--;\\n            if (hash[i % value] < 0)\\n                return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328144,
                "title": "python-runtime-beat-97-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create reminders array. (nums_div)\\n2. count the occurrence for each reminders. (count_div)\\n3. We need to find the index and minimum value.\\nFor example: if count_div = [1, 2, 1, 2, 1] with value = 5\\n--> That mean MEX can\\'t be 0, 1, 2, 3, 4, Since there is no 0 in count_div.\\n--> Minimum value is 1, index = 0.\\n4. Get the answer by **value * minimum + index**\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findSmallestInteger(self, nums, value):\\n        nums_div = [n % value for n in nums]\\n\\n        count_div = [0] * value\\n        for n in nums_div:\\n            count_div[n] += 1\\n\\n        m = min(count_div)\\n        return value * m + count_div.index(m)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findSmallestInteger(self, nums, value):\\n        nums_div = [n % value for n in nums]\\n\\n        count_div = [0] * value\\n        for n in nums_div:\\n            count_div[n] += 1\\n\\n        m = min(count_div)\\n        return value * m + count_div.index(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327855,
                "title": "c-easy-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int len = nums.size(),count=0;\\n        map<int,int> mp;\\n        for(int i=0;i<len;i++){\\n            if(nums[i]<0){\\n                nums[i]=-nums[i];\\n                if(nums[i]%value==0){\\n                    nums[i]=0;\\n                } else{\\n                    int div = nums[i]/value;\\n                    div++;\\n                    nums[i] = value*div - nums[i];\\n                }\\n            }\\n            mp[nums[i]%value]++;\\n        }\\n        while(true){\\n            if(mp[count%value]==0) return count;\\n            mp[count%value]--;\\n            count++;\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int len = nums.size(),count=0;\\n        map<int,int> mp;\\n        for(int i=0;i<len;i++){\\n            if(nums[i]<0){\\n                nums[i]=-nums[i];\\n                if(nums[i]%value==0){\\n                    nums[i]=0;\\n                } else{\\n                    int div = nums[i]/value;\\n                    div++;\\n                    nums[i] = value*div - nums[i];\\n                }\\n            }\\n            mp[nums[i]%value]++;\\n        }\\n        while(true){\\n            if(mp[count%value]==0) return count;\\n            mp[count%value]--;\\n            count++;\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327535,
                "title": "using-moduli-cpp-with-explanation-and-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat do we think at first ......\\nI wanna find out the possible numbers that can be made using a[i].\\nThis is where moduli comes to the rescue so by taking moduli of a number with k we know what is the least i.e between 0 & k what can be made using a[i]. This makes sense because what is moduli remainder after repeatedly subtracting or adding k (exactly what we need here).\\nIf we can make x using a[i] then we can also make x + 1*k , x + 2*k .... and so on we need to find the count of remainders which are [0,k)\\nthen just check how far we can push until we encounter a zero.\\n\\nDO UPVOTE IF HELPFUL. \\nI would really appreciate it :)\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& a, int k)\\n    {\\n        vector<int> c(k,0);\\n        for(auto x:a)\\n        {\\n            if(x%k<0)\\n            {\\n                c[(x%k)+k]++;\\n            }\\n            else\\n            {\\n                c[x%k]++;\\n            }\\n\\n        }\\n        int i=0;\\n        int ans=0;\\n        while(c[i]>0)\\n        {\\n            c[i]--;\\n            ans++;\\n            i++;\\n            if(i==k){i=0;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& a, int k)\\n    {\\n        vector<int> c(k,0);\\n        for(auto x:a)\\n        {\\n            if(x%k<0)\\n            {\\n                c[(x%k)+k]++;\\n            }\\n            else\\n            {\\n                c[x%k]++;\\n            }\\n\\n        }\\n        int i=0;\\n        int ans=0;\\n        while(c[i]>0)\\n        {\\n            c[i]--;\\n            ans++;\\n            i++;\\n            if(i==k){i=0;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326060,
                "title": "javascript-module-127ms",
                "content": "```\\nconst findSmallestInteger = (a, v) => {\\n    let mods = Array(v).fill(0), cur = 0;\\n    for (const x of a) mods[(x % v + v) % v]++;\\n    while (mods[cur % v] > 0) {\\n        mods[cur % v]--;\\n        cur++;\\n    }\\n    return cur;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nconst findSmallestInteger = (a, v) => {\\n    let mods = Array(v).fill(0), cur = 0;\\n    for (const x of a) mods[(x % v + v) % v]++;\\n    while (mods[cur % v] > 0) {\\n        mods[cur % v]--;\\n        cur++;\\n    }\\n    return cur;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326028,
                "title": "python-count-the-number-reminders-ranges-from-0-to-value-1-explained",
                "content": "(1) We can apply any number of operations to each number;\\n(2) We can only change the original number by adding or substacting value * n, where n can be any integer number;\\nTherefore, the problem translates to finding the reminder value with minimum occurrences (i.e, for each num, get the reminder: num % value). The reason is that we can always translate a number to another one with step \"value\". \\n\\nFor example, if the value is 5:\\nwe can translate 10 to (0, 5, 15, ...)\\nwe can translate 21 to (1, 6, 11, ...)\\n\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        mod_count = collections.defaultdict(int)\\n        for num in nums:\\n            mod_count[num % value] += 1\\n        \\n        missing_min = 0\\n        for i in range(value):\\n            if mod_count[i] < mod_count[missing_min]:\\n                missing_min = i\\n            \\n        return mod_count[missing_min] * value + missing_min\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        mod_count = collections.defaultdict(int)\\n        for num in nums:\\n            mod_count[num % value] += 1\\n        \\n        missing_min = 0\\n        for i in range(value):\\n            if mod_count[i] < mod_count[missing_min]:\\n                missing_min = i\\n            \\n        return mod_count[missing_min] * value + missing_min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325875,
                "title": "c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int result = 0;\\n        unordered_map<int,int> m,s;\\n        for(auto i:nums)\\n        {\\n            if(i>=0)\\n            {\\n                m[i%value]++;\\n            }\\n            else\\n            {\\n                int q = ceil(abs(i)/value);\\n                i += (q*value);\\n                i += value;\\n                m[i%value]++;\\n            }\\n        }\\n        int n = nums.size();\\n        while(true)\\n        {\\n           if(m[result] != 0)\\n           {\\n               m[result]--;\\n           }\\n           else if(m[result%value] != 0)\\n           {\\n               m[result%value]--;\\n           }\\n           else\\n           {\\n               return result;\\n           }\\n           result++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int result = 0;\\n        unordered_map<int,int> m,s;\\n        for(auto i:nums)\\n        {\\n            if(i>=0)\\n            {\\n                m[i%value]++;\\n            }\\n            else\\n            {\\n                int q = ceil(abs(i)/value);\\n                i += (q*value);\\n                i += value;\\n                m[i%value]++;\\n            }\\n        }\\n        int n = nums.size();\\n        while(true)\\n        {\\n           if(m[result] != 0)\\n           {\\n               m[result]--;\\n           }\\n           else if(m[result%value] != 0)\\n           {\\n               m[result%value]--;\\n           }\\n           else\\n           {\\n               return result;\\n           }\\n           result++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325591,
                "title": "easy-c-solution-with-complexiety-o-n-logn",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N * logN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        vector<int> remainders;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] < 0) \\n                nums[i] += (abs(nums[i])/value + (abs(nums[i])%value != 0)) * value;\\n            remainders.push_back(nums[i] % value);\\n        }\\n        sort(remainders.begin(), remainders.end());\\n        int mex = 0, mul = 0;\\n        for(int i=0;i<n;i++){\\n            if(i > 0 && remainders[i] % value != remainders[i-1] % value) mul = 0;\\n            remainders[i] += value * mul;\\n            mul++;\\n        }\\n        sort(remainders.begin(), remainders.end());\\n        for(int i=0;i<n;i++) if(remainders[i] == mex) mex++;\\n        return mex;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        vector<int> remainders;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] < 0) \\n                nums[i] += (abs(nums[i])/value + (abs(nums[i])%value != 0)) * value;\\n            remainders.push_back(nums[i] % value);\\n        }\\n        sort(remainders.begin(), remainders.end());\\n        int mex = 0, mul = 0;\\n        for(int i=0;i<n;i++){\\n            if(i > 0 && remainders[i] % value != remainders[i-1] % value) mul = 0;\\n            remainders[i] += value * mul;\\n            mul++;\\n        }\\n        sort(remainders.begin(), remainders.end());\\n        for(int i=0;i<n;i++) if(remainders[i] == mex) mex++;\\n        return mex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324348,
                "title": "easy-best-solution-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size(),i=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            int num=nums[i];\\n            if(num<0)\\n                num = (num)%value + value;\\n            num = num%value;\\n            mp[num]++;\\n        }\\n        while(1){\\n            if(mp.find(i)==mp.end())\\n                break;\\n            int cnt=mp[i],val=i;\\n            while(--cnt){\\n                val+=value;\\n                mp[val]++;\\n            }\\n            i++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size(),i=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            int num=nums[i];\\n            if(num<0)\\n                num = (num)%value + value;\\n            num = num%value;\\n            mp[num]++;\\n        }\\n        while(1){\\n            if(mp.find(i)==mp.end())\\n                break;\\n            int cnt=mp[i],val=i;\\n            while(--cnt){\\n                val+=value;\\n                mp[val]++;\\n            }\\n            i++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323789,
                "title": "simple-modulo-operation-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& a, int k) {\\n        int n=a.size();\\n        \\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            if(a[i]<0){\\n                int val=0,m=abs(a[i])/k;\\n                while(1){\\n                    val=m*k+a[i];\\n                    if(val>=0)\\n                        break;\\n                    m++;\\n                }\\n                a[i]=val;\\n            }\\n            mp[a[i]%k]++;\\n        }\\n        \\n        \\n        int curr=0;\\n        while(1){\\n            if(!mp[curr%k])\\n                return curr;\\n            mp[curr%k]--;\\n            curr++;\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& a, int k) {\\n        int n=a.size();\\n        \\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            if(a[i]<0){\\n                int val=0,m=abs(a[i])/k;\\n                while(1){\\n                    val=m*k+a[i];\\n                    if(val>=0)\\n                        break;\\n                    m++;\\n                }\\n                a[i]=val;\\n            }\\n            mp[a[i]%k]++;\\n        }\\n        \\n        \\n        int curr=0;\\n        while(1){\\n            if(!mp[curr%k])\\n                return curr;\\n            mp[curr%k]--;\\n            curr++;\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323089,
                "title": "easy-approach-with-fast-run",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int>ans(value,0);\\n        for(auto x:nums)ans[(x%value+value)%value]+=1;\\n        int n=100000,m=0;\\n        for(int i=0;i<value;i++){\\n            if(ans[i]<n){\\n                n=ans[i];m=i;\\n            }\\n        }\\n        if(n==100000)return n;\\n        return n*value+m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int>ans(value,0);\\n        for(auto x:nums)ans[(x%value+value)%value]+=1;\\n        int n=100000,m=0;\\n        for(int i=0;i<value;i++){\\n            if(ans[i]<n){\\n                n=ans[i];m=i;\\n            }\\n        }\\n        if(n==100000)return n;\\n        return n*value+m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321783,
                "title": "python-greedy",
                "content": "Just try numbers one by one from 0. We only care about module.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        count = defaultdict(int)\\n        for num in nums:\\n            count[num % value] += 1\\n\\n        res = 0\\n        valueNeeded = 0\\n        while True:\\n            if count[valueNeeded] > 0:\\n                count[valueNeeded] -= 1\\n                res += 1\\n                valueNeeded = (valueNeeded + 1) % value\\n            else:\\n                break\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        count = defaultdict(int)\\n        for num in nums:\\n            count[num % value] += 1\\n\\n        res = 0\\n        valueNeeded = 0\\n        while True:\\n            if count[valueNeeded] > 0:\\n                count[valueNeeded] -= 1\\n                res += 1\\n                valueNeeded = (valueNeeded + 1) % value\\n            else:\\n                break\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321729,
                "title": "c-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int, int> rem;\\n        for(int i = 0; i < nums.size(); i++){\\n            int v = (nums[i] % value + value) % value;\\n            rem[v]++;\\n        }\\n        for(int i = 0; i < nums.size()+1; i++){\\n            if(!rem.count(i % value)) return i;\\n            else if(rem[i % value] == 0) return i;\\n            rem[i % value]--;\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int, int> rem;\\n        for(int i = 0; i < nums.size(); i++){\\n            int v = (nums[i] % value + value) % value;\\n            rem[v]++;\\n        }\\n        for(int i = 0; i < nums.size()+1; i++){\\n            if(!rem.count(i % value)) return i;\\n            else if(rem[i % value] == 0) return i;\\n            rem[i % value]--;\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321519,
                "title": "practical-python-soln-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndiffrent discritption could be: try to get as many unique postive numbers from nums by +- value to any value in nums any number of times and returning the MEX of the unique postive numbers.\\n\\n\\nfirst thing i was thinking about was what values could i make by +- value from nums. What you get is you can only make n % value or\\n n%value + (value * x) numbers , i started by printing:\\n[n%value for n in nums]\\n\\nand what you end up seeing is repeated mod values.\\n\\nex: seen_mod would end up somthing like [4,4,3,3,2,2,1,1] i then relized the  + (value * x) part to n%value + (value * x).\\n\\nBasically if i had two 4\\'s i know that the next largest value i could make was by adding value to 4 (you cant substract value from n%value  because then youd be negitive and the goal was to try to get as many unique postive numbers from nums)\\n\\nthe next thing is to keep track of how many times youve seen that n%value\\nand that is the (value * x) part where x is the number of times youve seen that mod + 1 (plus 1 becuase weve now seen it just now)\\n\\nyou keep track of the the unique numbers youve made and find the MEX of that :)\\n\\nfrom there you can wittel your soln down to some optimized ugly thing\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findSmallestInteger(self, nums, value):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type value: int\\n        :rtype: int\\n        \"\"\"\\n        # how many times weve seen a mod value\\n        seen_mod_count= {}\\n\\n        # values weve collected\\n        seen_mod = set()\\n        \\n        for n in nums:\\n            \\n            # the mod for this number with value\\n            v = n % value\\n            \\n            # how many times have we seen this mod\\n            # first time we want to add 0*value to n%value\\n            seen_mod_count[v] = seen_mod_count.get(v,-1)+1\\n\\n            # adding to the mod value * the number of times weves seen this mod + 1\\n            # bascially going to the next largest number we could make by adding val\\n         \\n            seen_mod.add(v + (value*seen_mod_count[v]))\\n\\n\\n        # lazy way to find the MEX\\n        i = 0 \\n        while i in seen_mod:\\n            i+=1\\n        return i\\n\\n\\n\\n    \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def findSmallestInteger(self, nums, value):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type value: int\\n        :rtype: int\\n        \"\"\"\\n        # how many times weve seen a mod value\\n        seen_mod_count= {}\\n\\n        # values weve collected\\n        seen_mod = set()\\n        \\n        for n in nums:\\n            \\n            # the mod for this number with value\\n            v = n % value\\n            \\n            # how many times have we seen this mod\\n            # first time we want to add 0*value to n%value\\n            seen_mod_count[v] = seen_mod_count.get(v,-1)+1\\n\\n            # adding to the mod value * the number of times weves seen this mod + 1\\n            # bascially going to the next largest number we could make by adding val\\n         \\n            seen_mod.add(v + (value*seen_mod_count[v]))\\n\\n\\n        # lazy way to find the MEX\\n        i = 0 \\n        while i in seen_mod:\\n            i+=1\\n        return i\\n\\n\\n\\n    \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321324,
                "title": "c-golang-map",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int, int> Map;\\n        for(int num: nums) Map[(num % value + value) % value]++;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(!Map[i % value]) return i;\\n            --Map[i % value];\\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\n// Golang\\nfunc findSmallestInteger(nums []int, value int) int {\\n    Map := make(map[int]int)\\n    for _, num := range nums {Map[(num % value + value) % value]++}\\n    for i := 0; i < len(nums); i++ {\\n        if Map[i % value] == 0 {return i}\\n        Map[i % value]--\\n    }\\n    return len(nums)\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int, int> Map;\\n        for(int num: nums) Map[(num % value + value) % value]++;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(!Map[i % value]) return i;\\n            --Map[i % value];\\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\n// Golang\\nfunc findSmallestInteger(nums []int, value int) int {\\n    Map := make(map[int]int)\\n    for _, num := range nums {Map[(num % value + value) % value]++}\\n    for i := 0; i < len(nums); i++ {\\n        if Map[i % value] == 0 {return i}\\n        Map[i % value]--\\n    }\\n    return len(nums)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321247,
                "title": "java-o-n-remainder-concept-easy-to-understand",
                "content": "A more intutive and easy to understand solution for the above question\\nJust keep in mind that while storing the frequencies of negative numbers in terms of remainder, it should be ((a%b)+b)%b  , and rest is simple calculations....\\nthe while helps to more intutively give us the idea of solving the problem ...\\n\\n```\\n\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        int n=nums.length;\\n        int rem[]=new int[value+1];\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                rem[((nums[i]%value)+value)%value]++;\\n            }\\n            else{\\n                rem[nums[i]%value]++;\\n            }\\n        }\\n        int i=0;\\n        int count=0;\\n        while(true){\\n            if(rem[i]==0)   break;\\n            rem[i]--;\\n            i++;\\n            if(i==value){  \\n                count++;\\n                i=0;\\n            }\\n        }\\n        return (value*count)+i;\\n    }\\n}\\n\\n```\\n\\nHope you can understand the logic \\nPlease upvote if you like it !!!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        int n=nums.length;\\n        int rem[]=new int[value+1];\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                rem[((nums[i]%value)+value)%value]++;\\n            }\\n            else{\\n                rem[nums[i]%value]++;\\n            }\\n        }\\n        int i=0;\\n        int count=0;\\n        while(true){\\n            if(rem[i]==0)   break;\\n            rem[i]--;\\n            i++;\\n            if(i==value){  \\n                count++;\\n                i=0;\\n            }\\n        }\\n        return (value*count)+i;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320776,
                "title": "java-mathematical-nearly-100ms-a",
                "content": "# Intuition\\nCan solve it by maths\\n\\n# Approach\\nStraight Forward Mathematical\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nNot Sure\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        /*To check if any duplicate entries before & after\\n        the operation */\\n        Set<Integer> set = new HashSet<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        //Actual Conversion Logic\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] > value){\\n                int temp = nums[i] / value;\\n                temp *= value;\\n                nums[i] = nums[i] - temp;\\n            }\\n            else if(nums[i] < 0){\\n                int val = nums[i] * -1;\\n                val = val / value;\\n                int mul = (val*value) + nums[i] == 0 ? val : val+1;\\n                nums[i] = nums[i] + (mul*value);\\n            }\\n            else if(nums[i] == value){\\n              nums[i] = 0;\\n            }\\n            //Duplicate Checks & Multiply Based On The Count\\n            if(!set.add(nums[i])){\\n                int count = map.get(nums[i]);\\n                map.put(nums[i], ++count);\\n                nums[i] = nums[i]+(count*value);\\n                continue;\\n            }\\n            else\\n                map.put(nums[i], 0);\\n        }\\n        //Sort to check the 1st missing number\\n        Arrays.sort(nums);\\n        int min = -1;\\n        if(nums[0] != 0)\\n          return 0;\\n        //Removes if still having duplicates\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] != min+1)\\n              return min+1;\\n            if(i != nums.length-1)\\n                min += nums[i] != nums[i+1] ? 1 : 0; \\n        }\\n        return nums[nums.length-1]+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        /*To check if any duplicate entries before & after\\n        the operation */\\n        Set<Integer> set = new HashSet<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        //Actual Conversion Logic\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] > value){\\n                int temp = nums[i] / value;\\n                temp *= value;\\n                nums[i] = nums[i] - temp;\\n            }\\n            else if(nums[i] < 0){\\n                int val = nums[i] * -1;\\n                val = val / value;\\n                int mul = (val*value) + nums[i] == 0 ? val : val+1;\\n                nums[i] = nums[i] + (mul*value);\\n            }\\n            else if(nums[i] == value){\\n              nums[i] = 0;\\n            }\\n            //Duplicate Checks & Multiply Based On The Count\\n            if(!set.add(nums[i])){\\n                int count = map.get(nums[i]);\\n                map.put(nums[i], ++count);\\n                nums[i] = nums[i]+(count*value);\\n                continue;\\n            }\\n            else\\n                map.put(nums[i], 0);\\n        }\\n        //Sort to check the 1st missing number\\n        Arrays.sort(nums);\\n        int min = -1;\\n        if(nums[0] != 0)\\n          return 0;\\n        //Removes if still having duplicates\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] != min+1)\\n              return min+1;\\n            if(i != nums.length-1)\\n                min += nums[i] != nums[i+1] ? 1 : 0; \\n        }\\n        return nums[nums.length-1]+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320530,
                "title": "easy-java-solution-o-n-easy-approach-clean-code-chumeshwar-approach",
                "content": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] arr, int value) {\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            int ele = arr[i];\\n            int mod = ele % value;\\n            if(ele < 0 && mod != 0){\\n                mod += value;\\n            }\\n            map.put(mod , map.getOrDefault(mod , 0) + 1);\\n        }\\n        \\n        for(int i = 0 ; i <= 100000 ; i++){\\n            int ele = i % value;\\n            if(!map.containsKey(ele) || map.get(ele) == 0) return i;\\n            map.put(ele , map.get(ele) - 1);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] arr, int value) {\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            int ele = arr[i];\\n            int mod = ele % value;\\n            if(ele < 0 && mod != 0){\\n                mod += value;\\n            }\\n            map.put(mod , map.getOrDefault(mod , 0) + 1);\\n        }\\n        \\n        for(int i = 0 ; i <= 100000 ; i++){\\n            int ele = i % value;\\n            if(!map.containsKey(ele) || map.get(ele) == 0) return i;\\n            map.put(ele , map.get(ele) - 1);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320424,
                "title": "using-map-sorting-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        sort(nums.begin() , nums.end());\\n        vector<int>nums1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int g=nums[i]%value;\\n            if(g<0)\\n            {\\n                while(g<0)\\n                {\\n                    g+=value;\\n                }\\n            }\\n            nums1.push_back(g);\\n        }\\n        sort(nums1.begin() , nums1.end());\\n        map<int , int>mp;\\n        set<int>st;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int g=nums1[i]%value;\\n            st.insert(mp[g]+g);\\n            \\n            mp[g]=mp[g]+value;\\n        }\\n        vector<int>v1;\\n        for(auto i:st)\\n        {\\n            v1.push_back(i);\\n            cout<<i<<\" \";\\n        }\\n        \\n        vector<int>v2;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i]>=0)\\n                v2.push_back(v1[i]);\\n        }\\n        \\n        int c=0;\\n        for(int i=0;i<v2.size();i++)\\n        {\\n            if(c!=v2[i])\\n            {\\n                break;\\n            }\\n            c++;\\n        }\\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        sort(nums.begin() , nums.end());\\n        vector<int>nums1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int g=nums[i]%value;\\n            if(g<0)\\n            {\\n                while(g<0)\\n                {\\n                    g+=value;\\n                }\\n            }\\n            nums1.push_back(g);\\n        }\\n        sort(nums1.begin() , nums1.end());\\n        map<int , int>mp;\\n        set<int>st;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int g=nums1[i]%value;\\n            st.insert(mp[g]+g);\\n            \\n            mp[g]=mp[g]+value;\\n        }\\n        vector<int>v1;\\n        for(auto i:st)\\n        {\\n            v1.push_back(i);\\n            cout<<i<<\" \";\\n        }\\n        \\n        vector<int>v2;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i]>=0)\\n                v2.push_back(v1[i]);\\n        }\\n        \\n        int c=0;\\n        for(int i=0;i<v2.size();i++)\\n        {\\n            if(c!=v2[i])\\n            {\\n                break;\\n            }\\n            c++;\\n        }\\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3320398,
                "title": "c-faster-than-85-math",
                "content": "# Intuition\\nFirst calculate the number of all remainders for items of array nums by dividing by value.\\n\\n# Approach\\nFirst calculate the number of all remainders with method\\n```\\nprivate int[] CreateSet(int[] nums, int value)\\n```\\nThen find the first index with minimum number of remainders.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindSmallestInteger(int[] nums, int value) {\\n        var arr = CreateSet(nums, value);\\n        var minIndex = 0;\\n        var min = arr[minIndex];\\n        for (int i = 0; i < arr.Length; i++)\\n        {\\n            if (arr[minIndex] > arr[i])\\n            {\\n                minIndex = i;\\n            }\\n        }\\n        var rs = minIndex + arr[minIndex] * value;\\n        return rs;\\n    }\\n    private int[] CreateSet(int[] nums, int value)\\n    {\\n        var rs = new int[value];\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            var index = nums[i] % value;\\n            if (index < 0) index += value;\\n            rs[index]++;\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nprivate int[] CreateSet(int[] nums, int value)\\n```\n```\\npublic class Solution {\\n    public int FindSmallestInteger(int[] nums, int value) {\\n        var arr = CreateSet(nums, value);\\n        var minIndex = 0;\\n        var min = arr[minIndex];\\n        for (int i = 0; i < arr.Length; i++)\\n        {\\n            if (arr[minIndex] > arr[i])\\n            {\\n                minIndex = i;\\n            }\\n        }\\n        var rs = minIndex + arr[minIndex] * value;\\n        return rs;\\n    }\\n    private int[] CreateSet(int[] nums, int value)\\n    {\\n        var rs = new int[value];\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            var index = nums[i] % value;\\n            if (index < 0) index += value;\\n            rs[index]++;\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320389,
                "title": "c-solution",
                "content": "# Approach\\nStoring the modulo of all elements with value and replacing them with distinct smallest possible elements having the same modulo.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int, int> mp;\\n        for(auto&i:nums){\\n            mp[(i%value + value)%value]++;\\n        }\\n        vector<int> v;\\n        for(auto&[f, s]:mp){\\n            for(int i = 0, index = 0 ; i < s; i++){\\n                v.push_back(f + value*index++);\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        // for(auto&i:v) cout << i << \\' \\';\\n        // cout << \\'\\\\n\\';\\n        if(v[0] != 0) return 0;\\n        for(int i = 1, n = v.size(); i < n; i++){\\n            if(v[i] - v[i - 1] != 1) return v[i - 1] + 1;\\n        }\\n        return v.back() + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int, int> mp;\\n        for(auto&i:nums){\\n            mp[(i%value + value)%value]++;\\n        }\\n        vector<int> v;\\n        for(auto&[f, s]:mp){\\n            for(int i = 0, index = 0 ; i < s; i++){\\n                v.push_back(f + value*index++);\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        // for(auto&i:v) cout << i << \\' \\';\\n        // cout << \\'\\\\n\\';\\n        if(v[0] != 0) return 0;\\n        for(int i = 1, n = v.size(); i < n; i++){\\n            if(v[i] - v[i - 1] != 1) return v[i - 1] + 1;\\n        }\\n        return v.back() + 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3320383,
                "title": "c-100-fast-100-space-efficient-maths-hashmap",
                "content": "***If a problem doesn\\'t challenge you , it won\\'t change you***\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int>mp;vector<int>values_adding;\\n        for(auto &num:nums){num%=value;if(num<0)num+=value;mp[num]++;}\\n        for(auto &freq:mp){\\n            auto curr=freq.first;\\n            while(freq.second>1){\\n                freq.second--;curr+=value;\\n                values_adding.push_back(curr);\\n            }\\n        }for(auto &val:values_adding)mp[val]++;\\n        for(int i=0;i<1e5+3;i++)if(mp.count(i)==0)return i;return -1;\\n    }\\n};\\n```\\nnote: some knowledge of set theory is required and same for modulo operation \\n**logik:**\\n1. when we take modulo of a number x by value x%value=(a) here a always lies between 0 to value-1 \\n2. when the modulo is negative like taking -10%3 gives -1 but to make it positive we add value to it again so -10%3 becomes 2 instead of -1\\n3. now first we take modulo of each element in the given array and make a count of each remainder that occurs in a map\\n4. now for each number [i]  in the map let the frequency be x[i], while x[i]>1 we will keep adding value to [i]  and storing the result to be added in map (because a,a+value,a+2 x value... ) all can be taken, as any number of operations is possible. So by using this method we eliminate all possibility of picking a MEX value that may be present in array if adding is performed (lets say)k times \\n5. now we add all the values in the map, the total empty spaces can be maximum 1e5 (given) but values will be from -(1e9) to (1e9) now, there will always be a value from 0 to 1e5 that is missing and if all values from 0 to 1e5 are present 1e5+1 will be the missing value \\n6. hence run a loop from 0 to 1e5+2 to find the missing value in the map, the missing value is the answer\\n![image](https://assets.leetcode.com/users/images/3c622d53-4838-4540-b07b-db7f1a555ca2_1679324068.2118762.png)\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int>mp;vector<int>values_adding;\\n        for(auto &num:nums){num%=value;if(num<0)num+=value;mp[num]++;}\\n        for(auto &freq:mp){\\n            auto curr=freq.first;\\n            while(freq.second>1){\\n                freq.second--;curr+=value;\\n                values_adding.push_back(curr);\\n            }\\n        }for(auto &val:values_adding)mp[val]++;\\n        for(int i=0;i<1e5+3;i++)if(mp.count(i)==0)return i;return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320190,
                "title": "java-hashmap-math",
                "content": "\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                nums[i]=value+nums[i]%(value);\\n                nums[i]=nums[i]%value;\\n            }\\n            else{\\n                nums[i]=nums[i]%value;\\n            }\\n        }\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+value);\\n                nums[i]=map.get(nums[i]);\\n                map.put(nums[i],nums[i]);\\n            }\\n            else{\\n                map.put(nums[i],nums[i]);\\n            }\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }\\n        }\\n        System.out.println(-3%4);\\n        for(int i=0;i<max;i++){\\n            if(!map.containsKey(i)){\\n                return i;\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                nums[i]=value+nums[i]%(value);\\n                nums[i]=nums[i]%value;\\n            }\\n            else{\\n                nums[i]=nums[i]%value;\\n            }\\n        }\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+value);\\n                nums[i]=map.get(nums[i]);\\n                map.put(nums[i],nums[i]);\\n            }\\n            else{\\n                map.put(nums[i],nums[i]);\\n            }\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }\\n        }\\n        System.out.println(-3%4);\\n        for(int i=0;i<max;i++){\\n            if(!map.containsKey(i)){\\n                return i;\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319624,
                "title": "short-and-explained-c-modular-arithmetic-o-n-space-and-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe don\\'t care about number of steps. So if possible, we will try to make the current number equal to current MEX. What values it can take depends on the modulo of this number with the \\'value\\'.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore how many numbers are there for each remainder, i.e. `mp[nums[i]%value]++`. Since the modulo can be negative, get the positive modulo by modifying it to `mp[(nums[i]%value + value)%value]++`.\\nNow check if the remainder exists for the current MEX. If it exists, decrease the count in map(since it is now used) and increase MEX, else return MEX;\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int, int> mp;\\n        for(auto it: nums){\\n            mp[(it%value + value)%value]++;\\n        }\\n        int ans=0, k=ans%value;\\n        while(mp.count(k)){\\n            mp[k]--;\\n            if(mp[k]==0){mp.erase(k);}\\n            ans++;\\n            k = ans%value;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int, int> mp;\\n        for(auto it: nums){\\n            mp[(it%value + value)%value]++;\\n        }\\n        int ans=0, k=ans%value;\\n        while(mp.count(k)){\\n            mp[k]--;\\n            if(mp[k]==0){mp.erase(k);}\\n            ans++;\\n            k = ans%value;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319495,
                "title": "modular-arithmetic-binary-search",
                "content": "# Intuition\\n\\nSo, we need mostly positive numbers. if a num % value = x, we can change num to x, x* value, x * value * 2 . Example (6 = 1 in mod 5)\\n\\n# Approach\\n1. Find all positive mods in a greedy way. if num % value = x, and x is already found, for example 6 = 1 (mod 5) and 11 = 1 (mod 5) you can extend the next one.\\n2. Now that we have all values [0,1,2,3,4,5,7,8] (for example), we need to zero in on 6.\\n3. Note that for any non-gap progression, arr[i] = i, so we can use this to binary search on result.\\n\\n# Complexity\\n- Time complexity: O(n) + O(len(nums) * log2(len(nums)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nfunc findSmallestInteger(nums []int, value int) int {\\n    modSet := make(map[int]bool)\\n    multiplier := make(map[int]int)\\n    // remember 6=1 mod 5 if you have more than 1, you can extend them!!\\n    for _, num := range nums {\\n        cmod := ((num % value) + value) % value\\n        _, ok := modSet[cmod]\\n        if !ok {\\n            modSet[cmod] = true\\n            multiplier[cmod] = 0\\n        } else {\\n            lastMult, ok := multiplier[cmod]\\n            if !ok {\\n                panic(\"multiplier not found\")\\n            }\\n            lastMult++\\n            modSet[lastMult * value + cmod] = true\\n            multiplier[cmod] = lastMult\\n        }\\n    }\\n    modArr := make([]int, 0)\\n    for k, _ := range modSet {\\n        modArr = append(modArr, k)\\n    }\\n    sort.Ints(modArr)\\n    low := 0\\n    high := len(modArr) - 1\\n    validMid := -1\\n    for low <= high {\\n        mid := low + (high - low)/2\\n        if modArr[mid] > mid {\\n            high = mid-1\\n        } else {\\n            low = mid+1\\n            validMid = mid\\n        }\\n    }\\n    if validMid == -1 {\\n        return 0\\n    }\\n    return modArr[validMid]+1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nfunc findSmallestInteger(nums []int, value int) int {\\n    modSet := make(map[int]bool)\\n    multiplier := make(map[int]int)\\n    // remember 6=1 mod 5 if you have more than 1, you can extend them!!\\n    for _, num := range nums {\\n        cmod := ((num % value) + value) % value\\n        _, ok := modSet[cmod]\\n        if !ok {\\n            modSet[cmod] = true\\n            multiplier[cmod] = 0\\n        } else {\\n            lastMult, ok := multiplier[cmod]\\n            if !ok {\\n                panic(\"multiplier not found\")\\n            }\\n            lastMult++\\n            modSet[lastMult * value + cmod] = true\\n            multiplier[cmod] = lastMult\\n        }\\n    }\\n    modArr := make([]int, 0)\\n    for k, _ := range modSet {\\n        modArr = append(modArr, k)\\n    }\\n    sort.Ints(modArr)\\n    low := 0\\n    high := len(modArr) - 1\\n    validMid := -1\\n    for low <= high {\\n        mid := low + (high - low)/2\\n        if modArr[mid] > mid {\\n            high = mid-1\\n        } else {\\n            low = mid+1\\n            validMid = mid\\n        }\\n    }\\n    if validMid == -1 {\\n        return 0\\n    }\\n    return modArr[validMid]+1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3319486,
                "title": "simple-c-solution-100-tc-hashmap-sorting",
                "content": "# Intuition\\nFirst we sort the array , then we store the frequency of all the numbers in the array .\\nthen we started looking for non-negative integers starting from 0.\\nWe named the variable ans , for which we are looking for\\n\\nif the ans founds in array then increment it , if not then find someone in map that can make ans by adding of substracting value .\\n \\n//steps are explained in comments\\n\\n# Complexity\\n- Time complexity:O(n Log n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        unordered_map<int,int> cnt;\\n        for(auto x:nums)    cnt[x]++;   //count frequency of all the numbers\\n\\n        int ans=0, i=0;\\n        while(i<n && nums[i]<ans)  i++; //find first non negative number\\n        while(1){\\n            if(i<n && nums[i]==ans \\n                    && cnt[nums[i]]>0){  //ans is the number we are looking for\\n                cnt[nums[i]]--;          //decrease its frequency as it can\\'t be use again\\n                ans++;                   //now we had to look for next no\\n                i++;                     //from next index    \\n            }\\n            else {\\n                bool found=false;\\n                for(auto &[no,freq]:cnt){\\n                    if( (ans-no)%value==0 && freq>0 ){\\n                        cnt[no]--;\\n                        ans++;\\n                        found=true;\\n                    }\\n                }\\n                if(!found)  return ans;     //if a number not found after all map iteration then its the answer\\n            }\\n        }\\n        return INT_MAX;                     //control never reach here\\n    }\\n};\\n```\\nUpvote my answer if you find this worth it.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        unordered_map<int,int> cnt;\\n        for(auto x:nums)    cnt[x]++;   //count frequency of all the numbers\\n\\n        int ans=0, i=0;\\n        while(i<n && nums[i]<ans)  i++; //find first non negative number\\n        while(1){\\n            if(i<n && nums[i]==ans \\n                    && cnt[nums[i]]>0){  //ans is the number we are looking for\\n                cnt[nums[i]]--;          //decrease its frequency as it can\\'t be use again\\n                ans++;                   //now we had to look for next no\\n                i++;                     //from next index    \\n            }\\n            else {\\n                bool found=false;\\n                for(auto &[no,freq]:cnt){\\n                    if( (ans-no)%value==0 && freq>0 ){\\n                        cnt[no]--;\\n                        ans++;\\n                        found=true;\\n                    }\\n                }\\n                if(!found)  return ans;     //if a number not found after all map iteration then its the answer\\n            }\\n        }\\n        return INT_MAX;                     //control never reach here\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319150,
                "title": "c-o-n-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind all numbers which can be made from the given numbers.Find the first one which is not formed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nO(n)\\n```\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(n)\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            int t=nums[i]%value;\\n            if(t<0){\\n                t=t+value;\\n            }\\n            mp[t]++;\\n        }\\n        int ans=0;\\n        while(true){\\n            if(mp[ans]==0){\\n                return ans;\\n            }\\n            mp[ans]--;\\n            int count=mp[ans];\\n            while(count){\\n                int next=ans +(count*value);\\n                count--;\\n                mp[next]++;\\n            }\\n            ans++;\\n        }\\n        return (-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nO(n)\\n```\n```\\nO(n)\\n```\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            int t=nums[i]%value;\\n            if(t<0){\\n                t=t+value;\\n            }\\n            mp[t]++;\\n        }\\n        int ans=0;\\n        while(true){\\n            if(mp[ans]==0){\\n                return ans;\\n            }\\n            mp[ans]--;\\n            int count=mp[ans];\\n            while(count){\\n                int next=ans +(count*value);\\n                count--;\\n                mp[next]++;\\n            }\\n            ans++;\\n        }\\n        return (-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318846,
                "title": "python-counting-sort-o-n",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], k: int) -> int:\\n        counter = Counter([num%k for num in nums])\\n        if len(counter.keys()) < k:\\n            common = 0\\n        else:\\n            common = min(counter.values())\\n        res = common * k\\n        for i in range(k):\\n            if counter[i] == common:\\n                return res + i\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], k: int) -> int:\\n        counter = Counter([num%k for num in nums])\\n        if len(counter.keys()) < k:\\n            common = 0\\n        else:\\n            common = min(counter.values())\\n        res = common * k\\n        for i in range(k):\\n            if counter[i] == common:\\n                return res + i\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317967,
                "title": "java-using-hashmap-o-n-space-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        for (int i:nums){\\n            if(i>=0)i=i%k;\\n            else{\\n                i=i%k;\\n                i+=k;i=i%k;\\n            }\\n            if(map.get(i)==null)map.put(i,1);\\n            else map.put(i,map.get(i)+1);\\n        }\\n        \\n        int ans=0;\\n        while(true){\\n            if (map.get(ans%k)!=null && map.get(ans%k)>0){\\n                map.put(ans%k,map.get(ans%k)-1); ans++;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        for (int i:nums){\\n            if(i>=0)i=i%k;\\n            else{\\n                i=i%k;\\n                i+=k;i=i%k;\\n            }\\n            if(map.get(i)==null)map.put(i,1);\\n            else map.put(i,map.get(i)+1);\\n        }\\n        \\n        int ans=0;\\n        while(true){\\n            if (map.get(ans%k)!=null && map.get(ans%k)>0){\\n                map.put(ans%k,map.get(ans%k)-1); ans++;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317761,
                "title": "python-o-n-use-modulus",
                "content": "# Intuition\\nSince we can do the add/subtract ```value``` operation any number of times, each number in the list is effectively the same as ```num % value```. The largest missing non-negative integer is bound to be in the interval ```[0, len(nums)]```. To find the first missing non-negative integer, first save ```num % value``` in a map, and record their occurrences, and loop through ```[0, len(nums)]``` to find the first integer that cannot be formed with the moduli in the map. \\n\\n# Approach\\nFirst iteration, loop through ```nums``` and save ```num % value``` in a dictionary. \\n\\nSecond iteration, ```for i in [0, len(nums)]```, if ```nums[i]``` cannot be formed with any of the moduli in the dictionary, return immediately. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findSmallestInteger(self, nums, value):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type value: int\\n        :rtype: int\\n        \"\"\"\\n        m = {}\\n        for i in range(len(nums)):\\n            mod = nums[i] % value\\n            m[mod] = m.get(mod, 0) + 1\\n\\n        for i in range(len(nums)):\\n            mod = i % value\\n            if m.get(mod, 0) == 0:\\n                return i\\n            m[mod] -= 1\\n        return len(nums)\\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```value```\n```num % value```\n```[0, len(nums)]```\n```num % value```\n```[0, len(nums)]```\n```nums```\n```num % value```\n```for i in [0, len(nums)]```\n```nums[i]```\n```\\nclass Solution(object):\\n    def findSmallestInteger(self, nums, value):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type value: int\\n        :rtype: int\\n        \"\"\"\\n        m = {}\\n        for i in range(len(nums)):\\n            mod = nums[i] % value\\n            m[mod] = m.get(mod, 0) + 1\\n\\n        for i in range(len(nums)):\\n            mod = i % value\\n            if m.get(mod, 0) == 0:\\n                return i\\n            m[mod] -= 1\\n        return len(nums)\\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317686,
                "title": "using-frequency-map-and-mod",
                "content": "# Intuition\\n1. Calculate remainder values for each Integer. If number is less than 0 then add it with value. EX: [-3, 0], value: 4 -> Ans: 2 -> Because 0 is present, -3 +4 = 1 is present.\\n2. Calculate Frequency Map and get the least possible value which cannot be made.   \\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} value\\n * @return {number}\\n */\\nvar findSmallestInteger = function(nums, value) {\\n    nums = nums.map(num => {\\n        const val = num % value;\\n        if (val < 0) return val + value\\n        return val;\\n    });\\n            \\n    const freq = {};\\n    \\n    for (const num of nums) {\\n        if (freq[num]) freq[num]++;\\n        else freq[num] = 1;\\n    }\\n        \\n    let cur = 0;\\n    let res = Infinity;\\n    \\n    while(cur < value) {\\n        if (freq[cur] === undefined) return cur;\\n        let missing = (freq[cur] * value) + cur;\\n        res = Math.min(res, missing);\\n        cur++;\\n    }\\n\\n    return res;\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} value\\n * @return {number}\\n */\\nvar findSmallestInteger = function(nums, value) {\\n    nums = nums.map(num => {\\n        const val = num % value;\\n        if (val < 0) return val + value\\n        return val;\\n    });\\n            \\n    const freq = {};\\n    \\n    for (const num of nums) {\\n        if (freq[num]) freq[num]++;\\n        else freq[num] = 1;\\n    }\\n        \\n    let cur = 0;\\n    let res = Infinity;\\n    \\n    while(cur < value) {\\n        if (freq[cur] === undefined) return cur;\\n        let missing = (freq[cur] * value) + cur;\\n        res = Math.min(res, missing);\\n        cur++;\\n    }\\n\\n    return res;\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3317627,
                "title": "python-solution-explanation",
                "content": "# Intuition\\nIf repeatitive summation or subtraction shows up in the problem, modulo suddenly strikes in the mind. But how to use that? Well, We don\\'t care about the actual numbers, all we care about is, what can it be. For example value is 5, then element in nums i can be .., i-10, i-5,i, i+5, i+10, ... So, All you need is, just convert it in the represetation of module of 5 (value). So that we know it can be transferred to which number afterwards.\\n\\n# Approach\\nAll you need is, to maintain a count of each modulo in a has table and start from 0. If you have something in your hash availble which can be converted to your current number, well done, move ahead. Otherwise move ahead. How will you check the convertability? simple. You just check the modulo of the current number, if the current number is convertable to the present number in hash, then vice versa is also true.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        d = defaultdict(int)\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] % value\\n            d[nums[i]] += 1\\n        i = 0\\n        while True:\\n            if d[i%value] > 0: \\n                d[i%value] -= 1\\n            else:\\n                return i\\n            i += 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        d = defaultdict(int)\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] % value\\n            d[nums[i]] += 1\\n        i = 0\\n        while True:\\n            if d[i%value] > 0: \\n                d[i%value] -= 1\\n            else:\\n                return i\\n            i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317499,
                "title": "c-modulo-frequency-of-updated-elements",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        map<int,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                int tmp = abs(nums[i]);\\n                tmp = ceil((double)tmp/value);\\n                nums[i]+=(value*tmp);\\n            }\\n            else\\n            nums[i]%=value;\\n            m[nums[i]]++;\\n        }\\n        vector<int> vec;\\n        for(auto i:m)\\n        {\\n            int ele = i.first;\\n            vec.push_back(ele);\\n            for(int j=1;j<i.second;j++)\\n            {\\n                vec.push_back(value*j+ele);\\n            }\\n        }\\n        sort(vec.begin(),vec.end());\\n        int k=0;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i]==k)\\n            {\\n                k++;\\n            }\\n            if(vec[i]>k)\\n            {\\n                return k;\\n            }\\n        }\\n        return k;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        map<int,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                int tmp = abs(nums[i]);\\n                tmp = ceil((double)tmp/value);\\n                nums[i]+=(value*tmp);\\n            }\\n            else\\n            nums[i]%=value;\\n            m[nums[i]]++;\\n        }\\n        vector<int> vec;\\n        for(auto i:m)\\n        {\\n            int ele = i.first;\\n            vec.push_back(ele);\\n            for(int j=1;j<i.second;j++)\\n            {\\n                vec.push_back(value*j+ele);\\n            }\\n        }\\n        sort(vec.begin(),vec.end());\\n        int k=0;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i]==k)\\n            {\\n                k++;\\n            }\\n            if(vec[i]>k)\\n            {\\n                return k;\\n            }\\n        }\\n        return k;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317427,
                "title": "c-o-n-easy-solution",
                "content": "# Intuition\\n\\n# Approach\\nUse modulo to count and check the first index to be zero which would be the result.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        vector<int> data(value, 0);\\n        int ans = 0;\\n        \\n        for(auto a : nums)\\n            data[((a % value) + value) % value]++;\\n\\n        while(data[ans % value]--)\\n            ans++;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        \\n        vector<int> data(value, 0);\\n        int ans = 0;\\n        \\n        for(auto a : nums)\\n            data[((a % value) + value) % value]++;\\n\\n        while(data[ans % value]--)\\n            ans++;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317183,
                "title": "c-3-line",
                "content": "# Intuition\\nuse an counter array of remainder of value\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> cnt(value);\\n        for(auto x:nums)  cnt[(x%value + value) % value]++;\\n        for(int i=0;;i++) if(cnt[i%value]-- == 0) return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> cnt(value);\\n        for(auto x:nums)  cnt[(x%value + value) % value]++;\\n        for(int i=0;;i++) if(cnt[i%value]-- == 0) return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317175,
                "title": "sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=nums[i]/value;\\n            if(nums[i]>=0)\\n            {\\n                nums[i]-=x*value;\\n            }\\n            else{\\n                if(nums[i]-x*value==0)\\n                    nums[i]-=x*value;\\n                else nums[i]-=(x-1)*value;\\n            }\\n        }\\n        sort(nums.begin(),nums.end());\\n        // for(auto it:nums)\\n        // cout<<it<<\" \";\\n        cout<<endl;\\n        map<int,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[i]=-1;\\n            m[nums[i]]=-1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(m[nums[i]]>=0)\\n            {\\n                int x=nums[i];\\n                nums[i]=m[nums[i]];\\n                while(m[nums[i]]>=0 and nums[i]<n+2)\\n                {\\n                    nums[i]+=value;\\n                }\\n                m[nums[i]]=nums[i];\\n                m[x]=nums[i];\\n            }\\n            else m[nums[i]]=nums[i];\\n            // if(m[i]==0)\\n            //     return i;\\n        }\\n        \\n        // return 0;\\n        sort(nums.begin(),nums.end());\\n        // for(auto it:nums)\\n        // cout<<it<<\" \";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n       \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=nums[i]/value;\\n            if(nums[i]>=0)\\n            {\\n                nums[i]-=x*value;\\n            }\\n            else{\\n                if(nums[i]-x*value==0)\\n                    nums[i]-=x*value;\\n                else nums[i]-=(x-1)*value;\\n            }\\n        }\\n        sort(nums.begin(),nums.end());\\n        // for(auto it:nums)\\n        // cout<<it<<\" \";\\n        cout<<endl;\\n        map<int,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[i]=-1;\\n            m[nums[i]]=-1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(m[nums[i]]>=0)\\n            {\\n                int x=nums[i];\\n                nums[i]=m[nums[i]];\\n                while(m[nums[i]]>=0 and nums[i]<n+2)\\n                {\\n                    nums[i]+=value;\\n                }\\n                m[nums[i]]=nums[i];\\n                m[x]=nums[i];\\n            }\\n            else m[nums[i]]=nums[i];\\n            // if(m[i]==0)\\n            //     return i;\\n        }\\n        \\n        // return 0;\\n        sort(nums.begin(),nums.end());\\n        // for(auto it:nums)\\n        // cout<<it<<\" \";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n       \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3316974,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums, value):\\n        n, ans = len(nums), []\\n\\n        for i in nums:\\n            ans.append(i%value)\\n\\n        dict1 = Counter(ans)\\n\\n        for i in range(n+1):\\n            if dict1[i%value]:\\n                dict1[i%value] -= 1\\n            else:\\n                return i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums, value):\\n        n, ans = len(nums), []\\n\\n        for i in nums:\\n            ans.append(i%value)\\n\\n        dict1 = Counter(ans)\\n\\n        for i in range(n+1):\\n            if dict1[i%value]:\\n                dict1[i%value] -= 1\\n            else:\\n                return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316744,
                "title": "python-intuition-for-simple-o-n-solution",
                "content": "# Approach 1\\nWe want the maximum MEX of `nums`, meaning we want all the numbers in `nums` to be \\u2265 0 and small so we can have many conequtive numbers close to zero. Because we can add or subtract `value` as many times as we want, we can make any element of `nums` \\u2265 0 and small by simply adding/subtracting `value` until the element of `nums` cannot be made any smaller or it will become negative. \\n\\nWait a second, this is the same as taking the element of nums mod `value`. `nums[i] % value` gives us a number \\u2265 0 that is as small as possible by only adding/subtracting `value`. So we can just do `nums[i] % value` for all `i` and we\\'ll then sort the numbers and see where the first non-consequtive number appearing is.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        \\n        remainders = sorted([n % value for n in nums])\\n                \\n        for i, r in enumerate(remainders):\\n            if i != r:\\n                return i\\n        return len(remainders)\\n``` \\n\\n# Approach 2\\n\\nThe first approach passes the test cases but is not fully correct becasue we may have duplicate remainder values. For our example, let `value=4` and let us have some `nums` such that we have `remainders = [0, 1, 2, 2, 3, 4, 5]`. Our current code would say that the MEX is 6. However, we have two `2`\\'s that we got by subtracting/adding `value=4`. If we were to take one of the `2`\\'s and add another 4 to it, we\\'d get a six and `remainder = [0, 1, 2, 3, 4, 5, 6]`. Here our MEX would be 7.   \\n\\nSo if we have duplicate remainders, we want to add `value` so that all the remainders are unique. This may allow us to have a greater MEX value. We can do this by counting how many times a remainder appears. If a remainder has `k` duplicates then we add adding `value * i` for the `[0, ..., k-1]` duplicates of the remainder.\\n\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        \\n        # count how often a duplicate remainder appears in nums\\n        nums_to_freq = Counter([n % value for n in nums])\\n        \\n        # add value to duplicate remainders\\n        remainders = []\\n        for num, freq in nums_to_freq.items():\\n            for i in range(freq):\\n                remainders.append(num + value * i)\\n                \\n        # sort remainders\\n        remainders = sorted(remainders)\\n\\n        # find the greatest MEX\\n        for i, r in enumerate(remainders):\\n            if i != r:\\n                return i\\n        return len(remainders)\\n        \\n```\\n\\n# Complexity\\n- Time complexity: O(n) because we loop through each of `nums`, `nums_to_freq`, `remainders` once and all of these are linear in `n`, the length of `nums`.\\n\\n- Space complexity: O(n) because we compute `nums_to_freq` and `remainders` which are both linear in `n`, the length of `nums`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        \\n        remainders = sorted([n % value for n in nums])\\n                \\n        for i, r in enumerate(remainders):\\n            if i != r:\\n                return i\\n        return len(remainders)\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        \\n        # count how often a duplicate remainder appears in nums\\n        nums_to_freq = Counter([n % value for n in nums])\\n        \\n        # add value to duplicate remainders\\n        remainders = []\\n        for num, freq in nums_to_freq.items():\\n            for i in range(freq):\\n                remainders.append(num + value * i)\\n                \\n        # sort remainders\\n        remainders = sorted(remainders)\\n\\n        # find the greatest MEX\\n        for i, r in enumerate(remainders):\\n            if i != r:\\n                return i\\n        return len(remainders)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316688,
                "title": "10-line-code-simple-modulus-logic-explained-counting-remainder-s-short-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int>mp; // storing the modulus value;\\n        for(auto x: nums){\\n            if(x<0){\\n                int v = value * ceil(1.0*abs(x)/value) + x;\\n               mp[v%value]++;\\n            }else\\n                mp[x%value]++;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(mp[i%value]>0)\\n                mp[i%value]--;\\n            else\\n                return i;\\n        }\\n        \\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int>mp; // storing the modulus value;\\n        for(auto x: nums){\\n            if(x<0){\\n                int v = value * ceil(1.0*abs(x)/value) + x;\\n               mp[v%value]++;\\n            }else\\n                mp[x%value]++;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(mp[i%value]>0)\\n                mp[i%value]--;\\n            else\\n                return i;\\n        }\\n        \\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316619,
                "title": "count-by-equivalence-class",
                "content": "# Intuition\\nPartition the natural numbers into equivalence classes, with the classs labeled `n` containing all the numbers that can be reached after applying any number of operations on `n`, i.e.  $$\\\\set{n + value \\\\cdot k:  k  \\\\in \\\\mathbb{Z}}$$\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor an arbitrary number $$n+value \\\\cdot k$$, we can extract the class label `n` by taking the number modulo `value` and thereby eliminating any factor of `value`.\\n\\nFor each number in our list, we need to assign it to its corresponding equivalence class and keep track of how many numbers in our array belong to each class.\\n\\nThen, for each minimum-excluded value starting at 0, we look up the equivalence class `n` and generate if it at least one number in our array is a member of that class. If so, we decrement the count of elements belonging to the equivalence class `n`.\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        if(value==1) return nums.size();\\n        int mod[value] = {0};\\n        for(int n: nums) {\\n            int k = n%value;\\n            if (k<0) k = value + k;\\n            mod[k]+=1;\\n        }\\n        for(int i=0; i<=nums.size(); ++i){\\n            int k = i%value;\\n            // printf(\"i = %d, mod[%d] = %d\\\\n\", i, k, mod[k]);\\n            if (mod[k]>0) mod[k]-=1;\\n            else return i;\\n        }\\n        assert(false);\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        if(value==1) return nums.size();\\n        int mod[value] = {0};\\n        for(int n: nums) {\\n            int k = n%value;\\n            if (k<0) k = value + k;\\n            mod[k]+=1;\\n        }\\n        for(int i=0; i<=nums.size(); ++i){\\n            int k = i%value;\\n            // printf(\"i = %d, mod[%d] = %d\\\\n\", i, k, mod[k]);\\n            if (mod[k]>0) mod[k]-=1;\\n            else return i;\\n        }\\n        assert(false);\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316557,
                "title": "c-count-remainder-group-size",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> remainder(value, 0);\\n        for(auto n : nums) {\\n            n = n % value;\\n            if(n < 0) n += value;\\n            remainder[n]++;\\n        }\\n        auto itr = min_element(remainder.begin(), remainder.end());\\n        return (itr - remainder.begin()) + *itr * value;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> remainder(value, 0);\\n        for(auto n : nums) {\\n            n = n % value;\\n            if(n < 0) n += value;\\n            remainder[n]++;\\n        }\\n        auto itr = min_element(remainder.begin(), remainder.end());\\n        return (itr - remainder.begin()) + *itr * value;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316469,
                "title": "100-beats-time-100-beats-memory-perfect-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n       HashSet<Integer> set = new HashSet<>();\\n       if(value==1)\\n       {\\n           return nums.length;\\n       }\\n        int val =  value;\\n        int l = nums.length-1;\\n        for(int i : nums)\\n        { \\n            if(i>=0)\\n            {\\n                int sm = i % val;\\n                while(set.contains(sm) && sm<=l) sm+=val;\\n                if(sm<=l)set.add(sm);\\n            }\\n            else\\n            {\\n                int sm = -i;\\n                int z=  0;\\n                if(sm%val!=0) z = val - sm%val;\\n                while(set.contains(z) && z<=l)  z+=val;\\n                if(z<=l)set.add(z);\\n                \\n            }\\n        }\\n      \\n        for(int i = 0;i<=l;i++)\\n        {\\n            if(set.contains(i)==false)return i ;\\n        }\\n        return l+1;\\n        \\n        \\n    \\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n       HashSet<Integer> set = new HashSet<>();\\n       if(value==1)\\n       {\\n           return nums.length;\\n       }\\n        int val =  value;\\n        int l = nums.length-1;\\n        for(int i : nums)\\n        { \\n            if(i>=0)\\n            {\\n                int sm = i % val;\\n                while(set.contains(sm) && sm<=l) sm+=val;\\n                if(sm<=l)set.add(sm);\\n            }\\n            else\\n            {\\n                int sm = -i;\\n                int z=  0;\\n                if(sm%val!=0) z = val - sm%val;\\n                while(set.contains(z) && z<=l)  z+=val;\\n                if(z<=l)set.add(z);\\n                \\n            }\\n        }\\n      \\n        for(int i = 0;i<=l;i++)\\n        {\\n            if(set.contains(i)==false)return i ;\\n        }\\n        return l+1;\\n        \\n        \\n    \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316448,
                "title": "easy-c-solution-using-remainder-array",
                "content": "# Approach\\nLet $$n$$ = $$arr.size()$$.\\nWe will modify the array into array of remainders i.e. arr[i]=arr[i]%value. For negative numbers we can use arr[i] = (value + arr[i]%value)%value. Now if we have $$r$$ in the array we can modify it to $$r+value,r+value*2,...$$ Now we will check for the maximum missing non-negative integer from $$0$$ to $$n$$ . \\n\\nWe are checking only till arr.size() because we can always modify array to contain all numbers from $$0$$ to $$n-1$$ whenever the remainders array has all the remainders in equal count which makes $$n$$ as the MEX.\\n\\n- Time complexity:\\n$$O(n*log(n))$$\\nfor loop runs n times and log(n) time for map insertion.\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int v) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]>0) {\\n                nums[i]%=v;\\n            }\\n            if(nums[i]<0) {\\n                int k=abs(nums[i])/v;\\n                if(k*v==abs(nums[i])) nums[i]=0;\\n                else nums[i]=(k+1)*v-abs(nums[i]);\\n            }\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<=nums.size();i++) {\\n            int r=i%v,q=i/v;\\n            if(m[r]<=q) return i;\\n\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int v) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]>0) {\\n                nums[i]%=v;\\n            }\\n            if(nums[i]<0) {\\n                int k=abs(nums[i])/v;\\n                if(k*v==abs(nums[i])) nums[i]=0;\\n                else nums[i]=(k+1)*v-abs(nums[i]);\\n            }\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<=nums.size();i++) {\\n            int r=i%v,q=i/v;\\n            if(m[r]<=q) return i;\\n\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316427,
                "title": "java-solution",
                "content": "# Intuition\\nWe have understand that we need to reduce the largest numbers to smallest number possible, we can achieve this by doing division and saving the remainder. Once we have the frequency of smallest numbers possible, we can use them according to the need. \\n# Approach\\nFor negative numbers, we have to handle them to get the possible positive number for making the sequence. \\nWe have to store the remainders with frequency in the map and check against each smallest positivie number possible. \\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        int size = nums.length;\\n        Map<Integer,Integer> remCount = new HashMap<>();\\n        for(int num : nums){\\n            int rem = num % value;\\n            if(num < 0 && rem != 0){\\n                num = -num;\\n                int q = num / value;\\n                rem = (-num) + (value*(q+1));\\n            }\\n            int val = remCount.getOrDefault(rem,0);\\n            remCount.put(rem,val+1);\\n        }\\n        for(int i = 0; i < size; i++){\\n            int key = i % value;\\n            if(remCount.getOrDefault(key,0) == 0){\\n                return i;\\n            }else{\\n                int val = remCount.get(key);\\n                remCount.put(key,val-1);\\n            }\\n        }\\n        return size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        int size = nums.length;\\n        Map<Integer,Integer> remCount = new HashMap<>();\\n        for(int num : nums){\\n            int rem = num % value;\\n            if(num < 0 && rem != 0){\\n                num = -num;\\n                int q = num / value;\\n                rem = (-num) + (value*(q+1));\\n            }\\n            int val = remCount.getOrDefault(rem,0);\\n            remCount.put(rem,val+1);\\n        }\\n        for(int i = 0; i < size; i++){\\n            int key = i % value;\\n            if(remCount.getOrDefault(key,0) == 0){\\n                return i;\\n            }else{\\n                int val = remCount.get(key);\\n                remCount.put(key,val-1);\\n            }\\n        }\\n        return size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316393,
                "title": "go-python-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc findSmallestInteger(nums []int, value int) int {\\n    counter := make(map[int]int)\\n    for i,_ := range(nums){\\n        nums[i]%=value\\n        nums[i]+=value\\n        nums[i]%=value\\n        counter[nums[i]]++\\n    }\\n    n := 0\\n    rounds := 0\\n    for counter[n]>0{\\n        counter[n]-=1\\n        n+=1\\n        if n >= value{\\n            rounds+=1\\n            n%=value\\n        }\\n    }\\n    return rounds*value+n\\n}\\n```\\n```python []\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        for i in range(len(nums)):\\n            nums[i]%=value\\n            nums[i]+=value\\n            nums[i]%=value\\n        \\n        counter = Counter(nums)\\n        n = 0\\n        rounds = 0\\n        while counter[n]>0:\\n            counter[n]-=1\\n            n+=1\\n            if n >= value:\\n                rounds+=1\\n                n%=value\\n        return rounds*value+n\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Hash Table",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```golang []\\nfunc findSmallestInteger(nums []int, value int) int {\\n    counter := make(map[int]int)\\n    for i,_ := range(nums){\\n        nums[i]%=value\\n        nums[i]+=value\\n        nums[i]%=value\\n        counter[nums[i]]++\\n    }\\n    n := 0\\n    rounds := 0\\n    for counter[n]>0{\\n        counter[n]-=1\\n        n+=1\\n        if n >= value{\\n            rounds+=1\\n            n%=value\\n        }\\n    }\\n    return rounds*value+n\\n}\\n```\n```python []\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        for i in range(len(nums)):\\n            nums[i]%=value\\n            nums[i]+=value\\n            nums[i]%=value\\n        \\n        counter = Counter(nums)\\n        n = 0\\n        rounds = 0\\n        while counter[n]>0:\\n            counter[n]-=1\\n            n+=1\\n            if n >= value:\\n                rounds+=1\\n                n%=value\\n        return rounds*value+n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316346,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only have to consider how many numbers there are in each congruence class modulo value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we compute how many numbers there are in each congruence class modulo value. Then we start from 0 and see if the congruence class of each number (including 0 itself) is represented.\\nIf it is, we subtract 1 from the number of representatives (because we have just used up one) and move on. If not, we return the answer, because there is the first gap.\\n\\n# Complexity\\n- Time complexity: $O(n)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(value)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        a=[0]*value\\n        for n in nums:\\n            a[n%value]+=1\\n        i=0\\n        while a[i%value]!=0:\\n            a[i%value]-=1\\n            i+=1\\n        return i   \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        a=[0]*value\\n        for n in nums:\\n            a[n%value]+=1\\n        i=0\\n        while a[i%value]!=0:\\n            a[i%value]-=1\\n            i+=1\\n        return i   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316293,
                "title": "c-map",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int> umap;\\n        int n = nums.size();\\n        for(auto x : nums)\\n            umap[(x%value + value)%value]++;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(umap[i%value] == 0)\\n                return i;\\n            umap[i%value]--;\\n        }\\n        \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        unordered_map<int,int> umap;\\n        int n = nums.size();\\n        for(auto x : nums)\\n            umap[(x%value + value)%value]++;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(umap[i%value] == 0)\\n                return i;\\n            umap[i%value]--;\\n        }\\n        \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316262,
                "title": "c-modulo-arithmetic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy adding or subracting `value` to an `item` we can obtain only \\n\\n```\\nitem mod value, item mod value + value, ..., item mod value + n * value\\n``` \\n\\nso we can group `item`s of `nums` by their mod, produce `item % value, item % value + value` etc. sequences and look for MIX among them \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLinq query followed by MIX computation\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindSmallestInteger(int[] nums, int value) {\\n        var data = nums\\n           .Select(item => (item % value + value) % value)\\n           .GroupBy(item => item)\\n           .SelectMany(group => group.Select((item, index) => item + index * value))\\n           .OrderBy(item => item); \\n\\n        int result = 0;\\n\\n        foreach (var item in data) \\n            if (item == result)\\n                result += 1;\\n            else\\n                break;\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nitem mod value, item mod value + value, ..., item mod value + n * value\\n```\n```\\npublic class Solution {\\n    public int FindSmallestInteger(int[] nums, int value) {\\n        var data = nums\\n           .Select(item => (item % value + value) % value)\\n           .GroupBy(item => item)\\n           .SelectMany(group => group.Select((item, index) => item + index * value))\\n           .OrderBy(item => item); \\n\\n        int result = 0;\\n\\n        foreach (var item in data) \\n            if (item == result)\\n                result += 1;\\n            else\\n                break;\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316246,
                "title": "java-modulus-array",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] remainder = new int[nums.length];\\n        int index = 0;\\n        int mex = 0;\\n        int n = nums.length;\\n        \\n        for (int i : nums) {\\n            if (i < 0 ) {\\n                i %= value;\\n                i += value;\\n            }\\n            remainder[index++] = i % value;\\n        }\\n        \\n        System.out.println(Arrays.toString(remainder));\\n        Arrays.sort(remainder);\\n        for (int i : remainder) {\\n            if (i == mex)\\n                mex += 1;\\n            map.put(i, map.getOrDefault(i , 0) + 1);\\n        }\\n        \\n        if (mex > remainder[n - 1]) {\\n            int rem = mex % value;\\n            while (map.containsKey(rem) && map.get(rem) > 1) {\\n                mex += 1;\\n                map.put(rem, map.get(rem) - 1);\\n                rem = mex % value;\\n                System.out.println(mex);\\n            }\\n        }\\n        \\n        return mex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSmallestInteger(int[] nums, int value) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] remainder = new int[nums.length];\\n        int index = 0;\\n        int mex = 0;\\n        int n = nums.length;\\n        \\n        for (int i : nums) {\\n            if (i < 0 ) {\\n                i %= value;\\n                i += value;\\n            }\\n            remainder[index++] = i % value;\\n        }\\n        \\n        System.out.println(Arrays.toString(remainder));\\n        Arrays.sort(remainder);\\n        for (int i : remainder) {\\n            if (i == mex)\\n                mex += 1;\\n            map.put(i, map.getOrDefault(i , 0) + 1);\\n        }\\n        \\n        if (mex > remainder[n - 1]) {\\n            int rem = mex % value;\\n            while (map.containsKey(rem) && map.get(rem) > 1) {\\n                mex += 1;\\n                map.put(rem, map.get(rem) - 1);\\n                rem = mex % value;\\n                System.out.println(mex);\\n            }\\n        }\\n        \\n        return mex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316156,
                "title": "c-and-modulo-of-negative-number",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n         map<int, int> mp;\\n    int n=nums.size();\\n        int yy=0;\\n    for (int i = 0; i < n; i++) {\\n        mp[((nums[i] % value)+value)%value]++;\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (mp.find(i % value) == mp.end()) {\\n            return i;\\n        }\\n        mp[i % value]--;\\n        if (mp[i % value] == 0){\\n             mp.erase(i % value);\\n        }\\n           \\n    }\\n\\n    return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n         map<int, int> mp;\\n    int n=nums.size();\\n        int yy=0;\\n    for (int i = 0; i < n; i++) {\\n        mp[((nums[i] % value)+value)%value]++;\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (mp.find(i % value) == mp.end()) {\\n            return i;\\n        }\\n        mp[i % value]--;\\n        if (mp[i % value] == 0){\\n             mp.erase(i % value);\\n        }\\n           \\n    }\\n\\n    return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316105,
                "title": "very-intuitive-easy-c-o-n",
                "content": "# Intuition : \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOperation add or subtract gives the intuition of storing modulo of elements and do something with the calculated modulos.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the modulo of every element present in the array(Take care while calculate the modulo of -ve no. --> if a is -ve then it\\'s modulo will be (a % b + b) % b ).\\n2. Store the frequency of modulos.\\n3. Check for every non-negative integer starting from 0 and if any of the number starting from 0 does not exist in the frequency map then simply return it.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq;\\n        for(int i = 0; i < n; i++){\\n            int rem = (nums[i] % value + value) % value;\\n            freq[rem]++;         \\n        }\\n        int i = 0, siz = freq.size(), ans = 0;\\n        while(siz){\\n            if(freq[i] > 0){\\n                freq[i]--;\\n                ans++;\\n            }\\n            else{\\n                break;\\n            }\\n            i = (i+1)%value;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq;\\n        for(int i = 0; i < n; i++){\\n            int rem = (nums[i] % value + value) % value;\\n            freq[rem]++;         \\n        }\\n        int i = 0, siz = freq.size(), ans = 0;\\n        while(siz){\\n            if(freq[i] > 0){\\n                freq[i]--;\\n                ans++;\\n            }\\n            else{\\n                break;\\n            }\\n            i = (i+1)%value;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315982,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Using hashmap brute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O[N]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O[N]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n       vector<int>v;\\n       map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            int diff=(nums[i]-value);\\n            \\n            if((diff%value)<0)\\n            diff=(diff%value)+value;\\n            else\\n                diff=diff%value;\\n            v.push_back(diff);\\n          m[diff]++;\\n        }\\n        \\n        int j=0,c=0;\\n        while(m.find(j)!=m.end()){\\n        if(m[j]>1){\\n            int k=m[j]-1;\\n            m[j+value]=k;\\n        }\\n           \\n           j++;   \\n    \\n        }\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n       vector<int>v;\\n       map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            int diff=(nums[i]-value);\\n            \\n            if((diff%value)<0)\\n            diff=(diff%value)+value;\\n            else\\n                diff=diff%value;\\n            v.push_back(diff);\\n          m[diff]++;\\n        }\\n        \\n        int j=0,c=0;\\n        while(m.find(j)!=m.end()){\\n        if(m[j]>1){\\n            int k=m[j]-1;\\n            m[j+value]=k;\\n        }\\n           \\n           j++;   \\n    \\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315852,
                "title": "beats-100-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> v(value,0);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                if(nums[i]%value==0)  v[nums[i]%value]++;\\n                else\\n                    v[nums[i]%value+value]++;\\n            } \\n            else\\n            v[nums[i]%value]++;\\n        }\\n        int min =INT_MAX,idx=-1,k=0;\\n        for(int i=0;i<value;i++)\\n        {\\n            if(min==v[i])\\n                k++;\\n            if(min>v[i])\\n            {\\n                min=v[i];\\n                idx=i;\\n            }\\n            \\n        }\\n        // cout<<idx;\\n        if(k==value)\\n            return value*min;\\n        return idx+value*v[idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int> v(value,0);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                if(nums[i]%value==0)  v[nums[i]%value]++;\\n                else\\n                    v[nums[i]%value+value]++;\\n            } \\n            else\\n            v[nums[i]%value]++;\\n        }\\n        int min =INT_MAX,idx=-1,k=0;\\n        for(int i=0;i<value;i++)\\n        {\\n            if(min==v[i])\\n                k++;\\n            if(min>v[i])\\n            {\\n                min=v[i];\\n                idx=i;\\n            }\\n            \\n        }\\n        // cout<<idx;\\n        if(k==value)\\n            return value*min;\\n        return idx+value*v[idx];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3315607,
                "title": "shortest-solution-using-modulo-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can apply add and subtract operation any no of times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Take Modulo all numbers by value. \\n- Store their counts in map.\\n- Traverse k from 0 to .... If (k%value) is present in map, decreasee count by 1 and increase k by 1. \\n- If (k%value) is not in map then return k which is required MEX Value.\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        unordered_map <int,int> mp;\\n        for(auto &x: nums)\\n        {\\n            x %= value;\\n            if(x<0) x += value;\\n            mp[x]++;\\n        }\\n        int k = 0; // mex_value\\n        while(1)\\n        {\\n            if(mp[k%value])\\n            {\\n                mp[k%value]--;\\n                k++;\\n            }\\n            else return k;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        unordered_map <int,int> mp;\\n        for(auto &x: nums)\\n        {\\n            x %= value;\\n            if(x<0) x += value;\\n            mp[x]++;\\n        }\\n        int k = 0; // mex_value\\n        while(1)\\n        {\\n            if(mp[k%value])\\n            {\\n                mp[k%value]--;\\n                k++;\\n            }\\n            else return k;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315594,
                "title": "easy-understand-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. there are 10^5 constraints is given so that you can solve this question in O(NlogN).in this problem we observe that if a number is already generated then why we can use same number to make answer insted of this we make a differnt number .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.  First we find modulo of all the number but in negative number present then you need to first make it positive and find modulo\\n\\n2. after finding we use map because we want to cheak if number is present then why we generate again instead of this we want generate new number \\n\\n3. for generating a new number we use frequency of modulo and make a new number like example [1,7,13,6,8] value= 5 .In this 6%5 is 1 but 1 is already present in array count of 1 is 1 mp[1]=1 so \\n(value*(count)+(6%5) )=6 so new generated number is 6 and mp[1]++ so again 6 is not generate.**\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size();\\n        unordered_map<int,int>mp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int x=nums[i];\\n            \\n            if(nums[i]<0)\\n            {\\n                int y=abs(x)/value;\\n                 if(y*value==abs(x))\\n                 {\\n                     x=0;\\n                 }\\n                else\\n                {\\n                    x=x+(y+1)*value;\\n                }\\n                 int temp=mp[x];\\n                mp[x]++;\\n                if(temp==0)\\n                {\\n                    continue;\\n                }\\n                mp[value*(temp)+x]++;\\n                \\n                \\n            }\\n            else\\n            {\\n                x=x%value;\\n                \\n                int temp=mp[x];\\n                \\n                  mp[x]++;\\n               \\n                \\n                if(temp==0)\\n                {\\n                    \\n                    \\n                    continue;\\n                }\\n               \\n                \\n                mp[value*(temp)+x]++;\\n                \\n            }\\n            \\n            \\n            \\n        }\\n        int ans=0;\\n        \\n        for(int i=0;i<=1e5;i++)\\n        {\\n            if(mp[i]==0)\\n            {\\n                ans=i;\\n                break;\\n            }\\n            \\n        }\\n     \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n=nums.size();\\n        unordered_map<int,int>mp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int x=nums[i];\\n            \\n            if(nums[i]<0)\\n            {\\n                int y=abs(x)/value;\\n                 if(y*value==abs(x))\\n                 {\\n                     x=0;\\n                 }\\n                else\\n                {\\n                    x=x+(y+1)*value;\\n                }\\n                 int temp=mp[x];\\n                mp[x]++;\\n                if(temp==0)\\n                {\\n                    continue;\\n                }\\n                mp[value*(temp)+x]++;\\n                \\n                \\n            }\\n            else\\n            {\\n                x=x%value;\\n                \\n                int temp=mp[x];\\n                \\n                  mp[x]++;\\n               \\n                \\n                if(temp==0)\\n                {\\n                    \\n                    \\n                    continue;\\n                }\\n               \\n                \\n                mp[value*(temp)+x]++;\\n                \\n            }\\n            \\n            \\n            \\n        }\\n        int ans=0;\\n        \\n        for(int i=0;i<=1e5;i++)\\n        {\\n            if(mp[i]==0)\\n            {\\n                ans=i;\\n                break;\\n            }\\n            \\n        }\\n     \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315571,
                "title": "count-of-remainders-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        unordered_map<int, int> m;\\n        unordered_set<int> s;\\n        \\n        for(auto num : nums){\\n            m[ ( (num%value) + value ) % value ]++;   // Cnt of Remainder\\n        }\\n        \\n        for(auto [num, cnt] : m){  // adding/subtracting \\'value\\', this nums can be made.\\n            for(int i=0; i<cnt; i++)    s.insert( num + (i*value) );\\n        }\\n        \\n        int mex = 0;\\n        for(mex; mex <= n; mex++){\\n            if(s.count(mex) == 0)   break;\\n        }\\n        \\n        return mex;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        int n = nums.size();\\n        unordered_map<int, int> m;\\n        unordered_set<int> s;\\n        \\n        for(auto num : nums){\\n            m[ ( (num%value) + value ) % value ]++;   // Cnt of Remainder\\n        }\\n        \\n        for(auto [num, cnt] : m){  // adding/subtracting \\'value\\', this nums can be made.\\n            for(int i=0; i<cnt; i++)    s.insert( num + (i*value) );\\n        }\\n        \\n        int mex = 0;\\n        for(mex; mex <= n; mex++){\\n            if(s.count(mex) == 0)   break;\\n        }\\n        \\n        return mex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315543,
                "title": "time-complexity-100-c-mod",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int>mod(value,0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%value<0)\\n            {\\n                mod[(nums[i])%value+value]++;\\n            }\\n            else mod[nums[i]%value]++;\\n        }\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n            int m=i%value;\\n            mod[m]--;\\n            if(mod[m]<0)return i;\\n        }\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        vector<int>mod(value,0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%value<0)\\n            {\\n                mod[(nums[i])%value+value]++;\\n            }\\n            else mod[nums[i]%value]++;\\n        }\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n            int m=i%value;\\n            mod[m]--;\\n            if(mod[m]<0)return i;\\n        }\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315486,
                "title": "scala-mutable-map-for-modules",
                "content": "\\n# Code\\n```\\nobject Solution {\\n  def findSmallestInteger(nums: Array[Int], value: Int): Int = {\\n    val modules = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n    nums.foreach(i => modules(math.floorMod(i, value)) += 1)\\n    val mexs = LazyList.from(0).dropWhile { i =>\\n      val ind = i % value\\n      modules(ind) -= 1\\n      modules(ind) >= 0\\n    }\\n    mexs.head\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def findSmallestInteger(nums: Array[Int], value: Int): Int = {\\n    val modules = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n    nums.foreach(i => modules(math.floorMod(i, value)) += 1)\\n    val mexs = LazyList.from(0).dropWhile { i =>\\n      val ind = i % value\\n      modules(ind) -= 1\\n      modules(ind) >= 0\\n    }\\n    mexs.head\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3315470,
                "title": "c-count-frequency-of-mod",
                "content": "```\\n\\tpublic int FindSmallestInteger(int[] nums, int value) {\\n        var freq = new Dictionary<int, int>();\\n        var lists = new List<int>();\\n        foreach (var num in nums) {\\n            var mod = num % value;\\n            if (mod < 0) mod += value;\\n            if (!freq.ContainsKey(mod))\\n                freq[mod] = 0;\\n            freq[mod]++;\\n        }\\n        foreach (var num in freq.Keys) {\\n            var count = freq[num];\\n            for (int i = 0; i < count; i++)\\n                lists.Add(num + value * i);\\n        }\\n        lists.Sort();\\n        for (int i = 0; i < lists.Count; i++) {\\n            if (i == lists[i]) continue;\\n            return i;\\n        }\\n        return lists.Count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int FindSmallestInteger(int[] nums, int value) {\\n        var freq = new Dictionary<int, int>();\\n        var lists = new List<int>();\\n        foreach (var num in nums) {\\n            var mod = num % value;\\n            if (mod < 0) mod += value;\\n            if (!freq.ContainsKey(mod))\\n                freq[mod] = 0;\\n            freq[mod]++;\\n        }\\n        foreach (var num in freq.Keys) {\\n            var count = freq[num];\\n            for (int i = 0; i < count; i++)\\n                lists.Add(num + value * i);\\n        }\\n        lists.Sort();\\n        for (int i = 0; i < lists.Count; i++) {\\n            if (i == lists[i]) continue;\\n            return i;\\n        }\\n        return lists.Count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3315459,
                "title": "cpp-easy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& a, int k) {\\n      int n = a.size();\\n      vector<int> dp(k, 0);\\n      for(int i=0; i<n; i++){\\n        if(a[i]%k >= 0){\\n          dp[a[i]%k]++;\\n        }\\n        else{\\n          dp[k+a[i]%k]++;\\n        }\\n      }\\n      for(int i=0; i<n; i++){\\n        if(!dp[i%k]){\\n          return i;\\n        }\\n        else{\\n          dp[i%k]--;\\n        }\\n      }\\n      return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& a, int k) {\\n      int n = a.size();\\n      vector<int> dp(k, 0);\\n      for(int i=0; i<n; i++){\\n        if(a[i]%k >= 0){\\n          dp[a[i]%k]++;\\n        }\\n        else{\\n          dp[k+a[i]%k]++;\\n        }\\n      }\\n      for(int i=0; i<n; i++){\\n        if(!dp[i%k]){\\n          return i;\\n        }\\n        else{\\n          dp[i%k]--;\\n        }\\n      }\\n      return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315374,
                "title": "very-short-solution-easy-to-understand",
                "content": "### Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        v, ans = defaultdict(int), 0\\n        for i in nums: v[i%value] += 1\\n        while v[ans%value]:\\n            v[ans%value]-=1\\n            ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        v, ans = defaultdict(int), 0\\n        for i in nums: v[i%value] += 1\\n        while v[ans%value]:\\n            v[ans%value]-=1\\n            ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315325,
                "title": "count-and-update-remainder",
                "content": "Count $${num}\\\\mod{value}$$.\\nFor MEX from 0 to n-1, check if $${MEX}\\\\mod{value}$$ is still available in  count. \\nIf out of stock, return the current MEX.\\nIf everything match, return n.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        ct = Counter([x % value for x in nums])\\n        for i in range(len(nums)):\\n            x = i % value\\n            if ct[x]:\\n                ct[x] -= 1\\n            else:\\n                return i\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        ct = Counter([x % value for x in nums])\\n        for i in range(len(nums)):\\n            x = i % value\\n            if ct[x]:\\n                ct[x] -= 1\\n            else:\\n                return i\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315303,
                "title": "simple-solution-hash-map-o-n",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        map<int,int>mp1;\\n        for(auto it : nums){\\n            if(it%value<0){\\n                mp1[value + it%value]++;\\n            }\\n            else{\\n                mp1[it%value]++;\\n            }\\n        }\\n\\n        int N = 1e5+1;\\n        for(int i=0;i<N;i++){\\n            if(mp1[i]!=0){\\n                mp1[i]--;\\n            }\\n            else if(mp1[i%value]!=0){\\n                mp1[i%value]--;\\n            }\\n\\n            else{\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n# upvote if you like\\'s the Solution HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSmallestInteger(vector<int>& nums, int value) {\\n        map<int,int>mp1;\\n        for(auto it : nums){\\n            if(it%value<0){\\n                mp1[value + it%value]++;\\n            }\\n            else{\\n                mp1[it%value]++;\\n            }\\n        }\\n\\n        int N = 1e5+1;\\n        for(int i=0;i<N;i++){\\n            if(mp1[i]!=0){\\n                mp1[i]--;\\n            }\\n            else if(mp1[i%value]!=0){\\n                mp1[i%value]--;\\n            }\\n\\n            else{\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1837280,
                "content": [
                    {
                        "username": "d3g3n",
                        "content": "Feel like this could easily be a hard."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[3,0,3,2,4,2,1,1,0,4]\\n5\\nWhat will be the output of this test case anyone?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "```\n3     => 3\n0     => 0\n3 + 5 => 8\n2     => 2\n4     => 4\n2 + 5 => 7\n1     => 1\n1 + 5 => 6\n0 + 5 => 5\n4 + 5 => 9\n```\nhence maximum MEX = 10"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "the array should have unique value so just add 5 to all the repeating value you will see we all the value form 0 to 9 so MEX would be 10"
                    },
                    {
                        "username": "alisink",
                        "content": "[@ma5termiind](/ma5termiind) how?"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "--> 10\\n"
                    },
                    {
                        "username": "Jame98",
                        "content": "a%b , as long as operand b is positive python always produces positive number .https://stackoverflow.com/a/67139303/14998207 best  explanation ever, i found this helpul."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Smallest Missing Non-negative Integer After Operations...not a single operation i can ale to do...🙄🙄"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "i think question can be more clear about the fact that values can not repeat. otherwise question was quite good."
                    },
                    {
                        "username": "Anurag-S1ngh",
                        "content": "pls anyone explain this question to me.\\n"
                    }
                ]
            },
            {
                "id": 1840616,
                "content": [
                    {
                        "username": "d3g3n",
                        "content": "Feel like this could easily be a hard."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[3,0,3,2,4,2,1,1,0,4]\\n5\\nWhat will be the output of this test case anyone?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "```\n3     => 3\n0     => 0\n3 + 5 => 8\n2     => 2\n4     => 4\n2 + 5 => 7\n1     => 1\n1 + 5 => 6\n0 + 5 => 5\n4 + 5 => 9\n```\nhence maximum MEX = 10"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "the array should have unique value so just add 5 to all the repeating value you will see we all the value form 0 to 9 so MEX would be 10"
                    },
                    {
                        "username": "alisink",
                        "content": "[@ma5termiind](/ma5termiind) how?"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "--> 10\\n"
                    },
                    {
                        "username": "Jame98",
                        "content": "a%b , as long as operand b is positive python always produces positive number .https://stackoverflow.com/a/67139303/14998207 best  explanation ever, i found this helpul."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Smallest Missing Non-negative Integer After Operations...not a single operation i can ale to do...🙄🙄"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "i think question can be more clear about the fact that values can not repeat. otherwise question was quite good."
                    },
                    {
                        "username": "Anurag-S1ngh",
                        "content": "pls anyone explain this question to me.\\n"
                    }
                ]
            },
            {
                "id": 1837092,
                "content": [
                    {
                        "username": "d3g3n",
                        "content": "Feel like this could easily be a hard."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[3,0,3,2,4,2,1,1,0,4]\\n5\\nWhat will be the output of this test case anyone?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "```\n3     => 3\n0     => 0\n3 + 5 => 8\n2     => 2\n4     => 4\n2 + 5 => 7\n1     => 1\n1 + 5 => 6\n0 + 5 => 5\n4 + 5 => 9\n```\nhence maximum MEX = 10"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "the array should have unique value so just add 5 to all the repeating value you will see we all the value form 0 to 9 so MEX would be 10"
                    },
                    {
                        "username": "alisink",
                        "content": "[@ma5termiind](/ma5termiind) how?"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "--> 10\\n"
                    },
                    {
                        "username": "Jame98",
                        "content": "a%b , as long as operand b is positive python always produces positive number .https://stackoverflow.com/a/67139303/14998207 best  explanation ever, i found this helpul."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Smallest Missing Non-negative Integer After Operations...not a single operation i can ale to do...🙄🙄"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "i think question can be more clear about the fact that values can not repeat. otherwise question was quite good."
                    },
                    {
                        "username": "Anurag-S1ngh",
                        "content": "pls anyone explain this question to me.\\n"
                    }
                ]
            },
            {
                "id": 1837029,
                "content": [
                    {
                        "username": "d3g3n",
                        "content": "Feel like this could easily be a hard."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[3,0,3,2,4,2,1,1,0,4]\\n5\\nWhat will be the output of this test case anyone?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "```\n3     => 3\n0     => 0\n3 + 5 => 8\n2     => 2\n4     => 4\n2 + 5 => 7\n1     => 1\n1 + 5 => 6\n0 + 5 => 5\n4 + 5 => 9\n```\nhence maximum MEX = 10"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "the array should have unique value so just add 5 to all the repeating value you will see we all the value form 0 to 9 so MEX would be 10"
                    },
                    {
                        "username": "alisink",
                        "content": "[@ma5termiind](/ma5termiind) how?"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "--> 10\\n"
                    },
                    {
                        "username": "Jame98",
                        "content": "a%b , as long as operand b is positive python always produces positive number .https://stackoverflow.com/a/67139303/14998207 best  explanation ever, i found this helpul."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Smallest Missing Non-negative Integer After Operations...not a single operation i can ale to do...🙄🙄"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "i think question can be more clear about the fact that values can not repeat. otherwise question was quite good."
                    },
                    {
                        "username": "Anurag-S1ngh",
                        "content": "pls anyone explain this question to me.\\n"
                    }
                ]
            },
            {
                "id": 1941453,
                "content": [
                    {
                        "username": "d3g3n",
                        "content": "Feel like this could easily be a hard."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[3,0,3,2,4,2,1,1,0,4]\\n5\\nWhat will be the output of this test case anyone?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "```\n3     => 3\n0     => 0\n3 + 5 => 8\n2     => 2\n4     => 4\n2 + 5 => 7\n1     => 1\n1 + 5 => 6\n0 + 5 => 5\n4 + 5 => 9\n```\nhence maximum MEX = 10"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "the array should have unique value so just add 5 to all the repeating value you will see we all the value form 0 to 9 so MEX would be 10"
                    },
                    {
                        "username": "alisink",
                        "content": "[@ma5termiind](/ma5termiind) how?"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "--> 10\\n"
                    },
                    {
                        "username": "Jame98",
                        "content": "a%b , as long as operand b is positive python always produces positive number .https://stackoverflow.com/a/67139303/14998207 best  explanation ever, i found this helpul."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Smallest Missing Non-negative Integer After Operations...not a single operation i can ale to do...🙄🙄"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "i think question can be more clear about the fact that values can not repeat. otherwise question was quite good."
                    },
                    {
                        "username": "Anurag-S1ngh",
                        "content": "pls anyone explain this question to me.\\n"
                    }
                ]
            },
            {
                "id": 1855576,
                "content": [
                    {
                        "username": "d3g3n",
                        "content": "Feel like this could easily be a hard."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[3,0,3,2,4,2,1,1,0,4]\\n5\\nWhat will be the output of this test case anyone?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "```\n3     => 3\n0     => 0\n3 + 5 => 8\n2     => 2\n4     => 4\n2 + 5 => 7\n1     => 1\n1 + 5 => 6\n0 + 5 => 5\n4 + 5 => 9\n```\nhence maximum MEX = 10"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "the array should have unique value so just add 5 to all the repeating value you will see we all the value form 0 to 9 so MEX would be 10"
                    },
                    {
                        "username": "alisink",
                        "content": "[@ma5termiind](/ma5termiind) how?"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "--> 10\\n"
                    },
                    {
                        "username": "Jame98",
                        "content": "a%b , as long as operand b is positive python always produces positive number .https://stackoverflow.com/a/67139303/14998207 best  explanation ever, i found this helpul."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Smallest Missing Non-negative Integer After Operations...not a single operation i can ale to do...🙄🙄"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "i think question can be more clear about the fact that values can not repeat. otherwise question was quite good."
                    },
                    {
                        "username": "Anurag-S1ngh",
                        "content": "pls anyone explain this question to me.\\n"
                    }
                ]
            }
        ]
    }
]