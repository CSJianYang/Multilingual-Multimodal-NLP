[
    {
        "title": "Max Sum of Rectangle No Larger Than K",
        "question_content": "Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\nIt is guaranteed that there will be a rectangle with a sum no larger than k.\n&nbsp;\nExample 1:\n\nInput: matrix = [[1,0,1],[0,-2,3]], k = 2\nOutput: 2\nExplanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).\n\nExample 2:\n\nInput: matrix = [[2,2,-1]], k = 3\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 100\n\t-100 <= matrix[i][j] <= 100\n\t-105 <= k <= 105\n\n&nbsp;\nFollow up: What if the number of rows is much larger than the number of columns?",
        "solutions": [
            {
                "id": 83599,
                "title": "accepted-c-codes-with-explanation-and-references",
                "content": "The naive solution is brute-force, which is O((mn)^2). In order to be more efficient, I tried something similar to Kadane's algorithm. The only difference is that here we have upper bound restriction K. Here's the easily understanding video link for the problem \"find the max sum rectangle in 2D array\": [Maximum Sum Rectangular Submatrix in Matrix dynamic programming/2D kadane][1] (Trust me, it's really easy and straightforward). \\n\\nOnce you are clear how to solve the above problem, the next step is to find the max sum no more than K in an array. This can be done within O(nlogn), and you can refer to this article: [max subarray sum no more than k][2].\\n\\nFor the solution below, I assume that the number of rows is larger than the number of columns. Thus in general time complexity is O[min(m,n)^2 * max(m,n) * log(max(m,n))], space O(max(m, n)).\\n\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if (matrix.empty()) return 0;\\n        int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;\\n        for (int l = 0; l < col; ++l) {\\n            vector<int> sums(row, 0);\\n            for (int r = l; r < col; ++r) {\\n                for (int i = 0; i < row; ++i) {\\n                    sums[i] += matrix[i][r];\\n                }\\n                \\n                // Find the max subarray no more than K \\n                set<int> accuSet;\\n                accuSet.insert(0);\\n                int curSum = 0, curMax = INT_MIN;\\n                for (int sum : sums) {\\n                    curSum += sum;\\n                    set<int>::iterator it = accuSet.lower_bound(curSum - k);\\n                    if (it != accuSet.end()) curMax = std::max(curMax, curSum - *it);\\n                    accuSet.insert(curSum);\\n                }\\n                res = std::max(res, curMax);\\n            }\\n        }\\n        return res;\\n    }\\n\\n  [1]: https://www.youtube.com/watch?v=yCQN096CwWM\\n  [2]: https://www.quora.com/Given-an-array-of-integers-A-and-an-integer-k-find-a-subarray-that-contains-the-largest-sum-subject-to-a-constraint-that-the-sum-is-less-than-k",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "The naive solution is brute-force, which is O((mn)^2). In order to be more efficient, I tried something similar to Kadane's algorithm. The only difference is that here we have upper bound restriction K. Here's the easily understanding video link for the problem \"find the max sum rectangle in 2D array\": [Maximum Sum Rectangular Submatrix in Matrix dynamic programming/2D kadane][1] (Trust me, it's really easy and straightforward). \\n\\nOnce you are clear how to solve the above problem, the next step is to find the max sum no more than K in an array. This can be done within O(nlogn), and you can refer to this article: [max subarray sum no more than k][2].\\n\\nFor the solution below, I assume that the number of rows is larger than the number of columns. Thus in general time complexity is O[min(m,n)^2 * max(m,n) * log(max(m,n))], space O(max(m, n)).\\n\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if (matrix.empty()) return 0;\\n        int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;\\n        for (int l = 0; l < col; ++l) {\\n            vector<int> sums(row, 0);\\n            for (int r = l; r < col; ++r) {\\n                for (int i = 0; i < row; ++i) {\\n                    sums[i] += matrix[i][r];\\n                }\\n                \\n                // Find the max subarray no more than K \\n                set<int> accuSet;\\n                accuSet.insert(0);\\n                int curSum = 0, curMax = INT_MIN;\\n                for (int sum : sums) {\\n                    curSum += sum;\\n                    set<int>::iterator it = accuSet.lower_bound(curSum - k);\\n                    if (it != accuSet.end()) curMax = std::max(curMax, curSum - *it);\\n                    accuSet.insert(curSum);\\n                }\\n                res = std::max(res, curMax);\\n            }\\n        }\\n        return res;\\n    }\\n\\n  [1]: https://www.youtube.com/watch?v=yCQN096CwWM\\n  [2]: https://www.quora.com/Given-an-array-of-integers-A-and-an-integer-k-find-a-subarray-that-contains-the-largest-sum-subject-to-a-constraint-that-the-sum-is-less-than-k",
                "codeTag": "Unknown"
            },
            {
                "id": 1313721,
                "title": "java-python-sub-problem-max-sum-of-subarray-no-larger-than-k-clean-concise",
                "content": "**Idea**\\n- Firstly, let solve this sub problem **Max Sum of Subarray No Larger Than K**, which is \"Given an array of N integers, find the maximum sum of subarray which is no larger than K\".\\n\\t- Iterating index `i` from left to right.\\n\\t- Calculate prefixSum so far, let name it `right`\\n\\t- Try to find the `left` prefixSum so that `right - left <= k` => `left >= right - k`.\\n\\t- We can use `TreeSet` (implemented as BST), and use `ceiling(x)` to find the least key greater than or equal to the given `x`. So `left = bst.ceiling(right-k)`.\\n\\t- If we found a valid `left`, then we update the answer by `ans = max(ans, right - left)`.\\n- Then we try all possible pairs of `(r1, r2)` of rows in the matrix, where `0 <= r1 <= r2 < m`. Make an array of `n` integer, where `arr[c] = sum(matrix[r1][c]...matrix[r2][c])`, then solve that sub problem.\\n\\n![image](https://assets.leetcode.com/users/images/c9e51580-0e29-4125-a4d2-2c921c72aea8_1625336085.6260538.png)\\n\\n**Similar problems**\\n- [1. Two Sum](https://leetcode.com/problems/two-sum/) -> Check HashMap solution, which uses idea of calculate `right` prefixSum so far and looking for `left` prefixSum in the HashMap.\\n- [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/) -> Solve sub-matrix problems by solving sub-array problems.\\n\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/FawcNpny/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M^2 * N * logN)`, where `M <= 100` is number of rows, `N <= 100` is number of columns in the matrix.\\n- Space: `O(N)`\\n\\nIf you think this post is useful, I\\'m happy if you **give a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "solutionTags": [],
                "code": "**Idea**\\n- Firstly, let solve this sub problem **Max Sum of Subarray No Larger Than K**, which is \"Given an array of N integers, find the maximum sum of subarray which is no larger than K\".\\n\\t- Iterating index `i` from left to right.\\n\\t- Calculate prefixSum so far, let name it `right`\\n\\t- Try to find the `left` prefixSum so that `right - left <= k` => `left >= right - k`.\\n\\t- We can use `TreeSet` (implemented as BST), and use `ceiling(x)` to find the least key greater than or equal to the given `x`. So `left = bst.ceiling(right-k)`.\\n\\t- If we found a valid `left`, then we update the answer by `ans = max(ans, right - left)`.\\n- Then we try all possible pairs of `(r1, r2)` of rows in the matrix, where `0 <= r1 <= r2 < m`. Make an array of `n` integer, where `arr[c] = sum(matrix[r1][c]...matrix[r2][c])`, then solve that sub problem.\\n\\n![image](https://assets.leetcode.com/users/images/c9e51580-0e29-4125-a4d2-2c921c72aea8_1625336085.6260538.png)\\n\\n**Similar problems**\\n- [1. Two Sum](https://leetcode.com/problems/two-sum/) -> Check HashMap solution, which uses idea of calculate `right` prefixSum so far and looking for `left` prefixSum in the HashMap.\\n- [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/) -> Solve sub-matrix problems by solving sub-array problems.\\n\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/FawcNpny/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M^2 * N * logN)`, where `M <= 100` is number of rows, `N <= 100` is number of columns in the matrix.\\n- Space: `O(N)`\\n\\nIf you think this post is useful, I\\'m happy if you **give a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 851448,
                "title": "c-from-800-ms-to-50-ms",
                "content": "#### Intuition\\nPersonal observation: we spend all this time learning advanced data structures and algorithm. But the hardest problems seem to revolve around simple arrays and strings.\\n\\nThis is an interesting question that combines two (hard) subproblems:\\n1. Maximum Sum Rectangle, similar problems:\\n\\t- [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)\\n2. Max Subarray Sum Equals K; similar problems:\\n\\t- [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\t- [862. Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/)\\n\\nFor the first subproblem, the solution is to accumulate the sum of each row between columns `l` and `r`. Then, we can use the Kadane\\'s algorithm to find the maximum sum subarray for all those columns. Search for the Maximum Sum Rectangle problem on Youtube for video explanations.\\n\\nNow, we are not looking for just the maximum sum, but maximum sum less than `k`. You may be tempted to try a sliding window technique here, but the problem is that we can have negative numbers. For problem #560, we used a hash set to find a sum that equals to `k`. Here, we can use an ordered set and binary-search for a complement value. \\n\\n#### Base Solution\\nThis is the shortest solution, and it\\'s accepted with 800 ms runtime. \\n```cpp\\nint maxSumSubmatrix(vector<vector<int>>& m, int k) {\\n    int res = INT_MIN, rows = m.size(), cols = m[0].size();\\n    for (int l = 0; l < cols; ++l) {\\n        vector<int> sums(rows);\\n        for (int r = l; r < cols; ++r) {\\n            for (int i = 0; i < rows; ++i) \\n                sums[i] += m[i][r];\\n            set<int> s = {0};\\n            int run_sum = 0;\\n            for (int sum : sums) {\\n                run_sum += sum;\\n                auto it = s.lower_bound(run_sum - k);\\n                if (it != end(s))\\n                    res = max(res, run_sum - *it);\\n                s.insert(run_sum);\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```\\n#### Optimization: Add Kadane\\nWe could add few optimizations: e.g. exit early if we found a sum that is equals to `k`. We could also check whether number of rows is less than number of columns, and flip the dimensions. In addition, we can precompute the prefix sum in the matrix, instead of creating and populating the `sums` array.\\n\\nHowever, the most noticeable optimization is to go back to the Kadane\\'s algorithm! We can compute the maximum rectangle sum in O(n). If the maximum sum rectangle sum is less or equal than `k`, we can skip the binary search phase completely. This improves the runtime from 800 ms to 50 ms.\\n\\n```cpp\\nint maxSumSubmatrix(vector<vector<int>>& m, int k) {\\n    int res = INT_MIN, rows = m.size(), cols = m[0].size();\\n    for (int l = 0; l < cols; ++l) {\\n        vector<int> sums(rows);\\n        for (int r = l; r < cols; ++r) {\\n            int kadane = 0, max_kadane = INT_MIN;\\n            for (int i = 0; i < rows; ++i) {\\n                sums[i] += m[i][r];\\n                kadane = max(kadane + sums[i], sums[i]);\\n                max_kadane = max(max_kadane, kadane);\\n            }\\n            if (max_kadane <= k) {\\n                res = max(res, max_kadane);\\n                continue;\\n            }\\n            set<int> s = {0};\\n            int run_sum = 0;\\n            for (int sum : sums) {\\n                run_sum += sum;\\n                auto it = s.lower_bound(run_sum - k);\\n                if (it != end(s))\\n                    res = max(res, run_sum - *it);\\n                s.insert(run_sum);\\n            }\\n        }\\n    }\\n    return res;\\n}  \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxSumSubmatrix(vector<vector<int>>& m, int k) {\\n    int res = INT_MIN, rows = m.size(), cols = m[0].size();\\n    for (int l = 0; l < cols; ++l) {\\n        vector<int> sums(rows);\\n        for (int r = l; r < cols; ++r) {\\n            for (int i = 0; i < rows; ++i) \\n                sums[i] += m[i][r];\\n            set<int> s = {0};\\n            int run_sum = 0;\\n            for (int sum : sums) {\\n                run_sum += sum;\\n                auto it = s.lower_bound(run_sum - k);\\n                if (it != end(s))\\n                    res = max(res, run_sum - *it);\\n                s.insert(run_sum);\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint maxSumSubmatrix(vector<vector<int>>& m, int k) {\\n    int res = INT_MIN, rows = m.size(), cols = m[0].size();\\n    for (int l = 0; l < cols; ++l) {\\n        vector<int> sums(rows);\\n        for (int r = l; r < cols; ++r) {\\n            int kadane = 0, max_kadane = INT_MIN;\\n            for (int i = 0; i < rows; ++i) {\\n                sums[i] += m[i][r];\\n                kadane = max(kadane + sums[i], sums[i]);\\n                max_kadane = max(max_kadane, kadane);\\n            }\\n            if (max_kadane <= k) {\\n                res = max(res, max_kadane);\\n                continue;\\n            }\\n            set<int> s = {0};\\n            int run_sum = 0;\\n            for (int sum : sums) {\\n                run_sum += sum;\\n                auto it = s.lower_bound(run_sum - k);\\n                if (it != end(s))\\n                    res = max(res, run_sum - *it);\\n                s.insert(run_sum);\\n            }\\n        }\\n    }\\n    return res;\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 83597,
                "title": "java-binary-search-solution-time-complexity-min-m-n-2-max-m-n-log-max-m-n",
                "content": "\\n    /* first  consider the situation matrix is 1D\\n        we can save every sum of 0~i(0<=i<len) and binary search previous sum to find \\n        possible result for every index, time complexity is O(NlogN).\\n        so in 2D matrix, we can sum up all values from row i to row j and create a 1D array \\n        to use 1D array solution.\\n        If col number is less than row number, we can sum up all values from col i to col j \\n        then use 1D array solution.\\n    */\\n    public int maxSumSubmatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        if(row==0)return 0;\\n        int col = matrix[0].length;\\n        int m = Math.min(row,col);\\n        int n = Math.max(row,col);\\n        //indicating sum up in every row or every column\\n        boolean colIsBig = col>row;\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0;i<m;i++){\\n            int[] array = new int[n];\\n            // sum from row j to row i\\n            for(int j = i;j>=0;j--){\\n                int val = 0;\\n                TreeSet<Integer> set = new TreeSet<Integer>();\\n                set.add(0);\\n                //traverse every column/row and sum up\\n                for(int k = 0;k<n;k++){\\n                    array[k]=array[k]+(colIsBig?matrix[j][k]:matrix[k][j]);\\n                    val = val + array[k];\\n                    //use  TreeMap to binary search previous sum to get possible result \\n                    Integer subres = set.ceiling(val-target);\\n                    if(null!=subres){\\n                        res=Math.max(res,val-subres);\\n                    }\\n                    set.add(val);\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\n    /* first  consider the situation matrix is 1D\\n        we can save every sum of 0~i(0<=i<len) and binary search previous sum to find \\n        possible result for every index, time complexity is O(NlogN).\\n        so in 2D matrix, we can sum up all values from row i to row j and create a 1D array \\n        to use 1D array solution.\\n        If col number is less than row number, we can sum up all values from col i to col j \\n        then use 1D array solution.\\n    */\\n    public int maxSumSubmatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        if(row==0)return 0;\\n        int col = matrix[0].length;\\n        int m = Math.min(row,col);\\n        int n = Math.max(row,col);\\n        //indicating sum up in every row or every column\\n        boolean colIsBig = col>row;\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0;i<m;i++){\\n            int[] array = new int[n];\\n            // sum from row j to row i\\n            for(int j = i;j>=0;j--){\\n                int val = 0;\\n                TreeSet<Integer> set = new TreeSet<Integer>();\\n                set.add(0);\\n                //traverse every column/row and sum up\\n                for(int k = 0;k<n;k++){\\n                    array[k]=array[k]+(colIsBig?matrix[j][k]:matrix[k][j]);\\n                    val = val + array[k];\\n                    //use  TreeMap to binary search previous sum to get possible result \\n                    Integer subres = set.ceiling(val-target);\\n                    if(null!=subres){\\n                        res=Math.max(res,val-subres);\\n                    }\\n                    set.add(val);\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 445540,
                "title": "python-bisect-solution-960ms-beat-71-25",
                "content": "Please see and vote for my solution for these similar problems.\\n[560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/discuss/344431/Simple-Python-DP-solution)\\n[974. Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/344436/Simple-Python-DP-solution)\\n[325. Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/discuss/344432/Simple-Python-DP-solution)\\n[1074. Number of Submatrices That Sum to Target](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/344440/Simple-Python-DP-solution)\\n[363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/445540/Python-bisect-solution-(960ms-beat-71.25))\\n\\nFor each row, calculate the prefix sum. For each pair of columns, calculate the sum of rows.\\nNow this problem is changed to a 1D problem: max subarray sum no more than k.\\n```\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        def maxSumSubarray(arr):\\n            sub_s_max = float(\\'-inf\\')\\n            s_curr = 0\\n            prefix_sums = [float(\\'inf\\')]\\n            for x in arr:\\n                bisect.insort(prefix_sums, s_curr)\\n                s_curr += x\\n                i = bisect.bisect_left(prefix_sums, s_curr - k)\\n                sub_s_max = max(sub_s_max, s_curr - prefix_sums[i])\\n            return sub_s_max\\n        \\n        m, n = len(matrix), len(matrix[0])\\n        for x in range(m):\\n            for y in range(n - 1):\\n                matrix[x][y+1] += matrix[x][y]\\n        res = float(\\'-inf\\')\\n        for y1 in range(n):\\n            for y2 in range(y1, n):\\n                arr = [matrix[x][y2] - (matrix[x][y1-1] if y1 > 0 else 0) for x in range(m)]\\n                res = max(res, maxSumSubarray(arr))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        def maxSumSubarray(arr):\\n            sub_s_max = float(\\'-inf\\')\\n            s_curr = 0\\n            prefix_sums = [float(\\'inf\\')]\\n            for x in arr:\\n                bisect.insort(prefix_sums, s_curr)\\n                s_curr += x\\n                i = bisect.bisect_left(prefix_sums, s_curr - k)\\n                sub_s_max = max(sub_s_max, s_curr - prefix_sums[i])\\n            return sub_s_max\\n        \\n        m, n = len(matrix), len(matrix[0])\\n        for x in range(m):\\n            for y in range(n - 1):\\n                matrix[x][y+1] += matrix[x][y]\\n        res = float(\\'-inf\\')\\n        for y1 in range(n):\\n            for y2 in range(y1, n):\\n                arr = [matrix[x][y2] - (matrix[x][y1-1] if y1 > 0 else 0) for x in range(m)]\\n                res = max(res, maxSumSubarray(arr))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 469544,
                "title": "simple-c-prefix-sum-solution-w-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    // The Core Idea Behind This Problem:\\n    // Let\\'s first consider the 1 dimensional case, and then we can extrapolate to the 2-dimensional case of the problem\\n    // Let\\'s say we have an array [-3, 6, -2], and we need to find the greatest contiguous subsequence sum <= k=2\\n    // One approach which may immediately jump to mind is Kadane\\'s algorithm.\\n    // However, this cannot work for the simple reason that we cannot find the next greatest subsequence sum <= k=2 simply from the previous result.\\n    // This is best illustrated looking at [-3, 6, -2]. \\n    // Firstly, maxSum = -3\\n    // However, when we reach 6, what do we do? We can choose to take 6 on its own, however this exceeds k=2.\\n    // We can also take -3+6, however, this is less than 6 on its own (does not guarantee a maximum), and it also exceeds k. There is no reasonable course\\n\\t// of action to take in a case like this to guarantee that the maximum BOUNDED \\n\\t// contiguous subarray sum can be found simply by looking at the previous result.\\n    // So, we do the next best thing. We compute prefix sums\\n    //\\n    // Arr:      [-3, 6, -2].\\n    // Pref: [0,  -3, 3,  1].\\n    //\\n    // For those who do not know, a prefix sum essentially is the sum of all of the array elements up to and including index i from 0.\\n    // Using this prefix sum array, at each index r (standing for right side of contiguous sequence) we find index l \\n\\t// previous such that pref[r] - pref[l] <= k & pref[r] - pref[l] > currMax.\\n    // This naive algorithm has a time complexity of O(n^2). But can we do better?\\n    \\n    // Yes we can! Introducing, the balanced binary search tree.\\n    // Looking at the above algorithm, we are essentially trying to find pref[l] such at it is\\n\\t// maximised, however when added with pref[r] it does not exceed k.\\n    // This can be done through a binary search in a binary search tree, looking for the \\n\\t// previously encountered prefix sum such that it is >= currPrefixSum - k.\\n    \\n    // In the C++ STL, the underlying implementation of the ordered set is a\\n\\t// balanced binary search tree (Red-Black tree). We can use this, as well as the in-built\\n\\t// function lower_bound to perform this storage and search.\\n    \\n    // We store previously encountered prefix sums in our BST (Binary search tree), \\n\\t// and then for every new one we perform this search to try and maximise our sum whilst not exceeding k.\\n    \\n    // Insertion and searching a BST are both O(log n) operations. \\n\\t// We perform this insertion and search n times in a loop through our array. This leads to O(n log n) complexity.\\n    \\n    // Transitioning to two dimensions:\\n    // Moving to 2 dimensions is actually surprisingly easy once you have developed this core insight.\\n    // View each element in your 1 dimensional array as simply the contiguous array sum between two column boundaries, lCol and rCol.\\n    // Illustrated:\\n    // For 2D array              Corresponding 1D with lCol = 0, rCol = 0\\n    // [[1,  0, 1],              [1, 0]\\n    //  [0, -2, 3]]              Corresponding 1D with lCol = 0, rCol = 1\\n    //                           [1 + 0, 0 + -2] = [1, -2].\\n    //                           Corresponding 1D with lCol = 1, rCol = 2\\n    //                           [0 + 1, -2 + 3] = [1, 1].\\n    \\n    // We can efficiently compute these 1D arrays through using prefix sums AGAIN! Phew, that\\'s a lot of prefix sums.\\n    // Essentially, for each row of the 2D array we compute the prefix sums of the elements\\n    \\n    // So for the previous 2D array, the prefix sums look as follows.\\n    // [[1, 1, 2],\\n    //  [0, -2, 1]]\\n    //\\n    // Now, to find index 0 (row 0) of our 1D array, for lCol = 1 & rCol = 2\\n    // we take the pref[row = 0][rCol = 2] and subtract away pref[row = 0][lCol - 1 = 0] to remove any sums\\n    // which do not correspond to our inclusive range.\\n    \\n    // Each 1D array is found through iterating through all of the possible lCol, rCol combinations where lCol <= rCol.\\n    // Then, we perform the same algorithm with the BST (Binary Search Tree) on the current 1D array as outlined above.\\n    // Maximum is replaced if we find a larger rectangle sum.\\n    \\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        // Precompute column prefix sums\\n        for (int row = 0; row < matrix.size(); ++row) {\\n            int currSum = 0;\\n            for (int col = 0; col < matrix[row].size(); ++col) {\\n                currSum += matrix[row][col];\\n                matrix[row][col] = currSum;\\n            }\\n        }\\n        \\n        int maxSum = INT_MIN;\\n        for (int lCol = 0; lCol < matrix[0].size(); ++lCol) {\\n            for (int rCol = lCol; rCol < matrix[0].size(); ++rCol) {\\n                \\n                set<int> bst; // RB tree\\n                bst.insert(0);\\n                \\n                int rowPrefSum = 0;\\n                for (int row = 0; row < matrix.size(); ++row) {\\n                    int currSum = matrix[row][rCol] - (lCol == 0 ? 0 : matrix[row][lCol-1]);\\n                    rowPrefSum += currSum;\\n                    \\n                    auto searchRes = bst.lower_bound(rowPrefSum - k);\\n                    \\n                    if (searchRes != bst.end()) {      \\n                        maxSum = max(maxSum, rowPrefSum - *searchRes);\\n                    }\\n                    \\n                    bst.insert(rowPrefSum);\\n                }\\n                \\n                \\n            }\\n        }\\n        \\n        return maxSum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // The Core Idea Behind This Problem:\\n    // Let\\'s first consider the 1 dimensional case, and then we can extrapolate to the 2-dimensional case of the problem\\n    // Let\\'s say we have an array [-3, 6, -2], and we need to find the greatest contiguous subsequence sum <= k=2\\n    // One approach which may immediately jump to mind is Kadane\\'s algorithm.\\n    // However, this cannot work for the simple reason that we cannot find the next greatest subsequence sum <= k=2 simply from the previous result.\\n    // This is best illustrated looking at [-3, 6, -2]. \\n    // Firstly, maxSum = -3\\n    // However, when we reach 6, what do we do? We can choose to take 6 on its own, however this exceeds k=2.\\n    // We can also take -3+6, however, this is less than 6 on its own (does not guarantee a maximum), and it also exceeds k. There is no reasonable course\\n\\t// of action to take in a case like this to guarantee that the maximum BOUNDED \\n\\t// contiguous subarray sum can be found simply by looking at the previous result.\\n    // So, we do the next best thing. We compute prefix sums\\n    //\\n    // Arr:      [-3, 6, -2].\\n    // Pref: [0,  -3, 3,  1].\\n    //\\n    // For those who do not know, a prefix sum essentially is the sum of all of the array elements up to and including index i from 0.\\n    // Using this prefix sum array, at each index r (standing for right side of contiguous sequence) we find index l \\n\\t// previous such that pref[r] - pref[l] <= k & pref[r] - pref[l] > currMax.\\n    // This naive algorithm has a time complexity of O(n^2). But can we do better?\\n    \\n    // Yes we can! Introducing, the balanced binary search tree.\\n    // Looking at the above algorithm, we are essentially trying to find pref[l] such at it is\\n\\t// maximised, however when added with pref[r] it does not exceed k.\\n    // This can be done through a binary search in a binary search tree, looking for the \\n\\t// previously encountered prefix sum such that it is >= currPrefixSum - k.\\n    \\n    // In the C++ STL, the underlying implementation of the ordered set is a\\n\\t// balanced binary search tree (Red-Black tree). We can use this, as well as the in-built\\n\\t// function lower_bound to perform this storage and search.\\n    \\n    // We store previously encountered prefix sums in our BST (Binary search tree), \\n\\t// and then for every new one we perform this search to try and maximise our sum whilst not exceeding k.\\n    \\n    // Insertion and searching a BST are both O(log n) operations. \\n\\t// We perform this insertion and search n times in a loop through our array. This leads to O(n log n) complexity.\\n    \\n    // Transitioning to two dimensions:\\n    // Moving to 2 dimensions is actually surprisingly easy once you have developed this core insight.\\n    // View each element in your 1 dimensional array as simply the contiguous array sum between two column boundaries, lCol and rCol.\\n    // Illustrated:\\n    // For 2D array              Corresponding 1D with lCol = 0, rCol = 0\\n    // [[1,  0, 1],              [1, 0]\\n    //  [0, -2, 3]]              Corresponding 1D with lCol = 0, rCol = 1\\n    //                           [1 + 0, 0 + -2] = [1, -2].\\n    //                           Corresponding 1D with lCol = 1, rCol = 2\\n    //                           [0 + 1, -2 + 3] = [1, 1].\\n    \\n    // We can efficiently compute these 1D arrays through using prefix sums AGAIN! Phew, that\\'s a lot of prefix sums.\\n    // Essentially, for each row of the 2D array we compute the prefix sums of the elements\\n    \\n    // So for the previous 2D array, the prefix sums look as follows.\\n    // [[1, 1, 2],\\n    //  [0, -2, 1]]\\n    //\\n    // Now, to find index 0 (row 0) of our 1D array, for lCol = 1 & rCol = 2\\n    // we take the pref[row = 0][rCol = 2] and subtract away pref[row = 0][lCol - 1 = 0] to remove any sums\\n    // which do not correspond to our inclusive range.\\n    \\n    // Each 1D array is found through iterating through all of the possible lCol, rCol combinations where lCol <= rCol.\\n    // Then, we perform the same algorithm with the BST (Binary Search Tree) on the current 1D array as outlined above.\\n    // Maximum is replaced if we find a larger rectangle sum.\\n    \\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        // Precompute column prefix sums\\n        for (int row = 0; row < matrix.size(); ++row) {\\n            int currSum = 0;\\n            for (int col = 0; col < matrix[row].size(); ++col) {\\n                currSum += matrix[row][col];\\n                matrix[row][col] = currSum;\\n            }\\n        }\\n        \\n        int maxSum = INT_MIN;\\n        for (int lCol = 0; lCol < matrix[0].size(); ++lCol) {\\n            for (int rCol = lCol; rCol < matrix[0].size(); ++rCol) {\\n                \\n                set<int> bst; // RB tree\\n                bst.insert(0);\\n                \\n                int rowPrefSum = 0;\\n                for (int row = 0; row < matrix.size(); ++row) {\\n                    int currSum = matrix[row][rCol] - (lCol == 0 ? 0 : matrix[row][lCol-1]);\\n                    rowPrefSum += currSum;\\n                    \\n                    auto searchRes = bst.lower_bound(rowPrefSum - k);\\n                    \\n                    if (searchRes != bst.end()) {      \\n                        maxSum = max(maxSum, rowPrefSum - *searchRes);\\n                    }\\n                    \\n                    bst.insert(rowPrefSum);\\n                }\\n                \\n                \\n            }\\n        }\\n        \\n        return maxSum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83618,
                "title": "2-accepted-java-solution",
                "content": "Decide to post because I was actually asked this question during my interview!\\nThere is a simple version of O(n^4).\\nThe idea is to calculate every rectangle [[r1,c1], [r2,c2]], and simply pick the max area <= k.\\nAn improved version takes O(n^3logn). It borrows the idea to find max subarray with sum <= k in 1D array, and apply here: we find all rectangles bounded between r1 & r2, with columns from 0 to end. Pick a pair from tree.\\nI remember the interviewer said there could be an even better solution, but I haven't figured that out...\\n\\nSolution I, O(n^4):\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] areas = new int[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int area = matrix[r][c];\\n                if (r-1 >= 0)\\n                    area += areas[r-1][c];\\n                if (c-1 >= 0)\\n                    area += areas[r][c-1];\\n                if (r-1 >= 0 && c-1 >= 0)\\n                    area -= areas[r-1][c-1];\\n                areas[r][c] = area;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int r1 = 0; r1 < rows; r1++) {\\n            for (int c1 = 0; c1 < cols; c1++) {\\n                for (int r2 = r1; r2 < rows; r2++) {\\n                    for (int c2 = c1; c2 < cols; c2++) {\\n                        int area = areas[r2][c2];\\n                        if (r1-1 >= 0)\\n                            area -= areas[r1-1][c2];\\n                        if (c1-1 >= 0)\\n                            area -= areas[r2][c1-1];\\n                        if (r1-1 >= 0 && c1 -1 >= 0)\\n                            area += areas[r1-1][c1-1];\\n                        if (area <= k)\\n                            max = Math.max(max, area);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\nSolution II (O(n^3logn)\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] areas = new int[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int area = matrix[r][c];\\n                if (r-1 >= 0)\\n                    area += areas[r-1][c];\\n                if (c-1 >= 0)\\n                    area += areas[r][c-1];\\n                if (r-1 >= 0 && c-1 >= 0)\\n                    area -= areas[r-1][c-1];\\n                areas[r][c] = area;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int r1 = 0; r1 < rows; r1++) {\\n            for (int r2 = r1; r2 < rows; r2++) {\\n                TreeSet<Integer> tree = new TreeSet<>();\\n                tree.add(0);    // padding\\n                for (int c = 0; c < cols; c++) {\\n                    int area = areas[r2][c];\\n                    if (r1-1 >= 0)\\n                        area -= areas[r1-1][c];\\n                    Integer ceiling = tree.ceiling(area - k);\\n                    if (ceiling != null)\\n                        max = Math.max(max, area - ceiling);\\n                    tree.add(area);\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "Decide to post because I was actually asked this question during my interview!\\nThere is a simple version of O(n^4).\\nThe idea is to calculate every rectangle [[r1,c1], [r2,c2]], and simply pick the max area <= k.\\nAn improved version takes O(n^3logn). It borrows the idea to find max subarray with sum <= k in 1D array, and apply here: we find all rectangles bounded between r1 & r2, with columns from 0 to end. Pick a pair from tree.\\nI remember the interviewer said there could be an even better solution, but I haven't figured that out...\\n\\nSolution I, O(n^4):\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] areas = new int[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int area = matrix[r][c];\\n                if (r-1 >= 0)\\n                    area += areas[r-1][c];\\n                if (c-1 >= 0)\\n                    area += areas[r][c-1];\\n                if (r-1 >= 0 && c-1 >= 0)\\n                    area -= areas[r-1][c-1];\\n                areas[r][c] = area;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int r1 = 0; r1 < rows; r1++) {\\n            for (int c1 = 0; c1 < cols; c1++) {\\n                for (int r2 = r1; r2 < rows; r2++) {\\n                    for (int c2 = c1; c2 < cols; c2++) {\\n                        int area = areas[r2][c2];\\n                        if (r1-1 >= 0)\\n                            area -= areas[r1-1][c2];\\n                        if (c1-1 >= 0)\\n                            area -= areas[r2][c1-1];\\n                        if (r1-1 >= 0 && c1 -1 >= 0)\\n                            area += areas[r1-1][c1-1];\\n                        if (area <= k)\\n                            max = Math.max(max, area);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\nSolution II (O(n^3logn)\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] areas = new int[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int area = matrix[r][c];\\n                if (r-1 >= 0)\\n                    area += areas[r-1][c];\\n                if (c-1 >= 0)\\n                    area += areas[r][c-1];\\n                if (r-1 >= 0 && c-1 >= 0)\\n                    area -= areas[r-1][c-1];\\n                areas[r][c] = area;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int r1 = 0; r1 < rows; r1++) {\\n            for (int r2 = r1; r2 < rows; r2++) {\\n                TreeSet<Integer> tree = new TreeSet<>();\\n                tree.add(0);    // padding\\n                for (int c = 0; c < cols; c++) {\\n                    int area = areas[r2][c];\\n                    if (r1-1 >= 0)\\n                        area -= areas[r1-1][c];\\n                    Integer ceiling = tree.ceiling(area - k);\\n                    if (ceiling != null)\\n                        max = Math.max(max, area - ceiling);\\n                    tree.add(area);\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1312722,
                "title": "python-two-solutions-explained",
                "content": "#### Solution 1\\nFirst of all, let us understand how to solve 1d problem: that is given list `nums` and number `U` we need to find the maximum sum of adjacent several elements such that its sum is no more than `U`. Note, that it is very similar to problem **327. Count of Range Sum**, but there the goal was to find not the biggest sum, but number of such sums. However we can use the similar idea: let us add cumulative sums one by one, that is if we have `nums = [3, 1, 4, 1, 5, 9, 2, 6]`, then we add elements `[3, 4, 8, 9, 14, 23, 25, 31]`. Each time before we add element we do binary search of element `s - U`: the closest element bigger than `s - U`. If `ind != len(SList)`, then we update our answer.\\n\\nWhen we found how to solve 1-d problem, it is time to work with 2-d problem. Actually we need to solve `O(m^2)` 1-d problems, to choose numbers i,j such that `1 <= i <=j <= m`. What we can do is to calculate cumulative sums for each column and then for each pair create list of differences and apply our `countRangeSum` function.\\n\\n#### Complexity\\nTime complexity of 1-d problem is `O(n log n)`, so time complexity of all algorithm is `O(m^2*n log n)`. It can be make `O(n^2 * m log m)` if we rotate our matrix, but in practice it works similar for me. Space complexity is `O(mn)`.\\n\\n#### Code\\n```python\\nfrom sortedcontainers import SortedList\\n    \\nclass Solution:\\n    def maxSumSubmatrix(self, M, k):\\n        def countRangeSum(nums, U):\\n            SList, ans = SortedList([0]), -float(\"inf\")\\n            for s in accumulate(nums):\\n                idx = SList.bisect_left(s - U) \\n                if idx < len(SList): ans = max(ans, s - SList[idx])        \\n                SList.add(s)\\n            return ans\\n        \\n        m, n, ans = len(M), len(M[0]), -float(\"inf\")\\n        \\n        for i, j in product(range(1, m), range(n)):\\n            M[i][j] += M[i-1][j]\\n                \\n        M = [[0]*n] + M\\n        \\n        for r1, r2 in combinations(range(m + 1), 2):\\n            row = [j - i for i, j in zip(M[r1], M[r2])]\\n            ans = max(ans, countRangeSum(row, k))\\n            \\n        return ans\\n```\\n\\n#### Solution 2:\\n\\nWe can use slightly different function `countRangeSum`, where instead of SortedList we use usual list and `insort` function. Complexity is `O(n^2)`, however because `n` is not very big, it works even faster than previous method, like 2-3 times!\\n\\n#### Complexity\\nTime complexity is `O(n^2*m^2)`, but with very small constant. Space complexity is `O(mn)`.\\n\\n#### Code\\n```python\\ndef countRangeSum(nums, U):\\n\\t\\tSList, ans = [0], -float(\"inf\")\\n\\t\\tfor s in accumulate(nums):\\n\\t\\t\\tidx = bisect_left(SList, s - U) \\n\\t\\t\\tif idx < len(SList): ans = max(ans, s - SList[idx])        \\n\\t\\t\\tbisect.insort(SList, s)\\n\\t\\treturn ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n    \\nclass Solution:\\n    def maxSumSubmatrix(self, M, k):\\n        def countRangeSum(nums, U):\\n            SList, ans = SortedList([0]), -float(\"inf\")\\n            for s in accumulate(nums):\\n                idx = SList.bisect_left(s - U) \\n                if idx < len(SList): ans = max(ans, s - SList[idx])        \\n                SList.add(s)\\n            return ans\\n        \\n        m, n, ans = len(M), len(M[0]), -float(\"inf\")\\n        \\n        for i, j in product(range(1, m), range(n)):\\n            M[i][j] += M[i-1][j]\\n                \\n        M = [[0]*n] + M\\n        \\n        for r1, r2 in combinations(range(m + 1), 2):\\n            row = [j - i for i, j in zip(M[r1], M[r2])]\\n            ans = max(ans, countRangeSum(row, k))\\n            \\n        return ans\\n```\n```python\\ndef countRangeSum(nums, U):\\n\\t\\tSList, ans = [0], -float(\"inf\")\\n\\t\\tfor s in accumulate(nums):\\n\\t\\t\\tidx = bisect_left(SList, s - U) \\n\\t\\t\\tif idx < len(SList): ans = max(ans, s - SList[idx])        \\n\\t\\t\\tbisect.insort(SList, s)\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83595,
                "title": "java-117ms-beat-99-81-merge-sort",
                "content": "```\\n/*\\n * If # of columns is smaller, process one set of columns [i..j) at a time, for each different i<j.\\n * For one set of colums [i..j), do it like \"Count of Range Sum\".\\n * O(n) = n^2 * mlogm.\\n * Assume we have such result.\\n */\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length, ans = Integer.MIN_VALUE;\\n        long[] sum = new long[m+1]; // stores sum of rect[0..p][i..j]\\n        for (int i = 0; i < n; ++i) {\\n            long[] sumInRow = new long[m];\\n            for (int j = i; j < n; ++j) { // for each rect[*][i..j]\\n                for (int p = 0; p < m; ++p) {\\n                    sumInRow[p] += matrix[p][j];\\n                    sum[p+1] = sum[p] + sumInRow[p];\\n                }\\n                ans = Math.max(ans, mergeSort(sum, 0, m+1, k));\\n                if (ans == k) return k;\\n            }\\n        }\\n        return ans;\\n    }\\n    int mergeSort(long[] sum, int start, int end, int k) {\\n        if (end == start+1) return Integer.MIN_VALUE; // need at least 2 to proceed\\n        int mid = start + (end - start)/2, cnt = 0;\\n        int ans = mergeSort(sum, start, mid, k);\\n        if (ans == k) return k;\\n        ans = Math.max(ans, mergeSort(sum, mid, end, k));\\n        if (ans == k) return k;\\n        long[] cache = new long[end-start];\\n        for (int i = start, j = mid, p = mid; i < mid; ++i) {\\n            while (j < end && sum[j] - sum[i] <= k) ++j;\\n            if (j-1 >= mid) {\\n                ans = Math.max(ans, (int)(sum[j-1] - sum[i]));\\n                if (ans == k) return k;\\n            }\\n            while (p < end && sum[p] < sum[i]) cache[cnt++] = sum[p++];\\n            cache[cnt++] = sum[i];\\n        }\\n        System.arraycopy(cache, 0, sum, start, cnt);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * If # of columns is smaller, process one set of columns [i..j) at a time, for each different i<j.\\n * For one set of colums [i..j), do it like \"Count of Range Sum\".\\n * O(n) = n^2 * mlogm.\\n * Assume we have such result.\\n */\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length, ans = Integer.MIN_VALUE;\\n        long[] sum = new long[m+1]; // stores sum of rect[0..p][i..j]\\n        for (int i = 0; i < n; ++i) {\\n            long[] sumInRow = new long[m];\\n            for (int j = i; j < n; ++j) { // for each rect[*][i..j]\\n                for (int p = 0; p < m; ++p) {\\n                    sumInRow[p] += matrix[p][j];\\n                    sum[p+1] = sum[p] + sumInRow[p];\\n                }\\n                ans = Math.max(ans, mergeSort(sum, 0, m+1, k));\\n                if (ans == k) return k;\\n            }\\n        }\\n        return ans;\\n    }\\n    int mergeSort(long[] sum, int start, int end, int k) {\\n        if (end == start+1) return Integer.MIN_VALUE; // need at least 2 to proceed\\n        int mid = start + (end - start)/2, cnt = 0;\\n        int ans = mergeSort(sum, start, mid, k);\\n        if (ans == k) return k;\\n        ans = Math.max(ans, mergeSort(sum, mid, end, k));\\n        if (ans == k) return k;\\n        long[] cache = new long[end-start];\\n        for (int i = start, j = mid, p = mid; i < mid; ++i) {\\n            while (j < end && sum[j] - sum[i] <= k) ++j;\\n            if (j-1 >= mid) {\\n                ans = Math.max(ans, (int)(sum[j-1] - sum[i]));\\n                if (ans == k) return k;\\n            }\\n            while (p < end && sum[p] < sum[i]) cache[cnt++] = sum[p++];\\n            cache[cnt++] = sum[i];\\n        }\\n        System.arraycopy(cache, 0, sum, start, cnt);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83614,
                "title": "accepted-java-solution",
                "content": "The idea of this solution is to convert the problem into \"find the maximum sum of sub-array no larger than K\". \\n\\nThe time complexity will be O(r^2clogc) where r is the number of rows and c is the number of columns. If r is much larger than c, the complexity can be O(c^2rlogr) by creating a row-sum array instead of column-sum array\\n\\n```\\n\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < row; i ++) {\\n            int[] colSum = new int[col];\\n            for (int j = i; j < row; j ++) {\\n                for (int c = 0; c < col; c ++) {\\n                    colSum[c] += matrix[j][c];\\n                }\\n                max = Math.max(max, findMax(colSum, k));\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int findMax(int[] nums, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int sum = 0;\\n        TreeSet<Integer> s = new TreeSet();\\n        s.add(0);\\n    \\n        for(int i = 0;i < nums.length; i ++){\\n            int t = sum + nums[i];\\n            sum = t;\\n            Integer gap = s.ceiling(sum - k);\\n            if(gap != null) max = Math.max(max, sum - gap);\\n            s.add(t);\\n        }\\n    \\n        return max;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < row; i ++) {\\n            int[] colSum = new int[col];\\n            for (int j = i; j < row; j ++) {\\n                for (int c = 0; c < col; c ++) {\\n                    colSum[c] += matrix[j][c];\\n                }\\n                max = Math.max(max, findMax(colSum, k));\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int findMax(int[] nums, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int sum = 0;\\n        TreeSet<Integer> s = new TreeSet();\\n        s.add(0);\\n    \\n        for(int i = 0;i < nums.length; i ++){\\n            int t = sum + nums[i];\\n            sum = t;\\n            Integer gap = s.ceiling(sum - k);\\n            if(gap != null) max = Math.max(max, sum - gap);\\n            s.add(t);\\n        }\\n    \\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491014,
                "title": "python-99-2-using-kadane-s-algorithm-bisect",
                "content": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        res = -inf\\n        \\n        for l in range(n):\\n            rowSums = [0] * m\\n            for r in range(l, n):\\n                colSums = [0]\\n                colSum = 0\\n                for i in range(m):\\n                    rowSums[i] += matrix[i][r]\\n                    colSum += rowSums[i]\\n                    diff = colSum - k\\n                    idx = bisect_left(colSums, diff)\\n                    if idx < len(colSums):\\n                        if colSums[idx] == diff:\\n                            return k\\n                        else:\\n                            res = max(res, colSum - colSums[idx])\\n                    insort(colSums, colSum)\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/29dd3558-a351-4e70-b9b5-af0e03ab8425_1661617035.1357048.png)\\n\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        res = -inf\\n        \\n        for l in range(n):\\n            rowSums = [0] * m\\n            for r in range(l, n):\\n                colSums = [0]\\n                colSum = 0\\n                for i in range(m):\\n                    rowSums[i] += matrix[i][r]\\n                    colSum += rowSums[i]\\n                    diff = colSum - k\\n                    idx = bisect_left(colSums, diff)\\n                    if idx < len(colSums):\\n                        if colSums[idx] == diff:\\n                            return k\\n                        else:\\n                            res = max(res, colSum - colSums[idx])\\n                    insort(colSums, colSum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488551,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        \\n        int prefix[r+1][c+1];\\n        memset(prefix,0,sizeof(prefix));\\n        \\n        for(int i=1; i<=r; ++i) prefix[i][1] = prefix[i-1][1] + matrix[i-1][0];\\n        for(int i=1; i<=c; ++i) prefix[1][i] = prefix[1][i-1] + matrix[0][i-1];\\n        \\n        for(int i=2; i<=r; ++i){\\n            for(int j=2; j<=c; ++j){\\n                prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        \\n        int ans = INT_MIN;\\n        for (int x1 = 1; x1 <= r; ++x1) {\\n\\t\\t\\tfor (int y1 = 1; y1 <= c; ++y1) {\\n\\t\\t\\t\\tfor (int x2 = x1; x2 <= r; ++x2) {\\n\\t\\t\\t\\t\\tfor (int y2 = y1; y2 <= c; ++y2) {\\n\\t\\t\\t\\t\\t\\tint sum = prefix[x2][y2] - prefix[x1-1][y2] - prefix[x2][y1-1] + prefix[x1-1][y1-1];\\n\\t\\t\\t\\t\\t\\tif (sum <= k) {\\n\\t\\t\\t\\t\\t\\t\\tans = max(ans, sum);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n        return ans;\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        \\n        int prefix[r+1][c+1];\\n        memset(prefix,0,sizeof(prefix));\\n        \\n        for(int i=1; i<=r; ++i) prefix[i][1] = prefix[i-1][1] + matrix[i-1][0];\\n        for(int i=1; i<=c; ++i) prefix[1][i] = prefix[1][i-1] + matrix[0][i-1];\\n        \\n        for(int i=2; i<=r; ++i){\\n            for(int j=2; j<=c; ++j){\\n                prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        \\n        int ans = INT_MIN;\\n        for (int x1 = 1; x1 <= r; ++x1) {\\n\\t\\t\\tfor (int y1 = 1; y1 <= c; ++y1) {\\n\\t\\t\\t\\tfor (int x2 = x1; x2 <= r; ++x2) {\\n\\t\\t\\t\\t\\tfor (int y2 = y1; y2 <= c; ++y2) {\\n\\t\\t\\t\\t\\t\\tint sum = prefix[x2][y2] - prefix[x1-1][y2] - prefix[x2][y1-1] + prefix[x1-1][y1-1];\\n\\t\\t\\t\\t\\t\\tif (sum <= k) {\\n\\t\\t\\t\\t\\t\\t\\tans = max(ans, sum);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83596,
                "title": "any-accepted-python-solution",
                "content": "I got a TLE for the Python code below, because the time cost of bisect.insort is O(n) for a built-in list.\\n\\nThe code was rejudged as accepted just now, but very slow... 1800ms+\\n\\n    class Solution(object):\\n        def maxSumSubmatrix(self, matrix, k):\\n            \"\"\"\\n            :type matrix: List[List[int]]\\n            :type k: int\\n            :rtype: int\\n            \"\"\"\\n            m = len(matrix)\\n            n = len(matrix[0]) if m else 0\\n            \\n            M = max(m, n)\\n            N = min(m, n)\\n            ans = None\\n            for x in range(N):\\n                sums = [0] * M\\n                for y in range(x, N):\\n                    slist, num = [], 0\\n                    for z in range(M):\\n                        sums[z] += matrix[z][y] if m > n else matrix[y][z]\\n                        num += sums[z]\\n                        if num <= k: ans = max(ans, num)\\n                        i = bisect.bisect_left(slist, num - k)\\n                        if i != len(slist): ans = max(ans, num - slist[i])\\n                        bisect.insort(slist, num)\\n            return ans or 0\\n\\nCould anybody share a more efficient Python solution? Thank you :D",
                "solutionTags": [
                    "Python"
                ],
                "code": "I got a TLE for the Python code below, because the time cost of bisect.insort is O(n) for a built-in list.\\n\\nThe code was rejudged as accepted just now, but very slow... 1800ms+\\n\\n    class Solution(object):\\n        def maxSumSubmatrix(self, matrix, k):\\n            \"\"\"\\n            :type matrix: List[List[int]]\\n            :type k: int\\n            :rtype: int\\n            \"\"\"\\n            m = len(matrix)\\n            n = len(matrix[0]) if m else 0\\n            \\n            M = max(m, n)\\n            N = min(m, n)\\n            ans = None\\n            for x in range(N):\\n                sums = [0] * M\\n                for y in range(x, N):\\n                    slist, num = [], 0\\n                    for z in range(M):\\n                        sums[z] += matrix[z][y] if m > n else matrix[y][z]\\n                        num += sums[z]\\n                        if num <= k: ans = max(ans, num)\\n                        i = bisect.bisect_left(slist, num - k)\\n                        if i != len(slist): ans = max(ans, num - slist[i])\\n                        bisect.insort(slist, num)\\n            return ans or 0\\n\\nCould anybody share a more efficient Python solution? Thank you :D",
                "codeTag": "Java"
            },
            {
                "id": 2488222,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Prefix Sum && Binary Search***\\n\\n* ***Time Complexity :- O(N * N * N * logN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding maximum subarray having sum less than k\\n    \\n    int find_max(vector<int>& arr, int k)\\n    {\\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // curr_sum will store cumulative sum\\n        \\n        int curr_sum = 0;\\n        \\n        // set will store the prefix sum of array\\n        \\n        set<int> s;\\n        \\n        // put 0 into set, if curr_sum == k, (curr_sum - k) will be zero \\n        \\n        s.insert(0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // calculate cumulative sum\\n            \\n            curr_sum += arr[i];\\n            \\n            // find the prefix sum in set having sum == curr_sum - k\\n            \\n            auto it = s.lower_bound(curr_sum - k);\\n            \\n            // if prefix sum is present, update the maxi\\n            \\n            if(it != s.end())\\n            {\\n                maxi = max(maxi, curr_sum - *it);\\n            }\\n            \\n            // insert prefix sum into set\\n            \\n            s.insert(curr_sum);\\n        }\\n        \\n        return maxi;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // fix the position of two rows and take cumulative sum of columns between two fixed rows\\n        \\n        for(int start_row = 0; start_row < n; start_row++)\\n        {\\n            vector<int> col_array(m, 0);\\n            \\n            for(int end_row = start_row; end_row < n; end_row++)\\n            {\\n                // take cumulative sum of columns between two fixed rows\\n                \\n                for(int col = 0; col < m; col++)\\n                {\\n                    col_array[col] += matrix[end_row][col];\\n                }\\n                \\n                // find maximum subarray having sum less than equal to k\\n                \\n                int curr_max = find_max(col_array, k);\\n                \\n                // update the maximum sum\\n                \\n                maxi = max(maxi, curr_max);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding maximum subarray having sum less than k\\n    \\n    int find_max(vector<int>& arr, int k)\\n    {\\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // curr_sum will store cumulative sum\\n        \\n        int curr_sum = 0;\\n        \\n        // set will store the prefix sum of array\\n        \\n        set<int> s;\\n        \\n        // put 0 into set, if curr_sum == k, (curr_sum - k) will be zero \\n        \\n        s.insert(0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // calculate cumulative sum\\n            \\n            curr_sum += arr[i];\\n            \\n            // find the prefix sum in set having sum == curr_sum - k\\n            \\n            auto it = s.lower_bound(curr_sum - k);\\n            \\n            // if prefix sum is present, update the maxi\\n            \\n            if(it != s.end())\\n            {\\n                maxi = max(maxi, curr_sum - *it);\\n            }\\n            \\n            // insert prefix sum into set\\n            \\n            s.insert(curr_sum);\\n        }\\n        \\n        return maxi;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // fix the position of two rows and take cumulative sum of columns between two fixed rows\\n        \\n        for(int start_row = 0; start_row < n; start_row++)\\n        {\\n            vector<int> col_array(m, 0);\\n            \\n            for(int end_row = start_row; end_row < n; end_row++)\\n            {\\n                // take cumulative sum of columns between two fixed rows\\n                \\n                for(int col = 0; col < m; col++)\\n                {\\n                    col_array[col] += matrix[end_row][col];\\n                }\\n                \\n                // find maximum subarray having sum less than equal to k\\n                \\n                int curr_max = find_max(col_array, k);\\n                \\n                // update the maximum sum\\n                \\n                maxi = max(maxi, curr_max);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489079,
                "title": "python-prefix-sums-and-binary-search",
                "content": "This is an implementation of a solution provided [here](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/851448/C%2B%2B-from-800-ms-to-50-ms).\\n\\n**Solution**:\\nUse two pointers to generate prefix sums of each rows. Left pointer will go from 0 to n and right pointer will go from left to n. By calculating prefix sums for each row, we reduce all rectangle from 2d to 1d where each rectangle is represented by 1d array of rows prefix sum.\\n\\nFor each row prefix sum, we will calculate column prefix sum and use binary search to find maximum area lesser than k. Start by initialize a list to store previously calculated column prefix sum. Iterate through all values in the row prefix sum. At each iteration, calculate the column prefix sum and check if there exists a previous column prefix sum that is larger than the different between the current column sum and k but the smallest among all previous prefix sums that are greater than the different. Use binary search to find such values. If there is, update the result.\\n\\n    Ex: Given matrix = [[1,0,1],[0,-2,3]], k = 2\\n    l   r   rowSums     colSums     area        res        \\n    0   0   [1, 0]      [1, 1]      [1,  1]     1\\n    0   1   [1, -2]     [1, -1]     [1, -1]     1\\n    0   2   [2, 1]      [2, 3]      [2, None]   2\\n    1   1   [0, -2]     [0, -2]     [0, -2]     2\\n    1   2   [1, 1]      [1, 2]      [1, 2]      2\\n    2   2   [1, 3]      [1, 4]      [1, None]   2\\n\\n\\nP.S. Kadane Algorithm: Given a list of numbers. You can calculate the maximum area ended at each number by taking the maximum between the current number vs the maximum area of previous number plus the current number. \\n\\n        area(i) = max(area(i-1) + nums[i], nums[i])\\n\\n**Complexity**:\\n    Time: O(m\\\\**2 n\\\\**2)\\n    Space:  O(m)\\n\\t\\n```\\nfrom bisect import bisect_right, insort\\nfrom math import inf\\n\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:\\n\\n        # Get the length of rows and colums\\n        m, n = len(matrix), len(matrix[0])\\n\\n        # Initialize the result\\n        res = -inf\\n\\n        # Iterate the left pointer from 0 to n\\n        for l in range(n):\\n\\n            # Initialize the row prefix sum\\n            rowSums = [0] * m\\n\\n            # Iterate the right pointer from left to n\\n            for r in range(l, n):\\n\\n                # Calculate the row prefix sum from left to right\\n                for i in range(m):\\n                    rowSums[i] += matrix[i][r]\\n\\n                # Calculate the column prefix sums\\n                # Initialize a list to store previous column prefix sum\\n                colSums = [0]\\n\\n                # Intialize the column prefix sum\\n                colSum = 0\\n\\n                # Iterate through all row prefix sums\\n                for rowSum in rowSums:\\n\\n                    # Add the current row prefix sum to the column prefix sum\\n                    colSum += rowSum\\n\\n                    # Calculate the different between the column prefix sum and k\\n                    diff = colSum - k\\n\\n                    # Perform a binary search to find an index of a value is larger but cloest to the different among previously calculated column prefix sums\\n                    idx = bisect_right(colSums, diff)\\n\\n                    # Check if the different exists among the previously calculated column prefix sums\\n                    if idx - 1 >= 0 and colSums[idx - 1] == diff:\\n\\n                        # If yes, update the result\\n                        res = max(res, colSum - colSums[idx - 1])\\n\\n                        # End the search because we found the largest possible result\\n                        return k\\n\\n                    # Else, if the different does not exist among the previously calculated column prefix sums, check if there is a previously calculated column prefix sum larger than the different\\n                    elif idx != len(colSums):\\n\\n                        # If yes, update the result with the new area if it is larger than previous result\\n                        res = max(res, colSum - colSums[idx])\\n\\n                    # Insert the current column prefix sum into the list while maintaining the sorted order\\n                    insort(colSums, colSum)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_right, insort\\nfrom math import inf\\n\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:\\n\\n        # Get the length of rows and colums\\n        m, n = len(matrix), len(matrix[0])\\n\\n        # Initialize the result\\n        res = -inf\\n\\n        # Iterate the left pointer from 0 to n\\n        for l in range(n):\\n\\n            # Initialize the row prefix sum\\n            rowSums = [0] * m\\n\\n            # Iterate the right pointer from left to n\\n            for r in range(l, n):\\n\\n                # Calculate the row prefix sum from left to right\\n                for i in range(m):\\n                    rowSums[i] += matrix[i][r]\\n\\n                # Calculate the column prefix sums\\n                # Initialize a list to store previous column prefix sum\\n                colSums = [0]\\n\\n                # Intialize the column prefix sum\\n                colSum = 0\\n\\n                # Iterate through all row prefix sums\\n                for rowSum in rowSums:\\n\\n                    # Add the current row prefix sum to the column prefix sum\\n                    colSum += rowSum\\n\\n                    # Calculate the different between the column prefix sum and k\\n                    diff = colSum - k\\n\\n                    # Perform a binary search to find an index of a value is larger but cloest to the different among previously calculated column prefix sums\\n                    idx = bisect_right(colSums, diff)\\n\\n                    # Check if the different exists among the previously calculated column prefix sums\\n                    if idx - 1 >= 0 and colSums[idx - 1] == diff:\\n\\n                        # If yes, update the result\\n                        res = max(res, colSum - colSums[idx - 1])\\n\\n                        # End the search because we found the largest possible result\\n                        return k\\n\\n                    # Else, if the different does not exist among the previously calculated column prefix sums, check if there is a previously calculated column prefix sum larger than the different\\n                    elif idx != len(colSums):\\n\\n                        # If yes, update the result with the new area if it is larger than previous result\\n                        res = max(res, colSum - colSums[idx])\\n\\n                    # Insert the current column prefix sum into the list while maintaining the sorted order\\n                    insort(colSums, colSum)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488336,
                "title": "c-easy-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# **Please share and Upvote it Motivates me**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488344,
                "title": "java-easy-and-simple-solution-90-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] arr, int k) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int maxK = Integer.MIN_VALUE;\\n        for(int i = 0; i < cols; i++){\\n            int dp[] = new int[rows];\\n            for(int j = i; j < cols; j++){\\n                for(int l = 0; l < rows; l++){\\n                    dp[l] += arr[l][j];\\n                }\\n                int currSum = maxSubArray(dp, k);\\n                maxK = Math.max(maxK, currSum);                 \\n                if(maxK == k)\\n                    return k;\\n            }\\n        }\\n        return maxK;\\n    }\\n    public int maxSubArray(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int currSum = 0;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            currSum += arr[i];\\n            Integer ceilValue = set.ceiling(currSum - k);\\n            if(ceilValue != null) {\\n                max = Math.max(max, currSum - ceilValue);\\n            }\\n            set.add(currSum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] arr, int k) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int maxK = Integer.MIN_VALUE;\\n        for(int i = 0; i < cols; i++){\\n            int dp[] = new int[rows];\\n            for(int j = i; j < cols; j++){\\n                for(int l = 0; l < rows; l++){\\n                    dp[l] += arr[l][j];\\n                }\\n                int currSum = maxSubArray(dp, k);\\n                maxK = Math.max(maxK, currSum);                 \\n                if(maxK == k)\\n                    return k;\\n            }\\n        }\\n        return maxK;\\n    }\\n    public int maxSubArray(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int currSum = 0;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            currSum += arr[i];\\n            Integer ceilValue = set.ceiling(currSum - k);\\n            if(ceilValue != null) {\\n                max = Math.max(max, currSum - ceilValue);\\n            }\\n            set.add(currSum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83631,
                "title": "using-cumulative-sum-and-treeset",
                "content": "To find the max sum of an array, we can do as follows:\\n\\n* compute the cumulative sum of the array\\n* find a pair of i and j, constrained to i<j, and **cum[j]-cum[i]<=k**\\n* do some trick, the inequation above is actually **cum[j]-k<=cum[i]**, we need to find the minimum value of **cum[i]** in order to maximize **cum[j]-cum[i]**, that is, find **TreeSet.ceiling(cum[j]-k)**\\n* if founded in the treeset, the value is actually **cum[i]**, by subtract **cum[i]** from **cum[j]**, we update the result\\nThe Max sum of rectangle on larger than k can be transformed into the problem of finding the max sum of an array no larger than k by slicing  the matrix:\\n```\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int result = Integer.MIN_VALUE;\\n        for (int begin = 0; begin < n; begin++) {\\n            for (int end = begin + 1; end <= n; end++) {\\n                int[] arr = new int[m];\\n                for (int i = 0; i < m; i++) {\\n                    for (int j = begin; j < end; j++) {\\n                        arr[i] += matrix[i][j];\\n                    }\\n                }\\n                TreeSet<Integer> treeSet = new TreeSet<>();\\n                treeSet.add(0);\\n                int cumulative = 0;\\n                for (int i : arr) {\\n                    cumulative += i;\\n                    Integer ceiling = treeSet.ceiling(cumulative - k);\\n                    if (ceiling != null) {\\n                        result = Math.max(result, cumulative - ceiling);\\n                    }\\n                    treeSet.add(cumulative);\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "To find the max sum of an array, we can do as follows:\\n\\n* compute the cumulative sum of the array\\n* find a pair of i and j, constrained to i<j, and **cum[j]-cum[i]<=k**\\n* do some trick, the inequation above is actually **cum[j]-k<=cum[i]**, we need to find the minimum value of **cum[i]** in order to maximize **cum[j]-cum[i]**, that is, find **TreeSet.ceiling(cum[j]-k)**\\n* if founded in the treeset, the value is actually **cum[i]**, by subtract **cum[i]** from **cum[j]**, we update the result\\nThe Max sum of rectangle on larger than k can be transformed into the problem of finding the max sum of an array no larger than k by slicing  the matrix:\\n```\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int result = Integer.MIN_VALUE;\\n        for (int begin = 0; begin < n; begin++) {\\n            for (int end = begin + 1; end <= n; end++) {\\n                int[] arr = new int[m];\\n                for (int i = 0; i < m; i++) {\\n                    for (int j = begin; j < end; j++) {\\n                        arr[i] += matrix[i][j];\\n                    }\\n                }\\n                TreeSet<Integer> treeSet = new TreeSet<>();\\n                treeSet.add(0);\\n                int cumulative = 0;\\n                for (int i : arr) {\\n                    cumulative += i;\\n                    Integer ceiling = treeSet.ceiling(cumulative - k);\\n                    if (ceiling != null) {\\n                        result = Math.max(result, cumulative - ceiling);\\n                    }\\n                    treeSet.add(cumulative);\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 147759,
                "title": "clean-java-code-with-treeset-beat-99-99",
                "content": "Same idea: use the same rule to get the all the submatrix prefixsum. The lgn is **not** because the binary search. The reason lgN is here we use balanced bst here. (In java, TreeSet or TreeMap)\\n\\n    //Time: O(n * n * (m) * lgm) n means the col size and m row size\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int j = 0; j < col; j++) {\\n            int[] sum = new int[row];\\n            \\n            for(int current = j; current < col; current++) {\\n                for(int i = 0; i < row; i++) {\\n                    sum[i] += matrix[i][current];\\n                }\\n                \\n                int temp = find(sum, k);\\n                \\n                result = Math.max(temp, result);\\n                \\n            }\\n            \\n        }\\n        return result;\\n    }\\n    //O(lgM) find the maxium gap\\n    private int find(int[] sum, int k) {\\n        int result = Integer.MIN_VALUE;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        int current = 0;\\n        for(int i = 0; i < sum.length; i++) {\\n            current += sum[i];\\n            \\n            Integer target = set.ceiling(current - k); \\n                \\n            if(target != null) {\\n                result = Math.max(result, current - target);\\n            }\\n            set.add(current);\\n        }\\n        \\n        return result;\\n    }\\n",
                "solutionTags": [],
                "code": "Same idea: use the same rule to get the all the submatrix prefixsum. The lgn is **not** because the binary search. The reason lgN is here we use balanced bst here. (In java, TreeSet or TreeMap)\\n\\n    //Time: O(n * n * (m) * lgm) n means the col size and m row size\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int j = 0; j < col; j++) {\\n            int[] sum = new int[row];\\n            \\n            for(int current = j; current < col; current++) {\\n                for(int i = 0; i < row; i++) {\\n                    sum[i] += matrix[i][current];\\n                }\\n                \\n                int temp = find(sum, k);\\n                \\n                result = Math.max(temp, result);\\n                \\n            }\\n            \\n        }\\n        return result;\\n    }\\n    //O(lgM) find the maxium gap\\n    private int find(int[] sum, int k) {\\n        int result = Integer.MIN_VALUE;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        int current = 0;\\n        for(int i = 0; i < sum.length; i++) {\\n            current += sum[i];\\n            \\n            Integer target = set.ceiling(current - k); \\n                \\n            if(target != null) {\\n                result = Math.max(result, current - target);\\n            }\\n            set.add(current);\\n        }\\n        \\n        return result;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2491089,
                "title": "brute-force-binary-search-on-prefix-sum-explained",
                "content": "Note; \\nI\\'ve attached a link at the bottom to a post I\\'ve made explaining all the details like prefix matrix and rectangles in super great detail.\\n\\nThis post touches them briefly.\\n<hr />\\n\\nI\\'ve used few tricks for the solution.\\n\\n* Prefix matrix (extension of prefix sums) - `matrix_prefix[row][col]` is the sum of the matrix from `0, 0` (origin) to `row, col` (in code there is a buffer of +1 to every dimension to handle boundaries easier)\\n\\nThe prefix matrix is used to calculate the sum of a rectange in O(1) time.\\n\\n* Rectangle - A rectangle can be represented as a pair of cartesian coordinates `(x1, y1), (x2, y2)`\\n\\n\\n# Brute force\\nUnderstanding the previous ideas, one could generate all possible rectangle pairs and calculate the sum using the prefix matrix. That will cost `O(n^2*m^2)` or `O(n^4)` assume n=m\\n\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        \\n        matrix_prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        for row in range(1, m + 1):\\n            for col in range(1, n + 1):\\n                matrix_prefix[row][col] = matrix[row - 1][col - 1] + matrix_prefix[row-1][col] + matrix_prefix[row][col-1] - matrix_prefix[row-1][col-1]\\n        \\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        SUM = matrix_prefix[y2 + 1][x2 + 1] - matrix_prefix[y1][x2+1] - matrix_prefix[y2+1][x1] + matrix_prefix[y1][x1]\\n                        if SUM <= k:\\n                            ans = max(ans, SUM)\\n        return ans\\n```\\n\\n# Binary search\\nAn optimization is to fix 2 vertical points. (y1, y2) and iterate the whole horizontal space, x.\\n\\nThis turns the problem into a \"subarray sum equal k\" problem. We have a running sum and also we remember the prefixes of the sums we\\'ve seen.\\n\\nWhenever we subtract a prefix sum from the current sum we can find the \"middle sum\".\\n\\nNow image `k=10` and our current window sum is 8, we we have -2 as a prefix then we could subtract it and get to window sum = 10.\\n\\nSo we need to subtract a value with AT MOST -2. -2 is our `complement`.\\n\\nTo find the best matching prefix (to -2 in the former example) we will use a binary search.\\n\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        \\n        matrix_prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        for row in range(1, m + 1):\\n            for col in range(1, n + 1):\\n                matrix_prefix[row][col] = matrix[row - 1][col - 1] + matrix_prefix[row-1][col] + matrix_prefix[row][col-1] - matrix_prefix[row-1][col-1]\\n        \\n        for y1 in range(m):\\n            for y2 in range(y1, m):\\n                x_sums = []\\n                for x in range(n):\\n                    rec_sum = matrix_prefix[y2 + 1][x + 1] - matrix_prefix[y1][x+1] - matrix_prefix[y2+1][0] + matrix_prefix[y1][0]\\n                    comp = rec_sum - k\\n                    \\n                    if rec_sum <= k:\\n                        ans = max(ans, rec_sum)\\n                        \\n                    i = bisect.bisect_left(x_sums, comp)    \\n                    if x_sums and i < len(x_sums):\\n                        if rec_sum - x_sums[i] <= k:\\n                            ans = max(ans, rec_sum - x_sums[i])\\n                    \\n                    bisect.insort(x_sums, rec_sum)\\n                    \\n        return ans\\n```\\n\\n\\n# Note\\n* I\\'ve went over most technical concepts in a brief, like prefix matrix and turning the problem into \"subarray sum equal k\". I\\'ve made an in depth discussion to a similar question, please check it out if you are interested in more details\\n\\nhttps://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/2298642/fully-explained-intuition-4-solutions-must-read-with-image",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        \\n        matrix_prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        for row in range(1, m + 1):\\n            for col in range(1, n + 1):\\n                matrix_prefix[row][col] = matrix[row - 1][col - 1] + matrix_prefix[row-1][col] + matrix_prefix[row][col-1] - matrix_prefix[row-1][col-1]\\n        \\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        SUM = matrix_prefix[y2 + 1][x2 + 1] - matrix_prefix[y1][x2+1] - matrix_prefix[y2+1][x1] + matrix_prefix[y1][x1]\\n                        if SUM <= k:\\n                            ans = max(ans, SUM)\\n        return ans\\n```\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        \\n        matrix_prefix = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        for row in range(1, m + 1):\\n            for col in range(1, n + 1):\\n                matrix_prefix[row][col] = matrix[row - 1][col - 1] + matrix_prefix[row-1][col] + matrix_prefix[row][col-1] - matrix_prefix[row-1][col-1]\\n        \\n        for y1 in range(m):\\n            for y2 in range(y1, m):\\n                x_sums = []\\n                for x in range(n):\\n                    rec_sum = matrix_prefix[y2 + 1][x + 1] - matrix_prefix[y1][x+1] - matrix_prefix[y2+1][0] + matrix_prefix[y1][0]\\n                    comp = rec_sum - k\\n                    \\n                    if rec_sum <= k:\\n                        ans = max(ans, rec_sum)\\n                        \\n                    i = bisect.bisect_left(x_sums, comp)    \\n                    if x_sums and i < len(x_sums):\\n                        if rec_sum - x_sums[i] <= k:\\n                            ans = max(ans, rec_sum - x_sums[i])\\n                    \\n                    bisect.insort(x_sums, rec_sum)\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83632,
                "title": "easy-understand-python-ac-solution-with-clear-comments",
                "content": "The idea comes from the C++ or Java solution posted on discuss, I just rewrite the idea with python.\\n* using two pointers to scan the column, Space is O(col)\\n* `left` and `right` both start from the 0, and move `right` first when it reaches the end then move `left`\\n* record the sum of the value and find the max sum less than k \\n* the following code can also be used to solve `Max Sum of Sub-Matrix `, only need to replace the `maxSubArraylessK` with `Kadane's algorithm`\\n\\n```\\n def maxSubArraylessK(self,nums,k):\\n        \"\"\"\\n        we need to find the sum[right]-sum[left]<=k\\n        since the bitsect return the index of the sorted value\\n        we can't directly pop the nums[idx] \\n        we should use insort from the bisect\\n        \"\"\"\\n        # python set() doesn't support indexing, using list instead\\n        # similar as the c++ or java set()\\n        \\n        cumset=[]\\n        cumset.append(0)\\n        maxsum=-1<<32\\n        cursum=0\\n        for i in xrange(len(nums)):\\n            cursum+=nums[i]\\n            # find the lower bound of the index\\n            idx=bisect.bisect_left(cumset,cursum-k)\\n            # find max in sum[right]-sum[left]<=k\\n            if 0<=idx<len(cumset):\\n                maxsum=max(maxsum,cursum-cumset[idx])\\n            # using insort instead of append since bisect_left reason\\n            bisect.insort(cumset,cursum)\\n        return maxsum\\n    \\n    \\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \"\"\"\\n        The python solution hasn't a good time performance,\\n        since lack some of the datatype to do \\n        I am trying to imitate the way solved in c++ or Java\\n        Ther related quesiton might be:\\n        1. #53. Maximum Subarray \\n        2. Maximum Subarray sum less or equal than K\\n        3. maximun sum of rectangle \\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return 0\\n        row,col=len(matrix),len(matrix[0])\\n        res=-(1<<32)\\n        # using two pointer to record the scan position\\n        for left in xrange(col):\\n            # reset mem to store the row data\\n            cursums=[0 for _ in xrange(row)]\\n            # since the rectange has area>0 \\n            right=left\\n            while right<col:\\n                # count one row\\n                for i in xrange(row):\\n                    cursums[i]+=matrix[i][right]\\n                # find the max in this row\\n                curarrmax=self.maxSubArraylessK(cursums,k)\\n                res=max(res,curarrmax)\\n                right+=1\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n def maxSubArraylessK(self,nums,k):\\n        \"\"\"\\n        we need to find the sum[right]-sum[left]<=k\\n        since the bitsect return the index of the sorted value\\n        we can't directly pop the nums[idx] \\n        we should use insort from the bisect\\n        \"\"\"\\n        # python set() doesn't support indexing, using list instead\\n        # similar as the c++ or java set()\\n        \\n        cumset=[]\\n        cumset.append(0)\\n        maxsum=-1<<32\\n        cursum=0\\n        for i in xrange(len(nums)):\\n            cursum+=nums[i]\\n            # find the lower bound of the index\\n            idx=bisect.bisect_left(cumset,cursum-k)\\n            # find max in sum[right]-sum[left]<=k\\n            if 0<=idx<len(cumset):\\n                maxsum=max(maxsum,cursum-cumset[idx])\\n            # using insort instead of append since bisect_left reason\\n            bisect.insort(cumset,cursum)\\n        return maxsum\\n    \\n    \\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \"\"\"\\n        The python solution hasn't a good time performance,\\n        since lack some of the datatype to do \\n        I am trying to imitate the way solved in c++ or Java\\n        Ther related quesiton might be:\\n        1. #53. Maximum Subarray \\n        2. Maximum Subarray sum less or equal than K\\n        3. maximun sum of rectangle \\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return 0\\n        row,col=len(matrix),len(matrix[0])\\n        res=-(1<<32)\\n        # using two pointer to record the scan position\\n        for left in xrange(col):\\n            # reset mem to store the row data\\n            cursums=[0 for _ in xrange(row)]\\n            # since the rectange has area>0 \\n            right=left\\n            while right<col:\\n                # count one row\\n                for i in xrange(row):\\n                    cursums[i]+=matrix[i][right]\\n                # find the max in this row\\n                curarrmax=self.maxSubArraylessK(cursums,k)\\n                res=max(res,curarrmax)\\n                right+=1\\n                \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2488882,
                "title": "solution-in-python",
                "content": "The bisect_left() method is provided by the bisect module, which returns the left-most index to insert the given element, while maintaining the sorted order.\\nThe insort function is the second step that does the real insertion process. The function returns the list after the element has been inserted in the rightmost index without altering the sorted order.\\n\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        ans = float(\"-inf\")\\n        m, n = len(matrix), len(matrix[0])\\n        for i in range(n):\\n            lstSum = [0] * m\\n            for j in range(i, n):\\n                currSum = 0\\n                curlstSum = [0]\\n                for t in range(m):\\n                    lstSum[t] += matrix[t][j]\\n                    currSum += lstSum[t]\\n                    pos = bisect_left(curlstSum, currSum - k)\\n                    if pos < len(curlstSum):\\n                        if curlstSum[pos] == currSum - k:\\n                            return k\\n                        else:\\n                            ans = max(ans, currSum - curlstSum[pos])\\n                    insort(curlstSum, currSum)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        ans = float(\"-inf\")\\n        m, n = len(matrix), len(matrix[0])\\n        for i in range(n):\\n            lstSum = [0] * m\\n            for j in range(i, n):\\n                currSum = 0\\n                curlstSum = [0]\\n                for t in range(m):\\n                    lstSum[t] += matrix[t][j]\\n                    currSum += lstSum[t]\\n                    pos = bisect_left(curlstSum, currSum - k)\\n                    if pos < len(curlstSum):\\n                        if curlstSum[pos] == currSum - k:\\n                            return k\\n                        else:\\n                            ans = max(ans, currSum - curlstSum[pos])\\n                    insort(curlstSum, currSum)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741420,
                "title": "java-3ms-beats-100-no-binary-search-no-treeset",
                "content": "The basic idea is to use one 1-d array to record all possible area values every time we go through the matrix for every possible rectangle, and try to find the value we want. Every time we find a value which equals to k, we can just return it.\\n\\nWe do the outer loop column by column, and the inner loop row by row to find all possible rectangle.\\n\\nLet\\'s say we have a matrix as below:\\n\\n1  2  3\\n4  5  6\\n7  8  9\\n\\nWe start from column 0  and we are at column 1 now (the bold part). sum[i] means the accumulative area value for the i + 1 row.\\n**1**  **2**  3   ... sum[0] = 1 + 2 = 3\\n**4**  **5**  6   ... sum[1] = 4 + 5 = 9\\n**7**  **8**  9   ... sum[2] = 7 + 8 = 15\\n\\nThen we can try to find the result in the sum array by checking its subarray starting from sum[0]. It would give us the potential possible largest result. \\n\\n```\\nint curr = 0;\\nint max = sum[0];\\nfor (int n : sum) {\\n      curr = Math.max(n, curr + n);\\n      max = Math.max(curr, max);\\n      if (max == k) return max;\\n}\\n```\\n\\nIf max is smaller than k, the result would be the larger one between max and res. (we can prove that the current max is the largest possible result for the current rectangle we are at now (the bold part), there is no need to check it row by row). \\n\\nIf max is lager than k, it means we have to check the rectangle (the bold part as below) row by row.  (Actually we can just do this part to find the result directly but if we check the largest possible value from sum[0] first we can save like 50% time.)\\n\\n**1**  **2**   ... row 0\\n**4**  **5**   ... row 1\\n**7**  **8**   ... row 2\\n\\nCheck row0, row0 + row1, row0 + row1 + row2, row1, row1 + row2, row2. \\n\\nHope it could help.\\n\\n```\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n     \\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < col; i++) {\\n            int[] sum = new int[row];\\n            for (int j = i; j < col; j++) {\\n                for (int r = 0; r < row; r++) {\\n                    sum[r] += matrix[r][j];\\n                }\\n                int curr = 0;\\n                int max = sum[0];\\n                for (int n : sum) {\\n                    curr = Math.max(n, curr + n);\\n                    max = Math.max(curr, max);\\n                    if (max == k) return max;\\n                }\\n                if (max < k) {\\n                    res = Math.max(max, res);\\n                } else {\\n                    for (int a = 0; a < row; a++) {\\n                        int currSum = 0;\\n                        for (int b = a; b < row; b++) {\\n                            currSum += sum[b];\\n                            if (currSum <= k) res = Math.max(currSum, res);\\n                        }\\n                    }\\n                    if (res == k) return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\nint curr = 0;\\nint max = sum[0];\\nfor (int n : sum) {\\n      curr = Math.max(n, curr + n);\\n      max = Math.max(curr, max);\\n      if (max == k) return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739739,
                "title": "javascript-clean-dp-solution",
                "content": "Time Complexity: where `R` - num of Rows, `C` - num of Cols\\n* Average: `O(R^2 * C)` when kadane\\'s `max` <= `k`\\n* Worst: `O(R^2 * C^2)` when kadane\\'s `max` >`k`\\n\\n```javascript\\nvar maxSumSubmatrix = function(matrix, k) {\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    let maxSum = -Infinity;\\n    \\n    for(let l = 0; l < R_NUM; l++) {\\n        const dp = Array(C_NUM).fill(0);\\n        \\n        for(let r = l; r < R_NUM; r++) {\\n            let sum = 0, max = -Infinity;\\n            \\n            for(let c = 0; c < C_NUM; c++) {\\n                // build running dp array\\n                dp[c] += matrix[r][c];\\n                \\n                // implement kadane\\'s algorithm\\n                if(sum < 0) sum = 0;\\n                sum += dp[c];\\n                max = Math.max(max, sum);\\n            }\\n            \\n            // if max <= k take kadane\\'s algorithm\\n            if(max <= k) maxSum = Math.max(max, maxSum);\\n            else {\\n                // if max > k find the max subarray sum no larger than k\\n                max = -Infinity;\\n\\n                for(let c = 0; c < C_NUM; c++) {\\n                    sum = 0;\\n\\n                    for(let d = c; d < C_NUM; d++) {\\n                        sum += dp[d];\\n                        if(sum <= k) max = Math.max(sum, max);\\n                    }\\n                }\\n                maxSum = Math.max(max, maxSum);\\n            }\\n            if(maxSum === k) return k; // short circuit\\n        }\\n    }\\n    return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar maxSumSubmatrix = function(matrix, k) {\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    let maxSum = -Infinity;\\n    \\n    for(let l = 0; l < R_NUM; l++) {\\n        const dp = Array(C_NUM).fill(0);\\n        \\n        for(let r = l; r < R_NUM; r++) {\\n            let sum = 0, max = -Infinity;\\n            \\n            for(let c = 0; c < C_NUM; c++) {\\n                // build running dp array\\n                dp[c] += matrix[r][c];\\n                \\n                // implement kadane\\'s algorithm\\n                if(sum < 0) sum = 0;\\n                sum += dp[c];\\n                max = Math.max(max, sum);\\n            }\\n            \\n            // if max <= k take kadane\\'s algorithm\\n            if(max <= k) maxSum = Math.max(max, maxSum);\\n            else {\\n                // if max > k find the max subarray sum no larger than k\\n                max = -Infinity;\\n\\n                for(let c = 0; c < C_NUM; c++) {\\n                    sum = 0;\\n\\n                    for(let d = c; d < C_NUM; d++) {\\n                        sum += dp[d];\\n                        if(sum <= k) max = Math.max(sum, max);\\n                    }\\n                }\\n                maxSum = Math.max(max, maxSum);\\n            }\\n            if(maxSum === k) return k; // short circuit\\n        }\\n    }\\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298524,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 1; j < m; j++)\\n            {\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = i; j < m; j++)\\n            {\\n                int rowsum = 0;\\n                set<int> tmp = {0};\\n                for(int f = 0; f < n; f++)\\n                {\\n                    rowsum += matrix[f][j];\\n                    if(i > 0)\\n                        rowsum -= matrix[f][i-1];\\n                    auto lb = tmp.lower_bound(rowsum-k);\\n                    if(lb != tmp.end())\\n                        ans = max(ans, rowsum-*lb);\\n                    tmp.insert(rowsum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 1; j < m; j++)\\n            {\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = i; j < m; j++)\\n            {\\n                int rowsum = 0;\\n                set<int> tmp = {0};\\n                for(int f = 0; f < n; f++)\\n                {\\n                    rowsum += matrix[f][j];\\n                    if(i > 0)\\n                        rowsum -= matrix[f][i-1];\\n                    auto lb = tmp.lower_bound(rowsum-k);\\n                    if(lb != tmp.end())\\n                        ans = max(ans, rowsum-*lb);\\n                    tmp.insert(rowsum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665160,
                "title": "java-treeset-solution-with-m-m-nlog-n-time",
                "content": "First, let us simplify the problem, imagine this is a single - row matrix, which is equivalent to 1D array. How do we find the max subarray such that its sum is no larger than k? If all elements are non-negative, the problem can be much easier, \\u201Csliding window\\u201D could be a good start. However, there are negative elements as well. Accordingly, there is no fixed window or fixed amount we could refer to. When we do not know how to approach a problem, we can always start from a brute force solution.\\ncheck out my youtube link right here: https://youtu.be/gD4dzeQ6YH0\\n\\nBrute force :\\n\\tget all possible subarrays, and sum each respectively to find the closest sum to k.\\n\\tO(n^3)\\nMore optimized:\\n\\tTo avoid sum up subarrays multiple times, we can use prefixSum.\\n\\tO(n^2)\\nFurther optimized:\\n\\tprefixSum - x <= k\\n\\tx >= prefixSum - k\\nwe are looking for a previous prefixSum that is smallest larger or equal to \\u201CprefixSum - k\\u201D\\nTreeSet can help us with the implementation.\\nO(nlog(n)\\n\\t\\nNow, let\\'s come back to a 2D matrix. To convert it to a 1D array, we use a double for loop to get all possible consecutive-rows combinations and add them up. The rest is just the same as what we did for 1D array. If \\u201Cm\\u201D represents total rows, \\u201Cn\\u201D represents total cols, the time complexity is O(m * m * nlog(n)).\\n\\n```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length;\\n        \\n        int max = Integer.MIN_VALUE;\\n        // step 1\\n        for (int i = 0; i < m; i++) {\\n            int[] add = new int[n];\\n            for (int j = i; j < m; j++) {\\n                sum(add, matrix[j]);\\n                \\n                TreeSet<Integer> treeset = new TreeSet<>();\\n                max = Math.max(max, helper(add, treeset, k));\\n                if (max == k) {\\n                    return max;\\n                }\\n            }\\n        }\\n        return max == Integer.MIN_VALUE ? -1 : max;\\n    }\\n    private int helper(int[] add, TreeSet<Integer> treeset, int k) {\\n        treeset.add(0);\\n        int prefixSum = 0;\\n        int curMax = Integer.MIN_VALUE;\\n        for (int ele : add) {\\n            prefixSum += ele;\\n            Integer ceil = treeset.ceiling(prefixSum - k);\\n            if (ceil != null) {\\n                if (prefixSum - ceil == k) {\\n                    return k;\\n                } else {\\n                    curMax = Math.max(curMax, prefixSum - ceil);\\n                }\\n            }\\n            treeset.add(prefixSum);\\n        }\\n        return curMax;\\n    }\\n    private void sum(int[] add, int[] cols) {\\n        for (int i = 0; i < cols.length; i++){\\n            add[i] += cols[i];\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length;\\n        \\n        int max = Integer.MIN_VALUE;\\n        // step 1\\n        for (int i = 0; i < m; i++) {\\n            int[] add = new int[n];\\n            for (int j = i; j < m; j++) {\\n                sum(add, matrix[j]);\\n                \\n                TreeSet<Integer> treeset = new TreeSet<>();\\n                max = Math.max(max, helper(add, treeset, k));\\n                if (max == k) {\\n                    return max;\\n                }\\n            }\\n        }\\n        return max == Integer.MIN_VALUE ? -1 : max;\\n    }\\n    private int helper(int[] add, TreeSet<Integer> treeset, int k) {\\n        treeset.add(0);\\n        int prefixSum = 0;\\n        int curMax = Integer.MIN_VALUE;\\n        for (int ele : add) {\\n            prefixSum += ele;\\n            Integer ceil = treeset.ceiling(prefixSum - k);\\n            if (ceil != null) {\\n                if (prefixSum - ceil == k) {\\n                    return k;\\n                } else {\\n                    curMax = Math.max(curMax, prefixSum - ceil);\\n                }\\n            }\\n            treeset.add(prefixSum);\\n        }\\n        return curMax;\\n    }\\n    private void sum(int[] add, int[] cols) {\\n        for (int i = 0; i < cols.length; i++){\\n            add[i] += cols[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488679,
                "title": "explanation-and-example-for-the-binary-search-part",
                "content": "This problem can be solved by combining (1) Kadane\\'s algorithm, and (2) binary search.\\n\\nMany have talked about (1) the Kadane\\'s part.\\n\\nFor people who stumbled on the (2) binary search part below, here is some explanation and example.\\n\\nI am going to explain\\n\\n```c++\\n// vector<int> sums is the vector for the sums of each rows\\n// int res is our desired result\\n\\nset<int> s{0};\\nint cumsum = 0;\\nfor (int x : sums) {\\n\\tcumsum += x;\\n\\tconst auto it = s.lower_bound(cumsum - k);\\n\\tif (it != s.cend()) {\\n\\t\\tres = std::max(res, cumsum - *it);\\n\\t}\\n\\ts.insert(cumsum);\\n}\\n```\\n\\nGiven `k = 6` and\\n\\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n```\\n\\nour goal is to update `res` with the max subarray sum in `[ 5 8 -6 4 ]` whose value is no greater than `k=6`.\\n\\nNote that we can\\'t directly apply Kadane\\'s algorithm here, because we have a constraint.\\n\\nThe above algorithm works out the `cumsum` one by one, and each time adds one cumsum to a set.\\n\\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n cumsums    5    13   7   11\\n```\\n\\nNote that\\n\\n```\\nsubarray_sum in (a, b] = cumsums[b] - cumsums[a]\\n```\\n\\nGiven `b` and `k`, we would like to find the largest `subarray_sum in (a,b]`  such that\\n\\n```\\nsubarray_sum in (a,b] <= k\\n```\\n\\nor\\n\\n```\\ncumsums[b] - cumsums[a] <= k\\n```\\n\\nwhich is to find a smallest `cumsums[a]` such that\\n\\n```\\ncumsums[a] >= cumsums[b] - k\\n```\\n\\nand this is to find the smallest previous cumsum that is greater than or equal to `cumsums[b] - k`, which is the lower bound.\\n\\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n cumsums    5    13   7   11\\n```\\n\\nFor example, when we are at index `3`, our set is `{0, 5, 13, 7}`, and we want to find the smallest item in this set that greater than or equal to `cumsums[b] - k = 11 - 6 = 5`. So we got `cumsums[a] = 5` from our set. So we can update `res` with max subarray sum `cumsums[b] - cumsums[a] = 11 - 5 = 6`.\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```c++\\n// vector<int> sums is the vector for the sums of each rows\\n// int res is our desired result\\n\\nset<int> s{0};\\nint cumsum = 0;\\nfor (int x : sums) {\\n\\tcumsum += x;\\n\\tconst auto it = s.lower_bound(cumsum - k);\\n\\tif (it != s.cend()) {\\n\\t\\tres = std::max(res, cumsum - *it);\\n\\t}\\n\\ts.insert(cumsum);\\n}\\n```\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n```\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n cumsums    5    13   7   11\\n```\n```\\nsubarray_sum in (a, b] = cumsums[b] - cumsums[a]\\n```\n```\\nsubarray_sum in (a,b] <= k\\n```\n```\\ncumsums[b] - cumsums[a] <= k\\n```\n```\\ncumsums[a] >= cumsums[b] - k\\n```\n```\\n   index    0    1    2    3\\n    sums    5    8   -6    4\\n cumsums    5    13   7   11\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2088522,
                "title": "java-prefix-sum-bottom-right-rectangles-with-explanation-and-comments",
                "content": "**Intuition**: There are probably too many rectangles (and thus too many cells to add) to brute force this.  But if we can speed up the computation of the sum of a given rectangle, then can we expect to reach an answer without TLE?  We can get a sense of this from the limits.  The max width and height of the matrix are both 100.  Let\\'s take these maxima as the worst case.  So we have 100 choices of starting row and thus 100x101/2 choices of starting row and height.  Similarly, we have 100x101/2 choices for starting column and width.  So we have 25502500 total rectangles to compute in the worst case.  This is about 2.5x10^7.  If we can keep the computation of each rectangle O[1] then we\\'ll have O\\\\[m^2 n^2\\\\] for our overall runtime.  What if we track the bottom right sums of the complete rectangles (ending at height-1, width-1, inclusive) at a given (r0, c0)?  (This is actually more of a suffix sum than a prefix sum, but let\\'s see where it goes.)  Then, we have a way to compute the sum of a rectangle (r0, c0, rf, cf).  (Here, `r0` means initial (top) row, `rf` = final (bottom) row, `c0` = initial (left) column and `cf` = final (right) column).  We can visualize this to see it:\\n\\n```\\n     (r0, c0)                  (r0, cf+1)          (r0, width)\\n\\t          +--------------------------+--------------------+\\n\\t\\t\\t  |                          |                    |\\n\\t\\t\\t  |           (A)            |        (B)         |\\n\\t\\t\\t  |     target rectangle     |  right rectangle   |\\n\\t\\t\\t  |                          |                    |\\n  (rf+1, c0)  |             (rf+1, cf+1) |      (rf+1, width) |\\n\\t          +--------------------------+--------------------+\\n\\t\\t\\t  |                          |                    |\\n\\t\\t\\t  |           (C)            |        (D)         |\\n\\t\\t\\t  |     lower rectangle      |  lower-right rect. |\\n\\t\\t\\t  |                          |                    |\\n (height, c0) |           (height, cf+1) |    (height, width) |\\n\\t\\t\\t  +--------------------------+--------------------+\\n```\\n\\nThe entire rectangle (r0, c0, height, width) is comprised of four inner rectangles.  And if we precompute the entire rectangles (\\\\*, \\\\*, height, width) then we can say that:\\n\\ntarget rectangle = (r0, c0, height, width) - (r0, cf+1, height, width) - (rf+1, c0, height, width) + (rf+1, cf+1, height, width)\\n\\nNote that we are adding in the lower-right rectangle again because we have subtracted it away twice, so we add it back in to ensure our sum is correct.\\n\\nSo, we can see, if we precompute the sum for every rectangle (\\\\*, \\\\*, height, width), we can compute the sum of every rectangle (\\\\*, \\\\*, \\\\*, \\\\*) with two subtractions and an addition.  This keeps us under 10^8 operations and might be fast enough to complete within the time limit.\\n\\n**Buillding up the  bottom-right sums**:  We take advantage of the same identity, building the sum up from m, n right-to-left and bottom-to-top.  We\\'ll use a sum matrix of size \\\\[m+1\\\\]\\\\[n+1\\\\] in order to have zeros at the extremes and not worry about range checking in our sums matrix.  If our matrix name for sums is `brsum` for \"bottom-right sum\", and if we notice that our new sum at (r, c) is the value at (r, c) plus the sum to the right, plus the sum below, minus the sum below-and-right (we have to subtract it because it got added twice), we have\\n```\\n    brsum[r][c] = matrix[r][c] + brsum[r][c + 1] + brsum[r + 1][c] - brsum[r + 1][c + 1];\\n```\\n\\n**Optimizations**: First, if we encounter the value k in the matrix at (r, c), then we have a 1x1 rectangle with sum k - this means our answer is k and we can simply return early.  Second, as we are computing all sums for all possible rectangles, if we encounter k as a rectangle sum, we can also return early, as there is no way to improve upon this.\\n\\n**Code**: O\\\\[m\\\\*n\\\\] space, O\\\\[m^2\\\\*n^2\\\\] time.  Runtimes around ~230ms plus or minus 20ms, faster than about 75 or 80% as of May 2022.  Not the most optimal algorithm, but completes well within the time limit.\\n\\n```\\nclass Solution {\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        final int m = matrix.length;\\n        if (m < 1) {\\n            throw new IllegalArgumentException(\"empty matrix - no rows\");\\n        }\\n        final int n = matrix[0].length;\\n        if (n < 1) {\\n            throw new IllegalArgumentException(\"empty matrix - no columns\");\\n        }\\n        // Let\\'s make our bottom-right sum matrix wider and higher by 1 each, so we don\\'t go out of range.\\n        // All of the values r >= m and c >= n should be 0 (and will default to 0 during array construction).\\n        final int[][] brsum = new int[m + 1][n + 1];\\n        // Build up from bottom right, bottom to top and right to left.\\n        for (int r = (m - 1); r >= 0; --r) {\\n            for (int c = (n - 1); c >= 0; --c) {\\n                final int val = matrix[r][c];\\n                // did we happen to find a 1x1 rectangle at (r, c) which sums to k?\\n                if (val == k) {\\n                    return val;\\n                }\\n                // Extend the sum: value + right + down - rightAndDown (because rightAndDown was added twice)\\n                brsum[r][c] = matrix[r][c] + brsum[r][c + 1] + brsum[r + 1][c] - brsum[r + 1][c + 1];\\n            }\\n        }\\n        // Now, we search.\\n        int maxSum = Integer.MIN_VALUE;\\n        for (int r0 = 0; r0 < m; ++r0) {\\n            for (int rf = r0; rf < m; ++rf) {\\n                final int rfp1 = rf + 1; // Let\\'s avoid computing rf + 1 many times.\\n                for (int c0 = 0; c0 < n; ++c0) {\\n                    for (int cf = c0; cf < n; ++cf) {\\n                        final int cfp1 = cf + 1; // Let\\'s avoid computing cf + 1 multiple times.\\n\\t\\t\\t\\t\\t\\t// Compute the sum for this rectangle: complete - right - lower + lower_right.\\n                        final int sum = brsum[r0][c0] + brsum[rfp1][cfp1] - brsum[r0][cfp1] - brsum[rfp1][c0];\\n\\t\\t\\t\\t\\t\\t// Did we happen to find a sum adding to k?  If not, did we find a larger sum less than k?\\n                        if (sum == k) {\\n                            return sum;\\n                        } else if (sum < k && sum > maxSum) {\\n                            maxSum = sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n\\n}\\n```\\n\\n**Note**: Could we go faster with other approaches?  Yes, we could, if the effort is worth the runtime reduction.  But my goal for this solution was to find something we could be expected to remember (or develop easily from first principles) and implement quickly and accurately, which handles the constraints we are given, including time.  As someone who hires engineers and engineering managers, I would be quite satisfied with this approach combined with a mention that Kadane\\'s algorithm could probably be used to go faster, but some research and experimentation would be necessary.  In the information age, I don\\'t think we need to memorize everything.  Knowing things exist and being able to assimilate new information is often more than sufficient.  And sometimes understanding when perfect is the enemy of good is a useful skill.\\n\\n**Standard Plea**: If this solution and explanation were helpful or at least didn\\'t waste your time, I\\'d **appreciate your upvote**.  If not, or if you disagree with my point of view (regarding good vs perfect or memorizing things), I would **welcome your comments and/or constructive criticism**.\\n\\nThanks for reading, and happy coding!\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n     (r0, c0)                  (r0, cf+1)          (r0, width)\\n\\t          +--------------------------+--------------------+\\n\\t\\t\\t  |                          |                    |\\n\\t\\t\\t  |           (A)            |        (B)         |\\n\\t\\t\\t  |     target rectangle     |  right rectangle   |\\n\\t\\t\\t  |                          |                    |\\n  (rf+1, c0)  |             (rf+1, cf+1) |      (rf+1, width) |\\n\\t          +--------------------------+--------------------+\\n\\t\\t\\t  |                          |                    |\\n\\t\\t\\t  |           (C)            |        (D)         |\\n\\t\\t\\t  |     lower rectangle      |  lower-right rect. |\\n\\t\\t\\t  |                          |                    |\\n (height, c0) |           (height, cf+1) |    (height, width) |\\n\\t\\t\\t  +--------------------------+--------------------+\\n```\n```\\n    brsum[r][c] = matrix[r][c] + brsum[r][c + 1] + brsum[r + 1][c] - brsum[r + 1][c + 1];\\n```\n```\\nclass Solution {\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        final int m = matrix.length;\\n        if (m < 1) {\\n            throw new IllegalArgumentException(\"empty matrix - no rows\");\\n        }\\n        final int n = matrix[0].length;\\n        if (n < 1) {\\n            throw new IllegalArgumentException(\"empty matrix - no columns\");\\n        }\\n        // Let\\'s make our bottom-right sum matrix wider and higher by 1 each, so we don\\'t go out of range.\\n        // All of the values r >= m and c >= n should be 0 (and will default to 0 during array construction).\\n        final int[][] brsum = new int[m + 1][n + 1];\\n        // Build up from bottom right, bottom to top and right to left.\\n        for (int r = (m - 1); r >= 0; --r) {\\n            for (int c = (n - 1); c >= 0; --c) {\\n                final int val = matrix[r][c];\\n                // did we happen to find a 1x1 rectangle at (r, c) which sums to k?\\n                if (val == k) {\\n                    return val;\\n                }\\n                // Extend the sum: value + right + down - rightAndDown (because rightAndDown was added twice)\\n                brsum[r][c] = matrix[r][c] + brsum[r][c + 1] + brsum[r + 1][c] - brsum[r + 1][c + 1];\\n            }\\n        }\\n        // Now, we search.\\n        int maxSum = Integer.MIN_VALUE;\\n        for (int r0 = 0; r0 < m; ++r0) {\\n            for (int rf = r0; rf < m; ++rf) {\\n                final int rfp1 = rf + 1; // Let\\'s avoid computing rf + 1 many times.\\n                for (int c0 = 0; c0 < n; ++c0) {\\n                    for (int cf = c0; cf < n; ++cf) {\\n                        final int cfp1 = cf + 1; // Let\\'s avoid computing cf + 1 multiple times.\\n\\t\\t\\t\\t\\t\\t// Compute the sum for this rectangle: complete - right - lower + lower_right.\\n                        final int sum = brsum[r0][c0] + brsum[rfp1][cfp1] - brsum[r0][cfp1] - brsum[rfp1][c0];\\n\\t\\t\\t\\t\\t\\t// Did we happen to find a sum adding to k?  If not, did we find a larger sum less than k?\\n                        if (sum == k) {\\n                            return sum;\\n                        } else if (sum < k && sum > maxSum) {\\n                            maxSum = sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314266,
                "title": "c-yet-another-kadane-algorithm-solution",
                "content": "As many have pointed out, consider each pair of left column `l` and right `r`.\\nTry to compute a cumulative sum across rows.\\nIf there is no the `k` contraint, a plain Kadane algorithm would suffice.\\nSince the result needs to be no larger than `k`, a binary search is needed for the most general case.\\nHowever, Kadane algorithm can still be used to bypass the binary search in some cases.\\n\\nAs of 7/3/2021, this soultion runs for ~500ms. It looks like new test cases have been added.\\nTime complexity `O(n^2 * m * log(m))`\\nSpace comlexity `O(m)`\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int res = INT_MIN;\\n        vector<int> row_sum(m, 0);\\n        for (int l = 0; l < n; ++l)\\n        {\\n            fill(row_sum.begin(), row_sum.end(), 0);\\n            for (int r = l; r < n; ++r)\\n            {\\n                // Kadane algorithm for a possible shortcut to next iteration or even an early return\\n                int cur_sum = 0, best_sum = INT_MIN;\\n                for (int i = 0; i < m; ++i)\\n                {\\n                    row_sum[i] += matrix[i][r];\\n                    if (cur_sum < 0)\\n                        cur_sum = row_sum[i];\\n                    else\\n                        cur_sum += row_sum[i];\\n                    best_sum = max(best_sum, cur_sum);\\n                }\\n                if (best_sum == k)\\n                    return k;\\n                else if (best_sum < k)\\n                {\\n                    res = max(res, best_sum);\\n                    continue;\\n                }\\n                // Otherwise, try binary search of running sums\\n                cur_sum = 0;\\n                set<int> s{0};\\n                for (auto& sum: row_sum)\\n                {\\n                    cur_sum += sum;\\n                    auto it = s.lower_bound(cur_sum - k);\\n                    if (it != s.end())\\n                        res = max(res, cur_sum - *it);\\n                    if (res == k)\\n                        return k;\\n                    s.insert(cur_sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int res = INT_MIN;\\n        vector<int> row_sum(m, 0);\\n        for (int l = 0; l < n; ++l)\\n        {\\n            fill(row_sum.begin(), row_sum.end(), 0);\\n            for (int r = l; r < n; ++r)\\n            {\\n                // Kadane algorithm for a possible shortcut to next iteration or even an early return\\n                int cur_sum = 0, best_sum = INT_MIN;\\n                for (int i = 0; i < m; ++i)\\n                {\\n                    row_sum[i] += matrix[i][r];\\n                    if (cur_sum < 0)\\n                        cur_sum = row_sum[i];\\n                    else\\n                        cur_sum += row_sum[i];\\n                    best_sum = max(best_sum, cur_sum);\\n                }\\n                if (best_sum == k)\\n                    return k;\\n                else if (best_sum < k)\\n                {\\n                    res = max(res, best_sum);\\n                    continue;\\n                }\\n                // Otherwise, try binary search of running sums\\n                cur_sum = 0;\\n                set<int> s{0};\\n                for (auto& sum: row_sum)\\n                {\\n                    cur_sum += sum;\\n                    auto it = s.lower_bound(cur_sum - k);\\n                    if (it != s.end())\\n                        res = max(res, cur_sum - *it);\\n                    if (res == k)\\n                        return k;\\n                    s.insert(cur_sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521118,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func maxSumSubmatrix(_ matrix: [[Int]], _ k: Int) -> Int {\\n        var res = Int.min\\n        let m = matrix.count\\n        let n = matrix[0].count\\n        \\n        \\n        for left in 0..<n {\\n            var rowsSum = [Int](repeating: 0, count: m)\\n            for right in left..<n {\\n                \\n                for row in 0..<m {\\n                    rowsSum[row] += matrix[row][right]\\n                }\\n                res = max(countSubarraysSmallerThenK(rowsSum, k), res)\\n            }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func countSubarraysSmallerThenK(_ arr: [Int], _ k: Int) -> Int {\\n        var res = Int.min\\n        \\n        for i in 0..<arr.count {\\n            var sum = 0\\n            for j in i..<arr.count {\\n                sum += arr[j]\\n                if sum > res && sum <= k {\\n                    res = sum\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```\\n\\nSpace complexity is O(m)\\nTime complexity is 0(m*n\\u02C63)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maxSumSubmatrix(_ matrix: [[Int]], _ k: Int) -> Int {\\n        var res = Int.min\\n        let m = matrix.count\\n        let n = matrix[0].count\\n        \\n        \\n        for left in 0..<n {\\n            var rowsSum = [Int](repeating: 0, count: m)\\n            for right in left..<n {\\n                \\n                for row in 0..<m {\\n                    rowsSum[row] += matrix[row][right]\\n                }\\n                res = max(countSubarraysSmallerThenK(rowsSum, k), res)\\n            }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func countSubarraysSmallerThenK(_ arr: [Int], _ k: Int) -> Int {\\n        var res = Int.min\\n        \\n        for i in 0..<arr.count {\\n            var sum = 0\\n            for j in i..<arr.count {\\n                sum += arr[j]\\n                if sum > res && sum <= k {\\n                    res = sum\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487685,
                "title": "simple-python-solution",
                "content": "```\\nimport bisect\\nimport sys\\n\\n\\nclass Solution:\\n    \\n    # Overall complexity O(n^4)\\n    def maxSumSubmatrix(self, matrix, k):\\n\\n        # Validation for corner case.\\n        if not matrix:\\n            return 0\\n\\n        # Traditional kadane algorithm does not work \\n        # here, as that algorithm always finds max sum\\n        # in a sub array and disregards intermediate sums\\n        # which needs to be considered for evaluating <=k criteria. \\n        #\\n        # Below function stores prefix sum values\\n        # in a sorted list and performs binary \\n        # search on this list to get the closest\\n        # element whose difference with current element\\n        # does not exceed k. \\n        # Complexity for this algorithm is O(n^2)\\n        def max_sum_array_no_larger_than_k(l, k):\\n            prefix_sums = [0]\\n            prefix_sum, max_sum = 0, -sys.maxsize\\n            for item in l:\\n                prefix_sum += item\\n                \\n                left = bisect.bisect_left(prefix_sums, prefix_sum - k)\\n                if left < len(prefix_sums):\\n                    max_sum = max(max_sum, prefix_sum - prefix_sums[left])\\n                   \\n               # This has a worst case complexity of O(n) \\n                bisect.insort(prefix_sums, prefix_sum)\\n            return max_sum\\n\\n        row_len = len(matrix)\\n        col_len = len(matrix[0])\\n        max_sum = -sys.maxsize\\n        \\n        # Below loops basically fold 2-d array into \\n        # a single dimensional array, so that above \\n        # function can be applied to it.\\n        # Here we iterate through all possible 2-d\\n        # arrays possible for every column. \\n        for from_col in range(col_len):\\n            col_values = [0 for _ in range(row_len)]\\n            for to_col in range(from_col, col_len):\\n                for row in range(row_len):\\n                    col_values[row] = col_values[row] + matrix[row][to_col]\\n                curr_sum = max_sum_array_no_larger_than_k(col_values, k)\\n                max_sum = max(curr_sum, max_sum)\\n        return max_sum\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\nimport sys\\n\\n\\nclass Solution:\\n    \\n    # Overall complexity O(n^4)\\n    def maxSumSubmatrix(self, matrix, k):\\n\\n        # Validation for corner case.\\n        if not matrix:\\n            return 0\\n\\n        # Traditional kadane algorithm does not work \\n        # here, as that algorithm always finds max sum\\n        # in a sub array and disregards intermediate sums\\n        # which needs to be considered for evaluating <=k criteria. \\n        #\\n        # Below function stores prefix sum values\\n        # in a sorted list and performs binary \\n        # search on this list to get the closest\\n        # element whose difference with current element\\n        # does not exceed k. \\n        # Complexity for this algorithm is O(n^2)\\n        def max_sum_array_no_larger_than_k(l, k):\\n            prefix_sums = [0]\\n            prefix_sum, max_sum = 0, -sys.maxsize\\n            for item in l:\\n                prefix_sum += item\\n                \\n                left = bisect.bisect_left(prefix_sums, prefix_sum - k)\\n                if left < len(prefix_sums):\\n                    max_sum = max(max_sum, prefix_sum - prefix_sums[left])\\n                   \\n               # This has a worst case complexity of O(n) \\n                bisect.insort(prefix_sums, prefix_sum)\\n            return max_sum\\n\\n        row_len = len(matrix)\\n        col_len = len(matrix[0])\\n        max_sum = -sys.maxsize\\n        \\n        # Below loops basically fold 2-d array into \\n        # a single dimensional array, so that above \\n        # function can be applied to it.\\n        # Here we iterate through all possible 2-d\\n        # arrays possible for every column. \\n        for from_col in range(col_len):\\n            col_values = [0 for _ in range(row_len)]\\n            for to_col in range(from_col, col_len):\\n                for row in range(row_len):\\n                    col_values[row] = col_values[row] + matrix[row][to_col]\\n                curr_sum = max_sum_array_no_larger_than_k(col_values, k)\\n                max_sum = max(curr_sum, max_sum)\\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492107,
                "title": "easy-dp-beginner-level-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int tar) {\\n        int n=matrix.length,m=matrix[0].length,i,j,k,l,dp[][] = new int[n][m],val,max=Integer.MIN_VALUE,target=tar;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                dp[i][j]=matrix[i][j];\\n                if(j>0) dp[i][j]+=dp[i][j-1];\\n            }\\n        }\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(i>0) dp[i][j]+=dp[i-1][j];\\n            }\\n        }\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                for(k=i;k<n;k++){\\n                    for(l=j;l<m;l++){\\n                        val=dp[k][l];\\n                        if((i-1)>=0 && (j-1)>=0) val += dp[i-1][j-1];\\n                        if((i-1)>=0) val=val-dp[i-1][l];\\n                        if((j-1)>=0) val=val-dp[k][j-1];\\n                        if(val>max && val<=target) max=val;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int tar) {\\n        int n=matrix.length,m=matrix[0].length,i,j,k,l,dp[][] = new int[n][m],val,max=Integer.MIN_VALUE,target=tar;\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                dp[i][j]=matrix[i][j];\\n                if(j>0) dp[i][j]+=dp[i][j-1];\\n            }\\n        }\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(i>0) dp[i][j]+=dp[i-1][j];\\n            }\\n        }\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                for(k=i;k<n;k++){\\n                    for(l=j;l<m;l++){\\n                        val=dp[k][l];\\n                        if((i-1)>=0 && (j-1)>=0) val += dp[i-1][j-1];\\n                        if((i-1)>=0) val=val-dp[i-1][l];\\n                        if((j-1)>=0) val=val-dp[k][j-1];\\n                        if(val>max && val<=target) max=val;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488527,
                "title": "java-beats-100-32ms-kadane-s-algorithm-and-faster-approach-w-video-explanation",
                "content": "*Please **Upvote** if you find this explanation helpful*\\n\\n**Video Explanation**\\n[Max Sum of Rectangle No Larger Than K | YouTube](https://www.youtube.com/watch?v=rztZyG5kpvM&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//Kadane\\'s Algorithm Approach\\n//600ms+  explained in video\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int left =0 ;left<matrix[0].length; left++){\\n            \\n            int[] rSum = new int[matrix.length];\\n            \\n            for(int right = left;right<matrix[0].length;right++){\\n                for(int row=0; row < matrix.length; row++)\\n                    rSum[row] += matrix[row][right];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//explanation of these 3 loops starts from 02:00 in Video\\n                \\n                TreeSet<Integer> set = new TreeSet<>();\\n                \\n                set.add(0);\\n                int cs = 0;\\n                \\n                for(int a: rSum){\\n                    cs += a;\\n\\t\\t\\t\\t\\t\\n                    //if you don\\'t understand what exactly is going on here\\n\\t\\t\\t\\t\\t// then watch the video from 12:27\\n\\t\\t\\t\\t\\t\\n                    Integer target = set.ceiling(cs-k);\\n                    \\n                    if(target !=null)\\n                        result = Math.max(result,cs-target);\\n                    set.add(cs);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Faster Approach**\\n```\\n//32ms - faster than 100%\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (i > 0) {\\n                    matrix[i][j] += matrix[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    matrix[i][j] -= matrix[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        \\n        int[][] dpHigh = new int[matrix.length][matrix.length + 1];\\n        int[][] dpLow = new int[matrix.length][matrix.length + 1];\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int h = 1; h <= matrix.length - i; h++) {\\n                int theValue = getSum(matrix, i, matrix[0].length - 1, h, 1);\\n                dpLow[i][h] = theValue;\\n                dpHigh[i][h] = theValue;\\n                if (theValue == k) {\\n                    return theValue;\\n                }\\n                if (theValue < k) {\\n                    result = Math.max(result, theValue);\\n                }\\n            }\\n        }\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int j = matrix[0].length - 2; j >= 0; j--) {\\n                for (int h = 1; h <= matrix.length - i; h++) {\\n                    int newSum = getSum(matrix, i, j, h, 1);\\n                    if (dpLow[i][h] > 0) {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] = newSum;\\n                    } else if (dpHigh[i][h] < 0) {\\n                        dpLow[i][h] += newSum;\\n                        dpHigh[i][h] = newSum;\\n                    } else {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] += newSum;\\n                    }\\n                    if (dpHigh[i][h] >= result && dpLow[i][h] <= k) {\\n                        for (int w = 1; w <= matrix[0].length - j; w++) {\\n                            int sum = getSum(matrix, i, j, h, w);\\n                            if (sum == k) {\\n                                return sum;\\n                            } else if (sum < k) {\\n                                result = Math.max(result, sum);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int getSum(int[][] matrix, int i, int j, int h, int w) {\\n        int sum = matrix[i + h - 1][j + w - 1];\\n        if (i > 0) {\\n            sum -= matrix[i - 1][j + w - 1];\\n        }\\n        if (j > 0) {\\n            sum -= matrix[i + h - 1][j - 1];\\n        }\\n        if (i > 0 && j > 0) {\\n            sum += matrix[i - 1][j - 1];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\n//Kadane\\'s Algorithm Approach\\n//600ms+  explained in video\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int left =0 ;left<matrix[0].length; left++){\\n            \\n            int[] rSum = new int[matrix.length];\\n            \\n            for(int right = left;right<matrix[0].length;right++){\\n                for(int row=0; row < matrix.length; row++)\\n                    rSum[row] += matrix[row][right];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//explanation of these 3 loops starts from 02:00 in Video\\n                \\n                TreeSet<Integer> set = new TreeSet<>();\\n                \\n                set.add(0);\\n                int cs = 0;\\n                \\n                for(int a: rSum){\\n                    cs += a;\\n\\t\\t\\t\\t\\t\\n                    //if you don\\'t understand what exactly is going on here\\n\\t\\t\\t\\t\\t// then watch the video from 12:27\\n\\t\\t\\t\\t\\t\\n                    Integer target = set.ceiling(cs-k);\\n                    \\n                    if(target !=null)\\n                        result = Math.max(result,cs-target);\\n                    set.add(cs);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\n//32ms - faster than 100%\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (i > 0) {\\n                    matrix[i][j] += matrix[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    matrix[i][j] -= matrix[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        \\n        int[][] dpHigh = new int[matrix.length][matrix.length + 1];\\n        int[][] dpLow = new int[matrix.length][matrix.length + 1];\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int h = 1; h <= matrix.length - i; h++) {\\n                int theValue = getSum(matrix, i, matrix[0].length - 1, h, 1);\\n                dpLow[i][h] = theValue;\\n                dpHigh[i][h] = theValue;\\n                if (theValue == k) {\\n                    return theValue;\\n                }\\n                if (theValue < k) {\\n                    result = Math.max(result, theValue);\\n                }\\n            }\\n        }\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int j = matrix[0].length - 2; j >= 0; j--) {\\n                for (int h = 1; h <= matrix.length - i; h++) {\\n                    int newSum = getSum(matrix, i, j, h, 1);\\n                    if (dpLow[i][h] > 0) {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] = newSum;\\n                    } else if (dpHigh[i][h] < 0) {\\n                        dpLow[i][h] += newSum;\\n                        dpHigh[i][h] = newSum;\\n                    } else {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] += newSum;\\n                    }\\n                    if (dpHigh[i][h] >= result && dpLow[i][h] <= k) {\\n                        for (int w = 1; w <= matrix[0].length - j; w++) {\\n                            int sum = getSum(matrix, i, j, h, w);\\n                            if (sum == k) {\\n                                return sum;\\n                            } else if (sum < k) {\\n                                result = Math.max(result, sum);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int getSum(int[][] matrix, int i, int j, int h, int w) {\\n        int sum = matrix[i + h - 1][j + w - 1];\\n        if (i > 0) {\\n            sum -= matrix[i - 1][j + w - 1];\\n        }\\n        if (j > 0) {\\n            sum -= matrix[i + h - 1][j - 1];\\n        }\\n        if (i > 0 && j > 0) {\\n            sum += matrix[i - 1][j - 1];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488423,
                "title": "daily-leetcode-solution",
                "content": "![image](https://assets.leetcode.com/users/images/c74f2cc5-9780-4996-b6e1-3ab612bef7ce_1661572978.4759052.png)\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/c74f2cc5-9780-4996-b6e1-3ab612bef7ce_1661572978.4759052.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2488215,
                "title": "c-easy-solution-faster-than-99-5-less-memory-than-95",
                "content": "* **Runtime: 284 ms, faster than 99.74% of C++ online submissions for Max Sum of Rectangle No Larger Than K.**\\n* **Memory Usage: 10.5 MB, less than 94.90% of C++ online submissions for Max Sum of Rectangle No Larger Than K.**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int max_sum = INT_MIN, m=matrix.size(), n=matrix[0].size(), subarr[m];\\n        for(int l=0; l<n; l++) {\\n            memset(subarr,0,sizeof(subarr));\\n            for(int r=l; r<n; r++) {\\n                for(int i=0; i<m; i++) subarr[i] += matrix[i][r];\\n                for(int i=0; i<m; i++) {\\n                    int sum = 0;\\n                    for(int j=i; j<m; j++) {\\n                        sum += subarr[j];\\n                        if(sum > max_sum && sum <=k) max_sum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int max_sum = INT_MIN, m=matrix.size(), n=matrix[0].size(), subarr[m];\\n        for(int l=0; l<n; l++) {\\n            memset(subarr,0,sizeof(subarr));\\n            for(int r=l; r<n; r++) {\\n                for(int i=0; i<m; i++) subarr[i] += matrix[i][r];\\n                for(int i=0; i<m; i++) {\\n                    int sum = 0;\\n                    for(int j=i; j<m; j++) {\\n                        sum += subarr[j];\\n                        if(sum > max_sum && sum <=k) max_sum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645868,
                "title": "max-sum-of-rectangle-no-larger-than-k-java-solution-explained",
                "content": "```java\\n/**\\n* Idea: \\n*  We scan all columns and for each group of columns we calculate the row sum of till that columns  \\n*  Say we have 3 columns, so we will have group of column such that [0]. [0,1], [0,1,2], [1], [1,2], [2]\\n*  then we calculate corresponding row sum this is where we use rolling sum to reduce complexity\\n* \\n*  Then we use the row sum array to get the maximum contiguous sub array sum which is under k\\n*  For this we can use kadane\\'s algorithm \\n*   Say we have [1, 3, -1, 2]\\n*   Good explanation of Kadane\\'s Algorithm https://www.youtube.com/watch?v=2MmGzdiKR9Y\\n*\\n*   Kadane\\'s algorith states that we can figure out maximum contiguas subarray sum with only one scan of the array\\n*   The basic idea is every element can be the max or the max can come from elements previous to that element\\n*\\n*   In the above example take the first element (1), the max subarray sum is 1 till that point\\n*   For second element, the choice is between use the element 3 or (3 and previous subarray sum) in this case max(3, 4) = 4\\n*   For third element (-1), the choice is -1 or previous 4 -> (4 + -1) = 3 the output is  3\\n*   For fourth element (2), the choice is 2 or previous 3 -> (3 + 2) = 5, the output is 5 \\n*   Looks like the maximum subarray sum here is the summation of the complete array. Otherwise we would\\'ve take max of all above \\n*   values MAX(1, 4, 3, 5 ) => 5\\n*   \\n*   This is a bit special case where we need to find the sum does not exceed k value , say k is 2\\n*   The trick is to maintain a sorted order of the sums found at each step, so the array will look like \\n*   [We add a 0 for convinience with negative value, meaning our value should not go negative]\\n*   (0) the first element is having sum 1, then (1 - 2) = -1, the closest ceiling value is 0, we can subtract 0 to not exceed max value 2, and the closest value we can get to 2 is (1 - 0) = 1\\n*   (0, 1) THe second sum is 4, the closest larger value of 4 - 2 = 2 is not found, so we just add it, meaning till now we can\\'t subtract anything from 4 which will make sure it won\\'t exceed 2\\n*   (0, 1, 4) the third sum is 3, the closest larger value of 3 - 2 = 1, thus we know we can go till (3 - 1) = 2, this is the closest of 2 we go. This can be inferred as if we take (3, -1) that is the closest sum of 2. \\n*  (0, 1, 3, 4) the next value is 5, thus (5 - 2) = 3, closest to 3 is 3, thus we again know we can go till (5 - 3) = 2, the corresponding subarray will be same one as above.\\n*   Time Complexity => if n is no of cols and m is no of rows, then O(n^2 * mlogm)\\n*   Space Complexity => O(m) (originally 2m)\\n*/\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int maxSum = Integer.MIN_VALUE;\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        for (int i = 0; i < cols; i++) {\\n            \\n            // Starting at each column we incrementally go till end\\n            // [0], [0,1], [0,1,2]\\n            // [1], [1,2]\\n            // [2]\\n            \\n            int[] rowSum = new int[rows];\\n            for (int col = i; col < cols; col++) {\\n                for (int row = 0; row < rows; row++) {\\n                    rowSum[row] += matrix[row][col];\\n                }\\n                \\n                // We have calculated the row sum till the current column\\n                // Now it is time to mind the max subarray sum we can achieve lesser than k\\n                int maxSumUnderK = maxSubarrayLessThanK(rowSum, k);\\n                maxSum = Math.max(maxSum, maxSumUnderK);\\n                \\n                // This will prune the computations a bit, if we achieve k, we know \\n                // we don\\'t need to go futher this the max we can go, return now, don\\'t waste time computing more\\n                if (maxSum == k) return k;\\n            }\\n        }\\n        return maxSum;\\n    }\\n    \\n    // This is Kadane\\'s algorithm .. a bit modified\\n    private int maxSubarrayLessThanK(int[] array, int k) {\\n        int maxSumUnderK = Integer.MIN_VALUE;\\n        \\n        // Best possible data structure to keep stuff in sorted order and get back in log n time\\n        TreeSet<Integer> sortedPreviousSums = new TreeSet<>();\\n        sortedPreviousSums.add(0);\\n        \\n        int incrementalSum = 0;\\n        for (int i = 0; i < array.length; i++) {\\n            incrementalSum += array[i];\\n            \\n            // Now we try to find if our sorted sum list is having\\n            // any thing just larger than (sum - k), say that is previousSum\\n            // If there is an element we know we can go close to k as much as (sum - previousSum)\\n            Integer previousSum = sortedPreviousSums.ceiling(incrementalSum - k);\\n            if (previousSum != null) {\\n                maxSumUnderK = Math.max(maxSumUnderK, incrementalSum - previousSum);\\n            }\\n            \\n            sortedPreviousSums.add(incrementalSum);\\n        }\\n        \\n        return maxSumUnderK;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\n/**\\n* Idea: \\n*  We scan all columns and for each group of columns we calculate the row sum of till that columns  \\n*  Say we have 3 columns, so we will have group of column such that [0]. [0,1], [0,1,2], [1], [1,2], [2]\\n*  then we calculate corresponding row sum this is where we use rolling sum to reduce complexity\\n* \\n*  Then we use the row sum array to get the maximum contiguous sub array sum which is under k\\n*  For this we can use kadane\\'s algorithm \\n*   Say we have [1, 3, -1, 2]\\n*   Good explanation of Kadane\\'s Algorithm https://www.youtube.com/watch?v=2MmGzdiKR9Y\\n*\\n*   Kadane\\'s algorith states that we can figure out maximum contiguas subarray sum with only one scan of the array\\n*   The basic idea is every element can be the max or the max can come from elements previous to that element\\n*\\n*   In the above example take the first element (1), the max subarray sum is 1 till that point\\n*   For second element, the choice is between use the element 3 or (3 and previous subarray sum) in this case max(3, 4) = 4\\n*   For third element (-1), the choice is -1 or previous 4 -> (4 + -1) = 3 the output is  3\\n*   For fourth element (2), the choice is 2 or previous 3 -> (3 + 2) = 5, the output is 5 \\n*   Looks like the maximum subarray sum here is the summation of the complete array. Otherwise we would\\'ve take max of all above \\n*   values MAX(1, 4, 3, 5 ) => 5\\n*   \\n*   This is a bit special case where we need to find the sum does not exceed k value , say k is 2\\n*   The trick is to maintain a sorted order of the sums found at each step, so the array will look like \\n*   [We add a 0 for convinience with negative value, meaning our value should not go negative]\\n*   (0) the first element is having sum 1, then (1 - 2) = -1, the closest ceiling value is 0, we can subtract 0 to not exceed max value 2, and the closest value we can get to 2 is (1 - 0) = 1\\n*   (0, 1) THe second sum is 4, the closest larger value of 4 - 2 = 2 is not found, so we just add it, meaning till now we can\\'t subtract anything from 4 which will make sure it won\\'t exceed 2\\n*   (0, 1, 4) the third sum is 3, the closest larger value of 3 - 2 = 1, thus we know we can go till (3 - 1) = 2, this is the closest of 2 we go. This can be inferred as if we take (3, -1) that is the closest sum of 2. \\n*  (0, 1, 3, 4) the next value is 5, thus (5 - 2) = 3, closest to 3 is 3, thus we again know we can go till (5 - 3) = 2, the corresponding subarray will be same one as above.\\n*   Time Complexity => if n is no of cols and m is no of rows, then O(n^2 * mlogm)\\n*   Space Complexity => O(m) (originally 2m)\\n*/\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int maxSum = Integer.MIN_VALUE;\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        for (int i = 0; i < cols; i++) {\\n            \\n            // Starting at each column we incrementally go till end\\n            // [0], [0,1], [0,1,2]\\n            // [1], [1,2]\\n            // [2]\\n            \\n            int[] rowSum = new int[rows];\\n            for (int col = i; col < cols; col++) {\\n                for (int row = 0; row < rows; row++) {\\n                    rowSum[row] += matrix[row][col];\\n                }\\n                \\n                // We have calculated the row sum till the current column\\n                // Now it is time to mind the max subarray sum we can achieve lesser than k\\n                int maxSumUnderK = maxSubarrayLessThanK(rowSum, k);\\n                maxSum = Math.max(maxSum, maxSumUnderK);\\n                \\n                // This will prune the computations a bit, if we achieve k, we know \\n                // we don\\'t need to go futher this the max we can go, return now, don\\'t waste time computing more\\n                if (maxSum == k) return k;\\n            }\\n        }\\n        return maxSum;\\n    }\\n    \\n    // This is Kadane\\'s algorithm .. a bit modified\\n    private int maxSubarrayLessThanK(int[] array, int k) {\\n        int maxSumUnderK = Integer.MIN_VALUE;\\n        \\n        // Best possible data structure to keep stuff in sorted order and get back in log n time\\n        TreeSet<Integer> sortedPreviousSums = new TreeSet<>();\\n        sortedPreviousSums.add(0);\\n        \\n        int incrementalSum = 0;\\n        for (int i = 0; i < array.length; i++) {\\n            incrementalSum += array[i];\\n            \\n            // Now we try to find if our sorted sum list is having\\n            // any thing just larger than (sum - k), say that is previousSum\\n            // If there is an element we know we can go close to k as much as (sum - previousSum)\\n            Integer previousSum = sortedPreviousSums.ceiling(incrementalSum - k);\\n            if (previousSum != null) {\\n                maxSumUnderK = Math.max(maxSumUnderK, incrementalSum - previousSum);\\n            }\\n            \\n            sortedPreviousSums.add(incrementalSum);\\n        }\\n        \\n        return maxSumUnderK;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83621,
                "title": "no-real-dp-technique-actually-used-c-critically-commented",
                "content": "The last section of the solution can be tricky, but read it carefully and I believe you can get it done! \\n\\n**Good luck!**\\n\\n    class Solution {\\n    public:\\n        int maxSumSubmatrix(vector<vector<int>>& matrix, int k) \\n        {\\n            if(matrix.empty()) return 0;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            int ret = INT_MIN;\\n            for(int l = 0; l < colSize; ++l) //starting leftmost column;\\n            {\\n                vector<int> sums(rowSize, 0); //store the row pre-sums;\\n                for(int c = l; c < colSize; ++c) //try different ending columns;\\n                {\\n                    for(int r = 0; r < rowSize; ++r) //sum them up in rows;\\n                        sums[r] += matrix[r][c];\\n                    set<int> sums_set; //store the sums from the starting top-left;\\n                    sums_set.insert(0); //as a sentinel;\\n                    int maxSum = INT_MIN, sum = 0;\\n                    for(int i = 0; i < rowSize; ++i)\\n                    {\\n                        sum += sums[i]; //the sum from the starting top-left to current position;\\n                        auto iter = sums_set.lower_bound(sum-k); //check the possible sum candidates;\\n                        if(iter != sums_set.end()) maxSum = max(maxSum, sum-*iter); //found one, check it;\\n                        sums_set.insert(sum);\\n                    }\\n                    ret = max(ret, maxSum);\\n                }\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxSumSubmatrix(vector<vector<int>>& matrix, int k) \\n        {\\n            if(matrix.empty()) return 0;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            int ret = INT_MIN;\\n            for(int l = 0; l < colSize; ++l) //starting leftmost column;\\n            {\\n                vector<int> sums(rowSize, 0); //store the row pre-sums;\\n                for(int c = l; c < colSize; ++c) //try different ending columns;\\n                {\\n                    for(int r = 0; r < rowSize; ++r) //sum them up in rows;\\n                        sums[r] += matrix[r][c];\\n                    set<int> sums_set; //store the sums from the starting top-left;\\n                    sums_set.insert(0); //as a sentinel;\\n                    int maxSum = INT_MIN, sum = 0;\\n                    for(int i = 0; i < rowSize; ++i)\\n                    {\\n                        sum += sums[i]; //the sum from the starting top-left to current position;\\n                        auto iter = sums_set.lower_bound(sum-k); //check the possible sum candidates;\\n                        if(iter != sums_set.end()) maxSum = max(maxSum, sum-*iter); //found one, check it;\\n                        sums_set.insert(sum);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2459253,
                "title": "c-solution-time-o-m-2-n-2-memory-o-m-n-easy-to-understand-2d-prefix-sum",
                "content": "```C#\\npublic class Solution {\\n    public int MaxSumSubmatrix(int[][] matrix, int k) {\\n        int rows = matrix.Length, cols = matrix[0].Length;\\n        \\n        int[][] sums = new int[rows + 1][];\\n        for (int i = 0; i <= rows; i++) sums[i] = new int[cols + 1];\\n        \\n        int ans = int.MinValue;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                sums[i + 1][j + 1] = sums[i + 1][j] + sums[i][j + 1] - sums[i][j] + matrix[i][j];\\n                \\n                for (int rectangleHeight = 0; rectangleHeight <= i; rectangleHeight++) {\\n                    for (int rectangleWidth = 0; rectangleWidth <= j; rectangleWidth++) {\\n                        int rectangleSum = sums[i + 1][j + 1] - sums[i + 1][j - rectangleWidth] - sums[i - rectangleHeight][j + 1] + sums[i - rectangleHeight][j - rectangleWidth];\\n                        if (rectangleSum == k) return rectangleSum;\\n                        if (rectangleSum < k) ans = Math.Max(ans, rectangleSum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int MaxSumSubmatrix(int[][] matrix, int k) {\\n        int rows = matrix.Length, cols = matrix[0].Length;\\n        \\n        int[][] sums = new int[rows + 1][];\\n        for (int i = 0; i <= rows; i++) sums[i] = new int[cols + 1];\\n        \\n        int ans = int.MinValue;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                sums[i + 1][j + 1] = sums[i + 1][j] + sums[i][j + 1] - sums[i][j] + matrix[i][j];\\n                \\n                for (int rectangleHeight = 0; rectangleHeight <= i; rectangleHeight++) {\\n                    for (int rectangleWidth = 0; rectangleWidth <= j; rectangleWidth++) {\\n                        int rectangleSum = sums[i + 1][j + 1] - sums[i + 1][j - rectangleWidth] - sums[i - rectangleHeight][j + 1] + sums[i - rectangleHeight][j - rectangleWidth];\\n                        if (rectangleSum == k) return rectangleSum;\\n                        if (rectangleSum < k) ans = Math.Max(ans, rectangleSum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318887,
                "title": "java-kadane-s-algorithm-explanation",
                "content": "scan cols from left to right. for every fixed left & right column, store sum of rows in temp array. find max contiguous sum from this temp array using Kadane\\'s algorithm which is described below:\\n```\\n\\tx\\n<--->\\n\\t\\t\\ty\\n<----------->\\n\\n\\t\\ty-x=k\\n\\t <------>\\n```\\n\\n```\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\n        int res = Integer.MIN_VALUE;\\n        for(int leftCol = 0; leftCol < matrix[0].length; leftCol++) {\\n            int[] tempRowsSum = new int[matrix.length];\\n            for(int rightCol = leftCol; rightCol < matrix[0].length; rightCol++) {\\n                for(int row = 0; row < matrix.length; row++) {\\n                    tempRowsSum[row] += matrix[row][rightCol];\\n                }\\n                TreeSet<Integer> set = new TreeSet<>();\\n                set.add(0);\\n                int cSum = 0;\\n                for(int a : tempRowsSum) {\\n                    cSum += a;\\n                    //cSum is y & target is x here. cSum-k = y-k = x+k-k = x. \\n                    Integer target = set.ceiling(cSum - k);\\n                    //cSum-target = y-x = k\\n                    if(target != null) res = Math.max(res, cSum - target);\\n                    set.add(cSum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nTC: O(col * col * row * (log row))\\nSC: O(row)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tx\\n<--->\\n\\t\\t\\ty\\n<----------->\\n\\n\\t\\ty-x=k\\n\\t <------>\\n```\n```\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\n        int res = Integer.MIN_VALUE;\\n        for(int leftCol = 0; leftCol < matrix[0].length; leftCol++) {\\n            int[] tempRowsSum = new int[matrix.length];\\n            for(int rightCol = leftCol; rightCol < matrix[0].length; rightCol++) {\\n                for(int row = 0; row < matrix.length; row++) {\\n                    tempRowsSum[row] += matrix[row][rightCol];\\n                }\\n                TreeSet<Integer> set = new TreeSet<>();\\n                set.add(0);\\n                int cSum = 0;\\n                for(int a : tempRowsSum) {\\n                    cSum += a;\\n                    //cSum is y & target is x here. cSum-k = y-k = x+k-k = x. \\n                    Integer target = set.ceiling(cSum - k);\\n                    //cSum-target = y-x = k\\n                    if(target != null) res = Math.max(res, cSum - target);\\n                    set.add(cSum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313574,
                "title": "rust-translated-prefix-sum-on-1d-array-using-sorted-container",
                "content": "```rust\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let (row, col) = (matrix.len(), matrix[0].len());\\n        let mut answer = std::i32::MIN;\\n        for i in 0..row {\\n            let mut rowsum = vec![0; col];\\n            for r in matrix.iter().skip(i) {\\n                rowsum.iter_mut().zip(r).for_each(|(sum, val)| *sum += val);\\n                let mut sum = 0;\\n                let mut bts = BTreeSet::new();\\n                bts.insert(0);\\n                for val in &rowsum {\\n                    sum += val;\\n                    if let Some(x) = bts.range(sum - k..).next() {\\n                        answer = answer.max(sum - x);\\n                        if answer == k {\\n                            return k;\\n                        }\\n                    };\\n                    bts.insert(sum);\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let (row, col) = (matrix.len(), matrix[0].len());\\n        let mut answer = std::i32::MIN;\\n        for i in 0..row {\\n            let mut rowsum = vec![0; col];\\n            for r in matrix.iter().skip(i) {\\n                rowsum.iter_mut().zip(r).for_each(|(sum, val)| *sum += val);\\n                let mut sum = 0;\\n                let mut bts = BTreeSet::new();\\n                bts.insert(0);\\n                for val in &rowsum {\\n                    sum += val;\\n                    if let Some(x) = bts.range(sum - k..).next() {\\n                        answer = answer.max(sum - x);\\n                        if answer == k {\\n                            return k;\\n                        }\\n                    };\\n                    bts.insert(sum);\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1287117,
                "title": "c-prefix-sum-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        if(matrix == null || matrix.Length == 0)\\n            return -1;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        int[,] prefixSum = new int[m + 1, n + 1];\\n        for(int i = 1; i <= m; i++)\\n        {\\n            for(int j = 1; j <= n; j++)      \\n            {\\n                // prefixSum[i,j] denotes the sum of elements between matrix[0][0] ~ matrix[i-1][j-1]\\n                prefixSum[i,j] = prefixSum[i-1,j] + prefixSum[i,j-1] - prefixSum[i-1,j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        int max = Int32.MinValue;\\n        HashSet<int> set = new HashSet<int>();\\n        for(int r1 = 1; r1 <= m; r1++)\\n        {\\n            for(int r2 = r1; r2 <= m; r2++)\\n            {              \\n                set.Clear();\\n                set.Add(0);\\n                \\n                for(int col = 1; col <= n; col++)\\n                {\\n                    int rangeSum = prefixSum[r2,col] - prefixSum[r1-1,col];\\n                    \\n                    foreach(var num in set)\\n                    {\\n                        int sum = rangeSum - num;\\n                        if(sum <= k)\\n                            max = Math.Max(max, sum);\\n                    }\\n                    \\n                    set.Add(rangeSum);\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        if(matrix == null || matrix.Length == 0)\\n            return -1;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        int[,] prefixSum = new int[m + 1, n + 1];\\n        for(int i = 1; i <= m; i++)\\n        {\\n            for(int j = 1; j <= n; j++)      \\n            {\\n                // prefixSum[i,j] denotes the sum of elements between matrix[0][0] ~ matrix[i-1][j-1]\\n                prefixSum[i,j] = prefixSum[i-1,j] + prefixSum[i,j-1] - prefixSum[i-1,j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        int max = Int32.MinValue;\\n        HashSet<int> set = new HashSet<int>();\\n        for(int r1 = 1; r1 <= m; r1++)\\n        {\\n            for(int r2 = r1; r2 <= m; r2++)\\n            {              \\n                set.Clear();\\n                set.Add(0);\\n                \\n                for(int col = 1; col <= n; col++)\\n                {\\n                    int rangeSum = prefixSum[r2,col] - prefixSum[r1-1,col];\\n                    \\n                    foreach(var num in set)\\n                    {\\n                        int sum = rangeSum - num;\\n                        if(sum <= k)\\n                            max = Math.Max(max, sum);\\n                    }\\n                    \\n                    set.Add(rangeSum);\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963923,
                "title": "java-2-approaches-o-n-2-m-log-m-group-row-column-and-merge-sort",
                "content": "**Approach 1:**\\n1. Iterate over all row ranges and add those rows together.\\n2. Solve the problem of **maximum sum of subarray less than or equal to k** on this array.\\n\\nFor example:\\nrow 0 -> [ a\\u2003\\u2003b\\u2003\\u2003c\\u2003\\u2003d ]\\nrow 1 -> [ e\\u2003\\u2003f\\u2003\\u2003g\\u2003\\u2003h ]\\nrow 2 -> [ i\\u2003\\u2003j\\u2003\\u2003k\\u2003\\u2003l ]\\n\\nStep 1 means:\\nrows [0..0] -> [ a\\u2003\\u2003\\u2003\\u2003b\\u2003\\u2003\\u2003\\u2003c\\u2003\\u2003\\u2003\\u2003d ]\\nrows [0..1] -> [ a+e\\u2003\\u2003\\u2003b+f\\u2003\\u2003c+g\\u2003\\u2003d+h ]\\nrows [0..2] -> [ a+e+i\\u2003b+f+j\\u2003c+g+k\\u2003d+h+l ]\\nrows [1..1] -> [ e\\u2003\\u2003\\u2003f\\u2003\\u2003\\u2003g\\u2003\\u2003\\u2003h ]\\nrows [1..2] -> [ e+i\\u2003\\u2003f+j\\u2003\\u2003g+k\\u2003\\u2003h+l ]\\nrows [2..2] -> [ i\\u2003\\u2003\\u2003j\\u2003\\u2003\\u2003k\\u2003\\u2003\\u2003l ]\\n\\nStep 2 means solving the problem on all of these row range sums.\\nHow to solve **maximum sum of subarray less than or equal to k** efficiently?\\nLet\\'s say we have an array ```A```. We want to find out maximum value of ```sum[i..j] = A[i] + A[i+1] + ... A[j] <= k```\\n```sum[i..j]``` can be redefined in terms of ```prefix``` sum as ```sum[i..j] = prefix[j] - prefix[i-1]```\\nSo a solution could be to traverse over the array and calculate the best valid subarray ending at that index and take the maximum of all these subarray values.\\nSuppose we\\'re at an index ```j```, what is the best start index ```i (i < j)``` that we\\'re looking for?\\n\\n-> Maximize LHS (Left Hand Side) such that ```sum[i..j] <= k```\\n-> Maximize LHS such that ```prefix[j] - prefix[i-1] <= k```\\n-> **Minimize** ```prefix[i-1]``` (there is minus sign in front of ```prefix[i-1]``` so minimizing ```prefix[i-1]``` increases LHS) such that ```prefix[j] - prefix[i-1] <= k```\\n-> Minimize ```prefix[i-1]``` such that ```prefix[i-1] >= prefix[j] - k```\\nSo essentially we\\'re trying to **find an old prefix sum which is just greater than or equal to current prefix sum - k**. This can be efficiently solved using a sorted list like TreeSet on ```prefix``` sum values.\\n\\n**Follow up:** What if the number of rows is much larger than the number of columns?\\nIterate over column ranges instead of rows and solve the problem on array formed by column range sums.\\nSince whichever dimension we iterate the ranges on adds a quadratic time wherever the other dimension only contributes linear-logarithmic time, we\\'d like to do the grouping on whichever dimension is smaller.\\n\\n**Optimization:**\\nWe can use Kadane\\'s algorithm to find the maximum subarray sum in an array and use it directly if it is ```<= k```. That can help us avoid the more costly TreeSet based computation in some cases.\\n\\n```\\n// 12 ms. 94.57%\\nclass Solution {\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }\\n        return res;\\n    }\\n    private int maxSumSubarray(int[] A, int k) {\\n        int res = maxSumSubarray(A);\\n        if(res <= k) return res;\\n        res = Integer.MIN_VALUE;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for(int sum: A) {\\n            Integer old = set.ceiling(sum - k);\\n            if(old != null) {\\n                if(sum - old > res) {\\n                    res = sum - old;\\n                    if(res == k) return res;\\n                }\\n            }\\n            set.add(sum);\\n        }\\n        return res;\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = m == 0 ? 0 : matrix[0].length, res = Integer.MIN_VALUE;\\n        boolean groupingRows = true;\\n        if(m > n) {\\n            int temp = m; m = n; n = temp;\\n            groupingRows = false;\\n        }\\n        int[] sum = new int[n];\\n        for(int i = 0; i < m; i++) {\\n            Arrays.fill(sum, 0);\\n            for(int j = i; j < m; j++) {\\n                int pre = 0;\\n                if(groupingRows) {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[j][t];\\n                } else {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[t][j];\\n                }\\n                res = Math.max(res, maxSumSubarray(sum, k));\\n                if(res == k) return res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Approach 2:**\\nBasic idea is the same as previous approach but we solve the problem in Step 2 differently.\\nHere we leverage divide and conquer technique. Basically we perform merge sort on ```prefix``` sum values and calculate result during merge step.\\nOne might remember the idea of using merge sort to count inversions in an array. This is very similar.\\n\\nSo how exactly do we compute result during merge step?\\nSuppose we are merging left ```prefix``` subarray and right ```prefix``` subarray.\\nRemember from previous approach, for each index we\\'re trying to **find an old prefix sum which is just greater than or equal to current prefix sum - k**. So we can iterate over right subarray and for each index ```j```, keep incrementing the pointer in left array ```i``` (initialized to start index) till that situation is false (or basically ```prefix[i] < prefix[j] - k```). This way, we can compute the result for all cross subarrays (i.e. ```i``` in left subarray and ```j``` in right subarray) in linear time.\\nAfter this, we do the standard merging part of merge sort.\\n\\n```\\n// 7 ms. 95.80%\\nclass Solution {\\n    private int[] M;\\n    private int merge(int[] A, int l, int m, int r, int k) {\\n        int res = Integer.MIN_VALUE;\\n        for(int j = m+1, i = l; j <= r; j++) {\\n            while(i <= m && A[j] - A[i] > k) i++;\\n            if(i > m) break;\\n            res = Math.max(res, A[j] - A[i]);\\n            if(res == k) return res;\\n        }\\n        int i = l, j = m+1, t = 0;\\n        while(i <= m && j <= r) M[t++] = A[i] <= A[j] ? A[i++] : A[j++];\\n        while(i <= m) M[t++] = A[i++];\\n        while(j <= r) M[t++] = A[j++];\\n        for(i = l; i <= r; i++) A[i] = M[i-l];\\n        return res;\\n    }\\n    private int mergeSort(int[] A, int l, int r, int k) {\\n        if(l == r) return A[l] <= k ? A[l] : Integer.MIN_VALUE;\\n        int m = l + ((r-l) >> 1);\\n        int res = mergeSort(A, l, m, k);\\n        if(res == k) return res;\\n        res = Math.max(res, mergeSort(A, m+1, r, k));\\n        if(res == k) return res;\\n        return Math.max(res, merge(A, l, m, r, k));\\n    }\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }\\n        return res;\\n    }\\n    private int maxSumSubarray(int[] A, int k) {\\n        int res = maxSumSubarray(A);\\n        if(res <= k) return res;\\n        return mergeSort(A.clone(), 0, A.length-1, k);\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = m == 0 ? 0 : matrix[0].length, res = Integer.MIN_VALUE;\\n        boolean groupingRows = true;\\n        if(m > n) {\\n            int temp = m; m = n; n = temp;\\n            groupingRows = false;\\n        }\\n        int[] sum = new int[n];\\n        this.M = new int[n];\\n        for(int i = 0; i < m; i++) {\\n            Arrays.fill(sum, 0);\\n            for(int j = i; j < m; j++) {\\n                int pre = 0;\\n                if(groupingRows) {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[j][t];\\n                } else {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[t][j];\\n                }\\n                res = Math.max(res, maxSumSubarray(sum, k));\\n                if(res == k) return res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Merge Sort",
                    "Ordered Set"
                ],
                "code": "```A```\n```sum[i..j] = A[i] + A[i+1] + ... A[j] <= k```\n```sum[i..j]```\n```prefix```\n```sum[i..j] = prefix[j] - prefix[i-1]```\n```j```\n```i (i < j)```\n```sum[i..j] <= k```\n```prefix[j] - prefix[i-1] <= k```\n```prefix[i-1]```\n```prefix[i-1]```\n```prefix[i-1]```\n```prefix[j] - prefix[i-1] <= k```\n```prefix[i-1]```\n```prefix[i-1] >= prefix[j] - k```\n```prefix```\n```<= k```\n```\\n// 12 ms. 94.57%\\nclass Solution {\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }\\n        return res;\\n    }\\n    private int maxSumSubarray(int[] A, int k) {\\n        int res = maxSumSubarray(A);\\n        if(res <= k) return res;\\n        res = Integer.MIN_VALUE;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for(int sum: A) {\\n            Integer old = set.ceiling(sum - k);\\n            if(old != null) {\\n                if(sum - old > res) {\\n                    res = sum - old;\\n                    if(res == k) return res;\\n                }\\n            }\\n            set.add(sum);\\n        }\\n        return res;\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = m == 0 ? 0 : matrix[0].length, res = Integer.MIN_VALUE;\\n        boolean groupingRows = true;\\n        if(m > n) {\\n            int temp = m; m = n; n = temp;\\n            groupingRows = false;\\n        }\\n        int[] sum = new int[n];\\n        for(int i = 0; i < m; i++) {\\n            Arrays.fill(sum, 0);\\n            for(int j = i; j < m; j++) {\\n                int pre = 0;\\n                if(groupingRows) {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[j][t];\\n                } else {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[t][j];\\n                }\\n                res = Math.max(res, maxSumSubarray(sum, k));\\n                if(res == k) return res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```prefix```\n```prefix```\n```prefix```\n```j```\n```i```\n```prefix[i] < prefix[j] - k```\n```i```\n```j```\n```\\n// 7 ms. 95.80%\\nclass Solution {\\n    private int[] M;\\n    private int merge(int[] A, int l, int m, int r, int k) {\\n        int res = Integer.MIN_VALUE;\\n        for(int j = m+1, i = l; j <= r; j++) {\\n            while(i <= m && A[j] - A[i] > k) i++;\\n            if(i > m) break;\\n            res = Math.max(res, A[j] - A[i]);\\n            if(res == k) return res;\\n        }\\n        int i = l, j = m+1, t = 0;\\n        while(i <= m && j <= r) M[t++] = A[i] <= A[j] ? A[i++] : A[j++];\\n        while(i <= m) M[t++] = A[i++];\\n        while(j <= r) M[t++] = A[j++];\\n        for(i = l; i <= r; i++) A[i] = M[i-l];\\n        return res;\\n    }\\n    private int mergeSort(int[] A, int l, int r, int k) {\\n        if(l == r) return A[l] <= k ? A[l] : Integer.MIN_VALUE;\\n        int m = l + ((r-l) >> 1);\\n        int res = mergeSort(A, l, m, k);\\n        if(res == k) return res;\\n        res = Math.max(res, mergeSort(A, m+1, r, k));\\n        if(res == k) return res;\\n        return Math.max(res, merge(A, l, m, r, k));\\n    }\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }\\n        return res;\\n    }\\n    private int maxSumSubarray(int[] A, int k) {\\n        int res = maxSumSubarray(A);\\n        if(res <= k) return res;\\n        return mergeSort(A.clone(), 0, A.length-1, k);\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = m == 0 ? 0 : matrix[0].length, res = Integer.MIN_VALUE;\\n        boolean groupingRows = true;\\n        if(m > n) {\\n            int temp = m; m = n; n = temp;\\n            groupingRows = false;\\n        }\\n        int[] sum = new int[n];\\n        this.M = new int[n];\\n        for(int i = 0; i < m; i++) {\\n            Arrays.fill(sum, 0);\\n            for(int j = i; j < m; j++) {\\n                int pre = 0;\\n                if(groupingRows) {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[j][t];\\n                } else {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[t][j];\\n                }\\n                res = Math.max(res, maxSumSubarray(sum, k));\\n                if(res == k) return res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799232,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int kadane(vector<int> vt,int k){\\n        set<int> st;\\n        int sum=0;\\n        int result=INT_MIN;\\n        st.insert(0);\\n        for(int i=0;i<vt.size();i++){\\n            sum+=vt[i];\\n            auto it=st.lower_bound(sum-k);\\n            \\n            if(it!=st.end()){\\n                result=max(result,sum-(*it));\\n            }\\n            \\n            st.insert(sum);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    \\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int result=INT_MIN;\\n        \\n        for(int l=0;l<m;l++){\\n            vector<int> sum(n,0);\\n            for(int r=l;r<m;r++){\\n                \\n                for(int i=0;i<n;i++){\\n                    sum[i]+=matrix[i][r];\\n                }\\n                \\n                result=max(result,kadane(sum,k));\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int kadane(vector<int> vt,int k){\\n        set<int> st;\\n        int sum=0;\\n        int result=INT_MIN;\\n        st.insert(0);\\n        for(int i=0;i<vt.size();i++){\\n            sum+=vt[i];\\n            auto it=st.lower_bound(sum-k);\\n            \\n            if(it!=st.end()){\\n                result=max(result,sum-(*it));\\n            }\\n            \\n            st.insert(sum);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    \\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int result=INT_MIN;\\n        \\n        for(int l=0;l<m;l++){\\n            vector<int> sum(n,0);\\n            for(int r=l;r<m;r++){\\n                \\n                for(int i=0;i<n;i++){\\n                    sum[i]+=matrix[i][r];\\n                }\\n                \\n                result=max(result,kadane(sum,k));\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568746,
                "title": "python3-solution-with-bst",
                "content": "The idea comes from https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/83596/Any-Accepted-Python-Solution/300996 and Thanks to @sfcapital999\\n for sharing his solution. I have rewritten the implementation to make it more clear and hopefully it could help the other people who are stuck on this question for quite a while:)\\n \\n ```\\n class TreeNode:\\n    def __init__(self, val: int):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\n\\nclass BST:\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n\\n    def insert(self, newNode: TreeNode) -> None:\\n        \"\"\"\\n        Insert a new node to the BST.\\n        \"\"\"\\n        currNode = self.root\\n        while currNode:\\n            if currNode.val > newNode.val:\\n                if currNode.left:\\n                    currNode = currNode.left\\n                else:\\n                    currNode.left = newNode\\n                    break\\n            else:\\n                if currNode.right:\\n                    currNode = currNode.right\\n                else:\\n                    currNode.right = newNode\\n                    break\\n\\n    def ceiling(self, val: int) -> int:\\n        \"\"\"\\n        Try to find a node in BST whose value is the minimum value that is\\n        not less than the input value, then return the node\\'s value.\\n        \"\"\"\\n        currNode = self.root\\n        rslt = float(\\'inf\\')\\n        while currNode:\\n            if currNode.val < val:\\n                currNode = currNode.right\\n            else:\\n                rslt = min(rslt, currNode.val)\\n                currNode = currNode.left\\n\\n        return rslt\\n\\n\\nclass Solution:\\n    def _get_limit_max_sub_sum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Try to find a contiguous sub list from nums whose summary <= k.\\n        The search process is accelarated by storing the pre calculated\\n        sub summaries to each node of a BST.\\n        \"\"\"\\n        currSum, currMax = 0, float(\\'-inf\\')\\n        bst = BST(TreeNode(currSum))\\n        for num in nums:\\n            currSum += num\\n            preSum = bst.ceiling(currSum - k)\\n            currMax = max(currMax, currSum - preSum)\\n            bst.insert(TreeNode(currSum))\\n\\n        return currMax\\n\\n    def _get_no_limit_max_sub_sum(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Get the maximum summary of any contiguous sub list from the input list.\\n        \"\"\"\\n        currMax, currSum = float(\\'-inf\\'), 0\\n        for num in nums:\\n            currSum = max(num, currSum + num)\\n            currMax = max(currMax, currSum)\\n\\n        return currMax\\n\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        Presumptions:\\n        1. matrix is not empty.\\n        2. matrix has more rows than columns.\\n        \"\"\"\\n        R, C = len(matrix), len(matrix[0])\\n        currMax = float(\\'-inf\\')\\n        for c1 in range(C):\\n            rowSums = [0] * R\\n            for c2 in range(c1, C):\\n                # First calculate sum between column c1 to c2 of each row.\\n                for r in range(R):\\n                    rowSums[r] += matrix[r][c2]\\n\\n                # Then the sum of rectangles between column c1 and c2\\n                # could be formed by any contiguous sub list from rowSums.\\n                # So firstly we try to get the maximum sub sum from rowSums.\\n                noLimitSubMax = self._get_no_limit_max_sub_sum(rowSums)\\n                if noLimitSubMax <= k:\\n                    currMax = max(currMax, noLimitSubMax)\\n                else:\\n                    currMax = max(\\n                        currMax, self._get_limit_max_sub_sum(rowSums, k))\\n\\n                # Found the maximum possible sub sum.\\n                if currMax == k:\\n                    return k\\n\\n        return currMax\\n ```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\n class TreeNode:\\n    def __init__(self, val: int):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\n\\nclass BST:\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n\\n    def insert(self, newNode: TreeNode) -> None:\\n        \"\"\"\\n        Insert a new node to the BST.\\n        \"\"\"\\n        currNode = self.root\\n        while currNode:\\n            if currNode.val > newNode.val:\\n                if currNode.left:\\n                    currNode = currNode.left\\n                else:\\n                    currNode.left = newNode\\n                    break\\n            else:\\n                if currNode.right:\\n                    currNode = currNode.right\\n                else:\\n                    currNode.right = newNode\\n                    break\\n\\n    def ceiling(self, val: int) -> int:\\n        \"\"\"\\n        Try to find a node in BST whose value is the minimum value that is\\n        not less than the input value, then return the node\\'s value.\\n        \"\"\"\\n        currNode = self.root\\n        rslt = float(\\'inf\\')\\n        while currNode:\\n            if currNode.val < val:\\n                currNode = currNode.right\\n            else:\\n                rslt = min(rslt, currNode.val)\\n                currNode = currNode.left\\n\\n        return rslt\\n\\n\\nclass Solution:\\n    def _get_limit_max_sub_sum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Try to find a contiguous sub list from nums whose summary <= k.\\n        The search process is accelarated by storing the pre calculated\\n        sub summaries to each node of a BST.\\n        \"\"\"\\n        currSum, currMax = 0, float(\\'-inf\\')\\n        bst = BST(TreeNode(currSum))\\n        for num in nums:\\n            currSum += num\\n            preSum = bst.ceiling(currSum - k)\\n            currMax = max(currMax, currSum - preSum)\\n            bst.insert(TreeNode(currSum))\\n\\n        return currMax\\n\\n    def _get_no_limit_max_sub_sum(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Get the maximum summary of any contiguous sub list from the input list.\\n        \"\"\"\\n        currMax, currSum = float(\\'-inf\\'), 0\\n        for num in nums:\\n            currSum = max(num, currSum + num)\\n            currMax = max(currMax, currSum)\\n\\n        return currMax\\n\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        Presumptions:\\n        1. matrix is not empty.\\n        2. matrix has more rows than columns.\\n        \"\"\"\\n        R, C = len(matrix), len(matrix[0])\\n        currMax = float(\\'-inf\\')\\n        for c1 in range(C):\\n            rowSums = [0] * R\\n            for c2 in range(c1, C):\\n                # First calculate sum between column c1 to c2 of each row.\\n                for r in range(R):\\n                    rowSums[r] += matrix[r][c2]\\n\\n                # Then the sum of rectangles between column c1 and c2\\n                # could be formed by any contiguous sub list from rowSums.\\n                # So firstly we try to get the maximum sub sum from rowSums.\\n                noLimitSubMax = self._get_no_limit_max_sub_sum(rowSums)\\n                if noLimitSubMax <= k:\\n                    currMax = max(currMax, noLimitSubMax)\\n                else:\\n                    currMax = max(\\n                        currMax, self._get_limit_max_sub_sum(rowSums, k))\\n\\n                # Found the maximum possible sub sum.\\n                if currMax == k:\\n                    return k\\n\\n        return currMax\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 485276,
                "title": "java-prefix-sum-solution-o-n-4",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i <m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j] - dp[i][j] + matrix[i][j];\\n                if(dp[i + 1][j + 1] <= target) max = Math.max(max, dp[i + 1][j + 1]);\\n            }\\n        }\\n\\n        int sum = 0;\\n        for(int i = 1; i <= m; ++i) {\\n            for(int j = 1; j <= n; ++j) {\\n                for(int k = 1; i - k >= 0; ++k) {\\n                    for(int l = 1; j - l >= 0; ++l) {\\n                        sum = dp[i][j] - dp[i - k][j] - dp[i][j - l] + dp[i - k][j - l];\\n                        if(sum <= target) max = Math.max(max, sum);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i <m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j] - dp[i][j] + matrix[i][j];\\n                if(dp[i + 1][j + 1] <= target) max = Math.max(max, dp[i + 1][j + 1]);\\n            }\\n        }\\n\\n        int sum = 0;\\n        for(int i = 1; i <= m; ++i) {\\n            for(int j = 1; j <= n; ++j) {\\n                for(int k = 1; i - k >= 0; ++k) {\\n                    for(int l = 1; j - l >= 0; ++l) {\\n                        sum = dp[i][j] - dp[i - k][j] - dp[i][j - l] + dp[i - k][j - l];\\n                        if(sum <= target) max = Math.max(max, sum);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363968,
                "title": "c-20-ms-99-solution",
                "content": "This is pretty much the same as finding maximum rectangle sum, but with more work if the maximum sum exceeds the constraint. To handle the constraint, we can use a set with cumulative sums and look for a ```sum(i)``` that is as close to ```sum(j)-k``` as possible, and we can get the best sum as ```sum(j) - best sum(i)```. We can find `best sum(i)` by calling ```set::lower_bound```. \\n\\nBecause we need extra work only if the maximum sum exceeds the constraint, we can keep Kadane\\'s Algorithm for finding maximum sum, and only resort to using set and finding lower bound when the maximum sum does exceed constraint. \\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int maxS) {\\n        int maxA = INT32_MIN, r = matrix.size(), c = matrix[0].size();\\n        for(int i = 0; i < c; ++i) {\\n            vector<int> sum(r, 0);\\n            if(maxA == maxS) return maxA; // Stop if we can reach maxS\\n            for(int j = i; j < c; ++j) {\\n                for(int k = 0; k < r; ++k) sum[k] += matrix[k][j];\\n                \\n                //First try Kadane\\'s Algo and see if maxSum is less than maxS. \\n                int curMax = INT32_MIN, curSum = 0;\\n                for(int k = 0; k < r; ++k) {\\n                    curSum += sum[k];\\n                    curMax = max(curMax, curSum);\\n                    if(curSum < 0) curSum = 0;\\n                }\\n                if(curMax <= maxS) {maxA = max(maxA, curMax); continue;}\\n                \\n                // Only apply slow method when there maxSum that is greater than maxS.\\n                int csum = 0;\\n                set<int> s({csum});\\n                for(int k = 0; k < r; ++k) {\\n                    csum += sum[k];\\n                    auto it = s.lower_bound(csum - maxS);\\n                    if(it != s.end()) maxA = max(maxA, csum - *it);\\n                    s.insert(csum);\\n                }\\n            }\\n        }\\n        return maxA;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```sum(i)```\n```sum(j)-k```\n```sum(j) - best sum(i)```\n```set::lower_bound```\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int maxS) {\\n        int maxA = INT32_MIN, r = matrix.size(), c = matrix[0].size();\\n        for(int i = 0; i < c; ++i) {\\n            vector<int> sum(r, 0);\\n            if(maxA == maxS) return maxA; // Stop if we can reach maxS\\n            for(int j = i; j < c; ++j) {\\n                for(int k = 0; k < r; ++k) sum[k] += matrix[k][j];\\n                \\n                //First try Kadane\\'s Algo and see if maxSum is less than maxS. \\n                int curMax = INT32_MIN, curSum = 0;\\n                for(int k = 0; k < r; ++k) {\\n                    curSum += sum[k];\\n                    curMax = max(curMax, curSum);\\n                    if(curSum < 0) curSum = 0;\\n                }\\n                if(curMax <= maxS) {maxA = max(maxA, curMax); continue;}\\n                \\n                // Only apply slow method when there maxSum that is greater than maxS.\\n                int csum = 0;\\n                set<int> s({csum});\\n                for(int k = 0; k < r; ++k) {\\n                    csum += sum[k];\\n                    auto it = s.lower_bound(csum - maxS);\\n                    if(it != s.end()) maxA = max(maxA, csum - *it);\\n                    s.insert(csum);\\n                }\\n            }\\n        }\\n        return maxA;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 339848,
                "title": "true-o-min-m-n-2-min-m-n-log-min-m-n-solution-in-python-not-using-bisort",
                "content": "Didn\\'t see anyone post a solution in Python in O(m^2 * nlogn). As treemap is not available, most O(m^2 * nlogn) solutions in Java/C++ don\\'t apply. \\nPosting one, inspired by Prob. 975\\n\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        R, C = len(matrix), len(matrix[0])\\n        if R > C:\\n            n_matrix = [[matrix[r][c] for r in range(R)] for c in range(C)]\\n            R, C = C, R\\n            matrix = n_matrix\\n        \\n        ps = [[0] * (C + 1) for _ in range(R + 1)]\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                ps[r+1][c+1] = ps[r+1][c] + matrix[r][c]\\n        for c in range(C):\\n            for r in range(R):\\n                ps[r+1][c+1] = ps[r][c+1] + ps[r+1][c+1]\\n        \\n        res = -sys.maxsize\\n        for r1 in range(R):\\n            for r2 in range(r1, R):                \\n                vals = []\\n                maxx = -sys.maxsize\\n                flag = False\\n                for i in range(C + 1): # get the horizontal partial sums\\n                    val = ps[r2+1][i] - ps[r1][i]\\n                    if val - maxx <= k:\\n                        flag = True\\n                    maxx = max(maxx, val)\\n                    vals.append(val)\\n                                \\n                pairs = sorted([(v, i) for i, v in enumerate(vals)], reverse = True)\\n                stack = []\\n                i = 0\\n                for j in range(len(pairs)):\\n                    # elements with the value <= pairs[j][0] - k should be enstacked\\n                    while i < len(pairs) and pairs[i][0] >= pairs[j][0] - k:\\n                        while stack and stack[-1] >= pairs[i][1]:\\n                            stack.pop()\\n                        stack.append(pairs[i][1])\\n                        i += 1\\n    \\n                    pos = bisect.bisect_left(stack, pairs[j][1])\\n                    if pos > 0:\\n                        res = max(res, pairs[j][0] - vals[stack[pos-1]])\\n        return res\\n```\\n\\nNOT using bisort, only used bisect in the innermost loop, thus O(nlogn) for each combinations of r1, r2",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        R, C = len(matrix), len(matrix[0])\\n        if R > C:\\n            n_matrix = [[matrix[r][c] for r in range(R)] for c in range(C)]\\n            R, C = C, R\\n            matrix = n_matrix\\n        \\n        ps = [[0] * (C + 1) for _ in range(R + 1)]\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                ps[r+1][c+1] = ps[r+1][c] + matrix[r][c]\\n        for c in range(C):\\n            for r in range(R):\\n                ps[r+1][c+1] = ps[r][c+1] + ps[r+1][c+1]\\n        \\n        res = -sys.maxsize\\n        for r1 in range(R):\\n            for r2 in range(r1, R):                \\n                vals = []\\n                maxx = -sys.maxsize\\n                flag = False\\n                for i in range(C + 1): # get the horizontal partial sums\\n                    val = ps[r2+1][i] - ps[r1][i]\\n                    if val - maxx <= k:\\n                        flag = True\\n                    maxx = max(maxx, val)\\n                    vals.append(val)\\n                                \\n                pairs = sorted([(v, i) for i, v in enumerate(vals)], reverse = True)\\n                stack = []\\n                i = 0\\n                for j in range(len(pairs)):\\n                    # elements with the value <= pairs[j][0] - k should be enstacked\\n                    while i < len(pairs) and pairs[i][0] >= pairs[j][0] - k:\\n                        while stack and stack[-1] >= pairs[i][1]:\\n                            stack.pop()\\n                        stack.append(pairs[i][1])\\n                        i += 1\\n    \\n                    pos = bisect.bisect_left(stack, pairs[j][1])\\n                    if pos > 0:\\n                        res = max(res, pairs[j][0] - vals[stack[pos-1]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111842,
                "title": "python-1200ms-binary-search-using-bisect",
                "content": "```\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return 0\\n        m, n = len(matrix), len(matrix[0])\\n        if m > n:\\n            return self.maxSumSubmatrix(map(list,zip(*matrix)), target)\\n        res = -sys.maxint\\n        for r1 in range(m):\\n            sumArr = [0] * n\\n            for r2 in range(r1, m):\\n                # update sumArr: add matrix[r2]\\n                for j in range(n):\\n                    sumArr[j] += matrix[r2][j]\\n                \\n                curSum, tmpArr = 0, [0, sys.maxint]\\n                for k in range(n):\\n                    curSum += sumArr[k]\\n                    ind = bisect.bisect_left(tmpArr, curSum - target)\\n                    res = max(res, curSum - tmpArr[ind])\\n                    bisect.insort(tmpArr, curSum)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return 0\\n        m, n = len(matrix), len(matrix[0])\\n        if m > n:\\n            return self.maxSumSubmatrix(map(list,zip(*matrix)), target)\\n        res = -sys.maxint\\n        for r1 in range(m):\\n            sumArr = [0] * n\\n            for r2 in range(r1, m):\\n                # update sumArr: add matrix[r2]\\n                for j in range(n):\\n                    sumArr[j] += matrix[r2][j]\\n                \\n                curSum, tmpArr = 0, [0, sys.maxint]\\n                for k in range(n):\\n                    curSum += sumArr[k]\\n                    ind = bisect.bisect_left(tmpArr, curSum - target)\\n                    res = max(res, curSum - tmpArr[ind])\\n                    bisect.insort(tmpArr, curSum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83601,
                "title": "c-46ms-solution-beats-99-78",
                "content": "class Solution {\\npublic:\\n     \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size();\\n        int res=INT_MIN;\\n        for(int i=0;i<n;i++) {  // the number of columns is smaller\\n            vector<int> sums(m,0);\\n            for(int j=i;j<n;j++) {\\n                for(int row=0;row<m;row++) {\\n                    sums[row]+=matrix[row][j];\\n                }\\n                int ms = maxSumArray(sums, k);\\n                if (ms == k) return ms;\\n                if (ms < k && ms > res) res = ms;\\n          \\n            }\\n        }\\n        return res;\\n    }\\n     \\n    int maxSumArray(vector<int> & arr, int k) {\\n        int sum = 0, maxS = INT_MIN;\\n        for (int i = 0; i < arr.size(); i++) {  //it's a trick. Maybe O(n) to solve this problem\\n            sum += arr[i];\\n            maxS = max(sum, maxS);\\n            if (sum == k ) return sum;\\n            if (sum < 0) sum = 0;\\n        }\\n        if (maxS <= k) return maxS;\\n        maxS= INT_MIN;\\n        set<int>sums;\\n        sum = 0;\\n        sums.insert(0);\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            auto it = sums.lower_bound(sum - k);\\n            if (it != sums.end()) maxS = max(sum - *it, maxS);\\n            sums.insert(sum);\\n        }\\n        return maxS;\\n    }  \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size();\\n        int res=INT_MIN;\\n        for(int i=0;i<n;i++) {  // the number of columns is smaller\\n            vector<int> sums(m,0);\\n            for(int j=i;j<n;j++) {\\n                for(int row=0;row<m;row++) {\\n                    sums[row]+=matrix[row][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2491340,
                "title": "java-93-faster-clean-prefix-sum",
                "content": "```\\nclass Solution {\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        final int rows = matrix.length;\\n        final int cols = matrix[0].length;\\n        final int[][] prefixSum = new int[rows + 1][cols + 1];\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                prefixSum[r + 1][c + 1] = prefixSum[r][c + 1] + prefixSum[r + 1][c] - prefixSum[r][c] + matrix[r][c];\\n            }\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n\\n        for (int rowSize = 0; rowSize < rows; rowSize++) {\\n            for (int colSize = 0; colSize < cols; colSize++) {\\n                for (int rStart = 0; rStart + rowSize < rows; rStart++) {\\n                    for (int cStart = 0; cStart + colSize < cols; cStart++) {\\n                        final int r1 = rStart;\\n                        final int c1 = cStart;\\n                        final int r2 = rStart + rowSize;\\n                        final int c2 = cStart + colSize;\\n                        final int sum = prefixSum[r2 + 1][c2 + 1] + prefixSum[r1][c1] - prefixSum[r1][c2 + 1] - prefixSum[r2 + 1][c1];\\n\\n                        if (sum == k) return k;\\n                        else if (sum < k) max = Math.max(max, sum);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n/**\\n\\nComplexity Analysis: \\n\\nM : No of rows\\nN : No of cols\\n\\nTime Complexity : \\n\\nTo Build prefix Sum : O(M*N)\\nTo Calculate Size of all rectangles : O(M^2*N^2)\\n\\n\\nSpace Complexity : \\n\\nTo Build prefix Sum : O(M*N)\\n\\n*/\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        final int rows = matrix.length;\\n        final int cols = matrix[0].length;\\n        final int[][] prefixSum = new int[rows + 1][cols + 1];\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                prefixSum[r + 1][c + 1] = prefixSum[r][c + 1] + prefixSum[r + 1][c] - prefixSum[r][c] + matrix[r][c];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2490694,
                "title": "simple-prefix-sum-rust-solution-100-faster",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let n = matrix.len();\\n        let m = matrix[0].len();\\n        let mut ans = std::i32::MIN;\\n        let mut p = vec![vec![0; m + 1]; n + 1];\\n        \\n        for j in 1..=m {\\n            p[1][j] = p[1][j-1] + matrix[0][j-1];\\n        }\\n        \\n        for i in 1..=n {\\n            p[i][1] = p[i-1][1] + matrix[i-1][0];\\n        }\\n        \\n        for i in 2..=n {\\n            for j in 2..=m {\\n                p[i][j] = p[i-1][j] + p[i][j-1] - p[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        for i in 0..n {\\n            for j in 0..m {\\n                for si in 1..=n-i {\\n                    for sj in 1..=m-j {\\n                        let cur_sum = p[i+si][j+sj] - p[i][j+sj] - p[i+si][j] + p[i][j];\\n                        if cur_sum <= k && cur_sum > ans {\\n                            ans = cur_sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let n = matrix.len();\\n        let m = matrix[0].len();\\n        let mut ans = std::i32::MIN;\\n        let mut p = vec![vec![0; m + 1]; n + 1];\\n        \\n        for j in 1..=m {\\n            p[1][j] = p[1][j-1] + matrix[0][j-1];\\n        }\\n        \\n        for i in 1..=n {\\n            p[i][1] = p[i-1][1] + matrix[i-1][0];\\n        }\\n        \\n        for i in 2..=n {\\n            for j in 2..=m {\\n                p[i][j] = p[i-1][j] + p[i][j-1] - p[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        for i in 0..n {\\n            for j in 0..m {\\n                for si in 1..=n-i {\\n                    for sj in 1..=m-j {\\n                        let cur_sum = p[i+si][j+sj] - p[i][j+sj] - p[i+si][j] + p[i][j];\\n                        if cur_sum <= k && cur_sum > ans {\\n                            ans = cur_sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2490149,
                "title": "c-binary-search-prefix-sum-set-lower-bound-accepted",
                "content": "**Prefix Sum, Binary Search, Set Approach !!**\\n\\n**Time Complexity:- O(n^3*logn)**\\n  \\n\\n```\\nclass Solution {\\npublic:\\n   \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int final_res=INT_MIN;\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                // Prefix Sum Calculated\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        \\n        // Maintaining the window l-->start and r-->end\\n        for(int l=0;l<m;l++){\\n            for(int r=l;r<m;r++){\\n                set<int> st={0};\\n                //st.insert(0);\\n                \\n                // Prefix sum variable\\n                int p_sum1=0;\\n                \\n                // loop for considering the current width of the rectangle\\n                for(int i=0;i<n;i++){\\n                    int sum2=matrix[i][r];\\n                    if(l>0){\\n                        sum2=sum2-matrix[i][l-1];\\n                    }\\n                    \\n                    p_sum1=p_sum1 + sum2;\\n                    \\n                    int var = p_sum1-k;\\n                    \\n\\t\\t\\t\\t\\t// Lower Bound Calculated\\n                    auto it = st.lower_bound(var);\\n                    \\n                    if(it!=st.end()){\\n                        int tmp=p_sum1-(*it);\\n                    // updating the final res if it is maximum than the previous one\\n                        final_res = max(final_res,tmp);\\n                    }\\n                    \\n                    st.insert(p_sum1);\\n                }\\n            }\\n        }\\n        \\n        return final_res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int final_res=INT_MIN;\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                // Prefix Sum Calculated\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        \\n        // Maintaining the window l-->start and r-->end\\n        for(int l=0;l<m;l++){\\n            for(int r=l;r<m;r++){\\n                set<int> st={0};\\n                //st.insert(0);\\n                \\n                // Prefix sum variable\\n                int p_sum1=0;\\n                \\n                // loop for considering the current width of the rectangle\\n                for(int i=0;i<n;i++){\\n                    int sum2=matrix[i][r];\\n                    if(l>0){\\n                        sum2=sum2-matrix[i][l-1];\\n                    }\\n                    \\n                    p_sum1=p_sum1 + sum2;\\n                    \\n                    int var = p_sum1-k;\\n                    \\n\\t\\t\\t\\t\\t// Lower Bound Calculated\\n                    auto it = st.lower_bound(var);\\n                    \\n                    if(it!=st.end()){\\n                        int tmp=p_sum1-(*it);\\n                    // updating the final res if it is maximum than the previous one\\n                        final_res = max(final_res,tmp);\\n                    }\\n                    \\n                    st.insert(p_sum1);\\n                }\\n            }\\n        }\\n        \\n        return final_res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489584,
                "title": "fastest-python-working-99-faster-91-more-memory-efficient-solution-multiple-approach",
                "content": "# DON\\'T FORGET TO UPVOTE!!\\n# 1. 99% Fast and 91% memory efficient best solution:\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\tdef find(nums: List[int]):\\n\\t\\t\\t\\tprefixsums_encountered = [0]\\n\\t\\t\\t\\tn = 1\\n\\t\\t\\t\\tres = -inf\\n\\t\\t\\t\\tfor prefixsum in accumulate(nums):\\n\\t\\t\\t\\t\\tprev_sum = prefixsum - k\\n\\t\\t\\t\\t\\tpos = bisect_left(prefixsums_encountered, prev_sum)\\n\\t\\t\\t\\t\\tif pos < n:\\n\\t\\t\\t\\t\\t\\tres = max(res, prefixsum - prefixsums_encountered[pos])\\n\\t\\t\\t\\t\\t\\tif res == k:\\n\\t\\t\\t\\t\\t\\t\\treturn k\\n\\t\\t\\t\\t\\tinsort(prefixsums_encountered, prefixsum)\\n\\t\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\theight, width = len(matrix), len(matrix[0])\\n\\t\\t\\tres = -inf\\n\\t\\t\\tfor rownum in range(height):\\n\\t\\t\\t\\ttotals = [0] * width\\n\\t\\t\\t\\tfor bottom_row in range(rownum, height):\\n\\t\\t\\t\\t\\tfor colnum in range(width):\\n\\t\\t\\t\\t\\t\\ttotals[colnum] += matrix[bottom_row][colnum]\\n\\n\\t\\t\\t\\t\\tres = max(res, find(totals))\\n\\t\\t\\t\\t\\tif res == k:\\n\\t\\t\\t\\t\\t\\treturn k\\n\\t\\t\\treturn res\\n\\n\\n# 2. 91% fast and 90% memory efficient solution:\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\t\\tif not matrix:  return 0\\n\\n\\t\\t\\t\\tres = float(\\'-inf\\')\\n\\t\\t\\t\\tM, N = len(matrix), len(matrix[0])\\n\\n\\n\\t\\t\\t\\tfor i in range(N):\\n\\t\\t\\t\\t\\tsums = [0 for _ in range(M)]\\n\\t\\t\\t\\t\\tfor j in range(i, N):\\n\\t\\t\\t\\t\\t\\tfor r in range(M):\\n\\t\\t\\t\\t\\t\\t\\tsums[r] += matrix[r][j]\\n\\n\\t\\t\\t\\t\\t\\t# find the largest sum of a subarray which is no more than K\\n\\t\\t\\t\\t\\t\\timport bisect\\n\\t\\t\\t\\t\\t\\tcum_sum = [0]\\n\\t\\t\\t\\t\\t\\tcum, max_sum = 0, float(\\'-inf\\')\\n\\t\\t\\t\\t\\t\\tfor item in sums:\\n\\t\\t\\t\\t\\t\\t\\tcum += item\\n\\t\\t\\t\\t\\t\\t\\t# current accum - prev accum <= k, try to find the target in the list of accum values\\n\\t\\t\\t\\t\\t\\t\\ttarget = cum - k \\n\\t\\t\\t\\t\\t\\t\\tleft = bisect.bisect_left(cum_sum, target)\\n\\t\\t\\t\\t\\t\\t\\tif left < len(cum_sum):\\n\\t\\t\\t\\t\\t\\t\\t\\tmax_sum = max(max_sum, cum - cum_sum[left])\\n\\t\\t\\t\\t\\t\\t\\tbisect.insort(cum_sum, cum)\\n\\n\\t\\t\\t\\t\\t\\tres = max(res, max_sum)\\n\\n\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 3.  81% FAST slightly differtent solution:\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\tm = len(matrix)\\n\\t\\t\\tn = len(matrix[0])\\n\\n\\t\\t\\tfor i in range(1, m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tmatrix[i][j] += matrix[i - 1][j]\\n\\n\\t\\t\\tmax_sum = -float(\\'inf\\')\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(i, m):\\n\\t\\t\\t\\t\\tcol_prefix_sums = [0 for _ in range(n)]\\n\\t\\t\\t\\t\\tcol_prefix_sums[0] = matrix[j][0] - (0 if i - 1 < 0 else matrix[i - 1][0])\\n\\t\\t\\t\\t\\tfor l in range(1, n):\\n\\t\\t\\t\\t\\t\\tcol_prefix_sums[l] += (col_prefix_sums[l - 1] + matrix[j][l] - (0 if i - 1 < 0 else matrix[i - 1][l]))\\n\\t\\t\\t\\t\\tmax_sum = max(max_sum, self.process_col_prefix_sums(col_prefix_sums, k))\\n\\n\\t\\t\\treturn max_sum\\n\\n\\t\\tdef process_col_prefix_sums(self, col_prefix_sums, k):\\n\\t\\t\\tmax_sum = -float(\\'inf\\')\\n\\t\\t\\tordered_list = []\\n\\t\\t\\tordered_list.append(0)\\n\\t\\t\\tfor prefix_sum in col_prefix_sums:\\n\\t\\t\\t\\ttarget = prefix_sum - k\\n\\t\\t\\t\\tidx = bisect_left(ordered_list, target)\\n\\t\\t\\t\\tif idx < len(ordered_list):\\n\\t\\t\\t\\t\\tmax_sum = max(max_sum, prefix_sum - ordered_list[idx])\\n\\t\\t\\t\\tinsert_idx = bisect_left(ordered_list, prefix_sum)\\n\\t\\t\\t\\tordered_list.insert(insert_idx, prefix_sum)\\n\\t\\t\\treturn max_sum",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "# DON\\'T FORGET TO UPVOTE!!\\n# 1. 99% Fast and 91% memory efficient best solution:\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\tdef find(nums: List[int]):\\n\\t\\t\\t\\tprefixsums_encountered = [0]\\n\\t\\t\\t\\tn = 1\\n\\t\\t\\t\\tres = -inf\\n\\t\\t\\t\\tfor prefixsum in accumulate(nums):\\n\\t\\t\\t\\t\\tprev_sum = prefixsum - k\\n\\t\\t\\t\\t\\tpos = bisect_left(prefixsums_encountered, prev_sum)\\n\\t\\t\\t\\t\\tif pos < n:\\n\\t\\t\\t\\t\\t\\tres = max(res, prefixsum - prefixsums_encountered[pos])\\n\\t\\t\\t\\t\\t\\tif res == k:\\n\\t\\t\\t\\t\\t\\t\\treturn k\\n\\t\\t\\t\\t\\tinsort(prefixsums_encountered, prefixsum)\\n\\t\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\theight, width = len(matrix), len(matrix[0])\\n\\t\\t\\tres = -inf\\n\\t\\t\\tfor rownum in range(height):\\n\\t\\t\\t\\ttotals = [0] * width\\n\\t\\t\\t\\tfor bottom_row in range(rownum, height):\\n\\t\\t\\t\\t\\tfor colnum in range(width):\\n\\t\\t\\t\\t\\t\\ttotals[colnum] += matrix[bottom_row][colnum]\\n\\n\\t\\t\\t\\t\\tres = max(res, find(totals))\\n\\t\\t\\t\\t\\tif res == k:\\n\\t\\t\\t\\t\\t\\treturn k\\n\\t\\t\\treturn res\\n\\n\\n# 2. 91% fast and 90% memory efficient solution:\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\t\\tif not matrix:  return 0\\n\\n\\t\\t\\t\\tres = float(\\'-inf\\')\\n\\t\\t\\t\\tM, N = len(matrix), len(matrix[0])\\n\\n\\n\\t\\t\\t\\tfor i in range(N):\\n\\t\\t\\t\\t\\tsums = [0 for _ in range(M)]\\n\\t\\t\\t\\t\\tfor j in range(i, N):\\n\\t\\t\\t\\t\\t\\tfor r in range(M):\\n\\t\\t\\t\\t\\t\\t\\tsums[r] += matrix[r][j]\\n\\n\\t\\t\\t\\t\\t\\t# find the largest sum of a subarray which is no more than K\\n\\t\\t\\t\\t\\t\\timport bisect\\n\\t\\t\\t\\t\\t\\tcum_sum = [0]\\n\\t\\t\\t\\t\\t\\tcum, max_sum = 0, float(\\'-inf\\')\\n\\t\\t\\t\\t\\t\\tfor item in sums:\\n\\t\\t\\t\\t\\t\\t\\tcum += item\\n\\t\\t\\t\\t\\t\\t\\t# current accum - prev accum <= k, try to find the target in the list of accum values\\n\\t\\t\\t\\t\\t\\t\\ttarget = cum - k \\n\\t\\t\\t\\t\\t\\t\\tleft = bisect.bisect_left(cum_sum, target)\\n\\t\\t\\t\\t\\t\\t\\tif left < len(cum_sum):\\n\\t\\t\\t\\t\\t\\t\\t\\tmax_sum = max(max_sum, cum - cum_sum[left])\\n\\t\\t\\t\\t\\t\\t\\tbisect.insort(cum_sum, cum)\\n\\n\\t\\t\\t\\t\\t\\tres = max(res, max_sum)\\n\\n\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 3.  81% FAST slightly differtent solution:\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\t\\t\\tm = len(matrix)\\n\\t\\t\\tn = len(matrix[0])\\n\\n\\t\\t\\tfor i in range(1, m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tmatrix[i][j] += matrix[i - 1][j]\\n\\n\\t\\t\\tmax_sum = -float(\\'inf\\')\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(i, m):\\n\\t\\t\\t\\t\\tcol_prefix_sums = [0 for _ in range(n)]\\n\\t\\t\\t\\t\\tcol_prefix_sums[0] = matrix[j][0] - (0 if i - 1 < 0 else matrix[i - 1][0])\\n\\t\\t\\t\\t\\tfor l in range(1, n):\\n\\t\\t\\t\\t\\t\\tcol_prefix_sums[l] += (col_prefix_sums[l - 1] + matrix[j][l] - (0 if i - 1 < 0 else matrix[i - 1][l]))\\n\\t\\t\\t\\t\\tmax_sum = max(max_sum, self.process_col_prefix_sums(col_prefix_sums, k))\\n\\n\\t\\t\\treturn max_sum\\n\\n\\t\\tdef process_col_prefix_sums(self, col_prefix_sums, k):\\n\\t\\t\\tmax_sum = -float(\\'inf\\')\\n\\t\\t\\tordered_list = []\\n\\t\\t\\tordered_list.append(0)\\n\\t\\t\\tfor prefix_sum in col_prefix_sums:\\n\\t\\t\\t\\ttarget = prefix_sum - k\\n\\t\\t\\t\\tidx = bisect_left(ordered_list, target)\\n\\t\\t\\t\\tif idx < len(ordered_list):\\n\\t\\t\\t\\t\\tmax_sum = max(max_sum, prefix_sum - ordered_list[idx])\\n\\t\\t\\t\\tinsert_idx = bisect_left(ordered_list, prefix_sum)\\n\\t\\t\\t\\tordered_list.insert(insert_idx, prefix_sum)\\n\\t\\t\\treturn max_sum",
                "codeTag": "Java"
            },
            {
                "id": 2489164,
                "title": "using-kadane-algorithm-c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;\\n        for(int left = 0 ; left < col ; left++){\\n            vector<int> sum(row, 0);\\n            for(int right = left ; right < col ; right++){\\n                for(int r=0 ; r<row; r++){\\n                    sum[r] += matrix[r][right];\\n                }\\n                set<int> mySet;\\n                mySet.insert(0);\\n                int currSum = 0, currMax = INT_MIN;\\n                for(int r=0 ; r<row; r++){\\n                    currSum+=sum[r];\\n                    auto  it = mySet.lower_bound(currSum-k);\\n                    if(it!=mySet.end()) currMax = max(currMax, currSum - (*it));\\n                    mySet.insert(currSum);\\n                }\\n                res = max (res, currMax);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;\\n        for(int left = 0 ; left < col ; left++){\\n            vector<int> sum(row, 0);\\n            for(int right = left ; right < col ; right++){\\n                for(int r=0 ; r<row; r++){\\n                    sum[r] += matrix[r][right];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2488730,
                "title": "135-ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// TIME COMPLEXITY:- O(M^2 NLOG(N))\\n\\t// SPACE COMPLEXITY:- O(N)\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n    //     int n = matrix.size();\\n    //     int m = matrix[0].size();\\n    //     int ans = INT_MIN;\\n    //     // prefix sum of every row\\n    //     for(int i=0;i<n;i++){\\n    //         for(int j=1;j<m;j++)\\n    //             matrix[i][j]+=matrix[i][j-1];\\n    //     }\\n    //     // try every possible width of subarray\\n    //     for(int start=0;start<m;start++){\\n    //         for(int end=start;end<m;end++){\\n    //             set<int> s = {0};\\n    //             int pref_sum = 0;\\n    //             // for current width of rectangle\\n    //             for(int i=0;i<n;i++){\\n    //                 int sum = matrix[i][end];\\n    //                 if(start>0)\\n    //                     sum-=matrix[i][start-1];\\n    //                 pref_sum+=sum;\\n    //                 auto itr = s.lower_bound(pref_sum-k);\\n    //                 if(itr!=s.end())\\n    //                     ans = max(ans,pref_sum-(*itr));\\n    //                 s.insert(pref_sum);\\n    //             }\\n    //         }\\n    //     }\\n    //     return ans;\\n    \\n        int ans = INT_MIN;\\n        \\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        int arr[R];\\n        \\n        for(int l = 0; l < C; ++l) {\\n            memset(arr, 0, sizeof(arr));\\n            \\n            for(int r = l; r < C; ++r) \\n            {\\n                for(int up = 0; up < R; ++up)\\n                {\\n                    arr[up] += matrix[up][r]; \\n                }\\n                int sum = 0, g = INT_MIN;\\n                for(int up = 0; up < R; ++up) \\n                {\\n                    sum = max(sum + arr[up], arr[up]);\\n                    g = max(g, sum);\\n                    if(g == k) \\n                        return k;\\n                }\\n                if(g < k) \\n                {\\n                    ans = max(ans, g);\\n                } \\n                else \\n                {\\n                    for(int up1 = 0; up1 < R; ++up1) \\n                    {\\n                        sum = 0;\\n                        for(int up2 = up1; up2 < R; ++up2) \\n                        {\\n                            sum += arr[up2];\\n                            if(sum <= k) \\n                                ans = max(ans, sum);\\n                        }\\n                        \\n                        if(ans == k) return k;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// TIME COMPLEXITY:- O(M^2 NLOG(N))\\n\\t// SPACE COMPLEXITY:- O(N)\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n    //     int n = matrix.size();\\n    //     int m = matrix[0].size();\\n    //     int ans = INT_MIN;\\n    //     // prefix sum of every row\\n    //     for(int i=0;i<n;i++){\\n    //         for(int j=1;j<m;j++)\\n    //             matrix[i][j]+=matrix[i][j-1];\\n    //     }\\n    //     // try every possible width of subarray\\n    //     for(int start=0;start<m;start++){\\n    //         for(int end=start;end<m;end++){\\n    //             set<int> s = {0};\\n    //             int pref_sum = 0;\\n    //             // for current width of rectangle\\n    //             for(int i=0;i<n;i++){\\n    //                 int sum = matrix[i][end];\\n    //                 if(start>0)\\n    //                     sum-=matrix[i][start-1];\\n    //                 pref_sum+=sum;\\n    //                 auto itr = s.lower_bound(pref_sum-k);\\n    //                 if(itr!=s.end())\\n    //                     ans = max(ans,pref_sum-(*itr));\\n    //                 s.insert(pref_sum);\\n    //             }\\n    //         }\\n    //     }\\n    //     return ans;\\n    \\n        int ans = INT_MIN;\\n        \\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        int arr[R];\\n        \\n        for(int l = 0; l < C; ++l) {\\n            memset(arr, 0, sizeof(arr));\\n            \\n            for(int r = l; r < C; ++r) \\n            {\\n                for(int up = 0; up < R; ++up)\\n                {\\n                    arr[up] += matrix[up][r]; \\n                }\\n                int sum = 0, g = INT_MIN;\\n                for(int up = 0; up < R; ++up) \\n                {\\n                    sum = max(sum + arr[up], arr[up]);\\n                    g = max(g, sum);\\n                    if(g == k) \\n                        return k;\\n                }\\n                if(g < k) \\n                {\\n                    ans = max(ans, g);\\n                } \\n                else \\n                {\\n                    for(int up1 = 0; up1 < R; ++up1) \\n                    {\\n                        sum = 0;\\n                        for(int up2 = up1; up2 < R; ++up2) \\n                        {\\n                            sum += arr[up2];\\n                            if(sum <= k) \\n                                ans = max(ans, sum);\\n                        }\\n                        \\n                        if(ans == k) return k;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488502,
                "title": "java-easy-solution-updated",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] grid, int k) \\n    {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int a[]=new int[m];\\n            for(int j=i;j<n;j++)\\n            {\\n                for(int x=0;x<m;x++)\\n                a[x]+=grid[j][x];\\n                \\n                int sum=helper(a,k);\\n                max=Math.max(max,sum);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int helper(int a[],int k)\\n    {\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            int s=0;\\n            for(int j=i;j<a.length;j++)\\n            {\\n                s+=a[j];\\n                if(s<=k)\\n                ans=Math.max(ans,s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] grid, int k) \\n    {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int a[]=new int[m];\\n            for(int j=i;j<n;j++)\\n            {\\n                for(int x=0;x<m;x++)\\n                a[x]+=grid[j][x];\\n                \\n                int sum=helper(a,k);\\n                max=Math.max(max,sum);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int helper(int a[],int k)\\n    {\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            int s=0;\\n            for(int j=i;j<a.length;j++)\\n            {\\n                s+=a[j];\\n                if(s<=k)\\n                ans=Math.max(ans,s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329481,
                "title": "c-well-commented-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int process(vector<int> &v,int k){\\n        \\n        set<int> s;\\n        s.insert(0);\\n\\t\\t// horizontal prefix sum to find actual sum of matrix \\n        for(int i = 1;i<v.size();i++){\\n            v[i] += v[i-1];\\n        }\\n        int ans = INT_MIN;\\n\\t\\t// since we want sum to be less than k so for some pre[i] a j must exist such that pre[i] - pre[j] <= k\\n\\t\\t// this gives pre[j] >= pre[i] - k and can be easily found using lower_bound\\n        for(int i = 0;i<v.size();i++){\\n            int p = v[i];\\n            auto it = s.lower_bound(p-k);\\n            if(it != s.end()){\\n                ans = max(ans,p - *it);\\n            }\\n            s.insert(v[i]);\\n        }\\n        return ans;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int sum) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\t\\t// vertical prefix sum for each matrix i.e. for each column\\n        for(int i = 0;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                matrix[j][i] += matrix[j-1][i];\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            for(int j = i;j<n;j++){\\n\\t\\t\\t// fixing the height of matrix by setting starting row to i and ending row to j\\n                vector<int> temp;\\n\\t\\t\\t\\t// generating vertical prefix sum for i to j \\n                for(int k = 0;k<m;k++){\\n                    int val = matrix[j][k] - ((i-1>=0)?matrix[i-1][k]:0);\\n                    temp.push_back(val);\\n                }\\n                ans = max(ans,process(temp,sum));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int process(vector<int> &v,int k){\\n        \\n        set<int> s;\\n        s.insert(0);\\n\\t\\t// horizontal prefix sum to find actual sum of matrix \\n        for(int i = 1;i<v.size();i++){\\n            v[i] += v[i-1];\\n        }\\n        int ans = INT_MIN;\\n\\t\\t// since we want sum to be less than k so for some pre[i] a j must exist such that pre[i] - pre[j] <= k\\n\\t\\t// this gives pre[j] >= pre[i] - k and can be easily found using lower_bound\\n        for(int i = 0;i<v.size();i++){\\n            int p = v[i];\\n            auto it = s.lower_bound(p-k);\\n            if(it != s.end()){\\n                ans = max(ans,p - *it);\\n            }\\n            s.insert(v[i]);\\n        }\\n        return ans;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int sum) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\t\\t// vertical prefix sum for each matrix i.e. for each column\\n        for(int i = 0;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                matrix[j][i] += matrix[j-1][i];\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            for(int j = i;j<n;j++){\\n\\t\\t\\t// fixing the height of matrix by setting starting row to i and ending row to j\\n                vector<int> temp;\\n\\t\\t\\t\\t// generating vertical prefix sum for i to j \\n                for(int k = 0;k<m;k++){\\n                    int val = matrix[j][k] - ((i-1>=0)?matrix[i-1][k]:0);\\n                    temp.push_back(val);\\n                }\\n                ans = max(ans,process(temp,sum));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557124,
                "title": "simple-extended-kadane-s-algorithm-o-r-r-c-log-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int kadane(vector<int> a,int k){\\n        int ans=INT_MIN,cs=0,p=0;\\n        set<int> st;\\n        st.insert(0);\\n        for(int i=0;i<a.size();i++){\\n            cs+=a[i];\\n            if((cs-p)<=k)\\n                ans=max(ans,cs-p);\\n            else{\\n                auto it=st.lower_bound(cs-k);\\n                if(it!=st.end())\\n                    ans=max(ans,cs-*it);\\n            }\\n            st.insert(cs);\\n            p=min(p,cs);\\n        }\\n        return ans;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& a, int k) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<a.size();i++){\\n            vector<int> v(a[0].size(),0);\\n            for(int j=i;j<a.size();j++){\\n                for(int k=0;k<a[0].size();k++)\\n                    v[k]+=a[j][k];\\n                ans=max(ans,kadane(v,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kadane(vector<int> a,int k){\\n        int ans=INT_MIN,cs=0,p=0;\\n        set<int> st;\\n        st.insert(0);\\n        for(int i=0;i<a.size();i++){\\n            cs+=a[i];\\n            if((cs-p)<=k)\\n                ans=max(ans,cs-p);\\n            else{\\n                auto it=st.lower_bound(cs-k);\\n                if(it!=st.end())\\n                    ans=max(ans,cs-*it);\\n            }\\n            st.insert(cs);\\n            p=min(p,cs);\\n        }\\n        return ans;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& a, int k) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<a.size();i++){\\n            vector<int> v(a[0].size(),0);\\n            for(int j=i;j<a.size();j++){\\n                for(int k=0;k<a[0].size();k++)\\n                    v[k]+=a[j][k];\\n                ans=max(ans,kadane(v,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412192,
                "title": "clean-python-solution-offical-solution-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\nTime: O(min(M,N)^2 * max(M,N) * Log(max(M,N)))\\nSpace: O(MN), can reduce to O(max(M,N)) by not using a new 2D array \"matrixRotated\".\\nJust change the iteration in `maxSumSubmatrix()`.\\n\\nThis is the implementation of the offical solution 1 and 2.\\n\"\"\"\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, k):\\n        if len(matrix)>len(matrix[0]): matrix = self.rotate(matrix)\\n        \\n        ans = float(\\'-inf\\')\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        \\n        for start in xrange(M):\\n            rowSum = [0]*N #row sum of rows from matrix[start] to row\\n            for row in matrix[start:]:\\n                for i, n in enumerate(row): rowSum[i] += n\\n                ans = max(ans, self.maxSumRow(rowSum, k))\\n                if ans==k: return ans\\n        return ans\\n    \\n    def maxSumRow(self, row, k):\\n        ans = float(\\'-inf\\')\\n        total = 0\\n        \\n        ss = SortedSet()\\n        ss.add(0)\\n        \\n        for n in row:\\n            total += n\\n            i = ss.bisect_left(total-k)\\n            if i<len(ss):\\n                x = ss[i]\\n                ans = max(ans, total-x)\\n            ss.add(total)\\n        return ans\\n            \\n    def rotate(self, matrix):\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        matrixRotated = [[0]*M for _ in xrange(N)]\\n        \\n        for i in xrange(M):\\n            for j in xrange(N):\\n                matrixRotated[j][i] = matrix[i][j]\\n        return matrixRotated\\n            \\n\"\"\"\\nRelated Heap Problems:\\nContains Duplicate: I, II, III\\nMax Sum of Rectangle No Larger Than K\\nMaximum Sum Of Subarray Close To K\\nK Empty Slots\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(min(M,N)^2 * max(M,N) * Log(max(M,N)))\\nSpace: O(MN), can reduce to O(max(M,N)) by not using a new 2D array \"matrixRotated\".\\nJust change the iteration in `maxSumSubmatrix()`.\\n\\nThis is the implementation of the offical solution 1 and 2.\\n\"\"\"\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, k):\\n        if len(matrix)>len(matrix[0]): matrix = self.rotate(matrix)\\n        \\n        ans = float(\\'-inf\\')\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        \\n        for start in xrange(M):\\n            rowSum = [0]*N #row sum of rows from matrix[start] to row\\n            for row in matrix[start:]:\\n                for i, n in enumerate(row): rowSum[i] += n\\n                ans = max(ans, self.maxSumRow(rowSum, k))\\n                if ans==k: return ans\\n        return ans\\n    \\n    def maxSumRow(self, row, k):\\n        ans = float(\\'-inf\\')\\n        total = 0\\n        \\n        ss = SortedSet()\\n        ss.add(0)\\n        \\n        for n in row:\\n            total += n\\n            i = ss.bisect_left(total-k)\\n            if i<len(ss):\\n                x = ss[i]\\n                ans = max(ans, total-x)\\n            ss.add(total)\\n        return ans\\n            \\n    def rotate(self, matrix):\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        matrixRotated = [[0]*M for _ in xrange(N)]\\n        \\n        for i in xrange(M):\\n            for j in xrange(N):\\n                matrixRotated[j][i] = matrix[i][j]\\n        return matrixRotated\\n            \\n\"\"\"\\nRelated Heap Problems:\\nContains Duplicate: I, II, III\\nMax Sum of Rectangle No Larger Than K\\nMaximum Sum Of Subarray Close To K\\nK Empty Slots\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314118,
                "title": "max-sum-of-rectangle-no-larger-than-k-solution-python",
                "content": "Please  Upvote if you like the solution. \\n``` \\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\n        # For corner cases\\n        if not matrix:\\n            return 0\\n        \\n        def max_sumk(l, k):\\n            sums = [0]\\n            presum, ans = 0, -sys.maxsize\\n            for item in l:\\n                presum += item\\n                \\n                left = bisect.bisect_left(sums, presum - k)\\n                if left < len(sums):\\n                    ans = max(ans, presum - sums[left])\\n                    \\n                bisect.insort(sums, presum)\\n            return ans\\n\\n        \\n        \\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        ans = -sys.maxsize\\n       \\n        # iterating through all  2D arrays possible for every column. \\n        for i in range(cols):\\n            Cvalues = [0 for _ in range(rows)]\\n            \\n            for j in range(i, cols):\\n                \\n                for row in range(rows):\\n                    Cvalues[row] = Cvalues[row] + matrix[row][j]\\n                \\n                curr_sum = max_sumk(Cvalues, k)\\n                ans = max(curr_sum, ans)\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n\\n        # For corner cases\\n        if not matrix:\\n            return 0\\n        \\n        def max_sumk(l, k):\\n            sums = [0]\\n            presum, ans = 0, -sys.maxsize\\n            for item in l:\\n                presum += item\\n                \\n                left = bisect.bisect_left(sums, presum - k)\\n                if left < len(sums):\\n                    ans = max(ans, presum - sums[left])\\n                    \\n                bisect.insort(sums, presum)\\n            return ans\\n\\n        \\n        \\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        ans = -sys.maxsize\\n       \\n        # iterating through all  2D arrays possible for every column. \\n        for i in range(cols):\\n            Cvalues = [0 for _ in range(rows)]\\n            \\n            for j in range(i, cols):\\n                \\n                for row in range(rows):\\n                    Cvalues[row] = Cvalues[row] + matrix[row][j]\\n                \\n                curr_sum = max_sumk(Cvalues, k)\\n                ans = max(curr_sum, ans)\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313678,
                "title": "numpy-approach-with-o-n-2-m-2-648ms-beats-95-24",
                "content": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        import numpy as np\\n        \\n        matrix = np.array(matrix, dtype=np.int32)\\n        \\n        M,N = matrix.shape\\n        \\n        ret = float(\"-inf\")\\n        \\n        CUM = np.zeros((M,N), dtype=np.int32)\\n        for shift_r in range(M):\\n            CUM[:M-shift_r] += matrix[shift_r:]\\n            \\n            _CUM = np.zeros((M-shift_r,N), dtype=np.int32)\\n            for shift_c in range(N):\\n                _CUM[:, :N-shift_c] += CUM[:M-shift_r,shift_c:]\\n                tmp = _CUM[(_CUM<=k) & (_CUM>ret)]\\n                if tmp.size:\\n                    ret = tmp.max()\\n            if ret == k:\\n                return ret\\n        \\n        return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        import numpy as np\\n        \\n        matrix = np.array(matrix, dtype=np.int32)\\n        \\n        M,N = matrix.shape\\n        \\n        ret = float(\"-inf\")\\n        \\n        CUM = np.zeros((M,N), dtype=np.int32)\\n        for shift_r in range(M):\\n            CUM[:M-shift_r] += matrix[shift_r:]\\n            \\n            _CUM = np.zeros((M-shift_r,N), dtype=np.int32)\\n            for shift_c in range(N):\\n                _CUM[:, :N-shift_c] += CUM[:M-shift_r,shift_c:]\\n                tmp = _CUM[(_CUM<=k) & (_CUM>ret)]\\n                if tmp.size:\\n                    ret = tmp.max()\\n            if ret == k:\\n                return ret\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313484,
                "title": "go-optimal-solution-o-n-2-m-log-m-100-time-260ms-100-space-7-2mb",
                "content": "```\\nfunc maxSumSubmatrix(matrix [][]int, k int) int {\\n    m, n := len(matrix), len(matrix[0])\\n    maxSum := math.MinInt32\\n\\n    for i:=0; i<m; i++ {\\n        for j:=1;j<n; j++{\\n            matrix[i][j] += matrix[i][j-1]\\n        }\\n    }\\n    for l:=0; l<n; l++ {\\n        for r:=l; r < n; r++ {\\n            prefixSum, set := 0, Set{0}\\n            for i:=0; i< m; i++ {\\n                sum := matrix[i][r]\\n                if l > 0 {\\n                    sum -= matrix[i][l-1]\\n                }\\n                prefixSum += sum\\n                idx := sort.SearchInts(set, prefixSum-k)\\n                if idx != len(set) {\\n                    maxSum = max(maxSum, prefixSum-set[idx])\\n                }\\n                set.Insert(prefixSum)\\n            }\\n        }\\n    }\\n    \\n    return maxSum\\n}\\n\\ntype Set []int\\n\\nfunc (s *Set) Insert(x int) {\\n\\ti := sort.SearchInts(*s, x)\\n\\tif i == len(*s) {\\n\\t\\t*s = append(*s, x)\\n\\t} else if (*s)[i] != x {\\n\\t\\t*s = append(*s, 0)\\n\\t\\tcopy((*s)[i+1:], (*s)[i:])\\n\\t\\t(*s)[i] = x\\n\\t}\\n}\\n\\nfunc max(a, b int) int {\\n    if a < b {\\n        return b\\n    }\\n    return a\\n}",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc maxSumSubmatrix(matrix [][]int, k int) int {\\n    m, n := len(matrix), len(matrix[0])\\n    maxSum := math.MinInt32\\n\\n    for i:=0; i<m; i++ {\\n        for j:=1;j<n; j++{\\n            matrix[i][j] += matrix[i][j-1]\\n        }\\n    }\\n    for l:=0; l<n; l++ {\\n        for r:=l; r < n; r++ {\\n            prefixSum, set := 0, Set{0}\\n            for i:=0; i< m; i++ {\\n                sum := matrix[i][r]\\n                if l > 0 {\\n                    sum -= matrix[i][l-1]\\n                }\\n                prefixSum += sum\\n                idx := sort.SearchInts(set, prefixSum-k)\\n                if idx != len(set) {\\n                    maxSum = max(maxSum, prefixSum-set[idx])\\n                }\\n                set.Insert(prefixSum)\\n            }\\n        }\\n    }\\n    \\n    return maxSum\\n}\\n\\ntype Set []int\\n\\nfunc (s *Set) Insert(x int) {\\n\\ti := sort.SearchInts(*s, x)\\n\\tif i == len(*s) {\\n\\t\\t*s = append(*s, x)\\n\\t} else if (*s)[i] != x {\\n\\t\\t*s = append(*s, 0)\\n\\t\\tcopy((*s)[i+1:], (*s)[i:])\\n\\t\\t(*s)[i] = x\\n\\t}\\n}\\n\\nfunc max(a, b int) int {\\n    if a < b {\\n        return b\\n    }\\n    return a\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1313021,
                "title": "python3-sortedlist-time-is-o-m-2-n-log-n-accepted",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        CSr = [ None for _ in matrix]\\n        for i,row in enumerate(matrix):\\n            CSr[i] = list(accumulate(row, initial=0))\\n        \\n        best = float(\\'-inf\\')\\n        \\n        for r1 in range(M):\\n            Srow = [0]*(N+1)\\n            for r2 in range(r1+1,M+1):\\n                Srow = [a+b for a,b in zip(Srow,CSr[r2-1])]\\n                SL = SortedList(Srow)\\n                for c in range(N):\\n                    target = k + Srow[c]\\n                    SL.remove(Srow[c])\\n                    j = SL.bisect(target)-1\\n                    if j<0:\\n                        continue\\n                    best = max(best, SL[j]-Srow[c])\\n        \\n        return best\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        CSr = [ None for _ in matrix]\\n        for i,row in enumerate(matrix):\\n            CSr[i] = list(accumulate(row, initial=0))\\n        \\n        best = float(\\'-inf\\')\\n        \\n        for r1 in range(M):\\n            Srow = [0]*(N+1)\\n            for r2 in range(r1+1,M+1):\\n                Srow = [a+b for a,b in zip(Srow,CSr[r2-1])]\\n                SL = SortedList(Srow)\\n                for c in range(N):\\n                    target = k + Srow[c]\\n                    SL.remove(Srow[c])\\n                    j = SL.bisect(target)-1\\n                    if j<0:\\n                        continue\\n                    best = max(best, SL[j]-Srow[c])\\n        \\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312803,
                "title": "max-sum-of-rectangle-c-explained",
                "content": "At first glance, you may feel that it is very big, but believe me it is as simple as you read it.\\n**Part 1**\\nIdea is simple, suppose you are doing the same problem with 1D array then what should we do ?\\nFor 1D array just iterate the array and store the prefix sum in a set (for binary search), every time find the lower bound of the required value\\n(**as we stored prefix sum so for a sub array, form i to j, sum[i, j] = sum[j] - sum[i-1], let X = sum[j] - sum[i-1], then we find value of X such that runningSum - X <= k)**\\nWe can do this by lower_bound function in C++ and bisect_left in python;\\n\\n**Part 2**\\nNow think Matrix =>\\n1. iterate in every row ,from curr row to last row add numbers in every col store in a 1D array ( ofCourse size will be no. of columns)\\n2. Now apply the above algo in this 1D array and update the result\\n3. we will do this for every row as in step 1 and final result returned\\n\\nThis looks good but we can furthure optimize it =>\\ntime complexity of part 1 => O(nlog(n))\\ntime complexity of part 2 => O(m*m)\\n So we can take m as smaller dimension and n as bigger dimension \\n so if columns > row , then squeez rows\\n else squeez columns\\n \\n This will give => O(min(m,n)2*max(m,n)*log(max(m,n))\\n\\nsee comment for working example\\n```\\nstatic auto ______ = [](){\\n    std::ios_base::sync_with_stdio(0);\\n    cin.tie(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int m, n, K, result = INT_MIN;\\n    \\n\\t// you an skip this part\\n\\t// basically kadane\\'s algo is for fast look up max sum, so if we get the value less tha k, we don\\'t need to check part 1\\n    /* int kadaneAlgo(vector<int> nums){\\n        int maxSum=INT_MIN, currMaxSum = 0;\\n        for(int num : nums){\\n            currMaxSum = max(currMaxSum+num, num);\\n            maxSum = max(maxSum, currMaxSum);\\n        } \\n        return maxSum;\\n    }\\n    */\\n    void updateResult(vector<int> nums){\\n       //  int kadaneSum = kadaneAlgo(nums);\\n       // if(kadaneSum <= K) {\\n          //  result = max(result, kadaneSum);\\n           // return;\\n       // }\\n        int sum=0;\\n        set<int> s;\\n        s.insert(sum);\\n        for(int num : nums){\\n            sum+=num;\\n            auto tmp = s.lower_bound(sum-K);\\n            if(tmp != s.end()) result = max(result, sum- *tmp);\\n            s.insert(sum);\\n        }\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        K=k, m=matrix.size(), n=matrix[0].size();\\n        if(n > m){   // columns greater than rows \\n            vector<int> rowSum(n);   // sqeeze rows into a single array\\n            for(int i=0; i<m; i++){\\n                fill(rowSum.begin(), rowSum.end(), 0);\\n                for(int row=i; row<m; row++){    // convert from ith row till last row into a single 1D array\\n                    for(int col=0; col<n; col++){\\n                        rowSum[col] += matrix[row][col];\\n                    }\\n                    updateResult(rowSum);\\n                }\\n            }\\n            if(result == k)return result;\\n        }\\n        else{ // squeez columns into a single array\\n            vector<int> colSum(m);\\n            for(int i=0; i<n; i++){\\n                fill(colSum.begin(), colSum.end(), 0);\\n                for(int col=i; col<n; col++){\\n                    for(int row=0; row < m; row++)\\n                        colSum[row] += matrix[row][col];\\n                    updateResult(colSum);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n**if you find it helpful, plz upvote**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic auto ______ = [](){\\n    std::ios_base::sync_with_stdio(0);\\n    cin.tie(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int m, n, K, result = INT_MIN;\\n    \\n\\t// you an skip this part\\n\\t// basically kadane\\'s algo is for fast look up max sum, so if we get the value less tha k, we don\\'t need to check part 1\\n    /* int kadaneAlgo(vector<int> nums){\\n        int maxSum=INT_MIN, currMaxSum = 0;\\n        for(int num : nums){\\n            currMaxSum = max(currMaxSum+num, num);\\n            maxSum = max(maxSum, currMaxSum);\\n        } \\n        return maxSum;\\n    }\\n    */\\n    void updateResult(vector<int> nums){\\n       //  int kadaneSum = kadaneAlgo(nums);\\n       // if(kadaneSum <= K) {\\n          //  result = max(result, kadaneSum);\\n           // return;\\n       // }\\n        int sum=0;\\n        set<int> s;\\n        s.insert(sum);\\n        for(int num : nums){\\n            sum+=num;\\n            auto tmp = s.lower_bound(sum-K);\\n            if(tmp != s.end()) result = max(result, sum- *tmp);\\n            s.insert(sum);\\n        }\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        K=k, m=matrix.size(), n=matrix[0].size();\\n        if(n > m){   // columns greater than rows \\n            vector<int> rowSum(n);   // sqeeze rows into a single array\\n            for(int i=0; i<m; i++){\\n                fill(rowSum.begin(), rowSum.end(), 0);\\n                for(int row=i; row<m; row++){    // convert from ith row till last row into a single 1D array\\n                    for(int col=0; col<n; col++){\\n                        rowSum[col] += matrix[row][col];\\n                    }\\n                    updateResult(rowSum);\\n                }\\n            }\\n            if(result == k)return result;\\n        }\\n        else{ // squeez columns into a single array\\n            vector<int> colSum(m);\\n            for(int i=0; i<n; i++){\\n                fill(colSum.begin(), colSum.end(), 0);\\n                for(int col=i; col<n; col++){\\n                    for(int row=0; row < m; row++)\\n                        colSum[row] += matrix[row][col];\\n                    updateResult(colSum);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143118,
                "title": "java-dynamic-programming-treeset-binary-search-beats-91-o-col-col-row-log-row",
                "content": "\\n    // O(col*col*row*log(row))\\n\\tpublic static int maxSumSubmatrix(int[][] matrix, int k) {\\n\\n\\t\\tint row = matrix.length, col = matrix[0].length, max = Integer.MIN_VALUE;\\n\\t\\tfor (int left = 0; left < col; left++) {\\n\\t\\t\\tint[] temp = new int[row];\\n\\t\\t\\tfor (int right = left; right < col; right++) {\\n\\t\\t\\t\\tfor (int i = 0; i < row; i++)\\n\\t\\t\\t\\t\\ttemp[i] += matrix[i][right];\\n\\t\\t\\t\\tint sum = maxSubArrayK(temp, k);\\n\\t\\t\\t\\tif (sum > max)\\n\\t\\t\\t\\t\\tmax = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\t// O(nlogn)\\n\\tpublic static int maxSubArrayK(int[] temp, int k) {\\n\\n\\t\\tint sum = kadanes(temp);\\n\\t\\tif (sum <= k)\\n\\t\\t\\treturn sum;\\n\\t\\tTreeSet<Integer> set = new TreeSet<>();\\n\\t\\tset.add(0);\\n\\t\\tint csum = 0, len = temp.length, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tcsum += temp[i];\\n\\t\\t\\tInteger set2 = set.ceiling(csum - k);\\n\\t\\t\\tif (set2 != null) {\\n\\t\\t\\t\\tif (csum - set2 > max)\\n\\t\\t\\t\\t\\tmax = csum - set2;\\n\\t\\t\\t}\\n\\t\\t\\tset.add(csum);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\t// Kadanes\\n\\t// O(n)\\n\\tpublic static int kadanes(int[] temp) {\\n\\t\\tint omax = temp[0], cmax = temp[0], len = temp.length;\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tcmax += temp[i];\\n\\t\\t\\tif (temp[i] > cmax)\\n\\t\\t\\t\\tcmax = temp[i];\\n\\t\\t\\tif (cmax > omax)\\n\\t\\t\\t\\tomax = cmax;\\n\\t\\t}\\n\\t\\treturn omax;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // O(col*col*row*log(row))\\n\\tpublic static int maxSumSubmatrix(int[][] matrix, int k) {\\n\\n\\t\\tint row = matrix.length, col = matrix[0].length, max = Integer.MIN_VALUE;\\n\\t\\tfor (int left = 0; left < col; left++) {\\n\\t\\t\\tint[] temp = new int[row];\\n\\t\\t\\tfor (int right = left; right < col; right++) {\\n\\t\\t\\t\\tfor (int i = 0; i < row; i++)\\n\\t\\t\\t\\t\\ttemp[i] += matrix[i][right];\\n\\t\\t\\t\\tint sum = maxSubArrayK(temp, k);\\n\\t\\t\\t\\tif (sum > max)\\n\\t\\t\\t\\t\\tmax = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\t// O(nlogn)\\n\\tpublic static int maxSubArrayK(int[] temp, int k) {\\n\\n\\t\\tint sum = kadanes(temp);\\n\\t\\tif (sum <= k)\\n\\t\\t\\treturn sum;\\n\\t\\tTreeSet<Integer> set = new TreeSet<>();\\n\\t\\tset.add(0);\\n\\t\\tint csum = 0, len = temp.length, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tcsum += temp[i];\\n\\t\\t\\tInteger set2 = set.ceiling(csum - k);\\n\\t\\t\\tif (set2 != null) {\\n\\t\\t\\t\\tif (csum - set2 > max)\\n\\t\\t\\t\\t\\tmax = csum - set2;\\n\\t\\t\\t}\\n\\t\\t\\tset.add(csum);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\t// Kadanes\\n\\t// O(n)\\n\\tpublic static int kadanes(int[] temp) {\\n\\t\\tint omax = temp[0], cmax = temp[0], len = temp.length;\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tcmax += temp[i];\\n\\t\\t\\tif (temp[i] > cmax)\\n\\t\\t\\t\\tcmax = temp[i];\\n\\t\\t\\tif (cmax > omax)\\n\\t\\t\\t\\tomax = cmax;\\n\\t\\t}\\n\\t\\treturn omax;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 579734,
                "title": "java-easy-clean-code",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] arr, int k) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int maxK = Integer.MIN_VALUE;\\n        for(int i = 0; i < cols; i++){\\n            int dp[] = new int[rows];\\n            for(int j = i; j < cols; j++){\\n                for(int l = 0; l < rows; l++){\\n                    dp[l] += arr[l][j];\\n                }\\n                int currSum = maxSubArray(dp, k);\\n                maxK = Math.max(maxK, currSum);                 \\n                if(maxK == k)\\n                    return k;\\n            }\\n        }\\n        return maxK;\\n    }\\n    public int maxSubArray(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int currSum = 0;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            currSum += arr[i];\\n            Integer ceilValue = set.ceiling(currSum - k);\\n            if(ceilValue != null) {\\n                max = Math.max(max, currSum - ceilValue);\\n            }\\n            set.add(currSum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] arr, int k) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int maxK = Integer.MIN_VALUE;\\n        for(int i = 0; i < cols; i++){\\n            int dp[] = new int[rows];\\n            for(int j = i; j < cols; j++){\\n                for(int l = 0; l < rows; l++){\\n                    dp[l] += arr[l][j];\\n                }\\n                int currSum = maxSubArray(dp, k);\\n                maxK = Math.max(maxK, currSum);                 \\n                if(maxK == k)\\n                    return k;\\n            }\\n        }\\n        return maxK;\\n    }\\n    public int maxSubArray(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int currSum = 0;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            currSum += arr[i];\\n            Integer ceilValue = set.ceiling(currSum - k);\\n            if(ceilValue != null) {\\n                max = Math.max(max, currSum - ceilValue);\\n            }\\n            set.add(currSum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461411,
                "title": "easy-to-understand",
                "content": "Updated a little bit based on this solution: [JavaScript-Solution-Kadane\\'s\\n](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/407822/JavaScript-Solution-Kadane\\'s)\\n\\n#### Idea:\\n1. Basically brute-force.\\n2. Iterate from every column to the last column,\\n3. Calculate running sum for each row,\\n4. Calculate rectangle sum for each possibility on the way\\n5. Update the target max.\\n\\n```javascript\\nconst maxSumSubmatrix = function(matrix, k) {\\n  let max = -Infinity;\\n  const R = matrix.length, C = matrix[0].length;\\n  const sums = Array(R);\\n  // Try starting from column 0 to the rightmost column\\n  for (let c1 = 0; c1 < C; c1 += 1) {\\n    // Because we start with a new column, we should clear sums\\n    sums.fill(0);\\n    // Scan through the rest of the columns\\n    for (let c2 = c1; c2 < C; c2 += 1) {\\n      // Update current sums for each row, sums[r] = sum(matrix[r][c1:c2]) \\n      for (let row = 0; row < R; row += 1) {\\n        sums[row] += matrix[row][c2];\\n      }\\n      // console.log(sums) to see values of sums\\n      for (let r1 = 0; r1 < R; r1 += 1) {\\n        let sum = 0;\\n        for (let r2 = r1; r2 < R; r2 += 1) {\\n          // Calculate sum for current rectangle: sum(matrix[r1:r2, c1:c2])\\n          sum += sums[r2];\\n          // Update target max sum\\n          if (sum > max && sum <= k) {\\n            max = sum;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return max;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst maxSumSubmatrix = function(matrix, k) {\\n  let max = -Infinity;\\n  const R = matrix.length, C = matrix[0].length;\\n  const sums = Array(R);\\n  // Try starting from column 0 to the rightmost column\\n  for (let c1 = 0; c1 < C; c1 += 1) {\\n    // Because we start with a new column, we should clear sums\\n    sums.fill(0);\\n    // Scan through the rest of the columns\\n    for (let c2 = c1; c2 < C; c2 += 1) {\\n      // Update current sums for each row, sums[r] = sum(matrix[r][c1:c2]) \\n      for (let row = 0; row < R; row += 1) {\\n        sums[row] += matrix[row][c2];\\n      }\\n      // console.log(sums) to see values of sums\\n      for (let r1 = 0; r1 < R; r1 += 1) {\\n        let sum = 0;\\n        for (let r2 = r1; r2 < R; r2 += 1) {\\n          // Calculate sum for current rectangle: sum(matrix[r1:r2, c1:c2])\\n          sum += sums[r2];\\n          // Update target max sum\\n          if (sum > max && sum <= k) {\\n            max = sum;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return max;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453435,
                "title": "python-3-o-n-m-2-log-min-n-m-prefix-sum-with-dp-sliding-window-rb-tree",
                "content": "1. First just create a prefix sum of each row\\n2. Next we are going to do sliding window by starting off with rectangles of col length 1, then 2, then 3, then 4, and sliding those to every single possible spot. We just take each x1 and x2 and move them around all possible y spots.\\n3. This is probably the most difficult to understand part. There\\'s a special technique to drop the complexity from n^2 to nlogn. We can run an accumulator, and remember the past sums we found in a balanced tree, and every time we are on the next step, we can subtract from our current accumulated sum any old accumulated sum to get the true sum of a particular sub-rectangle. This lets us avoid manually checking each rectangle formed when sliding down the rows, and just let\\'s us do a linear sweep, and with each operation, doing a log(n) search to find the closest fitting element within our RB tree. Each time we find a possible solution, just check if the maximum is greater than the current.\\n\\nJust as a side note, Kadane\\'s algorithm fails in this problem because it only works without a given bound; this problem isn\\'t as deterministic, you need to actually take a look at what you got so far every time, rather than just the best previous.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        maxSum = -sys.maxsize\\n\\n        #prefix sum\\n        for i in range(m):\\n            for j in range(1,n):\\n                    matrix[i][j] += matrix[i][j-1]\\n        \\n        for x1 in range(n):\\n            for x2 in range(x1 , n):\\n                rectAcc = 0\\n                seen = SortedList()\\n                seen.add(0)\\n                for y in range(m):\\n                    rectAcc += matrix[y][x2] - (matrix[y][x1 - 1] if x1 > 0 else 0)\\n                    currTargetLoc = seen.bisect_left(rectAcc - k)\\n                    \\n                    if(currTargetLoc < len(seen)):\\n                        maxSum = max(maxSum, rectAcc - seen[currTargetLoc])\\n                        \\n                    seen.add(rectAcc)\\n                    \\n        return maxSum\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        maxSum = -sys.maxsize\\n\\n        #prefix sum\\n        for i in range(m):\\n            for j in range(1,n):\\n                    matrix[i][j] += matrix[i][j-1]\\n        \\n        for x1 in range(n):\\n            for x2 in range(x1 , n):\\n                rectAcc = 0\\n                seen = SortedList()\\n                seen.add(0)\\n                for y in range(m):\\n                    rectAcc += matrix[y][x2] - (matrix[y][x1 - 1] if x1 > 0 else 0)\\n                    currTargetLoc = seen.bisect_left(rectAcc - k)\\n                    \\n                    if(currTargetLoc < len(seen)):\\n                        maxSum = max(maxSum, rectAcc - seen[currTargetLoc])\\n                        \\n                    seen.add(rectAcc)\\n                    \\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252043,
                "title": "javascript",
                "content": "Solution mirrors the exact steps in this video: https://www.youtube.com/watch?v=yCQN096CwWM\\n   ```\\n    function maxSumSubmatrix(matrix, k) {\\n        const row = matrix.length, col = matrix[0].length;\\n        let result = -Infinity;\\n        for (let i = 0; i < col; i++) {\\n            let rowSum = Array(row).fill(0);\\n            for (let j = i; j < col; j++) {\\n                let sum = 0, max = -Infinity;\\n                for (let r = 0; r < row; r++) {\\n                    rowSum[r] += matrix[r][j];\\n                    if (sum < 0) sum = 0;\\n                    sum += rowSum[r];\\n                    max = Math.max(max, sum)\\n                }\\n                if (max <= k) result = Math.max(result, max)\\n                else {\\n                    max = -Infinity;\\n                    for (let m = 0; m < row; m++) {\\n                        sum = 0;\\n                        for (let n = m; n < row; n++) {\\n                            sum += rowSum[n];\\n                            if (sum <= k) max = Math.max(max, sum)\\n                        }\\n                    }\\n                    result = Math.max(result, max)\\n                }\\n                if (result === k) return k;\\n            }\\n        }\\n        return result;\\n    }\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    function maxSumSubmatrix(matrix, k) {\\n        const row = matrix.length, col = matrix[0].length;\\n        let result = -Infinity;\\n        for (let i = 0; i < col; i++) {\\n            let rowSum = Array(row).fill(0);\\n            for (let j = i; j < col; j++) {\\n                let sum = 0, max = -Infinity;\\n                for (let r = 0; r < row; r++) {\\n                    rowSum[r] += matrix[r][j];\\n                    if (sum < 0) sum = 0;\\n                    sum += rowSum[r];\\n                    max = Math.max(max, sum)\\n                }\\n                if (max <= k) result = Math.max(result, max)\\n                else {\\n                    max = -Infinity;\\n                    for (let m = 0; m < row; m++) {\\n                        sum = 0;\\n                        for (let n = m; n < row; n++) {\\n                            sum += rowSum[n];\\n                            if (sum <= k) max = Math.max(max, sum)\\n                        }\\n                    }\\n                    result = Math.max(result, max)\\n                }\\n                if (result === k) return k;\\n            }\\n        }\\n        return result;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 83610,
                "title": "python-o-n-4-solution",
                "content": "Convert the problem to 1-D and them find max subarray no larger than K.\\n\\n    class Solution(object):\\n        def maxSumSubmatrix(self, matrix, k):\\n            maxSum = -9999999\\n            horizontalSum = [[0 for j in xrange(0, len(matrix[0]) + 1)] for i in xrange(0, len(matrix))]\\n            for i in xrange(0, len(matrix)):\\n                for j in xrange(0, len(matrix[0])):\\n                    horizontalSum[i][j] = horizontalSum[i][j - 1] + matrix[i][j]\\n            for cola in xrange(0, len(matrix[0])):\\n                for colb in xrange(cola, len(matrix[0])):\\n                    bilist, vsum = [0], 0\\n                    for i in xrange(0, len(matrix)):\\n                        vsumj = horizontalSum[i][colb] - horizontalSum[i][cola - 1]\\n                        vsum += vsumj\\n                        i = bisect.bisect_left(bilist, vsum - k)\\n                        if i < len(bilist):\\n                            maxSum = max(maxSum, vsum - bilist[i])\\n                        bisect.insort(bilist, vsum)\\n            return maxSum",
                "solutionTags": [],
                "code": "Convert the problem to 1-D and them find max subarray no larger than K.\\n\\n    class Solution(object):\\n        def maxSumSubmatrix(self, matrix, k):\\n            maxSum = -9999999\\n            horizontalSum = [[0 for j in xrange(0, len(matrix[0]) + 1)] for i in xrange(0, len(matrix))]\\n            for i in xrange(0, len(matrix)):\\n                for j in xrange(0, len(matrix[0])):\\n                    horizontalSum[i][j] = horizontalSum[i][j - 1] + matrix[i][j]\\n            for cola in xrange(0, len(matrix[0])):\\n                for colb in xrange(cola, len(matrix[0])):\\n                    bilist, vsum = [0], 0\\n                    for i in xrange(0, len(matrix)):\\n                        vsumj = horizontalSum[i][colb] - horizontalSum[i][cola - 1]\\n                        vsum += vsumj\\n                        i = bisect.bisect_left(bilist, vsum - k)\\n                        if i < len(bilist):\\n                            maxSum = max(maxSum, vsum - bilist[i])\\n                        bisect.insort(bilist, vsum)\\n            return maxSum",
                "codeTag": "Java"
            },
            {
                "id": 83636,
                "title": "java-244ms-applying",
                "content": "Refer to [This solution][1]\\n\\n\\n    public class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        //Assuming that rows is larger than the number of cols\\n\\n        int row=matrix.length, col=matrix[0].length;\\n        int minDf=Integer.MAX_VALUE;\\n        for(int left=0;left<col;left++){\\n            int[] tmp=new int[row];\\n            for(int right=left;right<col;right++){\\n                TreeSet<Integer> set=new TreeSet<>();\\n                int cursum=0;\\n                for(int i=0;i<row;i++){\\n                    tmp[i]+=matrix[i][right];\\n                    cursum+=tmp[i];\\n                    if(cursum==k) return k;\\n                    if(cursum<k) minDf=Math.min(minDf,k-cursum);\\n                    Integer x=set.ceiling(cursum-k);\\n                    if(x!=null && cursum-x<=k) minDf=Math.min(minDf,k-cursum+x);\\n                    if(minDf==0) return k;\\n                    set.add(cursum);\\n                }\\n            }\\n        }\\n        return k-minDf;\\n    }\\n}\\n\\n\\n  [1]: https://leetcode.com/discuss/109749/accepted-c-codes-with-explanation-and-references",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        //Assuming that rows is larger than the number of cols\\n\\n        int row=matrix.length, col=matrix[0].length;\\n        int minDf=Integer.MAX_VALUE;\\n        for(int left=0;left<col;left++){\\n            int[] tmp=new int[row];\\n            for(int right=left;right<col;right++){\\n                TreeSet<Integer> set=new TreeSet<>();\\n                int cursum=0;\\n                for(int i=0;i<row;i++){\\n                    tmp[i]+=matrix[i][right];\\n                    cursum+=tmp[i];\\n                    if(cursum==k) return k;\\n                    if(cursum<k) minDf=Math.min(minDf,k-cursum);\\n                    Integer x=set.ceiling(cursum-k);\\n                    if(x!=null && cursum-x<=k) minDf=Math.min(minDf,k-cursum+x);\\n                    if(minDf==0) return k;\\n                    set.add(cursum);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3250225,
                "title": "363-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Firstly, iterate over all the columns starting from 0 to n. For each iteration, the sum of the values in the current column and all the previous columns will be stored in the list temp.\\n2. Using the Kadane\\'s algorithm, find the maximum sum of a subarray with a sum less than or equal to k in the list temp.\\n3. Update the maximum sum of a subarray found so far.\\n4. Return the maximum sum of a subarray found so far.\\n\\n\\nThe problem asks us to find the maximum sum of a subrectangle in a given matrix matrix such that the sum is no larger than a given integer k.\\n\\nThe solution uses a nested loop to iterate over all the possible subrectangles in the matrix. The outer loop iterates over the left column index left, and the inner loop iterates over the right column index right that is to the right of left. This ensures that we are considering all possible subrectangles that start from column left and end at column right.\\n\\nFor each subrectangle, the solution calculates the sum of each row in the subrectangle by iterating over the rows of the matrix. The row sums are stored in the list temp.\\n\\nThe problem now reduces to finding the maximum sum of a subarray in temp such that the sum is no larger than k. The solution uses Kadane\\'s algorithm to solve this subproblem. Kadane\\'s algorithm is a dynamic programming algorithm that can be used to find the maximum subarray sum in a given array.\\n\\nThe solution maintains a list cum_sum_set that stores the cumulative sum of the elements in temp. For each cumulative sum cum_sum, the solution finds the largest cumulative sum cum_sum_prev in cum_sum_set such that cum_sum - cum_sum_prev is no larger than k. This is done using the bisect_left function from the bisect module.\\n\\nIf such a cum_sum_prev is found, the solution updates the maximum sum found so far as cum_sum - cum_sum_prev.\\n\\nFinally, the solution returns the maximum sum found over all subrectangles.\\n# Complexity\\n- Time complexity:\\n75.76%\\n\\n- Space complexity:\\n67.10%\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \\n        # Getting the dimensions of the matrix\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # Initializing the maximum sum\\n        max_sum = -float(\\'inf\\')\\n        \\n        # Iterating over all the columns\\n        for left in range(n):\\n            \\n            # Initializing the temporary sum list\\n            temp = [0] * m\\n            \\n            # Iterating over all the columns to the right of left\\n            for right in range(left, n):\\n                \\n                # Adding the values of the current column to temp\\n                for i in range(m):\\n                    temp[i] += matrix[i][right]\\n                \\n                # Kadane\\'s algorithm to find the maximum sum of a subarray with sum less than or equal to k\\n                cum_sum = 0\\n                cum_sum_set = sorted([0])\\n                \\n                for t in temp:\\n                    cum_sum += t\\n                    it = bisect_left(cum_sum_set, cum_sum - k)\\n                    if it != len(cum_sum_set):\\n                        max_sum = max(max_sum, cum_sum - cum_sum_set[it])\\n                    bisect.insort(cum_sum_set, cum_sum)\\n        \\n        # Returning the maximum sum found\\n        return max_sum\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \\n        # Getting the dimensions of the matrix\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # Initializing the maximum sum\\n        max_sum = -float(\\'inf\\')\\n        \\n        # Iterating over all the columns\\n        for left in range(n):\\n            \\n            # Initializing the temporary sum list\\n            temp = [0] * m\\n            \\n            # Iterating over all the columns to the right of left\\n            for right in range(left, n):\\n                \\n                # Adding the values of the current column to temp\\n                for i in range(m):\\n                    temp[i] += matrix[i][right]\\n                \\n                # Kadane\\'s algorithm to find the maximum sum of a subarray with sum less than or equal to k\\n                cum_sum = 0\\n                cum_sum_set = sorted([0])\\n                \\n                for t in temp:\\n                    cum_sum += t\\n                    it = bisect_left(cum_sum_set, cum_sum - k)\\n                    if it != len(cum_sum_set):\\n                        max_sum = max(max_sum, cum_sum - cum_sum_set[it])\\n                    bisect.insort(cum_sum_set, cum_sum)\\n        \\n        # Returning the maximum sum found\\n        return max_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497906,
                "title": "python-prefix-sum-w-sorted-list-commented-and-explained",
                "content": "**Intuition**\\n\\nThis question is 2 Hard problems disguised as one:\\n\\n*Problem 1 - Sum of rectangle that satisfies some condition*\\n\\n- Brute-force way of solving this requires enumerating all possible rectangles in `O(m^2 * n^2)`\\n- But while brute-forcing, we will notice that we redo a lot of calculations when building up rectangles (afterall... many sub-rectangles have overlaps with each other).\\n- We can improve our brute-force by using prefix-sums. For a single column, we will create a prefix-sum for each cell. Then we add up all values for the next column, and the next... This prefix-sum array represents a 2D rectangle collapsing into a 1D array. From the 1D array, we can determine which sub-array (and therefore rectangle) satisfies our condition.\\n- Now we just need to figure out what we do with this 1D array, and can we do better than `O(n^2)`?\\n\\n*Problem 2 - Max Sum of sub-array less than k*\\n\\n- It is tempting to just throw Kadane\\'s algorithm. Which would be correct if we simply needed a max sum. However, we need max sum *less than k*, which implies we need some sorting.\\n- One observation/trick we have to realize is that we need to keep track of prefix-sums here as well! And we need to quick way of *extracting* a subarray from the array.\\n- If we keep a `running sum`, and a list of `prefix_sums` we have seen so far, we can extract out a subarray by simply subtracting any `prefix_sum` from `running sum`. This is the main motivation behind keeping a sorted list. It drops the runtime from `O(n^2)` to `O(n*log(n))`\\n- Next is deciding which `prefix_sum` we need from our list. We look at the formula `running_sum - k`. So we apply `bisect_left` to get index of the largest element that satisfies <= `running_sum - k`\\n\\nCombining the two problems above will give us the solution to tackle our main problem. To improve our performance, we make sure # of cols is always less than # of rows. Otherwise, we transpose our matrix.\\n\\n**Solution**\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        res = -math.inf\\n        \\n        m, n = len(matrix), len(matrix[0])\\n\\n        # ensure that cols < rows, otherwise transpose the matrix\\n        if m < n:\\n            matrix = list(zip(*matrix))\\n            m, n = n, m\\n        \\n        # for each column\\n        for col in range(n):\\n            \\n            prefix_sums = [0] * m\\n\\n            for j in range(col, n):\\n                # add current column into the prefix sum array\\n                for i in range(m):\\n                    prefix_sums[i] += matrix[i][j]\\n                \\n                res = max(res, self.maxSumSubarray(prefix_sums, k))\\n                if res == k:\\n                    return res\\n        \\n        return res\\n        \\n        \\n    def maxSumSubarray(self, nums: List[int], k: int) -> int:\\n        # create a sorted list of all prefix sums.\\n        # this allows us to look up desired prefixes\\n        # in O(log(n)) instead of O(n)\\n        prefix = SortedList([0])\\n                \\n        res = -math.inf\\n        \\n        # we keep a running sum of every element we\\'ve seen.\\n        # this allows us to extract a sub-array by simply\\n        # subtracting a previously recorded prefix from the running sum\\n        #\\n        #         [A,   B,     C,       D]\\n        # prefix  [A, A+B, A+B+C, A+B+C+D]\\n        #\\n        # If we want [C,D] and our running sum is (A+B+C+D)\\n        # Then we should subtract (A+B) from running sum to get (C+D).\\n        curr_sum = 0\\n        \\n        for num in nums:\\n            curr_sum += num\\n            \\n            # find the largest prefix that satisfies (curr_sum - k)\\n            i = prefix.bisect_left(curr_sum - k)\\n            if i < len(prefix):\\n                res = max(res, curr_sum - prefix[i])\\n                \\n            # add curr_sum to prefix_sum\\n            prefix.add(curr_sum)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        res = -math.inf\\n        \\n        m, n = len(matrix), len(matrix[0])\\n\\n        # ensure that cols < rows, otherwise transpose the matrix\\n        if m < n:\\n            matrix = list(zip(*matrix))\\n            m, n = n, m\\n        \\n        # for each column\\n        for col in range(n):\\n            \\n            prefix_sums = [0] * m\\n\\n            for j in range(col, n):\\n                # add current column into the prefix sum array\\n                for i in range(m):\\n                    prefix_sums[i] += matrix[i][j]\\n                \\n                res = max(res, self.maxSumSubarray(prefix_sums, k))\\n                if res == k:\\n                    return res\\n        \\n        return res\\n        \\n        \\n    def maxSumSubarray(self, nums: List[int], k: int) -> int:\\n        # create a sorted list of all prefix sums.\\n        # this allows us to look up desired prefixes\\n        # in O(log(n)) instead of O(n)\\n        prefix = SortedList([0])\\n                \\n        res = -math.inf\\n        \\n        # we keep a running sum of every element we\\'ve seen.\\n        # this allows us to extract a sub-array by simply\\n        # subtracting a previously recorded prefix from the running sum\\n        #\\n        #         [A,   B,     C,       D]\\n        # prefix  [A, A+B, A+B+C, A+B+C+D]\\n        #\\n        # If we want [C,D] and our running sum is (A+B+C+D)\\n        # Then we should subtract (A+B) from running sum to get (C+D).\\n        curr_sum = 0\\n        \\n        for num in nums:\\n            curr_sum += num\\n            \\n            # find the largest prefix that satisfies (curr_sum - k)\\n            i = prefix.bisect_left(curr_sum - k)\\n            if i < len(prefix):\\n                res = max(res, curr_sum - prefix[i])\\n                \\n            # add curr_sum to prefix_sum\\n            prefix.add(curr_sum)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490852,
                "title": "c-83-48-faster-medium",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        uint8_t m = matrix.size();\\n        uint8_t n = matrix[0].size();\\n        \\n        int psa[m][n];\\n        psa[0][0] = matrix[0][0];\\n        \\n        for(uint8_t i = 1; i < m; i++)\\n            psa[i][0] = psa[i-1][0] + matrix[i][0];\\n        for(uint8_t i = 1; i < n; i++)\\n            psa[0][i] = psa[0][i-1] + matrix[0][i];\\n        for (uint8_t i = 1; i < m; i++)\\n            for (uint8_t j = 1; j < n; j++)\\n                psa[i][j] = psa[i - 1][j] + psa[i][j - 1] - psa[i - 1][j - 1] + matrix[i][j];\\n        \\n        int maxSum = INT_MIN;\\n        for(uint8_t i = 0; i < m; i++)\\n            for(uint8_t j = 0; j < n; j++)\\n                for(uint8_t p = i; p < m; p++)\\n                    for(uint8_t q = j; q < n; q++)\\n                    {\\n                        int x = psa[p][q] + \\n                            (i > 0 ? -psa[i-1][q] : 0) +\\n                            (j > 0 ? -psa[p][j-1] : 0) +\\n                            (i > 0 && j > 0 ? psa[i-1][j-1] : 0);\\n                        if(x <= k)\\n                            maxSum = max(maxSum, x);\\n                    }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        uint8_t m = matrix.size();\\n        uint8_t n = matrix[0].size();\\n        \\n        int psa[m][n];\\n        psa[0][0] = matrix[0][0];\\n        \\n        for(uint8_t i = 1; i < m; i++)\\n            psa[i][0] = psa[i-1][0] + matrix[i][0];\\n        for(uint8_t i = 1; i < n; i++)\\n            psa[0][i] = psa[0][i-1] + matrix[0][i];\\n        for (uint8_t i = 1; i < m; i++)\\n            for (uint8_t j = 1; j < n; j++)\\n                psa[i][j] = psa[i - 1][j] + psa[i][j - 1] - psa[i - 1][j - 1] + matrix[i][j];\\n        \\n        int maxSum = INT_MIN;\\n        for(uint8_t i = 0; i < m; i++)\\n            for(uint8_t j = 0; j < n; j++)\\n                for(uint8_t p = i; p < m; p++)\\n                    for(uint8_t q = j; q < n; q++)\\n                    {\\n                        int x = psa[p][q] + \\n                            (i > 0 ? -psa[i-1][q] : 0) +\\n                            (j > 0 ? -psa[p][j-1] : 0) +\\n                            (i > 0 && j > 0 ? psa[i-1][j-1] : 0);\\n                        if(x <= k)\\n                            maxSum = max(maxSum, x);\\n                    }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490775,
                "title": "c-computing-back-sum-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int maxSum = INT_MIN;\\n        \\n        for(int l = 0; l < n; l++) {\\n            vector<int> sumArr(m, 0);\\n            for(int r = l; r < n; r++) {\\n                for(int i = 0; i < m; i++) sumArr[i] += matrix[i][r];\\n                for(int i = 0; i < m; i++) {\\n                    int sum = 0;\\n                    for(int j = i; j < m; j++) {\\n                        sum += sumArr[j];\\n                        if(sum > maxSum && sum <= k) maxSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n};\\n```\\n**PLEASE UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int maxSum = INT_MIN;\\n        \\n        for(int l = 0; l < n; l++) {\\n            vector<int> sumArr(m, 0);\\n            for(int r = l; r < n; r++) {\\n                for(int i = 0; i < m; i++) sumArr[i] += matrix[i][r];\\n                for(int i = 0; i < m; i++) {\\n                    int sum = 0;\\n                    for(int j = i; j < m; j++) {\\n                        sum += sumArr[j];\\n                        if(sum > maxSum && sum <= k) maxSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490503,
                "title": "c-prefix-sum-easy-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>> &matrix, int tar)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans = INT_MIN;\\n        vector<vector<int>> dp(m + 1, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                dp[i + 1][j] = dp[i][j] + matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int l = i + 1; l <= m; l++)\\n            {\\n                for (int j = 0; j < n; j++)\\n                {\\n                    int val = 0;\\n                    for (int k = j; k < n; k++)\\n                    {\\n                        val += dp[l][k] - dp[i][k];\\n\\n                        if (val < tar)\\n                        {\\n                            ans = max(ans, val);\\n                        }\\n                        else if (val == tar)\\n                        {\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>> &matrix, int tar)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans = INT_MIN;\\n        vector<vector<int>> dp(m + 1, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                dp[i + 1][j] = dp[i][j] + matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int l = i + 1; l <= m; l++)\\n            {\\n                for (int j = 0; j < n; j++)\\n                {\\n                    int val = 0;\\n                    for (int k = j; k < n; k++)\\n                    {\\n                        val += dp[l][k] - dp[i][k];\\n\\n                        if (val < tar)\\n                        {\\n                            ans = max(ans, val);\\n                        }\\n                        else if (val == tar)\\n                        {\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490332,
                "title": "c-code-for-beginners-easy-code",
                "content": "You can precompute a 2D prefix array, and then use a 2D sliding window to get the largest rectangle with sum<=k\\n\\nBut, I am using the other approach using the binary search and Kadanes\\n```\\nclass Solution {\\npublic:\\n    int BinarySearch(vector<int> &arr, int k){\\n        int res=INT_MIN;\\n        int sum=0;\\n        set<int> s;\\n        s.insert(0);\\n        for(int i=0;i<arr.size();i++){\\n            sum+=arr[i];\\n            auto it=s.lower_bound(sum-k);\\n//the reason why we take lower bound is--> let\\'s say, at any general index idx, the prefix sum is cur. We take lower bound of (cur- k). This will give me a value greater than or equal to (cur-k) , lets say we got cur-k + lambda, where lambda>=0. So the sum of the segment that we get is cur - (cur - k + lambda) = k-lambda. So we can clearly see, we got a value less than or equal to k, as lambda>=0.\\n            if(it!=s.end()){\\n                res=max(res,sum-*it);\\n            }\\n            if(res==k){\\n                return k;\\n            }\\n            s.insert(sum);\\n        }  \\n        return res;\\n    }\\n    \\n    int KadaneAlgo(vector<int> &arr, int k){\\n        int sum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<arr.size();i++){\\n            sum+=arr[i];\\n            maxSum=max(maxSum,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        maxSum=max(maxSum,*max_element(arr.begin(),arr.end()));\\n        return maxSum;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& M, int k) {\\n        int res=INT_MIN;\\n        int R=M.size();       \\n        int C=M[0].size();\\n        for(int i=0;i<C;i++){\\n            vector<int> arr(R,0);\\n            for(int j=i;j<C;j++){\\n                for(int k=0;k<R;k++){\\n                    arr[k]+=M[k][j];\\n                }\\n                int tempSum=KadaneAlgo(arr,k);\\n                if(tempSum==k){\\n                    return k;\\n                }\\n                else if(tempSum<k){\\n                    res=max(res,tempSum);\\n                }\\n                else{\\n                    tempSum=BinarySearch(arr,k);\\n                    res=max(res,tempSum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BinarySearch(vector<int> &arr, int k){\\n        int res=INT_MIN;\\n        int sum=0;\\n        set<int> s;\\n        s.insert(0);\\n        for(int i=0;i<arr.size();i++){\\n            sum+=arr[i];\\n            auto it=s.lower_bound(sum-k);\\n//the reason why we take lower bound is--> let\\'s say, at any general index idx, the prefix sum is cur. We take lower bound of (cur- k). This will give me a value greater than or equal to (cur-k) , lets say we got cur-k + lambda, where lambda>=0. So the sum of the segment that we get is cur - (cur - k + lambda) = k-lambda. So we can clearly see, we got a value less than or equal to k, as lambda>=0.\\n            if(it!=s.end()){\\n                res=max(res,sum-*it);\\n            }\\n            if(res==k){\\n                return k;\\n            }\\n            s.insert(sum);\\n        }  \\n        return res;\\n    }\\n    \\n    int KadaneAlgo(vector<int> &arr, int k){\\n        int sum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<arr.size();i++){\\n            sum+=arr[i];\\n            maxSum=max(maxSum,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        maxSum=max(maxSum,*max_element(arr.begin(),arr.end()));\\n        return maxSum;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& M, int k) {\\n        int res=INT_MIN;\\n        int R=M.size();       \\n        int C=M[0].size();\\n        for(int i=0;i<C;i++){\\n            vector<int> arr(R,0);\\n            for(int j=i;j<C;j++){\\n                for(int k=0;k<R;k++){\\n                    arr[k]+=M[k][j];\\n                }\\n                int tempSum=KadaneAlgo(arr,k);\\n                if(tempSum==k){\\n                    return k;\\n                }\\n                else if(tempSum<k){\\n                    res=max(res,tempSum);\\n                }\\n                else{\\n                    tempSum=BinarySearch(arr,k);\\n                    res=max(res,tempSum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489199,
                "title": "c-prefix-sum-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488864,
                "title": "c-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int res = INT_MIN;\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        \\n        for(int l = 0;l < cols;++l){\\n            vector<int> sums(rows);\\n            for(int r = l;r < cols;++r){\\n                for(int i=0;i<rows;++i){\\n                    sums[i] += matrix[i][r];\\n                }\\n                set<int> s = {0};\\n                int run_sum = 0;\\n                for(int sum : sums){\\n                    run_sum += sum;\\n                    auto it = s.lower_bound(run_sum - k);\\n                    if(it != end(s)){\\n                        res = max(res,run_sum - *it);\\n                    }\\n                    s.insert(run_sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int res = INT_MIN;\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        \\n        for(int l = 0;l < cols;++l){\\n            vector<int> sums(rows);\\n            for(int r = l;r < cols;++r){\\n                for(int i=0;i<rows;++i){\\n                    sums[i] += matrix[i][r];\\n                }\\n                set<int> s = {0};\\n                int run_sum = 0;\\n                for(int sum : sums){\\n                    run_sum += sum;\\n                    auto it = s.lower_bound(run_sum - k);\\n                    if(it != end(s)){\\n                        res = max(res,run_sum - *it);\\n                    }\\n                    s.insert(run_sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488861,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[] sum = new int[n];\\n        int maxSum = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i<m; i++){\\n            Arrays.fill(sum,0);\\n            \\n            for(int j = i; j<m; j++){\\n                \\n                for(int r = 0; r<n; r++){\\n                    sum[r] += matrix[r][j];\\n                }\\n                \\n                int currMax = findMaxSubarraySum(sum,k);\\n                maxSum = Math.max(currMax, maxSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n    \\n    \\n    public int findMaxSubarraySum(int a[], int k) {\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < a.length; i++) {\\n            int tsum = 0;\\n            for (int j = i; j < a.length; j++) {\\n                tsum += a[j];\\n                if (tsum <= k)\\n                    max = Math.max(max, tsum);\\n            }\\n        }\\n        return max;\\n    }\\n\\n}\\n\\n\\n\\n//     public static int kadane(int[] arr, int k){\\n//         int n = arr.length;\\n//         int max = Integer.MIN_VALUE;\\n//         int sum = 0;\\n//         for(int i = 0; i<n; i++){\\n//             sum = sum+arr[i];\\n            \\n//             if(sum<0){\\n//                 sum = 0;\\n//             }\\n//             if(sum>max){\\n//                 max = sum;\\n//             }\\n//         }\\n//         return max;\\n//     }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[] sum = new int[n];\\n        int maxSum = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i<m; i++){\\n            Arrays.fill(sum,0);\\n            \\n            for(int j = i; j<m; j++){\\n                \\n                for(int r = 0; r<n; r++){\\n                    sum[r] += matrix[r][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2488688,
                "title": "c-rust-2d-prefix-sum-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/8ad79f0a-27ea-42b0-a2b6-27e731a047d7_1661577986.1099648.png)\\n# Rust Code\\n\\n\\timpl Solution {\\n\\t\\tpub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n\\t\\t\\tlet m: usize = matrix.len();        \\n\\t\\t\\tlet n: usize = matrix[0].len();\\n\\t\\t\\tlet mut pre_sum = vec![vec![0;n+1];m+1];\\n\\t\\t\\tfor i in 1..=m {\\n\\t\\t\\t\\tfor j in 1..=n {\\n\\t\\t\\t\\t\\tpre_sum[i][j]=-pre_sum[i-1][j-1]+pre_sum[i-1][j]+pre_sum[i][j-1]+matrix[i-1][j-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// println!(\"{:?}\", pre_sum);\\n\\n\\t\\t\\tlet mut ans: i32 = -12222;\\n\\t\\t\\tfor sr in 1..=m {\\n\\t\\t\\t\\tfor sc in 1..=n {\\n\\t\\t\\t\\t\\tfor er in sr..=m {\\n\\t\\t\\t\\t\\t\\tfor ec in sc..=n {\\n\\t\\t\\t\\t\\t\\t\\tlet area = pre_sum[er][ec]-pre_sum[er][sc-1]-pre_sum[sr-1][ec]+pre_sum[sr-1][sc-1];\\n\\t\\t\\t\\t\\t\\t\\tif area <= k {ans = ans.max(area);}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans\\n\\t\\t}\\n\\t}\\n\\n# C# Code\\n\\tpublic class Solution {\\n\\t\\tpublic int MaxSumSubmatrix(int[][] matrix, int k) {\\n\\t\\t\\tvar m = matrix.Length;        \\n\\t\\t\\tvar n = matrix[0].Length;\\n\\t\\t\\tvar preSum = new int[m+1, n+1];\\n\\n\\t\\t\\tfor(int i=1; i<=m; ++i)\\n\\t\\t\\t\\tfor(int j=1; j<=n; ++j)\\n\\t\\t\\t\\t\\tpreSum[i, j] += preSum[i-1, j] + preSum[i, j-1] - preSum[i-1, j-1] + matrix[i-1][j-1];\\n\\n\\t\\t\\tvar ans = -111111;\\n\\n\\t\\t\\tfor(int sr=1; sr<=m; ++sr)\\n\\t\\t\\t\\tfor(int sc=1; sc<=n; ++sc)\\n\\t\\t\\t\\t\\tfor(int er=sr; er<=m; ++er)\\n\\t\\t\\t\\t\\t\\tfor(int ec=sc; ec<=n; ++ec){\\n\\t\\t\\t\\t\\t\\t\\tvar area = preSum[er, ec] - preSum[sr-1, ec] - preSum[er, sc-1] + preSum[sr-1, sc-1];\\n\\t\\t\\t\\t\\t\\t\\tif(area <= k)\\n\\t\\t\\t\\t\\t\\t\\t\\tans = Math.Max(ans, area);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Rust"
                ],
                "code": "class Solution {\\n\\t\\tpublic int MaxSumSubmatrix(int[][] matrix, int k) {\\n\\t\\t\\tvar m = matrix.Length;        \\n\\t\\t\\tvar n = matrix[0].Length;\\n\\t\\t\\tvar preSum = new int[m+1, n+1];\\n\\n\\t\\t\\tfor(int i=1; i<=m; ++i)\\n\\t\\t\\t\\tfor(int j=1; j<=n; ++j)\\n\\t\\t\\t\\t\\tpreSum[i, j] += preSum[i-1, j] + preSum[i, j-1] - preSum[i-1, j-1] + matrix[i-1][j-1];\\n\\n\\t\\t\\tvar ans = -111111;\\n\\n\\t\\t\\tfor(int sr=1; sr<=m; ++sr)\\n\\t\\t\\t\\tfor(int sc=1; sc<=n; ++sc)\\n\\t\\t\\t\\t\\tfor(int er=sr; er<=m; ++er)\\n\\t\\t\\t\\t\\t\\tfor(int ec=sc; ec<=n; ++ec){\\n\\t\\t\\t\\t\\t\\t\\tvar area = preSum[er, ec] - preSum[sr-1, ec] - preSum[er, sc-1] + preSum[sr-1, sc-1];\\n\\t\\t\\t\\t\\t\\t\\tif(area <= k)\\n\\t\\t\\t\\t\\t\\t\\t\\tans = Math.Max(ans, area);\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2488290,
                "title": "java-solution-using-prefix-sum-binary-search-o-nlogn-time-complexity",
                "content": "# Java\\n```\\npublic class Solution {\\n  //Time: O(r2 * clogc)\\n  // SC : O(c)\\n  public int maxSumSubmatrix(int[][] matrix, int k) {\\n    int row = matrix.length;\\n    int col = matrix[0].length;\\n    int max = Integer.MIN_VALUE;\\n    for (int i = 0; i < row; i ++) {\\n      int[] colSum = new int[col];\\n      for (int j = i; j < row; j ++) {\\n        for (int c = 0; c < col; c ++) {\\n          colSum[c] += matrix[j][c];\\n          //System.out.print(colSum[c] + \" \");\\n        }\\n        //System.out.println();\\n        max = Math.max(max, find(colSum, k));\\n      }\\n    }\\n    return max;\\n  }\\n\\n  private int find(int[] sum, int k) {\\n    int result = Integer.MIN_VALUE;\\n    TreeSet<Integer> set = new TreeSet<>();\\n    set.add(0);\\n    int prefixSum = 0;\\n    for(int i = 0; i < sum.length; i++) {\\n      prefixSum += sum[i];\\n\\n      Integer target = set.ceiling(prefixSum - k);\\n\\n      if(target != null) {\\n        result = Math.max(result, prefixSum - target);\\n      }\\n      set.add(prefixSum);\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n  //Time: O(r2 * clogc)\\n  // SC : O(c)\\n  public int maxSumSubmatrix(int[][] matrix, int k) {\\n    int row = matrix.length;\\n    int col = matrix[0].length;\\n    int max = Integer.MIN_VALUE;\\n    for (int i = 0; i < row; i ++) {\\n      int[] colSum = new int[col];\\n      for (int j = i; j < row; j ++) {\\n        for (int c = 0; c < col; c ++) {\\n          colSum[c] += matrix[j][c];\\n          //System.out.print(colSum[c] + \" \");\\n        }\\n        //System.out.println();\\n        max = Math.max(max, find(colSum, k));\\n      }\\n    }\\n    return max;\\n  }\\n\\n  private int find(int[] sum, int k) {\\n    int result = Integer.MIN_VALUE;\\n    TreeSet<Integer> set = new TreeSet<>();\\n    set.add(0);\\n    int prefixSum = 0;\\n    for(int i = 0; i < sum.length; i++) {\\n      prefixSum += sum[i];\\n\\n      Integer target = set.ceiling(prefixSum - k);\\n\\n      if(target != null) {\\n        result = Math.max(result, prefixSum - target);\\n      }\\n      set.add(prefixSum);\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485717,
                "title": "simple-java-solution-with-explanation-prefix-sum-with-brute-force-check",
                "content": "### Explanation:\\nAssume the following input:\\n```\\nMatrix:\\nthe input matrix\\n1    0    1\\n0  -2    3\\n2    2  -1\\n\\nk = 3\\n```\\n\\nGrid Sum: any index (i,j) below, is the sum of all numbers in the grid between (0,0) -> (i,j), padded with 0s on left and top for ease of computation\\n```\\n0\\t0\\t0\\t0\\t\\n0\\t1\\t1\\t2\\t\\n0\\t1\\t-1\\t3\\t\\n0\\t3\\t3\\t6\\t\\n```\\n\\nNested loop to check grid sum between two points (i,j) and (a,b):\\n- Just like in a 1D array where we need 2 nested loops to compare any combination of index i and index j in the loop where 0 <= i <= j < n\\n- Here, since it\\'s a 2D array, we will need 4 nested loops:\\n  -  The first 2 respresenting the row,col for the start of the grid (i,j)\\n  -  The last 2 representing the row,col for the end of the grid (a,b)\\n- Now, we can use the grid sum/ prefix sum to compute the sum of any rectangle formed between (i,j) and (a,b)\\n- How to calculate grid sum?\\n```\\nLet\\'s break down this statement:\\nint curr_sum = sum[a+1][b+1] - sum[i][b+1] - sum[a+1][j] + sum[i][j];\\n\\nLet\\'s say you want the sum of this grid:\\n- - - - - - - - -\\n- - - - - - - - -\\n- - - - - - - - -\\n- - - ? ? ? ? - -\\n- - - ? ? ? ? - -\\n- - - ? ? ? ? - -\\n- - - - - - - - -\\n\\nStep 1: Forget about the elements to it\\'s right and bottom, hence you can focus on below grid and we know the sum from (0,0) till [?] -> sum[a+1][b+1]\\n- - - - - - - \\n- - - - - - - \\n- - - - - - - \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? [?]\\n\\nStep 2: You need to eliminate the indices marked by \\'-\\' above, eliminate the top area (grid sum at [*]) -> sum[i][b+1]\\n* * * * * * *\\n* * * * * * * \\n* * * * * * [*] \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n\\nStep 3: You need to eliminate the indices marked by \\'-\\' above, eliminate the left area (grid sum at [*]) -> sum[a+1][j] \\n* * * - - - - \\n* * * - - - - \\n* * * - - - - \\n* * * ? ? ? ?\\n* * * ? ? ? ?\\n* * [*] ? ? ? ?\\n\\nStep 4: The area marked by \\'*\\' below was eliminated twice, hence add the grid sum at [*] -> sum[i][j]\\n* * * - - - - \\n* * * - - - - \\n* * [*] - - - - \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n```\\n\\n### Dry Run:\\n```\\nGrid Sum between (i,j) and (a,b):\\n0,0 -> 0,0 : 1\\n0,0 -> 0,1 : 1\\n0,0 -> 0,2 : 2\\n0,0 -> 1,0 : 1\\n0,0 -> 1,1 : -1\\n...\\n0,1 -> 2,2 : 3\\n0,2 -> 0,2 : 1\\n0,2 -> 1,2 : 4\\n0,2 -> 2,2 : 3\\n...\\n1,2 -> 2,2 : 2\\n2,0 -> 2,0 : 2\\n2,0 -> 2,1 : 4\\n2,0 -> 2,2 : 3\\n...\\n```\\n\\n### Why this works:\\n- The max grid size for this question is 100 x 100 (n = 100)\\n- The solution below runs in O(n4) ~ 10^8 operations < 10^9 operations, hence within runtime limits \\n\\n### Solution:\\n```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        // find prefix sum of grid\\n        int[][] sum = new int[matrix.length + 1][matrix[0].length + 1];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + matrix[i][j];\\n            }\\n        }\\n        int ans = Integer.MIN_VALUE;\\n        // brute force check sum of grid between (i,j) and (a,b)\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                for (int a = i; a < matrix.length; a++) {\\n                    for (int b = j; b < matrix[0].length; b++) {\\n                        int curr_sum = sum[a+1][b+1] - sum[i][b+1] - sum[a+1][j] + sum[i][j];\\n                        if (curr_sum <= k && curr_sum > ans) {\\n                            ans = curr_sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nMatrix:\\nthe input matrix\\n1    0    1\\n0  -2    3\\n2    2  -1\\n\\nk = 3\\n```\n```\\n0\\t0\\t0\\t0\\t\\n0\\t1\\t1\\t2\\t\\n0\\t1\\t-1\\t3\\t\\n0\\t3\\t3\\t6\\t\\n```\n```\\nLet\\'s break down this statement:\\nint curr_sum = sum[a+1][b+1] - sum[i][b+1] - sum[a+1][j] + sum[i][j];\\n\\nLet\\'s say you want the sum of this grid:\\n- - - - - - - - -\\n- - - - - - - - -\\n- - - - - - - - -\\n- - - ? ? ? ? - -\\n- - - ? ? ? ? - -\\n- - - ? ? ? ? - -\\n- - - - - - - - -\\n\\nStep 1: Forget about the elements to it\\'s right and bottom, hence you can focus on below grid and we know the sum from (0,0) till [?] -> sum[a+1][b+1]\\n- - - - - - - \\n- - - - - - - \\n- - - - - - - \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? [?]\\n\\nStep 2: You need to eliminate the indices marked by \\'-\\' above, eliminate the top area (grid sum at [*]) -> sum[i][b+1]\\n* * * * * * *\\n* * * * * * * \\n* * * * * * [*] \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n\\nStep 3: You need to eliminate the indices marked by \\'-\\' above, eliminate the left area (grid sum at [*]) -> sum[a+1][j] \\n* * * - - - - \\n* * * - - - - \\n* * * - - - - \\n* * * ? ? ? ?\\n* * * ? ? ? ?\\n* * [*] ? ? ? ?\\n\\nStep 4: The area marked by \\'*\\' below was eliminated twice, hence add the grid sum at [*] -> sum[i][j]\\n* * * - - - - \\n* * * - - - - \\n* * [*] - - - - \\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n- - - ? ? ? ?\\n```\n```\\nGrid Sum between (i,j) and (a,b):\\n0,0 -> 0,0 : 1\\n0,0 -> 0,1 : 1\\n0,0 -> 0,2 : 2\\n0,0 -> 1,0 : 1\\n0,0 -> 1,1 : -1\\n...\\n0,1 -> 2,2 : 3\\n0,2 -> 0,2 : 1\\n0,2 -> 1,2 : 4\\n0,2 -> 2,2 : 3\\n...\\n1,2 -> 2,2 : 2\\n2,0 -> 2,0 : 2\\n2,0 -> 2,1 : 4\\n2,0 -> 2,2 : 3\\n...\\n```\n```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        // find prefix sum of grid\\n        int[][] sum = new int[matrix.length + 1][matrix[0].length + 1];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + matrix[i][j];\\n            }\\n        }\\n        int ans = Integer.MIN_VALUE;\\n        // brute force check sum of grid between (i,j) and (a,b)\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                for (int a = i; a < matrix.length; a++) {\\n                    for (int b = j; b < matrix[0].length; b++) {\\n                        int curr_sum = sum[a+1][b+1] - sum[i][b+1] - sum[a+1][j] + sum[i][j];\\n                        if (curr_sum <= k && curr_sum > ans) {\\n                            ans = curr_sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485706,
                "title": "c-clean-code-similar-to-2d-kadane-approach",
                "content": "**Code** : \\n```\\nclass Solution {\\npublic:\\n    \\n    int sumNoLargerThanK_1D_array(vector<int> &v,int k){\\n        set<int> prefSet;\\n        prefSet.insert(0);\\n        int curSum = 0, curMax = INT_MIN;\\n        for (int sum : v) {\\n            curSum += sum;\\n            auto it = prefSet.lower_bound(curSum - k);\\n            if (it != prefSet.end()) curMax = max(curMax, curSum - *it);\\n            prefSet.insert(curSum);\\n        }\\n        return curMax;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if (matrix.empty()) return 0;\\n        int m = matrix.size(), n = matrix[0].size(), res = -1e8;\\n        for (int l = 0; l < n; ++l) {\\n            vector<int> v(m, 0);\\n            for (int r = l; r < n; ++r) {\\n                for (int i = 0; i < m; ++i) {\\n                    v[i] += matrix[i][r];\\n                }\\n                res=max(res,sumNoLargerThanK_1D_array(v,k));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nTime Complexity : **O[min(m,n)^2 * max(m,n) * log(max(m,n))]**\\nSpace Complexity :  **O(max(m, n))**\\n\\nHope this helps :)",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int sumNoLargerThanK_1D_array(vector<int> &v,int k){\\n        set<int> prefSet;\\n        prefSet.insert(0);\\n        int curSum = 0, curMax = INT_MIN;\\n        for (int sum : v) {\\n            curSum += sum;\\n            auto it = prefSet.lower_bound(curSum - k);\\n            if (it != prefSet.end()) curMax = max(curMax, curSum - *it);\\n            prefSet.insert(curSum);\\n        }\\n        return curMax;\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if (matrix.empty()) return 0;\\n        int m = matrix.size(), n = matrix[0].size(), res = -1e8;\\n        for (int l = 0; l < n; ++l) {\\n            vector<int> v(m, 0);\\n            for (int r = l; r < n; ++r) {\\n                for (int i = 0; i < m; ++i) {\\n                    v[i] += matrix[i][r];\\n                }\\n                res=max(res,sumNoLargerThanK_1D_array(v,k));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485659,
                "title": "100-fastest-98-less-space-easy-to-understand-c",
                "content": "![image](https://assets.leetcode.com/users/images/e77d693f-89b5-4f62-a77f-a601dac0f1cb_1661561205.8769515.png)\\n\\n\\nclass Solution {\\npublic:\\n\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int ans = INT_MIN;\\n        \\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        int arr[R];\\n        \\n        for(int l = 0; l < C; ++l) {\\n            memset(arr, 0, sizeof(arr));\\n            \\n            for(int r = l; r < C; ++r) \\n            {\\n                for(int up = 0; up < R; ++up)\\n                {\\n                    arr[up] += matrix[up][r]; \\n                }\\n                int sum = 0, g = INT_MIN;\\n                for(int up = 0; up < R; ++up) \\n                {\\n                    sum = max(sum + arr[up], arr[up]);\\n                    g = max(g, sum);\\n                    if(g == k) \\n                        return k;\\n                }\\n                if(g < k) \\n                {\\n                    ans = max(ans, g);\\n                } \\n                else \\n                {\\n                    for(int up1 = 0; up1 < R; ++up1) \\n                    {\\n                        sum = 0;\\n                        for(int up2 = up1; up2 < R; ++up2) \\n                        {\\n                            sum += arr[up2];\\n                            if(sum <= k) \\n                                ans = max(ans, sum);\\n                        }\\n                        \\n                        if(ans == k) return k;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int ans = INT_MIN;\\n        \\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        int arr[R];\\n        \\n        for(int l = 0; l < C; ++l) {\\n            memset(arr, 0, sizeof(arr));\\n            \\n            for(int r = l; r < C; ++r) \\n            {\\n                for(int up = 0; up < R; ++up)\\n                {\\n                    arr[up] += matrix[up][r]; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2485637,
                "title": "c-90-faster-small-solution",
                "content": "```\\nint maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n    const int m = matrix.size();\\n    const int n = matrix[0].size();\\n    int ans = INT_MIN;\\n\\n    for (int baseCol = 0; baseCol < n; ++baseCol) {\\n      // sums[i] := sum(matrix[i][baseCol..j])\\n      vector<int> sums(m, 0);\\n      for (int j = baseCol; j < n; ++j) {\\n        for (int i = 0; i < m; ++i)\\n          sums[i] += matrix[i][j];\\n        // find the max subarray no more than k\\n        set<int> accumulate{0};\\n        int prefix = 0;\\n        for (const int sum : sums) {\\n          prefix += sum;\\n          const auto it = accumulate.lower_bound(prefix - k);\\n          if (it != cend(accumulate))\\n            ans = max(ans, prefix - *it);\\n          accumulate.insert(prefix);\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n    const int m = matrix.size();\\n    const int n = matrix[0].size();\\n    int ans = INT_MIN;\\n\\n    for (int baseCol = 0; baseCol < n; ++baseCol) {\\n      // sums[i] := sum(matrix[i][baseCol..j])\\n      vector<int> sums(m, 0);\\n      for (int j = baseCol; j < n; ++j) {\\n        for (int i = 0; i < m; ++i)\\n          sums[i] += matrix[i][j];\\n        // find the max subarray no more than k\\n        set<int> accumulate{0};\\n        int prefix = 0;\\n        for (const int sum : sums) {\\n          prefix += sum;\\n          const auto it = accumulate.lower_bound(prefix - k);\\n          if (it != cend(accumulate))\\n            ans = max(ans, prefix - *it);\\n          accumulate.insert(prefix);\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485605,
                "title": "daily-leetcoding-challenge-august-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Prefix Sum on 1D Array using Sorted Container\n\n  \n**Approach 2:** Follow-up - Larger Number of Rows than Columns\n\n  \n**Approach 3:** Combining it with Kadane's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2459775,
                "title": "c-solution-time-o-n-3-logn-memory-o-m-n-easy-to-understand-subarray-sum-less-than-k",
                "content": "```\\nclass Solution {\\npublic:\\n    //2D into 1D compression than binary search\\n    int SubarrSumlessthanK(vector<int>&arr,int k){\\n        int n=arr.size();\\n        int ans=-1e9;\\n        set<int>st;\\n        st.insert(0);\\n        int csum=0;\\n        for(auto x:arr){\\n            csum+=x;\\n            auto it=st.lower_bound(csum-k);\\n            if(it!=st.end()){\\n                ans=max(ans,csum-*it);\\n            }\\n            st.insert(csum);\\n        }\\n        return ans;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        //Binary search ;\\n        //Hmare Saath Shri Ragunath To Kis Baat Ki Chinta -> \"Jai Shri Ram\"\\n        int ans=-int(1e9);\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        for(int c1=0;c1<n;c1++){\\n            vector<int>arr(m,0);\\n            for(int c2=c1;c2<n;c2++){\\n                for(int r=0;r<m;r++){\\n                    arr[r]+=mat[r][c2];\\n                }\\n                ans=max(ans,SubarrSumlessthanK(arr,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //2D into 1D compression than binary search\\n    int SubarrSumlessthanK(vector<int>&arr,int k){\\n        int n=arr.size();\\n        int ans=-1e9;\\n        set<int>st;\\n        st.insert(0);\\n        int csum=0;\\n        for(auto x:arr){\\n            csum+=x;\\n            auto it=st.lower_bound(csum-k);\\n            if(it!=st.end()){\\n                ans=max(ans,csum-*it);\\n            }\\n            st.insert(csum);\\n        }\\n        return ans;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        //Binary search ;\\n        //Hmare Saath Shri Ragunath To Kis Baat Ki Chinta -> \"Jai Shri Ram\"\\n        int ans=-int(1e9);\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        for(int c1=0;c1<n;c1++){\\n            vector<int>arr(m,0);\\n            for(int c2=c1;c2<n;c2++){\\n                for(int r=0;r<m;r++){\\n                    arr[r]+=mat[r][c2];\\n                }\\n                ans=max(ans,SubarrSumlessthanK(arr,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368438,
                "title": "faster-than-98-18-pyrhon-numpy",
                "content": "![image](https://assets.leetcode.com/users/images/6f27779a-667c-443f-9c77-01e2aabafe8f_1659428934.3194134.png)\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        import numpy as np\\n        \\n        matrix = np.array(matrix, dtype=np.int32)\\n        \\n        M,N = matrix.shape\\n        \\n        ret = float(\"-inf\")\\n        \\n        CUM = np.zeros((M,N), dtype=np.int32)\\n        for shift_r in range(M):\\n            CUM[:M-shift_r] += matrix[shift_r:]\\n            \\n            _CUM = np.zeros((M-shift_r,N), dtype=np.int32)\\n            for shift_c in range(N):\\n                _CUM[:, :N-shift_c] += CUM[:M-shift_r,shift_c:]\\n                tmp = _CUM[(_CUM<=k) & (_CUM>ret)]\\n                if tmp.size:\\n                    ret = tmp.max()\\n            if ret == k:\\n                return ret\\n        \\n        return ret\\n\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/6f27779a-667c-443f-9c77-01e2aabafe8f_1659428934.3194134.png)\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        import numpy as np\\n        \\n        matrix = np.array(matrix, dtype=np.int32)\\n        \\n        M,N = matrix.shape\\n        \\n        ret = float(\"-inf\")\\n        \\n        CUM = np.zeros((M,N), dtype=np.int32)\\n        for shift_r in range(M):\\n            CUM[:M-shift_r] += matrix[shift_r:]\\n            \\n            _CUM = np.zeros((M-shift_r,N), dtype=np.int32)\\n            for shift_c in range(N):\\n                _CUM[:, :N-shift_c] += CUM[:M-shift_r,shift_c:]\\n                tmp = _CUM[(_CUM<=k) & (_CUM>ret)]\\n                if tmp.size:\\n                    ret = tmp.max()\\n            if ret == k:\\n                return ret\\n        \\n        return ret\\n\\n\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 1959343,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n    class Solution {\\n\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }\\n        return res;\\n    }\\n    private int maxSumSubarray(int[] A, int k) {\\n        int res = maxSumSubarray(A);\\n        if(res <= k) return res;\\n        res = Integer.MIN_VALUE;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        set.add(0);\\n        for(int sum: A) {\\n            Integer old = set.ceiling(sum - k);\\n            if(old != null) {\\n                if(sum - old > res) {\\n                    res = sum - old;\\n                    if(res == k) return res;\\n                }\\n            }\\n            set.add(sum);\\n        }\\n        return res;\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = m == 0 ? 0 : matrix[0].length, res = Integer.MIN_VALUE;\\n        boolean groupingRows = true;\\n        if(m > n) {\\n            int temp = m; m = n; n = temp;\\n            groupingRows = false;\\n        }\\n        int[] sum = new int[n];\\n        for(int i = 0; i < m; i++) {\\n            Arrays.fill(sum, 0);\\n            for(int j = i; j < m; j++) {\\n                int pre = 0;\\n                if(groupingRows) {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[j][t];\\n                } else {\\n                    for(int t = 0; t < n; t++) sum[t] += pre += matrix[t][j];\\n                }\\n                res = Math.max(res, maxSumSubarray(sum, k));\\n                if(res == k) return res;\\n            }\\n        }\\n        return res;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    private int maxSumSubarray(int[] A) {\\n        int min = 0, res = Integer.MIN_VALUE;\\n        for(int sum: A) {\\n            res = Math.max(res, sum - min);\\n            min = Math.min(min, sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1778025,
                "title": "java-binarysearch",
                "content": "**Intuition**\\n\\n    1. Explore all possible rectangle\\n    2. Consider matrix with only one col. We get row*row no of rectangles. We have\\n\\t\\tto choose max sum(rectangle) where sum(rectangle) <= k\\n    3. We can make use of prefix array where prefix[i] is sum of val in row i.\\n    4. Make use of TreeSet && prefix sum to find all rectangles with sum less \\n\\t\\tthan k.\\n    5. Extend the above method to two dimensions\\n\\n```\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        int ans = Integer.MIN_VALUE;\\n        \\n        // l - left end of rectangle\\n        // r - right end of rectangle\\n        // loop for width expansion\\n        for(int l = 0; l < cols; l++){\\n            int[] prefix = new int[rows];\\n            for(int r = l; r < cols; r++){\\n                // step 3\\n                for(int row = 0; row < rows; row++){\\n                    prefix[row] += matrix[row][r];\\n                }\\n                //System.out.println(l+\" \"+r+\" \"+Arrays.toString(prefix));\\n                // step 4\\n                //cummulative[j] - cummulative[i] <=k  -> cummulative[j] - k <= cummulative[i];\\n                //we use ceil function to find cummulative sum which is store in our treeset\\n                int cj = 0;\\n                TreeSet<Integer> cummulative = new TreeSet<>();\\n                cummulative.add(0);\\n                for(int i = 0; i < rows; i++){\\n                    cj += prefix[i];\\n                    Integer ci = cummulative.ceiling(cj - k);\\n                    // ci found, sum between i & j is cj - ci;    \\n                    if(ci!=null){\\n                        ans = Math.max(ans, cj-ci);\\n                    }\\n                    cummulative.add(cj);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        int ans = Integer.MIN_VALUE;\\n        \\n        // l - left end of rectangle\\n        // r - right end of rectangle\\n        // loop for width expansion\\n        for(int l = 0; l < cols; l++){\\n            int[] prefix = new int[rows];\\n            for(int r = l; r < cols; r++){\\n                // step 3\\n                for(int row = 0; row < rows; row++){\\n                    prefix[row] += matrix[row][r];\\n                }\\n                //System.out.println(l+\" \"+r+\" \"+Arrays.toString(prefix));\\n                // step 4\\n                //cummulative[j] - cummulative[i] <=k  -> cummulative[j] - k <= cummulative[i];\\n                //we use ceil function to find cummulative sum which is store in our treeset\\n                int cj = 0;\\n                TreeSet<Integer> cummulative = new TreeSet<>();\\n                cummulative.add(0);\\n                for(int i = 0; i < rows; i++){\\n                    cj += prefix[i];\\n                    Integer ci = cummulative.ceiling(cj - k);\\n                    // ci found, sum between i & j is cj - ci;    \\n                    if(ci!=null){\\n                        ans = Math.max(ans, cj-ci);\\n                    }\\n                    cummulative.add(cj);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621975,
                "title": "python-sortedset-similar-to-java-official-solution",
                "content": "The answer in another discussion page made by otoc is still faster, however here\\'s an answer that matches the Java solution format wise.\\n\\n```\\nimport sortedcontainers\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        def updateResult(nums, k):\\n            nonlocal result\\n            \\n            summ = 0\\n            sortedSum = sortedcontainers.SortedSet()\\n            sortedSum.add(0)\\n            \\n            for num in nums:\\n                summ += num\\n                x = sortedSum.bisect_left(summ - k)\\n                if x < len(sortedSum):\\n                    result = max(result, summ - sortedSum[x])\\n                    \\n                sortedSum.add(summ)\\n                    \\n        result = -math.inf\\n                    \\n        for i in range(len(matrix)):\\n            rowSum = [0] * len(matrix[0])\\n            \\n            for row in range(i, len(matrix)):\\n                for col in range(len(matrix[row])):\\n                    rowSum[col] += matrix[row][col]\\n                    \\n                updateResult(rowSum, k)\\n                \\n                if result == k:\\n                    return result\\n                \\n        return result if result != -math.inf else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport sortedcontainers\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        def updateResult(nums, k):\\n            nonlocal result\\n            \\n            summ = 0\\n            sortedSum = sortedcontainers.SortedSet()\\n            sortedSum.add(0)\\n            \\n            for num in nums:\\n                summ += num\\n                x = sortedSum.bisect_left(summ - k)\\n                if x < len(sortedSum):\\n                    result = max(result, summ - sortedSum[x])\\n                    \\n                sortedSum.add(summ)\\n                    \\n        result = -math.inf\\n                    \\n        for i in range(len(matrix)):\\n            rowSum = [0] * len(matrix[0])\\n            \\n            for row in range(i, len(matrix)):\\n                for col in range(len(matrix[row])):\\n                    rowSum[col] += matrix[row][col]\\n                    \\n                updateResult(rowSum, k)\\n                \\n                if result == k:\\n                    return result\\n                \\n        return result if result != -math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430051,
                "title": "c-implementation",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int solve(vector<int>&v,int k){\\n        int maxi = INT_MIN;\\n       for(int i=0;i<v.size();i++){\\n           int sum = 0;\\n           for(int j = i;j<v.size();j++){\\n               sum+=v[j];\\n               if(sum<=k && sum>maxi) maxi = sum;\\n           }\\n       }\\n        return maxi;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int _k) {\\n      \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int ans = INT_MIN;\\n        for(int i=0;i<row;i++){\\n            vector<int>v(col);\\n            for(int j=i;j<row;j++){\\n                for(int k=0;k<col;k++){\\n                    v[k] = v[k] + matrix[j][k];\\n                }\\n                 ans = max(ans,solve(v,_k));   \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int solve(vector<int>&v,int k){\\n        int maxi = INT_MIN;\\n       for(int i=0;i<v.size();i++){\\n           int sum = 0;\\n           for(int j = i;j<v.size();j++){\\n               sum+=v[j];\\n               if(sum<=k && sum>maxi) maxi = sum;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1313898,
                "title": "c-using-concept-of-2-d-kadane-s-algorithm",
                "content": "You should first understand 2-D kadane\\'s and then come here.\\nAfter that, this question will be child\\'s play.\\n2-D Kadane\\'s  Link :  \\n\\thttps://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/DP/Maximum%20Sum%20Rectangular%20Submatrix%20in%20Matrix%20dynamic%20programming(2-D%20kadane).cpp\\n```\\n/*\\n\\tThis problem is solved using the concept of 2-D Kadane\\'s Algorithm\\n\\ti.e. maximum rectangle sum in a 2-D matrix\\n*/\\nclass Solution {\\npublic:\\n    void findMaxLessThanK(vector<int>& nums, int k, int &result) {\\n        int cuSum  = 0;\\n        int maxSum  = INT_MIN;\\n        set<int> st;\\n        st.insert(0);\\n\\n        for(int i = 0; i<nums.size(); i++) {\\n            cuSum += nums[i];\\n            auto it = st.lower_bound(cuSum-k);\\n\\n            if(it != end(st)) {\\n                maxSum = max(maxSum, cuSum-*it);\\n            }\\n            st.insert(cuSum);\\n        }\\n\\n        result = max(result, maxSum);\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int rows   = matrix.size();\\n        int cols   = matrix[0].size();\\n        int result = INT_MIN;\\n\\n        for(int L = 0; L<cols; L++) {\\n            vector<int> temp(rows, 0);\\n            for(int R = L; R<cols; R++) {\\n\\n                for(int row = 0; row < rows; row++)\\n                    temp[row] += matrix[row][R];\\n\\n                findMaxLessThanK(temp, k, result);            \\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tThis problem is solved using the concept of 2-D Kadane\\'s Algorithm\\n\\ti.e. maximum rectangle sum in a 2-D matrix\\n*/\\nclass Solution {\\npublic:\\n    void findMaxLessThanK(vector<int>& nums, int k, int &result) {\\n        int cuSum  = 0;\\n        int maxSum  = INT_MIN;\\n        set<int> st;\\n        st.insert(0);\\n\\n        for(int i = 0; i<nums.size(); i++) {\\n            cuSum += nums[i];\\n            auto it = st.lower_bound(cuSum-k);\\n\\n            if(it != end(st)) {\\n                maxSum = max(maxSum, cuSum-*it);\\n            }\\n            st.insert(cuSum);\\n        }\\n\\n        result = max(result, maxSum);\\n    }\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int rows   = matrix.size();\\n        int cols   = matrix[0].size();\\n        int result = INT_MIN;\\n\\n        for(int L = 0; L<cols; L++) {\\n            vector<int> temp(rows, 0);\\n            for(int R = L; R<cols; R++) {\\n\\n                for(int row = 0; row < rows; row++)\\n                    temp[row] += matrix[row][R];\\n\\n                findMaxLessThanK(temp, k, result);            \\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313293,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i<matrix[0].length;i++){\\n            int[] sum = new int[matrix.length];\\n            for(int m = i; m<matrix[0].length;m++){\\n                for(int j = 0; j<matrix.length;j++){\\n                    sum[j]+=matrix[j][m];\\n                    if(sum[j]==k)return  k;  \\n                    if(sum[j]<k)maxSum=Math.max(maxSum,sum[j]);\\n                }\\n                for(int j = 0; j<matrix.length;j++){\\n                    int summe=0;    \\n                    for(int n = j; n<matrix.length;n++){\\n                        summe+=sum[n];\\n                        if(summe==k)return k;\\n                        if(summe<k)maxSum=Math.max(maxSum,summe);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxSum;\\n \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i<matrix[0].length;i++){\\n            int[] sum = new int[matrix.length];\\n            for(int m = i; m<matrix[0].length;m++){\\n                for(int j = 0; j<matrix.length;j++){\\n                    sum[j]+=matrix[j][m];\\n                    if(sum[j]==k)return  k;  \\n                    if(sum[j]<k)maxSum=Math.max(maxSum,sum[j]);\\n                }\\n                for(int j = 0; j<matrix.length;j++){\\n                    int summe=0;    \\n                    for(int n = j; n<matrix.length;n++){\\n                        summe+=sum[n];\\n                        if(summe==k)return k;\\n                        if(summe<k)maxSum=Math.max(maxSum,summe);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxSum;\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277586,
                "title": "python3-insort-sortedlist",
                "content": "\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = -inf \\n        rsum = [[0]*(n+1) for _ in range(m)] # row prefix sum \\n        for j in range(n): \\n            for i in range(m): rsum[i][j+1] = matrix[i][j] + rsum[i][j]\\n            for jj in range(j+1):\\n                prefix = 0 \\n                vals = [0]\\n                for i in range(m): \\n                    prefix += rsum[i][j+1] - rsum[i][jj]\\n                    x = bisect_left(vals, prefix - k)\\n                    if x < len(vals): ans = max(ans, prefix - vals[x])\\n                    insort(vals, prefix)\\n        return ans\\n```\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = -inf \\n        rsum = [[0]*(n+1) for _ in range(m)] # row prefix sum \\n        for j in range(n): \\n            for i in range(m): rsum[i][j+1] = matrix[i][j] + rsum[i][j]\\n            for jj in range(j+1):\\n                prefix = 0 \\n                vals = SortedList()\\n                for i in range(m): \\n                    vals.add(prefix)\\n                    prefix += rsum[i][j+1] - rsum[i][jj]\\n                    x = vals.bisect_left(prefix - k)\\n                    if x < len(vals): ans = max(ans, prefix - vals[x])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = -inf \\n        rsum = [[0]*(n+1) for _ in range(m)] # row prefix sum \\n        for j in range(n): \\n            for i in range(m): rsum[i][j+1] = matrix[i][j] + rsum[i][j]\\n            for jj in range(j+1):\\n                prefix = 0 \\n                vals = [0]\\n                for i in range(m): \\n                    prefix += rsum[i][j+1] - rsum[i][jj]\\n                    x = bisect_left(vals, prefix - k)\\n                    if x < len(vals): ans = max(ans, prefix - vals[x])\\n                    insort(vals, prefix)\\n        return ans\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = -inf \\n        rsum = [[0]*(n+1) for _ in range(m)] # row prefix sum \\n        for j in range(n): \\n            for i in range(m): rsum[i][j+1] = matrix[i][j] + rsum[i][j]\\n            for jj in range(j+1):\\n                prefix = 0 \\n                vals = SortedList()\\n                for i in range(m): \\n                    vals.add(prefix)\\n                    prefix += rsum[i][j+1] - rsum[i][jj]\\n                    x = vals.bisect_left(prefix - k)\\n                    if x < len(vals): ans = max(ans, prefix - vals[x])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856618,
                "title": "python-solution-prefix-sum-2d-array",
                "content": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, w: List[List[int]], K: int) -> int:\\n        \\n        def get(x1: int, y1: int, x2: int, y2: int) -> int:\\n            return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]\\n        \\n        n, m = len(w), len(w[0])\\n        \"\"\"\\n        >>> a = [[1,2,3],[4,2,6]]\\n        >>> len(a) \\u884C\\u6570\\n        2\\n        >>> len(a[0]) \\u5217\\u6570\\n        3\\n        \"\"\"\\n        # \\u9884\\u5904\\u7406\\u5F97\\u5230\\u77E9\\u9635\\u524D\\u7F00\\u548C\\n        s = [[0 for i in range(m + 1)] for y in range(n + 1)]\\n        for i in range (1, n + 1):\\n            for j in range (1, m + 1):\\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + w[i - 1][j - 1]\\n        \\n        res = -sys.maxsize\\n        for i in range(1, m + 1):\\n            for j in range(i, m + 1):\\n                L = [0]\\n                for k in range(1, n + 1):\\n                    si = get(1, i, k, j)\\n                    it = bisect.bisect_left(L, si - K)\\n                    if it != len(L):\\n                        res = max(res, si - L[it])\\n                    bisect.insort(L, si)\\n        return res\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, w: List[List[int]], K: int) -> int:\\n        \\n        def get(x1: int, y1: int, x2: int, y2: int) -> int:\\n            return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]\\n        \\n        n, m = len(w), len(w[0])\\n        \"\"\"\\n        >>> a = [[1,2,3],[4,2,6]]\\n        >>> len(a) \\u884C\\u6570\\n        2\\n        >>> len(a[0]) \\u5217\\u6570\\n        3\\n        \"\"\"\\n        # \\u9884\\u5904\\u7406\\u5F97\\u5230\\u77E9\\u9635\\u524D\\u7F00\\u548C\\n        s = [[0 for i in range(m + 1)] for y in range(n + 1)]\\n        for i in range (1, n + 1):\\n            for j in range (1, m + 1):\\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + w[i - 1][j - 1]\\n        \\n        res = -sys.maxsize\\n        for i in range(1, m + 1):\\n            for j in range(i, m + 1):\\n                L = [0]\\n                for k in range(1, n + 1):\\n                    si = get(1, i, k, j)\\n                    it = bisect.bisect_left(L, si - K)\\n                    if it != len(L):\\n                        res = max(res, si - L[it])\\n                    bisect.insort(L, si)\\n        return res\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 782703,
                "title": "same-technique-to-solve-lc363-and-lc1074",
                "content": "Inspired by many other people and the discussions under both problems. The key idea follows the three steps below:\\n1. calculate presum for each row, which later help easily get the sum of sub array between col=i and col=j, for any row;\\n2. between any column pair [i, j] (both side inclusive), the problem of LC363 becomes `max sum of sub array no larger than K`, in a one-dimentional array, and the problem of LC1074 becomes `number of sub arrays that sum to target`. The reason is we can reduce the horizontal dimention to a single sum number, using the pre sum calculated from step 1;\\n3. at this point, the problem can very much borrow the idea from LC560. We can iterate vertically from the first row to the last row. Each step we can calculate the current sum so far until the current row. We also need to store the current sum in an O(1)-get data structure, to efficiently access later.\\n\\nFor LC 363, we can use a tree set to store all the current sum already seen, and each step fetch from the set using set.ceiling(curSum-k). I think the snippet pasted below is self-explained.\\n\\n```java\\nclass Solution {\\n  public int maxSumSubmatrix(int[][] matrix, int k) {\\n    if(matrix==null || matrix.length==0 || matrix[0].length==0) {\\n      return 0;\\n    }\\n    int m=matrix.length, n=matrix[0].length;\\n    int[][] sum=new int[m][n+1];\\n    for(int i=0; i<m; i++) {\\n      for(int j=1; j<=n; j++) {\\n        sum[i][j]=sum[i][j-1]+matrix[i][j-1];\\n      }\\n    }\\n    \\n    int res=Integer.MIN_VALUE;\\n    // for each column pair [i, j], where i and j are inclusive.\\n    for(int i=0; i<n; i++) {\\n      for(int j=i; j<n; j++) {\\n        int curSum=0;\\n        TreeSet<Integer> set=new TreeSet<>();\\n        set.add(0);\\n        for(int p=0; p<m; p++) {\\n          curSum=curSum+sum[p][j+1]-sum[p][i];\\n          Integer val=set.ceiling(curSum-k);\\n          if(val!=null) {\\n            res=Math.max(res, curSum-val);\\n          }\\n          set.add(curSum);\\n        }\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  public int maxSumSubmatrix(int[][] matrix, int k) {\\n    if(matrix==null || matrix.length==0 || matrix[0].length==0) {\\n      return 0;\\n    }\\n    int m=matrix.length, n=matrix[0].length;\\n    int[][] sum=new int[m][n+1];\\n    for(int i=0; i<m; i++) {\\n      for(int j=1; j<=n; j++) {\\n        sum[i][j]=sum[i][j-1]+matrix[i][j-1];\\n      }\\n    }\\n    \\n    int res=Integer.MIN_VALUE;\\n    // for each column pair [i, j], where i and j are inclusive.\\n    for(int i=0; i<n; i++) {\\n      for(int j=i; j<n; j++) {\\n        int curSum=0;\\n        TreeSet<Integer> set=new TreeSet<>();\\n        set.add(0);\\n        for(int p=0; p<m; p++) {\\n          curSum=curSum+sum[p][j+1]-sum[p][i];\\n          Integer val=set.ceiling(curSum-k);\\n          if(val!=null) {\\n            res=Math.max(res, curSum-val);\\n          }\\n          set.add(curSum);\\n        }\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779649,
                "title": "binary-search-with-bisect-or-your-own-implementation-python",
                "content": "```\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, k):\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def bsearch(nums, val):\\n            left = 0\\n            right = len(nums)\\n            while left < right:\\n                mid = left + (right - left)//2\\n                if nums[mid] >= val:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left\\n        \\n        res = -2**31\\n        \\n        for i in range(n):\\n            sums = [0] * m\\n            for j in range(i, n):\\n                for r in range(m):\\n                    sums[r] += matrix[r][j]\\n                \\n                # suppose we have an array, we need to find its sub array, \\n                # such that sum(subarray) <=k and sum(subarray) is maximum\\n                \\n                presum = 0\\n                cumsum = [0]\\n                for num in sums:\\n                    presum += num\\n                    \\n                    #left = bsearch(cumsum, presum - k) # cumsum[left] >= presum - k, i.e., k>= presum - cumsum[left]\\n                    left = bisect.bisect_left(cumsum, presum - k)\\n                    if left < len(cumsum):\\n                        res = max(res, presum - cumsum[left])\\n                        \\n                    #left2 = bsearch(cumsum, presum)\\n                    #cumsum.insert(left2, presum)\\n                    bisect.insort(cumsum, presum)\\n        return res\\n    \\n    def maxSumSubmatrix(self, matrix, k):\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def bsearch(nums, val):\\n            left = 0\\n            right = len(nums)\\n            while left < right:\\n                mid = left + (right - left)//2\\n                if nums[mid] >= val:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left\\n        \\n        res = -2**31\\n        \\n        for i in range(n):\\n            sums = [0] * m\\n            for j in range(i, n):\\n                for r in range(m):\\n                    sums[r] += matrix[r][j]\\n                \\n                # suppose we have an array, we need to find its sub array, \\n                # such that sum(subarray) <=k and sum(subarray) is maximum\\n                \\n                presum = 0\\n                cumsum = [0]\\n                for num in sums:\\n                    presum += num\\n                    \\n                    left = bsearch(cumsum, presum - k) # cumsum[left] >= presum - k, i.e., k>= presum - cumsum[left]\\n                    #left = bisect.bisect_left(cumsum, presum - k)\\n                    if left < len(cumsum):\\n                        res = max(res, presum - cumsum[left])\\n                        \\n                    left2 = bsearch(cumsum, presum)\\n                    cumsum.insert(left2, presum)\\n                    #bisect.insort(cumsum, presum)\\n        return res\\n```\\n\\nSpecially: \\n```\\n\\t\\tfor i in range(columns): # i \\u626B\\u8FC7\\u6BCF\\u4E00\\u5217\\n            sums = [0 for _ in range(rows)] # sums \\u7684\\u957F\\u5EA6\\uFF0C\\u548C\\u884C\\u6570\\u76F8\\u540C\\n            for j in range(i, columns): # j\\u4E5F\\u662F\\u626B\\u8FC7i\\u540E\\u9762\\u7684\\u5217\\n                for r in range(rows): # r\\u662F\\u6240\\u6709\\u884C\\uFF0C\\n                    sums[r] += matrix[r][j]\\n                print(sums)\\n                #\\u5206\\u522B\\u662F \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n                \\n                #       \\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n                \\n                #       \\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n```\\n\\nAnd details regarding finding a subarray, whose sum <= k and the sum is the largest among all subarraies that satisfy sum (x) <=k.\\n\\n```\\ndef bsearch(nums, val):\\n    left = 0\\n    right = len(nums)\\n    while left < right:\\n        mid = left + (right - left)//2\\n        if nums[mid] >= val:\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n\\ndef prefix(nums, k):\\n    import bisect\\n    res = float(\\'-inf\\')\\n    cum_sum = [0]\\n    prefixSum, max_sum = 0, float(\\'-inf\\')\\n    for num in nums:\\n        prefixSum += num # \\u5F53\\u524D\\u4E3A\\u6B62\\u7684\\u524D\\u7F00\\u548C\\n\\n        #cum_sum[left] >= prefixSum - k\\n        #\\u4ECE\\u800C\\u6211\\u4EEC\\u6709 k >= prefixSum - cum_sum[left]\\n        # \\u5F53\\u524D\\u6709\\u4E86\\u4E00\\u4E2AprefixSum\\u7684\\u7ED3\\u679C\\uFF0C\\u90A3\\u6211\\u4EEC\\u7684\\u76EE\\u6807\\u662F\\uFF1A\\u5411\\u5DE6\\uFF0C\\u5BFB\\u627E\\u4E00\\u4E2A\\u5DF2\\u6709\\u7684prefixSum (old) \\uFF0C\\u4F7F\\u5F97prefixSum - prefixSum(old) <= k \\u800C\\u4E14\\u8FD9\\u6837\\u7684\\u503C\\u53EF\\u4EE5\\u6700\\u5927\\u5316\\uFF01\\n\\n        #left = bisect.bisect_left(cum_sum, prefixSum - k) # why prefixSum - k? \\u4E3A\\u4EC0\\u4E48\\u4F7F\\u7528prefixSum-k\\u6765\\u786E\\u5B9Aleft?\\n        left = bsearch(cum_sum, prefixSum - k)\\n        # left\\u662FprefixSum - k\\u88AB\\u63D2\\u5165\\u7684\\u4F4D\\u7F6E\\uFF0C\\u5982\\u679CprefixSum - k\\u6BD4\\u5176\\u4E2D\\u7684\\u6240\\u6709\\u503C\\u90FD\\u5927\\uFF0C\\u5219left=len(cum_sum)\\n\\n        print(\\'cum_sum=\\', cum_sum, \\'prefixSum - k=\\', prefixSum - k, \\', prefixSum=\\', prefixSum, \\', left=\\', left)\\n\\n        if left < len(cum_sum):\\n            max_sum = max(max_sum, prefixSum - cum_sum[left])\\n\\n        #bisect.insort(cum_sum, prefixSum) # insert to sorted array, such as 3 in [2,4,5] -> [2,3,4,5]\\n        left2 = bsearch(cum_sum, prefixSum)\\n        cum_sum.insert(left2, prefixSum)\\n\\n    res = max(res, max_sum)\\n    return res\\n\\nnums = [1, -3, 4, 7, -5, 6]\\nprint(prefix(nums, 5))\\n\\n# \\u76EE\\u7684\\u5C31\\u662F\\u5728nums\\u4E2D\\u5BFB\\u627E\\u4E00\\u4E2A\\u5B50\\u6570\\u7EC4\\uFF0C\\u5E76\\u4E14\\u6EE1\\u8DB3\\uFF1A\\u8BE5\\u5B50\\u6570\\u7EC4\\u7684\\u548C<=k=5\\uFF0C\\u5E76\\u4E14\\u6700\\u63A5\\u8FD1k \\uFF08\\u662F\\u6240\\u6709<=k\\u4E2D\\uFF0C\"\\u548C\"/sum \\u6700\\u5927\\u7684\\uFF09\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumSubmatrix(self, matrix, k):\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def bsearch(nums, val):\\n            left = 0\\n            right = len(nums)\\n            while left < right:\\n                mid = left + (right - left)//2\\n                if nums[mid] >= val:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left\\n        \\n        res = -2**31\\n        \\n        for i in range(n):\\n            sums = [0] * m\\n            for j in range(i, n):\\n                for r in range(m):\\n                    sums[r] += matrix[r][j]\\n                \\n                # suppose we have an array, we need to find its sub array, \\n                # such that sum(subarray) <=k and sum(subarray) is maximum\\n                \\n                presum = 0\\n                cumsum = [0]\\n                for num in sums:\\n                    presum += num\\n                    \\n                    #left = bsearch(cumsum, presum - k) # cumsum[left] >= presum - k, i.e., k>= presum - cumsum[left]\\n                    left = bisect.bisect_left(cumsum, presum - k)\\n                    if left < len(cumsum):\\n                        res = max(res, presum - cumsum[left])\\n                        \\n                    #left2 = bsearch(cumsum, presum)\\n                    #cumsum.insert(left2, presum)\\n                    bisect.insort(cumsum, presum)\\n        return res\\n    \\n    def maxSumSubmatrix(self, matrix, k):\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def bsearch(nums, val):\\n            left = 0\\n            right = len(nums)\\n            while left < right:\\n                mid = left + (right - left)//2\\n                if nums[mid] >= val:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left\\n        \\n        res = -2**31\\n        \\n        for i in range(n):\\n            sums = [0] * m\\n            for j in range(i, n):\\n                for r in range(m):\\n                    sums[r] += matrix[r][j]\\n                \\n                # suppose we have an array, we need to find its sub array, \\n                # such that sum(subarray) <=k and sum(subarray) is maximum\\n                \\n                presum = 0\\n                cumsum = [0]\\n                for num in sums:\\n                    presum += num\\n                    \\n                    left = bsearch(cumsum, presum - k) # cumsum[left] >= presum - k, i.e., k>= presum - cumsum[left]\\n                    #left = bisect.bisect_left(cumsum, presum - k)\\n                    if left < len(cumsum):\\n                        res = max(res, presum - cumsum[left])\\n                        \\n                    left2 = bsearch(cumsum, presum)\\n                    cumsum.insert(left2, presum)\\n                    #bisect.insort(cumsum, presum)\\n        return res\\n```\n```\\n\\t\\tfor i in range(columns): # i \\u626B\\u8FC7\\u6BCF\\u4E00\\u5217\\n            sums = [0 for _ in range(rows)] # sums \\u7684\\u957F\\u5EA6\\uFF0C\\u548C\\u884C\\u6570\\u76F8\\u540C\\n            for j in range(i, columns): # j\\u4E5F\\u662F\\u626B\\u8FC7i\\u540E\\u9762\\u7684\\u5217\\n                for r in range(rows): # r\\u662F\\u6240\\u6709\\u884C\\uFF0C\\n                    sums[r] += matrix[r][j]\\n                print(sums)\\n                #\\u5206\\u522B\\u662F \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C0\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n                \\n                #       \\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C\\n                #       \\u7B2C1\\u5217\\u7684\\u6240\\u6709\\u884C+\\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n                \\n                #       \\u7B2C2\\u5217\\u7684\\u6240\\u6709\\u884C\\n```\n```\\ndef bsearch(nums, val):\\n    left = 0\\n    right = len(nums)\\n    while left < right:\\n        mid = left + (right - left)//2\\n        if nums[mid] >= val:\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n\\ndef prefix(nums, k):\\n    import bisect\\n    res = float(\\'-inf\\')\\n    cum_sum = [0]\\n    prefixSum, max_sum = 0, float(\\'-inf\\')\\n    for num in nums:\\n        prefixSum += num # \\u5F53\\u524D\\u4E3A\\u6B62\\u7684\\u524D\\u7F00\\u548C\\n\\n        #cum_sum[left] >= prefixSum - k\\n        #\\u4ECE\\u800C\\u6211\\u4EEC\\u6709 k >= prefixSum - cum_sum[left]\\n        # \\u5F53\\u524D\\u6709\\u4E86\\u4E00\\u4E2AprefixSum\\u7684\\u7ED3\\u679C\\uFF0C\\u90A3\\u6211\\u4EEC\\u7684\\u76EE\\u6807\\u662F\\uFF1A\\u5411\\u5DE6\\uFF0C\\u5BFB\\u627E\\u4E00\\u4E2A\\u5DF2\\u6709\\u7684prefixSum (old) \\uFF0C\\u4F7F\\u5F97prefixSum - prefixSum(old) <= k \\u800C\\u4E14\\u8FD9\\u6837\\u7684\\u503C\\u53EF\\u4EE5\\u6700\\u5927\\u5316\\uFF01\\n\\n        #left = bisect.bisect_left(cum_sum, prefixSum - k) # why prefixSum - k? \\u4E3A\\u4EC0\\u4E48\\u4F7F\\u7528prefixSum-k\\u6765\\u786E\\u5B9Aleft?\\n        left = bsearch(cum_sum, prefixSum - k)\\n        # left\\u662FprefixSum - k\\u88AB\\u63D2\\u5165\\u7684\\u4F4D\\u7F6E\\uFF0C\\u5982\\u679CprefixSum - k\\u6BD4\\u5176\\u4E2D\\u7684\\u6240\\u6709\\u503C\\u90FD\\u5927\\uFF0C\\u5219left=len(cum_sum)\\n\\n        print(\\'cum_sum=\\', cum_sum, \\'prefixSum - k=\\', prefixSum - k, \\', prefixSum=\\', prefixSum, \\', left=\\', left)\\n\\n        if left < len(cum_sum):\\n            max_sum = max(max_sum, prefixSum - cum_sum[left])\\n\\n        #bisect.insort(cum_sum, prefixSum) # insert to sorted array, such as 3 in [2,4,5] -> [2,3,4,5]\\n        left2 = bsearch(cum_sum, prefixSum)\\n        cum_sum.insert(left2, prefixSum)\\n\\n    res = max(res, max_sum)\\n    return res\\n\\nnums = [1, -3, 4, 7, -5, 6]\\nprint(prefix(nums, 5))\\n\\n# \\u76EE\\u7684\\u5C31\\u662F\\u5728nums\\u4E2D\\u5BFB\\u627E\\u4E00\\u4E2A\\u5B50\\u6570\\u7EC4\\uFF0C\\u5E76\\u4E14\\u6EE1\\u8DB3\\uFF1A\\u8BE5\\u5B50\\u6570\\u7EC4\\u7684\\u548C<=k=5\\uFF0C\\u5E76\\u4E14\\u6700\\u63A5\\u8FD1k \\uFF08\\u662F\\u6240\\u6709<=k\\u4E2D\\uFF0C\"\\u548C\"/sum \\u6700\\u5927\\u7684\\uFF09\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540718,
                "title": "java-readable-kadane-s-with-comments",
                "content": "`Runtime: 791 ms, faster than 18.26% of Java online submissions for Max Sum of Rectangle No Larger Than K.\\nMemory Usage: 42 MB, less than 100.00% of Java online submissions for Max Sum of Rectangle No Larger Than K.`\\n\\n\\n```\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int[] sumColumn = new int[matrix[0].length];\\n        int max = Integer.MIN_VALUE;\\n        for (int l = 0; l < matrix.length; l++) {\\n            // Reset sum column every time we move left index\\n            sumColumn = new int[matrix[0].length];\\n            \\n            // Iterate through combinations of left and right boundaries for columns\\n            for (int r = l; r < matrix.length; r++) { \\n                \\n                // Sum all cell values across columns, starting from left moving towards right\\n                for (int i = 0; i < matrix[0].length; i++) {\\n                    sumColumn[i] += matrix[r][i];\\n                }\\n\\n                // Calculate the local maximum using kadane\\'s and take the max between previous max and new value\\n                max = Math.max(max, kadanes(sumColumn, k));                 \\n                if (max == k) { return k; }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    // Like normal kadane\\'s except we use a TreeSet since we don\\'t want to exceed value k\\n    private int kadanes(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int curr = 0;\\n        \\n        // Create tree set to find local maximum with respect to k\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        // Populate with 0 for the case where curr - k is smaller than 0\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            curr += arr[i];\\n            \\n            // Use the previous sums to determine the smallest previous sum. that can be subtracted from the \\n            // current sum to stay under the value k, by taking the ceiling value for curr - k\\n            Integer ceil = set.ceiling(curr - k);\\n            if(ceil != null) {\\n                max = Math.max(max, curr - ceil);\\n            }\\n            set.add(curr);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int[] sumColumn = new int[matrix[0].length];\\n        int max = Integer.MIN_VALUE;\\n        for (int l = 0; l < matrix.length; l++) {\\n            // Reset sum column every time we move left index\\n            sumColumn = new int[matrix[0].length];\\n            \\n            // Iterate through combinations of left and right boundaries for columns\\n            for (int r = l; r < matrix.length; r++) { \\n                \\n                // Sum all cell values across columns, starting from left moving towards right\\n                for (int i = 0; i < matrix[0].length; i++) {\\n                    sumColumn[i] += matrix[r][i];\\n                }\\n\\n                // Calculate the local maximum using kadane\\'s and take the max between previous max and new value\\n                max = Math.max(max, kadanes(sumColumn, k));                 \\n                if (max == k) { return k; }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    // Like normal kadane\\'s except we use a TreeSet since we don\\'t want to exceed value k\\n    private int kadanes(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int curr = 0;\\n        \\n        // Create tree set to find local maximum with respect to k\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        // Populate with 0 for the case where curr - k is smaller than 0\\n        set.add(0);\\n        for (int i = 0; i < arr.length; i++) {\\n            curr += arr[i];\\n            \\n            // Use the previous sums to determine the smallest previous sum. that can be subtracted from the \\n            // current sum to stay under the value k, by taking the ceiling value for curr - k\\n            Integer ceil = set.ceiling(curr - k);\\n            if(ceil != null) {\\n                max = Math.max(max, curr - ceil);\\n            }\\n            set.add(curr);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463007,
                "title": "accepted-c-solution-376-ms-beats-75-61-time-o-col-2-row-2-memory-o-rows-easy-to-understand",
                "content": "Ported to C# and cleaned unnecessary code from: [JavaScript-Solution-Kadane\\'s](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/407822/JavaScript-Solution-Kadane\\'s)\\n```\\npublic class Solution {\\n    \\n    public int MaxSumSubmatrix(int[][] matrix, int k)\\n    {\\n        int max = int.MinValue;\\n        int rows = matrix.Length;\\n        int cols = matrix[0].Length;\\n        int[] sums = new int[rows];\\n        for (int l = 0; l < cols; l++)\\n        {\\n            Array.Clear(sums, 0, rows);            \\n            for (int r = l; r < cols; r++)\\n            {\\n                for (int row = 0; row < rows; row++)\\n                    sums[row] += matrix[row][r];                    \\n                \\n                for (int i = 0; i < rows; i++)\\n                {\\n                    int sum = 0;                             \\n                    for (int j = i; j < rows; j++)\\n                    {\\n                        sum += sums[j];\\n                        if (sum > max && sum <= k)\\n                            max = sum;\\n                    }                    \\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public int MaxSumSubmatrix(int[][] matrix, int k)\\n    {\\n        int max = int.MinValue;\\n        int rows = matrix.Length;\\n        int cols = matrix[0].Length;\\n        int[] sums = new int[rows];\\n        for (int l = 0; l < cols; l++)\\n        {\\n            Array.Clear(sums, 0, rows);            \\n            for (int r = l; r < cols; r++)\\n            {\\n                for (int row = 0; row < rows; row++)\\n                    sums[row] += matrix[row][r];                    \\n                \\n                for (int i = 0; i < rows; i++)\\n                {\\n                    int sum = 0;                             \\n                    for (int j = i; j < rows; j++)\\n                    {\\n                        sum += sums[j];\\n                        if (sum > max && sum <= k)\\n                            max = sum;\\n                    }                    \\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407822,
                "title": "javascript-solution-kadane-s",
                "content": "```javascript\\nvar maxSumSubmatrix = function(m, k) {\\n    let mt=0,mb=0, ml=0,mr=0, max=-Infinity;\\n    let rows = m.length, cols = m[0].length;\\n    let sums=Array(rows);\\n    for (let l = 0; l < cols; l++) {\\n        sums.fill(0);\\n        for (let r=l; l < cols; r++) {\\n            if(r>=cols)break;\\n            for (let row = 0; row < rows; row++) {\\n                sums[row] += m[row][r];\\n            }\\n            for (let i = 0; i < rows; i++) {\\n                let sum = 0;\\n                for (let j = i; j < rows; j++) {\\n                    sum += sums[j];\\n                    if (sum > max && sum <= k) {\\n                        mt = i;\\n                        mb = j;\\n                        ml = l;\\n                        mr = r;\\n                        max = sum;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxSumSubmatrix = function(m, k) {\\n    let mt=0,mb=0, ml=0,mr=0, max=-Infinity;\\n    let rows = m.length, cols = m[0].length;\\n    let sums=Array(rows);\\n    for (let l = 0; l < cols; l++) {\\n        sums.fill(0);\\n        for (let r=l; l < cols; r++) {\\n            if(r>=cols)break;\\n            for (let row = 0; row < rows; row++) {\\n                sums[row] += m[row][r];\\n            }\\n            for (let i = 0; i < rows; i++) {\\n                let sum = 0;\\n                for (let j = i; j < rows; j++) {\\n                    sum += sums[j];\\n                    if (sum > max && sum <= k) {\\n                        mt = i;\\n                        mb = j;\\n                        ml = l;\\n                        mr = r;\\n                        max = sum;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218304,
                "title": "python-dp-kadane-binary-search",
                "content": "* M = # of rows, N= # of cols\\n* M >  N\\n* O(N^2 M^2)\\n\\t* bisect.bisect() takes O(logM) but bisect.insort() takes O(M)\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        n_row, n_col = len(matrix), len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        for l in range(n_col):\\n            sums = [0] * n_row\\n            for r in range(l, n_col):\\n                for i in range(n_row):\\n                    sums[i] += matrix[i][r]\\n                ans = max(ans, self.maxSubArray(sums, k))\\n        return ans\\n                    \\n    def maxSubArray(self, nums, k):\\n        cur_sum, max_sum = 0, float(\\'-inf\\')\\n        sums = [0]\\n        for i, n in enumerate(nums, 1):\\n            cur_sum += n\\n            idx = bisect.bisect_left(sums, cur_sum - k)\\n            if idx != i:\\n                max_sum = max(max_sum, cur_sum - sums[idx])\\n            bisect.insort(sums, cur_sum)\\n        return max_sum\\n\\n        \\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        n_row, n_col = len(matrix), len(matrix[0])\\n        ans = float(\\'-inf\\')\\n        for l in range(n_col):\\n            sums = [0] * n_row\\n            for r in range(l, n_col):\\n                for i in range(n_row):\\n                    sums[i] += matrix[i][r]\\n                ans = max(ans, self.maxSubArray(sums, k))\\n        return ans\\n                    \\n    def maxSubArray(self, nums, k):\\n        cur_sum, max_sum = 0, float(\\'-inf\\')\\n        sums = [0]\\n        for i, n in enumerate(nums, 1):\\n            cur_sum += n\\n            idx = bisect.bisect_left(sums, cur_sum - k)\\n            if idx != i:\\n                max_sum = max(max_sum, cur_sum - sums[idx])\\n            bisect.insort(sums, cur_sum)\\n        return max_sum\\n\\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 83598,
                "title": "java-81ms-beats-previously-submitted-java-solutions",
                "content": "```\\npublic class Solution {\\n\\n    public static int maxSumSubArrayNoGreaterThanK(int[] s, int k) {\\n        int len     = s.length;\\n        int ans     = Integer.MIN_VALUE;\\n        int nums[] = new int[len];\\n        nums[0] = s[0];\\n        for(int i=1;i<len;i++){\\n            nums[i] = nums[i-1] + s[i];\\n        }\\n\\n        for(int i=0;i<len;i++){\\n            for(int j=i;j<len;j++){\\n                int sum;\\n                if(i==0) sum = nums[j];\\n                else sum = nums[j] - nums[i-1];\\n                if(sum > ans && sum <= k)\\n                    ans = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int cols    = matrix[0].length;\\n        int rows    = matrix.length;\\n        int maxSum  = Integer.MIN_VALUE;\\n\\n        for (int leftCol = 0; leftCol < cols; leftCol++) {\\n            int[] tmp = new int[rows];\\n            for (int rightCol = leftCol; rightCol < cols; rightCol++) {\\n                for (int l = 0; l < rows; l++) {\\n                    tmp[l] += matrix[l][rightCol];\\n                }\\n                int currentResult = maxSumSubArrayNoGreaterThanK(tmp,k);\\n                if (currentResult > maxSum) {\\n                    maxSum = currentResult;\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    public static int maxSumSubArrayNoGreaterThanK(int[] s, int k) {\\n        int len     = s.length;\\n        int ans     = Integer.MIN_VALUE;\\n        int nums[] = new int[len];\\n        nums[0] = s[0];\\n        for(int i=1;i<len;i++){\\n            nums[i] = nums[i-1] + s[i];\\n        }\\n\\n        for(int i=0;i<len;i++){\\n            for(int j=i;j<len;j++){\\n                int sum;\\n                if(i==0) sum = nums[j];\\n                else sum = nums[j] - nums[i-1];\\n                if(sum > ans && sum <= k)\\n                    ans = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int cols    = matrix[0].length;\\n        int rows    = matrix.length;\\n        int maxSum  = Integer.MIN_VALUE;\\n\\n        for (int leftCol = 0; leftCol < cols; leftCol++) {\\n            int[] tmp = new int[rows];\\n            for (int rightCol = leftCol; rightCol < cols; rightCol++) {\\n                for (int l = 0; l < rows; l++) {\\n                    tmp[l] += matrix[l][rightCol];\\n                }\\n                int currentResult = maxSumSubArrayNoGreaterThanK(tmp,k);\\n                if (currentResult > maxSum) {\\n                    maxSum = currentResult;\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83611,
                "title": "merge-sort-beat-100-python-submissions",
                "content": "class Solution(object):\\n    def findMaxArea(self, a, l, r, k):\\n        if l >= r: return -2**31\\n        \\n        m = (l+r)/2\\n        res = max(self.findMaxArea(a, l, m, k), self.findMaxArea(a, m+1, r, k))\\n        \\n        i = l\\n        for j in range(m+1, r+1):\\n            while i <= m and a[j] - a[i] > k: i += 1\\n            if i > m: break\\n            if res < a[j] - a[i]: res = a[j] - a[i]\\n            \\n        tmp = [0]*(r-l+1)\\n        i = l\\n        j = m+1\\n        t = 0\\n        \\n        while i <= m and j <= r:\\n            if a[i] <= a[j]:\\n                tmp[t] = a[i]\\n                i += 1\\n                t += 1\\n            else:\\n                tmp[t] = a[j]\\n                t += 1\\n                j += 1\\n        \\n        while i <= m:\\n            tmp[t] = a[i]\\n            t += 1\\n            i += 1\\n            \\n        while j <= r:\\n            tmp[t] = a[j]\\n            t += 1\\n            j += 1\\n            \\n        for i in range(len(tmp)): a[l+i] = tmp[i]\\n        \\n        return res\\n        \\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if len(matrix) == 0 or len(matrix[0]) == 0: return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        if m > n:\\n            m, n = n, m\\n            a = [[0]*n for i in range(m)]\\n            \\n            for i in range(m):\\n                for j in range(n):\\n                    a[i][j] = matrix[j][i]\\n        \\n        else:\\n            a = [[0]*n for i in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    a[i][j] = matrix[i][j]\\n                \\n        res = -2**31\\n        for i in range(m):\\n            h = [0] * n\\n            for j in range(i, m):\\n                sum = [0] * (n+1)\\n                \\n                low = 0\\n                maxArea = -2**31\\n                \\n                for t in range(n):\\n                    h[t] += a[j][t]\\n                    sum[t+1] = sum[t] + h[t]\\n                    \\n                    maxArea = max(maxArea, sum[t+1]-low)\\n                    low = min(low, sum[t+1])\\n                    \\n                if maxArea <= res: continue\\n            \\n                if maxArea == k: return k\\n                if maxArea > k: maxArea = self.findMaxArea(sum, 0, n, k)\\n                \\n                res = max(res, maxArea)\\n                \\n        return res",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def findMaxArea(self, a, l, r, k):\\n        if l >= r: return -2**31\\n        \\n        m = (l+r)/2\\n        res = max(self.findMaxArea(a, l, m, k), self.findMaxArea(a, m+1, r, k))\\n        \\n        i = l\\n        for j in range(m+1, r+1):\\n            while i <= m and a[j] - a[i] > k: i += 1\\n            if i > m: break\\n            if res < a[j] - a[i]: res = a[j] - a[i]\\n            \\n        tmp = [0]*(r-l+1)\\n        i = l\\n        j = m+1\\n        t = 0\\n        \\n        while i <= m and j <= r:\\n            if a[i] <= a[j]:\\n                tmp[t] = a[i]\\n                i += 1\\n                t += 1\\n            else:\\n                tmp[t] = a[j]\\n                t += 1\\n                j += 1\\n        \\n        while i <= m:\\n            tmp[t] = a[i]\\n            t += 1\\n            i += 1\\n            \\n        while j <= r:\\n            tmp[t] = a[j]\\n            t += 1\\n            j += 1\\n            \\n        for i in range(len(tmp)): a[l+i] = tmp[i]\\n        \\n        return res\\n        \\n    def maxSumSubmatrix(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if len(matrix) == 0 or len(matrix[0]) == 0: return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        if m > n:\\n            m, n = n, m\\n            a = [[0]*n for i in range(m)]\\n            \\n            for i in range(m):\\n                for j in range(n):\\n                    a[i][j] = matrix[j][i]\\n        \\n        else:\\n            a = [[0]*n for i in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    a[i][j] = matrix[i][j]\\n                \\n        res = -2**31\\n        for i in range(m):\\n            h = [0] * n\\n            for j in range(i, m):\\n                sum = [0] * (n+1)\\n                \\n                low = 0\\n                maxArea = -2**31\\n                \\n                for t in range(n):\\n                    h[t] += a[j][t]\\n                    sum[t+1] = sum[t] + h[t]\\n                    \\n                    maxArea = max(maxArea, sum[t+1]-low)\\n                    low = min(low, sum[t+1])\\n                    \\n                if maxArea <= res: continue\\n            \\n                if maxArea == k: return k\\n                if maxArea > k: maxArea = self.findMaxArea(sum, 0, n, k)\\n                \\n                res = max(res, maxArea)\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 83620,
                "title": "java-solution-easy-understand",
                "content": "This answer was almost like the solution mentioned in this video:https://www.youtube.com/watch?v=yCQN096CwWM\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int[] a = new int[n];\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int l=0;l<m;l++){\\n            for(int i=0;i<n;i++) a[i] = 0;\\n\\n            for(int r=l;r<m;r++){\\n                for(int i=0;i<n;i++) a[i] += matrix[r][i];\\n                int t = maxSumSubArray(a, k);\\n                max = Math.max(t, max);\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    private int maxSumSubArray(int[] a , int k){\\n\\n        int max = Integer.MIN_VALUE;\\n        int sumj = 0;\\n        TreeSet<Integer> s = new TreeSet();\\n        s.add(0);\\n\\n        for(int i=0;i<a.length;i++){\\n            int t = sumj + a[i];\\n            sumj = t;\\n            Integer gap = s.ceiling(sumj - k);\\n            if(gap != null) max = Math.max(max, sumj - gap);\\n            s.add(t);\\n        }\\n\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "This answer was almost like the solution mentioned in this video:https://www.youtube.com/watch?v=yCQN096CwWM\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int[] a = new int[n];\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int l=0;l<m;l++){\\n            for(int i=0;i<n;i++) a[i] = 0;\\n\\n            for(int r=l;r<m;r++){\\n                for(int i=0;i<n;i++) a[i] += matrix[r][i];\\n                int t = maxSumSubArray(a, k);\\n                max = Math.max(t, max);\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    private int maxSumSubArray(int[] a , int k){\\n\\n        int max = Integer.MIN_VALUE;\\n        int sumj = 0;\\n        TreeSet<Integer> s = new TreeSet();\\n        s.add(0);\\n\\n        for(int i=0;i<a.length;i++){\\n            int t = sumj + a[i];\\n            sumj = t;\\n            Integer gap = s.ceiling(sumj - k);\\n            if(gap != null) max = Math.max(max, sumj - gap);\\n            s.add(t);\\n        }\\n\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 83633,
                "title": "naive-but-accepted-java-solution",
                "content": "Well, I think that this is the most direct solution for this problem. We just add the numbers in every rectangle and find the sum closest but not larger than k. Since the array is 2-d, we have 4 points to decide the rectangle, the algorithm will be O(n^2).\\n\\n    public class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n        \\n        int[][] sums = new int[matrix.length][matrix[0].length];\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (j == 0) {\\n                    sums[i][j] = matrix[i][j];\\n                } else {\\n                    sums[i][j] = sums[i][j - 1] + matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        /* O(n^4) loop */\\n        int max = 0;\\n        boolean firstMax = false;\\n        int tmpSum = 0;\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            for (int j = i; j < matrix[0].length; j++) {\\n                for (int m = 0; m < matrix.length; m++) {\\n                    tmpSum = 0;\\n                    for (int n = m; n < matrix.length; n++) {\\n                        if (i == 0) {\\n                            tmpSum += sums[n][j];\\n                        } else {\\n                            tmpSum += sums[n][j] - sums[n][i - 1];\\n                        }\\n                        if (tmpSum > k) {\\n                            continue;\\n                        } else {\\n                            if (firstMax == false) {\\n                                max = tmpSum;\\n                                firstMax = true;\\n                            } else if ((k - tmpSum) < (k - max)) {\\n                                max = tmpSum;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3561775,
                "title": "363-max-sum-of-rectangle-no-larger-than-k",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n         int ans = INT_MIN, m = size(matrix), n = size(matrix[0]);\\n        for (int l = 0; l < n; l++) {\\n            vector<int>sums(m,0);\\n            for (int r = l; r < n; r++) {\\n                for (int i = 0; i < m; i++) sums[i] += matrix[i][r];\\n                for (int i = 0; i < m; i++) {\\n                    int sum = 0;\\n                    for (int j = i; j < m; j++) {\\n                        sum += sums[j];\\n                        if (sum > ans && sum <= k)                               ans = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n         int ans = INT_MIN, m = size(matrix), n = size(matrix[0]);\\n        for (int l = 0; l < n; l++) {\\n            vector<int>sums(m,0);\\n            for (int r = l; r < n; r++) {\\n                for (int i = 0; i < m; i++) sums[i] += matrix[i][r];\\n                for (int i = 0; i < m; i++) {\\n                    int sum = 0;\\n                    for (int j = i; j < m; j++) {\\n                        sum += sums[j];\\n                        if (sum > ans && sum <= k)                               ans = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518962,
                "title": "faster-than-87-solutions-not-showing-tle-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int res = INT_MIN;\\n        for(int left = 0;left<m;left++){\\n           vector<int>sums(n);\\n            for(int col = left;col<m;col++){\\n                for(int row=0;row<n;row++){\\n                   sums[row]+=matrix[row][col];\\n                }\\n                    set<int>st ={0};\\n                    int run_sum = 0;\\n                    for(int sum :sums){\\n                        run_sum+=sum;\\n                        auto it = st.lower_bound(run_sum-k);\\n                        if(it!=end(st)){\\n                            res = max(res,run_sum-*it);\\n                            if(res==k){\\n                                return res; // doing this for handling TLE\\n                            }\\n                        }\\n                        st.insert(run_sum);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int res = INT_MIN;\\n        for(int left = 0;left<m;left++){\\n           vector<int>sums(n);\\n            for(int col = left;col<m;col++){\\n                for(int row=0;row<n;row++){\\n                   sums[row]+=matrix[row][col];\\n                }\\n                    set<int>st ={0};\\n                    int run_sum = 0;\\n                    for(int sum :sums){\\n                        run_sum+=sum;\\n                        auto it = st.lower_bound(run_sum-k);\\n                        if(it!=end(st)){\\n                            res = max(res,run_sum-*it);\\n                            if(res==k){\\n                                return res; // doing this for handling TLE\\n                            }\\n                        }\\n                        st.insert(run_sum);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497970,
                "title": "wrong-test-case",
                "content": "For the case (Test cas number 20)\\ninput - [[5,-4,-3,4],[-3,-4,4,5],[5,1,5,-4]] and k =8\\nThe output expected answer is 8 - A lot of people are getting the answer 8 too especially if you are using a prefix sum method. I cannot for the life of me find the actual submatrix where 8 is the sum. Can anyone verify if this is a wrong testcase ?",
                "solutionTags": [],
                "code": "For the case (Test cas number 20)\\ninput - [[5,-4,-3,4],[-3,-4,4,5],[5,1,5,-4]] and k =8\\nThe output expected answer is 8 - A lot of people are getting the answer 8 too especially if you are using a prefix sum method. I cannot for the life of me find the actual submatrix where 8 is the sum. Can anyone verify if this is a wrong testcase ?",
                "codeTag": "Unknown"
            },
            {
                "id": 2495732,
                "title": "bfd-brute-force-deal-full-and-full-brute-force-and-nothing-else-beats-90-28-runtime",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int out =-100000-1;\\n        if(matrix.length==1){\\n            int [] arr = new int[matrix[0].length];\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=matrix[0][i];\\n            }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            return (out);\\n        }\\n        else{\\n        for(int j=0;j<matrix.length;j++){\\n            int [] arr = new int[matrix[0].length];\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=matrix[j][i];\\n            }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            for(int m=j+1;m<matrix.length;m++){\\n                for(int l=0;l<arr.length;l++){\\n                arr[l]=arr[l]+matrix[m][l];\\n                    }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            }\\n        }\\n        return out;\\n        }\\n    }\\n    static int desiredSum (int[] A,int k){\\n        int out=-100000-1;\\n        \\n        for(int i=0;i<A.length;i++){\\n            int cursum = A[i];\\n            if(cursum>out&&cursum<=k){\\n                    out=cursum;\\n                }\\n            for(int j=i+1;j<A.length;j++){\\n                cursum = cursum+A[j];\\n                if(cursum>out&&cursum<=k){\\n                    out=cursum;\\n                }\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int out =-100000-1;\\n        if(matrix.length==1){\\n            int [] arr = new int[matrix[0].length];\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=matrix[0][i];\\n            }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            return (out);\\n        }\\n        else{\\n        for(int j=0;j<matrix.length;j++){\\n            int [] arr = new int[matrix[0].length];\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=matrix[j][i];\\n            }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            for(int m=j+1;m<matrix.length;m++){\\n                for(int l=0;l<arr.length;l++){\\n                arr[l]=arr[l]+matrix[m][l];\\n                    }\\n            if(desiredSum(arr,k)>out ){\\n                out = desiredSum(arr,k);\\n            }\\n            }\\n        }\\n        return out;\\n        }\\n    }\\n    static int desiredSum (int[] A,int k){\\n        int out=-100000-1;\\n        \\n        for(int i=0;i<A.length;i++){\\n            int cursum = A[i];\\n            if(cursum>out&&cursum<=k){\\n                    out=cursum;\\n                }\\n            for(int j=i+1;j<A.length;j++){\\n                cursum = cursum+A[j];\\n                if(cursum>out&&cursum<=k){\\n                    out=cursum;\\n                }\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492688,
                "title": "ruby-o-n-2-m-log2-m-using-binary-search-with-comments",
                "content": "Seems like nobody except me has published a solution for Ruby. Nobody knows about `bsearch` method? Ok, here it is for you: [link](https://ruby-doc.org/core-3.1.2/doc/bsearch_rdoc.html).\\n\\n```ruby\\ndef max_sum_submatrix(matrix, k)\\n    m, n = matrix.length, matrix[0].length\\n    res = -Float::INFINITY\\n    # Lets iterate through start and last columns and then we\\'ll iterate through last rows setting boundaries to our rectangle.\\n    # We won\\'t iterate through start rows since we will find the most efficient start row with a binary search \\n    # that is way faster having complexity only O(log2(last_row)) instead of O(last_row).\\n    for start_col in (0...n)\\n        sum_row = Array.new(m, 0)   # There will be sums of elements in rows that are limited by the start and last columns.\\n        for last_col in (start_col...n)\\n            sum = 0     # Current sum of all sums of rows from 0 to last_row.\\n            accum_sums = [0] # It will be a sorted from min to max array of accumulated sums with size m + 1.\\n            for last_row in (0...m)\\n                sum += ( sum_row[last_row] += matrix[last_row][last_col] )\\n                # Now we want to find a minimum subsum to substract from sum so that (sum - subsub) <= k. Lets name it \\'excess\\'.\\n                excess = accum_sums.bsearch { |x| x >= sum - k }   \\n                unless excess.nil? # If excess == nil then it appeared to be imposible to achieve a condition (sum - subsub) <= k\\n                    res = [res, sum - excess].max\\n                end\\n                # Now we need to find an index to insert sum so that accum_sums array stayed sorted from min to max.\\n                idx = accum_sums.bsearch_index { |x| x >= sum }\\n                accum_sums.insert(idx || (last_row + 1), sum)\\n            end\\n        end\\n    end\\n    res\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Binary Search"
                ],
                "code": "```ruby\\ndef max_sum_submatrix(matrix, k)\\n    m, n = matrix.length, matrix[0].length\\n    res = -Float::INFINITY\\n    # Lets iterate through start and last columns and then we\\'ll iterate through last rows setting boundaries to our rectangle.\\n    # We won\\'t iterate through start rows since we will find the most efficient start row with a binary search \\n    # that is way faster having complexity only O(log2(last_row)) instead of O(last_row).\\n    for start_col in (0...n)\\n        sum_row = Array.new(m, 0)   # There will be sums of elements in rows that are limited by the start and last columns.\\n        for last_col in (start_col...n)\\n            sum = 0     # Current sum of all sums of rows from 0 to last_row.\\n            accum_sums = [0] # It will be a sorted from min to max array of accumulated sums with size m + 1.\\n            for last_row in (0...m)\\n                sum += ( sum_row[last_row] += matrix[last_row][last_col] )\\n                # Now we want to find a minimum subsum to substract from sum so that (sum - subsub) <= k. Lets name it \\'excess\\'.\\n                excess = accum_sums.bsearch { |x| x >= sum - k }   \\n                unless excess.nil? # If excess == nil then it appeared to be imposible to achieve a condition (sum - subsub) <= k\\n                    res = [res, sum - excess].max\\n                end\\n                # Now we need to find an index to insert sum so that accum_sums array stayed sorted from min to max.\\n                idx = accum_sums.bsearch_index { |x| x >= sum }\\n                accum_sums.insert(idx || (last_row + 1), sum)\\n            end\\n        end\\n    end\\n    res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492234,
                "title": "ruby-o-n-2-m-2",
                "content": "```ruby\\ndef max_sum_submatrix(matrix, k)\\n    m, n = matrix.length, matrix[0].length\\n    res = -Float::INFINITY\\n    for start_col in (0...n)\\n        sum_row = Array.new(m, 0)\\n        for last_col in (start_col...n)\\n            for row in (0...m)\\n                sum_row[row] += matrix[row][last_col]\\n            end\\n            for start_row in (0...m)\\n                sum = 0\\n                for last_row in (start_row...m)\\n                    sum += sum_row[last_row]\\n                    sum == k ? (return k) : (sum < k && sum > res && res = sum)\\n                end\\n            end\\n        end\\n    end\\n    res\\nend\\n```\\nMy another one ruby solution (more optimized using binary search) you can find here: [link](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/2492688/Ruby-or-O(n2-*-m-*-log2(m))-using-binary-search.-With-comments!).",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef max_sum_submatrix(matrix, k)\\n    m, n = matrix.length, matrix[0].length\\n    res = -Float::INFINITY\\n    for start_col in (0...n)\\n        sum_row = Array.new(m, 0)\\n        for last_col in (start_col...n)\\n            for row in (0...m)\\n                sum_row[row] += matrix[row][last_col]\\n            end\\n            for start_row in (0...m)\\n                sum = 0\\n                for last_row in (start_row...m)\\n                    sum += sum_row[last_row]\\n                    sum == k ? (return k) : (sum < k && sum > res && res = sum)\\n                end\\n            end\\n        end\\n    end\\n    res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492089,
                "title": "typescript-100-faster-and-100-memory-efficient",
                "content": "```\\nfunction maxSumSubmatrix(matrix: number[][], k: number): number {\\n    // Idea:\\n    // calculate sum of the rectangle from [0,0] to [i,j]\\n    // then calculate sum of rectangles from [x1,y1] to [x2,y2] using the previously calculated sum in O(1)\\n\\n    const m = matrix.length, n = matrix[0].length;\\n    const MIN_VAL = -100 * m * n;\\n\\n    // Calculate row-wise cummilitive sum\\n    const rowCSum: number[][] = []; // O(m*n)\\n    for (let i = 0; i < m; i++) { // O(m*n)\\n        rowCSum[i] = [];\\n        rowCSum[i][0] = matrix[i][0];\\n        for (let j = 1; j < n; j++) {\\n            rowCSum[i][j] = rowCSum[i][j - 1] + matrix[i][j];\\n        }\\n    }\\n\\n    const sums: number[][] = rowCSum.map(row => row.map(col => col)); // O(m*n)\\n\\n    for (let c = 0; c < n; c++) { // O(m*n)\\n        for (let r = 1; r < m; r++) {\\n            sums[r][c] = sums[r - 1][c] + rowCSum[r][c];\\n        }\\n    }\\n\\n    let ans = MIN_VAL;\\n    let reg = {};\\n\\n    // O(m^2*n^2)\\n    for (let x1 = 0; x1 < m; x1++) {\\n        for (let y1 = 0; y1 < n; y1++) {\\n            for (let x2 = x1; x2 < m; x2++) {\\n                for (let y2 = y1; y2 < n; y2++) {\\n                    let t = sums[x2][y2];\\n                    if (x1 > 0) t -= sums[x1 - 1][y2];\\n                    if (y1 > 0) t -= sums[x2][y1 - 1];\\n\\n                    if (x1 > 0 && y1 > 0) t += sums[x1 - 1][y1 - 1];\\n\\n                    if (t === k) return t;\\n                    if (t <= k && ans < t) { ans = t; reg = { x1, y1, x2, y2 } }\\n                }\\n            }\\n        }\\n    }\\n\\n    return ans;\\n};\\n```\\n\\nTime complexity: O(m^2 * n^2)\\nSpace: O(m*n) + O(m*n)",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxSumSubmatrix(matrix: number[][], k: number): number {\\n    // Idea:\\n    // calculate sum of the rectangle from [0,0] to [i,j]\\n    // then calculate sum of rectangles from [x1,y1] to [x2,y2] using the previously calculated sum in O(1)\\n\\n    const m = matrix.length, n = matrix[0].length;\\n    const MIN_VAL = -100 * m * n;\\n\\n    // Calculate row-wise cummilitive sum\\n    const rowCSum: number[][] = []; // O(m*n)\\n    for (let i = 0; i < m; i++) { // O(m*n)\\n        rowCSum[i] = [];\\n        rowCSum[i][0] = matrix[i][0];\\n        for (let j = 1; j < n; j++) {\\n            rowCSum[i][j] = rowCSum[i][j - 1] + matrix[i][j];\\n        }\\n    }\\n\\n    const sums: number[][] = rowCSum.map(row => row.map(col => col)); // O(m*n)\\n\\n    for (let c = 0; c < n; c++) { // O(m*n)\\n        for (let r = 1; r < m; r++) {\\n            sums[r][c] = sums[r - 1][c] + rowCSum[r][c];\\n        }\\n    }\\n\\n    let ans = MIN_VAL;\\n    let reg = {};\\n\\n    // O(m^2*n^2)\\n    for (let x1 = 0; x1 < m; x1++) {\\n        for (let y1 = 0; y1 < n; y1++) {\\n            for (let x2 = x1; x2 < m; x2++) {\\n                for (let y2 = y1; y2 < n; y2++) {\\n                    let t = sums[x2][y2];\\n                    if (x1 > 0) t -= sums[x1 - 1][y2];\\n                    if (y1 > 0) t -= sums[x2][y1 - 1];\\n\\n                    if (x1 > 0 && y1 > 0) t += sums[x1 - 1][y1 - 1];\\n\\n                    if (t === k) return t;\\n                    if (t <= k && ans < t) { ans = t; reg = { x1, y1, x2, y2 } }\\n                }\\n            }\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492027,
                "title": "max-sum-of-rectangle-no-longer-than-k-upvote-if-you-find-helpfull",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int tar) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<tar){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==tar){\\n                            return tar;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491727,
                "title": "java-prefixsum",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[][] prefix = calculatePrefix(matrix);\\n        int answer = -100_001;\\n        for (int sr = 0; sr < n; sr++) {\\n            for (int er = sr; er < n; er++) {\\n                for (int sc = 0; sc < m; sc++) {\\n                    for (int ec = sc; ec < m; ec++) {\\n                        //  find the sum of the rectangle [sr, sc] and [er, ec] both inclusive\\n                        int sum = prefix[er + 1][ec + 1] - prefix[sr][ec + 1] - prefix[er + 1][sc] + prefix[sr][sc];\\n                        if (sum <= k && sum > answer) {\\n                            answer = sum;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public int[][] calculatePrefix(int[][] a) {\\n        int n = a.length, m = a[0].length;\\n        int[][] answer = new int[n+1][m+1];\\n        //  at answer[i][j] -> sum of submatrix starting at (0,0) ending at (i - 1) and (j - 1)\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                answer[i][j] = answer[i-1][j] + answer[i][j-1] - answer[i-1][j-1] + a[i-1][j-1];\\n            }\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[][] prefix = calculatePrefix(matrix);\\n        int answer = -100_001;\\n        for (int sr = 0; sr < n; sr++) {\\n            for (int er = sr; er < n; er++) {\\n                for (int sc = 0; sc < m; sc++) {\\n                    for (int ec = sc; ec < m; ec++) {\\n                        //  find the sum of the rectangle [sr, sc] and [er, ec] both inclusive\\n                        int sum = prefix[er + 1][ec + 1] - prefix[sr][ec + 1] - prefix[er + 1][sc] + prefix[sr][sc];\\n                        if (sum <= k && sum > answer) {\\n                            answer = sum;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2491601,
                "title": "rust-functional-style",
                "content": "```\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let mut set = BTreeSet::<i32>::new();\\n        let (n, m) = (matrix.len(), matrix[0].len());\\n        (0..n).map(|i| {\\n            let mut acc = vec![0; m];\\n            matrix.iter().skip(i).map(|row| {\\n                set.clear();\\n                set.insert(0);\\n                let mut prefix_sum = 0;\\n                acc.iter_mut().zip(row.iter()).map(|(a, r)| {\\n                    *a += r;\\n                    prefix_sum += *a;\\n                    let rez = set.range(prefix_sum - k..).next().map(|s| prefix_sum - *s);\\n                    set.insert(prefix_sum);\\n                    rez\\n                }).max()\\n            }).max()\\n        }).max().unwrap().unwrap().unwrap().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let mut set = BTreeSet::<i32>::new();\\n        let (n, m) = (matrix.len(), matrix[0].len());\\n        (0..n).map(|i| {\\n            let mut acc = vec![0; m];\\n            matrix.iter().skip(i).map(|row| {\\n                set.clear();\\n                set.insert(0);\\n                let mut prefix_sum = 0;\\n                acc.iter_mut().zip(row.iter()).map(|(a, r)| {\\n                    *a += r;\\n                    prefix_sum += *a;\\n                    let rez = set.range(prefix_sum - k..).next().map(|s| prefix_sum - *s);\\n                    set.insert(prefix_sum);\\n                    rez\\n                }).max()\\n            }).max()\\n        }).max().unwrap().unwrap().unwrap().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491465,
                "title": "dp-vertical-prefix-same-logic-in-c-go-javascript-but-python-give-tle",
                "content": "# C++\\n```cpp\\nclass Solution {\\n\\n#define vvi vector<vector<int>>\\n#define vi vector<int>\\n\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& grid, int k)\\n    {\\n        int     C = grid[0].size();\\n        int     R = grid.size();\\n        int     i, j, ii, jj, tmp, r;\\n        vvi     dp(R + 1, vi(C, 0));\\n\\n        /*  \\n        *   step 1: make a dp grid of (r + 1) x c\\n        *   set to \\'cascading\\' prefix sum\\n        */\\n\\n        i = -1;\\n        while (++i < R)\\n        {\\n            j = -1;\\n            while (++j < C)\\n                dp[i + 1][j] = dp[i][j] + grid[i][j];\\n        }\\n        vvip(dp, R + 1, C); // printer\\n\\n        /*  \\n        *   step 2: traversing/squeezing in from top-left to bottom-right\\n        *   find sum that equals k\\n        *   if not found, let res = max(res, sum)\\n        */\\n\\n        r = -2147483648;\\n        i = -1;\\n        while (++i < R)\\n        {\\n            ii = i;\\n            while (++ii < R + 1)\\n            {\\n                j = -1;\\n                while (++j < C)\\n                {\\n                    tmp = 0;\\n                    jj = j - 1;\\n                    while (++jj < C)\\n                    {\\n                        tmp += dp[ii][jj] - dp[i][jj];\\n                        if (tmp == k)\\n                            return k;\\n                        if (tmp < k && r < tmp)\\n                            r = tmp;\\n                    }\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n\\n    void    vvip(vvi dp, int r, int c)\\n    {\\n        int     i = -1, j;\\n\\n        while (++i < r)\\n        {\\n            j = -1;\\n            while (++j < c)\\n                cout << dp[i][j] << \\' \\';\\n            cout << \\'\\\\n\\';\\n        }\\n        cout << \\'\\\\n\\';\\n    }\\n};\\n\\n/*\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\\n# Go\\n```cpp\\nfunc maxSumSubmatrix(grid [][]int, k int) int {\\n    r := len(grid)\\n    c := len(grid[0])\\n    dp := make([][] int, r + 1)\\n    for i := range dp {\\n        dp[i] = make([] int, c)\\n    }\\n    // fmt.Print(dp)\\n    for i := 0; i < r; i++ {\\n        for j := 0; j < c; j++ {\\n            dp[i + 1][j] = dp[i][j] + grid[i][j]\\n        }\\n    }\\n    // fmt.Print(dp)\\n    res := -2147483648\\n    for i := 0; i < r; i++ {\\n        for ii := i + 1; ii < r + 1; ii++ {\\n            for j := 0; j < c; j++ {\\n                tmp := 0\\n                for jj := j; jj < c; jj++ {\\n                    tmp += dp[ii][jj] - dp[i][jj] // minus\\n                    if tmp == k {\\n                        return k\\n                    }\\n                    if tmp < k && res < tmp {\\n                        res = tmp\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\n/*\\n[[1,0,1],[0,-2,3]]\\n2\\n[[2,2,-1]]\\n3\\n[[2,2,-1]]\\n0\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\\n# Javascript\\n```go\\n/**\\n * @param {number[][]} matrix\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxSumSubmatrix = function(grid, k) {\\n    let c = grid[0].length\\n    let r = grid.length\\n    let i, j\\n    let dp = [...Array(r + 1)].map(e => Array(c).fill(0))\\n    // console.log(dp)\\n    i = -1;\\n    while (++i < r) {\\n        j = -1;\\n        while (++j < c)\\n            dp[i + 1][j] = dp[i][j] + grid[i][j];\\n    }\\n    // console.log(dp)\\n    let res = -2147483648;\\n    i = -1;\\n    while (++i < r) {\\n        let ii = i;\\n        while (++ii < r + 1) {\\n            j = -1;\\n            while (++j < c) {\\n                let tmp = 0;\\n                let jj = j - 1;\\n                while (++jj < c) {\\n                    tmp += dp[ii][jj] - dp[i][jj];\\n                    if (tmp == k)\\n                        return k;\\n                    if (tmp < k && res < tmp)\\n                        res = tmp;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\n/*\\n[[1,0,1],[0,-2,3]]\\n2\\n[[2,2,-1]]\\n3\\n[[2,2,-1]]\\n0\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\\n\\n# Python \\n```rust\\nclass Solution:\\n    def maxSumSubmatrix(self, grid: List[List[int]], k: int) -> int:\\n        r = len(grid)\\n        c = len(grid[0])\\n        dp = [[0] * c for _ in range(r + 1)]\\n        for i in range(r):\\n            for j in range(c):\\n                dp[i + 1][j] = dp[i][j] + grid[i][j]\\n        res = -1e9\\n        for i in range(r):\\n            for ii in range(i + 1, r + 1): # 2 vertical idx\\n                for j in range(c):\\n                    val = 0\\n                    for jj in range(j, c):\\n                        val += dp[ii][jj] - dp[i][jj]\\n                        if val == k:\\n                            return k\\n                        if val < k and val > res:\\n                            res = val\\n        return res\\n\\n\\n\"\"\"\\n[[1,0,1],[0,-2,3]]\\n2\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n[[2,2,-1]]\\n0\\n\"\"\"\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\n\\n#define vvi vector<vector<int>>\\n#define vi vector<int>\\n\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& grid, int k)\\n    {\\n        int     C = grid[0].size();\\n        int     R = grid.size();\\n        int     i, j, ii, jj, tmp, r;\\n        vvi     dp(R + 1, vi(C, 0));\\n\\n        /*  \\n        *   step 1: make a dp grid of (r + 1) x c\\n        *   set to \\'cascading\\' prefix sum\\n        */\\n\\n        i = -1;\\n        while (++i < R)\\n        {\\n            j = -1;\\n            while (++j < C)\\n                dp[i + 1][j] = dp[i][j] + grid[i][j];\\n        }\\n        vvip(dp, R + 1, C); // printer\\n\\n        /*  \\n        *   step 2: traversing/squeezing in from top-left to bottom-right\\n        *   find sum that equals k\\n        *   if not found, let res = max(res, sum)\\n        */\\n\\n        r = -2147483648;\\n        i = -1;\\n        while (++i < R)\\n        {\\n            ii = i;\\n            while (++ii < R + 1)\\n            {\\n                j = -1;\\n                while (++j < C)\\n                {\\n                    tmp = 0;\\n                    jj = j - 1;\\n                    while (++jj < C)\\n                    {\\n                        tmp += dp[ii][jj] - dp[i][jj];\\n                        if (tmp == k)\\n                            return k;\\n                        if (tmp < k && r < tmp)\\n                            r = tmp;\\n                    }\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n\\n    void    vvip(vvi dp, int r, int c)\\n    {\\n        int     i = -1, j;\\n\\n        while (++i < r)\\n        {\\n            j = -1;\\n            while (++j < c)\\n                cout << dp[i][j] << \\' \\';\\n            cout << \\'\\\\n\\';\\n        }\\n        cout << \\'\\\\n\\';\\n    }\\n};\\n\\n/*\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\n```cpp\\nfunc maxSumSubmatrix(grid [][]int, k int) int {\\n    r := len(grid)\\n    c := len(grid[0])\\n    dp := make([][] int, r + 1)\\n    for i := range dp {\\n        dp[i] = make([] int, c)\\n    }\\n    // fmt.Print(dp)\\n    for i := 0; i < r; i++ {\\n        for j := 0; j < c; j++ {\\n            dp[i + 1][j] = dp[i][j] + grid[i][j]\\n        }\\n    }\\n    // fmt.Print(dp)\\n    res := -2147483648\\n    for i := 0; i < r; i++ {\\n        for ii := i + 1; ii < r + 1; ii++ {\\n            for j := 0; j < c; j++ {\\n                tmp := 0\\n                for jj := j; jj < c; jj++ {\\n                    tmp += dp[ii][jj] - dp[i][jj] // minus\\n                    if tmp == k {\\n                        return k\\n                    }\\n                    if tmp < k && res < tmp {\\n                        res = tmp\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\n/*\\n[[1,0,1],[0,-2,3]]\\n2\\n[[2,2,-1]]\\n3\\n[[2,2,-1]]\\n0\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\n```go\\n/**\\n * @param {number[][]} matrix\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxSumSubmatrix = function(grid, k) {\\n    let c = grid[0].length\\n    let r = grid.length\\n    let i, j\\n    let dp = [...Array(r + 1)].map(e => Array(c).fill(0))\\n    // console.log(dp)\\n    i = -1;\\n    while (++i < r) {\\n        j = -1;\\n        while (++j < c)\\n            dp[i + 1][j] = dp[i][j] + grid[i][j];\\n    }\\n    // console.log(dp)\\n    let res = -2147483648;\\n    i = -1;\\n    while (++i < r) {\\n        let ii = i;\\n        while (++ii < r + 1) {\\n            j = -1;\\n            while (++j < c) {\\n                let tmp = 0;\\n                let jj = j - 1;\\n                while (++jj < c) {\\n                    tmp += dp[ii][jj] - dp[i][jj];\\n                    if (tmp == k)\\n                        return k;\\n                    if (tmp < k && res < tmp)\\n                        res = tmp;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\n/*\\n[[1,0,1],[0,-2,3]]\\n2\\n[[2,2,-1]]\\n3\\n[[2,2,-1]]\\n0\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n*/\\n```\n```rust\\nclass Solution:\\n    def maxSumSubmatrix(self, grid: List[List[int]], k: int) -> int:\\n        r = len(grid)\\n        c = len(grid[0])\\n        dp = [[0] * c for _ in range(r + 1)]\\n        for i in range(r):\\n            for j in range(c):\\n                dp[i + 1][j] = dp[i][j] + grid[i][j]\\n        res = -1e9\\n        for i in range(r):\\n            for ii in range(i + 1, r + 1): # 2 vertical idx\\n                for j in range(c):\\n                    val = 0\\n                    for jj in range(j, c):\\n                        val += dp[ii][jj] - dp[i][jj]\\n                        if val == k:\\n                            return k\\n                        if val < k and val > res:\\n                            res = val\\n        return res\\n\\n\\n\"\"\"\\n[[1,0,1],[0,-2,3]]\\n2\\n[[1,0,1],[0,-2,3],[2,6,-6]]\\n2\\n[[1,0,1],[0,-2,3],[-10,-12,-1]]\\n2\\n[[2,2,-1]]\\n0\\n\"\"\"\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2491303,
                "title": "c-solution-using-kadanes-algorithm",
                "content": "have used kadanes algorithm to find max sum in every column and to overcome the issue with kadanes algorithm ( when sum<0 case) have used set. \\n```\\n int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if(matrix.empty())\\n            return 0;\\n        int sol = INT_MIN;\\n        int row= matrix.size(), column = matrix[0].size();\\n        for(int l=0;l<column;l++){\\n            vector<int> temp(row,0);\\n            for(int r=l; r<column;r++){\\n                for(int i=0;i<row;i++){\\n                    temp[i] += matrix[i][r];\\n                }\\n            set<int> accuSet;\\n            accuSet.insert(0);\\n            int sums = 0, max_sum = INT_MIN;\\n            for (int sum : temp) {\\n                sums += sum;\\n                set<int>::iterator it = accuSet.lower_bound(sums - k);\\n                if (it != accuSet.end()) max_sum = max(max_sum, sums - *it);\\n                accuSet.insert(sums);\\n            }\\n            sol = max(sol, max_sum);\\n            }\\n        }\\n        return sol;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if(matrix.empty())\\n            return 0;\\n        int sol = INT_MIN;\\n        int row= matrix.size(), column = matrix[0].size();\\n        for(int l=0;l<column;l++){\\n            vector<int> temp(row,0);\\n            for(int r=l; r<column;r++){\\n                for(int i=0;i<row;i++){\\n                    temp[i] += matrix[i][r];\\n                }\\n            set<int> accuSet;\\n            accuSet.insert(0);\\n            int sums = 0, max_sum = INT_MIN;\\n            for (int sum : temp) {\\n                sums += sum;\\n                set<int>::iterator it = accuSet.lower_bound(sums - k);\\n                if (it != accuSet.end()) max_sum = max(max_sum, sums - *it);\\n                accuSet.insert(sums);\\n            }\\n            sol = max(sol, max_sum);\\n            }\\n        }\\n        return sol;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491043,
                "title": "clean-simple-c-prefix-sum-solution-space-99",
                "content": "```\\nclass Solution {\\npublic:\\n  int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n      \\n    int n=matrix.size(), m = matrix[0].size();\\n    vector<vector<int>> cum(n, vector<int> (m, 0));\\n    //cum[i][j] gives area of rectangle from (0,0) to (i,j)\\n\\n    //Filling the cum matrix\\n    cum[0][0] = matrix[0][0];\\n\\n    //filling 0th row\\n    for(int row=1; row<n; row++){\\n      cum[row][0] = cum[row-1][0] + matrix[row][0];\\n    }\\n    //filling 0th col\\n    for(int col=1; col<m; col++){\\n      cum[0][col] = cum[0][col-1] + matrix[0][col];\\n    }     \\n\\n    for(int row=1; row<n; row++){\\n      for(int col=1; col<m; col++){\\n        cum[row][col] = matrix[row][col] + (cum[row][col-1] + cum[row-1][col] - cum[row-1][col-1]);\\n      }\\n    }\\n    //checking the values in cum matrix\\n    // for(int row=0; row<n; row++){\\n    //   for(int col=0; col<m; col++){\\n    //     cout<<cum[row][col]<<\" \";\\n    //   }cout<<endl;\\n    // }\\n\\n    int max_area = INT_MIN, cur_area;\\n\\n    for(int st_row=0; st_row<n; st_row++){\\n      for(int st_col=0; st_col<m; st_col++){\\n        \\n        for(int en_row=st_row; en_row<n; en_row++){\\n          for(int en_col=st_col; en_col<m; en_col++){\\n            \\n            cur_area = INT_MIN;\\n            \\n            if(en_row==st_row && en_col==st_col){\\n              cur_area = matrix[en_row][en_col]; //single ele max case \\n            }\\n            else{\\n              if(st_row==0 && st_col==0){\\n                cur_area = cum[en_row][en_col];\\n              }\\n              else if(st_row == 0){\\n                cur_area =  cum[en_row][en_col] - cum[en_row][st_col - 1];\\n              }\\n              else if(st_col == 0){\\n                cur_area = cum[en_row][en_col] - cum[st_row - 1][en_col];\\n              }\\n              else{\\n                cur_area = cum[en_row][en_col] - cum[en_row][st_col - 1] - cum[st_row - 1][en_col] + cum[st_row - 1][st_col - 1];\\n              }\\n            }\\n\\n            // cout<<cur_area<<\" \";\\n            if(cur_area <= k){\\n              max_area = max(max_area, cur_area);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return max_area;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n      \\n    int n=matrix.size(), m = matrix[0].size();\\n    vector<vector<int>> cum(n, vector<int> (m, 0));\\n    //cum[i][j] gives area of rectangle from (0,0) to (i,j)\\n\\n    //Filling the cum matrix\\n    cum[0][0] = matrix[0][0];\\n\\n    //filling 0th row\\n    for(int row=1; row<n; row++){\\n      cum[row][0] = cum[row-1][0] + matrix[row][0];\\n    }\\n    //filling 0th col\\n    for(int col=1; col<m; col++){\\n      cum[0][col] = cum[0][col-1] + matrix[0][col];\\n    }     \\n\\n    for(int row=1; row<n; row++){\\n      for(int col=1; col<m; col++){\\n        cum[row][col] = matrix[row][col] + (cum[row][col-1] + cum[row-1][col] - cum[row-1][col-1]);\\n      }\\n    }\\n    //checking the values in cum matrix\\n    // for(int row=0; row<n; row++){\\n    //   for(int col=0; col<m; col++){\\n    //     cout<<cum[row][col]<<\" \";\\n    //   }cout<<endl;\\n    // }\\n\\n    int max_area = INT_MIN, cur_area;\\n\\n    for(int st_row=0; st_row<n; st_row++){\\n      for(int st_col=0; st_col<m; st_col++){\\n        \\n        for(int en_row=st_row; en_row<n; en_row++){\\n          for(int en_col=st_col; en_col<m; en_col++){\\n            \\n            cur_area = INT_MIN;\\n            \\n            if(en_row==st_row && en_col==st_col){\\n              cur_area = matrix[en_row][en_col]; //single ele max case \\n            }\\n            else{\\n              if(st_row==0 && st_col==0){\\n                cur_area = cum[en_row][en_col];\\n              }\\n              else if(st_row == 0){\\n                cur_area =  cum[en_row][en_col] - cum[en_row][st_col - 1];\\n              }\\n              else if(st_col == 0){\\n                cur_area = cum[en_row][en_col] - cum[st_row - 1][en_col];\\n              }\\n              else{\\n                cur_area = cum[en_row][en_col] - cum[en_row][st_col - 1] - cum[st_row - 1][en_col] + cum[st_row - 1][st_col - 1];\\n              }\\n            }\\n\\n            // cout<<cur_area<<\" \";\\n            if(cur_area <= k){\\n              max_area = max(max_area, cur_area);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return max_area;\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2490720,
                "title": "elixir-rust-prefix-sum-solution",
                "content": "Similar as [1074. Number of Submatrices That Sum to Target](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/)\\n\\n```elixir\\ndefmodule Solution do\\n  @spec max_sum_submatrix(matrix :: [[integer]], k :: integer) :: integer\\n  def max_sum_submatrix(matrix, k) do\\n    m = length(matrix) - 1\\n    n = length(hd(matrix)) - 1\\n\\n    matrix =\\n      matrix\\n      |> Enum.with_index()\\n      |> Enum.reduce(%{}, fn {row, i}, acc ->\\n        row\\n        |> Enum.with_index()\\n        |> Enum.reduce(acc, fn {n, j}, acc ->\\n          if j == 0 do\\n            Map.put(acc, {i, j}, n)\\n          else\\n            Map.put(acc, {i, j}, n + acc[{i, j - 1}])\\n          end\\n        end)\\n      end)\\n\\n    for left <- 0..n, right <- left..n, reduce: -100_000 do\\n      ans ->\\n        for r <- 0..m, reduce: {ans, 0, :gb_sets.from_list([0])} do\\n          {ans, pre_sum, set} ->\\n            pre_sum = pre_sum + matrix[{r, right}] - Map.get(matrix, {r, left - 1}, 0)\\n            iter = :gb_sets.iterator_from(pre_sum - k, set)\\n\\n            ans =\\n              case :gb_sets.next(iter) do\\n                {sum, _} -> max(ans, pre_sum - sum)\\n                _ -> ans\\n              end\\n\\n            set = :gb_sets.add(pre_sum, set)\\n            {ans, pre_sum, set}\\n        end\\n        |> elem(0)\\n    end\\n  end\\nend\\n```\\n\\n```rust\\nuse std::collections::BTreeSet;\\nuse std::ops::Bound::Included;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(mut matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        for i in 0..matrix.len() {\\n            for j in 1..matrix[i].len() {\\n                matrix[i][j] += matrix[i][j - 1];\\n            }\\n        }\\n\\n        let mut ans = i32::MIN;\\n        for left in 0..matrix[0].len() {\\n            for right in left..matrix[0].len() {\\n                let mut set = BTreeSet::new();\\n                set.insert(0);\\n                let mut pre_sum = 0;\\n                for r in 0..matrix.len() {\\n                    pre_sum += matrix[r][right];\\n                    if left > 0 {\\n                        pre_sum -= matrix[r][left - 1];\\n                    }\\n                    if let Some(sum) = set.range(pre_sum - k..).next() {\\n                        ans = ans.max(pre_sum - sum);\\n                    }\\n\\n                    set.insert(pre_sum);\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Prefix Sum"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec max_sum_submatrix(matrix :: [[integer]], k :: integer) :: integer\\n  def max_sum_submatrix(matrix, k) do\\n    m = length(matrix) - 1\\n    n = length(hd(matrix)) - 1\\n\\n    matrix =\\n      matrix\\n      |> Enum.with_index()\\n      |> Enum.reduce(%{}, fn {row, i}, acc ->\\n        row\\n        |> Enum.with_index()\\n        |> Enum.reduce(acc, fn {n, j}, acc ->\\n          if j == 0 do\\n            Map.put(acc, {i, j}, n)\\n          else\\n            Map.put(acc, {i, j}, n + acc[{i, j - 1}])\\n          end\\n        end)\\n      end)\\n\\n    for left <- 0..n, right <- left..n, reduce: -100_000 do\\n      ans ->\\n        for r <- 0..m, reduce: {ans, 0, :gb_sets.from_list([0])} do\\n          {ans, pre_sum, set} ->\\n            pre_sum = pre_sum + matrix[{r, right}] - Map.get(matrix, {r, left - 1}, 0)\\n            iter = :gb_sets.iterator_from(pre_sum - k, set)\\n\\n            ans =\\n              case :gb_sets.next(iter) do\\n                {sum, _} -> max(ans, pre_sum - sum)\\n                _ -> ans\\n              end\\n\\n            set = :gb_sets.add(pre_sum, set)\\n            {ans, pre_sum, set}\\n        end\\n        |> elem(0)\\n    end\\n  end\\nend\\n```\n```rust\\nuse std::collections::BTreeSet;\\nuse std::ops::Bound::Included;\\n\\nimpl Solution {\\n    pub fn max_sum_submatrix(mut matrix: Vec<Vec<i32>>, k: i32) -> i32 {\\n        for i in 0..matrix.len() {\\n            for j in 1..matrix[i].len() {\\n                matrix[i][j] += matrix[i][j - 1];\\n            }\\n        }\\n\\n        let mut ans = i32::MIN;\\n        for left in 0..matrix[0].len() {\\n            for right in left..matrix[0].len() {\\n                let mut set = BTreeSet::new();\\n                set.insert(0);\\n                let mut pre_sum = 0;\\n                for r in 0..matrix.len() {\\n                    pre_sum += matrix[r][right];\\n                    if left > 0 {\\n                        pre_sum -= matrix[r][left - 1];\\n                    }\\n                    if let Some(sum) = set.range(pre_sum - k..).next() {\\n                        ans = ans.max(pre_sum - sum);\\n                    }\\n\\n                    set.insert(pre_sum);\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2490502,
                "title": "clean-python3-w-comments-prefix-sum-bisect-faster-than-97",
                "content": "Please Upvote if it helps! :)\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        rows, cols = len(matrix), len(matrix[0])\\n        prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] #take advantage of -1 indexing\\n        # build prefix sum matrix, keeping track of the sum above and left of each index\\n        for row in range(rows):\\n            sum_left = 0\\n            for col in range(cols):\\n                sum_above = prefix_sum[row - 1][col]\\n                sum_left += matrix[row][col]\\n                prefix_sum[row][col] = sum_above + sum_left\\n                \\n        # fix start and end row, and for each traverse across the columns\\n        max_sum_lk = float(\\'-inf\\')\\n        for row1 in range(rows):\\n            for row2 in range(row1, rows):\\n                left_sums = [0]\\n                # binary search for a sum to the left that is as small as possible (because we are subtracting it),\\n                # such that the cumulative sum across all these columns minus that left sum is <= k\\n                for end_col in range(cols):\\n                    sum_here = prefix_sum[row2][end_col] - prefix_sum[row1 - 1][end_col]\\n                    \\n                    ins = bisect_right(left_sums, sum_here - k)\\n                    if ins > 0 and left_sums[ins - 1] == sum_here - k:\\n                        return k\\n                    elif ins <= end_col:\\n                        max_sum_lk = max(max_sum_lk, sum_here - left_sums[ins])\\n                        \\n                    insort(left_sums, sum_here)\\n\\n        return max_sum_lk",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "Please Upvote if it helps! :)\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        rows, cols = len(matrix), len(matrix[0])\\n        prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] #take advantage of -1 indexing\\n        # build prefix sum matrix, keeping track of the sum above and left of each index\\n        for row in range(rows):\\n            sum_left = 0\\n            for col in range(cols):\\n                sum_above = prefix_sum[row - 1][col]\\n                sum_left += matrix[row][col]\\n                prefix_sum[row][col] = sum_above + sum_left\\n                \\n        # fix start and end row, and for each traverse across the columns\\n        max_sum_lk = float(\\'-inf\\')\\n        for row1 in range(rows):\\n            for row2 in range(row1, rows):\\n                left_sums = [0]\\n                # binary search for a sum to the left that is as small as possible (because we are subtracting it),\\n                # such that the cumulative sum across all these columns minus that left sum is <= k\\n                for end_col in range(cols):\\n                    sum_here = prefix_sum[row2][end_col] - prefix_sum[row1 - 1][end_col]\\n                    \\n                    ins = bisect_right(left_sums, sum_here - k)\\n                    if ins > 0 and left_sums[ins - 1] == sum_here - k:\\n                        return k\\n                    elif ins <= end_col:\\n                        max_sum_lk = max(max_sum_lk, sum_here - left_sums[ins])\\n                        \\n                    insort(left_sums, sum_here)\\n\\n        return max_sum_lk",
                "codeTag": "Java"
            },
            {
                "id": 2490476,
                "title": "sliding-window-kadane-faster-than-88-c",
                "content": "Time Complexity: O(m^2 nlog(n))\\nSpace Complexity: O(n)\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MIN;\\n        for (int left = 0; left<m; left++){\\n            vector<int> col(n, 0);\\n            for(int right = left; right<m; right++){\\n                // Apply Kadane Algorithm\\n                int best = INT_MIN;\\n                int curr = 0;\\n                for(int i=0; i<n; i++){\\n                    col[i] += matrix[right][i];\\n                    curr += col[i];\\n                    if (curr == k){\\n                        return k;\\n                    }\\n                    best = max(best, curr);\\n                    if (curr<0){\\n                        curr = 0;\\n                    }\\n                }\\n                if (best<k){\\n                    ans = max(ans, best);\\n                    continue;\\n                }\\n                // If not find from kadane algorithm i.e. k is less than 0\\n                set<int> s;\\n                s.insert(0);\\n                curr = 0;\\n                for(int i=0; i<n; i++){\\n                    curr += col[i];\\n                    auto it = s.lower_bound(curr - k);\\n                    if (it != s.end()){\\n                        ans = max(ans, curr-*it);\\n                    }\\n                    s.insert(curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MIN;\\n        for (int left = 0; left<m; left++){\\n            vector<int> col(n, 0);\\n            for(int right = left; right<m; right++){\\n                // Apply Kadane Algorithm\\n                int best = INT_MIN;\\n                int curr = 0;\\n                for(int i=0; i<n; i++){\\n                    col[i] += matrix[right][i];\\n                    curr += col[i];\\n                    if (curr == k){\\n                        return k;\\n                    }\\n                    best = max(best, curr);\\n                    if (curr<0){\\n                        curr = 0;\\n                    }\\n                }\\n                if (best<k){\\n                    ans = max(ans, best);\\n                    continue;\\n                }\\n                // If not find from kadane algorithm i.e. k is less than 0\\n                set<int> s;\\n                s.insert(0);\\n                curr = 0;\\n                for(int i=0; i<n; i++){\\n                    curr += col[i];\\n                    auto it = s.lower_bound(curr - k);\\n                    if (it != s.end()){\\n                        ans = max(ans, curr-*it);\\n                    }\\n                    s.insert(curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490017,
                "title": "java-solution-not-that-easy-dry-run-the-code-you-ll-get-it-for-sure-d",
                "content": "### Please Upvote !!!\\n```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        int rows = matrix.length, cols = matrix[0].length;\\n\\n        for (int left = 0; left < cols; left++) {\\n            int[] sum = new int[rows];\\n\\n            for (int right = left; right < cols; right++) {\\n                for (int i = 0; i < rows; i++) {\\n                    sum[i] += matrix[i][right];\\n                }\\n                result = Math.max(result, validSum(sum, k));\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    int validSum(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            int sum = 0;\\n\\n            for (int j = i; j < arr.length; j++) {\\n                sum += arr[j];\\n                if (sum <= k) max = Math.max(max, sum);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n/*\\n\\nTC:\\n\\nm = rows size\\nm = col size\\n\\nInside Helper :\\n-> n + (n-1) + (n-2) + ... + 1 = O(n^2)\\n\\nMain code :\\n-> m + (m-1) + (m-2) + ... + 1 = O(m^2)\\nAnd we are running m times for each loop\\n-> O(m^2 * n)\\n\\nAnd Helper also we are running for all O(n^2) times\\nSo, O(m^2 * n + m^2 * n^2) will be time complexity\\nTherefore, roughly \\'O(m^2 * n^2)\\'\\n\\n\\n\\nSC: O(m)\\nm -> Number of rows\\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        int rows = matrix.length, cols = matrix[0].length;\\n\\n        for (int left = 0; left < cols; left++) {\\n            int[] sum = new int[rows];\\n\\n            for (int right = left; right < cols; right++) {\\n                for (int i = 0; i < rows; i++) {\\n                    sum[i] += matrix[i][right];\\n                }\\n                result = Math.max(result, validSum(sum, k));\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    int validSum(int[] arr, int k) {\\n        int max = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            int sum = 0;\\n\\n            for (int j = i; j < arr.length; j++) {\\n                sum += arr[j];\\n                if (sum <= k) max = Math.max(max, sum);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n/*\\n\\nTC:\\n\\nm = rows size\\nm = col size\\n\\nInside Helper :\\n-> n + (n-1) + (n-2) + ... + 1 = O(n^2)\\n\\nMain code :\\n-> m + (m-1) + (m-2) + ... + 1 = O(m^2)\\nAnd we are running m times for each loop\\n-> O(m^2 * n)\\n\\nAnd Helper also we are running for all O(n^2) times\\nSo, O(m^2 * n + m^2 * n^2) will be time complexity\\nTherefore, roughly \\'O(m^2 * n^2)\\'\\n\\n\\n\\nSC: O(m)\\nm -> Number of rows\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490003,
                "title": "java-code-with-explanation",
                "content": "**Explanation to the solution** Feel free to ask doubts\\n\\nGiven m*n matrix and an integer k\\nso we will start with columns and find the maximum sum of that column taking care that sum<=k(we can do this using Kadane algorithm)\\nand this process will be followed for all the rows i.e for(row=0 to row<row.count) and for each row we will iterate through all the columns ie. for(col=0 to col<col.count)\\nwe will create an array for each row and will store the sum of each column in it one by one i.e., col++\\nand with this array we will find the max sum as long as it is less than equal to k\\nDry run it once for urself\\n**upvote if it helped**\\n\\n----------------------------------code------------------------------------------------------\\nclass Solution {\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\nint n=matrix.length;\\nint m=matrix[0].length;\\nint max=Integer.MIN_VALUE;\\nfor(int row=0;row<n;row++)\\n{\\nint arr[]=new int[m];\\nfor(int col=row;col<n;col++)\\n{\\nfor(int x=0;x<m;x++)\\narr[x]+=matrix[col][x];\\n\\n            int sum=kadaneHelper(arr,k);\\n            max=Math.max(max,sum);\\n        }\\n    }\\n    return max;\\n}\\n\\npublic int kadaneHelper(int arr[],int k)\\n{\\n    int res=Integer.MIN_VALUE;\\n    \\n    for(int i=0;i<arr.length;i++)\\n    {\\n        int sum=0;\\n        for(int j=i;j<arr.length;j++)\\n        {\\n            sum+=arr[j];\\n            if(sum<=k)\\n            res=Math.max(res,sum);\\n        }\\n    }\\n    return res;\\n}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\npublic int maxSumSubmatrix(int[][] matrix, int k) {\\nint n=matrix.length;\\nint m=matrix[0].length;\\nint max=Integer.MIN_VALUE;\\nfor(int row=0;row<n;row++)\\n{\\nint arr[]=new int[m];\\nfor(int col=row;col<n;col++)\\n{\\nfor(int x=0;x<m;x++)\\narr[x]+=matrix[col][x];\\n\\n            int sum=kadaneHelper(arr,k);\\n            max=Math.max(max,sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2489863,
                "title": "c-naive-faster-than-100-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        for(int i = 0;i < m;++i)\\n            for(int j = 1;j < n;++j)\\n                matrix[i][j] += matrix[i][j-1];\\n        int prefix[n+1];\\n        int ans = INT_MIN;\\n        for(int up = 0;up < m;++up){\\n            memset(prefix, 0, sizeof(prefix));\\n            for(int down = up;down < m;++down){\\n                for(int j = 1;j <= n;++j){\\n                    prefix[j] += matrix[down][j-1];\\n                    for(int col = 0;col < j;++col)\\n                        if((prefix[j] - prefix[col]) > ans && (prefix[j] - prefix[col]) <= k)\\n                            ans = prefix[j] - prefix[col];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime Complexity : O((mn)^2)\\nSpace Complexity : O(n)",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        for(int i = 0;i < m;++i)\\n            for(int j = 1;j < n;++j)\\n                matrix[i][j] += matrix[i][j-1];\\n        int prefix[n+1];\\n        int ans = INT_MIN;\\n        for(int up = 0;up < m;++up){\\n            memset(prefix, 0, sizeof(prefix));\\n            for(int down = up;down < m;++down){\\n                for(int j = 1;j <= n;++j){\\n                    prefix[j] += matrix[down][j-1];\\n                    for(int col = 0;col < j;++col)\\n                        if((prefix[j] - prefix[col]) > ans && (prefix[j] - prefix[col]) <= k)\\n                            ans = prefix[j] - prefix[col];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489831,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        int ans=INT_MIN;    \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>> pre=mat;\\n        for(int col=0;col<m;col++){\\n            for(int row=1;row<n;row++){\\n                pre[row][col]+=pre[row-1][col];\\n            }\\n        }\\n        for(int col=0;col<m;col++){\\n            vector<int> temp(n);\\n            for(int c=col;c<m;c++){\\n                set<int> s; s.insert(0);\\n                for(int r=0;r<n;r++){\\n                    if(c==col){\\n                        temp[r]=pre[r][c];\\n                    }\\n                    else{\\n                        temp[r]+=pre[r][c];\\n                    } \\n                    auto itr=s.lower_bound(temp[r]-k);\\n                    if(itr!=s.end()) ans=max(ans,temp[r]-(*itr)); \\n                    s.insert(temp[r]);\\n                }\\n            }            \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        int ans=INT_MIN;    \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>> pre=mat;\\n        for(int col=0;col<m;col++){\\n            for(int row=1;row<n;row++){\\n                pre[row][col]+=pre[row-1][col];\\n            }\\n        }\\n        for(int col=0;col<m;col++){\\n            vector<int> temp(n);\\n            for(int c=col;c<m;c++){\\n                set<int> s; s.insert(0);\\n                for(int r=0;r<n;r++){\\n                    if(c==col){\\n                        temp[r]=pre[r][c];\\n                    }\\n                    else{\\n                        temp[r]+=pre[r][c];\\n                    } \\n                    auto itr=s.lower_bound(temp[r]-k);\\n                    if(itr!=s.end()) ans=max(ans,temp[r]-(*itr)); \\n                    s.insert(temp[r]);\\n                }\\n            }            \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489824,
                "title": "daily-leetcode-challenge-august-27",
                "content": "class Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int t) {\\n       int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int l=i+1;l<=m;l++){\\n                for(int j=0;j<n;j++){\\n                    int val=0;\\n                    for(int k=j;k<n;k++){\\n                        val+=dp[l][k]-dp[i][k];\\n                        \\n                        if(val<t){\\n                            ans=max(ans,val);\\n                        }\\n                        else if(val==t){\\n                            return t;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n ****please upvote if u found this code useful****",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int t) {\\n       int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>>dp(m+1,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j]=dp[i][j]+matrix[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2489544,
                "title": "swift-solution-using-subsums",
                "content": "```\\nclass Solution {\\n    func maxSumSubmatrix(_ matrix: [[Int]], _ k: Int) -> Int {\\n        var subSums: [[Int]] = .init(repeating: .init(repeating: 0, count: matrix[0].count + 1), count: matrix.count + 1)\\n        var res = Int.min\\n        for y in 1...matrix.count {\\n            for x in 1...matrix[0].count {\\n                subSums[y][x] = matrix[y - 1][x - 1]\\n                subSums[y][x] += subSums[y - 1][x]\\n                subSums[y][x] += subSums[y][x - 1]\\n                subSums[y][x] -= subSums[y - 1][x - 1]\\n            }\\n        }\\n        for y in 0...matrix.count {\\n            for x in 0...matrix[0].count {\\n                for g in 0..<y {\\n                    for h in 0..<x {\\n                        let temp = subSums[y][x] - (subSums[y][h] + subSums[g][x] - subSums[g][h])\\n                        if temp <= k {\\n                            res = max(res, temp)\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxSumSubmatrix(_ matrix: [[Int]], _ k: Int) -> Int {\\n        var subSums: [[Int]] = .init(repeating: .init(repeating: 0, count: matrix[0].count + 1), count: matrix.count + 1)\\n        var res = Int.min\\n        for y in 1...matrix.count {\\n            for x in 1...matrix[0].count {\\n                subSums[y][x] = matrix[y - 1][x - 1]\\n                subSums[y][x] += subSums[y - 1][x]\\n                subSums[y][x] += subSums[y][x - 1]\\n                subSums[y][x] -= subSums[y - 1][x - 1]\\n            }\\n        }\\n        for y in 0...matrix.count {\\n            for x in 0...matrix[0].count {\\n                for g in 0..<y {\\n                    for h in 0..<x {\\n                        let temp = subSums[y][x] - (subSums[y][h] + subSums[g][x] - subSums[g][h])\\n                        if temp <= k {\\n                            res = max(res, temp)\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488541,
                "title": "python-3-built-in-function-necessary",
                "content": "I took the standard-solution approach. However I found the usage of the built-in `bisect_left` function seem to be necessary to pass the tests. I tried replacing `bisect_left` with a standard binary search implementation (`i` `j` pointers) and it got TLE. Doing it by hand is a lot slower than using built-ins I guess... \\n\\n```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n\\t\\t# Function to find the subarray sum that is closest to U in the given 1-D array \"psr\"\\n        def maxSumSubarray(psr, U: int) -> int:\\n            ss, ans = SortedSet([0]), -999999\\n            for c in range(n):\\n                diff = psr[c] - U\\n                if diff == 0: return U\\n                idx = ss.bisect_left(diff)\\n                if idx < len(ss): ans = max(ans, psr[c]-ss[idx])\\n                ss.add(psr[c])\\n            return ans\\n        \\n        res = -999999\\n        \\n        # construct row-wise prefix sum matrix\\n        ps = [[] for x in range(m)]\\n        for r in range(m):\\n            ps[r].append(matrix[r][0])\\n            for c in range(1, n):\\n                ps[r].append(ps[r][-1]+matrix[r][c])\\n        \\n\\t\\t# Run over merged rows\\n        for router in range(m):\\n            psr = [0 for x in range(n)]\\n            for rinner in range(router, m):\\n                psr = [ x+y for x, y in zip(psr, ps[rinner]) ]  \\n                res = max(maxSumSubarray(psr, k), res)\\n                if res == k: return k\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n\\t\\t# Function to find the subarray sum that is closest to U in the given 1-D array \"psr\"\\n        def maxSumSubarray(psr, U: int) -> int:\\n            ss, ans = SortedSet([0]), -999999\\n            for c in range(n):\\n                diff = psr[c] - U\\n                if diff == 0: return U\\n                idx = ss.bisect_left(diff)\\n                if idx < len(ss): ans = max(ans, psr[c]-ss[idx])\\n                ss.add(psr[c])\\n            return ans\\n        \\n        res = -999999\\n        \\n        # construct row-wise prefix sum matrix\\n        ps = [[] for x in range(m)]\\n        for r in range(m):\\n            ps[r].append(matrix[r][0])\\n            for c in range(1, n):\\n                ps[r].append(ps[r][-1]+matrix[r][c])\\n        \\n\\t\\t# Run over merged rows\\n        for router in range(m):\\n            psr = [0 for x in range(n)]\\n            for rinner in range(router, m):\\n                psr = [ x+y for x, y in zip(psr, ps[rinner]) ]  \\n                res = max(maxSumSubarray(psr, k), res)\\n                if res == k: return k\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488474,
                "title": "c",
                "content": "```\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int target) {       \\n        int ans = INT_MIN;\\n        \\n        vector<vector<int>> col_prefix(matrix.size() + 1, vector<int>(matrix[0].size(), 0));\\n        for (int i = 0; i < col_prefix[0].size(); ++ i){\\n            for (int j = 1; j < col_prefix.size(); ++ j){\\n                col_prefix[j][i] = col_prefix[j - 1][i] + matrix[j - 1][i];\\n            }\\n        }\\n        for (int i = 0; i < col_prefix.size(); ++ i){\\n            for (int j = i + 1; j < col_prefix.size(); ++ j){\\n                set<int> use;\\n                int accumulate = 0;\\n                use.insert(accumulate);\\n                \\n                for (int k = 0; k < col_prefix[0].size(); ++ k){\\n                    accumulate += col_prefix[j][k] - col_prefix[i][k];\\n                    \\n                    auto get = use.lower_bound(accumulate - target);\\n                    if (get != use.end()){\\n                        ans = max(ans, accumulate - *get);\\n                    }\\n                    \\n                    use.insert(accumulate);\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int target) {       \\n        int ans = INT_MIN;\\n        \\n        vector<vector<int>> col_prefix(matrix.size() + 1, vector<int>(matrix[0].size(), 0));\\n        for (int i = 0; i < col_prefix[0].size(); ++ i){\\n            for (int j = 1; j < col_prefix.size(); ++ j){\\n                col_prefix[j][i] = col_prefix[j - 1][i] + matrix[j - 1][i];\\n            }\\n        }\\n        for (int i = 0; i < col_prefix.size(); ++ i){\\n            for (int j = i + 1; j < col_prefix.size(); ++ j){\\n                set<int> use;\\n                int accumulate = 0;\\n                use.insert(accumulate);\\n                \\n                for (int k = 0; k < col_prefix[0].size(); ++ k){\\n                    accumulate += col_prefix[j][k] - col_prefix[i][k];\\n                    \\n                    auto get = use.lower_bound(accumulate - target);\\n                    if (get != use.end()){\\n                        ans = max(ans, accumulate - *get);\\n                    }\\n                    \\n                    use.insert(accumulate);\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488372,
                "title": "c-prefix-sum-faster",
                "content": "```\\nclass Solution {\\n   public:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        int ans = INT_MIN;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                dp[i][j] = dp[i][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n\\n        for (int c1 = 1; c1 <= m; c1++) {\\n            for (int c2 = c1; c2 <= m; c2++) {\\n                vector<int> arr(n + 1);\\n                for (int i = 1; i <= n; i++) {\\n                    arr[i] = arr[i - 1] + dp[i][c2] - dp[i][c1 - 1];\\n                }\\n\\n                for (int r1 = 1; r1 <= n; r1++) {\\n                    for (int r2 = r1; r2 <= n; r2++) {\\n                        if (arr[r2] - arr[r1 - 1] <= k) {\\n                            ans = max(ans, arr[r2] - arr[r1 - 1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        int ans = INT_MIN;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                dp[i][j] = dp[i][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n\\n        for (int c1 = 1; c1 <= m; c1++) {\\n            for (int c2 = c1; c2 <= m; c2++) {\\n                vector<int> arr(n + 1);\\n                for (int i = 1; i <= n; i++) {\\n                    arr[i] = arr[i - 1] + dp[i][c2] - dp[i][c1 - 1];\\n                }\\n\\n                for (int r1 = 1; r1 <= n; r1++) {\\n                    for (int r2 = r1; r2 <= n; r2++) {\\n                        if (arr[r2] - arr[r1 - 1] <= k) {\\n                            ans = max(ans, arr[r2] - arr[r1 - 1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488351,
                "title": "java-solution-faster-than-98",
                "content": "\\n```\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        for (int i = 0; i < m; i++ ) {\\n            for (int j = 0; j < n; j++) {\\n                for (int a = i + 1; a <= m; a++) {\\n                    for (int b = j + 1; b <= n; b++) {\\n                        int tmp = dp[a][b] - dp[a][j] - dp[i][b] + dp[i][j];\\n                        if (tmp <= k) {\\n                            if (tmp == k) {\\n                                return k;\\n                            }\\n                            result = Math.max(result, tmp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        for (int i = 0; i < m; i++ ) {\\n            for (int j = 0; j < n; j++) {\\n                for (int a = i + 1; a <= m; a++) {\\n                    for (int b = j + 1; b <= n; b++) {\\n                        int tmp = dp[a][b] - dp[a][j] - dp[i][b] + dp[i][j];\\n                        if (tmp <= k) {\\n                            if (tmp == k) {\\n                                return k;\\n                            }\\n                            result = Math.max(result, tmp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488332,
                "title": "simple-c-solution-easy-understand-brute-force-enumeration-prefix-sum-binary-search",
                "content": "(brute force enumeration + prefix sum + binary search) O(n^2mlogm)\\nConvert the problem into a one-dimensional problem. The enumeration lo and hi represent the column interval of the currently processed data. For each column interval, it can be regarded as a one-dimensional problem.\\nOne-dimensional problems can be solved in O(mlogm) time using prefix sum with binary search. Maintains an ordered collection with 0 initially placed in the collection. Each time the prefix sum of the current position is obtained, the first number greater than or equal to sum - k is binary searched in the set, and if it can be found, the answer is updated. Then put the prefix sum of the current position into an ordered set.\\ntime complexity\\nThere are n^2 column intervals in total, and the time to solve each one-dimensional problem is O(mlogm).\\nSo the total time complexity is O(n^2mlogm).\\nspace complexity\\nAdditional O(m) space is required to record the sum of each row under the current column interval.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans = INT_MIN;\\n\\n        for (int lo = 0; lo < n; lo++) {\\n            vector<int> row(m, 0);\\n            for (int hi = lo; hi < n; hi++) {\\n                set<int> pre;\\n                int sum = 0;\\n\\n                pre.insert(0);\\n                for (int i = 0; i < m; i++) {\\n                    row[i] += matrix[i][hi];\\n                    sum += row[i];\\n                    auto it = pre.lower_bound(sum - k);\\n                    if (it != pre.end())\\n                        ans = max(ans, sum - *it);\\n                    pre.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Enumeration",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans = INT_MIN;\\n\\n        for (int lo = 0; lo < n; lo++) {\\n            vector<int> row(m, 0);\\n            for (int hi = lo; hi < n; hi++) {\\n                set<int> pre;\\n                int sum = 0;\\n\\n                pre.insert(0);\\n                for (int i = 0; i < m; i++) {\\n                    row[i] += matrix[i][hi];\\n                    sum += row[i];\\n                    auto it = pre.lower_bound(sum - k);\\n                    if (it != pre.end())\\n                        ans = max(ans, sum - *it);\\n                    pre.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488296,
                "title": "java-brute-force-o-n-4-prefix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] grid, int k) \\n    {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int a[]=new int[m];\\n            for(int j=i;j<n;j++)\\n            {\\n                for(int x=0;x<m;x++)\\n                a[x]+=grid[j][x];\\n                \\n                int sum=helper(a,k);\\n                max=Math.max(max,sum);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int helper(int a[],int k)\\n    {\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            int s=0;\\n            for(int j=i;j<a.length;j++)\\n            {\\n                s+=a[j];\\n                if(s<=k)\\n                ans=Math.max(ans,s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] grid, int k) \\n    {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int a[]=new int[m];\\n            for(int j=i;j<n;j++)\\n            {\\n                for(int x=0;x<m;x++)\\n                a[x]+=grid[j][x];\\n                \\n                int sum=helper(a,k);\\n                max=Math.max(max,sum);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int helper(int a[],int k)\\n    {\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            int s=0;\\n            for(int j=i;j<a.length;j++)\\n            {\\n                s+=a[j];\\n                if(s<=k)\\n                ans=Math.max(ans,s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488291,
                "title": "c-prefix-sum-for-2d-array-simple-solution",
                "content": "```\\ntypedef int ll;\\nclass Solution {\\npublic:\\n    ll dp[105][105];\\n \\n    ll get(ll x1,ll y1,ll x2,ll y2){\\n        return dp[x2+1][y2+1] - dp[x1][y2+1] - dp[x2+1][y1] + dp[x1][y1];\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& arr, int ch) {\\n        ll n = arr.size(),m = arr[0].size();\\n        for(ll i = 0;i <= n;i++){\\n            for(ll j = 0;j <= m;j++){\\n                dp[i][j] = 0;\\n            }\\n        }\\n        for(ll i = 1;i <= n;i++){\\n            for(ll j = 1;j <= m;j++){\\n                dp[i][j] = arr[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\\n            }\\n        }\\n        ll ans = -INT_MAX;\\n        for(ll i = 0;i < n;i++){\\n            for(ll j = 0;j < m;j++){\\n                for(ll k = i;k < n;k++){\\n                    for(ll l = j;l < m;l++){\\n                        \\n                        ll temp = get(i, j, k, l);\\n                        if(temp > ans && temp <= ch)\\n                            ans = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef int ll;\\nclass Solution {\\npublic:\\n    ll dp[105][105];\\n \\n    ll get(ll x1,ll y1,ll x2,ll y2){\\n        return dp[x2+1][y2+1] - dp[x1][y2+1] - dp[x2+1][y1] + dp[x1][y1];\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& arr, int ch) {\\n        ll n = arr.size(),m = arr[0].size();\\n        for(ll i = 0;i <= n;i++){\\n            for(ll j = 0;j <= m;j++){\\n                dp[i][j] = 0;\\n            }\\n        }\\n        for(ll i = 1;i <= n;i++){\\n            for(ll j = 1;j <= m;j++){\\n                dp[i][j] = arr[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\\n            }\\n        }\\n        ll ans = -INT_MAX;\\n        for(ll i = 0;i < n;i++){\\n            for(ll j = 0;j < m;j++){\\n                for(ll k = i;k < n;k++){\\n                    for(ll l = j;l < m;l++){\\n                        \\n                        ll temp = get(i, j, k, l);\\n                        if(temp > ans && temp <= ch)\\n                            ans = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485686,
                "title": "c-90-speed-1100-ms-99-space-for-loop",
                "content": "So this problem is an inclusion exclusion principle problem.\\n\\nAs it turns out this problem can be solved in O(n^2 m^2)  time where n is the length and m is the width of your array.\\n\\nFirst you make a DP  of size n x m  where DP[i][j] holds the area of the rectangle starting at coordinate (0,0) and ending at coordinate (i,j)\\n\\nReally this is all the information you need to calculate any rectangle in your matrix\\n\\nSay we wish to find the area of the rectangle with upper left hand coordinate  (x1, y1) and lower right hand coordinate (x2,y2).\\n\\nOf course x1<=x2  and y1<=y2\\n\\nObviously this box is inside DP[x2][y2]  so what we do next is slice off everything that is not inside our box\\n\\nYou can cut Box DP[x2][y2] into four pieces to get your rectangle with corners (x1,y1) , (x2,y2)\\n\\nNamely it is as follows DP[x2][y2] - DP[x1-1][y2] - DP[x2][y1-1] + DP[x1-1][y1-1]\\n\\nWe cut out the rectangles DP[x2][y1-1] and DP[x1-1][y2] BUT we should note we cut out the rectangle \\nDP[x1-1][y1-1] one too many times so we add it back in.\\n\\nSo in effect you can do this trick and run over all quadruplets (x1,y1)  (x2,y2)\\n\\nOf course as was said earlier this is O(n^2 m^2)  time constraints.\\n\\nThe Code is Below:      Thank You!   =]\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& M, int k) {\\n       \\n        \\n        int n=M.size(), m=M[0].size();\\n        int DP[n][m];\\n        memset(DP,0,sizeof(DP));\\n        \\n        DP[0][0]=M[0][0];\\n        \\n        for(int i=1;i<m;i++) DP[0][i]=DP[0][i-1] + M[0][i];\\n        for(int i=1;i<n;i++) DP[i][0]=DP[i-1][0] + M[i][0];\\n        \\n        for(int i=1;i<n;i++)\\n            for(int j=1;j<m;j++)\\n            {\\n                DP[i][j]=DP[i-1][j]+DP[i][j-1]-DP[i-1][j-1] + M[i][j];\\n            }\\n        \\n        int ret=INT_MIN, cur;\\n        \\n        int M1, M2, M3, M4;\\n        \\n        for(int x1=0;x1<n;x1++)\\n            for(int x2=x1;x2<n;x2++)\\n                for(int y1=0;y1<m;y1++)\\n                    for(int y2=y1;y2<m;y2++)\\n                    {\\n                        M1=0; M2=0; M3=0; M4=0;\\n                        \\n                        if(x1>0&&y1>0) M1=DP[x1-1][y1-1];\\n                        if(x1>0) M2=DP[x1-1][y2];\\n                        if(y1>0) M3=DP[x2][y1-1];\\n                        \\n                        M4=DP[x2][y2];\\n                        \\n                         cur=M4-M3-M2+M1;\\n               \\n                         if(cur<=k) ret=max(ret,cur);\\n                        \\n                        \\n                    } \\n        return(ret);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& M, int k) {\\n       \\n        \\n        int n=M.size(), m=M[0].size();\\n        int DP[n][m];\\n        memset(DP,0,sizeof(DP));\\n        \\n        DP[0][0]=M[0][0];\\n        \\n        for(int i=1;i<m;i++) DP[0][i]=DP[0][i-1] + M[0][i];\\n        for(int i=1;i<n;i++) DP[i][0]=DP[i-1][0] + M[i][0];\\n        \\n        for(int i=1;i<n;i++)\\n            for(int j=1;j<m;j++)\\n            {\\n                DP[i][j]=DP[i-1][j]+DP[i][j-1]-DP[i-1][j-1] + M[i][j];\\n            }\\n        \\n        int ret=INT_MIN, cur;\\n        \\n        int M1, M2, M3, M4;\\n        \\n        for(int x1=0;x1<n;x1++)\\n            for(int x2=x1;x2<n;x2++)\\n                for(int y1=0;y1<m;y1++)\\n                    for(int y2=y1;y2<m;y2++)\\n                    {\\n                        M1=0; M2=0; M3=0; M4=0;\\n                        \\n                        if(x1>0&&y1>0) M1=DP[x1-1][y1-1];\\n                        if(x1>0) M2=DP[x1-1][y2];\\n                        if(y1>0) M3=DP[x2][y1-1];\\n                        \\n                        M4=DP[x2][y2];\\n                        \\n                         cur=M4-M3-M2+M1;\\n               \\n                         if(cur<=k) ret=max(ret,cur);\\n                        \\n                        \\n                    } \\n        return(ret);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379893,
                "title": "python-concise-bisect-solution",
                "content": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        prefix sum, bisect.\\n        T(n) = O(m^2n), S(n) = O(n).\\n        \"\"\"\\n        m, n = len(matrix), len(matrix[0])\\n        res = - 2**31\\n        for ii in range(m):\\n            sums = [0] * n\\n            for i in range(ii, m):\\n                sorted_ps, ps = [], 0\\n                for j in range(n):\\n                    sums[j] += matrix[i][j]\\n                    ps += sums[j]\\n                    if ps <= k:\\n                        res = max(res, ps)\\n                    index = bisect.bisect_left(sorted_ps, ps - k)\\n                    if index < len(sorted_ps):\\n                        res = max(res, ps - sorted_ps[index])\\n                    bisect.insort(sorted_ps, ps)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        prefix sum, bisect.\\n        T(n) = O(m^2n), S(n) = O(n).\\n        \"\"\"\\n        m, n = len(matrix), len(matrix[0])\\n        res = - 2**31\\n        for ii in range(m):\\n            sums = [0] * n\\n            for i in range(ii, m):\\n                sorted_ps, ps = [], 0\\n                for j in range(n):\\n                    sums[j] += matrix[i][j]\\n                    ps += sums[j]\\n                    if ps <= k:\\n                        res = max(res, ps)\\n                    index = bisect.bisect_left(sorted_ps, ps - k)\\n                    if index < len(sorted_ps):\\n                        res = max(res, ps - sorted_ps[index])\\n                    bisect.insort(sorted_ps, ps)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309175,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size(), res = INT32_MIN;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = i; j < n; j++) {\\n                vector<int> pref(m);\\n                for(int k = 0; k < m; k++) pref[k] = mat[k][j]-(i > 0? mat[k][i-1]:0);\\n                for(int k = 1; k < m; k++) pref[k] += pref[k-1];\\n                set<int> st;\\n                \\n                for(int l = -1; l < m; l++) {\\n                    int curr = l >= 0? pref[l]:0;\\n                    auto it = st.lower_bound(curr-k);\\n                    if(it != st.end()) {\\n                        res = max(res,curr-(*it));\\n                    }\\n                    st.insert(curr);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size(), res = INT32_MIN;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = i; j < n; j++) {\\n                vector<int> pref(m);\\n                for(int k = 0; k < m; k++) pref[k] = mat[k][j]-(i > 0? mat[k][i-1]:0);\\n                for(int k = 1; k < m; k++) pref[k] += pref[k-1];\\n                set<int> st;\\n                \\n                for(int l = -1; l < m; l++) {\\n                    int curr = l >= 0? pref[l]:0;\\n                    auto it = st.lower_bound(curr-k);\\n                    if(it != st.end()) {\\n                        res = max(res,curr-(*it));\\n                    }\\n                    st.insert(curr);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181397,
                "title": "c-easy-to-understand-intuitive",
                "content": "Key Point : Fix starting and ending columns between which our maximum sum sub-rectangle is present whose sum is less than or equal to k\\n```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=INT_MIN;\\n        for(int c1=0;c1<m;c1++){ \\n            vector<int> v(n,0);\\n            for(int c2=c1;c2<m;c2++){\\n                for(int i=0;i<n;i++){\\n                    v[i]+=matrix[i][c2];   // finding row-wise sum of the current sub-matrix\\n                }\\n                int sum=0;\\n                set<int> st;\\n                st.insert(0);\\n                for(int r=0;r<n;r++){     // finding maximum subarray sum less than k\\n                    sum+=v[r];\\n                    auto it=st.lower_bound(sum-k);\\n                    if(it!=st.end()){\\n                        ans=max(ans,sum-(*it));\\n                    }\\n                    st.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=INT_MIN;\\n        for(int c1=0;c1<m;c1++){ \\n            vector<int> v(n,0);\\n            for(int c2=c1;c2<m;c2++){\\n                for(int i=0;i<n;i++){\\n                    v[i]+=matrix[i][c2];   // finding row-wise sum of the current sub-matrix\\n                }\\n                int sum=0;\\n                set<int> st;\\n                st.insert(0);\\n                for(int r=0;r<n;r++){     // finding maximum subarray sum less than k\\n                    sum+=v[r];\\n                    auto it=st.lower_bound(sum-k);\\n                    if(it!=st.end()){\\n                        ans=max(ans,sum-(*it));\\n                    }\\n                    st.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126907,
                "title": "multiset-solution-faster-than-70",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++)\\n                matrix[i][j]+=matrix[i][j-1];\\n        }\\n        int ans=INT_MIN;\\n        for(int c1=0;c1<m;c1++){\\n            for(int c2=c1;c2<m;c2++){\\n                multiset<int> me;\\n                int sum=0;\\n                for(int row=0;row<n;row++){\\n                    sum+=matrix[row][c2]-(c1>0?matrix[row][c1-1]:0);\\n                    if(sum<=k) ans=max(sum,ans); \\n                    auto it=me.lower_bound(sum-k);\\n                    if(it!=me.end() and (sum-*it)<=k) ans=max(ans,sum-*it);\\n                    me.insert(sum);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++)\\n                matrix[i][j]+=matrix[i][j-1];\\n        }\\n        int ans=INT_MIN;\\n        for(int c1=0;c1<m;c1++){\\n            for(int c2=c1;c2<m;c2++){\\n                multiset<int> me;\\n                int sum=0;\\n                for(int row=0;row<n;row++){\\n                    sum+=matrix[row][c2]-(c1>0?matrix[row][c1-1]:0);\\n                    if(sum<=k) ans=max(sum,ans); \\n                    auto it=me.lower_bound(sum-k);\\n                    if(it!=me.end() and (sum-*it)<=k) ans=max(ans,sum-*it);\\n                    me.insert(sum);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070378,
                "title": "c-dp-72-faster-90-less-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int arr[101][101];\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        \\n        for(int i=1;i<=matrix.size();i++){\\n            for(int j=1;j<=matrix[0].size();j++){\\n                arr[i][j] = arr[i-1][j] + arr[i][j-1] - arr[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        int lmax = INT_MIN;\\n        for(int a=1;a<=matrix.size();a++){\\n            for(int b=1;b<=matrix[0].size();b++){\\n                for(int c=a;c<=matrix.size();c++){\\n                    for(int d=b;d<=matrix[0].size();d++){\\n                        int val = arr[c][d] - arr[c][b-1] - arr[a-1][d] + arr[a-1][b-1];\\n                        \\n                        if(val <= k){\\n                            \\n                            lmax = max(lmax, val);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return lmax;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int arr[101][101];\\n    \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        \\n        for(int i=1;i<=matrix.size();i++){\\n            for(int j=1;j<=matrix[0].size();j++){\\n                arr[i][j] = arr[i-1][j] + arr[i][j-1] - arr[i-1][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n        \\n        int lmax = INT_MIN;\\n        for(int a=1;a<=matrix.size();a++){\\n            for(int b=1;b<=matrix[0].size();b++){\\n                for(int c=a;c<=matrix.size();c++){\\n                    for(int d=b;d<=matrix[0].size();d++){\\n                        int val = arr[c][d] - arr[c][b-1] - arr[a-1][d] + arr[a-1][b-1];\\n                        \\n                        if(val <= k){\\n                            \\n                            lmax = max(lmax, val);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return lmax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776725,
                "title": "java-prefixsum-treemap",
                "content": "```\\nclass Solution {\\n    public int find(int sum[][],int p,int j,int k)\\n    {\\n        int max=-10000000,s=0;\\n        TreeMap<Integer,Integer>map=new TreeMap<Integer,Integer>();\\n        map.put(0,-1);\\n        for(int i=0;i<sum.length;i++)\\n        {\\n            s=s+sum[i][p]-sum[i][j+1];\\n            if(map.containsKey(s-k))\\n            {\\n                    return k;\\n            }\\n            if(map.higherKey(s-k)!=null)\\n            {\\n                int y=map.higherKey(s-k);\\n                max=Math.max(max,s-y);\\n            }\\n            map.put(s,i);\\n        }\\n        return max;\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int ans=-1000000;\\n        int sum[][]=new int[matrix.length][matrix[0].length+1];\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=matrix[0].length-1;j>=0;j--)\\n            {\\n                sum[i][j]=sum[i][j+1]+matrix[i][j];\\n            }\\n        }\\n        for(int j=matrix[0].length-1;j>=0;j--)\\n        {\\n            for(int p=j;p>=0;p--)\\n            {\\n                ans=Math.max(ans,find(sum,p,j,k));\\n                if(ans==k)\\n                    return k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int find(int sum[][],int p,int j,int k)\\n    {\\n        int max=-10000000,s=0;\\n        TreeMap<Integer,Integer>map=new TreeMap<Integer,Integer>();\\n        map.put(0,-1);\\n        for(int i=0;i<sum.length;i++)\\n        {\\n            s=s+sum[i][p]-sum[i][j+1];\\n            if(map.containsKey(s-k))\\n            {\\n                    return k;\\n            }\\n            if(map.higherKey(s-k)!=null)\\n            {\\n                int y=map.higherKey(s-k);\\n                max=Math.max(max,s-y);\\n            }\\n            map.put(s,i);\\n        }\\n        return max;\\n    }\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int ans=-1000000;\\n        int sum[][]=new int[matrix.length][matrix[0].length+1];\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=matrix[0].length-1;j>=0;j--)\\n            {\\n                sum[i][j]=sum[i][j+1]+matrix[i][j];\\n            }\\n        }\\n        for(int j=matrix[0].length-1;j>=0;j--)\\n        {\\n            for(int p=j;p>=0;p--)\\n            {\\n                ans=Math.max(ans,find(sum,p,j,k));\\n                if(ans==k)\\n                    return k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742951,
                "title": "c-simplified-set-kadane-running-sum-o-rows-log-rows-cols-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int K) {\\n        \\n        int num_rows = matrix.size(), num_cols = matrix[0].size();\\n        int ans = INT_MIN;\\n   \\n        for(int l=0;l<num_cols;l++){\\n            vector<int>row_sum(num_rows,0);\\n            for(int r=l;r<num_cols;r++){\\n                for(int k=0;k<num_rows;k++)\\n                    row_sum[k] += matrix[k][r];\\n                int sum = 0;\\n                set<int>s;\\n                s.insert(0);\\n                if(num_rows==1){\\n                    if(row_sum[0]<=K)\\n                        ans = max(ans,row_sum[0]);\\n                    continue;\\n                }\\n                for(int k=0;k<num_rows;k++){\\n                      sum+=row_sum[k];\\n                      auto it = (s.lower_bound((sum-K)));\\n                      if(it!=s.end()){\\n                          int x = *it;\\n                          ans = max(ans, sum-x);\\n                      }\\n                      s.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int K) {\\n        \\n        int num_rows = matrix.size(), num_cols = matrix[0].size();\\n        int ans = INT_MIN;\\n   \\n        for(int l=0;l<num_cols;l++){\\n            vector<int>row_sum(num_rows,0);\\n            for(int r=l;r<num_cols;r++){\\n                for(int k=0;k<num_rows;k++)\\n                    row_sum[k] += matrix[k][r];\\n                int sum = 0;\\n                set<int>s;\\n                s.insert(0);\\n                if(num_rows==1){\\n                    if(row_sum[0]<=K)\\n                        ans = max(ans,row_sum[0]);\\n                    continue;\\n                }\\n                for(int k=0;k<num_rows;k++){\\n                      sum+=row_sum[k];\\n                      auto it = (s.lower_bound((sum-K)));\\n                      if(it!=s.end()){\\n                          int x = *it;\\n                          ans = max(ans, sum-x);\\n                      }\\n                      s.insert(sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687900,
                "title": "python-3-100-time-96-memory-prefix-sum-bisect-left",
                "content": "![image](https://assets.leetcode.com/users/images/44d8fcc1-8a63-4a21-84d3-12b4f99092cf_1642093217.1059096.png)\\n\\nThe problem is quite similar to [1074. Number of Submatrices That Sum to Target](http://https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/). In 1074 we keep a rolling hash counter to look up for whether (cumulative_sum - target) exists in the hash. For this one, for each two columns 0 <= i <= j < n, we maintain a sorted list of cumulative sums from all previous rows 0 to r - 1. Arriving at row r, we calculate the cumulative_sum[r], and binary search for (cumulative_sum[r] - k) in the sorted list to find the best row x for calculating one candidate answer (cumulative_sum[r] - cumulative_sum[x]). (cumulative_sum[r] - cumulative_sum[x]) represents the submatrix sum inclusively from `matrix[x+1][i]` to `matrix[r][j]`.\\n\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n\\t\\t# prefix sum each row\\n        for row in matrix:\\n            for i in range(1, n):\\n                row[i] = row[i] + row[i-1]\\n            row.insert(0, 0)\\n        \\n        ans = -inf\\n        for i in range(n):\\n            for j in range(i, n):\\n                arr = [0] # init with a 0 in case cur_sum == k at a paricular row\\n                cur_sum = 0\\n                for r in range(m):\\n\\t\\t\\t\\t    cur_sum += matrix[r][j+1] - matrix[r][i] # submatrix sum row 0 to r\\n                    x = bisect_left(arr, cur_sum - k) # search for the best candidate from earlier rows\\n                    if x < len(arr):\\n                        if arr[x] == cur_sum - k:\\n                            return k\\n                        else:\\n                            ans = max(ans, cur_sum - arr[x])\\n                    insort(arr, cur_sum) # update sorted list of cumulative sums\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n\\t\\t# prefix sum each row\\n        for row in matrix:\\n            for i in range(1, n):\\n                row[i] = row[i] + row[i-1]\\n            row.insert(0, 0)\\n        \\n        ans = -inf\\n        for i in range(n):\\n            for j in range(i, n):\\n                arr = [0] # init with a 0 in case cur_sum == k at a paricular row\\n                cur_sum = 0\\n                for r in range(m):\\n\\t\\t\\t\\t    cur_sum += matrix[r][j+1] - matrix[r][i] # submatrix sum row 0 to r\\n                    x = bisect_left(arr, cur_sum - k) # search for the best candidate from earlier rows\\n                    if x < len(arr):\\n                        if arr[x] == cur_sum - k:\\n                            return k\\n                        else:\\n                            ans = max(ans, cur_sum - arr[x])\\n                    insort(arr, cur_sum) # update sorted list of cumulative sums\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430650,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n   int fun(vector<int> arr, int K)\\n   {\\n        int N=arr.size();\\n        set<int> cum_set;\\n        cum_set.insert(0);\\n\\n        int max_sum = INT_MIN, cSum = 0;\\n\\n        for (int i = 0; i < N; i++) {\\n            cSum += arr[i];\\n            set<int>::iterator sit= cum_set.lower_bound(cSum - K);\\n            if (sit != cum_set.end())\\n                max_sum = max(max_sum, cSum - *sit);\\n            cum_set.insert(cSum);\\n        }\\n        return max_sum;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<vector<int>> pre(r+1,vector<int>(c+1,0));\\n        \\n       for(int j=1;j<c+1;j++){\\n           for(int i=1;i<r+1;i++){\\n               pre[i][j]+=pre[i-1][j]+matrix[i-1][j-1];\\n           }\\n       }\\n        int ans=INT_MIN;\\n        for(int i=1;i<r+1;i++){\\n            for(int j=1;j<=r+1-i;j++){\\n                int cr=1;\\n                vector<int> v;\\n                while(cr<c+1){\\n                    v.push_back(pre[j+i-1][cr]-pre[j-1][cr]);\\n                   \\n                    cr++;\\n                }\\n                ans=max(ans,fun(v,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int fun(vector<int> arr, int K)\\n   {\\n        int N=arr.size();\\n        set<int> cum_set;\\n        cum_set.insert(0);\\n\\n        int max_sum = INT_MIN, cSum = 0;\\n\\n        for (int i = 0; i < N; i++) {\\n            cSum += arr[i];\\n            set<int>::iterator sit= cum_set.lower_bound(cSum - K);\\n            if (sit != cum_set.end())\\n                max_sum = max(max_sum, cSum - *sit);\\n            cum_set.insert(cSum);\\n        }\\n        return max_sum;\\n    }\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<vector<int>> pre(r+1,vector<int>(c+1,0));\\n        \\n       for(int j=1;j<c+1;j++){\\n           for(int i=1;i<r+1;i++){\\n               pre[i][j]+=pre[i-1][j]+matrix[i-1][j-1];\\n           }\\n       }\\n        int ans=INT_MIN;\\n        for(int i=1;i<r+1;i++){\\n            for(int j=1;j<=r+1-i;j++){\\n                int cr=1;\\n                vector<int> v;\\n                while(cr<c+1){\\n                    v.push_back(pre[j+i-1][cr]-pre[j-1][cr]);\\n                   \\n                    cr++;\\n                }\\n                ans=max(ans,fun(v,k));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401036,
                "title": "python-solution-using-bisect-module",
                "content": "here is the python solution using bisect module. Bisect module is used whenever we want to find the index (```index = bisect.bisect_left(a,x)```) in an list such that it bisects the list in two halfs, each element in left half is lesser than x and each element in right half is greater than or equal to x.\\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        r,c = len(matrix), len(matrix[0])\\n        ans = -math.inf\\n        for up in range(r):\\n            curr = [0]*c\\n            for down in range(up,r):\\n                curr = [curr[i]+matrix[down][i] for i in range(c)]\\n                seen = [0]\\n                sm = 0\\n                for i in range(c):\\n                    sm += curr[i]\\n                    ind = bisect.bisect_left(seen,sm-k)\\n                    if ind < len(seen) and sm-seen[ind] > ans:\\n                        ans = sm-seen[ind]\\n                    bisect.insort_right(seen,sm)\\n        return ans\\n\\t\\t```",
                "solutionTags": [],
                "code": "```index = bisect.bisect_left(a,x)```\n```\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\\n        r,c = len(matrix), len(matrix[0])\\n        ans = -math.inf\\n        for up in range(r):\\n            curr = [0]*c\\n            for down in range(up,r):\\n                curr = [curr[i]+matrix[down][i] for i in range(c)]\\n                seen = [0]\\n                sm = 0\\n                for i in range(c):\\n                    sm += curr[i]\\n                    ind = bisect.bisect_left(seen,sm-k)\\n                    if ind < len(seen) and sm-seen[ind] > ans:\\n                        ans = sm-seen[ind]\\n                    bisect.insort_right(seen,sm)\\n        return ans\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1365977,
                "title": "accepted-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int ki) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int[][] dp=new int[n+2][m+2];\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                dp[i][j]=dp[i][j-1]+dp[i-1][j]-dp[i-1][j-1]+matrix[i-1][j-1];\\n                if(matrix[i-1][j-1]<=ki)ans=Math.max(ans,matrix[i-1][j-1]);\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                for(int k=0;k<=n-i;k++){\\n                    for(int l=0;l<=m-j;l++){\\n                        int a=k+i;\\n                        int b=l+j;\\n                        int d=dp[a][b]-dp[a-i][b]-dp[a][b-j]+dp[a-i][b-j];\\n                        if(d<=ki)ans=Math.max(ans,d);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int ki) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int[][] dp=new int[n+2][m+2];\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                dp[i][j]=dp[i][j-1]+dp[i-1][j]-dp[i-1][j-1]+matrix[i-1][j-1];\\n                if(matrix[i-1][j-1]<=ki)ans=Math.max(ans,matrix[i-1][j-1]);\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                for(int k=0;k<=n-i;k++){\\n                    for(int l=0;l<=m-j;l++){\\n                        int a=k+i;\\n                        int b=l+j;\\n                        int d=dp[a][b]-dp[a-i][b]-dp[a][b-j]+dp[a-i][b-j];\\n                        if(d<=ki)ans=Math.max(ans,d);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343104,
                "title": "2d-kadane-prefix-sum-solution-c",
                "content": "```\\nclass Solution{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int sum[m][n], mx=INT_MIN;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                auto x = matrix[i][j];\\n                if(i>0 && j>0) x=x+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];\\n                else if(i>0 && j<=0) x=x+sum[i-1][j];\\n                else if(i<=0 && j>0) x=x+sum[i][j-1];\\n                sum[i][j]=x;\\n                for(int r=0;r<=i;r++)\\n                {\\n                    for(int c=0;c<=j;c++)\\n                    {\\n                        auto chk = sum[i][j];\\n                        if(r>0 && c>0) chk=chk-sum[r-1][j]-sum[i][c-1]+sum[r-1][c-1];\\n                        else if(r>0 && c<=0) chk=chk-sum[r-1][j];\\n                        else if(r<=0 && c>0) chk=chk-sum[i][c-1];\\n                        if(chk<=k) mx=max(mx,chk);\\n                    }\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\\n```\\nclass Solution{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int sum[m][n], res=INT_MIN;  \\n        vector<int> row(m, 0);\\n        for(int l=0;l<n;l++)\\n        {\\n            fill(row.begin(), row.end(), 0); //refill vector with 0 with every change in pointer \\'l\\'\\n            for(int r=l;r<n;r++)\\n            {\\n                int csum=0, mx=INT_MIN;\\n                for(int i=0;i<m;i++)\\n                {\\n                    row[i]+=matrix[i][r];\\n                    if(csum<0) csum = row[i];\\n                    else csum=csum+row[i];\\n                    mx=max(mx, csum);\\n                }\\n                if(mx<=k)\\n                {\\n                    res=max(res, mx); \\n                    continue;\\n                }\\n                set<int> s; //if maximum sum for a l is greater than k\\n                s.insert(0); \\n                csum=0;\\n                for(auto x: row)\\n                {\\n                    csum+=x;\\n                    auto f = s.lower_bound(csum-k); //find element which is equal to or just greater than difference between current sum and k\\n                    if(f!=s.end()) res=max(res, csum -*f);\\n                    s.insert(csum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int sum[m][n], mx=INT_MIN;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                auto x = matrix[i][j];\\n                if(i>0 && j>0) x=x+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];\\n                else if(i>0 && j<=0) x=x+sum[i-1][j];\\n                else if(i<=0 && j>0) x=x+sum[i][j-1];\\n                sum[i][j]=x;\\n                for(int r=0;r<=i;r++)\\n                {\\n                    for(int c=0;c<=j;c++)\\n                    {\\n                        auto chk = sum[i][j];\\n                        if(r>0 && c>0) chk=chk-sum[r-1][j]-sum[i][c-1]+sum[r-1][c-1];\\n                        else if(r>0 && c<=0) chk=chk-sum[r-1][j];\\n                        else if(r<=0 && c>0) chk=chk-sum[i][c-1];\\n                        if(chk<=k) mx=max(mx,chk);\\n                    }\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k)\\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int sum[m][n], res=INT_MIN;  \\n        vector<int> row(m, 0);\\n        for(int l=0;l<n;l++)\\n        {\\n            fill(row.begin(), row.end(), 0); //refill vector with 0 with every change in pointer \\'l\\'\\n            for(int r=l;r<n;r++)\\n            {\\n                int csum=0, mx=INT_MIN;\\n                for(int i=0;i<m;i++)\\n                {\\n                    row[i]+=matrix[i][r];\\n                    if(csum<0) csum = row[i];\\n                    else csum=csum+row[i];\\n                    mx=max(mx, csum);\\n                }\\n                if(mx<=k)\\n                {\\n                    res=max(res, mx); \\n                    continue;\\n                }\\n                set<int> s; //if maximum sum for a l is greater than k\\n                s.insert(0); \\n                csum=0;\\n                for(auto x: row)\\n                {\\n                    csum+=x;\\n                    auto f = s.lower_bound(csum-k); //find element which is equal to or just greater than difference between current sum and k\\n                    if(f!=s.end()) res=max(res, csum -*f);\\n                    s.insert(csum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320556,
                "title": "javascript-2-solutions-dp-binary-search",
                "content": "DP: 944ms\\n```\\nconst maxSumSubmatrix = (g, k) => {\\n    let [n, m, res] = [g.length, g[0].length, Number.MIN_SAFE_INTEGER];\\n    let dp = initialize2DArrayNew(n, m); // save 2D matrix pre sum\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            let sum = g[i][j];\\n            if (i > 0) sum += dp[i - 1][j];\\n            if (j > 0) sum += dp[i][j - 1];\\n            if (i > 0 && j > 0) sum -= dp[i - 1][j - 1];\\n            dp[i][j] = sum;\\n            for (let r = 0; r <= i; r++) { // subrectangles sum calculation\\n                for (let c = 0; c <= j; c++) {\\n                    let curSum = dp[i][j];\\n                    if (r > 0) curSum -= dp[r - 1][j];\\n                    if (c > 0) curSum -= dp[i][c - 1];\\n                    if (r > 0 && c > 0) curSum += dp[r - 1][c - 1];\\n                    if (curSum <= k) res = Math.max(res, curSum);\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\nconst initialize2DArrayNew = (n, m) => {\\n    let data = [];\\n    for (let i = 0; i < n; i++) {\\n        let tmp = Array(m).fill(0);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n```\\nbinary search with Treeset 792ms\\n```\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) {\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = lo + hi >> 1;\\n            x < a[mid] ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) {\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = lo + hi >> 1;\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction TreeSet(elements) {\\n    let ts = [];\\n    let se = new Set();\\n    let bisect = new Bisect();\\n    if (elements) addAll(elements);\\n    return { add, floor, ceiling, lower, remove, contains, size, clear, toArray };\\n    function addAll(elements) {\\n        for (const e of elements) {\\n            if (se.has(e)) continue;\\n            add(e);\\n            se.add(e);\\n        }\\n    }\\n    function add(e) {\\n        if (!se.has(e)) {\\n            bisect.insort_right(ts, e);\\n            se.add(e);\\n        }\\n    }\\n    function ceiling(e) {\\n        let idx = bisect.bisect_right(ts, e);\\n        if (ts[idx - 1] == e) return e;\\n        return ts[bisect.bisect_right(ts, e)];\\n    }\\n    function floor(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] == e) {\\n            return e;\\n        } else {\\n            return ts[bisect.bisect_left(ts, e) - 1];\\n        }\\n    }\\n    function lower(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] < e) {\\n            return ts[idx];\\n        } else {\\n            return ts[bisect.bisect_left(ts, e) - 1];\\n        }\\n    }\\n    function remove(e) {\\n        let res = new Set(ts);\\n        res.delete(e);\\n        ts = [...res];\\n        se.delete(e);\\n    }\\n    function contains(e) {\\n        return se.has(e);\\n    }\\n    function size() {\\n        return ts.length;\\n    }\\n    function clear() {\\n        ts = [];\\n    }\\n    function toArray() {\\n        return ts;\\n    }\\n}\\n\\nconst maxSumSubmatrix = (g, k) => {\\n    let [n, m, res] = [g.length, g[0].length, Number.MIN_SAFE_INTEGER];\\n    for (let i = 0; i < m; i++) {\\n        let sum = Array(n).fill(0);\\n        for (let j = i; j < m; j++) {\\n            for (let k = 0; k < n; k++) {\\n                sum[k] += g[k][j];\\n            }\\n            let curSum = 0;\\n            let ts = new TreeSet([0]);\\n            for (const x of sum) {\\n                curSum += x;\\n                let tmp = ts.ceiling(curSum - k); // java treeset ceiling, c++ set lower_bound\\n                if (tmp != undefined) res = Math.max(res, curSum - tmp);\\n                ts.add(curSum);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Tree",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nconst maxSumSubmatrix = (g, k) => {\\n    let [n, m, res] = [g.length, g[0].length, Number.MIN_SAFE_INTEGER];\\n    let dp = initialize2DArrayNew(n, m); // save 2D matrix pre sum\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            let sum = g[i][j];\\n            if (i > 0) sum += dp[i - 1][j];\\n            if (j > 0) sum += dp[i][j - 1];\\n            if (i > 0 && j > 0) sum -= dp[i - 1][j - 1];\\n            dp[i][j] = sum;\\n            for (let r = 0; r <= i; r++) { // subrectangles sum calculation\\n                for (let c = 0; c <= j; c++) {\\n                    let curSum = dp[i][j];\\n                    if (r > 0) curSum -= dp[r - 1][j];\\n                    if (c > 0) curSum -= dp[i][c - 1];\\n                    if (r > 0 && c > 0) curSum += dp[r - 1][c - 1];\\n                    if (curSum <= k) res = Math.max(res, curSum);\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\nconst initialize2DArrayNew = (n, m) => {\\n    let data = [];\\n    for (let i = 0; i < n; i++) {\\n        let tmp = Array(m).fill(0);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n```\n```\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) {\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = lo + hi >> 1;\\n            x < a[mid] ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) {\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = lo + hi >> 1;\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction TreeSet(elements) {\\n    let ts = [];\\n    let se = new Set();\\n    let bisect = new Bisect();\\n    if (elements) addAll(elements);\\n    return { add, floor, ceiling, lower, remove, contains, size, clear, toArray };\\n    function addAll(elements) {\\n        for (const e of elements) {\\n            if (se.has(e)) continue;\\n            add(e);\\n            se.add(e);\\n        }\\n    }\\n    function add(e) {\\n        if (!se.has(e)) {\\n            bisect.insort_right(ts, e);\\n            se.add(e);\\n        }\\n    }\\n    function ceiling(e) {\\n        let idx = bisect.bisect_right(ts, e);\\n        if (ts[idx - 1] == e) return e;\\n        return ts[bisect.bisect_right(ts, e)];\\n    }\\n    function floor(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] == e) {\\n            return e;\\n        } else {\\n            return ts[bisect.bisect_left(ts, e) - 1];\\n        }\\n    }\\n    function lower(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] < e) {\\n            return ts[idx];\\n        } else {\\n            return ts[bisect.bisect_left(ts, e) - 1];\\n        }\\n    }\\n    function remove(e) {\\n        let res = new Set(ts);\\n        res.delete(e);\\n        ts = [...res];\\n        se.delete(e);\\n    }\\n    function contains(e) {\\n        return se.has(e);\\n    }\\n    function size() {\\n        return ts.length;\\n    }\\n    function clear() {\\n        ts = [];\\n    }\\n    function toArray() {\\n        return ts;\\n    }\\n}\\n\\nconst maxSumSubmatrix = (g, k) => {\\n    let [n, m, res] = [g.length, g[0].length, Number.MIN_SAFE_INTEGER];\\n    for (let i = 0; i < m; i++) {\\n        let sum = Array(n).fill(0);\\n        for (let j = i; j < m; j++) {\\n            for (let k = 0; k < n; k++) {\\n                sum[k] += g[k][j];\\n            }\\n            let curSum = 0;\\n            let ts = new TreeSet([0]);\\n            for (const x of sum) {\\n                curSum += x;\\n                let tmp = ts.ceiling(curSum - k); // java treeset ceiling, c++ set lower_bound\\n                if (tmp != undefined) res = Math.max(res, curSum - tmp);\\n                ts.add(curSum);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1567964,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            },
            {
                "id": 1571637,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            },
            {
                "id": 1571636,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            },
            {
                "id": 1861282,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            },
            {
                "id": 1759629,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            },
            {
                "id": 1713297,
                "content": [
                    {
                        "username": "galster",
                        "content": "I solved this problem  in C++ just like most other people solved it here, except I started iterating over the rows and performing a one-dimensional binary search on sum of columns. I got a TLE. When I switched between the rows and columns the solution was accepted. This should not be the case. Either the algorithm enforces this on both the rows and columns or it doesnt enforce it at all."
                    },
                    {
                        "username": "FatShibaInu",
                        "content": "My submission failed at the following test case:\\nInput:\\n[[2,2,-1]]\\n2\\nOutput:\\n0\\nExpected:\\n2\\n\\nAs I see it, to make a rectangle with an area>0, the rectangle must have at least two rows and two columns, so this test case should return 0, because it's a straight line with area =0.\\n\\nIf a single element [2] means an area =0, which means as long as the rectangle has elements, its area is greater than 0, then what's the point saying \"The rectangle inside the matrix must have an area > 0\"?\\n\\nAm I misunderstanding something?"
                    },
                    {
                        "username": "Fengster",
                        "content": "So I think another condition that needs to be added is that there must exist a number no greater than k.\\nOtherwise, the only solution is empty matrix, however area must > 0.\\nConsider this test case: [[2]] 1\\nIt returns -2147483648 on mine because my max variable is default min value of Integer. It returns -1000000000 as the expected answer. (so problem creator used -1000000000 as default result? : ) )"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this one is like a sequel to https://leetcode.com/problems/range-sum-query-2d-immutable/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for additional tag: Merge Sort "
                    }
                ]
            }
        ]
    },
    {
        "title": "Swap Adjacent in LR String",
        "question_content": "<p>In a string composed of <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;X&#39;</code> characters, like <code>&quot;RXXLRXRXL&quot;</code>, a move consists of either replacing one occurrence of <code>&quot;XL&quot;</code> with <code>&quot;LX&quot;</code>, or replacing one occurrence of <code>&quot;RX&quot;</code> with <code>&quot;XR&quot;</code>. Given the starting string <code>start</code> and the ending string <code>end</code>, return <code>True</code> if and only if there exists a sequence of moves to transform one string to the other.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can transform start to end following these steps:\nRXXLRXRXL -&gt;\nXRXLRXRXL -&gt;\nXRLXRXRXL -&gt;\nXRLXXRRXL -&gt;\nXRLXXRRLX\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> start = &quot;X&quot;, end = &quot;L&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= start.length&nbsp;&lt;= 10<sup>4</sup></code></li>\n\t<li><code>start.length == end.length</code></li>\n\t<li>Both <code>start</code> and <code>end</code> will only consist of characters in <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and&nbsp;<code>&#39;X&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 113789,
                "title": "simple-java-one-pass-o-n-solution-with-explaination",
                "content": "The idea is simple. Just get the non-X characters and compare the positions of them.\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (!start.replace(\"X\", \"\").equals(end.replace(\"X\", \"\")))\\n            return false;\\n        \\n        int p1 = 0;\\n        int p2 = 0;\\n        \\n        while(p1 < start.length() && p2 < end.length()){\\n            \\n            // get the non-X positions of 2 strings\\n            while(p1 < start.length() && start.charAt(p1) == 'X'){\\n                p1++;\\n            }\\n            while(p2 < end.length() && end.charAt(p2) == 'X'){\\n                p2++;\\n            }\\n            \\n            //if both of the pointers reach the end the strings are transformable\\n            if(p1 == start.length() && p2 == end.length()){\\n                return true;\\n            }\\n            // if only one of the pointer reach the end they are not transformable\\n            if(p1 == start.length() || p2 == end.length()){\\n                return false;\\n            }\\n            \\n            if(start.charAt(p1) != end.charAt(p2)){\\n                return false;\\n            }\\n            // if the character is 'L', it can only be moved to the left. p1 should be greater or equal to p2.\\n            if(start.charAt(p1) == 'L' && p2 > p1){\\n                return false;\\n            }\\n            // if the character is 'R', it can only be moved to the right. p2 should be greater or equal to p1.\\n            if(start.charAt(p1) == 'R' && p1 > p2){\\n                return false;\\n            }\\n            p1++;\\n            p2++;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (!start.replace(\"X\", \"\").equals(end.replace(\"X\", \"\")))\\n            return false;\\n        \\n        int p1 = 0;\\n        int p2 = 0;\\n        \\n        while(p1 < start.length() && p2 < end.length()){\\n            \\n            // get the non-X positions of 2 strings\\n            while(p1 < start.length() && start.charAt(p1) == 'X'){\\n                p1++;\\n            }\\n            while(p2 < end.length() && end.charAt(p2) == 'X'){\\n                p2++;\\n            }\\n            \\n            //if both of the pointers reach the end the strings are transformable\\n            if(p1 == start.length() && p2 == end.length()){\\n                return true;\\n            }\\n            // if only one of the pointer reach the end they are not transformable\\n            if(p1 == start.length() || p2 == end.length()){\\n                return false;\\n            }\\n            \\n            if(start.charAt(p1) != end.charAt(p2)){\\n                return false;\\n            }\\n            // if the character is 'L', it can only be moved to the left. p1 should be greater or equal to p2.\\n            if(start.charAt(p1) == 'L' && p2 > p1){\\n                return false;\\n            }\\n            // if the character is 'R', it can only be moved to the right. p2 should be greater or equal to p1.\\n            if(start.charAt(p1) == 'R' && p1 > p2){\\n                return false;\\n            }\\n            p1++;\\n            p2++;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873004,
                "title": "easy-to-understand-explanation-with-picture",
                "content": "\\n[Better formatted original blog post here](https://medium.com/@algo.monster.hello/leetcode-777-swap-adjacent-in-lr-string-google-interview-question-3574d2c77d19)\\n\\n## Key observations:\\nThere are three kinds of characters, \\u2018L\\u2019, \\u2018R\\u2019, \\u2018X\\u2019.\\nReplacing XL with LX = move L to the left by one\\nReplacing RX with XR = move R to the right by one\\nIf we remove all the X in both strings, the resulting strings should be the same.\\n## Additional observations:\\nSince a move always involves X, an L or R cannot move through another L or R.\\nSince an L can only move to the right, for each occurrence of L in the start string, its position should be to the same or to the left of its corresponding L in the end string.\\n\\n![image](https://assets.leetcode.com/users/images/8c1c2572-00a8-4413-8383-ec5d5126c060_1601526675.9118004.png)\\n\\nAnd vice versa for the R characters.\\n\\n## Implementation\\n\\nWe first compare two strings with X removed. This checks relative position between Ls and Rs are correct.\\n\\nThen we find the indices for each occurence of L and check the condition in the above figure. Then we do the same for R.\\n\\n```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if len(start) != len(end): return False\\n        \\n        # check L R orders are the same\\n        if start.replace(\\'X\\',\\'\\') != end.replace(\\'X\\', \\'\\'): return False\\n        \\n        n = len(start)\\n        Lstart = [i for i in range(n) if start[i] == \\'L\\']\\n        Lend = [i for i in range(n) if end[i] == \\'L\\']\\n        \\n        Rstart = [i for i in range(n) if start[i] == \\'R\\']\\n        Rend = [i for i in range(n) if end[i] == \\'R\\']\\n\\t\\t# check L positions are correct\\n        for i, j in zip(Lstart, Lend):\\n            if i < j:\\n                return False\\n            \\n        # check R positions are correct\\n        for i, j in zip(Rstart, Rend):\\n            if i > j:\\n                return False\\n            \\n        return True\\n```\\n\\n[Better formatted original post and solutions and patterns ](https://medium.com/@algo.monster.hello/leetcode-777-swap-adjacent-in-lr-string-google-interview-question-3574d2c77d19)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if len(start) != len(end): return False\\n        \\n        # check L R orders are the same\\n        if start.replace(\\'X\\',\\'\\') != end.replace(\\'X\\', \\'\\'): return False\\n        \\n        n = len(start)\\n        Lstart = [i for i in range(n) if start[i] == \\'L\\']\\n        Lend = [i for i in range(n) if end[i] == \\'L\\']\\n        \\n        Rstart = [i for i in range(n) if start[i] == \\'R\\']\\n        Rend = [i for i in range(n) if end[i] == \\'R\\']\\n\\t\\t# check L positions are correct\\n        for i, j in zip(Lstart, Lend):\\n            if i < j:\\n                return False\\n            \\n        # check R positions are correct\\n        for i, j in zip(Rstart, Rend):\\n            if i > j:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113787,
                "title": "c-with-explanation-o-n-14ms",
                "content": "First, check the sequence of L and R in start and end is the same;\\nSecond, index of L in start should be >= index of corresponding L in end, while index of R <= corresponding index.\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n = start.size();\\n        string s1, s2;\\n        for (int i = 0; i < n; ++i) \\n            if (start[i] != 'X') s1 += start[i];\\n        for (int i = 0; i < n; ++i) \\n            if (end[i] != 'X') s2 += end[i];\\n        if (s1 != s2) return false;\\n        for (int i = 0, j = 0; i < n && j < n;) {\\n            if (start[i] == 'X') \\n               i++;\\n            else if (end[j] == 'X') \\n               j++;\\n            else {\\n                if ((start[i] == 'L' && i < j) || (start[i] == 'R' && i > j)) return false;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n = start.size();\\n        string s1, s2;\\n        for (int i = 0; i < n; ++i) \\n            if (start[i] != 'X') s1 += start[i];\\n        for (int i = 0; i < n; ++i) \\n            if (end[i] != 'X') s2 += end[i];\\n        if (s1 != s2) return false;\\n        for (int i = 0, j = 0; i < n && j < n;) {\\n            if (start[i] == 'X') \\n               i++;\\n            else if (end[j] == 'X') \\n               j++;\\n            else {\\n                if ((start[i] == 'L' && i < j) || (start[i] == 'R' && i > j)) return false;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536718,
                "title": "python-check-their-positions-with-picture-clean-concise",
                "content": "**Key observations:**\\n- There are three kinds of characters, `L`, `R`, `X`.\\n- Replacing `XL` with `LX` = move `L` to the left by one.\\n- Replacing `RX` with `XR` = move `R` to the right by one.\\n- If we remove all the `X` in both strings, the resulting strings should be the same.\\n\\n**Additional observations:**\\n- Since a move always involves `X`, an `L` or `R` cannot move through another `L` or `R`.\\n- Since an `L` can only move to the right, for each occurrence of `L` in the start string, its position should be to the same or to the left of its corresponding `L` in the end string.\\n\\n![image](https://assets.leetcode.com/users/images/d3a2cefe-6cd4-49fa-ad7c-f825369e753c_1635008908.8039162.png)\\n\\n\\n```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        # L, R orders must be the same\\n        if start.replace(\"X\", \"\") != end.replace(\"X\", \"\"):\\n            return False\\n        \\n        n = len(start)\\n        startL = [i for i in range(n) if start[i] == \\'L\\']\\n        endL = [i for i in range(n) if end[i] == \\'L\\']\\n        startR = [i for i in range(n) if start[i] == \\'R\\']\\n        endR = [i for i in range(n) if end[i] == \\'R\\']\\n        \\n        for i, j in zip(startL, endL):\\n            if i < j:\\n                return False\\n            \\n        for i, j in zip(startR, endR):\\n            if i > j:\\n                return False\\n        \\n        return True\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^4` is length of `start` or `end` string.\\n- Space: `O(N)`\\n\\nNote: This post is written based on this **[Easy-to-understand explanation with PICTURE](https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/873004/Easy-to-understand-explanation-with-PICTURE)** post.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        # L, R orders must be the same\\n        if start.replace(\"X\", \"\") != end.replace(\"X\", \"\"):\\n            return False\\n        \\n        n = len(start)\\n        startL = [i for i in range(n) if start[i] == \\'L\\']\\n        endL = [i for i in range(n) if end[i] == \\'L\\']\\n        startR = [i for i in range(n) if start[i] == \\'R\\']\\n        endR = [i for i in range(n) if end[i] == \\'R\\']\\n        \\n        for i, j in zip(startL, endL):\\n            if i < j:\\n                return False\\n            \\n        for i, j in zip(startR, endR):\\n            if i > j:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953911,
                "title": "explained-python-simple-and-concise-solution",
                "content": "IDEA: \\n1. As \\'L\\' and \\'R\\' are only swapped with \\'X\\', thus if we take out all \\'X\\'s from both start and end strings, the remaining strings should have the following properties:\\n\\ta. same total length.\\n\\tb. same number and order w.r.t. \\'L\\' and \\'R\\'.\\n2. As len(start) = len(end) is given in the problem description, this means the number of \\'X\\' in both string should be the same as well considering the point above. \\n3. We use two pointers one for the start string, one for the end string. When start pointer is pointing to the ```nth``` non-\\'X\\' char, the char that the end pointer is pointing to the ```nth``` non-\\'X\\' char should be the same, i.e. if the char in start string is a \\'L\\', the end pointer should be pointing to a \\'L\\' as well.\\n4. As \\'L\\' can only move to the left of its index in start string, when we go through two strings using two pointers, the pointer index in the end string for ```nth``` \\'L\\' should be only smaller or equal than the pointer index pointing to the ```nth``` \\'L\\' in the start string. Same idea for \\'R\\', except now the end pointer index should be equal or larger than the start pointer index.\\n5. Time complexity: O(n) where n is the length of the start string. As we only go through it once. ```.count()``` is a O(n) as well. Space Complexity: O(1). Constant spaces used for variables. \\n\\n```\\ndef canTransform(self, start: str, end: str) -> bool:\\n        if start.count(\\'X\\') != end.count(\\'X\\'): \\n            return False\\n        \\n        n = len(start)\\n        i = j = 0\\n        \\n        while i < n and j < n: \\n            if start[i] == \\'X\\': \\n                i += 1\\n                continue\\n            if end[j] == \\'X\\':\\n                j += 1\\n                continue\\n            \\n            if start[i] != end[j]: return False\\n            if start[i] == \\'L\\' and i < j: return False\\n            if start[i] == \\'R\\' and i > j:  return False\\n            \\n            i += 1\\n            j += 1\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```nth```\n```nth```\n```nth```\n```nth```\n```.count()```\n```\\ndef canTransform(self, start: str, end: str) -> bool:\\n        if start.count(\\'X\\') != end.count(\\'X\\'): \\n            return False\\n        \\n        n = len(start)\\n        i = j = 0\\n        \\n        while i < n and j < n: \\n            if start[i] == \\'X\\': \\n                i += 1\\n                continue\\n            if end[j] == \\'X\\':\\n                j += 1\\n                continue\\n            \\n            if start[i] != end[j]: return False\\n            if start[i] == \\'L\\' and i < j: return False\\n            if start[i] == \\'R\\' and i > j:  return False\\n            \\n            i += 1\\n            j += 1\\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113782,
                "title": "python-simple-solution-3-lines-o-n",
                "content": "The idea it to compare 'L' position in start is greater than or equal to that in end, also 'R' position in start is less than or equal to that in end.\\n\\nThe reason is 'L' can move left when 'X' exists before, and 'R' can move right when 'X' exists after, and 'L' and 'R' cannot cross each other, so we do not care about 'X'.\\n```\\nclass Solution:\\n    def canTransform(self, start, end):\\n        \"\"\"\\n        :type start: str\\n        :type end: str\\n        :rtype: bool\\n        \"\"\"\\n        s = [(c, i) for i, c in enumerate(start) if c == 'L' or c == 'R']\\n        e = [(c, i) for i, c in enumerate(end) if c == 'L' or c == 'R']\\n        return len(s) == len(e) and all(c1 == c2 and (i1 >= i2 and c1 == 'L' or i1 <= i2 and c1 == 'R') for (c1, i1), (c2, i2) in zip(s,e))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start, end):\\n        \"\"\"\\n        :type start: str\\n        :type end: str\\n        :rtype: bool\\n        \"\"\"\\n        s = [(c, i) for i, c in enumerate(start) if c == 'L' or c == 'R']\\n        e = [(c, i) for i, c in enumerate(end) if c == 'L' or c == 'R']\\n        return len(s) == len(e) and all(c1 == c2 and (i1 >= i2 and c1 == 'L' or i1 <= i2 and c1 == 'R') for (c1, i1), (c2, i2) in zip(s,e))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147987,
                "title": "explanation-and-java-solution",
                "content": "The solution is simple and similar to others, but more detailed explanation is needed.\\n\\nIn fact, \"R\" can move to the right until it is blocked by \"L\" while \"L\" can move to the left until it is blocked by \"R\". \\n\\nWe may count the number of \"L\" and \"R\" as follows. There are several principles during the loop:\\n\\n1. the value of `l` could be zero and negative, but not positive. This is becasue \"L\" could move to the left, so \"L\" may appear earlier in `end` than that in `start`. So once find `l > 0`, we may return false;\\n2. the value of `r` could be zero and positive, but not negative. The reasons are similar to the one above. So once find`r < 0`, we may return false;\\n3. When `l < 0`, `r` must be zero. This is because when `l < 0`, it means that one \"L\" appears earlier in `end`, and all \"R\"s before the current \"L\" in `end` should have also been visited in `start` (this is because \"R\" could only remove to the right).\\n4.  When `r > 0`, `l` must be zero. Reasons are similar.\\n```java\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int l = 0, r = 0;\\n        for (int i = 0; i < start.length(); i++) {\\n            if (start.charAt(i) == \\'L\\') l++;\\n            if (start.charAt(i) == \\'R\\') r++;\\n            if (end.charAt(i) == \\'L\\') l--;\\n            if (end.charAt(i) == \\'R\\') r --;\\n            \\n            if (l > 0 || r < 0 || ( l < 0 && r != 0) || (r > 0 && l != 0)) return false;\\n        }\\n        \\n        return l == 0 && r == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int l = 0, r = 0;\\n        for (int i = 0; i < start.length(); i++) {\\n            if (start.charAt(i) == \\'L\\') l++;\\n            if (start.charAt(i) == \\'R\\') r++;\\n            if (end.charAt(i) == \\'L\\') l--;\\n            if (end.charAt(i) == \\'R\\') r --;\\n            \\n            if (l > 0 || r < 0 || ( l < 0 && r != 0) || (r > 0 && l != 0)) return false;\\n        }\\n        \\n        return l == 0 && r == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888675,
                "title": "python-o-n-two-pointers-with-comments-faster-than-99",
                "content": "The key is to figure out that we can ignore the `X`s, but the relative position of the `L`s and `R`s must be equal in both strings. \\n\\nSo think of it as if the `L`s can only \"move\" backwards:\\n```\\nstart: XXXXL\\n        <--L\\nend:   LXXXX\\n```\\nand the `R`s can only \"move\" forward:\\n```\\nstart: RXXXX\\n       R-->\\nend:   XXXXR\\n```\\nSo we can scan the characters, skipping the `X`s, verifying that the next non-X character is equal in both strings. Later we have to make sure that:\\n* If the current character is `L`, the index in `start` must be greater or equal to the index in `end` (can only \"move\" backwards in the `start` string).\\n* If the current character is `R`, the index in `start` must be smaller or equal to the index in `end` (can only \"move\" forward in the `start` string).\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n```\\n        i = j = 0\\n        n = len(start)\\n        while i < n or j < n:\\n            \\n            # Skip \"X\" chars\\n            while i < n and start[i] == \"X\":\\n                i += 1\\n            while j < n and end[j] == \"X\":\\n                j += 1\\n                            \\n            # Reached the end of only one string\\n            if i != j and (i == n or j == n):\\n                return False\\n            \\n            # Reached the end of both strings\\n            if i == j and i == n:\\n                return True\\n            \\n            # After skipping the Xs, the characters\\n            # in both strings must be equal\\n            if start[i] != end[j]:\\n                return False\\n            \\n            # \"L\" can only move backwards,\\n            # so if the current chars are \"L\",\\n            # the index of `end` must be less or equal\\n            # to the index of `start`\\n            if start[i] == \"L\" and j > i:\\n                return False\\n            \\n            # \"R\" can only move forward,\\n            # so if the current chars are \"R\",\\n            # the index of `end` must be greater or equal\\n            # to the index of `start`\\n            if start[i] == \"R\" and j < i:\\n                return False\\n            \\n            i += 1\\n            j += 1\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nstart: XXXXL\\n        <--L\\nend:   LXXXX\\n```\n```\\nstart: RXXXX\\n       R-->\\nend:   XXXXR\\n```\n```\\n        i = j = 0\\n        n = len(start)\\n        while i < n or j < n:\\n            \\n            # Skip \"X\" chars\\n            while i < n and start[i] == \"X\":\\n                i += 1\\n            while j < n and end[j] == \"X\":\\n                j += 1\\n                            \\n            # Reached the end of only one string\\n            if i != j and (i == n or j == n):\\n                return False\\n            \\n            # Reached the end of both strings\\n            if i == j and i == n:\\n                return True\\n            \\n            # After skipping the Xs, the characters\\n            # in both strings must be equal\\n            if start[i] != end[j]:\\n                return False\\n            \\n            # \"L\" can only move backwards,\\n            # so if the current chars are \"L\",\\n            # the index of `end` must be less or equal\\n            # to the index of `start`\\n            if start[i] == \"L\" and j > i:\\n                return False\\n            \\n            # \"R\" can only move forward,\\n            # so if the current chars are \"R\",\\n            # the index of `end` must be greater or equal\\n            # to the index of `start`\\n            if start[i] == \"R\" and j < i:\\n                return False\\n            \\n            i += 1\\n            j += 1\\n            \\n        return True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114737,
                "title": "simple-java-solution",
                "content": "    public boolean canTransform(String start, String end) {\\n        int r = 0, l = 0;\\n        for (int i = 0; i< start.length(); i++){\\n            if (start.charAt(i) == \\'R\\'){ r++; l = 0;}\\n            if (end.charAt(i) == \\'R\\') { r--; l = 0;}\\n            if (end.charAt(i) == \\'L\\') { l++; r = 0;}\\n            if (start.charAt(i) == \\'L\\') { l--; r = 0;}\\n            if (l < 0 || r < 0) return false;\\n        }\\n\\n        if (l != 0 || r != 0) return false;\\n        return true;\\n    }\\n",
                "solutionTags": [],
                "code": "    public boolean canTransform(String start, String end) {\\n        int r = 0, l = 0;\\n        for (int i = 0; i< start.length(); i++){\\n            if (start.charAt(i) == \\'R\\'){ r++; l = 0;}\\n            if (end.charAt(i) == \\'R\\') { r--; l = 0;}\\n            if (end.charAt(i) == \\'L\\') { l++; r = 0;}\\n            if (start.charAt(i) == \\'L\\') { l--; r = 0;}\\n            if (l < 0 || r < 0) return false;\\n        }\\n\\n        if (l != 0 || r != 0) return false;\\n        return true;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 126728,
                "title": "imagine-r-and-l-as-walker",
                "content": "This is actually a good quesion. Why does everybody donw vote it. We can imagine R as the walker who can only walk right, and L as the walker who can only walk left. X is the empty space that walkers can pass through\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int i = 0, j = 0;\\n        if(start.length() != end.length()) return false;\\n        while(i < start.length() && j < end.length()){\\n            while(i < start.length() && start.charAt(i) == \\'X\\') ++i;\\n            while(j < end.length() && end.charAt(j) == \\'X\\') ++j;\\n            if(i == start.length() || j == end.length()) break;\\n            if(start.charAt(i) != end.charAt(j)) return false;\\n            if(start.charAt(i) == \\'R\\' && i > j) return false;\\n            else if(start.charAt(i) == \\'L\\' && i < j) return false;\\n            ++i;\\n            ++j;\\n        }\\n        while(i < start.length() && start.charAt(i) == \\'X\\') ++i;\\n        while(j < end.length() && end.charAt(j) == \\'X\\') ++j;\\n        return i == j;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int i = 0, j = 0;\\n        if(start.length() != end.length()) return false;\\n        while(i < start.length() && j < end.length()){\\n            while(i < start.length() && start.charAt(i) == \\'X\\') ++i;\\n            while(j < end.length() && end.charAt(j) == \\'X\\') ++j;\\n            if(i == start.length() || j == end.length()) break;\\n            if(start.charAt(i) != end.charAt(j)) return false;\\n            if(start.charAt(i) == \\'R\\' && i > j) return false;\\n            else if(start.charAt(i) == \\'L\\' && i < j) return false;\\n            ++i;\\n            ++j;\\n        }\\n        while(i < start.length() && start.charAt(i) == \\'X\\') ++i;\\n        while(j < end.length() && end.charAt(j) == \\'X\\') ++j;\\n        return i == j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571655,
                "title": "java-easy-to-understand-with-pictures",
                "content": "![image](https://assets.leetcode.com/users/images/870e1979-2650-4669-bfa0-c29f4d516259_1636616700.965476.jpeg)\\n<br/>\\nFrom the above image it can be observed that \\n* Both start and end have same number of L and R .\\n* Length of start and end are same.\\n* XL transforming to LX , means it either stays in the same start index  or is less than that of its start index in the end.\\n* Similarly RX transforming to XR , means it either stays in the same start index  or is greater than that of its start index in the end.\\n\\n<br/>\\n** JAVA**\\n\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n\\t\\n\\t//Checking if the number of L and R are equal without X in start and end\\n        if(!start.replace(\"X\",\"\").equals(end.replace(\"X\",\"\"))) return false;\\n\\t\\t\\n\\t//Checking if length of start and end are different\\n        if(start.length()>end.length() || end.length()>start.length()) return false;\\n        \\n        //Making Arraylist for storing indices of L and R in both start and end\\n\\t\\t\\n        ArrayList<Integer> lstart = new ArrayList<>(); \\n        ArrayList<Integer> lend = new ArrayList<>(); \\n        ArrayList<Integer> rstart = new ArrayList<>(); \\n        ArrayList<Integer> rend = new ArrayList<>(); \\n        \\n\\t\\t//Iterating over start and storing L and R indices in their respective ArrayList\\n        for(int i=0;i<start.length();i++){\\n            if(start.charAt(i)==\\'L\\') lstart.add(i);\\n            if(start.charAt(i)==\\'R\\') rstart.add(i);\\n\\t\\t\\n\\t\\t//Iterating over end and storing L and R indices in their respective ArrayList\\n        }\\n        for(int i=0;i<end.length();i++){\\n            if(end.charAt(i)==\\'L\\') lend.add(i);\\n            if(end.charAt(i)==\\'R\\') rend.add(i);\\n\\n        }\\n        \\n        //Taking two pointers and checking the condition which violates the rules\\n\\t\\t\\n\\t\\t//For L\\n        int i=0,j=0;\\n        while(i<lstart.size() && j<lend.size()){\\n            if (lend.get(j)>lstart.get(i)) return false;    //index in start should be less than or equal to index in end \\n            i++;\\n            j++;\\n        }\\n        \\n\\t\\t//For R\\n        i=0;j=0;\\n         while(i<rstart.size() && j<rend.size()){\\n            if (rend.get(j)<rstart.get(i)) return false;   //index in start should be greater than or equal to index in end \\n             i++;\\n             j++;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n\\t\\n\\t//Checking if the number of L and R are equal without X in start and end\\n        if(!start.replace(\"X\",\"\").equals(end.replace(\"X\",\"\"))) return false;\\n\\t\\t\\n\\t//Checking if length of start and end are different\\n        if(start.length()>end.length() || end.length()>start.length()) return false;\\n        \\n        //Making Arraylist for storing indices of L and R in both start and end\\n\\t\\t\\n        ArrayList<Integer> lstart = new ArrayList<>(); \\n        ArrayList<Integer> lend = new ArrayList<>(); \\n        ArrayList<Integer> rstart = new ArrayList<>(); \\n        ArrayList<Integer> rend = new ArrayList<>(); \\n        \\n\\t\\t//Iterating over start and storing L and R indices in their respective ArrayList\\n        for(int i=0;i<start.length();i++){\\n            if(start.charAt(i)==\\'L\\') lstart.add(i);\\n            if(start.charAt(i)==\\'R\\') rstart.add(i);\\n\\t\\t\\n\\t\\t//Iterating over end and storing L and R indices in their respective ArrayList\\n        }\\n        for(int i=0;i<end.length();i++){\\n            if(end.charAt(i)==\\'L\\') lend.add(i);\\n            if(end.charAt(i)==\\'R\\') rend.add(i);\\n\\n        }\\n        \\n        //Taking two pointers and checking the condition which violates the rules\\n\\t\\t\\n\\t\\t//For L\\n        int i=0,j=0;\\n        while(i<lstart.size() && j<lend.size()){\\n            if (lend.get(j)>lstart.get(i)) return false;    //index in start should be less than or equal to index in end \\n            i++;\\n            j++;\\n        }\\n        \\n\\t\\t//For R\\n        i=0;j=0;\\n         while(i<rstart.size() && j<rend.size()){\\n            if (rend.get(j)<rstart.get(i)) return false;   //index in start should be greater than or equal to index in end \\n             i++;\\n             j++;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704920,
                "title": "c-one-pass-time-o-n-space-o-1-with-explanation",
                "content": "Here I translate \\'X\\' to \\'.\\' for understanding more easily.\\n\\n```\\nstart = \"R..LR.R.L\"\\nend   = \".RL..RRL.\"\\n```\\nFrom the above example, we can find some rules for \\'L\\' and \\'R\\':\\n\\n**1. \"*XL*\" to \"*LX*\": L only go left\\n2. \"*RX*\" to \"*XR*\": R only go right\\n3. L and R cannot change their order**\\n\\nFor example, if we have \"XXXXXXXL\" and finally we may get the result \"LXXXXXXX\".\\n###### -----------------------------------------------------------------\\nWe only need to check the \"L\" and \"R\" position in two string.\\nUsing two pointer `i` and `j` to keep comparing:\\n1. skip \\'X\\', make sure `start[i]` and `end[j]` is the same \\n2. \\'R\\' position in `start` is smaller than `end`\\n3. \\'L\\' position in `start` is larger than `end`\\n\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        \\n        int i=0, j=0;\\n        while(i<start.size() && j<end.size()) {\\n            \\n            while(start[i]==\\'X\\') i++;\\n            while(end[j]==\\'X\\') j++;\\n            \\n            if(start[i]!=end[j]) return false;\\n            if(start[i]==\\'R\\' && i>j) return false;\\n            if(start[i]==\\'L\\' && i<j) return false;\\n            i++; j++;\\n        }\\n        while(i<start.size() && start[i]==\\'X\\') i++;\\n        while(j<end.size() && end[j]==\\'X\\') j++;\\n        return i==j;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstart = \"R..LR.R.L\"\\nend   = \".RL..RRL.\"\\n```\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        \\n        int i=0, j=0;\\n        while(i<start.size() && j<end.size()) {\\n            \\n            while(start[i]==\\'X\\') i++;\\n            while(end[j]==\\'X\\') j++;\\n            \\n            if(start[i]!=end[j]) return false;\\n            if(start[i]==\\'R\\' && i>j) return false;\\n            if(start[i]==\\'L\\' && i<j) return false;\\n            i++; j++;\\n        }\\n        while(i<start.size() && start[i]==\\'X\\') i++;\\n        while(j<end.size() && end[j]==\\'X\\') j++;\\n        return i==j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113774,
                "title": "c-simple-subsequence-matching-with-position-constraint",
                "content": "We see that L can move backwards and R can move forwards. So we can first see if subsequence that contains only L & R is the same for start and end. If so, we can compare the corresponding positions of L and R. \\nFor L in start it need to be somewhere ahead of corresponding L in end (since L can only move backwards).\\nFor R in start, it needs to be somewhere behind of corresponding R in end.\\n\\n```\\n    bool canTransform(string start, string end) {\\n        int n=start.size();\\n        assert(n == end.size());\\n\\t// --Check for anagrams.\\n        int lcnt = 0, rcnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(start[i] == \\'L\\') ++lcnt;\\n            else if(start[i] == \\'R\\') ++rcnt;\\n            if(end[i] == \\'L\\') --lcnt;\\n            else if(end[i] == \\'R\\') --rcnt;\\n        }\\n        if(lcnt || rcnt) return false;\\n        \\n        int i=0,j=0;\\n        while(j < n && i < n){\\n            while(j < n && end[j] == \\'X\\') ++j;\\n            while(i < n && start[i] == \\'X\\') ++i;\\n            if(i==n&&j==n) break;\\n            if(i==n || j==n || start[i] != end[j]) return false;\\n            if(start[i] == \\'R\\' && i > j) return false;\\n            else if(start[i] == \\'L\\' && i < j) return false;\\n            ++i; ++j;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool canTransform(string start, string end) {\\n        int n=start.size();\\n        assert(n == end.size());\\n\\t// --Check for anagrams.\\n        int lcnt = 0, rcnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(start[i] == \\'L\\') ++lcnt;\\n            else if(start[i] == \\'R\\') ++rcnt;\\n            if(end[i] == \\'L\\') --lcnt;\\n            else if(end[i] == \\'R\\') --rcnt;\\n        }\\n        if(lcnt || rcnt) return false;\\n        \\n        int i=0,j=0;\\n        while(j < n && i < n){\\n            while(j < n && end[j] == \\'X\\') ++j;\\n            while(i < n && start[i] == \\'X\\') ++i;\\n            if(i==n&&j==n) break;\\n            if(i==n || j==n || start[i] != end[j]) return false;\\n            if(start[i] == \\'R\\' && i > j) return false;\\n            else if(start[i] == \\'L\\' && i < j) return false;\\n            ++i; ++j;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2144775,
                "title": "java-easy-understanding-with-explanation",
                "content": "(i) First, \\'L\\' cannot swap to left of \\'R\\', and \\'R\\' cannot swap to right of \\'L\\'. So we remove all \\'X\\' in both `start` and `end` to find if all \\'L\\' and \\'R\\' in the same order. If not, return false.\\n\\n(ii) Second, let\\'s look at this pair:\\n\\tstart: \"LXX\"\\n\\tend:    \"XXL\"\\n\\tAfter removing all \\'X\\', this pair can pass the first condition. But `start` can\\'t transfer to `end`. The problem is the positon of \\'L\\' in `start` is more left than the \\'L\\' in `end` (\\'L\\' can only go to left side, can\\'t go right). So we go through two strings(from `0` to `start.length()`), to make sure every \\'L\\' comes earlier in `end`. \\n\\tFor \\'R\\', make sure every \\'R\\' comes earlier in `start`. \\n```\\npublic boolean canTransform(String start, String end) {\\n\\t// First, remove all \\'X\\', and compare if they equal.\\n\\tStringBuffer s = new StringBuffer();\\n\\tStringBuffer e = new StringBuffer();\\n\\tfor (char c : start.toCharArray()) {\\n\\t\\tif (c != \\'X\\') {\\n\\t\\t\\ts.append(c);\\n\\t\\t}\\n\\t}\\n\\tfor (char c : end.toCharArray()) {\\n\\t\\tif (c != \\'X\\') {\\n\\t\\t\\te.append(c);\\n\\t\\t}\\n\\t}\\n\\tif (!s.toString().equals(e.toString()))\\n\\t\\treturn false;\\n\\t// check R\\n\\t// form i to start.length(), \\n\\t// if R found in start count++, \\n\\t// if R found in end count--, \\n\\t// if count comes to negative, that means \\'R\\' is in more left position in end, so \\'R\\' can\\'t move from start to end.\\n\\tint count = 0;\\n\\tfor (int i = 0; i < start.length(); i++) {\\n\\t\\tif (start.charAt(i) == \\'R\\') {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse if (end.charAt(i) == \\'R\\') {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tif (count < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t// check L\\n\\t// same with checking \\'R\\', only difference is: \\n\\t// to ensure every \\'L\\' comes first in end.\\n\\tcount = 0;\\n\\tfor (int i = 0; i < start.length(); i++) {\\n\\t\\tif (end.charAt(i) == \\'L\\') {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse if (start.charAt(i) == \\'L\\') {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tif (count < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```\\n\\nIt is easy to understand, if it helps, upvote please! \\n^_^\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canTransform(String start, String end) {\\n\\t// First, remove all \\'X\\', and compare if they equal.\\n\\tStringBuffer s = new StringBuffer();\\n\\tStringBuffer e = new StringBuffer();\\n\\tfor (char c : start.toCharArray()) {\\n\\t\\tif (c != \\'X\\') {\\n\\t\\t\\ts.append(c);\\n\\t\\t}\\n\\t}\\n\\tfor (char c : end.toCharArray()) {\\n\\t\\tif (c != \\'X\\') {\\n\\t\\t\\te.append(c);\\n\\t\\t}\\n\\t}\\n\\tif (!s.toString().equals(e.toString()))\\n\\t\\treturn false;\\n\\t// check R\\n\\t// form i to start.length(), \\n\\t// if R found in start count++, \\n\\t// if R found in end count--, \\n\\t// if count comes to negative, that means \\'R\\' is in more left position in end, so \\'R\\' can\\'t move from start to end.\\n\\tint count = 0;\\n\\tfor (int i = 0; i < start.length(); i++) {\\n\\t\\tif (start.charAt(i) == \\'R\\') {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse if (end.charAt(i) == \\'R\\') {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tif (count < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t// check L\\n\\t// same with checking \\'R\\', only difference is: \\n\\t// to ensure every \\'L\\' comes first in end.\\n\\tcount = 0;\\n\\tfor (int i = 0; i < start.length(); i++) {\\n\\t\\tif (end.charAt(i) == \\'L\\') {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse if (start.charAt(i) == \\'L\\') {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tif (count < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113791,
                "title": "easy-understanding-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        char[] s = start.toCharArray();\\n        char[] e = end.toCharArray();\\n        if (s.length != e.length) return false;\\n        for (int i = 0; i < s.length; i++) {\\n            if (s[i] == e[i]) continue;\\n            if (s[i] != 'X' && e[i] != 'X') return false;\\n            if (s[i] == 'L' && e[i] == 'X') return false;\\n            if (s[i] == 'X' && e[i] == 'R') return false;\\n            if (s[i] == 'R' && e[i] == 'X') {\\n                int nextR = findNext(s, i+1, 'X', 'R');\\n                if (nextR == -1) return false;\\n                else swap(s, i, nextR);\\n            } else if (s[i] == 'X' && e[i] == 'L') {\\n                int nextL = findNext(s, i+1, 'L', 'X');\\n                if (nextL == -1) return false;\\n                else swap(s, i, nextL);\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    private int findNext(char[] s, int startIdx, char target, char skip) {\\n        for (int i = startIdx; i < s.length; i++) {\\n            if (s[i] == target) return i;\\n            else if (s[i] == skip) continue;\\n            else return -1;\\n        }\\n        return -1;\\n    }\\n    private void swap(char[] s, int i, int j) {\\n        char tmp = s[i];\\n        s[i] = s[j];\\n        s[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        char[] s = start.toCharArray();\\n        char[] e = end.toCharArray();\\n        if (s.length != e.length) return false;\\n        for (int i = 0; i < s.length; i++) {\\n            if (s[i] == e[i]) continue;\\n            if (s[i] != 'X' && e[i] != 'X') return false;\\n            if (s[i] == 'L' && e[i] == 'X') return false;\\n            if (s[i] == 'X' && e[i] == 'R') return false;\\n            if (s[i] == 'R' && e[i] == 'X') {\\n                int nextR = findNext(s, i+1, 'X', 'R');\\n                if (nextR == -1) return false;\\n                else swap(s, i, nextR);\\n            } else if (s[i] == 'X' && e[i] == 'L') {\\n                int nextL = findNext(s, i+1, 'L', 'X');\\n                if (nextL == -1) return false;\\n                else swap(s, i, nextL);\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    private int findNext(char[] s, int startIdx, char target, char skip) {\\n        for (int i = startIdx; i < s.length; i++) {\\n            if (s[i] == target) return i;\\n            else if (s[i] == skip) continue;\\n            else return -1;\\n        }\\n        return -1;\\n    }\\n    private void swap(char[] s, int i, int j) {\\n        char tmp = s[i];\\n        s[i] = s[j];\\n        s[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160198,
                "title": "my-java-solution-with-my-understanding-as-comments",
                "content": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        // if there are no X, then the two string must be equal\\n        if (!start.replace(\"X\", \"\").equals(end.replace(\"X\", \"\")))\\n            return false;\\n        int pointer1 = 0;\\n        int pointer2 = 0;\\n        while (pointer1 < start.length() && pointer2 < end.length()) {\\n            // increment p1 and p2 whenever we see X from the position\\n            // this is to get the nonX positions\\n            while (pointer1 < start.length() && start.charAt(pointer1) == \\'X\\') {\\n                pointer1 += 1;\\n            }\\n            while (pointer2 < end.length() && end.charAt(pointer2) == \\'X\\') {\\n                pointer2 += 1;\\n            }\\n            // if both the pointer reaches the end of the strings, then we can return true.\\n            // if only one of the pointer reaches the end of the strings, then we can return false\\n            if (pointer1 == start.length() && pointer2 == end.length())\\n                return true;\\n            if (pointer1 == start.length() || pointer2 == end.length())\\n                return false;\\n            // if the characyer at respective pointer1 and pointer2 of start and end is not equal, then we cannot transform\\n            if (start.charAt(pointer1) != end.charAt(pointer2))\\n                return false;\\n            // if the pointer1 at the start points to the \\'L\\' and pointer2 > pointer1 return false\\n            // this is because L can be only moved to the left and pointer1 must be > pointer2\\n            // if the pointer2 at the end points to the \\'R\\' and pointer1 > pointer2 return false\\n            // this is because R can be only moved to the right and pointer2 must be > pointer1\\n            if (start.charAt(pointer1) == \\'L\\' && pointer2 > pointer1)\\n                return false;\\n            if (end.charAt(pointer2) == \\'R\\' && pointer1 > pointer2)\\n                return false;\\n            pointer1 += 1;\\n            pointer2 += 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        // if there are no X, then the two string must be equal\\n        if (!start.replace(\"X\", \"\").equals(end.replace(\"X\", \"\")))\\n            return false;\\n        int pointer1 = 0;\\n        int pointer2 = 0;\\n        while (pointer1 < start.length() && pointer2 < end.length()) {\\n            // increment p1 and p2 whenever we see X from the position\\n            // this is to get the nonX positions\\n            while (pointer1 < start.length() && start.charAt(pointer1) == \\'X\\') {\\n                pointer1 += 1;\\n            }\\n            while (pointer2 < end.length() && end.charAt(pointer2) == \\'X\\') {\\n                pointer2 += 1;\\n            }\\n            // if both the pointer reaches the end of the strings, then we can return true.\\n            // if only one of the pointer reaches the end of the strings, then we can return false\\n            if (pointer1 == start.length() && pointer2 == end.length())\\n                return true;\\n            if (pointer1 == start.length() || pointer2 == end.length())\\n                return false;\\n            // if the characyer at respective pointer1 and pointer2 of start and end is not equal, then we cannot transform\\n            if (start.charAt(pointer1) != end.charAt(pointer2))\\n                return false;\\n            // if the pointer1 at the start points to the \\'L\\' and pointer2 > pointer1 return false\\n            // this is because L can be only moved to the left and pointer1 must be > pointer2\\n            // if the pointer2 at the end points to the \\'R\\' and pointer1 > pointer2 return false\\n            // this is because R can be only moved to the right and pointer2 must be > pointer1\\n            if (start.charAt(pointer1) == \\'L\\' && pointer2 > pointer1)\\n                return false;\\n            if (end.charAt(pointer2) == \\'R\\' && pointer1 > pointer2)\\n                return false;\\n            pointer1 += 1;\\n            pointer2 += 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238081,
                "title": "2-ways-to-solve-this-problem-dfs-or-2-pointers-easy-to-understand-solution",
                "content": "**Solution 1 (Time Limit Exceeded)**: Simply DFS, we iterate through all the possible next moves with the current LR string and perform the check, but this solution will cause Time Limit Exceeded:\\n```java\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        return search(start, end, map);\\n    }\\n    \\n    boolean search(String cur, String end, Map<String, List<String>> map) {\\n        if (cur.equals(end)) return true;\\n        List<String> states;\\n        if (map.containsKey(cur)) states = map.get(cur);\\n        else {\\n            states = getAllStates(cur);\\n            map.put(cur, states);\\n        }\\n        for (String s : states) {\\n            if (search(s, end, map)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    List<String> getAllStates(String s) {\\n        List<String> states = new ArrayList<>();\\n        for (int i = 0;i < s.length() - 1;i++) {\\n            String ss = s.substring(i, i + 2);\\n            if (ss.equals(\"XL\")) {\\n                String newS = s.substring(0, i) + \"LX\" + s.substring(i + 2, s.length());\\n                states.add(newS);\\n            }\\n            \\n            if (ss.equals(\"RX\")) {\\n                String newS = s.substring(0, i) + \"XR\" + s.substring(i + 2, s.length());\\n                states.add(newS);\\n            }\\n        }\\n        return states;\\n    }\\n}\\n```\\n\\n**Solution 2 (Accepted)**: Simply use 2 pointers `i, j` to iterate through each character `ci, cj` of both strings one by one:\\n- If `ci == \\'X\\' or cj == \\'X\\'`, increment `i` or `j`\\n- If `ci != cj`, return `false`\\n- Else, we will have `ci == cj`, at this step, need to check:\\n\\t- If `ci == \\'L\\'`, then we must have `i >= j`, otherwise return `false`\\n\\t- If `ci == \\'R\\'`, then we must have `j >= i`, otherwise return `false`\\n\\nKeep looping to the end of both strings and return `true` at the end of the function.\\n```java\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (start.length() != end.length()) return false;\\n        int n = start.length();\\n        int i = 0, j = 0;\\n        while (i < n && j < n) {\\n            while (i < n && start.charAt(i) == \\'X\\') i++;\\n            while (j < n && end.charAt(j) == \\'X\\') j++;\\n            if (i == n || j == n) break;\\n            char s = start.charAt(i);\\n            char e = end.charAt(j);\\n            if (s != e) return false;\\n            if (s == \\'L\\' && i < j) return false;\\n            if (s == \\'R\\' && i > j) return false;\\n            i++;\\n            j++;\\n        }\\n        if (i < n) {\\n            if (start.charAt(i) != \\'X\\') return false;\\n            i++;\\n        }\\n        if (j < n) {\\n            if (end.charAt(j) != \\'X\\') return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        return search(start, end, map);\\n    }\\n    \\n    boolean search(String cur, String end, Map<String, List<String>> map) {\\n        if (cur.equals(end)) return true;\\n        List<String> states;\\n        if (map.containsKey(cur)) states = map.get(cur);\\n        else {\\n            states = getAllStates(cur);\\n            map.put(cur, states);\\n        }\\n        for (String s : states) {\\n            if (search(s, end, map)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    List<String> getAllStates(String s) {\\n        List<String> states = new ArrayList<>();\\n        for (int i = 0;i < s.length() - 1;i++) {\\n            String ss = s.substring(i, i + 2);\\n            if (ss.equals(\"XL\")) {\\n                String newS = s.substring(0, i) + \"LX\" + s.substring(i + 2, s.length());\\n                states.add(newS);\\n            }\\n            \\n            if (ss.equals(\"RX\")) {\\n                String newS = s.substring(0, i) + \"XR\" + s.substring(i + 2, s.length());\\n                states.add(newS);\\n            }\\n        }\\n        return states;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (start.length() != end.length()) return false;\\n        int n = start.length();\\n        int i = 0, j = 0;\\n        while (i < n && j < n) {\\n            while (i < n && start.charAt(i) == \\'X\\') i++;\\n            while (j < n && end.charAt(j) == \\'X\\') j++;\\n            if (i == n || j == n) break;\\n            char s = start.charAt(i);\\n            char e = end.charAt(j);\\n            if (s != e) return false;\\n            if (s == \\'L\\' && i < j) return false;\\n            if (s == \\'R\\' && i > j) return false;\\n            i++;\\n            j++;\\n        }\\n        if (i < n) {\\n            if (start.charAt(i) != \\'X\\') return false;\\n            i++;\\n        }\\n        if (j < n) {\\n            if (end.charAt(j) != \\'X\\') return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113788,
                "title": "u3010simple-python-1-scan-o-1-space-u3011",
                "content": "Actually two scans....\\n```\\nclass Solution(object):\\n    def canTransform(self, start, end):\\n        \"\"\"\\n        :type start: str\\n        :type end: str\\n        :rtype: bool\\n        \"\"\"\\n        if start.replace('X','')!=end.replace('X',''): return False\\n\\n        l1=l2=r1=r2=0\\n        for v1,v2 in zip(start,end):\\n            if v1=='L': l1+=1\\n            elif v1=='R': r1+=1\\n            if v2=='L': l2+=1\\n            elif v2=='R': r2+=1\\n            if l1>l2 or r1<r2: return False\\n        return True",
                "solutionTags": [],
                "code": "Actually two scans....\\n```\\nclass Solution(object):\\n    def canTransform(self, start, end):\\n        \"\"\"\\n        :type start: str\\n        :type end: str\\n        :rtype: bool\\n        \"\"\"\\n        if start.replace('X','')!=end.replace('X',''): return False\\n\\n        l1=l2=r1=r2=0\\n        for v1,v2 in zip(start,end):\\n            if v1=='L': l1+=1\\n            elif v1=='R': r1+=1\\n            if v2=='L': l2+=1\\n            elif v2=='R': r2+=1\\n            if l1>l2 or r1<r2: return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2097125,
                "title": "javascript-o-n-time-o-1-space-simple",
                "content": "#### Intuition\\n\\n1. We cannot move Rs and Ls past eachother. \\n2. We cannot move Rs to the left.\\n3. We cannot move Ls to the right.\\n\\n```javascript\\n/**\\n * @param {string} start\\n * @param {string} end\\n * @return {boolean}\\n */\\nvar canTransform = function(start, end) {\\n    let i = 0;\\n    let j = 0;\\n    \\n    while (i < start.length || j < end.length) {\\n        if (start[i] === \\'X\\') {\\n            i++;\\n            continue;\\n        }\\n        \\n        if (end[j] === \\'X\\') {\\n            j++;\\n            continue;\\n        }\\n        \\n\\t\\t// Breaking (1)\\n        if (start[i] !== end[j]) return false;\\n        \\n\\t\\t// Breaking (2)\\n        if (start[i] === \\'R\\' && i > j) return false;\\n\\t\\t\\n\\t\\t// Breaking (3)\\n        if (start[i] === \\'L\\' && j > i) return false;\\n        \\n        i++;\\n        j++;\\n    }\\n    \\n    return true;\\n};\\n```\\n\\nExample:\\n\\nstart: XXRLX\\nend:  XXLRX\\n\\nThis breaks (1) because the first non-X we find in start and end respectively will be R and L. We will never be able to swap R and L.\\n\\nstart: XXRXX\\nend:  XRXXX\\n\\nThis breaks (2) because the index of the start R is greater than the index of end R. We can only move R to the right.\\n\\nstart: XXLXX\\nend:  XXXLX\\n\\nThis breaks (3) because the index of the start L is less than the index of end L. We can only move L to the left.\\n\\nThere are implicit swapping rules and we just ensure that those rules are followed.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} start\\n * @param {string} end\\n * @return {boolean}\\n */\\nvar canTransform = function(start, end) {\\n    let i = 0;\\n    let j = 0;\\n    \\n    while (i < start.length || j < end.length) {\\n        if (start[i] === \\'X\\') {\\n            i++;\\n            continue;\\n        }\\n        \\n        if (end[j] === \\'X\\') {\\n            j++;\\n            continue;\\n        }\\n        \\n\\t\\t// Breaking (1)\\n        if (start[i] !== end[j]) return false;\\n        \\n\\t\\t// Breaking (2)\\n        if (start[i] === \\'R\\' && i > j) return false;\\n\\t\\t\\n\\t\\t// Breaking (3)\\n        if (start[i] === \\'L\\' && j > i) return false;\\n        \\n        i++;\\n        j++;\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787881,
                "title": "clean-python-solution-self-explained-easy-to-understand",
                "content": "```python\\n\"\"\"\\n1. Check if the sequence of L and R are the same.\\n2. Check if the index of L in the \"start\" are larger than index of the L in the \"end\", since L can only move left.\\n3. Check if the index of R in the \"start\" are smaller than index of the R in the \"end\", since R can only move left.\\n\"\"\"\\nclass Solution(object):\\n    def canTransform(self, start, end):\\n        if len(start)!=len(end): return False\\n        if start.replace(\\'X\\', \\'\\')!=end.replace(\\'X\\', \\'\\'): return False #[1]\\n        \\n\\t\\t#[2]\\n        startLIndex = [i for i, c in enumerate(start) if c==\\'L\\']\\n        endLIndex = [i for i, c in enumerate(end) if c==\\'L\\']\\n        for i in xrange(len(startLIndex)):\\n            if startLIndex[i]<endLIndex[i]:\\n                return False\\n        \\n\\t\\t#[3]\\n        startRIndex = [i for i, c in enumerate(start) if c==\\'R\\']\\n        endRIndex = [i for i, c in enumerate(end) if c==\\'R\\']\\n        for i in xrange(len(startRIndex)):\\n            if startRIndex[i]>endRIndex[i]:\\n                return False\\n        \\n        return True\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\n1. Check if the sequence of L and R are the same.\\n2. Check if the index of L in the \"start\" are larger than index of the L in the \"end\", since L can only move left.\\n3. Check if the index of R in the \"start\" are smaller than index of the R in the \"end\", since R can only move left.\\n\"\"\"\\nclass Solution(object):\\n    def canTransform(self, start, end):\\n        if len(start)!=len(end): return False\\n        if start.replace(\\'X\\', \\'\\')!=end.replace(\\'X\\', \\'\\'): return False #[1]\\n        \\n\\t\\t#[2]\\n        startLIndex = [i for i, c in enumerate(start) if c==\\'L\\']\\n        endLIndex = [i for i, c in enumerate(end) if c==\\'L\\']\\n        for i in xrange(len(startLIndex)):\\n            if startLIndex[i]<endLIndex[i]:\\n                return False\\n        \\n\\t\\t#[3]\\n        startRIndex = [i for i, c in enumerate(start) if c==\\'R\\']\\n        endRIndex = [i for i, c in enumerate(end) if c==\\'R\\']\\n        for i in xrange(len(startRIndex)):\\n            if startRIndex[i]>endRIndex[i]:\\n                return False\\n        \\n        return True\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149384,
                "title": "easy-c-o-n-solution-with-explanation",
                "content": "NOTE:\\n - In the given string `start`, `L` can move to the left but can\\'t pass through `R`, `R` can move to the right but can\\'t pass through `L`. Basically, there are 4 situations (when `start[i] != \\'X\\'` and `end[j] != \\'X\\'`):\\n   - `start[i] != end[j]` return `false`, cause `L` and `R` can\\'t pass through each other.\\n   - `start[i] == \\'L\\' && j > i ` return `false`, cause `L` can\\'t move to the right.\\n   - `start[i] == \\'R\\' && j < i` return `false` cause `R` can\\'t move to the left.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int i = 0, j = 0;\\n        for (; i < start.size() && j < end.size();) {\\n            if (start[i] == \\'X\\') i++;\\n            if (end[j] == \\'X\\') j++;\\n            \\n            if (start[i] != \\'X\\' && end[j] != \\'X\\') {\\n                if (start[i] != end[j]) return false;\\n                else if (start[i] == \\'L\\' && j > i) return false;\\n                else if (start[i] == \\'R\\' && j < i) return false;\\n                else i++, j++;\\n            }\\n        }\\n        \\n        while (i < start.size()) {\\n            if (start[i++] != \\'X\\') return false;\\n        }\\n        \\n        while (j < end.size()) {\\n            if (end[j++] != \\'X\\') return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int i = 0, j = 0;\\n        for (; i < start.size() && j < end.size();) {\\n            if (start[i] == \\'X\\') i++;\\n            if (end[j] == \\'X\\') j++;\\n            \\n            if (start[i] != \\'X\\' && end[j] != \\'X\\') {\\n                if (start[i] != end[j]) return false;\\n                else if (start[i] == \\'L\\' && j > i) return false;\\n                else if (start[i] == \\'R\\' && j < i) return false;\\n                else i++, j++;\\n            }\\n        }\\n        \\n        while (i < start.size()) {\\n            if (start[i++] != \\'X\\') return false;\\n        }\\n        \\n        while (j < end.size()) {\\n            if (end[j++] != \\'X\\') return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047353,
                "title": "python-o-n-with-comments-and-reasonings",
                "content": "```\\n\\nclass Solution:\\n    \\'\\'\\'\\n    1. The order of L and Rs in the start and end must be the same as L and R cannot cross one another. The allowed transformations are \\n       equivalent to an L/R swapping position with an adjacent X (Left X for L and right X for R). In other words L and R can cross an X \\n\\t   (to the left and right respectively) but they can\\'t cross one another.\\n    2. Since an L can only cross to the left (of an X), in the destination the index of an L must be the same or less than that of the \\n       corresponding L in start.\\n    3. Similarly since an R can only cross to the Right, in the destination the index of an R must be the same or greater than that of the \\n       corresponding R in start .\\n    \\'\\'\\'\\n\\t\\n    def canTransform(self, start: str, end: str) -> bool:\\n        \\'\\'\\'\\n        Check if order is the same (condition 1)\\n        \\'\\'\\'\\n        if start.replace(\"X\", \"\") != end.replace(\"X\", \"\"):\\n            return False\\n        \\n        \\'\\'\\'\\n        Check conditions 2 and 3\\n        \\'\\'\\'\\n        startLIndexes = [i for i in range(len(start)) if start[i] == \"L\"]\\n        startRIndexes = [i for i in range(len(start)) if start[i] == \"R\"]\\n        endLIndexes = [i for i in range(len(end)) if end[i] == \"L\"]\\n        endRIndexes = [i for i in range(len(end)) if end[i] == \"R\"]\\n        \\n        for i in range(len(startLIndexes)):\\n            if endLIndexes[i] > startLIndexes[i]:\\n                return False\\n        \\n        for i in range(len(startRIndexes)):\\n            if endRIndexes[i] < startRIndexes[i]:\\n                return False\\n        \\n        return True\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    \\'\\'\\'\\n    1. The order of L and Rs in the start and end must be the same as L and R cannot cross one another. The allowed transformations are \\n       equivalent to an L/R swapping position with an adjacent X (Left X for L and right X for R). In other words L and R can cross an X \\n\\t   (to the left and right respectively) but they can\\'t cross one another.\\n    2. Since an L can only cross to the left (of an X), in the destination the index of an L must be the same or less than that of the \\n       corresponding L in start.\\n    3. Similarly since an R can only cross to the Right, in the destination the index of an R must be the same or greater than that of the \\n       corresponding R in start .\\n    \\'\\'\\'\\n\\t\\n    def canTransform(self, start: str, end: str) -> bool:\\n        \\'\\'\\'\\n        Check if order is the same (condition 1)\\n        \\'\\'\\'\\n        if start.replace(\"X\", \"\") != end.replace(\"X\", \"\"):\\n            return False\\n        \\n        \\'\\'\\'\\n        Check conditions 2 and 3\\n        \\'\\'\\'\\n        startLIndexes = [i for i in range(len(start)) if start[i] == \"L\"]\\n        startRIndexes = [i for i in range(len(start)) if start[i] == \"R\"]\\n        endLIndexes = [i for i in range(len(end)) if end[i] == \"L\"]\\n        endRIndexes = [i for i in range(len(end)) if end[i] == \"R\"]\\n        \\n        for i in range(len(startLIndexes)):\\n            if endLIndexes[i] > startLIndexes[i]:\\n                return False\\n        \\n        for i in range(len(startRIndexes)):\\n            if endRIndexes[i] < startRIndexes[i]:\\n                return False\\n        \\n        return True\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952120,
                "title": "cpp-two-pointers-o-n-withexplaination",
                "content": "**Observations**\\n\\nLets take an example to understand solution:\\n1. XXXXXXL\\nWe can replace \\'XL\\' with XXXXXLX. Again doing this we can obtain XXXXLXX. Which shows we can move L in left. \\nNote: We are able to move L in left as long as there is no R in left side of L.\\n\\n2. On a similar note we can say R can be moved to right until we have L following R.\\n\\n**Conclusion**\\n\\na. L can not cross R and R cannot cross L i.e. Order of LR in original and final string should be same.\\nb. R in final string can be at position >= what it was before in original string. It cannot go in left.\\nc. L in final string can be at position <= what is was before in original string. It cannot go in right.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {        \\n        \\n        int len = start.length();\\n        int i=0,j=0;\\n      \\n        while(i<len && j<len){\\n            while(start[i]==\\'X\\'){\\n                i++;\\n            }\\n            while(end[j]==\\'X\\'){\\n                j++;\\n            }\\n            if(start[i]!=end[j]){\\n                return false;\\n            }\\n            if(start[i]==\\'R\\' && j<i){\\n                return false;\\n            }\\n            if(start[i]==\\'L\\' && j>i){\\n                return false;\\n            }\\n            i++;j++;\\n        }\\n        \\n        while(i<len && start[i]==\\'X\\'){\\n            i++;\\n        }\\n        while(j<len && end[j]==\\'X\\'){\\n            j++;\\n        }\\n        if(i<len || j<len){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n\\n\\nPlease upvote incase you find my explaination useful.",
                "solutionTags": [
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {        \\n        \\n        int len = start.length();\\n        int i=0,j=0;\\n      \\n        while(i<len && j<len){\\n            while(start[i]==\\'X\\'){\\n                i++;\\n            }\\n            while(end[j]==\\'X\\'){\\n                j++;\\n            }\\n            if(start[i]!=end[j]){\\n                return false;\\n            }\\n            if(start[i]==\\'R\\' && j<i){\\n                return false;\\n            }\\n            if(start[i]==\\'L\\' && j>i){\\n                return false;\\n            }\\n            i++;j++;\\n        }\\n        \\n        while(i<len && start[i]==\\'X\\'){\\n            i++;\\n        }\\n        while(j<len && end[j]==\\'X\\'){\\n            j++;\\n        }\\n        if(i<len || j<len){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692037,
                "title": "java-simple-idea-and-clean-code-o-n-time-o-1-space",
                "content": "I found the brilliant idea and clean code at [here](https://gist.github.com/wangming2046/b5ac650ac565c0e37fd5886b68339201), so I share it.\\nThe key observations are same with problem\\'s hint:\\n- Think of the L and R as people on a horizontal line, where X is a space.\\n- L can only go to left spaces, R can only go to right spaces and the people can\\'t cross each other.\\n\\nAssume the index of **first** `L` character in `start` string is `i`, we iterate `end` string to find index `j` of **first**  `L` character in `end`.\\nWe can only convert `start` to `end` if  `i <= j`, otherwise it\\'s impossible.\\nFor example: the following case is okay\\nstart = \".....L..\"\\nend  = \"..L.....\"\\n\\nThe same thinking when met `R` character in `start`, but because `R` can only go to right spaces, we can only convert `start` to `end` if `i >= j`.\\n\\nThen, continue iterate `start` string and do same logic.\\n\\nAlgorithm:\\n- Define `j` pointer for `end` string.\\n- Iterate `start` string.\\n  - When met `L` in `start` string, increase `j` until `end.charAt(j) == \\'L\\'`, if `j > i` return false\\n  - When met `R` in `start` string, increase `j` until `end.charAt(j) == \\'R\\'`, if `j < i` return false\\n\\nImplementation:\\n\\n```java\\nclass Solution {\\n  \\n  public boolean canTransform(String start, String end) {\\n    \\n    if (start.replace(\"X\", \"\").length() != end.replace(\"X\", \"\").length()) {\\n      return false;\\n    }\\n    \\n    int len = start.length();\\n    int j = 0;\\n    for (int i = 0; i < len; i++) {\\n      \\n      if (start.charAt(i) == \\'L\\') {\\n        // find the next \\'L\\' position in \"end\"\\n        while (j < len && end.charAt(j) != \\'L\\') j += 1;\\n                \\n        // index of next \\'L\\' in \"end\" > index of \\'L\\' in \"start\", it\\'s impossible to convert start to end.\\n        // For example:\\n        // start = \"..L....\"\\n        // end   = \"....L..\"\\n        if (j > i) return false;\\n        \\n        j += 1;\\n      }       \\n      \\n      if (start.charAt(i) == \\'R\\') {\\n        // find the next \\'R\\' position in \"end\"\\n        while (j < len && end.charAt(j) != \\'R\\') j += 1;\\n        \\n        // index of next \\'R\\' in \"end\" < index of \\'R\\' in \"start\", it\\'s impossible to convert start to end.\\n        // For example:\\n        // start = \"....R...\"\\n        // end   = \"..R.....\"\\n        if (j < i) return false;\\n        \\n        j += 1;\\n      }      \\n    }\\n    \\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\nclass Solution {\\n  \\n  public boolean canTransform(String start, String end) {\\n    \\n    if (start.replace(\"X\", \"\").length() != end.replace(\"X\", \"\").length()) {\\n      return false;\\n    }\\n    \\n    int len = start.length();\\n    int j = 0;\\n    for (int i = 0; i < len; i++) {\\n      \\n      if (start.charAt(i) == \\'L\\') {\\n        // find the next \\'L\\' position in \"end\"\\n        while (j < len && end.charAt(j) != \\'L\\') j += 1;\\n                \\n        // index of next \\'L\\' in \"end\" > index of \\'L\\' in \"start\", it\\'s impossible to convert start to end.\\n        // For example:\\n        // start = \"..L....\"\\n        // end   = \"....L..\"\\n        if (j > i) return false;\\n        \\n        j += 1;\\n      }       \\n      \\n      if (start.charAt(i) == \\'R\\') {\\n        // find the next \\'R\\' position in \"end\"\\n        while (j < len && end.charAt(j) != \\'R\\') j += 1;\\n        \\n        // index of next \\'R\\' in \"end\" < index of \\'R\\' in \"start\", it\\'s impossible to convert start to end.\\n        // For example:\\n        // start = \"....R...\"\\n        // end   = \"..R.....\"\\n        if (j < i) return false;\\n        \\n        j += 1;\\n      }      \\n    }\\n    \\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676777,
                "title": "python-one-pass-o-n-time-o-1-space",
                "content": "Observations:\\n1. R can only be moved to right\\n2. L can only be moved to left\\n3. Relative order of R and L cannot be changed\\n\\nThus, at any given index `i`, number R in `start[:i+1]` >= in ` end[:i+1]`, number of L in `start[:i+1]` <= in `end[:i+1]`. \\n\\nSolution: go thru start and end from left to right, maintain two variables and both variables must be non-negative all the time (recall the observations above).\\n\\n+ `count_R`: count of R in `start[:i+1]` - count of R in `end[:i+1]`\\n+ `count_L`: count of L in `end[:i+1]` - count of L in `start[:i+1]`\\n\\nBesides, when we are waiting for a L in `start` (`count_L` > 0), we must see next L before next R in `start` (observation 3). Similarly, when we are waiting for a R in `end` (`count_R` > 0), we must see next R before next L in `end`.\\n\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        count_R = count_L = 0\\n\\t\\t\\n        for i in range(len(start)):\\n            if start[i] == \\'R\\':\\n                if count_L > 0:\\n                    return False\\n                count_R += 1\\n            if end[i] == \\'R\\':\\n                count_R -= 1\\n                if count_R < 0:\\n                    return False\\n            if end[i] == \\'L\\':\\n                if count_R > 0:\\n                    return False\\n                count_L += 1\\n            if start[i] == \\'L\\':\\n                count_L -= 1\\n                if count_L < 0: \\n                    return False\\n        if count_R or count_L:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        count_R = count_L = 0\\n\\t\\t\\n        for i in range(len(start)):\\n            if start[i] == \\'R\\':\\n                if count_L > 0:\\n                    return False\\n                count_R += 1\\n            if end[i] == \\'R\\':\\n                count_R -= 1\\n                if count_R < 0:\\n                    return False\\n            if end[i] == \\'L\\':\\n                if count_R > 0:\\n                    return False\\n                count_L += 1\\n            if start[i] == \\'L\\':\\n                count_L -= 1\\n                if count_L < 0: \\n                    return False\\n        if count_R or count_L:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494845,
                "title": "simplest-python-solution-o-n",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        \\n        so , eo , sind, eind = [],[],[],[]\\n        for i in range(len(start)):\\n            if start[i] != \\'X\\':\\n                so.append(start[i])\\n                sind.append(i)\\n            if end[i] != \\'X\\':\\n                eo.append(end[i])\\n                eind.append(i)\\n        if so != eo:\\n            return False\\n        \\n        for j in range(len(so)):\\n            if so[j] == \\'L\\' and eind[j]>sind[j]:\\n                return False\\n            if so[j] == \\'R\\' and eind[j]<sind[j]:\\n                return False\\n        \\n        return True\\n\\'\\'\\'\\nThe idea is to initialy check whether the starting and the ending position have the same order of R and L configuration. We can imagine that X is the space that L and R can move along the array. So, we can check whether we can move R to the right or L to the left with the provided space.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        \\n        so , eo , sind, eind = [],[],[],[]\\n        for i in range(len(start)):\\n            if start[i] != \\'X\\':\\n                so.append(start[i])\\n                sind.append(i)\\n            if end[i] != \\'X\\':\\n                eo.append(end[i])\\n                eind.append(i)\\n        if so != eo:\\n            return False\\n        \\n        for j in range(len(so)):\\n            if so[j] == \\'L\\' and eind[j]>sind[j]:\\n                return False\\n            if so[j] == \\'R\\' and eind[j]<sind[j]:\\n                return False\\n        \\n        return True\\n\\'\\'\\'\\nThe idea is to initialy check whether the starting and the ending position have the same order of R and L configuration. We can imagine that X is the space that L and R can move along the array. So, we can check whether we can move R to the right or L to the left with the provided space.",
                "codeTag": "Java"
            },
            {
                "id": 1176488,
                "title": "easy-to-follow-c-solution",
                "content": "We just need to record each \\'L\\' and \\'R\\' positions in both string, and compare them. Since \\'L\\' can only move left and \\'R\\' can only move right,  \\'L\\' position in end string should be <= that in start string. Similarly \\'R\\' position in end string should be >= that in start string.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        std::vector<std::pair<char, int>> pos1, pos2;\\n        for (int i = 0; i < start.size(); ++i) {\\n            if (start[i] != \\'X\\') {\\n                pos1.push_back(std::make_pair(start[i], i));\\n            }\\n            if (end[i] != \\'X\\') {\\n                pos2.push_back(std::make_pair(end[i], i));\\n            }\\n        }\\n        \\n        if (pos1.size() != pos2.size()) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < pos1.size(); ++i) {\\n            if (pos1[i].first != pos2[i].first) {\\n                return false;\\n            }\\n            \\n            if (pos1[i].first == \\'L\\' && pos1[i].second < pos2[i].second) {\\n                return false;\\n            }\\n            \\n            if (pos1[i].first == \\'R\\' && pos1[i].second > pos2[i].second) {\\n                return false;\\n            }\\n        }\\n    \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        std::vector<std::pair<char, int>> pos1, pos2;\\n        for (int i = 0; i < start.size(); ++i) {\\n            if (start[i] != \\'X\\') {\\n                pos1.push_back(std::make_pair(start[i], i));\\n            }\\n            if (end[i] != \\'X\\') {\\n                pos2.push_back(std::make_pair(end[i], i));\\n            }\\n        }\\n        \\n        if (pos1.size() != pos2.size()) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < pos1.size(); ++i) {\\n            if (pos1[i].first != pos2[i].first) {\\n                return false;\\n            }\\n            \\n            if (pos1[i].first == \\'L\\' && pos1[i].second < pos2[i].second) {\\n                return false;\\n            }\\n            \\n            if (pos1[i].first == \\'R\\' && pos1[i].second > pos2[i].second) {\\n                return false;\\n            }\\n        }\\n    \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186240,
                "title": "5ms-java-with-explanations",
                "content": "-- What does `either replacing one occurrence of \"XL\" with \"LX\", or replacing one occurrence of \"RX\" with \"XR\"` mean?\\nL and R cannot go across each other, that is, their relative order in a string doesn\\'t change.\\nMeanwhile, we should satisfy either one of cases below: \\n```\\ncase 1 : L = start[i] = end[j] and i >= j\\ncase 2 : R = start[i] = end[j] and i <= j\\n```\\nfor i, j are the index of next non-X character in start and end separately.\\n\\n```\\nFor example,\\n-- i = 0, j = 1 satisfies case 2\\nRXXL\\ni\\nXRLX\\n j\\n-- i = 3, j = 2 satisfies case 1\\nRXXL\\n   i\\nXRLX\\n  j\\n```\\nIn order to transfer start to end, they should own same number of Ls and Rs as well. That is, when one run out of non-Xs, the other cannot have non-Xs.\\n****\\n```\\n    public boolean canTransform(String start, String end) {       \\n        int i = 0, j = 0, len = start.length();\\n        \\n        while (i < len && j < len) {\\n            while (i < len && start.charAt(i) == \\'X\\')\\n                i++;\\n            while (j < len && end.charAt(j) == \\'X\\')\\n                j++;   \\n            if (i < len && j < len) {\\n                char chS = start.charAt(i);\\n                char chE = end.charAt(j);\\n                if ((chS != chE) || (chS == \\'L\\' && i < j) || (chS == \\'R\\' && i > j))\\n                    return false;\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        while (i < len) {\\n            if (start.charAt(i) != \\'X\\')\\n                return false;\\n            i++;\\n        }\\n        \\n        while (j < len) {\\n            if (end.charAt(j) != \\'X\\')\\n                return false;\\n            j++;\\n        }\\n        \\n        return true;\\n    }\\n```\\n**(\\uFF89>\\u03C9<)\\uFF89 Vote up, please!**",
                "solutionTags": [],
                "code": "```\\ncase 1 : L = start[i] = end[j] and i >= j\\ncase 2 : R = start[i] = end[j] and i <= j\\n```\n```\\nFor example,\\n-- i = 0, j = 1 satisfies case 2\\nRXXL\\ni\\nXRLX\\n j\\n-- i = 3, j = 2 satisfies case 1\\nRXXL\\n   i\\nXRLX\\n  j\\n```\n```\\n    public boolean canTransform(String start, String end) {       \\n        int i = 0, j = 0, len = start.length();\\n        \\n        while (i < len && j < len) {\\n            while (i < len && start.charAt(i) == \\'X\\')\\n                i++;\\n            while (j < len && end.charAt(j) == \\'X\\')\\n                j++;   \\n            if (i < len && j < len) {\\n                char chS = start.charAt(i);\\n                char chE = end.charAt(j);\\n                if ((chS != chE) || (chS == \\'L\\' && i < j) || (chS == \\'R\\' && i > j))\\n                    return false;\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        while (i < len) {\\n            if (start.charAt(i) != \\'X\\')\\n                return false;\\n            i++;\\n        }\\n        \\n        while (j < len) {\\n            if (end.charAt(j) != \\'X\\')\\n                return false;\\n            j++;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967526,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n        int i = 0, j = 0, n = s.size(), m = e.size();\\n        while(i < n || j < m) {\\n            while(s[i] == \\'X\\') i++;\\n            while(e[j] == \\'X\\') j++;\\n\\n            if(s[i] != e[j]) return false;\\n            if(s[i] == \\'R\\' && i > j) return false;\\n            if(s[i] == \\'L\\' && i < j) return false; \\n            i++, j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n        int i = 0, j = 0, n = s.size(), m = e.size();\\n        while(i < n || j < m) {\\n            while(s[i] == \\'X\\') i++;\\n            while(e[j] == \\'X\\') j++;\\n\\n            if(s[i] != e[j]) return false;\\n            if(s[i] == \\'R\\' && i > j) return false;\\n            if(s[i] == \\'L\\' && i < j) return false; \\n            i++, j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407359,
                "title": "easy-c-solution-basic-loops-easy-to-understand-for-begineers-proper-comment",
                "content": "***Read the comment for better understanding of the solution***\\n\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        string f,s; // to copy only original pattern from the string         \\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]!=\\'X\\') f+=start[i];  //take only elements to check their order\\n        }\\n        for(int i=0;i<end.size();i++)\\n        {\\n            if(end[i]!=\\'X\\') s+=end[i];     // to check the order of second and first string \\n        }\\n        \\n        if(f!=s) return false; // means both the string dont have the equal no. of elements and there is no swap in LR or RL\\n        \\n        //strat moving with this 2 pointer and check for index of left in both start and end string similarly for \\n        int i=0,j=0;\\n        while(i<start.size() and j<end.size())\\n        {\\n            if(start[i]==\\'X\\') i++; // move if dummy found;\\n            else if(end[j]==\\'X\\') j++; //move if dummy found in end\\n            else\\n            {\\n                if(start[i]==\\'L\\' and i<j ) return false;     //here the move if LX to XL which is invalid\\n                else if(start[i]==\\'R\\' and i>j) return false; //here the move if XR to RX which is invalid\\n                else {\\n                    i++;\\n                    j++;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        string f,s; // to copy only original pattern from the string         \\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]!=\\'X\\') f+=start[i];  //take only elements to check their order\\n        }\\n        for(int i=0;i<end.size();i++)\\n        {\\n            if(end[i]!=\\'X\\') s+=end[i];     // to check the order of second and first string \\n        }\\n        \\n        if(f!=s) return false; // means both the string dont have the equal no. of elements and there is no swap in LR or RL\\n        \\n        //strat moving with this 2 pointer and check for index of left in both start and end string similarly for \\n        int i=0,j=0;\\n        while(i<start.size() and j<end.size())\\n        {\\n            if(start[i]==\\'X\\') i++; // move if dummy found;\\n            else if(end[j]==\\'X\\') j++; //move if dummy found in end\\n            else\\n            {\\n                if(start[i]==\\'L\\' and i<j ) return false;     //here the move if LX to XL which is invalid\\n                else if(start[i]==\\'R\\' and i>j) return false; //here the move if XR to RX which is invalid\\n                else {\\n                    i++;\\n                    j++;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399870,
                "title": "a-joke-misunderstanding-to-me",
                "content": "Not sure if only me, but I first mis-understood the L, R switch can only happen one time, to either left or right position X.\\n\\nAnd the solution I wrote passed 59/94 test cases @_@\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2214373,
                "title": "c-two-pointers-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/swap-adjacent-in-lr-string/\\n    \\n    Things to note:\\n    1. Based on the swap patterns, L can be moved to left in presence of X\\n    2. R can be moved right in presence of X\\n    \\n    So that means it is only possible to swap and reach end iff each L in start lies atleast\\n    >= position compared to end and each R in start should be <= position compared to end.\\n    This is again due to the fact that L can only move left and R can move right.\\n    \\n    So we start traversal ignoring the X and focus on the breaking cases, if we don\\'t find any breaking cases\\n    then it is possible.\\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    bool twoPointerSol(string start, string end) {\\n        // both the strings have be of same size\\n        if(start.size() != end.size())\\n            return false;\\n        \\n        int n = start.size();\\n        int i = 0, j = 0;\\n        \\n        while(i < n && j < n) {\\n            // Get past all the X since these help move L or R\\n            while(i < n && start[i] == \\'X\\')\\n                ++i;\\n            while(j < n && end[j] == \\'X\\')\\n                ++j;\\n            \\n            // traversal finished, so it must be possible\\n            if(i == n && j == n)\\n                return true;\\n            \\n            // if the curr char is not same, then there is no way to match \\n            if(start[i] != end[j])\\n                return false;\\n            \\n            // If both point to R, then start\\'s ptr should be <= end\\'s ptr since\\n            // R can move towards right\\n            if(start[i] == \\'R\\' && i > j)\\n                return false;\\n            \\n            // If both point to L, then start\\'s ptr should be >= end\\'s ptr since\\n            // L can move towards left\\n            if(start[i] == \\'L\\' && i < j)\\n                return false;\\n            ++i, ++j;\\n        }\\n        \\n        // We might still have some chars left for one of the strings\\n        // Eg start = XXXXL, end = XLXXX \\n        // \\'i\\' will end first. So let the indices get past X and then check if they both finished processing\\n        while(i < n && start[i] == \\'X\\')\\n            ++i;\\n        while(j < n && end[j] == \\'X\\')\\n            ++j;\\n\\n        return i == j;\\n    }\\n    \\n    bool canTransform(string start, string end) {\\n        return twoPointerSol(start, end);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/swap-adjacent-in-lr-string/\\n    \\n    Things to note:\\n    1. Based on the swap patterns, L can be moved to left in presence of X\\n    2. R can be moved right in presence of X\\n    \\n    So that means it is only possible to swap and reach end iff each L in start lies atleast\\n    >= position compared to end and each R in start should be <= position compared to end.\\n    This is again due to the fact that L can only move left and R can move right.\\n    \\n    So we start traversal ignoring the X and focus on the breaking cases, if we don\\'t find any breaking cases\\n    then it is possible.\\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    bool twoPointerSol(string start, string end) {\\n        // both the strings have be of same size\\n        if(start.size() != end.size())\\n            return false;\\n        \\n        int n = start.size();\\n        int i = 0, j = 0;\\n        \\n        while(i < n && j < n) {\\n            // Get past all the X since these help move L or R\\n            while(i < n && start[i] == \\'X\\')\\n                ++i;\\n            while(j < n && end[j] == \\'X\\')\\n                ++j;\\n            \\n            // traversal finished, so it must be possible\\n            if(i == n && j == n)\\n                return true;\\n            \\n            // if the curr char is not same, then there is no way to match \\n            if(start[i] != end[j])\\n                return false;\\n            \\n            // If both point to R, then start\\'s ptr should be <= end\\'s ptr since\\n            // R can move towards right\\n            if(start[i] == \\'R\\' && i > j)\\n                return false;\\n            \\n            // If both point to L, then start\\'s ptr should be >= end\\'s ptr since\\n            // L can move towards left\\n            if(start[i] == \\'L\\' && i < j)\\n                return false;\\n            ++i, ++j;\\n        }\\n        \\n        // We might still have some chars left for one of the strings\\n        // Eg start = XXXXL, end = XLXXX \\n        // \\'i\\' will end first. So let the indices get past X and then check if they both finished processing\\n        while(i < n && start[i] == \\'X\\')\\n            ++i;\\n        while(j < n && end[j] == \\'X\\')\\n            ++j;\\n\\n        return i == j;\\n    }\\n    \\n    bool canTransform(string start, string end) {\\n        return twoPointerSol(start, end);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079699,
                "title": "simple-java-one-pass-o-n-moving-on-a-track",
                "content": "Imagine 2 kinds of pawn moving on a track, left pawn and right pawn. You want to push all the left pawns to the left and all the right pawns to the right.\\nThe right pawn will block all the left pawns from its right to move left, and the left pawn will block all the right pawns from its left to move right.\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int L1 = 0, L2 = 0, R1 = 0, R2 = 0;\\n        for (int i = 0; i < start.length(); i++) {\\n            char c1 = start.charAt(i), c2 = end.charAt(i);\\n\\t\\t\\t\\n            if (c1 == \\'R\\') {\\n\\t\\t\\t\\t// if we encounter a R in first string, the number of L on its left is fixed, not more L can added to its left.\\n                if (L1 != L2) return false;\\n                R1++;\\n            }else if (c1 == \\'L\\') {\\n\\t\\t\\t\\t// if we encounter a L in first string, the number of R on its left is fixed, it can\\'t decrease.\\n                if (R1 != R2) return false;\\n                L1++;\\n            }\\n            if (c2 == \\'L\\') {\\n                L2++;\\n            } else if (c2 == \\'R\\') {\\n                R2++;\\n            }\\n            \\n\\t\\t\\t// L can\\'t move right and R can\\'t move left\\n            if (L2 < L1 || R2 > R1) {\\n                return false;\\n            }\\n        }\\n        \\n\\t\\t// for case like \"XXXX\" \"LXXX\"\\n        return L1 == L2 && R1 == R2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int L1 = 0, L2 = 0, R1 = 0, R2 = 0;\\n        for (int i = 0; i < start.length(); i++) {\\n            char c1 = start.charAt(i), c2 = end.charAt(i);\\n\\t\\t\\t\\n            if (c1 == \\'R\\') {\\n\\t\\t\\t\\t// if we encounter a R in first string, the number of L on its left is fixed, not more L can added to its left.\\n                if (L1 != L2) return false;\\n                R1++;\\n            }else if (c1 == \\'L\\') {\\n\\t\\t\\t\\t// if we encounter a L in first string, the number of R on its left is fixed, it can\\'t decrease.\\n                if (R1 != R2) return false;\\n                L1++;\\n            }\\n            if (c2 == \\'L\\') {\\n                L2++;\\n            } else if (c2 == \\'R\\') {\\n                R2++;\\n            }\\n            \\n\\t\\t\\t// L can\\'t move right and R can\\'t move left\\n            if (L2 < L1 || R2 > R1) {\\n                return false;\\n            }\\n        }\\n        \\n\\t\\t// for case like \"XXXX\" \"LXXX\"\\n        return L1 == L2 && R1 == R2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855140,
                "title": "super-crisp-spoon-feeding-explanation-time-o-n",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    bool canTransform(string start, string end)\\n    {\\n        int si = 0;\\n        int ei = 0;\\n        \\n        while (si < start.size() || ei < end.size())\\n        {\\n\\t\\t    // Skip all \\'X\\' and find 1st letter after X in \\'start\\' & \\'end\\'.\\n            while (si < start.size() && start[si]==\\'X\\') si++;\\n            while (ei < end.size() && end[ei]==\\'X\\') ei++;\\n            \\n            // start = \"XXL\" --> start[si] = \\'L\\'\\n            // end   = \"RXX\" -->   end[ei] = \\'R\\'\\n            if (start[si] != end[ei])\\n                return false;\\n            \\n            // start = \"XXR\" --> start[si] = \\'R\\'\\n            // end   = \"RXX\" -->   end[ei] = \\'R\\'   --> XXR cannot be converted to RXX, i.e., si cannot be greater than ei\\n            if (start[si]==\\'R\\' && si>ei)\\n                return false;\\n            \\n            // start = \"LXX\" --> start[si] = \\'L\\'\\n            // end   = \"XXL\" -->   end[ei] = \\'L\\'   --> LXX cannot be converted to XXL, i.e., si cannot be less than ei\\n            if (start[si]==\\'L\\' && si<ei)\\n                return false;\\n            \\n            si++;\\n            ei++;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nPlease upvote if you understood the solution with my examples above. This will keep my spirits high. Thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    bool canTransform(string start, string end)\\n    {\\n        int si = 0;\\n        int ei = 0;\\n        \\n        while (si < start.size() || ei < end.size())\\n        {\\n\\t\\t    // Skip all \\'X\\' and find 1st letter after X in \\'start\\' & \\'end\\'.\\n            while (si < start.size() && start[si]==\\'X\\') si++;\\n            while (ei < end.size() && end[ei]==\\'X\\') ei++;\\n            \\n            // start = \"XXL\" --> start[si] = \\'L\\'\\n            // end   = \"RXX\" -->   end[ei] = \\'R\\'\\n            if (start[si] != end[ei])\\n                return false;\\n            \\n            // start = \"XXR\" --> start[si] = \\'R\\'\\n            // end   = \"RXX\" -->   end[ei] = \\'R\\'   --> XXR cannot be converted to RXX, i.e., si cannot be greater than ei\\n            if (start[si]==\\'R\\' && si>ei)\\n                return false;\\n            \\n            // start = \"LXX\" --> start[si] = \\'L\\'\\n            // end   = \"XXL\" -->   end[ei] = \\'L\\'   --> LXX cannot be converted to XXL, i.e., si cannot be less than ei\\n            if (start[si]==\\'L\\' && si<ei)\\n                return false;\\n            \\n            si++;\\n            ei++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845122,
                "title": "java-o-n-with-stack",
                "content": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        Stack<Integer> L = new Stack(), R = new Stack();\\n        for (int i = 0; i < start.length(); i++) {\\n            if (start.charAt(i) == \\'R\\')\\n                R.add(i);\\n            if (end.charAt(i) == \\'L\\')\\n                L.add(i);\\n            if (start.charAt(i) == \\'L\\') {\\n                if (L.isEmpty() || !R.isEmpty() && L.peek() >= R.peek())\\n                    return false;\\n                else \\n                    L.pop();\\n            } \\n            if (end.charAt(i) == \\'R\\') {\\n                if (R.isEmpty() || !L.isEmpty() && R.peek() >= L.peek())\\n                    return false;\\n                else\\n                    R.pop();\\n            } \\n        }\\n        if (!L.isEmpty() || !R.isEmpty())\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        Stack<Integer> L = new Stack(), R = new Stack();\\n        for (int i = 0; i < start.length(); i++) {\\n            if (start.charAt(i) == \\'R\\')\\n                R.add(i);\\n            if (end.charAt(i) == \\'L\\')\\n                L.add(i);\\n            if (start.charAt(i) == \\'L\\') {\\n                if (L.isEmpty() || !R.isEmpty() && L.peek() >= R.peek())\\n                    return false;\\n                else \\n                    L.pop();\\n            } \\n            if (end.charAt(i) == \\'R\\') {\\n                if (R.isEmpty() || !L.isEmpty() && R.peek() >= L.peek())\\n                    return false;\\n                else\\n                    R.pop();\\n            } \\n        }\\n        if (!L.isEmpty() || !R.isEmpty())\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731113,
                "title": "java-explained-easy-to-understand",
                "content": "// Replace all \\'X\\' in both strings and see if they are SAME then return true\\n// Whenever you see \\'X\\' just update the idx\\n\\n// TC : O(N) -> N = start.length\\n// SC : O(1)\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int startIdx = 0;\\n        int endIdx = 0;\\n        \\n        while(startIdx < start.length() || endIdx < end.length()) {\\n            while(startIdx < start.length() && start.charAt(startIdx) == \\'X\\') {\\n                startIdx++;\\n            }\\n            \\n            while(endIdx < end.length() && end.charAt(endIdx) == \\'X\\') {\\n                endIdx++;\\n            }\\n            \\n            if(startIdx >= start.length() || endIdx >= end.length()) break; // come out of while loop\\n            \\n            if(start.charAt(startIdx) != end.charAt(endIdx)) return false;\\n            \\n            // if the character is \\'L\\', it can only be moved to the LEFT. startIdx should be greater or equal to endIdx. \\n            if(start.charAt(startIdx) == \\'L\\' && endIdx > startIdx) {\\n                return false;\\n            }\\n            \\n            // if the character is \\'R\\', it can only be moved to the RIGHT. endIdx should be greater or equal to startIdx.\\n            if(start.charAt(startIdx) == \\'R\\' && startIdx > endIdx) {\\n                return false;\\n            }\\n            \\n            startIdx++;\\n            endIdx++;\\n        }\\n        \\n        return startIdx == endIdx; // if while loop exited because of the string (start or end) reach end but not other, return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int startIdx = 0;\\n        int endIdx = 0;\\n        \\n        while(startIdx < start.length() || endIdx < end.length()) {\\n            while(startIdx < start.length() && start.charAt(startIdx) == \\'X\\') {\\n                startIdx++;\\n            }\\n            \\n            while(endIdx < end.length() && end.charAt(endIdx) == \\'X\\') {\\n                endIdx++;\\n            }\\n            \\n            if(startIdx >= start.length() || endIdx >= end.length()) break; // come out of while loop\\n            \\n            if(start.charAt(startIdx) != end.charAt(endIdx)) return false;\\n            \\n            // if the character is \\'L\\', it can only be moved to the LEFT. startIdx should be greater or equal to endIdx. \\n            if(start.charAt(startIdx) == \\'L\\' && endIdx > startIdx) {\\n                return false;\\n            }\\n            \\n            // if the character is \\'R\\', it can only be moved to the RIGHT. endIdx should be greater or equal to startIdx.\\n            if(start.charAt(startIdx) == \\'R\\' && startIdx > endIdx) {\\n                return false;\\n            }\\n            \\n            startIdx++;\\n            endIdx++;\\n        }\\n        \\n        return startIdx == endIdx; // if while loop exited because of the string (start or end) reach end but not other, return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240151,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        if(start.length() == 1)\\n            return start == end;\\n        int n = start.length();\\n        int i = 0;\\n        int j = 0;\\n        while(1)\\n        {\\n            while(i<n and start[i] == \\'X\\')\\n                i++;\\n            while(j<n and end[j] == \\'X\\')\\n                j++;\\n            if(i==n or j==n)\\n                return i==j;\\n            if(start[i] != end[j])\\n                return false;\\n            if(start[i] == \\'R\\' and i>j)\\n                return false;\\n            if(start[i] == \\'L\\' and i<j)\\n                return false;\\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        if(start.length() == 1)\\n            return start == end;\\n        int n = start.length();\\n        int i = 0;\\n        int j = 0;\\n        while(1)\\n        {\\n            while(i<n and start[i] == \\'X\\')\\n                i++;\\n            while(j<n and end[j] == \\'X\\')\\n                j++;\\n            if(i==n or j==n)\\n                return i==j;\\n            if(start[i] != end[j])\\n                return false;\\n            if(start[i] == \\'R\\' and i>j)\\n                return false;\\n            if(start[i] == \\'L\\' and i<j)\\n                return false;\\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612851,
                "title": "simple-c-solution-with-explanation",
                "content": "Idea is that L moves backwards (XL->LX) and R moves forwards (RX->XR) so L is decremented and R is incremented. Parallely at the same position of end string, L will be incremented and R will be decremented. At any point, if the count of L or R becomes -ve then return false. \\n\\nNote that L cannot move beyond R and R cannot move beyond L. Like mentioned in the HINT.\\n\\nFor example: \\n\"XXXXXLXXXLXXXX\"\\n\"XXLXXXXXXXXLXX\"\\n\\nWhen start[i] has \\'L\\' it means, we should  have already encountered \\'L\\' in end string somewhere before this. In this example, for the second L which comes before second L in end string. Hence \\'L\\' count becomes -ve and answer is false.\\n\\nSimilarly, when end[i] has \\'R\\' it means, we should have already encountered \\'R\\' in start string before this. If thats not the case then again \\'R\\' count will become -ve and answer will be false.\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) \\n    {\\n        int L=0,R=0;\\n        \\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'L\\')\\n                L--,R=0; // Reset count of R to zero because previous \\'R\\' characters cannot move beyond \\'L\\' so reset it to zero.  If end[i] has \\'R\\' character then R becomes -ve and returns false or if there is L then L is incremented;\\n            else if(start[i]==\\'R\\')\\n                R++,L=0; // Reset count of L to zero because previous \\'L\\' characters cannot move beyond \\'R\\' so reset it to zero. If end[i] \\'R\\' then \\'R\\' count is decremented and if there is \\'L\\' then L is incremented;\\n            \\n            if(end[i]==\\'L\\')\\n                L++;\\n            else if(end[i]==\\'R\\')\\n                R--;\\n            \\n            if(L<0 or R<0)\\n                return false;\\n        }\\n        if(L>0 or R>0)\\n            return false;\\n        return true; // If both L and R are zero then return true else return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) \\n    {\\n        int L=0,R=0;\\n        \\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'L\\')\\n                L--,R=0; // Reset count of R to zero because previous \\'R\\' characters cannot move beyond \\'L\\' so reset it to zero.  If end[i] has \\'R\\' character then R becomes -ve and returns false or if there is L then L is incremented;\\n            else if(start[i]==\\'R\\')\\n                R++,L=0; // Reset count of L to zero because previous \\'L\\' characters cannot move beyond \\'R\\' so reset it to zero. If end[i] \\'R\\' then \\'R\\' count is decremented and if there is \\'L\\' then L is incremented;\\n            \\n            if(end[i]==\\'L\\')\\n                L++;\\n            else if(end[i]==\\'R\\')\\n                R--;\\n            \\n            if(L<0 or R<0)\\n                return false;\\n        }\\n        if(L>0 or R>0)\\n            return false;\\n        return true; // If both L and R are zero then return true else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448005,
                "title": "c-solution-with-explanation",
                "content": "We can only move \"R\" backwards and \"L\" forward as we can convert \"XL\" to \"LX\" and \"RX\" to \"XR\"\\n\\n    - Maintain count of R\\'s found in the \"start\" string to match with \"end\"\\n        - BECAUSE WE CAN ONLY MOVE \"R\" BACK WE INC THEM WHEN WE FIND THEM IN \"start\" AND DECREMENT IN \"end\" (matching step)\\n        \\n    - Maintain count of L\\'s found in the \"end\" string to match with \"start\"\\n        - BECAUSE WE CAN ONLY MOVE \"L\" FWD WE INC THEM WHEN WE FIND THEM IN \"end\" AND DECREMENT IN \"start\" (matching step)\\n\\n    - If at any point  we have unmatched \"R\" or \"L\" we can return false\\n   \\n   \\n```\\nbool canTransform(string start, string end) {\\n        int i = 0;\\n        int fwdL = 0, bwdR = 0;\\n        \\n        while (i < start.size()) {\\n            \\n            if (start[i] == \\'R\\') bwdR++;\\n            \\n            if (end[i]   == \\'L\\') fwdL++;\\n            \\n            if (end[i]   == \\'R\\') bwdR--;\\n            \\n            if (start[i] == \\'L\\') fwdL--;\\n            \\n\\t\\t\\t /* If we have more R\\'s or L\\'s that can be matched or if a cross over b/w R & L has occured (indicated by both +ve) we can\\'t transform further*/\\n            if ((bwdR > 0 && fwdL > 0) || (bwdR < 0 || fwdL < 0))\\n                return false;\\n            \\n            i++;\\n        }\\n        \\n        return fwdL == 0 && bwdR == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canTransform(string start, string end) {\\n        int i = 0;\\n        int fwdL = 0, bwdR = 0;\\n        \\n        while (i < start.size()) {\\n            \\n            if (start[i] == \\'R\\') bwdR++;\\n            \\n            if (end[i]   == \\'L\\') fwdL++;\\n            \\n            if (end[i]   == \\'R\\') bwdR--;\\n            \\n            if (start[i] == \\'L\\') fwdL--;\\n            \\n\\t\\t\\t /* If we have more R\\'s or L\\'s that can be matched or if a cross over b/w R & L has occured (indicated by both +ve) we can\\'t transform further*/\\n            if ((bwdR > 0 && fwdL > 0) || (bwdR < 0 || fwdL < 0))\\n                return false;\\n            \\n            i++;\\n        }\\n        \\n        return fwdL == 0 && bwdR == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359483,
                "title": "straightforward-python-solution",
                "content": "Based on the rules, we can move \\'L\\' to left, \\'R\\' to right without crossing any \\'L\\' or \\'R\\'.\\n```\\n    def canTransform(self, start: str, end: str) -> bool:\\n        n = len(start)\\n        groups_start = [[start[i], i] for i in range(n) if start[i] != \\'X\\']\\n        groups_end = [[end[i], i] for i in range(n) if end[i] != \\'X\\']\\n        if len(groups_start) != len(groups_end):\\n            return False\\n        for i in range(len(groups_start)):\\n            c_s, i_s = groups_start[i]\\n            c_e, i_e = groups_end[i]\\n            if c_s != c_e:\\n                return False\\n            elif c_s == \\'R\\':\\n                if i_s > i_e:\\n                    return False\\n            else:\\n                if i_s < i_e:\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def canTransform(self, start: str, end: str) -> bool:\\n        n = len(start)\\n        groups_start = [[start[i], i] for i in range(n) if start[i] != \\'X\\']\\n        groups_end = [[end[i], i] for i in range(n) if end[i] != \\'X\\']\\n        if len(groups_start) != len(groups_end):\\n            return False\\n        for i in range(len(groups_start)):\\n            c_s, i_s = groups_start[i]\\n            c_e, i_e = groups_end[i]\\n            if c_s != c_e:\\n                return False\\n            elif c_s == \\'R\\':\\n                if i_s > i_e:\\n                    return False\\n            else:\\n                if i_s < i_e:\\n                    return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3299186,
                "title": "short-and-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n        int i = 0, j = 0, n = s.size(), m = e.size();\\n        while(i < n || j < m) {\\n            while(s[i] == \\'X\\') i++;\\n            while(e[j] == \\'X\\') j++;\\n\\n            if(s[i] != e[j]) return false;\\n            if(s[i] == \\'R\\' && i > j) return false;\\n            if(s[i] == \\'L\\' && i < j) return false; \\n            i++, j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n        int i = 0, j = 0, n = s.size(), m = e.size();\\n        while(i < n || j < m) {\\n            while(s[i] == \\'X\\') i++;\\n            while(e[j] == \\'X\\') j++;\\n\\n            if(s[i] != e[j]) return false;\\n            if(s[i] == \\'R\\' && i > j) return false;\\n            if(s[i] == \\'L\\' && i < j) return false; \\n            i++, j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881228,
                "title": "python-with-explanation",
                "content": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        # replace x with empty string to make sure the left R and L are in same order\\n        if start.replace(\"X\",\"\") != end.replace(\"X\",\"\"):\\n            return False\\n        n = len(start)\\n        i = j = 0\\n        # check the index of L in start is more than end(Only XL to LX, L index decrease )\\n        # check the index of R in start is less than end (Only RX to XR, R index increase )\\n        while True:\\n            while i < n and start[i] == \"X\":\\n                i += 1\\n            while j < n and end[j] == \"X\":\\n                j += 1\\n            #if approach the end of start, all the L R statisfied the requirement\\n            if i == n: return True\\n            if start[i] == \"L\" and i < j: return False\\n            if start[i] == \"R\" and i > j: return False\\n            i += 1\\n            j += 1\\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        # replace x with empty string to make sure the left R and L are in same order\\n        if start.replace(\"X\",\"\") != end.replace(\"X\",\"\"):\\n            return False\\n        n = len(start)\\n        i = j = 0\\n        # check the index of L in start is more than end(Only XL to LX, L index decrease )\\n        # check the index of R in start is less than end (Only RX to XR, R index increase )\\n        while True:\\n            while i < n and start[i] == \"X\":\\n                i += 1\\n            while j < n and end[j] == \"X\":\\n                j += 1\\n            #if approach the end of start, all the L R statisfied the requirement\\n            if i == n: return True\\n            if start[i] == \"L\" and i < j: return False\\n            if start[i] == \"R\" and i > j: return False\\n            i += 1\\n            j += 1\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868735,
                "title": "javascript-two-pointer-with-comments",
                "content": "```\\n/**\\n* @param {string} start\\n* @param {string} end\\n* @return {boolean}\\n*/\\nvar canTransform = function (start, end) {\\n    const sWithoutX = start.replace(/X/g, \\'\\');\\n    const eWithoutX = end.replace(/X/g, \\'\\');\\n\\n    // start and end text without x\\'s should equal\\n    if (sWithoutX !== eWithoutX) return false;\\n\\n    const sCount = { l: 0, r: 0 };\\n    const eCount = { l: 0, r: 0 };\\n\\n    // iterate through original start string\\n    for (let i = 0; i < start.length; i++) {\\n        \\n        // track occurances of L\\'s and R\\'s\\n        if (start[i] === \\'L\\') {\\n            sCount.l++;\\n        } else if (start[i] === \\'R\\') {\\n            sCount.r++;\\n        }\\n\\n        // also track L/R occurances on end string\\n        if (end[i] === \\'L\\') {\\n            eCount.l++;\\n        } else if (end[i] === \\'R\\') {\\n            eCount.r++;\\n        }\\n\\n        // if at any point during iteration, start has more l\\'s than end\\n        // or if start has less r\\'s than end - path impossible\\n        if (sCount.l > eCount.l || sCount.r < eCount.r) return false;\\n    }\\n    \\n    return true;\\n \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n* @param {string} start\\n* @param {string} end\\n* @return {boolean}\\n*/\\nvar canTransform = function (start, end) {\\n    const sWithoutX = start.replace(/X/g, \\'\\');\\n    const eWithoutX = end.replace(/X/g, \\'\\');\\n\\n    // start and end text without x\\'s should equal\\n    if (sWithoutX !== eWithoutX) return false;\\n\\n    const sCount = { l: 0, r: 0 };\\n    const eCount = { l: 0, r: 0 };\\n\\n    // iterate through original start string\\n    for (let i = 0; i < start.length; i++) {\\n        \\n        // track occurances of L\\'s and R\\'s\\n        if (start[i] === \\'L\\') {\\n            sCount.l++;\\n        } else if (start[i] === \\'R\\') {\\n            sCount.r++;\\n        }\\n\\n        // also track L/R occurances on end string\\n        if (end[i] === \\'L\\') {\\n            eCount.l++;\\n        } else if (end[i] === \\'R\\') {\\n            eCount.r++;\\n        }\\n\\n        // if at any point during iteration, start has more l\\'s than end\\n        // or if start has less r\\'s than end - path impossible\\n        if (sCount.l > eCount.l || sCount.r < eCount.r) return false;\\n    }\\n    \\n    return true;\\n \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833458,
                "title": "python-o-n-solution-with-explanation",
                "content": "idea:\\n1. each time we saw a L in end string, it means that we must find a L in start (increase the debtL)\\n2. each time we saw a R in end string, it means that we must already found a R in start (decrease the debtR)\\n3. in case of RL, L cannot move left of R, so if this L is a matching L, at the time we found this L, the debtR must be zero; similarly, if it\\'s a matching R, debtL must be zero\\n\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n\\n        n = len(start)\\n        debtL = 0\\n        debtR = 0\\n        \\n        for i in range(n):\\n            if end[i] == \\'L\\':\\n                debtL += 1\\n            elif end[i] == \\'R\\':\\n                debtR -= 1\\n                \\n            if start[i] == \\'L\\' and debtR == 0:\\n                debtL -= 1\\n            elif start[i] == \\'R\\' and debtL == 0:\\n                debtR += 1\\n                \\n            if debtL < 0 or debtR < 0:\\n                return False\\n            \\n        return debtL == 0 and debtR == 0",
                "solutionTags": [],
                "code": "idea:\\n1. each time we saw a L in end string, it means that we must find a L in start (increase the debtL)\\n2. each time we saw a R in end string, it means that we must already found a R in start (decrease the debtR)\\n3. in case of RL, L cannot move left of R, so if this L is a matching L, at the time we found this L, the debtR must be zero; similarly, if it\\'s a matching R, debtL must be zero\\n\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n\\n        n = len(start)\\n        debtL = 0\\n        debtR = 0\\n        \\n        for i in range(n):\\n            if end[i] == \\'L\\':\\n                debtL += 1\\n            elif end[i] == \\'R\\':\\n                debtR -= 1\\n                \\n            if start[i] == \\'L\\' and debtR == 0:\\n                debtL -= 1\\n            elif start[i] == \\'R\\' and debtL == 0:\\n                debtR += 1\\n                \\n            if debtL < 0 or debtR < 0:\\n                return False\\n            \\n        return debtL == 0 and debtR == 0",
                "codeTag": "Java"
            },
            {
                "id": 1708832,
                "title": "a-solution-that-moves-x-if-you-find-this-easier-to-understand",
                "content": "The move is as follows:\\n\\n1. X can go through R to move to the left\\nRRRX. -> XRRR\\n\\n2. X can go through L to move to the right\\nXLLL -> LLLX\\n\\nNow go from left to right, have counter to save number of \\'X\\' in end minus number of \\'X\\' in start\\n```\\ncount = #\\'X\\' in end - #\\'X\\' in start\\n```\\n\\nThere could be two scenarios:\\n\\n         count > 0 means there\\'s an X in start need to move left -> it must go through \\'R\\' in start, not an \\'L\\'\\n                 i\\n         start:  R R X\\n         end  :  X R R\\n       \\n         count < 0 means there\\'s an X in start need to move right -> it must go through \\'L\\' in start, not an \\'R\\'\\n                 i\\n         start:  X L L\\n         end  :  L L X\\n        \\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int n = start.length();\\n        \\n        //check if R and L count match\\n        String s1 = start.replace(\"X\", \"\");\\n        String s2 = end.replace(\"X\", \"\");\\n        if (!s1.equals(s2)) {\\n            return false;\\n        }\\n\\t\\t\\n        // count: go from left to right. Number of X in end - Number of X in start\\n        int count = 0; \\n        while(i < n) { \\n\\t\\t\\t// need to move right through \\'L\\', but there\\'s an \\'R\\'\\n\\t\\t    if (count < 0 && start.charAt(i) == \\'R\\') {\\n                return false;\\n            }\\n            if (end.charAt(i) == \\'X\\') {\\n                count++;\\n            }\\n            if (start.charAt(i) == \\'X\\') {\\n                count--;\\n            }\\n\\t\\t\\t// need to move left through \\'R\\', but there\\'s an \\'L\\'\\n            if (count > 0 && start.charAt(i) == \\'L\\') {\\n                return false;\\n            }            \\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ncount = #\\'X\\' in end - #\\'X\\' in start\\n```\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int n = start.length();\\n        \\n        //check if R and L count match\\n        String s1 = start.replace(\"X\", \"\");\\n        String s2 = end.replace(\"X\", \"\");\\n        if (!s1.equals(s2)) {\\n            return false;\\n        }\\n\\t\\t\\n        // count: go from left to right. Number of X in end - Number of X in start\\n        int count = 0; \\n        while(i < n) { \\n\\t\\t\\t// need to move right through \\'L\\', but there\\'s an \\'R\\'\\n\\t\\t    if (count < 0 && start.charAt(i) == \\'R\\') {\\n                return false;\\n            }\\n            if (end.charAt(i) == \\'X\\') {\\n                count++;\\n            }\\n            if (start.charAt(i) == \\'X\\') {\\n                count--;\\n            }\\n\\t\\t\\t// need to move left through \\'R\\', but there\\'s an \\'L\\'\\n            if (count > 0 && start.charAt(i) == \\'L\\') {\\n                return false;\\n            }            \\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462315,
                "title": "c-two-pointers-o-n",
                "content": "The key is that we only can make \\'L\\' backword and \\'R\\' forward.\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n = start.size();\\n        int i = 0, j = 0;\\n        \\n        for( ; j < n; j++){\\n            if (end[j] == \\'X\\') continue;\\n            \\n            while (i < n && start[i] == \\'X\\') i++;\\n            \\n            if (i == n) return false;\\n            \\n            if (end[j] == \\'L\\'){\\n                if (i < j || start[i] != \\'L\\') return false; //we only can make \\'L\\' backword\\n            }else{\\n                if (i > j || start[i] != \\'R\\') return false; //we only can make \\'R\\' forward\\n            }\\n            i++;\\n        }\\n        \\n        while (i < n && start[i] == \\'X\\') i++;\\n        \\n        return i == n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n = start.size();\\n        int i = 0, j = 0;\\n        \\n        for( ; j < n; j++){\\n            if (end[j] == \\'X\\') continue;\\n            \\n            while (i < n && start[i] == \\'X\\') i++;\\n            \\n            if (i == n) return false;\\n            \\n            if (end[j] == \\'L\\'){\\n                if (i < j || start[i] != \\'L\\') return false; //we only can make \\'L\\' backword\\n            }else{\\n                if (i > j || start[i] != \\'R\\') return false; //we only can make \\'R\\' forward\\n            }\\n            i++;\\n        }\\n        \\n        while (i < n && start[i] == \\'X\\') i++;\\n        \\n        return i == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169583,
                "title": "java-simple-solution-o-n",
                "content": "rnum:  there are rnum of \\'R\\' need to move to right;\\nlnum: there are lnum of \\'L\\' need to move to left;\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (start.length() != end.length()) return false;\\n        int rnum = 0, lnum = 0;\\n        for (int i = 0; i < start.length(); i++) {\\n            if (start.charAt(i) == \\'R\\') {\\n                rnum++;\\n            }\\n            if (start.charAt(i) == \\'L\\') {\\n                lnum--;\\n            }\\n\\t\\t\\t// if there are R need to move to right , but there are some L obstacles \\n            if (rnum > 0 && lnum != 0) return false;\\n            if (end.charAt(i) == \\'R\\') {\\n                rnum--;\\n            }\\n            if (end.charAt(i) == \\'L\\') {\\n                lnum++;\\n            }\\n\\t\\t\\t// there are R in right , or L in left\\n            if (rnum < 0 || lnum < 0) return false;\\n\\t\\t\\t// there are obstacles when we move R or L;\\n            if (rnum > 0 && lnum > 0) return false;\\n        }\\n        return rnum == 0 && lnum == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (start.length() != end.length()) return false;\\n        int rnum = 0, lnum = 0;\\n        for (int i = 0; i < start.length(); i++) {\\n            if (start.charAt(i) == \\'R\\') {\\n                rnum++;\\n            }\\n            if (start.charAt(i) == \\'L\\') {\\n                lnum--;\\n            }\\n\\t\\t\\t// if there are R need to move to right , but there are some L obstacles \\n            if (rnum > 0 && lnum != 0) return false;\\n            if (end.charAt(i) == \\'R\\') {\\n                rnum--;\\n            }\\n            if (end.charAt(i) == \\'L\\') {\\n                lnum++;\\n            }\\n\\t\\t\\t// there are R in right , or L in left\\n            if (rnum < 0 || lnum < 0) return false;\\n\\t\\t\\t// there are obstacles when we move R or L;\\n            if (rnum > 0 && lnum > 0) return false;\\n        }\\n        return rnum == 0 && lnum == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134932,
                "title": "java-solution-beats-99-and-99-one-pass",
                "content": "I thought it\\'s a bit funny it was categorized as \"brainteaser\", why don\\'t they put it under \"String\"?\\n\\nSeveral observations:\\n1. `L` can be moved all the way to the left with the help of `X`\\n2. `R` can be moved all the way to the right with the help of `X`\\n3. `L` and `R` can not switch positions under any circumstances\\n\\n```java\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (start.length() != end.length()) return false;\\n        char[] chars1 = start.toCharArray(), chars2 = end.toCharArray();\\n        int p1 = 0, p2 = 0, count = 0;\\n        while (p1 < chars1.length || p2 < chars2.length) {\\n            while (p1 < chars1.length && chars1[p1] == \\'X\\') {\\n                count++;\\n                p1++;\\n            }\\n            while (p2 < chars2.length && chars2[p2] == \\'X\\') {\\n                count--;\\n                p2++;\\n            }\\n            if (p1 == chars1.length || p2 == chars2.length) break;\\n            if (chars1[p1] != chars2[p2]) return false;\\n            if (chars1[p1] == \\'L\\' && p1 < p2) return false;\\n            if (chars1[p1] == \\'R\\' && p1 > p2) return false;\\n            p1++;\\n            p2++;\\n        }\\n        return count == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (start.length() != end.length()) return false;\\n        char[] chars1 = start.toCharArray(), chars2 = end.toCharArray();\\n        int p1 = 0, p2 = 0, count = 0;\\n        while (p1 < chars1.length || p2 < chars2.length) {\\n            while (p1 < chars1.length && chars1[p1] == \\'X\\') {\\n                count++;\\n                p1++;\\n            }\\n            while (p2 < chars2.length && chars2[p2] == \\'X\\') {\\n                count--;\\n                p2++;\\n            }\\n            if (p1 == chars1.length || p2 == chars2.length) break;\\n            if (chars1[p1] != chars2[p2]) return false;\\n            if (chars1[p1] == \\'L\\' && p1 < p2) return false;\\n            if (chars1[p1] == \\'R\\' && p1 > p2) return false;\\n            p1++;\\n            p2++;\\n        }\\n        return count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797397,
                "title": "easy-python",
                "content": "```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        # Same number of L and R\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'):\\n            return False\\n        # L can only move left and R can only move right\\n        l_start = [i for i, c in enumerate(start) if c == \\'L\\']\\n        r_start = [i for i, c in enumerate(start) if c == \\'R\\']\\n        l_end = [i for i, c in enumerate(end) if c == \\'L\\']\\n        r_end = [i for i, c in enumerate(end) if c == \\'R\\']\\n        if any(l_start[i] < l_end[i] for i in range(len(l_start))):\\n            return False\\n        if any(r_start[i] > r_end[i] for i in range(len(r_start))):\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        # Same number of L and R\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'):\\n            return False\\n        # L can only move left and R can only move right\\n        l_start = [i for i, c in enumerate(start) if c == \\'L\\']\\n        r_start = [i for i, c in enumerate(start) if c == \\'R\\']\\n        l_end = [i for i, c in enumerate(end) if c == \\'L\\']\\n        r_end = [i for i, c in enumerate(end) if c == \\'R\\']\\n        if any(l_start[i] < l_end[i] for i in range(len(l_start))):\\n            return False\\n        if any(r_start[i] > r_end[i] for i in range(len(r_start))):\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703305,
                "title": "simple-c-o-n-stack-solution-beats-90",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        stack<pair<char, int>> st1, st2;\\n        if (start.length() != end.length()) return false;\\n        for (int i = 0; i < start.length(); i++) {\\n            if (start[i] != \\'X\\')    st1.push(make_pair(start[i], i));\\n            if (end[i] != \\'X\\')  st2.push(make_pair(end[i], i));\\n        }\\n        if (st1.size() != st2.size())   return false;\\n        while (!st1.empty()) {\\n            char ch1 = st1.top().first, ch2 = st2.top().first;\\n            int pos1 = st1.top().second, pos2 = st2.top().second;\\n            st1.pop();\\n            st2.pop();\\n            if (ch1 != ch2) return false;\\n            if (ch1 == \\'R\\') {\\n                if (pos1 > pos2)   return false;    \\n            } else {\\n                if (pos1 < pos2)   return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        stack<pair<char, int>> st1, st2;\\n        if (start.length() != end.length()) return false;\\n        for (int i = 0; i < start.length(); i++) {\\n            if (start[i] != \\'X\\')    st1.push(make_pair(start[i], i));\\n            if (end[i] != \\'X\\')  st2.push(make_pair(end[i], i));\\n        }\\n        if (st1.size() != st2.size())   return false;\\n        while (!st1.empty()) {\\n            char ch1 = st1.top().first, ch2 = st2.top().first;\\n            int pos1 = st1.top().second, pos2 = st2.top().second;\\n            st1.pop();\\n            st2.pop();\\n            if (ch1 != ch2) return false;\\n            if (ch1 == \\'R\\') {\\n                if (pos1 > pos2)   return false;    \\n            } else {\\n                if (pos1 < pos2)   return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331767,
                "title": "really-concise-and-fast-c-code-8ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n = start.length();\\n        if(n != end.length()) return false;\\n        int l1 = 0, l2 = 0, r1 = 0, r2 = 0;\\n        for(int i = 0; i < n; ++i){\\n            if(start[i] == \\'L\\') ++l1;\\n            else if(start[i] == \\'R\\') ++r1;\\n            if(end[i] == \\'L\\') ++l2;\\n            else if(end[i] == \\'R\\') ++r2;\\n            if(l1 > l2 || r1 < r2 || (l1 < l2 && r1 > r2)) return false;\\n        }\\n        return l1==l2 && r1==r2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n = start.length();\\n        if(n != end.length()) return false;\\n        int l1 = 0, l2 = 0, r1 = 0, r2 = 0;\\n        for(int i = 0; i < n; ++i){\\n            if(start[i] == \\'L\\') ++l1;\\n            else if(start[i] == \\'R\\') ++r1;\\n            if(end[i] == \\'L\\') ++l2;\\n            else if(end[i] == \\'R\\') ++r2;\\n            if(l1 > l2 || r1 < r2 || (l1 < l2 && r1 > r2)) return false;\\n        }\\n        return l1==l2 && r1==r2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321932,
                "title": "one-pass-o-n-python-beat-99-easy-to-understand",
                "content": "The idea is keep a variable ```count```. For ```start```, R plus 1, L minus 1, opposite for ```end```. And they should meet two rules:\\n1.The count could not be less than 0.\\nOne example is \"XR\" and \"RX\". Remember you can only replace strings in start, not end.\\n2.The difference could never be 2 or -2.\\nOne example is \"RL\" and \"LR\". The reason is to move the letter \"R\", you have to make sure there is always a \"X\" on the right of it. Same for \"L\".\\n\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        n = len(start)\\n        value = {\"R\":1,\"X\":0,\"L\":-1}\\n        count = 0\\n        for i in range(n):\\n            diff = value[start[i]]-value[end[i]]\\n            count+=diff\\n            if count < 0 or abs(diff) == 2:\\n                return False\\n        return count == 0\\n```",
                "solutionTags": [],
                "code": "```count```\n```start```\n```end```\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        n = len(start)\\n        value = {\"R\":1,\"X\":0,\"L\":-1}\\n        count = 0\\n        for i in range(n):\\n            diff = value[start[i]]-value[end[i]]\\n            count+=diff\\n            if count < 0 or abs(diff) == 2:\\n                return False\\n        return count == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303200,
                "title": "4ms-99-simple-c-solution",
                "content": "The relative position of R and L can\\'t be changed. Since R can only move back and L can only move forward, the position of R in the \"end\" can\\'t be less than it in the start, the position of L in the \"end\" can\\'t be larger than that of in the \"start\". \"X\"s are like \"spaces\". \\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        if(start.size()!=end.size()) return false;\\n        int i=0, j=0;\\n        while(i<start.size() && j<end.size()){\\n            while(start[i]==\\'X\\') i++;\\n            while(end[j]==\\'X\\') j++;\\n            if(start[i]!=end[j]) return false;\\n            if(start[i]==\\'R\\' && i>j) return false;\\n            if(start[i]==\\'L\\' && i<j) return false;\\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        if(start.size()!=end.size()) return false;\\n        int i=0, j=0;\\n        while(i<start.size() && j<end.size()){\\n            while(start[i]==\\'X\\') i++;\\n            while(end[j]==\\'X\\') j++;\\n            if(start[i]!=end[j]) return false;\\n            if(start[i]==\\'R\\' && i>j) return false;\\n            if(start[i]==\\'L\\' && i<j) return false;\\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241082,
                "title": "one-pass-o-n-python-solution",
                "content": "We just need to keep track of two counters.\\n```\\nclass Solution:\\n    def canTransform(self, start: \\'str\\', end: \\'str\\') -> \\'bool\\':\\n        countR = 0\\n        countL = 0\\n        for idx in range(len(start)):\\n            if start[idx] == \\'R\\':\\n                countR += 1\\n            if end[idx] == \\'L\\':\\n                countL += 1\\n                \\n            if countR > 0 and countL > 0:\\n                return False\\n            \\n            if start[idx] == \\'L\\':\\n                countL -= 1\\n            if end[idx] == \\'R\\':\\n                countR -= 1\\n            \\n            if countR < 0 or countL < 0:\\n                return False\\n        \\n        return countR == 0 and countL == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: \\'str\\', end: \\'str\\') -> \\'bool\\':\\n        countR = 0\\n        countL = 0\\n        for idx in range(len(start)):\\n            if start[idx] == \\'R\\':\\n                countR += 1\\n            if end[idx] == \\'L\\':\\n                countL += 1\\n                \\n            if countR > 0 and countL > 0:\\n                return False\\n            \\n            if start[idx] == \\'L\\':\\n                countL -= 1\\n            if end[idx] == \\'R\\':\\n                countR -= 1\\n            \\n            if countR < 0 or countL < 0:\\n                return False\\n        \\n        return countR == 0 and countL == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462893,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool canTransform(string st, string tar) {\\n        int n=tar.length();\\n        int i=0,j=0;\\n        while(i<=n && j<=n){\\n            while(i<n && tar[i]==\\'X\\') i++;\\n            while(j<n && st[j]==\\'X\\') j++;\\n            if(i==n || j==n)\\n                return i==n && j==n;\\n            if(tar[i]!=st[j] || (tar[i]==\\'L\\' && j<i) || (tar[i]==\\'R\\' && i<j)) return false;\\n            i++,j++;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        countR = countL = 0\\n        for i in range(len(start)):\\n            if start[i]==\\'R\\':\\n                if countL > 0:\\n                    return False\\n                countR += 1\\n            if end[i]==\\'R\\':\\n                countR -= 1\\n                if countR < 0:\\n                    return False\\n            if end[i]==\\'L\\':\\n                if countR > 0:\\n                    return False\\n                countL+=1\\n            if start[i]==\\'L\\':\\n                countL -= 1\\n                if countL < 0:\\n                    return False\\n        if countR or countL:\\n            return False\\n        return True \\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int i = 0;\\n        int j = 0;\\n        char[] s = start.toCharArray();\\n        char[] e = end.toCharArray();\\n        while (i < s.length || j < e.length)\\n        {\\n            while (i<s.length && s[i] == \\'X\\') { \\n                i++; \\n            }\\n            while (j<e.length && e[j] == \\'X\\') {\\n                j++; \\n            }\\n            if (i == s.length || j == e.length) {\\n                break; \\n            }\\n            if (s[i] != e[j] || (s[i] == \\'R\\' && i > j) || (s[i] == \\'L\\' && i < j)) {\\n                return false; \\n            }\\n            i++;\\n            j++;\\n        }\\n        return i == j;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool canTransform(string st, string tar) {\\n        int n=tar.length();\\n        int i=0,j=0;\\n        while(i<=n && j<=n){\\n            while(i<n && tar[i]==\\'X\\') i++;\\n            while(j<n && st[j]==\\'X\\') j++;\\n            if(i==n || j==n)\\n                return i==n && j==n;\\n            if(tar[i]!=st[j] || (tar[i]==\\'L\\' && j<i) || (tar[i]==\\'R\\' && i<j)) return false;\\n            i++,j++;\\n        }\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        countR = countL = 0\\n        for i in range(len(start)):\\n            if start[i]==\\'R\\':\\n                if countL > 0:\\n                    return False\\n                countR += 1\\n            if end[i]==\\'R\\':\\n                countR -= 1\\n                if countR < 0:\\n                    return False\\n            if end[i]==\\'L\\':\\n                if countR > 0:\\n                    return False\\n                countL+=1\\n            if start[i]==\\'L\\':\\n                countL -= 1\\n                if countL < 0:\\n                    return False\\n        if countR or countL:\\n            return False\\n        return True \\n```\n```Java []\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int i = 0;\\n        int j = 0;\\n        char[] s = start.toCharArray();\\n        char[] e = end.toCharArray();\\n        while (i < s.length || j < e.length)\\n        {\\n            while (i<s.length && s[i] == \\'X\\') { \\n                i++; \\n            }\\n            while (j<e.length && e[j] == \\'X\\') {\\n                j++; \\n            }\\n            if (i == s.length || j == e.length) {\\n                break; \\n            }\\n            if (s[i] != e[j] || (s[i] == \\'R\\' && i > j) || (s[i] == \\'L\\' && i < j)) {\\n                return false; \\n            }\\n            i++;\\n            j++;\\n        }\\n        return i == j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826070,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        \\n        int i=0, j=0;\\n        while(i<start.size() && j<end.size()) {\\n            \\n            while(start[i]==\\'X\\') i++;\\n            while(end[j]==\\'X\\') j++;\\n            \\n            if(start[i]!=end[j]) return false;\\n            if(start[i]==\\'R\\' && i>j) return false;\\n            if(start[i]==\\'L\\' && i<j) return false;\\n            i++; j++;\\n        }\\n        while(i<start.size() && start[i]==\\'X\\') i++;\\n        while(j<end.size() && end[j]==\\'X\\') j++;\\n        return i==j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        \\n        int i=0, j=0;\\n        while(i<start.size() && j<end.size()) {\\n            \\n            while(start[i]==\\'X\\') i++;\\n            while(end[j]==\\'X\\') j++;\\n            \\n            if(start[i]!=end[j]) return false;\\n            if(start[i]==\\'R\\' && i>j) return false;\\n            if(start[i]==\\'L\\' && i<j) return false;\\n            i++; j++;\\n        }\\n        while(i<start.size() && start[i]==\\'X\\') i++;\\n        while(j<end.size() && end[j]==\\'X\\') j++;\\n        return i==j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563447,
                "title": "simple-explanation-c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // * R and L ka order remains unchanged\\n    // * L can go only left of X\\n    // * R can go only right of X\\n    \\n    // logic: use two pointers to find positions of L and R (ptr1 for start and ptr2 for end)\\n    // the pointers skip all X\\'s (consider X\\'s as spaces)\\n    // after skipping space each time, check if start[ptr1]==end[ptr2] (if not, return false)\\n    // as R can move only right, index of R in start must <= index of R in end (think!!)\\n    // as L can move only left, index of L in start must be >= index of L in end (think!!)\\n    bool canTransform(string start, string end) {\\n        if(start.size()==1){\\n            if(start[0]==end[0])\\n                return true;\\n            return false;\\n        }\\n        \\n        int ptr1=0, ptr2=0;\\n        while( ptr1<start.size() && ptr2<end.size() ){\\n            while(start[ptr1] == \\'X\\')\\n                ptr1++;\\n            while(end[ptr2] == \\'X\\')\\n                ptr2++;\\n            char a=start[ptr1];\\n            char b=end[ptr2];\\n            if(a!=b)\\n                return false;\\n            if(a == \\'L\\' && ptr1<ptr2)\\n                return false;\\n            if(a == \\'R\\' && ptr1>ptr2)\\n                return false;\\n            ptr1=ptr1+1;\\n            ptr2=ptr2+1;\\n        }\\n        // for remaining spaces in the end (X\\'s)\\n        while(ptr1<start.size() && start[ptr1]==\\'X\\')\\n            ptr1++;\\n        while(ptr2<end.size() && end[ptr2]==\\'X\\')\\n            ptr2++;\\n        \\n        return ptr1==ptr2;\\n    }\\n};\\n```\\n\\nreferred from soln of :[https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/1704920/C++-one-pass-time:O(n)-space:O(1)-(with-explanation)](http://)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // * R and L ka order remains unchanged\\n    // * L can go only left of X\\n    // * R can go only right of X\\n    \\n    // logic: use two pointers to find positions of L and R (ptr1 for start and ptr2 for end)\\n    // the pointers skip all X\\'s (consider X\\'s as spaces)\\n    // after skipping space each time, check if start[ptr1]==end[ptr2] (if not, return false)\\n    // as R can move only right, index of R in start must <= index of R in end (think!!)\\n    // as L can move only left, index of L in start must be >= index of L in end (think!!)\\n    bool canTransform(string start, string end) {\\n        if(start.size()==1){\\n            if(start[0]==end[0])\\n                return true;\\n            return false;\\n        }\\n        \\n        int ptr1=0, ptr2=0;\\n        while( ptr1<start.size() && ptr2<end.size() ){\\n            while(start[ptr1] == \\'X\\')\\n                ptr1++;\\n            while(end[ptr2] == \\'X\\')\\n                ptr2++;\\n            char a=start[ptr1];\\n            char b=end[ptr2];\\n            if(a!=b)\\n                return false;\\n            if(a == \\'L\\' && ptr1<ptr2)\\n                return false;\\n            if(a == \\'R\\' && ptr1>ptr2)\\n                return false;\\n            ptr1=ptr1+1;\\n            ptr2=ptr2+1;\\n        }\\n        // for remaining spaces in the end (X\\'s)\\n        while(ptr1<start.size() && start[ptr1]==\\'X\\')\\n            ptr1++;\\n        while(ptr2<end.size() && end[ptr2]==\\'X\\')\\n            ptr2++;\\n        \\n        return ptr1==ptr2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272582,
                "title": "c-easiest-code-clean-and-easy-to-understand",
                "content": "Please upvote\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n       int n=s.size(); \\n       int i=0,j=0;\\n        while(i<n or j<n){\\n            \\n            while(i<n and s[i]==\\'X\\'){\\n                i++;\\n            }\\n            while(j<n and e[j]==\\'X\\'){\\n                j++;\\n            }\\n            if(i==n or j==n){\\n                return i==n and j==n;\\n            }\\n            //no we are at two characters\\n            //so now compare\\n            if(s[i]!=e[j]){\\n                return false;\\n            }\\n            if(s[i]==e[j] and s[i]==\\'R\\'){\\n                if(j<i){\\n                    return false;\\n                }\\n            }\\n            if(s[i]==e[j] and s[i]==\\'L\\'){\\n               if(j>i){\\n                   return false;\\n               }  \\n            }\\n            \\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n       int n=s.size(); \\n       int i=0,j=0;\\n        while(i<n or j<n){\\n            \\n            while(i<n and s[i]==\\'X\\'){\\n                i++;\\n            }\\n            while(j<n and e[j]==\\'X\\'){\\n                j++;\\n            }\\n            if(i==n or j==n){\\n                return i==n and j==n;\\n            }\\n            //no we are at two characters\\n            //so now compare\\n            if(s[i]!=e[j]){\\n                return false;\\n            }\\n            if(s[i]==e[j] and s[i]==\\'R\\'){\\n                if(j<i){\\n                    return false;\\n                }\\n            }\\n            if(s[i]==e[j] and s[i]==\\'L\\'){\\n               if(j>i){\\n                   return false;\\n               }  \\n            }\\n            \\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155986,
                "title": "simple-java-two-pointers-solution-no-replace-no-equals-no-stringbuilder",
                "content": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        \\n        int p1=0, p2=0;\\n        \\n        while(p1 < start.length() || p2 < end.length()) {\\n            while(p1 < start.length() && start.charAt(p1) == \\'X\\')\\n                p1++;\\n            while(p2 < end.length() && end.charAt(p2) == \\'X\\')\\n                p2++;\\n            \\n            if(p1 >= start.length() && p2 >= end.length())\\n                return true;\\n            \\n            if(p1 >= start.length() || p2 >= end.length())\\n                return false;\\n            \\n            if(start.charAt(p1) != end.charAt(p2)) \\n                return false;\\n            \\n            if(start.charAt(p1) == \\'R\\' && p1 > p2) {\\n                return false;\\n            }\\n            \\n            if(start.charAt(p1) == \\'L\\' && p1 < p2) {\\n                return false;\\n            }\\n            \\n            p1++;\\n            p2++;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        \\n        int p1=0, p2=0;\\n        \\n        while(p1 < start.length() || p2 < end.length()) {\\n            while(p1 < start.length() && start.charAt(p1) == \\'X\\')\\n                p1++;\\n            while(p2 < end.length() && end.charAt(p2) == \\'X\\')\\n                p2++;\\n            \\n            if(p1 >= start.length() && p2 >= end.length())\\n                return true;\\n            \\n            if(p1 >= start.length() || p2 >= end.length())\\n                return false;\\n            \\n            if(start.charAt(p1) != end.charAt(p2)) \\n                return false;\\n            \\n            if(start.charAt(p1) == \\'R\\' && p1 > p2) {\\n                return false;\\n            }\\n            \\n            if(start.charAt(p1) == \\'L\\' && p1 < p2) {\\n                return false;\\n            }\\n            \\n            p1++;\\n            p2++;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005133,
                "title": "java-two-pointer-one-pass-o-n-with-explanation",
                "content": "We have 3 cases to handle:\\n1. if Xs are removed, the two strings should be identical.\\n2. L cannot go to right.\\n3. R cannot go to left.\\n\\nBased on that we can use two pointers and check Rs and Ls positions.\\n\\n```\\npublic boolean canTransform(String start, String end) {\\n    char[] s = start.toCharArray();\\n    char[] e = end.toCharArray();\\n\\n    int i = 0, j = 0;\\n    while(i < s.length && j < e.length){\\n      if(s[i] == \\'X\\'){\\n        i++;\\n      }else if(e[j] == \\'X\\'){\\n        j++;\\n      }else{\\n        if(s[i] != e[j] || s[i] == \\'R\\' && j < i || s[i] == \\'L\\' && j > i) return false;\\n        i++;\\n        j++;\\n      }\\n    }\\n\\n    while(i < s.length){\\n      if(s[i++] != \\'X\\') return false;\\n    }\\n\\n    while(j < e.length){\\n      if(e[j++] != \\'X\\') return false;\\n    }\\n\\n    return true;\\n  }\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "We have 3 cases to handle:\\n1. if Xs are removed, the two strings should be identical.\\n2. L cannot go to right.\\n3. R cannot go to left.\\n\\nBased on that we can use two pointers and check Rs and Ls positions.\\n\\n```\\npublic boolean canTransform(String start, String end) {\\n    char[] s = start.toCharArray();\\n    char[] e = end.toCharArray();\\n\\n    int i = 0, j = 0;\\n    while(i < s.length && j < e.length){\\n      if(s[i] == \\'X\\'){\\n        i++;\\n      }else if(e[j] == \\'X\\'){\\n        j++;\\n      }else{\\n        if(s[i] != e[j] || s[i] == \\'R\\' && j < i || s[i] == \\'L\\' && j > i) return false;\\n        i++;\\n        j++;\\n      }\\n    }\\n\\n    while(i < s.length){\\n      if(s[i++] != \\'X\\') return false;\\n    }\\n\\n    while(j < e.length){\\n      if(e[j++] != \\'X\\') return false;\\n    }\\n\\n    return true;\\n  }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1957581,
                "title": "java-2-pointers-o-n",
                "content": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int f = 0;\\n        int s = 0;\\n        while(f < start.length() || s < end.length()) {\\n            while(f < start.length() && start.charAt(f) == \\'X\\') f++;\\n            while(s < end.length() && end.charAt(s) == \\'X\\') s++;\\n            if (f == start.length() || s == end.length()) return s == end.length() && f == start.length();\\n            char stChar = start.charAt(f);\\n            char enChar = end.charAt(s);\\n            if (stChar != enChar) return false;\\n            if (stChar == \\'R\\' && f > s) return false;\\n            if (stChar == \\'L\\' && f < s) return false;\\n            f++;\\n            s++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int f = 0;\\n        int s = 0;\\n        while(f < start.length() || s < end.length()) {\\n            while(f < start.length() && start.charAt(f) == \\'X\\') f++;\\n            while(s < end.length() && end.charAt(s) == \\'X\\') s++;\\n            if (f == start.length() || s == end.length()) return s == end.length() && f == start.length();\\n            char stChar = start.charAt(f);\\n            char enChar = end.charAt(s);\\n            if (stChar != enChar) return false;\\n            if (stChar == \\'R\\' && f > s) return false;\\n            if (stChar == \\'L\\' && f < s) return false;\\n            f++;\\n            s++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875936,
                "title": "faang-onsite-interview-problem-solution-c-o-n",
                "content": "My friend was asked from one of the FAANG companies.\\n\\n**Logic & Algo**\\nWe will check all the cases where it should return false, if none matches then we will return true.\\nWe will use two pointers, one for start (say, iS), and one for end(say, iE).\\nWe will move iS and iE till they are pointing at \\'X\\'.\\nNow, if iS and iE are pointing to different values, then we can never reach to the end from the start, hence, return false.\\nIf it matches:\\n* \\tif they are pointing to \\'R\\', then iS must be less than or equal to iE, as R can be moved to right only from start.\\n* \\tif they are pointing to \\'L\\', then iS must be greater than or equal to iE, as L can be moved to left only from start.\\n* \\tIf the above fails, then we will return false.\\n\\nAs we will reach the end, there must not remain any L or R in any of the start or end remaining strings.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int iS = 0, iE = 0;\\n        while(iS < start.size() && iE < end.size()){\\n            if(start[iS] != \\'X\\' && end[iE] != \\'X\\'){\\n                if(start[iS] != end[iE])\\n                    return false;\\n                else if(start[iS] == \\'R\\' && iS > iE)\\n                    return false;\\n                else if(start[iS] == \\'L\\' && iS < iE)\\n                    return false;\\n                iS++;\\n                iE++;\\n            }\\n            else{\\n                if(start[iS] == \\'X\\')\\n                    iS++;\\n                else\\n                    iE++;\\n            }\\n        }\\n        while(iS < start.size()){\\n            if(start[iS] != \\'X\\')\\n                return false;\\n            iS++;\\n        }\\n        while(iE < end.size()){\\n            if(end[iE] != \\'X\\')\\n                return false;\\n            iE++;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nPlease upvote and share your feedback.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int iS = 0, iE = 0;\\n        while(iS < start.size() && iE < end.size()){\\n            if(start[iS] != \\'X\\' && end[iE] != \\'X\\'){\\n                if(start[iS] != end[iE])\\n                    return false;\\n                else if(start[iS] == \\'R\\' && iS > iE)\\n                    return false;\\n                else if(start[iS] == \\'L\\' && iS < iE)\\n                    return false;\\n                iS++;\\n                iE++;\\n            }\\n            else{\\n                if(start[iS] == \\'X\\')\\n                    iS++;\\n                else\\n                    iE++;\\n            }\\n        }\\n        while(iS < start.size()){\\n            if(start[iS] != \\'X\\')\\n                return false;\\n            iS++;\\n        }\\n        while(iE < end.size()){\\n            if(end[iE] != \\'X\\')\\n                return false;\\n            iE++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782915,
                "title": "java-solution-with-comments",
                "content": "```\\npublic boolean swapAdjacentInLRString(String s, String e) {\\n\\tif(s.length() != e.length()) return false;\\n\\tint i = 0, j = 0;\\n\\tchar[] st = s.toCharArray();\\n\\tchar[] ed = e.toCharArray();\\n\\twhile(i < st.length || j < ed.length) {\\n\\t\\t// only need to work with \\'L\\' and \\'R\\' so ignore \\'X\\'\\n\\t\\twhile(i < st.length && st[i] == \\'X\\'){\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\t\\twhile(j < ed.length && ed[j] == \\'X\\') {\\n\\t\\t\\t++j;\\n\\t\\t}\\n\\t\\t// both at end\\n\\t\\tif(i == st.length && j == ed.length) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t// one of them at the end\\n\\t\\tif(i == st.length || j == ed.length) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t// character not similar\\n\\t\\tif(st[i] != ed[j]) return false;\\n\\t\\t// if char is R we can go right only when i pointer doesn\\'t exceed j pointer\\n\\t\\tif(st[i] == \\'R\\' && i > j) return false;\\n\\t\\t// if char is L we can go left only when i pointer exceed j pointer\\n\\t\\tif(st[i] == \\'L\\' && i < j) return false;\\n\\t\\ti++;\\n\\t\\tj++;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean swapAdjacentInLRString(String s, String e) {\\n\\tif(s.length() != e.length()) return false;\\n\\tint i = 0, j = 0;\\n\\tchar[] st = s.toCharArray();\\n\\tchar[] ed = e.toCharArray();\\n\\twhile(i < st.length || j < ed.length) {\\n\\t\\t// only need to work with \\'L\\' and \\'R\\' so ignore \\'X\\'\\n\\t\\twhile(i < st.length && st[i] == \\'X\\'){\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\t\\twhile(j < ed.length && ed[j] == \\'X\\') {\\n\\t\\t\\t++j;\\n\\t\\t}\\n\\t\\t// both at end\\n\\t\\tif(i == st.length && j == ed.length) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t// one of them at the end\\n\\t\\tif(i == st.length || j == ed.length) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t// character not similar\\n\\t\\tif(st[i] != ed[j]) return false;\\n\\t\\t// if char is R we can go right only when i pointer doesn\\'t exceed j pointer\\n\\t\\tif(st[i] == \\'R\\' && i > j) return false;\\n\\t\\t// if char is L we can go left only when i pointer exceed j pointer\\n\\t\\tif(st[i] == \\'L\\' && i < j) return false;\\n\\t\\ti++;\\n\\t\\tj++;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737784,
                "title": "python-3-with-explanation",
                "content": "\\n\\nFound idea in discussion, replacing names to make it readable. The first idea is \\'RX\\' can be replaced only with \\'XR\\', which means that \\'R\\' is always moving to the right position if replacement was done.  If many replacements done, \\'R\\' can move to the right so many times until there is a \\'L\\' on the road or the end of string, then \\'R\\' can not move further.  \\'L\\' has an opposite behaviour - it can move only to the left side from previous position and it can move until \\'R\\' is found or until it reach the beginning of string. \\nSo we will check 2 coditions - 1. we remove all X and we check that order of \\'R\\' and \\'L\\' in strings stays same (you remembre \\'R\\' can no move further if \\'L\\' is met and opposite). 2. We will start checking on which position R was in Start string and where it is in End string. If we found that R somehow moved to the left (R must always move to right) then we can not make End string by replacement. Same with L - if we found that at End string it\\'s position is more right than in Start - this means we wan\\'t be able to create End string with replacemnt. \\n\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'): #check 1st condition\\n            return False\\n        \\n        posInEnd = 0\\n        for posInStart in range(len(start)):\\n            currentChar = start[posInStart]\\n            if currentChar == \\'X\\':\\n                continue\\n            else:\\n                while end[posInEnd] != currentChar : \\n                    posInEnd += 1 # we skip all chars until we found first occurance of currentChar,\\n\\t\\t\\t\\t\\t# we don\\'t check if skipped positions have \\'X\\' or \\'R\\' or \\'L\\' because we already confirmed \\n\\t\\t\\t\\t\\t# that \\'R\\' and \\'L\\' are having same order is strings during 1st condition check\\n                if currentChar == \\'R\\':\\n                    if posInEnd < posInStart:\\n                        return False\\n                elif currentChar == \\'L\\': \\n                    if posInEnd > posInStart:\\n                        return False\\n                posInEnd += 1 # we move to next char because current was confirmed\\n        \\n        return True # all checks are passed, we can create End from Start\\n",
                "solutionTags": [],
                "code": "\\n\\nFound idea in discussion, replacing names to make it readable. The first idea is \\'RX\\' can be replaced only with \\'XR\\', which means that \\'R\\' is always moving to the right position if replacement was done.  If many replacements done, \\'R\\' can move to the right so many times until there is a \\'L\\' on the road or the end of string, then \\'R\\' can not move further.  \\'L\\' has an opposite behaviour - it can move only to the left side from previous position and it can move until \\'R\\' is found or until it reach the beginning of string. \\nSo we will check 2 coditions - 1. we remove all X and we check that order of \\'R\\' and \\'L\\' in strings stays same (you remembre \\'R\\' can no move further if \\'L\\' is met and opposite). 2. We will start checking on which position R was in Start string and where it is in End string. If we found that R somehow moved to the left (R must always move to right) then we can not make End string by replacement. Same with L - if we found that at End string it\\'s position is more right than in Start - this means we wan\\'t be able to create End string with replacemnt. \\n\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'): #check 1st condition\\n            return False\\n        \\n        posInEnd = 0\\n        for posInStart in range(len(start)):\\n            currentChar = start[posInStart]\\n            if currentChar == \\'X\\':\\n                continue\\n            else:\\n                while end[posInEnd] != currentChar : \\n                    posInEnd += 1 # we skip all chars until we found first occurance of currentChar,\\n\\t\\t\\t\\t\\t# we don\\'t check if skipped positions have \\'X\\' or \\'R\\' or \\'L\\' because we already confirmed \\n\\t\\t\\t\\t\\t# that \\'R\\' and \\'L\\' are having same order is strings during 1st condition check\\n                if currentChar == \\'R\\':\\n                    if posInEnd < posInStart:\\n                        return False\\n                elif currentChar == \\'L\\': \\n                    if posInEnd > posInStart:\\n                        return False\\n                posInEnd += 1 # we move to next char because current was confirmed\\n        \\n        return True # all checks are passed, we can create End from Start\\n",
                "codeTag": "Java"
            },
            {
                "id": 1632126,
                "title": "c-strict-one-pass-o-n-time-o-1-space",
                "content": "```\\n// IDEA:\\n//   1. Observed that for a valid result:\\n//      a. For each \\'R\\' in start, you will have to shift it to right\\n//         without meeting any \\'L\\' in either start or end\\n//      b. Similar to a, For each \\'L\\' in end, you will have to shift it\\n//         to right without meeting any \\'R\\' in either start or end\\n//      c. The reason why they cannot meet is because if \\'L\\' and \\'R\\' meet\\n//         they cannot cross eachother to their desired position.\\n//      d. a special case is:\\n//           s: XXLL\\n//           e: LLXX\\n//         observed that rule a and b still cannot be broken, so use a count\\n//         to store the Ls / Rs that needs to be shifted\\n//\\n//   3. So for our solution, we use a one pass for loop from left to right,\\n//      whenever we meet a \\'R\\' in start or \\'L\\' in end, mark it. Keep traversing\\n//      until we meet an \\'R\\' or \\'L\\' in the opposing string. If a false condition\\n//      is encoutnered, return false. As last, check if there is a buffered \\'L\\'\\n//      or \\'R\\', if not, the two strings are valid.\\n//\\n//   4. Complexity analysis:\\n//      O(n) time due to for loop checking each character in start and end\\n//      O(1) space, only two variables c and cnt\\n\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n        char c = \\'X\\'; // current buffered \\'L\\' or \\'R\\'\\n        int cnt = 0;  // number of buffered \\'L\\' or \\'R\\'\\n\\n        // One pass for loop\\n        for (int i = 0; i < s.size(); i++) {\\n            \\n            // Check if \\'L\\' or \\'R\\' is buffered\\n            if (c == \\'X\\') {\\n                \\n                // continue if the two characters are the same\\n                if (s[i] == e[i]) continue;\\n                \\n                // invalid position of \\'L\\' / \\'R\\', because\\n                // e[i] should have a buffered \\'L\\' before an \\'L\\' in s[i]\\n                // s[i] should have a buffered \\'R\\' before an \\'R\\' in e[i]\\n                if (s[i] == \\'L\\' || e[i] == \\'R\\') return false;\\n                \\n                // valid position of \\'L\\' / \\'R\\', buffer them\\n                if (s[i] == \\'R\\') {\\n                    if (e[i] == \\'L\\') return false;\\n                    c = s[i];\\n                    cnt++;\\n                } else if (e[i] == \\'L\\') {\\n                    if (s[i] == \\'R\\') return false;\\n                    c = e[i];\\n                    cnt++;\\n                }\\n            } else {\\n                if (s[i] == \\'X\\' && e[i] == \\'X\\') continue;\\n                switch (c) {\\n                    case \\'L\\':\\n                        if (s[i] == \\'R\\' || e[i] == \\'R\\') return false; // refer to description 1c\\n                        if (e[i] == \\'L\\') cnt++;\\n                        if (s[i] == \\'L\\') cnt--;\\n                        break;\\n                    case \\'R\\':\\n                        if (s[i] == \\'L\\' || e[i] == \\'L\\') return false; // refer to description 1c\\n                        if (s[i] == \\'R\\') cnt++;\\n                        if (e[i] == \\'R\\') cnt--;\\n                        break;\\n                    default:\\n                        return false; // catch exception\\n                }\\n                // clear buffer if the count is 0\\n                if (cnt == 0) c = \\'X\\';\\n            }\\n        }\\n        // Check if the buffer is cleared\\n        return c == \\'X\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// IDEA:\\n//   1. Observed that for a valid result:\\n//      a. For each \\'R\\' in start, you will have to shift it to right\\n//         without meeting any \\'L\\' in either start or end\\n//      b. Similar to a, For each \\'L\\' in end, you will have to shift it\\n//         to right without meeting any \\'R\\' in either start or end\\n//      c. The reason why they cannot meet is because if \\'L\\' and \\'R\\' meet\\n//         they cannot cross eachother to their desired position.\\n//      d. a special case is:\\n//           s: XXLL\\n//           e: LLXX\\n//         observed that rule a and b still cannot be broken, so use a count\\n//         to store the Ls / Rs that needs to be shifted\\n//\\n//   3. So for our solution, we use a one pass for loop from left to right,\\n//      whenever we meet a \\'R\\' in start or \\'L\\' in end, mark it. Keep traversing\\n//      until we meet an \\'R\\' or \\'L\\' in the opposing string. If a false condition\\n//      is encoutnered, return false. As last, check if there is a buffered \\'L\\'\\n//      or \\'R\\', if not, the two strings are valid.\\n//\\n//   4. Complexity analysis:\\n//      O(n) time due to for loop checking each character in start and end\\n//      O(1) space, only two variables c and cnt\\n\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n        char c = \\'X\\'; // current buffered \\'L\\' or \\'R\\'\\n        int cnt = 0;  // number of buffered \\'L\\' or \\'R\\'\\n\\n        // One pass for loop\\n        for (int i = 0; i < s.size(); i++) {\\n            \\n            // Check if \\'L\\' or \\'R\\' is buffered\\n            if (c == \\'X\\') {\\n                \\n                // continue if the two characters are the same\\n                if (s[i] == e[i]) continue;\\n                \\n                // invalid position of \\'L\\' / \\'R\\', because\\n                // e[i] should have a buffered \\'L\\' before an \\'L\\' in s[i]\\n                // s[i] should have a buffered \\'R\\' before an \\'R\\' in e[i]\\n                if (s[i] == \\'L\\' || e[i] == \\'R\\') return false;\\n                \\n                // valid position of \\'L\\' / \\'R\\', buffer them\\n                if (s[i] == \\'R\\') {\\n                    if (e[i] == \\'L\\') return false;\\n                    c = s[i];\\n                    cnt++;\\n                } else if (e[i] == \\'L\\') {\\n                    if (s[i] == \\'R\\') return false;\\n                    c = e[i];\\n                    cnt++;\\n                }\\n            } else {\\n                if (s[i] == \\'X\\' && e[i] == \\'X\\') continue;\\n                switch (c) {\\n                    case \\'L\\':\\n                        if (s[i] == \\'R\\' || e[i] == \\'R\\') return false; // refer to description 1c\\n                        if (e[i] == \\'L\\') cnt++;\\n                        if (s[i] == \\'L\\') cnt--;\\n                        break;\\n                    case \\'R\\':\\n                        if (s[i] == \\'L\\' || e[i] == \\'L\\') return false; // refer to description 1c\\n                        if (s[i] == \\'R\\') cnt++;\\n                        if (e[i] == \\'R\\') cnt--;\\n                        break;\\n                    default:\\n                        return false; // catch exception\\n                }\\n                // clear buffer if the count is 0\\n                if (cnt == 0) c = \\'X\\';\\n            }\\n        }\\n        // Check if the buffer is cleared\\n        return c == \\'X\\';\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1312622,
                "title": "simple-java-o-n-solution-with-o-1-space-with-explanation",
                "content": "The problem states that cars cannot collide while moving from one position to the other. Hence if we remove the empty lanes both the start and end would look like identical. For Example : \\nstart -> `RXXL` end -> `XRXL`. Both of the strings are identical if we remove the empty lanes -> `RL`. This is because no two cars exchange their relative position. Thus the final result is to find whether both the lanes after removing the empty lanes looks identical and the index in the end is either left or right with respect to the start positions.\\n\\nFor Example : \\n`XXRXXL` -> `XRXXL` would be invalid because istead of movig right the first car has moved left.\\n\\nTo achieve this we use two pointers one poiting the car in the source lane and another in the target lane. For every car in the soure lane we check the next car in the target lane and if it is  not positioned with the given conditions we return false.\\n\\nTime Complexity : `O(n)`\\nWe do Atmost 2 * n number of operations.\\n\\nSpace Complexity : `O(1)`\\nWe only use constant space for the pointers and static variables for storing the \\'L\\', \\'R\\' and \\'X\\'.\\n\\n```\\nclass Solution {\\n    private static char EMPTY = \\'X\\';\\n    private static char RIGHT = \\'R\\';\\n    private static char LEFT = \\'L\\';\\n    public boolean canTransform(String start, String end) {\\n        int len = start.length();\\n        if (end.length() != len) {\\n            return false;\\n        }\\n        int endPointer = 0;\\n        for (int index = 0; index < len; index++) {\\n            char c = start.charAt(index);\\n            if (c != EMPTY) {\\n                while (endPointer < len && end.charAt(endPointer) == EMPTY){//pointing to the next car in the target lane\\n                    endPointer++;\\n                }\\n                if (endPointer == len) {//insufficient number of  cars in the target// we ran out of cars to match the source lane\\n                    return false;\\n                }\\n                if (c != end.charAt(endPointer) || c == RIGHT && endPointer < index || c == LEFT && endPointer > index) {\\n                    return false;\\n                }\\n                endPointer++;\\n            }\\n        }\\n        while (endPointer < len){\\n            if (end.charAt(endPointer) != EMPTY) {//excess cars in the target lane\\n                return false;\\n            }\\n            endPointer++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    private static char EMPTY = \\'X\\';\\n    private static char RIGHT = \\'R\\';\\n    private static char LEFT = \\'L\\';\\n    public boolean canTransform(String start, String end) {\\n        int len = start.length();\\n        if (end.length() != len) {\\n            return false;\\n        }\\n        int endPointer = 0;\\n        for (int index = 0; index < len; index++) {\\n            char c = start.charAt(index);\\n            if (c != EMPTY) {\\n                while (endPointer < len && end.charAt(endPointer) == EMPTY){//pointing to the next car in the target lane\\n                    endPointer++;\\n                }\\n                if (endPointer == len) {//insufficient number of  cars in the target// we ran out of cars to match the source lane\\n                    return false;\\n                }\\n                if (c != end.charAt(endPointer) || c == RIGHT && endPointer < index || c == LEFT && endPointer > index) {\\n                    return false;\\n                }\\n                endPointer++;\\n            }\\n        }\\n        while (endPointer < len){\\n            if (end.charAt(endPointer) != EMPTY) {//excess cars in the target lane\\n                return false;\\n            }\\n            endPointer++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043158,
                "title": "simple-one-pass-solution-o-n-c",
                "content": "```\\n    bool canTransform(string start, string end) {\\n        int l = 0;\\n        int r = 0;\\n        for(int i = 0;i<start.size();i++){\\n            if(start[i]==\\'R\\'){\\n                r++;\\n            }\\n            if(end[i]==\\'L\\'){\\n                l++;\\n            }\\n            if(l&&r) return false;\\n            if(start[i]==\\'L\\'){\\n                l--;\\n                if(l==-1) return false;\\n            }\\n            if(end[i]==\\'R\\'){\\n                r--;\\n                if(r==-1) return false;\\n            }\\n        }\\n        return l==0&&r==0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool canTransform(string start, string end) {\\n        int l = 0;\\n        int r = 0;\\n        for(int i = 0;i<start.size();i++){\\n            if(start[i]==\\'R\\'){\\n                r++;\\n            }\\n            if(end[i]==\\'L\\'){\\n                l++;\\n            }\\n            if(l&&r) return false;\\n            if(start[i]==\\'L\\'){\\n                l--;\\n                if(l==-1) return false;\\n            }\\n            if(end[i]==\\'R\\'){\\n                r--;\\n                if(r==-1) return false;\\n            }\\n        }\\n        return l==0&&r==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851274,
                "title": "java-stack-each-l-and-r-in-start-actually-corresponds-to-each-other-in-end",
                "content": "As the title indicates, each \\'L\\' and \\'R\\' in \\'start\\' should correspond to their counterparts in \\'end\\'. This is because \\'R\\' can only move to right blank space \\'X\\' (if any) and \\'L\\' can only move to left blank space \\'X\\' (if any), and they can\\'t \\'fly over\\' each other (e.g. `RL` can\\'t be transformed into `LR`).\\n\\nKeeping this in mind, take start=`RXXLRXRXL` and end=`XRLXXRRLX` as an example:\\n\\n1. First \\'R\\' at index 0 in \\'start\\' should correspond to the first \\'R\\' at index 1 in \\'end. \\'R\\' should only move towards right so this step is valid. \\'R\\' can only move to right so make sure `start.R.index <= end.R.index`\\n\\n2. Similarly first \\'L\\' at index 3 in \\'start\\' corresponds exactly to the first \\'L\\' at index 2 in \\'end\\'. It\\'s also valid. \\'L\\' can only move to left so make sure `start.L.index >= end.L.index`.\\n\\n3. So on so forth...\\n\\nLet\\'s use 2 stacks to indicate this simple mapping and I know this can be optimized :)\\n\\n```\\nclass Solution {\\n    class Pos {\\n        char c;\\n        int index;\\n        public Pos(char c, int index) {\\n            this.c = c;\\n            this.index = index;\\n        }\\n    }\\n    \\n    public boolean canTransform(String start, String end) {\\n        Deque<Pos> startStack = new ArrayDeque<>();\\n        Deque<Pos> endStack = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < start.length(); i++) {\\n            char sc = start.charAt(i);\\n            char ec = end.charAt(i);\\n            if (sc != \\'X\\') {\\n                startStack.addLast(new Pos(sc, i));\\n            }\\n            if (ec != \\'X\\') {\\n                endStack.addLast(new Pos(ec, i));\\n            }\\n        }\\n        \\n        if (startStack.size() != endStack.size()) {\\n            return false;\\n        }\\n        \\n        while (!startStack.isEmpty() && !endStack.isEmpty()) {\\n            Pos sPos = startStack.removeLast();\\n            Pos ePos = endStack.removeLast();\\n            \\n            char sc = sPos.c;\\n            int sIndex = sPos.index;\\n            char ec = ePos.c;\\n            int eIndex = ePos.index;\\n            \\n            if (sc != ec) {\\n                return false;\\n            }\\n            if (sc == \\'L\\' && sIndex < eIndex || sc == \\'R\\' && sIndex > eIndex) {\\n                return false;\\n            }\\n        }\\n        return startStack.isEmpty() && endStack.isEmpty();\\n    }\\n}\\n```\\n\\nWith O(n) time and space.",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    class Pos {\\n        char c;\\n        int index;\\n        public Pos(char c, int index) {\\n            this.c = c;\\n            this.index = index;\\n        }\\n    }\\n    \\n    public boolean canTransform(String start, String end) {\\n        Deque<Pos> startStack = new ArrayDeque<>();\\n        Deque<Pos> endStack = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < start.length(); i++) {\\n            char sc = start.charAt(i);\\n            char ec = end.charAt(i);\\n            if (sc != \\'X\\') {\\n                startStack.addLast(new Pos(sc, i));\\n            }\\n            if (ec != \\'X\\') {\\n                endStack.addLast(new Pos(ec, i));\\n            }\\n        }\\n        \\n        if (startStack.size() != endStack.size()) {\\n            return false;\\n        }\\n        \\n        while (!startStack.isEmpty() && !endStack.isEmpty()) {\\n            Pos sPos = startStack.removeLast();\\n            Pos ePos = endStack.removeLast();\\n            \\n            char sc = sPos.c;\\n            int sIndex = sPos.index;\\n            char ec = ePos.c;\\n            int eIndex = ePos.index;\\n            \\n            if (sc != ec) {\\n                return false;\\n            }\\n            if (sc == \\'L\\' && sIndex < eIndex || sc == \\'R\\' && sIndex > eIndex) {\\n                return false;\\n            }\\n        }\\n        return startStack.isEmpty() && endStack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838532,
                "title": "does-anyone-understand-what-the-question-is-asking",
                "content": "I don\\'t understand the explanation provided by the example. Where did `RXXLRXRXL` come from? My understanding is that the transformation would start with X\\n\\n```\\nInput: start = \"X\", end = \"L\"\\nOutput: false\\nExplanation:\\nWe can transform start to end following these steps:\\nRXXLRXRXL ->\\nXRXLRXRXL ->\\nXRLXRXRXL ->\\nXRLXXRRXL ->\\nXRLXXRRLX",
                "solutionTags": [],
                "code": "I don\\'t understand the explanation provided by the example. Where did `RXXLRXRXL` come from? My understanding is that the transformation would start with X\\n\\n```\\nInput: start = \"X\", end = \"L\"\\nOutput: false\\nExplanation:\\nWe can transform start to end following these steps:\\nRXXLRXRXL ->\\nXRXLRXRXL ->\\nXRLXRXRXL ->\\nXRLXXRRXL ->\\nXRLXXRRLX",
                "codeTag": "Unknown"
            },
            {
                "id": 689826,
                "title": "python-simple-one-pass-o-n-solution",
                "content": "Iterate from left to right, to check if there are enough ```R```.\\nIterate from right to left, to check if there are enough ```L```.\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        L = R = 0\\n        for i in range(len(start)):\\n            a, b = start[i], end[i]\\n            R = R + 1 if a == \\'R\\' else (0 if a == \\'L\\' else R)\\n            if b == \\'R\\' and not R:\\n                return False\\n            R -= b == \\'R\\'\\n            \\n            j = len(start) - 1 - i\\n            c, d = start[j], end[j]\\n            L = L + 1 if c == \\'L\\' else (0 if c == \\'R\\' else L)\\n            if d == \\'L\\' and not L:\\n                return False\\n            L -= d == \\'L\\'\\n        \\n        return L == R == 0\\n```",
                "solutionTags": [],
                "code": "```R```\n```L```\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        L = R = 0\\n        for i in range(len(start)):\\n            a, b = start[i], end[i]\\n            R = R + 1 if a == \\'R\\' else (0 if a == \\'L\\' else R)\\n            if b == \\'R\\' and not R:\\n                return False\\n            R -= b == \\'R\\'\\n            \\n            j = len(start) - 1 - i\\n            c, d = start[j], end[j]\\n            L = L + 1 if c == \\'L\\' else (0 if c == \\'R\\' else L)\\n            if d == \\'L\\' and not L:\\n                return False\\n            L -= d == \\'L\\'\\n        \\n        return L == R == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589016,
                "title": "short-and-clean-java-code",
                "content": "```\\n\\tpublic boolean canTransform(String start, String end) {\\n\\t\\tif (!start.replace(\"X\", \"\").equals(end.replace(\"X\", \"\"))) return false;\\n\\n\\t\\tint i = 0, j = 0;\\n\\t\\tint len = start.length();\\n\\n\\t\\twhile (i < len && j < len) {\\n\\t\\t\\twhile (i < len && start.charAt(i) == \\'X\\') i++;\\n\\t\\t\\twhile (j < len && end.charAt(j) == \\'X\\') j++;\\n\\t\\t\\tif (i < len && start.charAt(i) == \\'L\\' && i < j) return false;\\n\\t\\t\\tif (i < len && start.charAt(i) == \\'R\\' && i > j) return false;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean canTransform(String start, String end) {\\n\\t\\tif (!start.replace(\"X\", \"\").equals(end.replace(\"X\", \"\"))) return false;\\n\\n\\t\\tint i = 0, j = 0;\\n\\t\\tint len = start.length();\\n\\n\\t\\twhile (i < len && j < len) {\\n\\t\\t\\twhile (i < len && start.charAt(i) == \\'X\\') i++;\\n\\t\\t\\twhile (j < len && end.charAt(j) == \\'X\\') j++;\\n\\t\\t\\tif (i < len && start.charAt(i) == \\'L\\' && i < j) return false;\\n\\t\\t\\tif (i < len && start.charAt(i) == \\'R\\' && i > j) return false;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532824,
                "title": "java-ac-solution-with-explanation",
                "content": "\\n```\\n    public boolean canTransform(String start, String end) {\\n        /**\\n        Core concept - Left should stay in the left and R should stay in the right\\n        we traverse both the string ignoring the \\'X\\'\\n        If both indices reach the end, we are good, return true.\\n        If either reaches end means a mismatch, so return false\\n        Also L can only move left so if the position of L in the END is after START, return false\\n        Similarly if R moves left, return false\\n        \\n        **/\\n        if(start.length() != end.length()) return false;\\n        \\n        int i=0, j =0;\\n        while(i<start.length() && j<start.length()) {\\n            \\n            while(i<start.length() && start.charAt(i) == \\'X\\') i++;\\n            while(j<end.length() && end.charAt(j) == \\'X\\') j++;\\n            \\n            \\n            if(i == start.length() && j == start.length()) return true;\\n            if(i == start.length() || j == start.length()) return false;\\n            \\n            if(start.charAt(i) != end.charAt(j) ) return false;\\n            \\n            if(start.charAt(i) ==\\'L\\' && i<j) return false;\\n            \\n            if(start.charAt(i) ==\\'R\\' && i>j) return false;\\n            \\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "\\n```\\n    public boolean canTransform(String start, String end) {\\n        /**\\n        Core concept - Left should stay in the left and R should stay in the right\\n        we traverse both the string ignoring the \\'X\\'\\n        If both indices reach the end, we are good, return true.\\n        If either reaches end means a mismatch, so return false\\n        Also L can only move left so if the position of L in the END is after START, return false\\n        Similarly if R moves left, return false\\n        \\n        **/\\n        if(start.length() != end.length()) return false;\\n        \\n        int i=0, j =0;\\n        while(i<start.length() && j<start.length()) {\\n            \\n            while(i<start.length() && start.charAt(i) == \\'X\\') i++;\\n            while(j<end.length() && end.charAt(j) == \\'X\\') j++;\\n            \\n            \\n            if(i == start.length() && j == start.length()) return true;\\n            if(i == start.length() || j == start.length()) return false;\\n            \\n            if(start.charAt(i) != end.charAt(j) ) return false;\\n            \\n            if(start.charAt(i) ==\\'L\\' && i<j) return false;\\n            \\n            if(start.charAt(i) ==\\'R\\' && i>j) return false;\\n            \\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 321288,
                "title": "java-o-n-two-point",
                "content": "If start can be tansform to end, then\\n1. index of i-L in start >= index of i-L in end,\\n2. index of i-R in start <= index of i-R in end.\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (start.equals(end)) return true;\\n\\n        int i = 0, j = 0;\\n        while (i < start.length() && j < end.length()) {\\n            while (i < start.length() && start.charAt(i) == \\'X\\') i++;\\n            while (j < end.length() && end.charAt(j) == \\'X\\') j++;\\n            if (i < start.length() && j < end.length()) {\\n                if (start.charAt(i) != end.charAt(j)) return false;\\n                if (start.charAt(i) == \\'L\\' && i < j) return false;\\n                if (start.charAt(i) == \\'R\\' && i > j) return false;\\n                i++;\\n                j++;\\n            } else if (i < start.length() || j < end.length()) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (start.equals(end)) return true;\\n\\n        int i = 0, j = 0;\\n        while (i < start.length() && j < end.length()) {\\n            while (i < start.length() && start.charAt(i) == \\'X\\') i++;\\n            while (j < end.length() && end.charAt(j) == \\'X\\') j++;\\n            if (i < start.length() && j < end.length()) {\\n                if (start.charAt(i) != end.charAt(j)) return false;\\n                if (start.charAt(i) == \\'L\\' && i < j) return false;\\n                if (start.charAt(i) == \\'R\\' && i > j) return false;\\n                i++;\\n                j++;\\n            } else if (i < start.length() || j < end.length()) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191482,
                "title": "c-10-lines-o-n-detailed-explaination-easy-to-understand",
                "content": "The basic idea is to count the number of R in start string, and the number of L in end string. \\nThe reason is that when we meet a \\'R\\' in the end string, we hope there is a \\'R\\' in the start string before. This is why we need to count the number of R in the start string.\\nAnd when we meet a \\'L\\' in the start string, we hope we have meet a \\'L\\' in the end string before.\\nIf we didn\\'t meet what we need before, return false, that is  (cnt_r < 0 || cnt_l < 0).\\nIf we meet both \\'L\\' and \\'R\\', return false, because we cannot let a \\'L\\' or \\'R\\' go across each other, and that is (cnt_r > 0 && cnt_l > 0)\\n\\nIn the end, we hope all R and L have been used, that is return cnt_r == 0 && cnt_l == 0\\n```\\n    bool canTransform(string start, string end) {\\n        if(start.length() != end.length()) return false;\\n        int cnt_r = 0, cnt_l = 0;\\n        for(int i = 0, j = 0; i < start.size(), j < end.size(); i++, j++) {\\n            cnt_r += start[i] == \\'R\\' ? 1 : 0;\\n            cnt_l += end[j] == \\'L\\' ? 1 : 0;\\n            if(end[j] == \\'R\\' && cnt_l == 0) cnt_r --;\\n            if(start[i] == \\'L\\' && cnt_r == 0) cnt_l --;\\n            if(cnt_r < 0 || cnt_l < 0 || (cnt_r > 0 && cnt_l > 0)) return false;\\n        }\\n        return cnt_r == 0 && cnt_l == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool canTransform(string start, string end) {\\n        if(start.length() != end.length()) return false;\\n        int cnt_r = 0, cnt_l = 0;\\n        for(int i = 0, j = 0; i < start.size(), j < end.size(); i++, j++) {\\n            cnt_r += start[i] == \\'R\\' ? 1 : 0;\\n            cnt_l += end[j] == \\'L\\' ? 1 : 0;\\n            if(end[j] == \\'R\\' && cnt_l == 0) cnt_r --;\\n            if(start[i] == \\'L\\' && cnt_r == 0) cnt_l --;\\n            if(cnt_r < 0 || cnt_l < 0 || (cnt_r > 0 && cnt_l > 0)) return false;\\n        }\\n        return cnt_r == 0 && cnt_l == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113794,
                "title": "o-n-time-o-1-space-c",
                "content": "Let j be the index that is the first that r[j] != r[i]. Moving i from 0 to n, if r[i] == s[i] then do nothing. When r[i] != s[i], it is only feasible to change r to match s if r[i] == 'R' or s[i] == 'L', and one of them is 'X'. In that case the right move is to move r[j] all the way back to i-th position in case r[i] = 'X' and r[j] ='L', or to move r[i] all the way to j-th position if r[i] ='R' and r[j] = 'X'. Either case is equivalent to swap(r[i], r[j]).\\n```\\nclass Solution {\\npublic:\\n    bool can(string r, string s) {\\n        int n = r.size();\\n        r += 'T';\\n        int i = 0, j = 0;\\n        while (i < n) {\\n            while (r[j] == r[i]) ++j;\\n            if (i >= 0 && s[i] != r[i]) {\\n                if (r[i] != 'X' && s[i] != 'X') return false;\\n                if (r[i] == 'R' || s[i] == 'L') {\\n                    if (r[j] != s[i]) return false;\\n                    swap(r[j],r[i]);\\n                }\\n                else return false;\\n            }\\n            ++i;\\n        }\\n        return true;\\n    }    \\n    \\n    bool canTransform(string r, string s) {\\n        if (r.size() != s.size()) return false;\\n        return can(r,s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool can(string r, string s) {\\n        int n = r.size();\\n        r += 'T';\\n        int i = 0, j = 0;\\n        while (i < n) {\\n            while (r[j] == r[i]) ++j;\\n            if (i >= 0 && s[i] != r[i]) {\\n                if (r[i] != 'X' && s[i] != 'X') return false;\\n                if (r[i] == 'R' || s[i] == 'L') {\\n                    if (r[j] != s[i]) return false;\\n                    swap(r[j],r[i]);\\n                }\\n                else return false;\\n            }\\n            ++i;\\n        }\\n        return true;\\n    }    \\n    \\n    bool canTransform(string r, string s) {\\n        if (r.size() != s.size()) return false;\\n        return can(r,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113783,
                "title": "python-o-n-solution",
                "content": "* both strings must have equal character counts\\n* for any substring `end[:i]`, the number of `R` characters must be `<=` those in `start`, since `Rs` only move to the right\\n* for any substring `end[:i]`, the number of `L` characters must be `>=` those in `start`, since `Ls` only move to the left\\n* an `L` and an `R` cannot cross each other, so we must see the same blocks of consecutive `Ls` and `Rs` in both strings. This can be verified by ignoring the `X` characters\\n\\n```\\nclass Solution(object):\\n    def canTransform(self, start, end):\\n        \"\"\"\\n        :type start: str\\n        :type end: str\\n        :rtype: bool\\n        \"\"\"\\n\\n        if collections.Counter(start)!=collections.Counter(end):\\n            return False\\n        \\n        \\n        a,b=0,0\\n        \\n        c,d=0,0\\n        \\n        for i in xrange(len(end)):\\n            a+=start[i]=='R'\\n            b+=end[i]=='R'\\n            if a<b: return False\\n            \\n            c+=start[i]=='L'\\n            d+=end[i]=='L'\\n            if c>d: return False\\n        \\n        return start.replace(\"X\", \"\")==end.replace(\"X\", \"\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canTransform(self, start, end):\\n        \"\"\"\\n        :type start: str\\n        :type end: str\\n        :rtype: bool\\n        \"\"\"\\n\\n        if collections.Counter(start)!=collections.Counter(end):\\n            return False\\n        \\n        \\n        a,b=0,0\\n        \\n        c,d=0,0\\n        \\n        for i in xrange(len(end)):\\n            a+=start[i]=='R'\\n            b+=end[i]=='R'\\n            if a<b: return False\\n            \\n            c+=start[i]=='L'\\n            d+=end[i]=='L'\\n            if c>d: return False\\n        \\n        return start.replace(\"X\", \"\")==end.replace(\"X\", \"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113779,
                "title": "java-o-n-two-pointer-solution",
                "content": "Use two pointer to check the following 2 conditions:\\n1. Without 'X', 'L' and 'R' has the same relative position in start and end\\n2. For any corresponding 'R' in start and end, say start[i] and end[j], i <= j, and for any corresponding 'L', i >= j.\\n```\\npublic boolean canTransform(String start, String end) {\\n    if (start.length() != end.length()) {\\n        return false;\\n    }\\n    int i = 0, j = 0;\\n    while (i < start.length() && j < end.length()) {\\n        if (start.charAt(i) == 'X') {\\n            i++;\\n            continue;\\n        }\\n        else if (end.charAt(j) == 'X') {\\n            j++;\\n            continue;\\n        }\\n        else if (start.charAt(i) == end.charAt(j)) {\\n            if ((start.charAt(i) == 'R' && i > j) || (end.charAt(j) == 'L' && i < j)) {\\n                return false;\\n            }\\n            i++;\\n            j++;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n    while (i < start.length()) {\\n        if (start.charAt(i++) != 'X') {\\n            return false;\\n        }\\n    }\\n    while (j < end.length()) {\\n        if (end.charAt(j++) != 'X') {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canTransform(String start, String end) {\\n    if (start.length() != end.length()) {\\n        return false;\\n    }\\n    int i = 0, j = 0;\\n    while (i < start.length() && j < end.length()) {\\n        if (start.charAt(i) == 'X') {\\n            i++;\\n            continue;\\n        }\\n        else if (end.charAt(j) == 'X') {\\n            j++;\\n            continue;\\n        }\\n        else if (start.charAt(i) == end.charAt(j)) {\\n            if ((start.charAt(i) == 'R' && i > j) || (end.charAt(j) == 'L' && i < j)) {\\n                return false;\\n            }\\n            i++;\\n            j++;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n    while (i < start.length()) {\\n        if (start.charAt(i++) != 'X') {\\n            return false;\\n        }\\n    }\\n    while (j < end.length()) {\\n        if (end.charAt(j++) != 'X') {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113775,
                "title": "python-regex-and-recursion-iterative-versions",
                "content": "The recursive solution is easy to understand, but the recursive version fails in OJ for huge strings with maximum recursion depth exceeded, hence I converted it to iterative version, which gets accepted easily.\\n\\nLogic:\\n\\nIf the current character matches, we just increment i.\\nIf the current character does not match:\\nthen we are trying to find patterns XXXL or RRRX which is basically [X]+L  or [R]+X in regex form.\\nSay XXXL matches the start string, then we just make sure that end string starts with L, and we convert the start string to XXX + remaining  and proceed with the rest of the string\\n\\nIterative version:\\n```\\ndef canTransform(self, start, end):\\n        if start == end: return True\\n        i = 0\\n        while i < len(start):\\n            if start[i] == end[i]:\\n                i += 1\\n            else:\\n                new_se = self.get_transformed(start[i:], end[i:], 'X+L') or self.get_transformed(start[i:], end[i:], 'R+X')\\n                if not new_se: return False\\n                start, end, i = new_se[0], new_se[1], 0\\n        return True\\n\\n    def get_transformed(self, start, end, regex):\\n        m = re.match(regex, start)\\n        if m and end[0] == start[m.end() - 1]:\\n            return (start[0] * (m.end() - 1)) + start[m.end():], end[1:]\\n        return None\\n```\\n\\nRecursive version:\\n\\n    def canTransform(self, start, end):\\n        if start == end: return True\\n\\n        if start[0] == end[0]:\\n            return self.canTransform(start[1:], end[1:])\\n\\n        new_se = self.get_transformed(start, end, 'X+L') or self.get_transformed(start, end, 'R+X')\\n        if new_se: return self.canTransform(new_se[0], new_se[1])\\n\\n        return False\\n    \\n    def get_transformed(self, start, end, regex):\\n        m = re.match(regex, start)\\n        if m and end[0] == start[m.end()-1]:\\n            return (start[0] * (m.end()-1)) + start[m.end():], end[1:]\\n        return None",
                "solutionTags": [],
                "code": "```\\ndef canTransform(self, start, end):\\n        if start == end: return True\\n        i = 0\\n        while i < len(start):\\n            if start[i] == end[i]:\\n                i += 1\\n            else:\\n                new_se = self.get_transformed(start[i:], end[i:], 'X+L') or self.get_transformed(start[i:], end[i:], 'R+X')\\n                if not new_se: return False\\n                start, end, i = new_se[0], new_se[1], 0\\n        return True\\n\\n    def get_transformed(self, start, end, regex):\\n        m = re.match(regex, start)\\n        if m and end[0] == start[m.end() - 1]:\\n            return (start[0] * (m.end() - 1)) + start[m.end():], end[1:]\\n        return None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113771,
                "title": "c-10-line-o-n-solution",
                "content": "````\\n    bool canTransform(string start, string end) {\\n\\n        string s, t;\\n        \\n        FORI (0, start.size ()) if (start[i] != 'X') s += start[i];\\n        FORI (0, end.size ()) if (end[i] != 'X') t += end[i];\\n        \\n        if (s != t) return false;\\n        else {\\n            int sR = 0, sL = 0, eR = 0, eL = 0;\\n            FORI (0, start.size ()) {\\n                if (start[i] == 'L') sL++;\\n                if (start[i] == 'R') sR++;\\n                if (end[i] == 'R') eR++;\\n                if (end[i] == 'L') eL++;\\n\\n                if (eR > sR) return false;\\n                if (sL > eL) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "````\\n    bool canTransform(string start, string end) {\\n\\n        string s, t;\\n        \\n        FORI (0, start.size ()) if (start[i] != 'X') s += start[i];\\n        FORI (0, end.size ()) if (end[i] != 'X') t += end[i];\\n        \\n        if (s != t) return false;\\n        else {\\n            int sR = 0, sL = 0, eR = 0, eL = 0;\\n            FORI (0, start.size ()) {\\n                if (start[i] == 'L') sL++;\\n                if (start[i] == 'R') sR++;\\n                if (end[i] == 'R') eR++;\\n                if (end[i] == 'L') eL++;\\n\\n                if (eR > sR) return false;\\n                if (sL > eL) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3275171,
                "title": "c-4-ms-with-explanation",
                "content": "```\\nbool canTransform(string start, string end) {\\n        int n=start.size();\\n        string s1=\"\",s2=\"\";\\n\\t\\t//we take LR from 1st string and LR from 2nd string if it is not equal it means\\n\\t\\t//count of R & l in both the strings is not equal ex- start=\"X\" end=\"L\"\\n\\t\\t//excluding the below checking we get wrong ans.\\n        for(int i=0;i<n;i++){\\n            if (start[i] != \\'X\\' ){\\n                s1+=start[i];\\n            }\\n            if(end[i] != \\'X\\'){\\n                s2+=end[i];\\n            }\\n        }\\n        if(s1 != s2){\\n            return false;\\n        }\\n\\t\\t//then we check if both conditions are true then we return true.\\n\\t\\t//1.if pos of \\'L\\' of first string is  >= pos of \\'L\\' in second string \\n\\t\\t//2.pos of \\'R\\' in first string is <= pos of \\'R in second string \\n\\t\\t\\n        for(int i=0,j=0;i<n && j<n;){\\n            if(start[i] == \\'X\\'){\\n                i++;\\n                continue;\\n            }\\n            else if(end[j] == \\'X\\'){\\n                j++;\\n                continue;\\n            }\\n            else if(start[i] == \\'R\\' && end[j] == \\'R\\' && i > j || \\n\\t\\t\\tstart[i] == \\'L\\' && end[j] == \\'L\\' && i < j ){\\n                return false;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nbool canTransform(string start, string end) {\\n        int n=start.size();\\n        string s1=\"\",s2=\"\";\\n\\t\\t//we take LR from 1st string and LR from 2nd string if it is not equal it means\\n\\t\\t//count of R & l in both the strings is not equal ex- start=\"X\" end=\"L\"\\n\\t\\t//excluding the below checking we get wrong ans.\\n        for(int i=0;i<n;i++){\\n            if (start[i] != \\'X\\' ){\\n                s1+=start[i];\\n            }\\n            if(end[i] != \\'X\\'){\\n                s2+=end[i];\\n            }\\n        }\\n        if(s1 != s2){\\n            return false;\\n        }\\n\\t\\t//then we check if both conditions are true then we return true.\\n\\t\\t//1.if pos of \\'L\\' of first string is  >= pos of \\'L\\' in second string \\n\\t\\t//2.pos of \\'R\\' in first string is <= pos of \\'R in second string \\n\\t\\t\\n        for(int i=0,j=0;i<n && j<n;){\\n            if(start[i] == \\'X\\'){\\n                i++;\\n                continue;\\n            }\\n            else if(end[j] == \\'X\\'){\\n                j++;\\n                continue;\\n            }\\n            else if(start[i] == \\'R\\' && end[j] == \\'R\\' && i > j || \\n\\t\\t\\tstart[i] == \\'L\\' && end[j] == \\'L\\' && i < j ){\\n                return false;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2697002,
                "title": "simple-java-solution-keep-ordering-of-l-r",
                "content": "The idea is must guarantee:\\n- Number of L, R are the same and keep ordering. \\n- Number of X on the left of L from `end` always less than or equal the corresponding L from `start`\\n- Number of X on the right of R from `end` always more than or equal the corresponding R from `start`\\n\\nWe can terminate the process early once got the first violation, no need to loop through the end of `start`.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        Queue<Node> logs = new LinkedList<>();\\n\\n        int count = 0;\\n        for (char c : start.toCharArray()) {\\n            if (c == \\'X\\') count++;\\n            else {\\n                logs.add(new Node(c, count));\\n            }\\n        }\\n\\n        count = 0;\\n        for (char c : end.toCharArray()) {\\n            if (c == \\'X\\') count++;\\n            else {\\n                if (logs.isEmpty()) return false;\\n\\n                Node node = logs.poll();\\n                if (c != node.c) return false;\\n\\n                if (c == \\'L\\' && count > node.count) return false;\\n                if (c == \\'R\\' && count < node.count) return false;                \\n            }\\n        }\\n\\n        return logs.isEmpty();\\n    }\\n\\n    class Node {\\n        public Character c;\\n        public int count;\\n\\n        public Node(Character c, int count) {\\n            this.c = c;\\n            this.count = count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        Queue<Node> logs = new LinkedList<>();\\n\\n        int count = 0;\\n        for (char c : start.toCharArray()) {\\n            if (c == \\'X\\') count++;\\n            else {\\n                logs.add(new Node(c, count));\\n            }\\n        }\\n\\n        count = 0;\\n        for (char c : end.toCharArray()) {\\n            if (c == \\'X\\') count++;\\n            else {\\n                if (logs.isEmpty()) return false;\\n\\n                Node node = logs.poll();\\n                if (c != node.c) return false;\\n\\n                if (c == \\'L\\' && count > node.count) return false;\\n                if (c == \\'R\\' && count < node.count) return false;                \\n            }\\n        }\\n\\n        return logs.isEmpty();\\n    }\\n\\n    class Node {\\n        public Character c;\\n        public int count;\\n\\n        public Node(Character c, int count) {\\n            this.c = c;\\n            this.count = count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561039,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar canTransform = function(start, end) {\\n\\t\\tlet L = R = 0;\\n\\n\\t\\tfor (let index = 0; index < start.length; index++) {\\n\\t\\t\\tstart[index] === \\'R\\' && R++;\\n\\t\\t\\tend[index] === \\'L\\' && L++;\\n\\t\\t\\tif (R > 0 && L > 0) return false;\\n\\n\\t\\t\\tstart[index] === \\'L\\' && L--;\\n\\t\\t\\tend[index] === \\'R\\' && R--;\\n\\t\\t\\tif (L < 0 || R < 0) return false;\\n\\t\\t}\\n\\t\\treturn L === 0 && R === 0;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar canTransform = function(start, end) {\\n\\t\\tlet L = R = 0;\\n\\n\\t\\tfor (let index = 0; index < start.length; index++) {\\n\\t\\t\\tstart[index] === \\'R\\' && R++;\\n\\t\\t\\tend[index] === \\'L\\' && L++;\\n\\t\\t\\tif (R > 0 && L > 0) return false;\\n\\n\\t\\t\\tstart[index] === \\'L\\' && L--;\\n\\t\\t\\tend[index] === \\'R\\' && R--;\\n\\t\\t\\tif (L < 0 || R < 0) return false;\\n\\t\\t}\\n\\t\\treturn L === 0 && R === 0;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2531738,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end)\\n    {\\n        int n=start.size();\\n        string s1,s2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(start[i]!=\\'X\\')\\n                s1+=start[i];\\n        }\\n         for(int i=0;i<n;i++)\\n        {\\n            if(end[i]!=\\'X\\')\\n                s2+=end[i];\\n        }\\n        if(s1!=s2)\\n            return false;\\n        for(int i=0,j=0;i<n&&j<n;)\\n        {\\n            while(i<n&&start[i]==\\'X\\')\\n                i++;\\n            while(j<n&&end[j]==\\'X\\')\\n                j++;\\n            if(start[i]==\\'L\\'&&i<j||start[i]==\\'R\\'&&i>j)\\n                return false;\\n            i++;\\n            j++;\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool canTransform(string start, string end)\\n    {\\n        int n=start.size();\\n        string s1,s2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(start[i]!=\\'X\\')\\n                s1+=start[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2376521,
                "title": "explain-failing-test-case",
                "content": "Could someone please explain why this test case returns false?\\n\"LXXL\"\\n\"XLLX\"\\n\\nWe can only transform XL to LX, right?\\nSo transform the 2nd XL of start\\nand 1st XL of end.\\n\\n\"LX  -XL-\" -> LX LX\\n\"-XL- LX\"  -> LX LX\\n\\nI must be trippin here\\n\\nEDIT: Nvm, I think I understand. We can only modifiy one string.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2304125,
                "title": "four-easy-steps-c",
                "content": "If you observe, it is clear that\\nL can keep moving left till there is an X before it.\\nR can keep moving right till there is an X ahead of it.\\n\\nConstarints that should be there if start can convert to end:\\n1. Both strings should be anagrams of each other.\\n2. Relative positions of R and L in start should not change in end.\\n   This means if i remove all X from both strings, what is left of both\\n   should be same.\\n3. position of R in start <= position of R in end\\n4. position of L in start >= position of L in end\\n\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        //check for anagrams first\\n        //According to given constaraints in problem,\\n        //start.length == end.length, so just checking for 2. above\\n        //will also check for point 1.\\n        \\n        //remove all X from both.\\n        //At the same time, also record positions of R and L in\\n        //both strings. This can be done inplace as well to save space.\\n        vector<int> pos_l_start;\\n        vector<int> pos_r_start;\\n        vector<int> pos_l_end;\\n        vector<int> pos_r_end;\\n        string new_start, new_end;\\n        for(int i=0;i<start.length();i++) {\\n            if(start[i]!=\\'X\\')\\n            {\\n                new_start+=start[i];\\n                start[i] == \\'L\\'? pos_l_start.push_back(i):pos_r_start.push_back(i);\\n            }\\n            if(end[i]!=\\'X\\'){\\n                new_end+=end[i];\\n                end[i] == \\'L\\'? pos_l_end.push_back(i):pos_r_end.push_back(i);\\n            }\\n        }\\n\\n        if(new_start.compare(new_end) != 0)\\n            return false;\\n        //compare relative positions of L in start and end\\n        for(int i=0;i<pos_l_start.size();i++) {\\n            if(pos_l_start[i] < pos_l_end[i])\\n                return false;\\n        }\\n        //compare relative positions of R in start and end\\n        for(int i=0;i<pos_r_start.size();i++) {\\n            if(pos_r_start[i] > pos_r_end[i])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        //check for anagrams first\\n        //According to given constaraints in problem,\\n        //start.length == end.length, so just checking for 2. above\\n        //will also check for point 1.\\n        \\n        //remove all X from both.\\n        //At the same time, also record positions of R and L in\\n        //both strings. This can be done inplace as well to save space.\\n        vector<int> pos_l_start;\\n        vector<int> pos_r_start;\\n        vector<int> pos_l_end;\\n        vector<int> pos_r_end;\\n        string new_start, new_end;\\n        for(int i=0;i<start.length();i++) {\\n            if(start[i]!=\\'X\\')\\n            {\\n                new_start+=start[i];\\n                start[i] == \\'L\\'? pos_l_start.push_back(i):pos_r_start.push_back(i);\\n            }\\n            if(end[i]!=\\'X\\'){\\n                new_end+=end[i];\\n                end[i] == \\'L\\'? pos_l_end.push_back(i):pos_r_end.push_back(i);\\n            }\\n        }\\n\\n        if(new_start.compare(new_end) != 0)\\n            return false;\\n        //compare relative positions of L in start and end\\n        for(int i=0;i<pos_l_start.size();i++) {\\n            if(pos_l_start[i] < pos_l_end[i])\\n                return false;\\n        }\\n        //compare relative positions of R in start and end\\n        for(int i=0;i<pos_r_start.size();i++) {\\n            if(pos_r_start[i] > pos_r_end[i])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290578,
                "title": "c-two-pointers-time-o-n-space-o-1",
                "content": "Two pointers solution\\n\\n```\\ngiven moves:\\n\"XL\" -> \"LX\" : imagine \\'L\\' can possibly move along to its left if there are as many as possible \\'X\\' on its left\\n\"RX\" -> \"XR\" : imagine \\'R\\' can possibly move along to its right if there are as many as possible \\'X\\' on its right\\n```\\n\\nthey will stuck on their moves when they meet to each other\\nwe use two pointers `s` and `e` to implement `where the \\'L\\' and \\'R\\' will possibly move to` based on the given moves and stuck\\n![image](https://assets.leetcode.com/users/images/1bd738a0-f7e3-4a36-83e5-e4c19cfe877e_1657980819.0553403.png)\\n\\n\\n```\\n// time: O(n)\\n// space: O(1)\\n\\nclass Solution {\\npublic:\\n  bool canTransform(string& start, string& end) {\\n    int n = start.length();\\n    \\n    int s = 0, e = 0;\\n    while (s < n or e < n) {\\n      while (s < n and start[s] == \\'X\\')\\n        s++;\\n      while (e < n and end[e] == \\'X\\')\\n        e++;\\n      \\n      if (s == n or e == n) // if one of them run out of bound\\n        return s == n and e == n; // -> check if both of them are out of bound\\n      \\n      if ((start[s] != end[e]) or // if they are not the same character\\n          (start[s] == \\'L\\' and s < e) or // they are \\'L\\' but index s should be >= index e\\n          (start[s] == \\'R\\' and s > e)) // they are \\'R\\' but index s should be <= index e\\n        return false;\\n      \\n      s++;\\n      e++;\\n    }\\n    \\n    return true;\\n  }\\n};\\n```\\n\\nThanks for watching : )",
                "solutionTags": [],
                "code": "```\\ngiven moves:\\n\"XL\" -> \"LX\" : imagine \\'L\\' can possibly move along to its left if there are as many as possible \\'X\\' on its left\\n\"RX\" -> \"XR\" : imagine \\'R\\' can possibly move along to its right if there are as many as possible \\'X\\' on its right\\n```\n```\\n// time: O(n)\\n// space: O(1)\\n\\nclass Solution {\\npublic:\\n  bool canTransform(string& start, string& end) {\\n    int n = start.length();\\n    \\n    int s = 0, e = 0;\\n    while (s < n or e < n) {\\n      while (s < n and start[s] == \\'X\\')\\n        s++;\\n      while (e < n and end[e] == \\'X\\')\\n        e++;\\n      \\n      if (s == n or e == n) // if one of them run out of bound\\n        return s == n and e == n; // -> check if both of them are out of bound\\n      \\n      if ((start[s] != end[e]) or // if they are not the same character\\n          (start[s] == \\'L\\' and s < e) or // they are \\'L\\' but index s should be >= index e\\n          (start[s] == \\'R\\' and s > e)) // they are \\'R\\' but index s should be <= index e\\n        return false;\\n      \\n      s++;\\n      e++;\\n    }\\n    \\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285502,
                "title": "java-solution",
                "content": "```\\n//check for first occurance of L or R in both strings as L can only move toward left and R to the right\\n//make two pointers and check if L pointer in second string is left or equal to L pointer in first string and same for R\\n public boolean canTransform(String start, String end) {\\n       // checking if they are at equal postions\\n        if(!start.replace(\"X\",\"\").equals(end.replace(\"X\",\"\"))){\\n            return false;\\n        }\\n        int p1=0;\\n        int p2=0;\\n        while(p1<start.length() &&p2<end.length()){\\n            while(p1<start.length() && start.charAt(p1)==\\'X\\'){\\n                p1++;\\n            }\\n            while(p2<end.length() && end.charAt(p2)==\\'X\\'){\\n                p2++;\\n            }\\n            //if both pointers reach the end then its true\\n            if(p1==start.length() &&p2==end.length()){\\n                return true;\\n            }\\n            //if only one reach the end then its false\\n             if(p1==start.length()||p2==end.length()){\\n                return false;\\n            }\\n            \\n            //check if they both are equal\\n            if(start.charAt(p1)!=end.charAt(p2)){\\n                return false;\\n            }\\n            // as l can only move to the left\\n            if(start.charAt(p1)==\\'L\\' &&p2>p1){\\n                return false;\\n            }\\n            \\n            //as r can only move to the right\\n              if(start.charAt(p1)==\\'R\\' &&p1>p2){\\n                return false;\\n            }\\n          p1++;\\n            p2++;\\n            \\n            \\n            \\n        }\\n        return true;\\n\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n//check for first occurance of L or R in both strings as L can only move toward left and R to the right\\n//make two pointers and check if L pointer in second string is left or equal to L pointer in first string and same for R\\n public boolean canTransform(String start, String end) {\\n       // checking if they are at equal postions\\n        if(!start.replace(\"X\",\"\").equals(end.replace(\"X\",\"\"))){\\n            return false;\\n        }\\n        int p1=0;\\n        int p2=0;\\n        while(p1<start.length() &&p2<end.length()){\\n            while(p1<start.length() && start.charAt(p1)==\\'X\\'){\\n                p1++;\\n            }\\n            while(p2<end.length() && end.charAt(p2)==\\'X\\'){\\n                p2++;\\n            }\\n            //if both pointers reach the end then its true\\n            if(p1==start.length() &&p2==end.length()){\\n                return true;\\n            }\\n            //if only one reach the end then its false\\n             if(p1==start.length()||p2==end.length()){\\n                return false;\\n            }\\n            \\n            //check if they both are equal\\n            if(start.charAt(p1)!=end.charAt(p2)){\\n                return false;\\n            }\\n            // as l can only move to the left\\n            if(start.charAt(p1)==\\'L\\' &&p2>p1){\\n                return false;\\n            }\\n            \\n            //as r can only move to the right\\n              if(start.charAt(p1)==\\'R\\' &&p1>p2){\\n                return false;\\n            }\\n          p1++;\\n            p2++;\\n            \\n            \\n            \\n        }\\n        return true;\\n\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281949,
                "title": "o-n-simple-solution-counting-r-and-l",
                "content": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        List<Pair<Character, Integer>> startRandL = new ArrayList<>();\\n        List<Pair<Character, Integer>> endRandL = new ArrayList<>();\\n        \\n        for(int i = 0; i < start.length(); i++) {\\n            if(start.charAt(i) != \\'X\\') {\\n                startRandL.add(new Pair(start.charAt(i), i));\\n            }\\n            if(end.charAt(i) != \\'X\\') {\\n                endRandL.add(new Pair(end.charAt(i), i));\\n            }\\n        }\\n        \\n        if(startRandL.size() != endRandL.size()) {\\n            return false;\\n        }\\n        \\n        for(int i = 0; i < startRandL.size(); i++) {\\n            Pair<Character, Integer> startPair = startRandL.get(i);\\n            Pair<Character, Integer> endPair = endRandL.get(i);\\n            if(startPair.getKey() == \\'L\\' && endPair.getKey() == \\'L\\') {\\n                if(startPair.getValue() < endPair.getValue()) {\\n                    return false;\\n                }\\n            }\\n            else if(startPair.getKey() == \\'R\\' && endPair.getKey() == \\'R\\') {\\n                if(startPair.getValue() > endPair.getValue()) {\\n                    return false;\\n                }\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        List<Pair<Character, Integer>> startRandL = new ArrayList<>();\\n        List<Pair<Character, Integer>> endRandL = new ArrayList<>();\\n        \\n        for(int i = 0; i < start.length(); i++) {\\n            if(start.charAt(i) != \\'X\\') {\\n                startRandL.add(new Pair(start.charAt(i), i));\\n            }\\n            if(end.charAt(i) != \\'X\\') {\\n                endRandL.add(new Pair(end.charAt(i), i));\\n            }\\n        }\\n        \\n        if(startRandL.size() != endRandL.size()) {\\n            return false;\\n        }\\n        \\n        for(int i = 0; i < startRandL.size(); i++) {\\n            Pair<Character, Integer> startPair = startRandL.get(i);\\n            Pair<Character, Integer> endPair = endRandL.get(i);\\n            if(startPair.getKey() == \\'L\\' && endPair.getKey() == \\'L\\') {\\n                if(startPair.getValue() < endPair.getValue()) {\\n                    return false;\\n                }\\n            }\\n            else if(startPair.getKey() == \\'R\\' && endPair.getKey() == \\'R\\') {\\n                if(startPair.getValue() > endPair.getValue()) {\\n                    return false;\\n                }\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261866,
                "title": "c-simple-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string t) {\\n        vector<pair<char,int>> v1;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=\\'X\\') v1.push_back({s[i],i});\\n        }\\n        vector<pair<char,int>> v2;\\n        for(int i=0;i<n;i++){\\n            if(t[i]!=\\'X\\') v2.push_back({t[i],i});\\n        }\\n        if(v1.size()!=v2.size()) return false;\\n        for(int i=0;i<v1.size();i++){\\n            if(v1[i].first!=v2[i].first) return false;\\n            if(v1[i].first==\\'L\\'){\\n                if(v1[i].second<v2[i].second) return false;\\n            }\\n            if(v1[i].first==\\'R\\'){\\n                if(v1[i].second>v2[i].second) return false;\\n            }\\n        }return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string t) {\\n        vector<pair<char,int>> v1;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=\\'X\\') v1.push_back({s[i],i});\\n        }\\n        vector<pair<char,int>> v2;\\n        for(int i=0;i<n;i++){\\n            if(t[i]!=\\'X\\') v2.push_back({t[i],i});\\n        }\\n        if(v1.size()!=v2.size()) return false;\\n        for(int i=0;i<v1.size();i++){\\n            if(v1[i].first!=v2[i].first) return false;\\n            if(v1[i].first==\\'L\\'){\\n                if(v1[i].second<v2[i].second) return false;\\n            }\\n            if(v1[i].first==\\'R\\'){\\n                if(v1[i].second>v2[i].second) return false;\\n            }\\n        }return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244595,
                "title": "python-time-o-n-space-o-1-one-pass-solution",
                "content": "We can observe that **\"L\" can only move to left** and **\"R\" can only move to right**, as long as we have X in between. \\n\\nWhen comparing ```start``` and ```end```\\n- We can handle missing ```\"L\"``` in ```start``` because we can move future ```\"L\"``` to the left\\n- We can handle excess ```\"R\"``` in ```start``` because we can move excess ```\"R\"``` to right as needed\\n- But movement can only happen assuming we have continous ```\"X\"```\\n\\nSo all we have to do is to keep track of ```L``` and ```R``` seen so far, and check certain conditions. \\n\\n```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n\\t\\t# keep track of char counts\\n        count = {\"X\":0, \"R\":0, \"L\":0}\\n\\t\\t\\n        for char1, char2 in zip(start, end):\\n            count[char1] += 1\\n            count[char2] -= 1\\n            \\n\\t\\t\\t# we can only freely move if we have continous \"X\"\\n\\t\\t\\t# so if we have \"L\" then \"R\" count should be zero and vice versa\\n            if (\"L\" in (char1, char2) and count[\"R\"]!=0) or (\"R\" in (char1, char2) and count[\"L\"]!=0):\\n                return False\\n            \\n\\t\\t\\t# positive \"L\" means we have more \"L\" in start than end at this point\\n\\t\\t\\t# and since \"L\" can only move to left, we have excess of \"L\" in start\\n\\t\\t\\t# reverse is true for \"R\"\\n            if count[\"L\"] > 0 or count[\"R\"] < 0:\\n                return False\\n\\t\\t\\n\\t\\t# make sure all char counts are zero\\n        return not any(count.values())\\n```",
                "solutionTags": [],
                "code": "```start```\n```end```\n```\"L\"```\n```start```\n```\"L\"```\n```\"R\"```\n```start```\n```\"R\"```\n```\"X\"```\n```L```\n```R```\n```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n\\t\\t# keep track of char counts\\n        count = {\"X\":0, \"R\":0, \"L\":0}\\n\\t\\t\\n        for char1, char2 in zip(start, end):\\n            count[char1] += 1\\n            count[char2] -= 1\\n            \\n\\t\\t\\t# we can only freely move if we have continous \"X\"\\n\\t\\t\\t# so if we have \"L\" then \"R\" count should be zero and vice versa\\n            if (\"L\" in (char1, char2) and count[\"R\"]!=0) or (\"R\" in (char1, char2) and count[\"L\"]!=0):\\n                return False\\n            \\n\\t\\t\\t# positive \"L\" means we have more \"L\" in start than end at this point\\n\\t\\t\\t# and since \"L\" can only move to left, we have excess of \"L\" in start\\n\\t\\t\\t# reverse is true for \"R\"\\n            if count[\"L\"] > 0 or count[\"R\"] < 0:\\n                return False\\n\\t\\t\\n\\t\\t# make sure all char counts are zero\\n        return not any(count.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218747,
                "title": "well-documented-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        \\n        String removedStart = start.replaceAll(\"X\",\"\");\\n        String removedEnd = end.replaceAll(\"X\",\"\");\\n\\n        //L\\'s and R\\'s can\\'t cross, so after we\\'ve pruned the X\\'s, the strings should match.\\n        //If they don\\'t, the starting and ending strings cannot be made to match.\\n        if(!removedStart.equals(removedEnd))\\n            return false;\\n\\n        //Can the Ls move only left?\\n        if(!checkLOrROnlyMoveLeftOrRight(start, end, \"L\"))\\n            return false;\\n\\n        //Can the Rs move only right?\\n        if(!checkLOrROnlyMoveLeftOrRight(start, end, \"R\"))\\n            return false;\\n\\n        return true;\\n        \\n    }\\n    \\n    /**\\n     * This function checks to be sure that L\\'s in the start string only\\n     * need to move left to match the end string.\\n     */\\n    private boolean checkLOrROnlyMoveLeftOrRight(String start, String end, String lor)\\n    {\\n        //Find the first L/R in the end string:\\n        int endIndex = end.indexOf(lor);\\n        int startIndex=0;\\n        while(endIndex>-1) //While there are more L\\'s/R\\'s...\\n        {\\n            //Find the next index of L/R in the starting index.\\n            startIndex = start.indexOf(lor, startIndex);\\n            \\n            switch(lor){\\n                case \"L\":\\n                    //If the starting index of L is less than the ending index of L, then return false\\n                    //because L\\'s can only move left.\\n                    if(startIndex<endIndex)\\n                        return false;\\n                        break;\\n                case \"R\":\\n                    //If the starting index of R is greater than the ending index of R, then return false\\n                    //because R\\'s can only move right.\\n                    if(startIndex>endIndex)\\n                        return false;\\n                        break;\\n                default:\\n                    //In production, throw an error. Here, not so much.\\n                    break;\\n            }\\n            \\n            //The next time we search for an L/R in the start string, search after the L/R\\n            //that was just found.\\n            startIndex++;\\n            //Find the next L/R in the end string.\\n            endIndex = end.indexOf(lor,endIndex+1);\\n        }\\n        \\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        \\n        String removedStart = start.replaceAll(\"X\",\"\");\\n        String removedEnd = end.replaceAll(\"X\",\"\");\\n\\n        //L\\'s and R\\'s can\\'t cross, so after we\\'ve pruned the X\\'s, the strings should match.\\n        //If they don\\'t, the starting and ending strings cannot be made to match.\\n        if(!removedStart.equals(removedEnd))\\n            return false;\\n\\n        //Can the Ls move only left?\\n        if(!checkLOrROnlyMoveLeftOrRight(start, end, \"L\"))\\n            return false;\\n\\n        //Can the Rs move only right?\\n        if(!checkLOrROnlyMoveLeftOrRight(start, end, \"R\"))\\n            return false;\\n\\n        return true;\\n        \\n    }\\n    \\n    /**\\n     * This function checks to be sure that L\\'s in the start string only\\n     * need to move left to match the end string.\\n     */\\n    private boolean checkLOrROnlyMoveLeftOrRight(String start, String end, String lor)\\n    {\\n        //Find the first L/R in the end string:\\n        int endIndex = end.indexOf(lor);\\n        int startIndex=0;\\n        while(endIndex>-1) //While there are more L\\'s/R\\'s...\\n        {\\n            //Find the next index of L/R in the starting index.\\n            startIndex = start.indexOf(lor, startIndex);\\n            \\n            switch(lor){\\n                case \"L\":\\n                    //If the starting index of L is less than the ending index of L, then return false\\n                    //because L\\'s can only move left.\\n                    if(startIndex<endIndex)\\n                        return false;\\n                        break;\\n                case \"R\":\\n                    //If the starting index of R is greater than the ending index of R, then return false\\n                    //because R\\'s can only move right.\\n                    if(startIndex>endIndex)\\n                        return false;\\n                        break;\\n                default:\\n                    //In production, throw an error. Here, not so much.\\n                    break;\\n            }\\n            \\n            //The next time we search for an L/R in the start string, search after the L/R\\n            //that was just found.\\n            startIndex++;\\n            //Find the next L/R in the end string.\\n            endIndex = end.indexOf(lor,endIndex+1);\\n        }\\n        \\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122478,
                "title": "python-2-pointers-minimize-if-conditions",
                "content": "by applying the 2 rules, \\'L\\' can only go left, \\'R\\' can only go right, thay implies\\n1. the pattern of \\'L\\' and \\'R\\' must be the same in the 2 strings\\n2. during the search, the position of \\'L\\' at `start` should  \\'>=\\' the correspond position at `end`, so it can be moved left.\\n3. position of \\'R\\' at `start` should \\'>=\\' the correspond position at `end` in order to be moved right.\\n\\n\\n```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if start.replace(\"X\", \"\") != end.replace(\"X\", \"\"):\\n            return False\\n\\n        def nxt_not_x(s: str, si=0):\\n            while si < len(s) and s[si] == \"X\":\\n                si += 1\\n            return si\\n\\n        i = nxt_not_x(start, 0)\\n        j = nxt_not_x(end, 0)\\n        while i < len(start) and j < len(end):\\n            if start[i] == \"L\" and i < j:\\n                break\\n            elif start[i] == \"R\" and i > j:\\n                break\\n            i = nxt_not_x(start, i + 1)\\n            j = nxt_not_x(end, j + 1)\\n\\n        return i == len(start) and j == len(end)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if start.replace(\"X\", \"\") != end.replace(\"X\", \"\"):\\n            return False\\n\\n        def nxt_not_x(s: str, si=0):\\n            while si < len(s) and s[si] == \"X\":\\n                si += 1\\n            return si\\n\\n        i = nxt_not_x(start, 0)\\n        j = nxt_not_x(end, 0)\\n        while i < len(start) and j < len(end):\\n            if start[i] == \"L\" and i < j:\\n                break\\n            elif start[i] == \"R\" and i > j:\\n                break\\n            i = nxt_not_x(start, i + 1)\\n            j = nxt_not_x(end, j + 1)\\n\\n        return i == len(start) and j == len(end)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034224,
                "title": "python-simple-for-loop-and-lr-count",
                "content": "Referenced from https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/1536718/Python-Check-their-positions-with-Picture-Clean-and-Concise\\n\\nhttps://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/873004/Easy-to-understand-explanation-with-PICTURE\\n\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if len(start) != len(end):\\n            return False\\n        \\n        if start.replace(\"X\",\"\") != end.replace(\"X\",\"\"):\\n            return False\\n        \\n        \\n        start_L_cnt = 0\\n        end_L_cnt = 0\\n\\n        start_R_cnt = 0\\n        end_R_cnt = 0\\n        \\n        for i in range(len(start)):\\n            if start[i] == \\'L\\':\\n                start_L_cnt+=1\\n            if end[i] == \\'L\\':\\n                end_L_cnt +=1\\n                \\n            if start_L_cnt > end_L_cnt: ## L can not move to Right Side\\n                return False\\n            \\n            if start[i] == \\'R\\':\\n                start_R_cnt+=1\\n            if end[i] == \\'R\\':\\n                end_R_cnt +=1\\n                \\n            if start_R_cnt < end_R_cnt:## R can not move to Left Side\\n                return False\\n            \\n        return True\\n\\t\\t\\n\\n",
                "solutionTags": [],
                "code": "Referenced from https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/1536718/Python-Check-their-positions-with-Picture-Clean-and-Concise\\n\\nhttps://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/873004/Easy-to-understand-explanation-with-PICTURE\\n\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if len(start) != len(end):\\n            return False\\n        \\n        if start.replace(\"X\",\"\") != end.replace(\"X\",\"\"):\\n            return False\\n        \\n        \\n        start_L_cnt = 0\\n        end_L_cnt = 0\\n\\n        start_R_cnt = 0\\n        end_R_cnt = 0\\n        \\n        for i in range(len(start)):\\n            if start[i] == \\'L\\':\\n                start_L_cnt+=1\\n            if end[i] == \\'L\\':\\n                end_L_cnt +=1\\n                \\n            if start_L_cnt > end_L_cnt: ## L can not move to Right Side\\n                return False\\n            \\n            if start[i] == \\'R\\':\\n                start_R_cnt+=1\\n            if end[i] == \\'R\\':\\n                end_R_cnt +=1\\n                \\n            if start_R_cnt < end_R_cnt:## R can not move to Left Side\\n                return False\\n            \\n        return True\\n\\t\\t\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1968050,
                "title": "linear-solution-with-duque-c",
                "content": "Idea:\\n* if you remove all Xs in both strings, they should be the same. Why? because there is no transition of RL or LR so they cannot pass each others. I store compressed version of start and end in two strings as we go. \\n* Rs in start string apear at the same index as end or later. So when we are visiting Rs in start string, we can just put the index of that at the back of its deque. \\n* Similarly, Ls in end string apear at the same index as start string or later. So when we are visiting L\\'s in the end string, we can just put the index of that at the back of its deque. \\n* when we are visiting L in start string, we MUST have an index in L queue and the index MUST be equal or less than the current. If so, we pop front and move on.\\n* You can guess the last one! \\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n\\t\\n        if (start.size() != end.size()) return false;\\n        \\n        string s_comp =\"\", e_comp=\"\";\\n        deque<int> Rs, Ls;\\n        \\n        for(int i=0; i<start.size(); i++)\\n        {\\n            if (start[i] != \\'X\\')\\n                s_comp+=start[i];\\n            \\n            if (end[i] != \\'X\\')\\n                e_comp+=end[i];\\n            \\n            if (start[i] == \\'R\\')\\n                Rs.push_back(i);\\n            \\n            if (end[i] == \\'L\\')\\n                Ls.push_back(i);\\n            \\n            if (start[i] == \\'L\\')\\n            {\\n                if (Ls.empty() || Ls.front() > i) return false;\\n                else\\n                    Ls.pop_front();\\n            }\\n            \\n            if (end[i] == \\'R\\')\\n            {\\n                if (Rs.empty() || Rs.front() > i) return false;\\n                else\\n                    Rs.pop_front();\\n            }\\n        }\\n        return s_comp == e_comp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n\\t\\n        if (start.size() != end.size()) return false;\\n        \\n        string s_comp =\"\", e_comp=\"\";\\n        deque<int> Rs, Ls;\\n        \\n        for(int i=0; i<start.size(); i++)\\n        {\\n            if (start[i] != \\'X\\')\\n                s_comp+=start[i];\\n            \\n            if (end[i] != \\'X\\')\\n                e_comp+=end[i];\\n            \\n            if (start[i] == \\'R\\')\\n                Rs.push_back(i);\\n            \\n            if (end[i] == \\'L\\')\\n                Ls.push_back(i);\\n            \\n            if (start[i] == \\'L\\')\\n            {\\n                if (Ls.empty() || Ls.front() > i) return false;\\n                else\\n                    Ls.pop_front();\\n            }\\n            \\n            if (end[i] == \\'R\\')\\n            {\\n                if (Rs.empty() || Rs.front() > i) return false;\\n                else\\n                    Rs.pop_front();\\n            }\\n        }\\n        return s_comp == e_comp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929091,
                "title": "c-simple-single-pass-solution-0ms",
                "content": "```\\nbool canTransform(char * start, char * end){\\n    int r = 0, l = 0;\\n        for(int i = 0; start[i] != \\'\\\\0\\'; ++i){\\n            if(start[i] == \\'R\\'){\\n                if(l) return false;\\n                ++r;\\n            }\\n            if(end[i] == \\'L\\'){\\n                if(r) return false;\\n                ++l;\\n            }\\n            if(end[i] == \\'R\\'){\\n                if(r == 0) return false;\\n                --r;\\n            }\\n            if(start[i] == \\'L\\'){\\n                if(l == 0) return false;\\n                --l;\\n            }\\n        }\\n        return r == 0 && l == 0 ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canTransform(char * start, char * end){\\n    int r = 0, l = 0;\\n        for(int i = 0; start[i] != \\'\\\\0\\'; ++i){\\n            if(start[i] == \\'R\\'){\\n                if(l) return false;\\n                ++r;\\n            }\\n            if(end[i] == \\'L\\'){\\n                if(r) return false;\\n                ++l;\\n            }\\n            if(end[i] == \\'R\\'){\\n                if(r == 0) return false;\\n                --r;\\n            }\\n            if(start[i] == \\'L\\'){\\n                if(l == 0) return false;\\n                --l;\\n            }\\n        }\\n        return r == 0 && l == 0 ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925967,
                "title": "python-simple-o-n-time-o-1-space-single-pass",
                "content": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        num_r = num_l = 0\\n        for i in range(len(start)):\\n            if start[i] == \\'R\\':\\n                if num_l:\\n                    return False\\n                num_r += 1\\n            elif start[i] == \\'L\\':\\n                if num_r:\\n                    return False\\n                num_l -= 1\\n            if end[i] == \\'R\\':\\n                num_r -= 1\\n            elif end[i] == \\'L\\':\\n                num_l += 1\\n            if num_r < 0 or num_l < 0:\\n                return False\\n        return not (num_r or num_l)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        num_r = num_l = 0\\n        for i in range(len(start)):\\n            if start[i] == \\'R\\':\\n                if num_l:\\n                    return False\\n                num_r += 1\\n            elif start[i] == \\'L\\':\\n                if num_r:\\n                    return False\\n                num_l -= 1\\n            if end[i] == \\'R\\':\\n                num_r -= 1\\n            elif end[i] == \\'L\\':\\n                num_l += 1\\n            if num_r < 0 or num_l < 0:\\n                return False\\n        return not (num_r or num_l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840438,
                "title": "java-o-n-solution-using-swaps-to-build-answer-not-2-pointer",
                "content": "Code followed by explanation:\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        char[] startChars = start.toCharArray();\\n        int n = startChars.length;\\n        int candidateNextL = -1;\\n        int candidateNextX = -1;\\n        for(int i=0; i<n; i++) {\\n            char target = end.charAt(i);\\n            if (startChars[i] == target) {\\n                // great, we match at this position\\n                continue;\\n            }\\n            if (target == \\'R\\') {\\n                /*\\n                so we want an R. But we have X or L.\\n                We can\\'t bring an R though either.\\n                R can only go Right\\n                */\\n                return false;\\n            } else if (target == \\'L\\') {\\n                if (startChars[i] == \\'R\\') {\\n                    // no L can make it\\'s way left thru the R\\n                    return false;\\n                }\\n                /* ok so at an X. Keep scanning\\n                want something like X..XL\\n                that way can pull an L from right\\n                */\\n                int curr = Math.max(i+1, candidateNextL);\\n                while(curr < n && startChars[curr] == \\'X\\') {\\n                    curr++;\\n                }\\n                if (curr == n) {\\n                    // reached end only found Xs no L to borrow\\n                    return false;\\n                }\\n                if (startChars[curr] == \\'R\\') {\\n                    return false;\\n                }\\n                // great, finally found L after 1 or more X\\'s so use it\\n                swap(curr, i, startChars);\\n                candidateNextL = curr + 1; // found all X\\'s till curr and L is used..\\n            } else {\\n                // target = X\\n                if (startChars[i] == \\'L\\') {\\n                    // L blocks.\\n                    return false;\\n                }\\n                // this time go thru all the filler R\\'s\\n                int curr = Math.max(i+1, candidateNextX);\\n                while(curr < n && startChars[curr] == \\'R\\') {\\n                    curr++;\\n                }\\n                if (curr == n) {\\n                    // reached end only found Rs no X to borrow\\n                    return false;\\n                }\\n                if (startChars[curr] == \\'L\\') {\\n                    return false;\\n                }\\n                // great, finally found X after 1 or more R\\'s so use it\\n                swap(curr, i, startChars);\\n                candidateNextX = curr + 1;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private void swap(int pos1, int pos2, char[] arr) {\\n        char tmp = arr[pos1];\\n        arr[pos1] = arr[pos2];\\n        arr[pos2] = tmp;\\n    }\\n}\\n\\n```\\n\\nI looked at top recommended answers and didn\\'t come up with the right and left \"walkers\" approach which in hindsight is really intuitive.  However, I went for an approach that seemed natural to me (didn\\'t read Hint before solving): for every position ```i```, we try to make ```start[i] = end[i]``` and return ```false``` first time we are unable to.\\n\\nThere are 3 cases for mismatches ```start[i] != end[i]``` that we have to handle. \\n1. Case ```end[i] == R```: return false on mismatch. X??? cannot transform to R??? as R can\\'t migrate left and same for L???\\n2. Case ```end[i] == L```: If ```start[i] == R``` here then return false because R??? cannot transform into L??? because while L can migrate left thru X\\'s it can\\'t do so through an R. However if ```start[i] == X``` then X...XL (all intermediate are X\\'s) can potentially transform into L??? because through a series of swaps we can borrow the first L after the Xs (ex. XXL -> XLX -> LXX).  Here is where the optimization happens: we store 1 past location of the L so in future don\\'t have to double-scan past the X\\'s.\\n3. Case ```end[i] == X```: Similar to prior case. If ```start[i] == L``` here then return false because L??? cannot transform into X??? because we can\\'t pull an X through L. However if ```start[i] == R``` then R...RX (all intermediate are R\\'s) can potentially transform into X??? because we can borrow the first X after the Rs (ex. RRX -> RXR -> XRR). Again same idea where we store 1 past location of discovered X to avoid double-scanning.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        char[] startChars = start.toCharArray();\\n        int n = startChars.length;\\n        int candidateNextL = -1;\\n        int candidateNextX = -1;\\n        for(int i=0; i<n; i++) {\\n            char target = end.charAt(i);\\n            if (startChars[i] == target) {\\n                // great, we match at this position\\n                continue;\\n            }\\n            if (target == \\'R\\') {\\n                /*\\n                so we want an R. But we have X or L.\\n                We can\\'t bring an R though either.\\n                R can only go Right\\n                */\\n                return false;\\n            } else if (target == \\'L\\') {\\n                if (startChars[i] == \\'R\\') {\\n                    // no L can make it\\'s way left thru the R\\n                    return false;\\n                }\\n                /* ok so at an X. Keep scanning\\n                want something like X..XL\\n                that way can pull an L from right\\n                */\\n                int curr = Math.max(i+1, candidateNextL);\\n                while(curr < n && startChars[curr] == \\'X\\') {\\n                    curr++;\\n                }\\n                if (curr == n) {\\n                    // reached end only found Xs no L to borrow\\n                    return false;\\n                }\\n                if (startChars[curr] == \\'R\\') {\\n                    return false;\\n                }\\n                // great, finally found L after 1 or more X\\'s so use it\\n                swap(curr, i, startChars);\\n                candidateNextL = curr + 1; // found all X\\'s till curr and L is used..\\n            } else {\\n                // target = X\\n                if (startChars[i] == \\'L\\') {\\n                    // L blocks.\\n                    return false;\\n                }\\n                // this time go thru all the filler R\\'s\\n                int curr = Math.max(i+1, candidateNextX);\\n                while(curr < n && startChars[curr] == \\'R\\') {\\n                    curr++;\\n                }\\n                if (curr == n) {\\n                    // reached end only found Rs no X to borrow\\n                    return false;\\n                }\\n                if (startChars[curr] == \\'L\\') {\\n                    return false;\\n                }\\n                // great, finally found X after 1 or more R\\'s so use it\\n                swap(curr, i, startChars);\\n                candidateNextX = curr + 1;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private void swap(int pos1, int pos2, char[] arr) {\\n        char tmp = arr[pos1];\\n        arr[pos1] = arr[pos2];\\n        arr[pos2] = tmp;\\n    }\\n}\\n\\n```\n```i```\n```start[i] = end[i]```\n```false```\n```start[i] != end[i]```\n```end[i] == R```\n```end[i] == L```\n```start[i] == R```\n```start[i] == X```\n```end[i] == X```\n```start[i] == L```\n```start[i] == R```",
                "codeTag": "Java"
            },
            {
                "id": 1835137,
                "title": "javascript-two-pointers-w-explanation",
                "content": "**Solution: Two Pointers**\\n\\nBeing able to swap \"XL\" with \"LX\" means we can move L as far LEFT as we want until it reaches an R.\\nBeing able to swap RX\" with \"XR\" means we can move R as far RIGHT as we want until it reaches an L.\\nWhen L and R meet, they can\\'t be swapped.\\n\\nConditions that need to be met:\\n1. Start without X\\'s must be equal to end without X\\'s.\\n2. Positions of L in start must be <= to the positions of L in end.\\n3. Positions of R in start must be >= to the positions of R in end.\\n\\nTo check for conditions 2 & 3, we can keep a running counter of L\\'s and R\\'s in start and end.\\nIf the count of L\\'s in start is greater than the count of L\\'s in end, it is invalid.\\nIf the count of R\\'s in start is less than the count of R\\'s in end, it is invalid.\\n\\nTime Complexity: O(n) 79ms\\nSpace Complexity: O(1) 44.3MB\\n```\\nvar canTransform = function(start, end) {  \\n  let n = start.length;\\n  let start_str = \"\", end_str = \"\";\\n  for (let i = 0; i < n; i++) {\\n    if (start[i] !== \\'X\\') start_str += start[i];\\n    if (end[i] !== \\'X\\') end_str += end[i];\\n  }\\n  if (start_str !== end_str) return false; // the start and end without X\\'s should be equal.\\n\\n  let start_l_count = 0, end_l_count = 0;\\n  let start_r_count = 0, end_r_count = 0;\\n  for (let i = 0; i < n; i++) {\\n    if (start[i] === \\'L\\') start_l_count++;\\n    else if (start[i] === \\'R\\') start_r_count++;\\n    \\n    if (end[i] === \\'L\\') end_l_count++;\\n    else if (end[i] === \\'R\\') end_r_count++;\\n    \\n    if (start_l_count > end_l_count) return false; // this means there is an L in start ahead of an L in end.\\n    if (start_r_count < end_r_count) return false; // this means there is an R in start behind an R in end.\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canTransform = function(start, end) {  \\n  let n = start.length;\\n  let start_str = \"\", end_str = \"\";\\n  for (let i = 0; i < n; i++) {\\n    if (start[i] !== \\'X\\') start_str += start[i];\\n    if (end[i] !== \\'X\\') end_str += end[i];\\n  }\\n  if (start_str !== end_str) return false; // the start and end without X\\'s should be equal.\\n\\n  let start_l_count = 0, end_l_count = 0;\\n  let start_r_count = 0, end_r_count = 0;\\n  for (let i = 0; i < n; i++) {\\n    if (start[i] === \\'L\\') start_l_count++;\\n    else if (start[i] === \\'R\\') start_r_count++;\\n    \\n    if (end[i] === \\'L\\') end_l_count++;\\n    else if (end[i] === \\'R\\') end_r_count++;\\n    \\n    if (start_l_count > end_l_count) return false; // this means there is an L in start ahead of an L in end.\\n    if (start_r_count < end_r_count) return false; // this means there is an R in start behind an R in end.\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1799713,
                "title": "c-one-pass-simple-and-clean-code",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {        \\n        int si=0, ei=0;\\n\\n        while(si<start.size() || ei<end.size()){            \\n            while(start[si]==\\'X\\' && si<start.size()) ++si;\\n            while(end[ei]==\\'X\\' && ei<end.size()) ++ei;\\n            \\n            if(start[si]!=end[ei])\\n                return false;            \\n            if(start[si] == \\'R\\' && si>ei) \\n                return false;\\n            if(start[si] == \\'L\\' && si<ei) \\n                return false;\\n            \\n            ++si;\\n            ++ei;        \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {        \\n        int si=0, ei=0;\\n\\n        while(si<start.size() || ei<end.size()){            \\n            while(start[si]==\\'X\\' && si<start.size()) ++si;\\n            while(end[ei]==\\'X\\' && ei<end.size()) ++ei;\\n            \\n            if(start[si]!=end[ei])\\n                return false;            \\n            if(start[si] == \\'R\\' && si>ei) \\n                return false;\\n            if(start[si] == \\'L\\' && si<ei) \\n                return false;\\n            \\n            ++si;\\n            ++ei;        \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790592,
                "title": "java-with-simple-counting-time-o-n-space-o-1",
                "content": "#### Idea\\n\\'L\\' can only move to the left. This means that \\'L\\' should appear in `end` string before in `start`.\\nXL -> LX : OK\\nLX -> XL :  Not OK\\n\\n\\'R\\' can only move to the right. This means that \\'R\\' should appear in `start` string before in `end`.\\nRX -> XR : OK\\nXR -> RX: Not OK\\n\\n\\'L\\' and \\'R\\' cannot cross each other. This means that all \\'L\\'s found in `end` must be cleared before finding \\'R\\' in `start` and vice versa.\\nXX..RL -> XX..L..R : Not possible\\n\\nIn the end, all \\'L\\'s and \\'R\\'s must be cleared.\\n\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (start.length() != end.length()) return false;\\n\\n        int len = start.length(), lCnt = 0, rCnt = 0;\\n\\n        for (int i = 0; i < len; i++) {\\n            char sc = start.charAt(i);\\n            char ec = end.charAt(i);\\n            if (ec == \\'L\\') {\\n                if (rCnt > 0) return false; // L, R need to cross each other so fail.\\n                else lCnt++;\\n            } \\n            if (sc == \\'L\\') {\\n                if (lCnt == 0) return false; // L appears in start before appearing in end\\n                else lCnt--;\\n            }\\n            if (sc == \\'R\\') {\\n                if (lCnt > 0) return false; // L, R need to cross each other so fail.\\n                else rCnt++;\\n            }\\n            if (ec == \\'R\\') {\\n                if (rCnt == 0) return false; // R appears in end before appearing in start\\n                else rCnt--;\\n            }\\n        }\\n        return lCnt == 0 && rCnt == 0; // all L and R are cleared.\\n    }\\n}\\n```\\nTIme Complexity: O(n) - a simple loop through the given strings.\\nSpace Complexity: O(1) - only L and R counts are used.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        if (start.length() != end.length()) return false;\\n\\n        int len = start.length(), lCnt = 0, rCnt = 0;\\n\\n        for (int i = 0; i < len; i++) {\\n            char sc = start.charAt(i);\\n            char ec = end.charAt(i);\\n            if (ec == \\'L\\') {\\n                if (rCnt > 0) return false; // L, R need to cross each other so fail.\\n                else lCnt++;\\n            } \\n            if (sc == \\'L\\') {\\n                if (lCnt == 0) return false; // L appears in start before appearing in end\\n                else lCnt--;\\n            }\\n            if (sc == \\'R\\') {\\n                if (lCnt > 0) return false; // L, R need to cross each other so fail.\\n                else rCnt++;\\n            }\\n            if (ec == \\'R\\') {\\n                if (rCnt == 0) return false; // R appears in end before appearing in start\\n                else rCnt--;\\n            }\\n        }\\n        return lCnt == 0 && rCnt == 0; // all L and R are cleared.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756487,
                "title": "short-and-simple-python-solution-o-n-time-o-n-space",
                "content": "\\tdef canTransform(self, start: str, end: str) -> bool:\\n        \\n        # If after filtering out all \\'X\\'s the strings are not equal, return False\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'):\\n            return False\\n        \\n        # get all indices of \"L\"s in start and end\\n        lIdxStart = [i for i, c in enumerate(start) if c == \\'L\\']\\n        lIdxEnd = [i for i, c in enumerate(end) if c == \\'L\\']\\n        \\n        # get all indices of \"R\"s in start and end\\n        rIdxStart = [i for i, c in enumerate(start) if c == \\'R\\']\\n        rIdxEnd = [i for i, c in enumerate(end) if c == \\'R\\']\\n        \\n        # if any \\'L\\' moved to the right or any \\'R\\' moved to the left -> return False\\n        for s, e in zip(lIdxStart, lIdxEnd):\\n            if s < e: return False\\n        \\n        for s, e in zip(rIdxStart, rIdxEnd):\\n            if s > e: return False\\n        \\n        \\n        return True",
                "solutionTags": [],
                "code": "\\tdef canTransform(self, start: str, end: str) -> bool:\\n        \\n        # If after filtering out all \\'X\\'s the strings are not equal, return False\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'):\\n            return False\\n        \\n        # get all indices of \"L\"s in start and end\\n        lIdxStart = [i for i, c in enumerate(start) if c == \\'L\\']\\n        lIdxEnd = [i for i, c in enumerate(end) if c == \\'L\\']\\n        \\n        # get all indices of \"R\"s in start and end\\n        rIdxStart = [i for i, c in enumerate(start) if c == \\'R\\']\\n        rIdxEnd = [i for i, c in enumerate(end) if c == \\'R\\']\\n        \\n        # if any \\'L\\' moved to the right or any \\'R\\' moved to the left -> return False\\n        for s, e in zip(lIdxStart, lIdxEnd):\\n            if s < e: return False\\n        \\n        for s, e in zip(rIdxStart, rIdxEnd):\\n            if s > e: return False\\n        \\n        \\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 1613868,
                "title": "ruby-beats-100-time-space",
                "content": "For a sequence of transformations to be possible, the following must be true:\\n\\n1.   Without Xs starting and ending strings must have L and R with the same order and counts.\\n2.   For each L its final index must be at the left (or same) of its original index.\\n3.   For each R its final index must be at the right (or same) of its original index.\\n  \\n```\\n# @param {String} start\\n# @param {String} ending\\n# @return {Boolean}\\ndef can_transform(starting, ending)\\n    return false if starting.delete(\"X\") != ending.delete(\"X\") \\n\\t\\n    hsl = starting.chars.map.with_index.reduce([]) { |l, (c, i)| c == \"L\" ? l + [i] : l }\\n    hsr = starting.chars.map.with_index.reduce([]) { |l, (c, i)| c == \"R\" ? l + [i] : l }\\n    hel = ending.chars.map.with_index.reduce([]) { |l, (c, i)| c == \"L\" ? l + [i] : l }\\n    her = ending.chars.map.with_index.reduce([]) { |l, (c, i)| c == \"R\" ? l + [i] : l }\\n\\t\\n    hsl.zip(hel).all?{ |i0, i1| i1 <= i0 } && hsr.zip(her).all?{ |i0, i1| i1 >= i0 } \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} start\\n# @param {String} ending\\n# @return {Boolean}\\ndef can_transform(starting, ending)\\n    return false if starting.delete(\"X\") != ending.delete(\"X\") \\n\\t\\n    hsl = starting.chars.map.with_index.reduce([]) { |l, (c, i)| c == \"L\" ? l + [i] : l }\\n    hsr = starting.chars.map.with_index.reduce([]) { |l, (c, i)| c == \"R\" ? l + [i] : l }\\n    hel = ending.chars.map.with_index.reduce([]) { |l, (c, i)| c == \"L\" ? l + [i] : l }\\n    her = ending.chars.map.with_index.reduce([]) { |l, (c, i)| c == \"R\" ? l + [i] : l }\\n\\t\\n    hsl.zip(hel).all?{ |i0, i1| i1 <= i0 } && hsr.zip(her).all?{ |i0, i1| i1 >= i0 } \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1560226,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        A = [(letter, idx) for idx,letter in enumerate(start) if letter == \\'L\\' or letter == \\'R\\']\\n        B = [(letter, idx) for idx,letter in enumerate(end) if letter == \\'L\\' or letter == \\'R\\']\\n        \\n        if len(A) != len(B):\\n            return False\\n        \\n        for (s,i),(e,j) in zip(A,B):\\n            if s != e:\\n                return False\\n            \\n            if s == \\'R\\':\\n                if i > j:\\n                    return False\\n                \\n            if s == \\'L\\':\\n                if i < j:\\n                    return False\\n                \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        A = [(letter, idx) for idx,letter in enumerate(start) if letter == \\'L\\' or letter == \\'R\\']\\n        B = [(letter, idx) for idx,letter in enumerate(end) if letter == \\'L\\' or letter == \\'R\\']\\n        \\n        if len(A) != len(B):\\n            return False\\n        \\n        for (s,i),(e,j) in zip(A,B):\\n            if s != e:\\n                return False\\n            \\n            if s == \\'R\\':\\n                if i > j:\\n                    return False\\n                \\n            if s == \\'L\\':\\n                if i < j:\\n                    return False\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497725,
                "title": "left-and-right-pass-o-n-very-simple-to-understand",
                "content": "Idea is to check whether \\'R\\' in \\'start\\' in different position can be pushed further right to correct position in \\'end\\', if not return false. There should be no \\'L\\' in between. We return false if there is \\'L\\' in between.\\nDoing the same thing for \\'L\\'.\\n\\n```\\npublic static boolean canTransform (String start, String end) {\\n\\t\\tStringBuffer _start = new StringBuffer(start);\\n\\n\\t\\tint endPointer = start.length() - 1;\\n\\t\\tint startPointer = start.length() - 1;\\n\\t\\twhile (startPointer >= 0) {\\n\\t\\t\\tif (end.charAt(endPointer) != \\'R\\') {\\n\\t\\t\\t\\tendPointer--;\\n\\t\\t\\t\\tstartPointer = endPointer;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (_start.charAt(startPointer) == \\'L\\') {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (_start.charAt(startPointer) == \\'R\\') {\\n\\t\\t\\t\\t_start.setCharAt(startPointer, _start.charAt(endPointer));\\n\\t\\t\\t\\t_start.setCharAt(endPointer, \\'R\\');\\n\\t\\t\\t\\tendPointer--;\\n\\t\\t\\t}\\n\\t\\t\\tstartPointer--;\\n\\t\\t}\\n\\n\\t\\tendPointer = 0;\\n\\t\\tstartPointer = 0;\\n\\t\\twhile (startPointer < start.length()) {\\n\\t\\t\\tif (end.charAt(endPointer) != \\'L\\') {\\n\\t\\t\\t\\tendPointer++;\\n\\t\\t\\t\\tstartPointer = endPointer;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (_start.charAt(startPointer) == \\'R\\') {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (_start.charAt(startPointer) == \\'L\\') {\\n\\t\\t\\t\\t_start.setCharAt(startPointer, _start.charAt(endPointer));\\n\\t\\t\\t\\t_start.setCharAt(endPointer, \\'L\\');\\n\\t\\t\\t\\tendPointer++;\\n\\t\\t\\t}\\n\\t\\t\\tstartPointer++;\\n\\t\\t}\\n\\t\\treturn _start.toString().equals(end);\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic static boolean canTransform (String start, String end) {\\n\\t\\tStringBuffer _start = new StringBuffer(start);\\n\\n\\t\\tint endPointer = start.length() - 1;\\n\\t\\tint startPointer = start.length() - 1;\\n\\t\\twhile (startPointer >= 0) {\\n\\t\\t\\tif (end.charAt(endPointer) != \\'R\\') {\\n\\t\\t\\t\\tendPointer--;\\n\\t\\t\\t\\tstartPointer = endPointer;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (_start.charAt(startPointer) == \\'L\\') {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (_start.charAt(startPointer) == \\'R\\') {\\n\\t\\t\\t\\t_start.setCharAt(startPointer, _start.charAt(endPointer));\\n\\t\\t\\t\\t_start.setCharAt(endPointer, \\'R\\');\\n\\t\\t\\t\\tendPointer--;\\n\\t\\t\\t}\\n\\t\\t\\tstartPointer--;\\n\\t\\t}\\n\\n\\t\\tendPointer = 0;\\n\\t\\tstartPointer = 0;\\n\\t\\twhile (startPointer < start.length()) {\\n\\t\\t\\tif (end.charAt(endPointer) != \\'L\\') {\\n\\t\\t\\t\\tendPointer++;\\n\\t\\t\\t\\tstartPointer = endPointer;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (_start.charAt(startPointer) == \\'R\\') {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (_start.charAt(startPointer) == \\'L\\') {\\n\\t\\t\\t\\t_start.setCharAt(startPointer, _start.charAt(endPointer));\\n\\t\\t\\t\\t_start.setCharAt(endPointer, \\'L\\');\\n\\t\\t\\t\\tendPointer++;\\n\\t\\t\\t}\\n\\t\\t\\tstartPointer++;\\n\\t\\t}\\n\\t\\treturn _start.toString().equals(end);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1325742,
                "title": "backtracking-solution",
                "content": "I could not make this test case pass and seems weird. \\nInput:\\n\"XXXXXLXXXX\"\\n\"LXXXXXXXXX\"\\n\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\n```\\n public boolean canTransform(String start, String end) {\\n        return ct(start, 0, end);\\n    }\\n    \\n   boolean ct(String current, int index, String end){\\n        if(current.equals(end)){\\n            return true;\\n        }\\n        if(current.length() != end.length()){\\n            return false;\\n        }\\n        if(index == current.length()-1){\\n            if(current.equals(end)){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        for(int i=index; i< current.length(); i++){\\n            String st = current.substring(i, i+2);\\n            String replace = null;\\n            if(st.equals(\"XL\")){\\n                replace = \"LX\";\\n            }else if(st.equals(\"RX\")){\\n                replace = \"XR\";\\n            }\\n            if(replace == null){\\n                return false;\\n            }\\n            current = current.substring(0,i)+ replace+ current.substring(i+2, current.length());\\n            if(ct(current, index+2, end)){\\n                return true;\\n            }\\n            current = current.substring(0,i)+ st+ current.substring(i+2, current.length());\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean canTransform(String start, String end) {\\n        return ct(start, 0, end);\\n    }\\n    \\n   boolean ct(String current, int index, String end){\\n        if(current.equals(end)){\\n            return true;\\n        }\\n        if(current.length() != end.length()){\\n            return false;\\n        }\\n        if(index == current.length()-1){\\n            if(current.equals(end)){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        for(int i=index; i< current.length(); i++){\\n            String st = current.substring(i, i+2);\\n            String replace = null;\\n            if(st.equals(\"XL\")){\\n                replace = \"LX\";\\n            }else if(st.equals(\"RX\")){\\n                replace = \"XR\";\\n            }\\n            if(replace == null){\\n                return false;\\n            }\\n            current = current.substring(0,i)+ replace+ current.substring(i+2, current.length());\\n            if(ct(current, index+2, end)){\\n                return true;\\n            }\\n            current = current.substring(0,i)+ st+ current.substring(i+2, current.length());\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1231452,
                "title": "python-o-n-time-o-1-space",
                "content": "Intuition: Ls and Rs are like objects in a field of Xs. In a valid transformation, Ls can stay still or move left freely but not past another L or R. Rs can stay still or move right freely but not past another L or R. From this we know a valid transformation has the same number of Ls and Rs and also that the relative order of Ls and Rs remains the same. The number of Xs in each list doesn\\'t matter, only the count and relative order of Ls and Rs. Checking the constraint that Ls must move left and Rs must move right is easy if we store the index of each L/R and compare one L/R from each list at a time, left to right.\\n\\nTypical solution (including my first one) processes each list such that Xs are removed and original index of each L/R is stored. Then you can check the number of Ls/Rs is the same by comparing the lengths of these processed lists. You can remove the need for these intermediate processed lists by using two iterators and walking through the lists one L/R at a time, and if one iterator can get the next L/R while the other reaches the end of the string, the number of L/Rs were inequal so you can reject the transformation. Alternatively in python you can just use generators instead of lists when filtering which is O(1) memory.\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        lr = {\\'L\\', \\'R\\'}\\n        \\n        l = len(start)\\n        i = 0\\n        j = 0\\n        \\n        # walk through both strings, ignoring Xs\\n        # take one character from each list and compare them\\n        # (since we are ignoring X they will both be L or R)\\n        while True:\\n            # take the next non-X character from start\\n            while i < l and start[i] not in lr:\\n                i += 1\\n\\n            # take the next non-X character from end\\n            while j < l and end[j] not in lr:\\n                j += 1\\n\\n            # if one iterator has reached the end but one hasn\\'t, this implies one list had\\n            # more L+R characters than the other. This can\\'t be a valid transformation.\\n            if (i == l) != (j == l):\\n                return False\\n\\n            # if both iterators reached the end, all characters were paired and checked\\n            if i == l:\\n                break\\n\\n            # if one was an L and one was an R, this can\\'t be valid\\n            if start[i] != end[j]:\\n                return False\\n\\n            # if both were Ls, the L in end must have moved left or stayed in place\\n            if start[i] == \\'L\\' and i < j:\\n                return False\\n\\n            # if both were Rs, the R in end must have moved right or stayed in place\\n            if start[i] == \\'R\\' and i > j:\\n                return False\\n            \\n            # advance both iterators so the next loop can get the next pair of characters\\n            i += 1\\n            j += 1\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        lr = {\\'L\\', \\'R\\'}\\n        \\n        l = len(start)\\n        i = 0\\n        j = 0\\n        \\n        # walk through both strings, ignoring Xs\\n        # take one character from each list and compare them\\n        # (since we are ignoring X they will both be L or R)\\n        while True:\\n            # take the next non-X character from start\\n            while i < l and start[i] not in lr:\\n                i += 1\\n\\n            # take the next non-X character from end\\n            while j < l and end[j] not in lr:\\n                j += 1\\n\\n            # if one iterator has reached the end but one hasn\\'t, this implies one list had\\n            # more L+R characters than the other. This can\\'t be a valid transformation.\\n            if (i == l) != (j == l):\\n                return False\\n\\n            # if both iterators reached the end, all characters were paired and checked\\n            if i == l:\\n                break\\n\\n            # if one was an L and one was an R, this can\\'t be valid\\n            if start[i] != end[j]:\\n                return False\\n\\n            # if both were Ls, the L in end must have moved left or stayed in place\\n            if start[i] == \\'L\\' and i < j:\\n                return False\\n\\n            # if both were Rs, the R in end must have moved right or stayed in place\\n            if start[i] == \\'R\\' and i > j:\\n                return False\\n            \\n            # advance both iterators so the next loop can get the next pair of characters\\n            i += 1\\n            j += 1\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029693,
                "title": "c-o-n-time-o-1-space-explained-with-examples",
                "content": "Rules: \\nXL -> LX\\nRX -> XR\\nRL is a deadline.(incase it dosen\\'t match with \\'end\\')\\nSo check for dangling \\'R\\' to the right side of \\'RL\\' (i.e an R not followed by an \\'X\\' and not matching with end[i])\\n***Something like : \"XRLXR\" and \"RXXLL\"***\\nFor finding unpaired \\'L\\' iterate from the end, check for a dangling \\'L\\' (i.e an \\'L\\' to the left of \\'RX\\' where the \\'L\\' is not preceded by an \\'X\\' and not matching with end[i])\\n***Something like : \"LXRLX\" and \"RRXXL\"***\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        if(start.length()!=end.length()) \\n            return 0;\\n        int count =0;\\n        for(int i=0;i<start.length();i++) {\\n            if(start[i]==\\'R\\')\\n            {\\n                count++;\\n            }\\n            if(end[i]==\\'R\\') {\\n                if(--count<0) \\n                    return 0;\\n            }\\n            else if(end[i]==\\'L\\' && count!=0)\\n                return 0;\\n        }\\n        if(count!=0) \\n            return 0;\\n        for(int i=start.size();i>=0;i--) {\\n            if(start[i]==\\'L\\') \\n                count++;\\n            if(end[i]==\\'L\\') {\\n                if(--count<0)\\n                    return 0;\\n            }\\n            else if(end[i]==\\'R\\' && count!=0)\\n                return 0;\\n        }\\n        return count==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        if(start.length()!=end.length()) \\n            return 0;\\n        int count =0;\\n        for(int i=0;i<start.length();i++) {\\n            if(start[i]==\\'R\\')\\n            {\\n                count++;\\n            }\\n            if(end[i]==\\'R\\') {\\n                if(--count<0) \\n                    return 0;\\n            }\\n            else if(end[i]==\\'L\\' && count!=0)\\n                return 0;\\n        }\\n        if(count!=0) \\n            return 0;\\n        for(int i=start.size();i>=0;i--) {\\n            if(start[i]==\\'L\\') \\n                count++;\\n            if(end[i]==\\'L\\') {\\n                if(--count<0)\\n                    return 0;\\n            }\\n            else if(end[i]==\\'R\\' && count!=0)\\n                return 0;\\n        }\\n        return count==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997509,
                "title": "ruby-solution",
                "content": "```\\n# @param {String} start\\n# @param {String} ender\\n# @return {Boolean}\\ndef can_transform(start, ender)\\n    return false if start.length != ender.length\\n    return false if start.delete(\\'X\\') != ender.delete(\\'X\\')\\n    # check to see if the R\\'s in start are to the left or equal to those in ender\\n    # and then ditto for the L\\'s\\n\\n    r1=0\\n    r2=0\\n    while r1<start.length\\n        while start[r1]!=\\'R\\' and r1<start.length\\n            r1+=1\\n        end\\n        break if r1==start.length\\n        while ender[r2]!=\\'R\\' and r2<start.length\\n            r2+=1\\n        end\\n        return false if r2<r1\\n        r1+=1\\n        r2+=1\\n    end\\n    \\n    l1=0\\n    l2=0\\n    while l1<start.length\\n        while start[l1]!=\\'L\\' and l1<start.length\\n            l1+=1\\n        end\\n        break if l1==start.length\\n        while ender[l2]!=\\'L\\' and l2<start.length\\n            l2+=1\\n        end\\n        return false if l2>l1\\n        l1+=1\\n        l2+=1\\n    end\\n    \\n    return true\\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {String} start\\n# @param {String} ender\\n# @return {Boolean}\\ndef can_transform(start, ender)\\n    return false if start.length != ender.length\\n    return false if start.delete(\\'X\\') != ender.delete(\\'X\\')\\n    # check to see if the R\\'s in start are to the left or equal to those in ender\\n    # and then ditto for the L\\'s\\n\\n    r1=0\\n    r2=0\\n    while r1<start.length\\n        while start[r1]!=\\'R\\' and r1<start.length\\n            r1+=1\\n        end\\n        break if r1==start.length\\n        while ender[r2]!=\\'R\\' and r2<start.length\\n            r2+=1\\n        end\\n        return false if r2<r1\\n        r1+=1\\n        r2+=1\\n    end\\n    \\n    l1=0\\n    l2=0\\n    while l1<start.length\\n        while start[l1]!=\\'L\\' and l1<start.length\\n            l1+=1\\n        end\\n        break if l1==start.length\\n        while ender[l2]!=\\'L\\' and l2<start.length\\n            l2+=1\\n        end\\n        return false if l2>l1\\n        l1+=1\\n        l2+=1\\n    end\\n    \\n    return true\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 976196,
                "title": "c-two-pass-o-n-time-o-1-space-4ms-using-balance-between-two-string",
                "content": "We know that `R` can never go back to the left and `L` can never go back to the right.\\nAnd `RL` is a deadend where the `R` cannot be used beyond the `L` and `L` cannot be used beyond the `R` as they cannot cross over each other.\\nBy using this charateristic, we can figure out whether `start` can be tranformed into `end` or not by checking the balance of\\n`L` and `R` respectively between two input string.\\n\\n```\\nbool canTransform(string start, string end) {\\n        if(start.size() != end.size()){ //Simple Edge Case Checking\\n            return false;\\n        }\\n        int count = 0; //First iteration is for `R` balance between two\\n        for(int i = 0; i < start.size(); ++i){\\n            if(start[i] == \\'R\\'){\\n                ++count;\\n            }\\n            if(end[i] == \\'R\\'){\\n                if(--count < 0){ //If we dont have `R` that are available then there is no way to have `R` in this position after transformation\\n                    return false;\\n                }\\n            }\\n            else if(end[i] == \\'L\\' && count != 0){ //When we meet the `deadend` place, our `R` balance should be 0. OW, it means we have dangling `R` on the left side of this `deadend`\\n                return false;\\n            }\\n        }\\n        if(count != 0){ //check whether we had extra `R` \\n            return false;\\n        }\\n\\t\\t//Now do it opposite way to check the balance of `L`\\n        for(int i = start.size() - 1; i >= 0; --i){\\n            if(start[i] == \\'L\\'){\\n                ++count;\\n            }\\n            if(end[i] == \\'L\\'){\\n                if(--count < 0){\\n                    return false;\\n                }\\n            }\\n            else if(end[i] == \\'R\\' && count != 0){\\n                return false;\\n            }\\n        }\\n        return count == 0;\\n    } // O(N) time and O(1) space \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nbool canTransform(string start, string end) {\\n        if(start.size() != end.size()){ //Simple Edge Case Checking\\n            return false;\\n        }\\n        int count = 0; //First iteration is for `R` balance between two\\n        for(int i = 0; i < start.size(); ++i){\\n            if(start[i] == \\'R\\'){\\n                ++count;\\n            }\\n            if(end[i] == \\'R\\'){\\n                if(--count < 0){ //If we dont have `R` that are available then there is no way to have `R` in this position after transformation\\n                    return false;\\n                }\\n            }\\n            else if(end[i] == \\'L\\' && count != 0){ //When we meet the `deadend` place, our `R` balance should be 0. OW, it means we have dangling `R` on the left side of this `deadend`\\n                return false;\\n            }\\n        }\\n        if(count != 0){ //check whether we had extra `R` \\n            return false;\\n        }\\n\\t\\t//Now do it opposite way to check the balance of `L`\\n        for(int i = start.size() - 1; i >= 0; --i){\\n            if(start[i] == \\'L\\'){\\n                ++count;\\n            }\\n            if(end[i] == \\'L\\'){\\n                if(--count < 0){\\n                    return false;\\n                }\\n            }\\n            else if(end[i] == \\'R\\' && count != 0){\\n                return false;\\n            }\\n        }\\n        return count == 0;\\n    } // O(N) time and O(1) space \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 972445,
                "title": "python3-easy-to-understand-solution",
                "content": "The end string can be reached from the start, \\nif and only if \\n\\n1. the sequence of LR are the same, \\nthat is, \\nwhen \"X\" is replaced with \"\",\\nthe two strings are the same. \\n\\nand \\n\\n2. The i-th L is at the same position, \\nor on the left of its original position. \\nThe i-th R is at the same position, \\nor on the right of its original position. \\n\\nWe replace \"X\" with \"\" to compare whether \\nthe two string have the same sequence of LR. \\n\\nWe maintain two lists, \\nwith values the index of the i-th L (R). \\n\\nThen we traverse the end string, \\nwhen we encounter an L or R, \\nwe compare the index with the top of the two lists, \\nand we pop the top of the lists. \\n\\n\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'):\\n            return False\\n        else:\\n            \"\"\"\\n            We construct the two lists of indices.\\n            \"\"\"\\n            index_L = []\\n            index_R = []\\n            for i, ch in enumerate(start):\\n                if ch == \\'L\\':\\n                    index_L.append(i)\\n                elif ch == \\'R\\':\\n                    index_R.append(i)\\n                    \\n            \"\"\"\\n            We check the indicies of the elements.\\n            \"\"\" \\n            for i, ch in enumerate(end):\\n                if ch == \\'L\\':\\n                    if index_L[0] >= i:\\n                        index_L.pop(0)\\n                    else:\\n                        return False\\n                elif ch == \\'R\\':\\n                    if index_R[0] <= i:\\n                        index_R.pop(0)\\n                    else:\\n                        return False\\n            else:\\n                return True\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'):\\n            return False\\n        else:\\n            \"\"\"\\n            We construct the two lists of indices.\\n            \"\"\"\\n            index_L = []\\n            index_R = []\\n            for i, ch in enumerate(start):\\n                if ch == \\'L\\':\\n                    index_L.append(i)\\n                elif ch == \\'R\\':\\n                    index_R.append(i)\\n                    \\n            \"\"\"\\n            We check the indicies of the elements.\\n            \"\"\" \\n            for i, ch in enumerate(end):\\n                if ch == \\'L\\':\\n                    if index_L[0] >= i:\\n                        index_L.pop(0)\\n                    else:\\n                        return False\\n                elif ch == \\'R\\':\\n                    if index_R[0] <= i:\\n                        index_R.pop(0)\\n                    else:\\n                        return False\\n            else:\\n                return True\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 967545,
                "title": "java-two-pointers",
                "content": "Since we can only move `L` to left and `R` to right, \\n* for index of cosponding `R`, `end` should be greater or equal than `begin`.\\n* for index of cosponding `L`, `end` should be less or equal `begin`.\\n\\nScan  `start` and `end` for index of next non-X character `i` and `j`.\\n* If the characters are different, return false.\\n* If the characters is `R` but `j<i` return false.\\n* If the characters is `L` but `j>i` return false.\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        var len=start.length();\\n        int i=scan(start, 0);\\n        int j=scan(end, 0);\\n        while (i<len&&j<len) {\\n            char s=start.charAt(i);\\n            char e=end.charAt(j);\\n            if (s!=e) {\\n                return false;\\n            }\\n            if (s==\\'R\\'&&j<i) {\\n                return false;\\n            }\\n            if (s==\\'L\\'&&j>i) {\\n                return false;\\n            }\\n            i = scan(start,i+1);\\n            j = scan(end,j+1);\\n        }\\n        return i==j;\\n    }\\n    \\n    int scan(String str,int idx) {\\n        while (idx<str.length()) {\\n            if (str.charAt(idx)!=\\'X\\') {\\n                return idx;\\n            }\\n            idx++;\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        var len=start.length();\\n        int i=scan(start, 0);\\n        int j=scan(end, 0);\\n        while (i<len&&j<len) {\\n            char s=start.charAt(i);\\n            char e=end.charAt(j);\\n            if (s!=e) {\\n                return false;\\n            }\\n            if (s==\\'R\\'&&j<i) {\\n                return false;\\n            }\\n            if (s==\\'L\\'&&j>i) {\\n                return false;\\n            }\\n            i = scan(start,i+1);\\n            j = scan(end,j+1);\\n        }\\n        return i==j;\\n    }\\n    \\n    int scan(String str,int idx) {\\n        while (idx<str.length()) {\\n            if (str.charAt(idx)!=\\'X\\') {\\n                return idx;\\n            }\\n            idx++;\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887190,
                "title": "c-4ms-solution-with-detailed-explanation",
                "content": "Intuition:\\n\\nScan the two strings, at each index compare the character at the index from either string, depending on the comparison we perform diferent actions.\\n\\nSome observations:\\n```\\nFirstly, replacing XL with LX basically means moving the character L to the left by one position, \\n\\nSimilary replacing RX with XR means moving the character X to the left by one position. \\n\\nNotice that there is no way of moving a character R to the LEFT (can be moved to the right, but that does not help us with what we are trying to achieve).\\n```\\n\\nLet\\'s say for the current index ```i```:\\n\\nThe main idea is that whenever we found a mismatch, we will need to check if there is a way of finding the target character on the ```start``` string from the remaining substr (i.e ```start[i+1:n-1]```), and moving it along to the current index ```i```.\\n\\nBased on the observations above, if the target character is ```L```, then the substr mentioned above needs to be ```XXXX...XL```, similarly if the target character is ```X```, then it needs to be ```RRRR....RX```. If the target character is ```R```, there is nothing we can do.\\n\\n`Algorithm:`\\n1. compare the characters from both strings at every each position.\\n2. The two charactesr are ame: All good, continue on for both strings.\\n3. The two charactesr are different:\\n* \\ttarget character is ```R```. cannot do anything, return false.\\n* \\ttarget character is ```L```. look for substr ```XXXX...XL``` from string ```start```, move along ```L``` to the current position, then move on to the next position for both strings.\\n* \\ttarget character is ```X```. look for substr ```RRRR...RX``` from string ```start```, move along ```X``` to the current position, then move on to the next position for both strings.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n=start.size();\\n        int px=0,pr=0;\\n        for(int i=0,j=0; i<n && j<n; j++)\\n        {\\n            if(start[i]==end[j])\\n            {\\n                i++;\\n            }\\n            else if(end[j]==\\'R\\') \\n            {\\n                return false;\\n            }\\n            else\\n            {\\n                char c2=end[j];\\n                char c1=(c2==\\'L\\')?\\'X\\':\\'R\\';\\n                \\n                int k=max(i,(c2==\\'L\\')?px:pr);\\n                while(k<n && start[k]==c1) k++;\\n                if(k==i || k==n || start[k]!=c2) return false;\\n                \\n                start[k]=c1;                \\n                start[i]=c2;\\n                if(c2==\\'L\\') px=k;\\n                else pr=k;\\n                i++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nFirstly, replacing XL with LX basically means moving the character L to the left by one position, \\n\\nSimilary replacing RX with XR means moving the character X to the left by one position. \\n\\nNotice that there is no way of moving a character R to the LEFT (can be moved to the right, but that does not help us with what we are trying to achieve).\\n```\n```i```\n```start```\n```start[i+1:n-1]```\n```i```\n```L```\n```XXXX...XL```\n```X```\n```RRRR....RX```\n```R```\n```R```\n```L```\n```XXXX...XL```\n```start```\n```L```\n```X```\n```RRRR...RX```\n```start```\n```X```\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n=start.size();\\n        int px=0,pr=0;\\n        for(int i=0,j=0; i<n && j<n; j++)\\n        {\\n            if(start[i]==end[j])\\n            {\\n                i++;\\n            }\\n            else if(end[j]==\\'R\\') \\n            {\\n                return false;\\n            }\\n            else\\n            {\\n                char c2=end[j];\\n                char c1=(c2==\\'L\\')?\\'X\\':\\'R\\';\\n                \\n                int k=max(i,(c2==\\'L\\')?px:pr);\\n                while(k<n && start[k]==c1) k++;\\n                if(k==i || k==n || start[k]!=c2) return false;\\n                \\n                start[k]=c1;                \\n                start[i]=c2;\\n                if(c2==\\'L\\') px=k;\\n                else pr=k;\\n                i++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866680,
                "title": "2ms-faster-than-99-13-of-java",
                "content": "```\\npublic boolean canTransform(String start, String end) {\\n        if (start.length() != end.length()) \\n            return false;     \\n        \\n        int n = end.length();\\n        \\n        for (int i = 0, j = 0; true ; i++, j++) {//i < n && j < n\\n            while (i < n && start.charAt(i) == \\'X\\') i++;\\n            while (j < n && end.charAt(j) == \\'X\\') j++;\\n            \\n            if (i == n || j == n)\\n                return i ==  j ;\\n\\n            if (start.charAt(i) != end.charAt(j)) return false;\\n            \\n            if (start.charAt(i) == \\'L\\' && i < j) return false;\\n            if (start.charAt(i) == \\'R\\' && i > j) return false;\\n        }\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic boolean canTransform(String start, String end) {\\n        if (start.length() != end.length()) \\n            return false;     \\n        \\n        int n = end.length();\\n        \\n        for (int i = 0, j = 0; true ; i++, j++) {//i < n && j < n\\n            while (i < n && start.charAt(i) == \\'X\\') i++;\\n            while (j < n && end.charAt(j) == \\'X\\') j++;\\n            \\n            if (i == n || j == n)\\n                return i ==  j ;\\n\\n            if (start.charAt(i) != end.charAt(j)) return false;\\n            \\n            if (start.charAt(i) == \\'L\\' && i < j) return false;\\n            if (start.charAt(i) == \\'R\\' && i > j) return false;\\n        }\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 759970,
                "title": "python-solution",
                "content": "Idea: `start` can be transformed into `end` if and only if:\\n1. The `RL` sequence of `start` is equal to that of `end`.\\n2. For each `R` in `start` (with index `i`), the corresponding `R` in `end` (with index `j`)  must have `i <= j`, because `R` can only move to the right.\\n3. For each `L` in `start` (with index `i`), the corresponding `L` in `end` (with index `j`)  must have `j <= i`, because `L` can only move to the left.\\n\\nThis is equivalent to the following conditions:\\n1. The `RL` sequence of `start` is equal to that of `end`.\\n2. For each index `0 <= i <= n-1`, where `n = len(start) = len(end)`, the number of `R`\\'s in `start[:i+1]` must be larger than or equal to the number of `R`\\'s in `end[:i+1]`; and the number of `L`\\'s in `start[:i+1]` must be smaller than or equal to the number of `L`\\'s in `end[:i+1]`.\\n\\nThis leads to the following solution, with time complexity O(n), and space complexity O(n). The space complexity can be reduced to O(1) if we optimize a bit the `RL` sequence comparison.\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:        \\n        start_without_x = start.replace(\\'X\\', \\'\\')\\n        end_without_x = end.replace(\\'X\\', \\'\\')\\n        if start_without_x != end_without_x:\\n            return False\\n\\t\\t\\t\\n        r_count_start = 0\\n        r_count_end = 0\\n        l_count_start = 0\\n        l_count_end = 0\\n        for i in range(len(start)):\\n            if start[i] == \\'R\\':\\n                r_count_start += 1\\n            elif start[i] == \\'L\\':\\n                l_count_start += 1\\n            if end[i] == \\'R\\':\\n                r_count_end += 1\\n            elif end[i] == \\'L\\':\\n                l_count_end += 1\\n            if r_count_start < r_count_end or l_count_start > l_count_end:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:        \\n        start_without_x = start.replace(\\'X\\', \\'\\')\\n        end_without_x = end.replace(\\'X\\', \\'\\')\\n        if start_without_x != end_without_x:\\n            return False\\n\\t\\t\\t\\n        r_count_start = 0\\n        r_count_end = 0\\n        l_count_start = 0\\n        l_count_end = 0\\n        for i in range(len(start)):\\n            if start[i] == \\'R\\':\\n                r_count_start += 1\\n            elif start[i] == \\'L\\':\\n                l_count_start += 1\\n            if end[i] == \\'R\\':\\n                r_count_end += 1\\n            elif end[i] == \\'L\\':\\n                l_count_end += 1\\n            if r_count_start < r_count_end or l_count_start > l_count_end:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707291,
                "title": "simple-cpp-solution-using-stack-with-detailed-explanation-o-n-tc",
                "content": "```\\n    bool canTransform(string start, string end) {\\n        if(start.size() != end.size())\\n            return false;\\n        \\n        //Notice that index of L in start will be greater than index of L in end.\\n        //Index of R in start will be less than index of R in end.\\n        //Record all L and R positions in both strings and verify this condition.\\n        //Stack for start and end. {L or R, its index position corresponding string}\\n        stack<pair<char, int>> stStart, stEnd;\\n        \\n        //Take only indices of L and R in start and end string\\n        for(int i = 0; i < start.size(); i++)\\n        {\\n            if(start[i] != \\'X\\')\\n                stStart.push({start[i], i});\\n            if(end[i] != \\'X\\')\\n                stEnd.push({end[i], i});\\n        }\\n        \\n        //If they don\\'t have same number of L\\'s and R\\'s, return false\\n        if(stStart.size() != stEnd.size())\\n            return false;\\n        \\n        //Loop through all the elements in both stacks\\n        while(!stStart.empty())\\n        {\\n            //take characters from start and end stacks and their corresponding indexes from the pair.\\n            char first = stStart.top().first, second = stEnd.top().first;\\n            int i = stStart.top().second, j = stEnd.top().second;\\n            \\n            //pop seen elements.\\n            stStart.pop();\\n            stEnd.pop();\\n            \\n            //If characters are not the same in the sequence, then return false.\\n            if(first != second)\\n                return false;\\n            //If we have R on both strings, then R in start must be less than R in end. If not, return false.\\n            else if(first == \\'R\\' && i > j)\\n                return false;\\n            //If we have L on both strings, then L in start must be more than L in end. If not, return false.\\n            else if(first == \\'L\\' && i < j)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool canTransform(string start, string end) {\\n        if(start.size() != end.size())\\n            return false;\\n        \\n        //Notice that index of L in start will be greater than index of L in end.\\n        //Index of R in start will be less than index of R in end.\\n        //Record all L and R positions in both strings and verify this condition.\\n        //Stack for start and end. {L or R, its index position corresponding string}\\n        stack<pair<char, int>> stStart, stEnd;\\n        \\n        //Take only indices of L and R in start and end string\\n        for(int i = 0; i < start.size(); i++)\\n        {\\n            if(start[i] != \\'X\\')\\n                stStart.push({start[i], i});\\n            if(end[i] != \\'X\\')\\n                stEnd.push({end[i], i});\\n        }\\n        \\n        //If they don\\'t have same number of L\\'s and R\\'s, return false\\n        if(stStart.size() != stEnd.size())\\n            return false;\\n        \\n        //Loop through all the elements in both stacks\\n        while(!stStart.empty())\\n        {\\n            //take characters from start and end stacks and their corresponding indexes from the pair.\\n            char first = stStart.top().first, second = stEnd.top().first;\\n            int i = stStart.top().second, j = stEnd.top().second;\\n            \\n            //pop seen elements.\\n            stStart.pop();\\n            stEnd.pop();\\n            \\n            //If characters are not the same in the sequence, then return false.\\n            if(first != second)\\n                return false;\\n            //If we have R on both strings, then R in start must be less than R in end. If not, return false.\\n            else if(first == \\'R\\' && i > j)\\n                return false;\\n            //If we have L on both strings, then L in start must be more than L in end. If not, return false.\\n            else if(first == \\'L\\' && i < j)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697496,
                "title": "javascript-time-o-n",
                "content": "```\\n/**\\n * @param {string} start\\n * @param {string} end\\n * @return {boolean}\\n */\\nvar canTransform = function(start, end) {\\n    let R = 0\\n    let L = 0\\n    if (start.length != end.length) {\\n        return false\\n    }\\n    var i = 0\\n    while (i < start.length) {\\n        let char_s = start[i]\\n        let char_e = end[i] \\n        if (char_s === \\'R\\') {\\n            R += 1\\n        } else if (char_s === \\'L\\') {\\n            L += 1\\n        }     \\n        if (L < 0 && R > 0) {\\n            return false\\n        }        \\n        \\n        if (char_e === \\'R\\') {\\n            R -= 1\\n        } else if (char_e === \\'L\\') {\\n            L -= 1\\n        }\\n        if (L > 0 || R < 0) {\\n            return false\\n        }\\n        if (L < 0 && R > 0) {\\n            return false\\n        }   \\n        i++\\n    }\\n    \\n    return L === 0 && R === 0\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} start\\n * @param {string} end\\n * @return {boolean}\\n */\\nvar canTransform = function(start, end) {\\n    let R = 0\\n    let L = 0\\n    if (start.length != end.length) {\\n        return false\\n    }\\n    var i = 0\\n    while (i < start.length) {\\n        let char_s = start[i]\\n        let char_e = end[i] \\n        if (char_s === \\'R\\') {\\n            R += 1\\n        } else if (char_s === \\'L\\') {\\n            L += 1\\n        }     \\n        if (L < 0 && R > 0) {\\n            return false\\n        }        \\n        \\n        if (char_e === \\'R\\') {\\n            R -= 1\\n        } else if (char_e === \\'L\\') {\\n            L -= 1\\n        }\\n        if (L > 0 || R < 0) {\\n            return false\\n        }\\n        if (L < 0 && R > 0) {\\n            return false\\n        }   \\n        i++\\n    }\\n    \\n    return L === 0 && R === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 631038,
                "title": "c-easy-to-understand-solution",
                "content": "```\\npublic class Solution {\\n    public bool CanTransform(string start, string end) {\\n        var sb = new StringBuilder();\\n        \\n        foreach(var c in start){\\n            if(c == \\'X\\') continue;\\n            sb.Append(c);\\n        }\\n        var s = sb.ToString();\\n        \\n        sb.Clear();\\n        foreach(var c in end){\\n            if(c ==\\'X\\') continue;\\n            sb.Append(c);\\n        }\\n        var e = sb.ToString();\\n        \\n        if(s != e) return false;\\n        \\n        var j = 0;\\n        for(var i = 0; i < start.Length; ++i){\\n            if(start[i] == \\'X\\') continue;\\n            while(end[j] == \\'X\\')\\n                j++;    \\n            if(start[i] == \\'L\\' && i < j)\\n                return false;\\n            \\n            if(start[i] == \\'R\\' && i > j)\\n                return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanTransform(string start, string end) {\\n        var sb = new StringBuilder();\\n        \\n        foreach(var c in start){\\n            if(c == \\'X\\') continue;\\n            sb.Append(c);\\n        }\\n        var s = sb.ToString();\\n        \\n        sb.Clear();\\n        foreach(var c in end){\\n            if(c ==\\'X\\') continue;\\n            sb.Append(c);\\n        }\\n        var e = sb.ToString();\\n        \\n        if(s != e) return false;\\n        \\n        var j = 0;\\n        for(var i = 0; i < start.Length; ++i){\\n            if(start[i] == \\'X\\') continue;\\n            while(end[j] == \\'X\\')\\n                j++;    \\n            if(start[i] == \\'L\\' && i < j)\\n                return false;\\n            \\n            if(start[i] == \\'R\\' && i > j)\\n                return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540992,
                "title": "c-easy-100-sc-95-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        string st = start;\\n        string en = end;\\n        st.erase(remove(st.begin(),st.end(),\\'X\\'),st.end());\\n        en.erase(remove(en.begin(),en.end(),\\'X\\'),en.end());\\n        if(st != en)return false;\\n        \\n        int t = 0;\\n        for(int i = 0;i<start.length();i++) {\\n            if(start[i] == \\'L\\') {\\n                while(end[t] != \\'L\\')t++;\\n                if(t++>i)return false;\\n            }\\n        }\\n        \\n        t = 0;\\n        for(int i = 0;i<start.length();i++) {\\n            if(start[i] == \\'R\\') {\\n                while(end[t] != \\'R\\') t++;\\n                if(t++<i)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        string st = start;\\n        string en = end;\\n        st.erase(remove(st.begin(),st.end(),\\'X\\'),st.end());\\n        en.erase(remove(en.begin(),en.end(),\\'X\\'),en.end());\\n        if(st != en)return false;\\n        \\n        int t = 0;\\n        for(int i = 0;i<start.length();i++) {\\n            if(start[i] == \\'L\\') {\\n                while(end[t] != \\'L\\')t++;\\n                if(t++>i)return false;\\n            }\\n        }\\n        \\n        t = 0;\\n        for(int i = 0;i<start.length();i++) {\\n            if(start[i] == \\'R\\') {\\n                while(end[t] != \\'R\\') t++;\\n                if(t++<i)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499452,
                "title": "simple-javascript-for-loop",
                "content": "```javascript\\nvar canTransform = function(start, end) {\\n    let i = 0, j = 0\\n    for (; i < start.length && j < end.length; i++, j++) {\\n        while (end[j] === \\'X\\') j++\\n        while (start[i] === \\'X\\') i++\\n        if (start[i] !== end[j]) return false\\n        if (start[i] === \\'R\\' && i > j || start[i] === \\'L\\' && j > i) {\\n            return false\\n        }\\n    }\\n    while (i < start.length) {\\n        if (start[i] !== \\'X\\') return false\\n        i++\\n    }\\n    while (j < end.length) {\\n        if (end[j] !== \\'X\\') return false\\n        j++\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar canTransform = function(start, end) {\\n    let i = 0, j = 0\\n    for (; i < start.length && j < end.length; i++, j++) {\\n        while (end[j] === \\'X\\') j++\\n        while (start[i] === \\'X\\') i++\\n        if (start[i] !== end[j]) return false\\n        if (start[i] === \\'R\\' && i > j || start[i] === \\'L\\' && j > i) {\\n            return false\\n        }\\n    }\\n    while (i < start.length) {\\n        if (start[i] !== \\'X\\') return false\\n        i++\\n    }\\n    while (j < end.length) {\\n        if (end[j] !== \\'X\\') return false\\n        j++\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444034,
                "title": "python-o-n-time-o-1-space-7-lines",
                "content": "```\\ndef canTransform(self, start: str, end: str) -> bool:\\n        L, R = 0, 0\\n        for s, e in zip(start, end):\\n            L += (e == \\'L\\') - (s == \\'L\\')\\n            R += (s == \\'R\\') - (e == \\'R\\')\\n\\n            if L < 0 or L > 0 and s == \\'R\\' or R < 0 or R > 0 and s == \\'L\\' or L > 0 and R > 0:\\n                return False\\n\\n        return not R and not L\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef canTransform(self, start: str, end: str) -> bool:\\n        L, R = 0, 0\\n        for s, e in zip(start, end):\\n            L += (e == \\'L\\') - (s == \\'L\\')\\n            R += (s == \\'R\\') - (e == \\'R\\')\\n\\n            if L < 0 or L > 0 and s == \\'R\\' or R < 0 or R > 0 and s == \\'L\\' or L > 0 and R > 0:\\n                return False\\n\\n        return not R and not L\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 406183,
                "title": "c-o-n-2-incrementally-transform-the-source-string-to-target-string",
                "content": "Just provide another method different with the official O(n) solution.\\nWe transform the source string to target string from left to right at each character.\\n1. start[i] == end[i]: We are fine, just continue;\\n2. start[i] == \\'X\\' and end[i] == \\'L\\': Find and swap with the next \\'L\\' without \\'R\\' in between; otherwise return false because [1];\\n3. start[i] == \\'R\\' and end[i] == \\'X\\': Find and swap with the next \\'X\\' without \\'L\\' in between, otherwise return false because [1];\\n4. otherswise: return false, because:\\n\\t\\ta. X->R, left strings are already matched, so we don\\'t have additional R to move from left side.\\n\\t\\tb. R->L, [1]\\n\\n[1] we can\\'t move R and L across each other.\\nRunning time is O(n^2)\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n = start.length();\\n        for (int i = 0; i < n; i++) {\\n            if (start[i] == end[i]) {\\n                continue;\\n            }\\n            if (end[i] == \\'L\\' && start[i] == \\'X\\') {\\n                int k = i + 1;\\n                while (k < n && start[k] == \\'X\\') {\\n                    k++;\\n                }\\n                if (k == n) {\\n                    return false;\\n                }\\n                if (start[k] == \\'L\\') {\\n                    swap(start[i], start[k]);\\n                } else {\\n                    return false;\\n                }\\n            } else if (end[i] = \\'X\\' && start[i] == \\'R\\') {\\n                int k = i + 1;\\n                while (k < n && start[k] == \\'R\\') {\\n                    k++;\\n                }\\n                if (k == n) {\\n                    return false;\\n                }\\n                if (start[k] == \\'X\\') {\\n                    swap(start[i], start[k]);\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n = start.length();\\n        for (int i = 0; i < n; i++) {\\n            if (start[i] == end[i]) {\\n                continue;\\n            }\\n            if (end[i] == \\'L\\' && start[i] == \\'X\\') {\\n                int k = i + 1;\\n                while (k < n && start[k] == \\'X\\') {\\n                    k++;\\n                }\\n                if (k == n) {\\n                    return false;\\n                }\\n                if (start[k] == \\'L\\') {\\n                    swap(start[i], start[k]);\\n                } else {\\n                    return false;\\n                }\\n            } else if (end[i] = \\'X\\' && start[i] == \\'R\\') {\\n                int k = i + 1;\\n                while (k < n && start[k] == \\'R\\') {\\n                    k++;\\n                }\\n                if (k == n) {\\n                    return false;\\n                }\\n                if (start[k] == \\'X\\') {\\n                    swap(start[i], start[k]);\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397436,
                "title": "simple-java-solution",
                "content": "Note: Many similar solutions miss edge cases like \"XRL\"->\"LRX\".\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        char[] s = start.toCharArray(), t = end.toCharArray();\\n        if (s.length != t.length) return false;\\n        int n = s.length;\\n        \\n        int R = 0; // need R from end\\n        int L = 0; // need L from start\\n        for (int i=0; i<n; i++) {\\n            if (s[i] == \\'R\\') {\\n                if (L > 0) return false;\\n                R++;\\n            } else if (s[i] == \\'L\\') {\\n                L--;\\n            }\\n            \\n            if (t[i] == \\'R\\') R--;\\n            else if (t[i] == \\'L\\') {\\n                if (R > 0) return false;\\n                L++;\\n            }\\n            \\n            if (L > 0 && R > 0 || L < 0 || R < 0) return false;\\n        }\\n        return R == 0 && L == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        char[] s = start.toCharArray(), t = end.toCharArray();\\n        if (s.length != t.length) return false;\\n        int n = s.length;\\n        \\n        int R = 0; // need R from end\\n        int L = 0; // need L from start\\n        for (int i=0; i<n; i++) {\\n            if (s[i] == \\'R\\') {\\n                if (L > 0) return false;\\n                R++;\\n            } else if (s[i] == \\'L\\') {\\n                L--;\\n            }\\n            \\n            if (t[i] == \\'R\\') R--;\\n            else if (t[i] == \\'L\\') {\\n                if (R > 0) return false;\\n                L++;\\n            }\\n            \\n            if (L > 0 && R > 0 || L < 0 || R < 0) return false;\\n        }\\n        return R == 0 && L == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365376,
                "title": "python-3-solution-by-using-i-and-j-pointer",
                "content": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        i, j = 0, 0\\n        if(start == end): return True\\n        n = len(start)\\n        \\n        while i < n and j < n:\\n            while i < n - 1 and (start[i] == \\'X\\'): i += 1\\n            while j < n -1 and (end[j] == \\'X\\'): j += 1\\n            \\n            if (start[i] != end[j]): \\n                return False\\n            \\n            if (start[i] == \\'R\\' and j < i) or (start[i] == \\'L\\' and i < j): \\n                return False\\n            \\n            i += 1\\n            j += 1\\n            \\n        return True```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        i, j = 0, 0\\n        if(start == end): return True\\n        n = len(start)\\n        \\n        while i < n and j < n:\\n            while i < n - 1 and (start[i] == \\'X\\'): i += 1\\n            while j < n -1 and (end[j] == \\'X\\'): j += 1\\n            \\n            if (start[i] != end[j]): \\n                return False\\n            \\n            if (start[i] == \\'R\\' and j < i) or (start[i] == \\'L\\' and i < j): \\n                return False\\n            \\n            i += 1\\n            j += 1\\n            \\n        return True```",
                "codeTag": "Java"
            },
            {
                "id": 296106,
                "title": "oj-issue-or-am-i-crazy",
                "content": "Hi guys,\\n\\nSo, I have a sub-optimal solution, bi-directional BFS search. And I know there is a better way, but my dumb solution should work bearing slowness.\\nAnd here is the weird part, for test case below, my code outputs \"true\" according to OJ, but in the playground debug, it outputs the correct answer \"false\". What\\'s happending here? Can someone help take a look?\\n\\nTest case:\\n\"XXRXXLXXXX\"\\n\"XXXXRXXLXX\"\\n\\nBelow is dumb code:\\n\\n```\\nbool canTransform(string start, string end) {\\n        if (start == end)   return true;\\n        \\n        int n = start.size();\\n        if (n == 1) return start == end;\\n        \\n        unordered_set<string> s1{start}, s2{end}, seen{start, end};\\n        \\n        while (!s1.empty() && !s2.empty())\\n        {\\n            if (s1.size() > s2.size())  s1.swap(s2);\\n            \\n            unordered_set<string> next;\\n            for (auto s : s1)\\n            {\\n                n = s.size();\\n                for (int i = 1; i < n; ++i)\\n                {\\n                    if ((s[i - 1] == \\'X\\' && s[i] == \\'L\\')\\n                        || (s[i - 1] == \\'R\\' && s[i] == \\'X\\'))\\n                    {\\n                        swap(s[i - 1], s[i]);\\n                        \\n                        if (s2.find(s) != s2.end()) return true;\\n                        if (seen.find(s) == seen.end())\\n                        {\\n                            next.insert(s);\\n                            seen.insert(s);\\n                        }\\n                        \\n                        swap(s[i - 1], s[i]);\\n                    }\\n                }\\n            }\\n            \\n            next.swap(s1);\\n        }\\n        \\n        return false;\\n    }\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\nbool canTransform(string start, string end) {\\n        if (start == end)   return true;\\n        \\n        int n = start.size();\\n        if (n == 1) return start == end;\\n        \\n        unordered_set<string> s1{start}, s2{end}, seen{start, end};\\n        \\n        while (!s1.empty() && !s2.empty())\\n        {\\n            if (s1.size() > s2.size())  s1.swap(s2);\\n            \\n            unordered_set<string> next;\\n            for (auto s : s1)\\n            {\\n                n = s.size();\\n                for (int i = 1; i < n; ++i)\\n                {\\n                    if ((s[i - 1] == \\'X\\' && s[i] == \\'L\\')\\n                        || (s[i - 1] == \\'R\\' && s[i] == \\'X\\'))\\n                    {\\n                        swap(s[i - 1], s[i]);\\n                        \\n                        if (s2.find(s) != s2.end()) return true;\\n                        if (seen.find(s) == seen.end())\\n                        {\\n                            next.insert(s);\\n                            seen.insert(s);\\n                        }\\n                        \\n                        swap(s[i - 1], s[i]);\\n                    }\\n                }\\n            }\\n            \\n            next.swap(s1);\\n        }\\n        \\n        return false;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 291409,
                "title": "my-c-solution",
                "content": "Don\\'t know if this is good solution or not...but it passed\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canTransform(string start, string end) {\\n\\t\\t\\tif(start.size() == 1 && start[0] != end[0])\\n\\t\\t\\t\\treturn false;\\n        \\n        for(int i=0;i<start.size();++i){\\n            if(start[i] == end[i])\\n                continue;\\n            else{\\n                int j = i+1;\\n                if(i<start.size()-1 && (start[i] == \\'X\\' || start[i] == \\'R\\')){\\n                    while(start[i]==start[j]){\\n                        j++;\\n                    }\\n                }\\n                if((start[i] ==\\'X\\' && start[j] == \\'L\\') || (start[i] == \\'R\\'&& start[j] == \\'X\\'))\\n                    swap(start[i],start[j]);\\n                if(end[i] == start[i])\\n                    continue;\\n                else\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool canTransform(string start, string end) {\\n\\t\\t\\tif(start.size() == 1 && start[0] != end[0])\\n\\t\\t\\t\\treturn false;\\n        \\n        for(int i=0;i<start.size();++i){\\n            if(start[i] == end[i])\\n                continue;\\n            else{\\n                int j = i+1;\\n                if(i<start.size()-1 && (start[i] == \\'X\\' || start[i] == \\'R\\')){\\n                    while(start[i]==start[j]){\\n                        j++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 222477,
                "title": "simple-c",
                "content": "```\\n    bool canTransform(string start, string end) {\\n        if(start.size() != end.size()) return false;\\n        int i = 0, j = 0;\\n        while(i < start.size() && j < end.size())\\n        {\\n            while(start[i] == \\'X\\') ++i;\\n            while(end[j] == \\'X\\') ++j;\\n            if( (start[i] != end[j]) ||\\n                (start[i] == \\'R\\' && i > j) ||\\n                (start[i] == \\'L\\' && i < j) ) \\n                return false;\\n            ++i;\\n            ++j;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool canTransform(string start, string end) {\\n        if(start.size() != end.size()) return false;\\n        int i = 0, j = 0;\\n        while(i < start.size() && j < end.size())\\n        {\\n            while(start[i] == \\'X\\') ++i;\\n            while(end[j] == \\'X\\') ++j;\\n            if( (start[i] != end[j]) ||\\n                (start[i] == \\'R\\' && i > j) ||\\n                (start[i] == \\'L\\' && i < j) ) \\n                return false;\\n            ++i;\\n            ++j;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 139104,
                "title": "walking-robot-algorithm-with-java-solution",
                "content": "Algorithm:\\n1. Every current `non-X` character must be the same (both `L` or both `R`)\\n2. `L` cannot move right, so when both `L`: `i >= j `required\\n3. `R` cannot move left, so when both `R`: `i <= j` required\\n4. They must stop together\\n\\n\\u7B97\\u6CD5\\uFF1A\\n1. \\u6BCF\\u4E2A\\u5F53\\u524D\\u7684\\u975EX\\u5B57\\u6BCD\\u5FC5\\u987B\\u76F8\\u540C\\n2. L\\u4E0D\\u80FD\\u5411\\u53F3\\u79FB\\uFF0C\\u6240\\u4EE5\\u540C\\u4E3AL\\uFF0Ci >= j \\u624D\\u884C\\uFF1B\\n3. \\u540C\\u7406\\uFF0CR\\u4E0D\\u80FD\\u5411\\u5DE6\\u79FB\\uFF0C\\u6240\\u4EE5\\u540C\\u4E3AR\\uFF0Ci <= j \\u624D\\u884C\\uFF1B\\n4. \\u5FC5\\u987B\\u4E00\\u8D77\\u7ED3\\u675F\\n\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        final int N = start.length();       \\n        for (int i = 0, j = 0; i < N && j < N; i++, j++) {\\n            while (i < N && start.charAt(i) == \\'X\\') i++;\\n            while (j < N && end.charAt(j) == \\'X\\') j++;\\n            if (i == N || j == N) return i == j;\\n            if (start.charAt(i) != end.charAt(j)) return false;\\n            boolean isLeft = start.charAt(i) == \\'L\\';\\n            if (isLeft && j > i) return false;\\n            if (!isLeft && i > j) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        final int N = start.length();       \\n        for (int i = 0, j = 0; i < N && j < N; i++, j++) {\\n            while (i < N && start.charAt(i) == \\'X\\') i++;\\n            while (j < N && end.charAt(j) == \\'X\\') j++;\\n            if (i == N || j == N) return i == j;\\n            if (start.charAt(i) != end.charAt(j)) return false;\\n            boolean isLeft = start.charAt(i) == \\'L\\';\\n            if (isLeft && j > i) return false;\\n            if (!isLeft && i > j) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115472,
                "title": "clean-one-pass-o-n-o-1-java",
                "content": "```\n    public boolean canTransform(String start, String end) {\n        int el = 0;\n        int sr = 0;\n        \n        for(int i = 0; i < start.length(); i++) {\n            if(start.charAt(i) == 'R') \n                sr++;\n            \n            if(end.charAt(i) == 'L') \n                el++;\n            \n            if(start.charAt(i) == 'L' && --el < 0) \n                return false;\n            \n            if(end.charAt(i) == 'R' && --sr < 0) \n                return false;\n            \n            if(sr > 0 && el > 0) \n                return false;\n        }\n        \n        return el == 0 && sr == 0;\n    }\n```",
                "solutionTags": [],
                "code": "```\n    public boolean canTransform(String start, String end) {\n        int el = 0;\n        int sr = 0;\n        \n        for(int i = 0; i < start.length(); i++) {\n            if(start.charAt(i) == 'R') \n                sr++;\n            \n            if(end.charAt(i) == 'L') \n                el++;\n            \n            if(start.charAt(i) == 'L' && --el < 0) \n                return false;\n            \n            if(end.charAt(i) == 'R' && --sr < 0) \n                return false;\n            \n            if(sr > 0 && el > 0) \n                return false;\n        }\n        \n        return el == 0 && sr == 0;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113796,
                "title": "python-o-n-two-pointers-solution",
                "content": "```\\n        p0, p1, l = 0, 0, len(start)\\n        while p0 < l and p1 < l:\\n            while p0 < l and start[p0] == 'X':\\n                p0 += 1\\n            while p1 < l and end[p1] == 'X':\\n                p1 += 1\\n            if p0 < l and p1 < l:\\n                if start[p0] != end[p1]:\\n                    return False\\n                if start[p0] == 'R' and p0 > p1:\\n                    return False\\n                if start[p0] == 'L' and p0 < p1:\\n                    return False\\n                p0 += 1\\n                p1 += 1\\n        while p0 < l and start[p0] == 'X':\\n            p0 += 1\\n        while p1 < l and end[p1] == 'X':\\n            p1 += 1\\n        return True if p0 == p1 else False\\n```\\nUsing the fact that the order of 'L' and 'R' are certain and 'L' can only go left and 'R' can only go right. \\nAt the end, we need to make sure the number of L and R are the same.",
                "solutionTags": [],
                "code": "```\\n        p0, p1, l = 0, 0, len(start)\\n        while p0 < l and p1 < l:\\n            while p0 < l and start[p0] == 'X':\\n                p0 += 1\\n            while p1 < l and end[p1] == 'X':\\n                p1 += 1\\n            if p0 < l and p1 < l:\\n                if start[p0] != end[p1]:\\n                    return False\\n                if start[p0] == 'R' and p0 > p1:\\n                    return False\\n                if start[p0] == 'L' and p0 < p1:\\n                    return False\\n                p0 += 1\\n                p1 += 1\\n        while p0 < l and start[p0] == 'X':\\n            p0 += 1\\n        while p1 < l and end[p1] == 'X':\\n            p1 += 1\\n        return True if p0 == p1 else False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113785,
                "title": "one-pass-c-o-n-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        if (start.size() != end.size()) return false;\\n        int n = start.size(), sL = 0, sR = 0, eL = 0, eR = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (start[i] != 'X') start[i] == 'L' ? ++sL : ++sR;\\n            if (end[i] != 'X') end[i] == 'L' ? ++eL : ++eR;\\n            if ((sL > eL || sR < eR) || (start[i] == 'L' && sR > eR) || (start[i] == 'R' && sL < eL)) return false;\\n        }\\n        return sL == eL && sR == eR;\\n    }\\n};\\n```\\n* L can't move to the right, at index ``i``, ``sL`` must be less than or equal to ``eL``\\n* R can't move to the left, at index ``i``, ``sR`` must be greater than or equal to ``eR``\\n* R can't move to the right of the first L on its right, at index ``i``, if ``start[i]`` is L, ``sR`` must be less than or equal to ``eR``\\n* L can't move to the left of the first R on its left, at index ``i``, if ``start[i]`` is R, ``sL`` must be greater than or equal to ``eL``",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        if (start.size() != end.size()) return false;\\n        int n = start.size(), sL = 0, sR = 0, eL = 0, eR = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (start[i] != 'X') start[i] == 'L' ? ++sL : ++sR;\\n            if (end[i] != 'X') end[i] == 'L' ? ++eL : ++eR;\\n            if ((sL > eL || sR < eR) || (start[i] == 'L' && sR > eR) || (start[i] == 'R' && sL < eL)) return false;\\n        }\\n        return sL == eL && sR == eR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113778,
                "title": "tried-c-dfs-but-tle-working-to-improve-it",
                "content": "    bool canTransform(string start, string end) {\\n        unordered_set<string> visited;\\n        \\n        stack<string> s;\\n        s.push(start);\\n        visited.insert(start);\\n        \\n        while(!s.empty()){\\n            start=s.top();\\n            s.pop();\\n            if(start==end) return true;\\n            for(int i=0;i<start.length()-1;i++){\\n                if(start[i]=='X' && start[i+1]=='L'){\\n                    start[i]='L';\\n                    start[i+1]='X';\\n                    if(visited.insert(start).second){\\n                        s.push(start);\\n                    }\\n                    start[i]='X';\\n                    start[i+1]='L';\\n                }else if(start[i]=='R' && start[i+1]=='X'){\\n                    start[i]='X';\\n                    start[i+1]='R';\\n                    if(visited.insert(start).second){\\n                        s.push(start);\\n                    }\\n                    start[i]='R';\\n                    start[i+1]='X';\\n                }\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool canTransform(string start, string end) {\\n        unordered_set<string> visited;\\n        \\n        stack<string> s;\\n        s.push(start);\\n        visited.insert(start);\\n        \\n        while(!s.empty()){\\n            start=s.top();\\n            s.pop();\\n            if(start==end) return true;\\n            for(int i=0;i<start.length()-1;i++){\\n                if(start[i]=='X' && start[i+1]=='L'){\\n                    start[i]='L';\\n                    start[i+1]='X';\\n                    if(visited.insert(start).second){\\n                        s.push(start);\\n                    }\\n                    start[i]='X';\\n                    start[i+1]='L';\\n                }else if(start[i]=='R' && start[i+1]=='X'){\\n                    start[i]='X';\\n                    start[i+1]='R';\\n                    if(visited.insert(start).second){\\n                        s.push(start);\\n                    }\\n                    start[i]='R';\\n                    start[i+1]='X';\\n                }\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 113777,
                "title": "java-13-lines-o-n",
                "content": "Since each char is visited one time in `for` loop and at most one time in `while` loop, the runtime is `O(n)` where n is the length of the strings.\\n\\n    public boolean canTransform(String start, String end) {\\n        char[] s = start.toCharArray(), e = end.toCharArray();\\n        int n = s.length, next = 1;\\n        for(int i = 0; i < n; i++) {\\n            if (s[i] == e[i]) continue;\\n            if ((e[i] == 'X' && s[i] == 'R') || (e[i] == 'L' && s[i] == 'X')) {\\n                next = Math.max(next, i+1);\\n                while(next < n && s[next] == s[i]) next++;\\n                if (next == n || s[next] != e[i]) return false;\\n                s[next] = s[i];\\n            } else\\n                return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "Since each char is visited one time in `for` loop and at most one time in `while` loop, the runtime is `O(n)` where n is the length of the strings.\\n\\n    public boolean canTransform(String start, String end) {\\n        char[] s = start.toCharArray(), e = end.toCharArray();\\n        int n = s.length, next = 1;\\n        for(int i = 0; i < n; i++) {\\n            if (s[i] == e[i]) continue;\\n            if ((e[i] == 'X' && s[i] == 'R') || (e[i] == 'L' && s[i] == 'X')) {\\n                next = Math.max(next, i+1);\\n                while(next < n && s[next] == s[i]) next++;\\n                if (next == n || s[next] != e[i]) return false;\\n                s[next] = s[i];\\n            } else\\n                return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4063447,
                "title": "c-beats-100-of-solutions-in-runtime",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n = start.size(), i = 0, j = 0;\\n        while (i < n || j < n) {\\n            while (i < n && start[i] == \\'X\\') ++ i;\\n            while (j < n && end[j] == \\'X\\') ++ j;\\n            if (j == n || i == n) break; \\n            if (start[i] != end[j]) return false;\\n            if (start[i] == \\'L\\' && i < j) return false;\\n            if (start[i] == \\'R\\' && i > j) return false;\\n            ++ i; ++ j;\\n        }\\n        return (j == n && i == n);\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int n = start.size(), i = 0, j = 0;\\n        while (i < n || j < n) {\\n            while (i < n && start[i] == \\'X\\') ++ i;\\n            while (j < n && end[j] == \\'X\\') ++ j;\\n            if (j == n || i == n) break; \\n            if (start[i] != end[j]) return false;\\n            if (start[i] == \\'L\\' && i < j) return false;\\n            if (start[i] == \\'R\\' && i > j) return false;\\n            ++ i; ++ j;\\n        }\\n        return (j == n && i == n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047941,
                "title": "python3-simple-solution-beats-100-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe keep track of possible Ls and Rs to keep track of, so that they can be accounted for by future characters. This is kept track of in the lCount and rCount variables.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        lCount = 0\\n        rCount = 0\\n        n = len(start)\\n        for i in range(n):\\n            s = start[i]; e = end[i]\\n            if s == \\'L\\' and rCount > 0:\\n                return False\\n            if e == \\'R\\' and lCount > 0:\\n                return False\\n            if e == \\'L\\':\\n                lCount += 1\\n            if s == \\'R\\':\\n                rCount += 1\\n            if s == \\'L\\':\\n                if lCount > 0:\\n                    lCount -= 1\\n                else:\\n                    return False\\n            if e == \\'R\\':\\n                if rCount > 0:\\n                    rCount -= 1\\n                else:\\n                    return False\\n        return lCount == 0 and rCount == 0\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        lCount = 0\\n        rCount = 0\\n        n = len(start)\\n        for i in range(n):\\n            s = start[i]; e = end[i]\\n            if s == \\'L\\' and rCount > 0:\\n                return False\\n            if e == \\'R\\' and lCount > 0:\\n                return False\\n            if e == \\'L\\':\\n                lCount += 1\\n            if s == \\'R\\':\\n                rCount += 1\\n            if s == \\'L\\':\\n                if lCount > 0:\\n                    lCount -= 1\\n                else:\\n                    return False\\n            if e == \\'R\\':\\n                if rCount > 0:\\n                    rCount -= 1\\n                else:\\n                    return False\\n        return lCount == 0 and rCount == 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033409,
                "title": "simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn can_transform(start: String, end: String) -> bool {\\n        let start = start.chars().enumerate().filter(|&(i,c)| c!=\\'X\\').collect::<Vec<(_,_)>>();\\n        let end   =   end.chars().enumerate().filter(|&(i,c)| c!=\\'X\\').collect::<Vec<(_,_)>>();\\n        let len_s = start.len();\\n        let len_e = end.len();\\n\\n        if len_s != len_e {\\n            return false;\\n        }\\n\\n        for i in 0..len_s {\\n            let (pos_s,c_s) =start[i]; \\n            let (pos_e,c_e) = end[i]; \\n            if c_e != c_s {\\n                return false;\\n            }\\n            if c_s == \\'L\\' && c_e == \\'L\\' {\\n                if pos_s < pos_e {\\n                    return false;\\n                }\\n            }\\n            if c_s == \\'R\\' && c_e == \\'R\\' {\\n                if pos_s > pos_e {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        true\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_transform(start: String, end: String) -> bool {\\n        let start = start.chars().enumerate().filter(|&(i,c)| c!=\\'X\\').collect::<Vec<(_,_)>>();\\n        let end   =   end.chars().enumerate().filter(|&(i,c)| c!=\\'X\\').collect::<Vec<(_,_)>>();\\n        let len_s = start.len();\\n        let len_e = end.len();\\n\\n        if len_s != len_e {\\n            return false;\\n        }\\n\\n        for i in 0..len_s {\\n            let (pos_s,c_s) =start[i]; \\n            let (pos_e,c_e) = end[i]; \\n            if c_e != c_s {\\n                return false;\\n            }\\n            if c_s == \\'L\\' && c_e == \\'L\\' {\\n                if pos_s < pos_e {\\n                    return false;\\n                }\\n            }\\n            if c_s == \\'R\\' && c_e == \\'R\\' {\\n                if pos_s > pos_e {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        true\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022176,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int i = 0;\\n        int j = 0;\\n        int n = start.length();\\n        int m = end.length();\\n\\n        while(i < n || j < m) {\\n            while(start[i] == \\'X\\') {\\n                i++;\\n            }\\n            while(end[j] == \\'X\\') {\\n                j++;\\n            }\\n\\n            if(start[i] != end[j]) \\n                return false;\\n            if(start[i] == \\'R\\' && i > j) \\n                return false;\\n            if(start[i] == \\'L\\' && i < j) \\n                return false; \\n            i++;\\n            j++;\\n        }\\n        return true;    \\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/05b04280-21c8-46c8-83ec-c3e2b0e085fb_1694077342.2801075.png)",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int i = 0;\\n        int j = 0;\\n        int n = start.length();\\n        int m = end.length();\\n\\n        while(i < n || j < m) {\\n            while(start[i] == \\'X\\') {\\n                i++;\\n            }\\n            while(end[j] == \\'X\\') {\\n                j++;\\n            }\\n\\n            if(start[i] != end[j]) \\n                return false;\\n            if(start[i] == \\'R\\' && i > j) \\n                return false;\\n            if(start[i] == \\'L\\' && i < j) \\n                return false; \\n            i++;\\n            j++;\\n        }\\n        return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015904,
                "title": "easy-java-solution-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canTransform(String st, String end) {\\n        int n = st.length();\\n\\n        int i=0; \\n        int j=0;\\n\\n        while(i<n || j<n){\\n            \\n            while(i<n && st.charAt(i)==\\'X\\') i++;\\n\\n            while(j<n && end.charAt(j)==\\'X\\') j++;\\n\\n            if(i==n || j==n) break;\\n\\n            if(st.charAt(i)!=end.charAt(j) || (st.charAt(i)==\\'R\\' && i>j) || st.charAt(i)==\\'L\\' && i<j) return false;\\n\\n            i++;\\n            j++;\\n        }\\n\\n        if(i==j) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String st, String end) {\\n        int n = st.length();\\n\\n        int i=0; \\n        int j=0;\\n\\n        while(i<n || j<n){\\n            \\n            while(i<n && st.charAt(i)==\\'X\\') i++;\\n\\n            while(j<n && end.charAt(j)==\\'X\\') j++;\\n\\n            if(i==n || j==n) break;\\n\\n            if(st.charAt(i)!=end.charAt(j) || (st.charAt(i)==\\'R\\' && i>j) || st.charAt(i)==\\'L\\' && i<j) return false;\\n\\n            i++;\\n            j++;\\n        }\\n\\n        if(i==j) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001049,
                "title": "c-python-solution-with-explanation",
                "content": "First, remove all Xs, if start != end, return False\\nAnd L only is allowed to go to left, R only is allowed to go to right.\\n![image](https://assets.leetcode.com/users/images/117a8737-eea7-44d7-9645-f03c0f47874f_1693826594.5535896.png)\\nBecause of removing all Xs and start == end,\\neach of L in start has corresponding L, each R is the same.\\n\\nposition of corresponding L on end should <= position of L on the start.\\nposition of corresponding R on end should >= position of R on the start.\\n\\n![image](https://assets.leetcode.com/users/images/05a5808a-c502-48a4-a61f-658251bacf8d_1693827180.657234.png)\\n\\ntc is O(n), sc is O(1).\\n### python\\n```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'): return False\\n        j = 0\\n        for i, x in enumerate(start):\\n            if x == \\'X\\': continue\\n            while end[j] == \\'X\\': j += 1\\n            if (x == \\'L\\' and j > i) or (x == \\'R\\' and j < i): return False\\n            j += 1\\n        return True\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int i = 0, j = 0;\\n        while (i < start.size() || j < end.size()) {\\n            if (i < start.size() && start[i] == \\'X\\') {\\n                i += 1;\\n                continue;\\n            }\\n            if (j < end.size() && end[j] == \\'X\\') {\\n                j += 1;\\n                continue;\\n            }\\n            if ((i < start.size() && j < end.size() && start[i] != end[j]) || i == start.size() || j == end.size()) return false;\\n            i += 1;\\n            j += 1;\\n        }\\n        for (i = 0, j = 0; i < start.size(); i+=1) {\\n            if (start[i] == \\'X\\') continue;\\n            while (end[j] == \\'X\\') j += 1;\\n            if ((start[i] == \\'L\\' && j > i) || (start[i] == \\'R\\' && j < i)) return false;\\n            j += 1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'): return False\\n        j = 0\\n        for i, x in enumerate(start):\\n            if x == \\'X\\': continue\\n            while end[j] == \\'X\\': j += 1\\n            if (x == \\'L\\' and j > i) or (x == \\'R\\' and j < i): return False\\n            j += 1\\n        return True\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        int i = 0, j = 0;\\n        while (i < start.size() || j < end.size()) {\\n            if (i < start.size() && start[i] == \\'X\\') {\\n                i += 1;\\n                continue;\\n            }\\n            if (j < end.size() && end[j] == \\'X\\') {\\n                j += 1;\\n                continue;\\n            }\\n            if ((i < start.size() && j < end.size() && start[i] != end[j]) || i == start.size() || j == end.size()) return false;\\n            i += 1;\\n            j += 1;\\n        }\\n        for (i = 0, j = 0; i < start.size(); i+=1) {\\n            if (start[i] == \\'X\\') continue;\\n            while (end[j] == \\'X\\') j += 1;\\n            if ((start[i] == \\'L\\' && j > i) || (start[i] == \\'R\\' && j < i)) return false;\\n            j += 1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987696,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n\\t// First, remove all \\'X\\', and compare if they equal.\\n\\tStringBuffer s = new StringBuffer();\\n\\tStringBuffer e = new StringBuffer();\\n\\tfor (char c : start.toCharArray()) {\\n\\t\\tif (c != \\'X\\') {\\n\\t\\t\\ts.append(c);\\n\\t\\t}\\n\\t}\\n\\tfor (char c : end.toCharArray()) {\\n\\t\\tif (c != \\'X\\') {\\n\\t\\t\\te.append(c);\\n\\t\\t}\\n\\t}\\n\\tif (!s.toString().equals(e.toString()))\\n\\t\\treturn false;\\n\\t// check R\\n\\t// form i to start.length(), \\n\\t// if R found in start count++, \\n\\t// if R found in end count--, \\n\\t// if count comes to negative, that means \\'R\\' is in more left position in end, so \\'R\\' can\\'t move from start to end.\\n\\tint count = 0;\\n\\tfor (int i = 0; i < start.length(); i++) {\\n\\t\\tif (start.charAt(i) == \\'R\\') {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse if (end.charAt(i) == \\'R\\') {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tif (count < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t// check L\\n\\t// same with checking \\'R\\', only difference is: \\n\\t// to ensure every \\'L\\' comes first in end.\\n\\tcount = 0;\\n\\tfor (int i = 0; i < start.length(); i++) {\\n\\t\\tif (end.charAt(i) == \\'L\\') {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse if (start.charAt(i) == \\'L\\') {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tif (count < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n        int i = 0, j = 0, n = s.size(), m = e.size();\\n        while(i < n || j < m) {\\n            while(s[i] == \\'X\\') i++;\\n            while(e[j] == \\'X\\') j++;\\n\\n            if(s[i] != e[j]) return false;\\n            if(s[i] == \\'R\\' && i > j) return false;\\n            if(s[i] == \\'L\\' && i < j) return false; \\n            i++, j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n\\t// First, remove all \\'X\\', and compare if they equal.\\n\\tStringBuffer s = new StringBuffer();\\n\\tStringBuffer e = new StringBuffer();\\n\\tfor (char c : start.toCharArray()) {\\n\\t\\tif (c != \\'X\\') {\\n\\t\\t\\ts.append(c);\\n\\t\\t}\\n\\t}\\n\\tfor (char c : end.toCharArray()) {\\n\\t\\tif (c != \\'X\\') {\\n\\t\\t\\te.append(c);\\n\\t\\t}\\n\\t}\\n\\tif (!s.toString().equals(e.toString()))\\n\\t\\treturn false;\\n\\t// check R\\n\\t// form i to start.length(), \\n\\t// if R found in start count++, \\n\\t// if R found in end count--, \\n\\t// if count comes to negative, that means \\'R\\' is in more left position in end, so \\'R\\' can\\'t move from start to end.\\n\\tint count = 0;\\n\\tfor (int i = 0; i < start.length(); i++) {\\n\\t\\tif (start.charAt(i) == \\'R\\') {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse if (end.charAt(i) == \\'R\\') {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tif (count < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t// check L\\n\\t// same with checking \\'R\\', only difference is: \\n\\t// to ensure every \\'L\\' comes first in end.\\n\\tcount = 0;\\n\\tfor (int i = 0; i < start.length(); i++) {\\n\\t\\tif (end.charAt(i) == \\'L\\') {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse if (start.charAt(i) == \\'L\\') {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tif (count < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n        int i = 0, j = 0, n = s.size(), m = e.size();\\n        while(i < n || j < m) {\\n            while(s[i] == \\'X\\') i++;\\n            while(e[j] == \\'X\\') j++;\\n\\n            if(s[i] != e[j]) return false;\\n            if(s[i] == \\'R\\' && i > j) return false;\\n            if(s[i] == \\'L\\' && i < j) return false; \\n            i++, j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973075,
                "title": "code-can-be-simplified-with-a-next-function",
                "content": "We need two pointers each tracks R and L respectively. Some solutions remove the X. But the easier way is simply skip the X using a next function. The next function will return the next R or L. It also simplies the condtions we have to check inside the while loop.\\n\\n# Code\\n```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if len(start) != len(end): return False\\n        i, j = self.next(-1, start), self.next(-1, end)\\n        while i < len(start) and j < len(end):\\n            if start[i] != end[j]: return False\\n            if start[i] == \\'R\\' and j < i: return False\\n            if start[i] == \\'L\\' and i < j: return False\\n            i, j = self.next(i, start), self.next(j, end)\\n        return True if i == j else False\\n\\n    def next(self, i, array):\\n        i += 1\\n        while i < len(array) and array[i] == \\'X\\': i += 1\\n        return i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        if len(start) != len(end): return False\\n        i, j = self.next(-1, start), self.next(-1, end)\\n        while i < len(start) and j < len(end):\\n            if start[i] != end[j]: return False\\n            if start[i] == \\'R\\' and j < i: return False\\n            if start[i] == \\'L\\' and i < j: return False\\n            i, j = self.next(i, start), self.next(j, end)\\n        return True if i == j else False\\n\\n    def next(self, i, array):\\n        i += 1\\n        while i < len(array) and array[i] == \\'X\\': i += 1\\n        return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872249,
                "title": "swap-adjacent-in-lr-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        string s1=\"\";\\n        string s2=\"\";\\n\\n        int i, j, k;\\n\\n        for(i=0 ; i<start.length() ; i++)\\n        {\\n            if(start[i]!=\\'X\\')\\n            {\\n                s1 += start[i];\\n            }\\n        }\\n        for(i=0 ; i<end.length() ; i++)\\n        {\\n            if(end[i]!=\\'X\\')\\n            {\\n                s2 += end[i];\\n            }\\n        }\\n\\n        if(s1!=s2)\\n            return false;\\n        \\n        for(i=0, j=0 ; i<start.length(), j<end.length();)\\n        {\\n            if(start[i]==\\'X\\')\\n            {\\n                i++;\\n            }\\n            else if(end[j]==\\'X\\')\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                if((start[i]==\\'L\\' && i<j) || (start[i]==\\'R\\' && i>j))\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4a08cdcf-2784-4774-a413-dbb7fb2c9188_1691328834.197557.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string start, string end) {\\n        string s1=\"\";\\n        string s2=\"\";\\n\\n        int i, j, k;\\n\\n        for(i=0 ; i<start.length() ; i++)\\n        {\\n            if(start[i]!=\\'X\\')\\n            {\\n                s1 += start[i];\\n            }\\n        }\\n        for(i=0 ; i<end.length() ; i++)\\n        {\\n            if(end[i]!=\\'X\\')\\n            {\\n                s2 += end[i];\\n            }\\n        }\\n\\n        if(s1!=s2)\\n            return false;\\n        \\n        for(i=0, j=0 ; i<start.length(), j<end.length();)\\n        {\\n            if(start[i]==\\'X\\')\\n            {\\n                i++;\\n            }\\n            else if(end[j]==\\'X\\')\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                if((start[i]==\\'L\\' && i<j) || (start[i]==\\'R\\' && i>j))\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870031,
                "title": "intuitive-solution-for-swap-lr-fastest-time",
                "content": "# Intuition\\nif switch to L then R count have to be equal\\nif switch to R then L count have to be equal\\nstart L count >= end L has to be true\\nstart R count <= end R has to be true\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncount L R for start and end\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nbool canTransform(char * start, char * end){\\n        int startLCount = 0;\\n        int startRCount = 0;\\n        int endLCount = 0;\\n        int endRCount = 0;\\n        for( int i =  0; start[i] ; ++i ){\\n            if(start[i] == \\'X\\' && end[i] == \\'X\\') continue;\\n            startLCount += (start[i] == \\'L\\');\\n            startRCount += (start[i] == \\'R\\');\\n            endLCount += (end[i] == \\'L\\');\\n            endRCount += (end[i] == \\'R\\');\\n            if( ( (start[i] == \\'L\\' || end[i] == \\'L\\') && (startRCount != endRCount || startLCount > endLCount) ) ||\\n                ( (end[i] == \\'R\\' || start[i] == \\'R\\') && (startLCount != endLCount || startRCount < endRCount) ) ) return false;\\n        }\\n        return startLCount == endLCount && startRCount == endRCount;\\n        return startLCount == endLCount && startRCount == endRCount;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canTransform(char * start, char * end){\\n        int startLCount = 0;\\n        int startRCount = 0;\\n        int endLCount = 0;\\n        int endRCount = 0;\\n        for( int i =  0; start[i] ; ++i ){\\n            if(start[i] == \\'X\\' && end[i] == \\'X\\') continue;\\n            startLCount += (start[i] == \\'L\\');\\n            startRCount += (start[i] == \\'R\\');\\n            endLCount += (end[i] == \\'L\\');\\n            endRCount += (end[i] == \\'R\\');\\n            if( ( (start[i] == \\'L\\' || end[i] == \\'L\\') && (startRCount != endRCount || startLCount > endLCount) ) ||\\n                ( (end[i] == \\'R\\' || start[i] == \\'R\\') && (startLCount != endLCount || startRCount < endRCount) ) ) return false;\\n        }\\n        return startLCount == endLCount && startRCount == endRCount;\\n        return startLCount == endLCount && startRCount == endRCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3756947,
                "title": "python-two-passes",
                "content": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        #R can flipt to right if no L in between\\n        #L can flip to left if no R in between\\n        \\n        m = len(start)\\n        r = 0\\n        for i in range(m):\\n            if start[i] == \"R\":\\n                r += 1\\n            if start[i] == \"L\":\\n                r = 0\\n            if end[i] == \"R\":\\n                r -= 1\\n            if r < 0:\\n                return False\\n\\n        l = 0\\n        for i in range(m - 1, -1, -1):\\n            if start[i] == \"L\":\\n                l += 1\\n            if start[i] == \"R\":\\n                l = 0\\n            if end[i] == \"L\":\\n                l -= 1\\n            if l < 0:\\n                return False\\n\\n        return l == 0 and r == 0            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canTransform(self, start: str, end: str) -> bool:\\n        #R can flipt to right if no L in between\\n        #L can flip to left if no R in between\\n        \\n        m = len(start)\\n        r = 0\\n        for i in range(m):\\n            if start[i] == \"R\":\\n                r += 1\\n            if start[i] == \"L\":\\n                r = 0\\n            if end[i] == \"R\":\\n                r -= 1\\n            if r < 0:\\n                return False\\n\\n        l = 0\\n        for i in range(m - 1, -1, -1):\\n            if start[i] == \"L\":\\n                l += 1\\n            if start[i] == \"R\":\\n                l = 0\\n            if end[i] == \"L\":\\n                l -= 1\\n            if l < 0:\\n                return False\\n\\n        return l == 0 and r == 0            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671412,
                "title": "a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool CanTransform(string start, string end) {\\n        if (start == end) return true;\\n        if (start.Count(x => x == \\'L\\') != end.Count(x => x == \\'L\\')) return false;\\n        if (start.Count(x => x == \\'R\\') != end.Count(x => x == \\'R\\')) return false;\\n        int first = 0, second = 0;\\n        while(first < start.Length && second < end.Length)\\n        {\\n            while (first < start.Length && start[first] == \\'X\\') first++;\\n            while (second < end.Length && end[second] == \\'X\\') second++;\\n            if (first == start.Length) return second == end.Length;\\n            if (second == end.Length) return first == start.Length;\\n            if (start[first] != end[second]) return false;\\n            if (start[first] == \\'L\\') \\n            {\\n                if (first < second) return false;\\n            }\\n            if (start[first] == \\'R\\') \\n            {\\n                if (first > second) return false;\\n            }\\n            first++; second++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CanTransform(string start, string end) {\\n        if (start == end) return true;\\n        if (start.Count(x => x == \\'L\\') != end.Count(x => x == \\'L\\')) return false;\\n        if (start.Count(x => x == \\'R\\') != end.Count(x => x == \\'R\\')) return false;\\n        int first = 0, second = 0;\\n        while(first < start.Length && second < end.Length)\\n        {\\n            while (first < start.Length && start[first] == \\'X\\') first++;\\n            while (second < end.Length && end[second] == \\'X\\') second++;\\n            if (first == start.Length) return second == end.Length;\\n            if (second == end.Length) return first == start.Length;\\n            if (start[first] != end[second]) return false;\\n            if (start[first] == \\'L\\') \\n            {\\n                if (first < second) return false;\\n            }\\n            if (start[first] == \\'R\\') \\n            {\\n                if (first > second) return false;\\n            }\\n            first++; second++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586002,
                "title": "100-beats-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int i = 0;\\n        int j = 0;\\n        char[] s = start.toCharArray();\\n        char[] e = end.toCharArray();\\n        while (i < s.length || j < e.length)\\n        {\\n            while (i<s.length && s[i] == \\'X\\') { \\n                i++; \\n            }\\n            while (j<e.length && e[j] == \\'X\\') {\\n                j++; \\n            }\\n            if (i == s.length || j == e.length) {\\n                break; \\n            }\\n  if (s[i] != e[j] || (s[i] == \\'R\\' && i > j) || (s[i] == \\'L\\' && i < j)) {\\n                return false; \\n            }\\n            i++;\\n            j++;\\n        }\\n        return i == j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int i = 0;\\n        int j = 0;\\n        char[] s = start.toCharArray();\\n        char[] e = end.toCharArray();\\n        while (i < s.length || j < e.length)\\n        {\\n            while (i<s.length && s[i] == \\'X\\') { \\n                i++; \\n            }\\n            while (j<e.length && e[j] == \\'X\\') {\\n                j++; \\n            }\\n            if (i == s.length || j == e.length) {\\n                break; \\n            }\\n  if (s[i] != e[j] || (s[i] == \\'R\\' && i > j) || (s[i] == \\'L\\' && i < j)) {\\n                return false; \\n            }\\n            i++;\\n            j++;\\n        }\\n        return i == j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554364,
                "title": "kotlin-solution-explanation",
                "content": "# Intuition\\nI first tried to solve it using quotas - for each X it meets, it will add 1 to quota. I don\\'t exactly know why I tried it, but I\\'m pretty sure one of them is that I read the question wrong, and wrote invalid test cases from the very beginning (In my IDE).\\n\\n# Approach\\nWe can find out that `L` can only move to the left of it, `R` can only move to the right of it, and that\\'s basically all you can do.\\n\\nSince we know that the order of `L` and `R` can\\'t be changed (Let\\'s say RXRXXLXL, there\\'s no way you can move an L beyond the first R, as `L` can only move left if the left side of it is X, and `R` can only move right if the right side of it is X), we can first verify if the ordering of `L` and `R` are the same in `start` and `end`, and then we just verify if all the `L` only goes left, and all the `R` only goes right!\\n\\nTo verify that, we can first do 2 passes approach, and figure out how we do the 1 pass.\\nFor `R`, we will remember how many `R`s has been recorded and unused in the end result, and move the pointer from left to right.\\n\\n\\nFor `L`, we will remember how many `L`s has been recorded and unused in the `end`, and move the pointer from right to left.\\n\\nNow we can optimize it by making the `L` check also do the pointer moving from left to right, but instead remember how many `L`s has been recorded and unused in the `start`, which means we can do it in 1 pass\\n\\nSorry if it sounds a bit confusing, it may be easier to just read the code.\\n\\nHere\\'s the simplified steps:\\n1. Check if the ordering is the same\\n  (`start.replace(\"X\", \"\") == end.replace(\"X\", \"\")`)\\n2. Now we just do the simple left-right-checking-thingy algorithm\\n3. Return true if the test case does not fail any tests above\\n\\n# Complexity\\n- Time complexity: We did it in 1 pass, so `O(n)`\\n\\n- Space complexity: We don\\'t have any array to store stuff, so `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun canTransform(start: String, end: String): Boolean {\\n        // Check the ordering\\n        if (start.replace(\"X\", \"\") != end.replace(\"X\", \"\")) return false\\n        \\n        // How many Ls has been recorded as not used in the end array, sorta like a stack\\n        var leftQuota = 0\\n        // How many Rs has been recorded as not used in the start array, sorta like a stack\\n        var rightQuota = 0\\n        for ((index, c) in start.withIndex()) {\\n            if (c == \\'L\\') {\\n                leftQuota--\\n                if (leftQuota < 0) {\\n                    return false\\n                }\\n            }\\n            if (end[index] == \\'L\\') {\\n                leftQuota++\\n            }\\n            if (c == \\'R\\') {\\n                rightQuota++\\n            }\\n            if (end[index] == \\'R\\') {\\n                rightQuota--\\n                if (rightQuota < 0) {\\n                    return false\\n                }\\n            }\\n        }\\n\\n        return true\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun canTransform(start: String, end: String): Boolean {\\n        // Check the ordering\\n        if (start.replace(\"X\", \"\") != end.replace(\"X\", \"\")) return false\\n        \\n        // How many Ls has been recorded as not used in the end array, sorta like a stack\\n        var leftQuota = 0\\n        // How many Rs has been recorded as not used in the start array, sorta like a stack\\n        var rightQuota = 0\\n        for ((index, c) in start.withIndex()) {\\n            if (c == \\'L\\') {\\n                leftQuota--\\n                if (leftQuota < 0) {\\n                    return false\\n                }\\n            }\\n            if (end[index] == \\'L\\') {\\n                leftQuota++\\n            }\\n            if (c == \\'R\\') {\\n                rightQuota++\\n            }\\n            if (end[index] == \\'R\\') {\\n                rightQuota--\\n                if (rightQuota < 0) {\\n                    return false\\n                }\\n            }\\n        }\\n\\n        return true\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535644,
                "title": "clean-and-concise-c-code-based-on-two-pointers-one-pass-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n(1)The relative order of \\'X\\' and \\'R\\' in both strings must be the same.\\n\\n(2-1)For any \\'L\\',  its position in \"start\" must to the right of that in \"end\", b/c \\'L\\' can only move to left. \\n\\n(2-2)For any \\'R\\', then its position in \"start\" must to the left of that in \"end\", b/c \\'R\\' can only move to right.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointers. One pass. If any of the above conditions are violated, return false. Otherwise, rethen true.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canTransform(string start, string end) {\\n        //check if all relative order of R and L are the same\\n        int n = start.size();\\n        int i = 0, j = 0;\\n        while (i < n || j < n) {\\n            while (i < n && start[i] == \\'X\\') i++;\\n            while (j < n && end[j] == \\'X\\') j++;\\n            \\n            //here  i, j piont to \\'X\\' or \\'R\\'\\n            //(1-1) If there are more \\'X\\' or \\'R\\' in one string than the other return false \\n            if (i == n && j != n) return false;\\n            if (i != n && j == n) return false;\\n            //(1-2) \\'X\\' and \\'R\\' in both strings must have the same relative orders\\n\\n            if (start[i] != end[j]) return false;\\n            //(2-1) If the current char is \\'L\\', then its position in start must to the right of that in end, b/c \\'L\\' can only move to left.\\n            //If this is not the case, return false;\\n            if (start[i] == \\'L\\' && j > i) return false;\\n            //(2-2) If the current char is \\'R\\', then its position in start must to the left of that in end, b/c \\'R\\' can only move to right.\\n            //If this is not the case, return false;\\n            if (start[i] == \\'R\\' && j < i) return false;\\n\\n            i++;\\n            j++;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool canTransform(string start, string end) {\\n        //check if all relative order of R and L are the same\\n        int n = start.size();\\n        int i = 0, j = 0;\\n        while (i < n || j < n) {\\n            while (i < n && start[i] == \\'X\\') i++;\\n            while (j < n && end[j] == \\'X\\') j++;\\n            \\n            //here  i, j piont to \\'X\\' or \\'R\\'\\n            //(1-1) If there are more \\'X\\' or \\'R\\' in one string than the other return false \\n            if (i == n && j != n) return false;\\n            if (i != n && j == n) return false;\\n            //(1-2) \\'X\\' and \\'R\\' in both strings must have the same relative orders\\n\\n            if (start[i] != end[j]) return false;\\n            //(2-1) If the current char is \\'L\\', then its position in start must to the right of that in end, b/c \\'L\\' can only move to left.\\n            //If this is not the case, return false;\\n            if (start[i] == \\'L\\' && j > i) return false;\\n            //(2-2) If the current char is \\'R\\', then its position in start must to the left of that in end, b/c \\'R\\' can only move to right.\\n            //If this is not the case, return false;\\n            if (start[i] == \\'R\\' && j < i) return false;\\n\\n            i++;\\n            j++;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486897,
                "title": "python-o-n-explained-observations-to-solve-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# TC - O(n)\\n# SC - O(1)\\n\\nclass Solution:\\n\\n    def canTransform(self, start: str, end: str) -> bool:\\n        # observations -  L can move only towards left & R can move only to right. Hence, \\n        # 1. start = end if X is removed from both start and end; as L can not cross over R\\n        # 2. pos of L in start has to be greater than or equal to corresponding pos of L in end \\n        # 3. pos of R in start has to be less than or equal to corresponding position of R in end\\n\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'):\\n            return False\\n\\n        generator = self.getCorrespondingChPos(start, end)\\n        for ch, start_pos, end_pos in generator:\\n            if ch == \\'L\\' and start_pos < end_pos:\\n                return False\\n            if ch == \\'R\\' and start_pos > end_pos:\\n                return False\\n\\n        return True \\n\\n    \\n    def getCorrespondingChPos(self, start, end):\\n        n = len(start)\\n        s_indx, e_indx = 0, 0\\n        while True:\\n            while s_indx < n and start[s_indx] == \\'X\\':\\n                s_indx += 1\\n            \\n            while e_indx < n and end[e_indx] == \\'X\\':\\n                e_indx += 1\\n            \\n     \\n\\n            if s_indx == n or e_indx == n:\\n                break\\n            \\n            yield start[s_indx], s_indx, e_indx\\n            s_indx += 1\\n            e_indx += 1\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# TC - O(n)\\n# SC - O(1)\\n\\nclass Solution:\\n\\n    def canTransform(self, start: str, end: str) -> bool:\\n        # observations -  L can move only towards left & R can move only to right. Hence, \\n        # 1. start = end if X is removed from both start and end; as L can not cross over R\\n        # 2. pos of L in start has to be greater than or equal to corresponding pos of L in end \\n        # 3. pos of R in start has to be less than or equal to corresponding position of R in end\\n\\n        if start.replace(\\'X\\', \\'\\') != end.replace(\\'X\\', \\'\\'):\\n            return False\\n\\n        generator = self.getCorrespondingChPos(start, end)\\n        for ch, start_pos, end_pos in generator:\\n            if ch == \\'L\\' and start_pos < end_pos:\\n                return False\\n            if ch == \\'R\\' and start_pos > end_pos:\\n                return False\\n\\n        return True \\n\\n    \\n    def getCorrespondingChPos(self, start, end):\\n        n = len(start)\\n        s_indx, e_indx = 0, 0\\n        while True:\\n            while s_indx < n and start[s_indx] == \\'X\\':\\n                s_indx += 1\\n            \\n            while e_indx < n and end[e_indx] == \\'X\\':\\n                e_indx += 1\\n            \\n     \\n\\n            if s_indx == n or e_indx == n:\\n                break\\n            \\n            yield start[s_indx], s_indx, e_indx\\n            s_indx += 1\\n            e_indx += 1\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456413,
                "title": "simple-two-pointer-solution-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n        int n=s.length();\\n        int i=0;\\n        int j=0;\\n        for(;i<n||j<n;i++,j++){\\n            while(i<n&&s[i]==\\'X\\'){\\n                i++;\\n            }\\n            while(j<n&&e[j]==\\'X\\'){\\n                j++;\\n            }\\n            if(i==n||j==n||s[i]!=e[j]||(s[i]==\\'L\\'&&i<j)||(s[i]==\\'R\\'&&i>j))break;\\n        }\\n       return i==n && j==n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTransform(string s, string e) {\\n        int n=s.length();\\n        int i=0;\\n        int j=0;\\n        for(;i<n||j<n;i++,j++){\\n            while(i<n&&s[i]==\\'X\\'){\\n                i++;\\n            }\\n            while(j<n&&e[j]==\\'X\\'){\\n                j++;\\n            }\\n            if(i==n||j==n||s[i]!=e[j]||(s[i]==\\'L\\'&&i<j)||(s[i]==\\'R\\'&&i>j))break;\\n        }\\n       return i==n && j==n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453736,
                "title": "fast-java-solution-beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int s=0,e=0,n=start.length();\\n        while(s<n || e<n){ \\n            while (s<n && start.charAt(s)==\\'X\\')\\n                s++;\\n            while (e<n && end.charAt(e)==\\'X\\')\\n                e++;\\n            if(s>=n || e>=n)\\n                return (s==n && e==n);\\n            char sc=start.charAt(s);\\n            char tc=end.charAt(e);\\n            if(sc!=tc)\\n                return false;\\n            if ((tc==\\'L\\' && s<e) || (tc==\\'R\\' && s>e))\\n                return false;\\n            s++;\\n            e++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        int s=0,e=0,n=start.length();\\n        while(s<n || e<n){ \\n            while (s<n && start.charAt(s)==\\'X\\')\\n                s++;\\n            while (e<n && end.charAt(e)==\\'X\\')\\n                e++;\\n            if(s>=n || e>=n)\\n                return (s==n && e==n);\\n            char sc=start.charAt(s);\\n            char tc=end.charAt(e);\\n            if(sc!=tc)\\n                return false;\\n            if ((tc==\\'L\\' && s<e) || (tc==\\'R\\' && s>e))\\n                return false;\\n            s++;\\n            e++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564969,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Misleading description; the sentence \"return True if and only if there exists a sequence of moves to transform **one string to the other**.\" may infer \"return True if **either** A can be transformed to B **or** B can be transformed to A\""
                    },
                    {
                        "username": "abhiarya329",
                        "content": "start = \"XXXXXXXXLXXXXXXRXXXX\"\\nend = \"XXXXXXXXXLXXXXXRXXXX\"\\n\\nMy solution give True ans \"End\" can be transformed to \"Start\"\\n\\nbut  it\\'s expected answer is False \\n\\nhow can you explain it "
                    },
                    {
                        "username": "redblue2017",
                        "content": "start=\"RLX\"\\nend=\"XLR\"\\nMy code passed this problem\\'s test cases, but failed the above one. Its answer should be false.\\nThere are some similar solutions that will also fail this test case, such as this one https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/114737/Simple-Java-Solution\\n"
                    },
                    {
                        "username": "limeybear7",
                        "content": "An important thing to understand the problem description is to pay close attention to the allowed operations.\nStart and end are not interchangeable, as the operations are not bidirectional.\n\nA move could more clearly be described as \"move L to the left, across X\" and \"move R to the right, across X\".\n\nAs such, the common issue of transforming end with the given operations to form start results in start needing to do the inverse, moving L right and R left, which is not allowed."
                    },
                    {
                        "username": "hana_y",
                        "content": "\"XXRXXLXXXX\"\\n\"XXXXRXXLXX\"\\n\\nI failed above case and I\\'m wondering why. The right answer is false\\n\\ncould we turn start to end in the following way:\\nXXXRXLXXXX ->\\nXXXXRLXXXX ->\\nXXXXRXLXXX -> \\nXXXXRXXLXX"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "No, because you are replacing \"LX\" with \"XL\" in this case which is not allowed. It must be the other way around.\nThis is happening here:\nXXXXRLXXXX ->\nXXXXRXLXXX ->"
                    },
                    {
                        "username": "RajathGoku",
                        "content": "for test case, \"XXXXXLXXXX\" \"LXXXXXXXXX\" ....It should return false since no move, or sequence of moves can make first string equal to second.But i see both OJ and your code returns true. How is this possible?"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "The possible sequence:\\nXXXXXLXXXX\\nXXXXLXXXXX\\nXXXLXXXXXX\\nXXLXXXXXXX\\nXLXXXXXXXX\\nLXXXXXXXXX"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "it\\'s like two way street, either start/end can be the final reference, the problem desc is really unable to easily grasp, i failed in some other cases which i don\\'t even know why, damn it"
                    },
                    {
                        "username": "ajaysaiva",
                        "content": "**if and only if there exists a sequence of moves to transform one string to the other**\\n\\nIn english, this means you should convert end to start or start to end.\\nBut official solution fails this input \"LX\", \"XL\".\\n\\n"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "No not really"
                    },
                    {
                        "username": "romangrigorii",
                        "content": "The official solution fails on many obvious cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "How this\\n\"LXXLXRLXXL\"\\ncan\\'t go to\\n\"XLLXRXLXLX\"\\n??\\n\"LXXLXRLXXL\"\\n  XLLXRX    LX\\n\\n??????????????????"
                    },
                    {
                        "username": "feng3245",
                        "content": "Ohhhhhhh it only works with one direction...."
                    },
                    {
                        "username": "ishitatrivedidocs",
                        "content": "I feel the problem description is quite incomplete, problem-solving doesn\\'t involve guessing incomplete problems."
                    }
                ]
            },
            {
                "id": 1569236,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Misleading description; the sentence \"return True if and only if there exists a sequence of moves to transform **one string to the other**.\" may infer \"return True if **either** A can be transformed to B **or** B can be transformed to A\""
                    },
                    {
                        "username": "abhiarya329",
                        "content": "start = \"XXXXXXXXLXXXXXXRXXXX\"\\nend = \"XXXXXXXXXLXXXXXRXXXX\"\\n\\nMy solution give True ans \"End\" can be transformed to \"Start\"\\n\\nbut  it\\'s expected answer is False \\n\\nhow can you explain it "
                    },
                    {
                        "username": "redblue2017",
                        "content": "start=\"RLX\"\\nend=\"XLR\"\\nMy code passed this problem\\'s test cases, but failed the above one. Its answer should be false.\\nThere are some similar solutions that will also fail this test case, such as this one https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/114737/Simple-Java-Solution\\n"
                    },
                    {
                        "username": "limeybear7",
                        "content": "An important thing to understand the problem description is to pay close attention to the allowed operations.\nStart and end are not interchangeable, as the operations are not bidirectional.\n\nA move could more clearly be described as \"move L to the left, across X\" and \"move R to the right, across X\".\n\nAs such, the common issue of transforming end with the given operations to form start results in start needing to do the inverse, moving L right and R left, which is not allowed."
                    },
                    {
                        "username": "hana_y",
                        "content": "\"XXRXXLXXXX\"\\n\"XXXXRXXLXX\"\\n\\nI failed above case and I\\'m wondering why. The right answer is false\\n\\ncould we turn start to end in the following way:\\nXXXRXLXXXX ->\\nXXXXRLXXXX ->\\nXXXXRXLXXX -> \\nXXXXRXXLXX"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "No, because you are replacing \"LX\" with \"XL\" in this case which is not allowed. It must be the other way around.\nThis is happening here:\nXXXXRLXXXX ->\nXXXXRXLXXX ->"
                    },
                    {
                        "username": "RajathGoku",
                        "content": "for test case, \"XXXXXLXXXX\" \"LXXXXXXXXX\" ....It should return false since no move, or sequence of moves can make first string equal to second.But i see both OJ and your code returns true. How is this possible?"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "The possible sequence:\\nXXXXXLXXXX\\nXXXXLXXXXX\\nXXXLXXXXXX\\nXXLXXXXXXX\\nXLXXXXXXXX\\nLXXXXXXXXX"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "it\\'s like two way street, either start/end can be the final reference, the problem desc is really unable to easily grasp, i failed in some other cases which i don\\'t even know why, damn it"
                    },
                    {
                        "username": "ajaysaiva",
                        "content": "**if and only if there exists a sequence of moves to transform one string to the other**\\n\\nIn english, this means you should convert end to start or start to end.\\nBut official solution fails this input \"LX\", \"XL\".\\n\\n"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "No not really"
                    },
                    {
                        "username": "romangrigorii",
                        "content": "The official solution fails on many obvious cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "How this\\n\"LXXLXRLXXL\"\\ncan\\'t go to\\n\"XLLXRXLXLX\"\\n??\\n\"LXXLXRLXXL\"\\n  XLLXRX    LX\\n\\n??????????????????"
                    },
                    {
                        "username": "feng3245",
                        "content": "Ohhhhhhh it only works with one direction...."
                    },
                    {
                        "username": "ishitatrivedidocs",
                        "content": "I feel the problem description is quite incomplete, problem-solving doesn\\'t involve guessing incomplete problems."
                    }
                ]
            },
            {
                "id": 1660928,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Misleading description; the sentence \"return True if and only if there exists a sequence of moves to transform **one string to the other**.\" may infer \"return True if **either** A can be transformed to B **or** B can be transformed to A\""
                    },
                    {
                        "username": "abhiarya329",
                        "content": "start = \"XXXXXXXXLXXXXXXRXXXX\"\\nend = \"XXXXXXXXXLXXXXXRXXXX\"\\n\\nMy solution give True ans \"End\" can be transformed to \"Start\"\\n\\nbut  it\\'s expected answer is False \\n\\nhow can you explain it "
                    },
                    {
                        "username": "redblue2017",
                        "content": "start=\"RLX\"\\nend=\"XLR\"\\nMy code passed this problem\\'s test cases, but failed the above one. Its answer should be false.\\nThere are some similar solutions that will also fail this test case, such as this one https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/114737/Simple-Java-Solution\\n"
                    },
                    {
                        "username": "limeybear7",
                        "content": "An important thing to understand the problem description is to pay close attention to the allowed operations.\nStart and end are not interchangeable, as the operations are not bidirectional.\n\nA move could more clearly be described as \"move L to the left, across X\" and \"move R to the right, across X\".\n\nAs such, the common issue of transforming end with the given operations to form start results in start needing to do the inverse, moving L right and R left, which is not allowed."
                    },
                    {
                        "username": "hana_y",
                        "content": "\"XXRXXLXXXX\"\\n\"XXXXRXXLXX\"\\n\\nI failed above case and I\\'m wondering why. The right answer is false\\n\\ncould we turn start to end in the following way:\\nXXXRXLXXXX ->\\nXXXXRLXXXX ->\\nXXXXRXLXXX -> \\nXXXXRXXLXX"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "No, because you are replacing \"LX\" with \"XL\" in this case which is not allowed. It must be the other way around.\nThis is happening here:\nXXXXRLXXXX ->\nXXXXRXLXXX ->"
                    },
                    {
                        "username": "RajathGoku",
                        "content": "for test case, \"XXXXXLXXXX\" \"LXXXXXXXXX\" ....It should return false since no move, or sequence of moves can make first string equal to second.But i see both OJ and your code returns true. How is this possible?"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "The possible sequence:\\nXXXXXLXXXX\\nXXXXLXXXXX\\nXXXLXXXXXX\\nXXLXXXXXXX\\nXLXXXXXXXX\\nLXXXXXXXXX"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "it\\'s like two way street, either start/end can be the final reference, the problem desc is really unable to easily grasp, i failed in some other cases which i don\\'t even know why, damn it"
                    },
                    {
                        "username": "ajaysaiva",
                        "content": "**if and only if there exists a sequence of moves to transform one string to the other**\\n\\nIn english, this means you should convert end to start or start to end.\\nBut official solution fails this input \"LX\", \"XL\".\\n\\n"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "No not really"
                    },
                    {
                        "username": "romangrigorii",
                        "content": "The official solution fails on many obvious cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "How this\\n\"LXXLXRLXXL\"\\ncan\\'t go to\\n\"XLLXRXLXLX\"\\n??\\n\"LXXLXRLXXL\"\\n  XLLXRX    LX\\n\\n??????????????????"
                    },
                    {
                        "username": "feng3245",
                        "content": "Ohhhhhhh it only works with one direction...."
                    },
                    {
                        "username": "ishitatrivedidocs",
                        "content": "I feel the problem description is quite incomplete, problem-solving doesn\\'t involve guessing incomplete problems."
                    }
                ]
            },
            {
                "id": 1569404,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Misleading description; the sentence \"return True if and only if there exists a sequence of moves to transform **one string to the other**.\" may infer \"return True if **either** A can be transformed to B **or** B can be transformed to A\""
                    },
                    {
                        "username": "abhiarya329",
                        "content": "start = \"XXXXXXXXLXXXXXXRXXXX\"\\nend = \"XXXXXXXXXLXXXXXRXXXX\"\\n\\nMy solution give True ans \"End\" can be transformed to \"Start\"\\n\\nbut  it\\'s expected answer is False \\n\\nhow can you explain it "
                    },
                    {
                        "username": "redblue2017",
                        "content": "start=\"RLX\"\\nend=\"XLR\"\\nMy code passed this problem\\'s test cases, but failed the above one. Its answer should be false.\\nThere are some similar solutions that will also fail this test case, such as this one https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/114737/Simple-Java-Solution\\n"
                    },
                    {
                        "username": "limeybear7",
                        "content": "An important thing to understand the problem description is to pay close attention to the allowed operations.\nStart and end are not interchangeable, as the operations are not bidirectional.\n\nA move could more clearly be described as \"move L to the left, across X\" and \"move R to the right, across X\".\n\nAs such, the common issue of transforming end with the given operations to form start results in start needing to do the inverse, moving L right and R left, which is not allowed."
                    },
                    {
                        "username": "hana_y",
                        "content": "\"XXRXXLXXXX\"\\n\"XXXXRXXLXX\"\\n\\nI failed above case and I\\'m wondering why. The right answer is false\\n\\ncould we turn start to end in the following way:\\nXXXRXLXXXX ->\\nXXXXRLXXXX ->\\nXXXXRXLXXX -> \\nXXXXRXXLXX"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "No, because you are replacing \"LX\" with \"XL\" in this case which is not allowed. It must be the other way around.\nThis is happening here:\nXXXXRLXXXX ->\nXXXXRXLXXX ->"
                    },
                    {
                        "username": "RajathGoku",
                        "content": "for test case, \"XXXXXLXXXX\" \"LXXXXXXXXX\" ....It should return false since no move, or sequence of moves can make first string equal to second.But i see both OJ and your code returns true. How is this possible?"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "The possible sequence:\\nXXXXXLXXXX\\nXXXXLXXXXX\\nXXXLXXXXXX\\nXXLXXXXXXX\\nXLXXXXXXXX\\nLXXXXXXXXX"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "it\\'s like two way street, either start/end can be the final reference, the problem desc is really unable to easily grasp, i failed in some other cases which i don\\'t even know why, damn it"
                    },
                    {
                        "username": "ajaysaiva",
                        "content": "**if and only if there exists a sequence of moves to transform one string to the other**\\n\\nIn english, this means you should convert end to start or start to end.\\nBut official solution fails this input \"LX\", \"XL\".\\n\\n"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "No not really"
                    },
                    {
                        "username": "romangrigorii",
                        "content": "The official solution fails on many obvious cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "How this\\n\"LXXLXRLXXL\"\\ncan\\'t go to\\n\"XLLXRXLXLX\"\\n??\\n\"LXXLXRLXXL\"\\n  XLLXRX    LX\\n\\n??????????????????"
                    },
                    {
                        "username": "feng3245",
                        "content": "Ohhhhhhh it only works with one direction...."
                    },
                    {
                        "username": "ishitatrivedidocs",
                        "content": "I feel the problem description is quite incomplete, problem-solving doesn\\'t involve guessing incomplete problems."
                    }
                ]
            },
            {
                "id": 1571848,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Misleading description; the sentence \"return True if and only if there exists a sequence of moves to transform **one string to the other**.\" may infer \"return True if **either** A can be transformed to B **or** B can be transformed to A\""
                    },
                    {
                        "username": "abhiarya329",
                        "content": "start = \"XXXXXXXXLXXXXXXRXXXX\"\\nend = \"XXXXXXXXXLXXXXXRXXXX\"\\n\\nMy solution give True ans \"End\" can be transformed to \"Start\"\\n\\nbut  it\\'s expected answer is False \\n\\nhow can you explain it "
                    },
                    {
                        "username": "redblue2017",
                        "content": "start=\"RLX\"\\nend=\"XLR\"\\nMy code passed this problem\\'s test cases, but failed the above one. Its answer should be false.\\nThere are some similar solutions that will also fail this test case, such as this one https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/114737/Simple-Java-Solution\\n"
                    },
                    {
                        "username": "limeybear7",
                        "content": "An important thing to understand the problem description is to pay close attention to the allowed operations.\nStart and end are not interchangeable, as the operations are not bidirectional.\n\nA move could more clearly be described as \"move L to the left, across X\" and \"move R to the right, across X\".\n\nAs such, the common issue of transforming end with the given operations to form start results in start needing to do the inverse, moving L right and R left, which is not allowed."
                    },
                    {
                        "username": "hana_y",
                        "content": "\"XXRXXLXXXX\"\\n\"XXXXRXXLXX\"\\n\\nI failed above case and I\\'m wondering why. The right answer is false\\n\\ncould we turn start to end in the following way:\\nXXXRXLXXXX ->\\nXXXXRLXXXX ->\\nXXXXRXLXXX -> \\nXXXXRXXLXX"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "No, because you are replacing \"LX\" with \"XL\" in this case which is not allowed. It must be the other way around.\nThis is happening here:\nXXXXRLXXXX ->\nXXXXRXLXXX ->"
                    },
                    {
                        "username": "RajathGoku",
                        "content": "for test case, \"XXXXXLXXXX\" \"LXXXXXXXXX\" ....It should return false since no move, or sequence of moves can make first string equal to second.But i see both OJ and your code returns true. How is this possible?"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "The possible sequence:\\nXXXXXLXXXX\\nXXXXLXXXXX\\nXXXLXXXXXX\\nXXLXXXXXXX\\nXLXXXXXXXX\\nLXXXXXXXXX"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "it\\'s like two way street, either start/end can be the final reference, the problem desc is really unable to easily grasp, i failed in some other cases which i don\\'t even know why, damn it"
                    },
                    {
                        "username": "ajaysaiva",
                        "content": "**if and only if there exists a sequence of moves to transform one string to the other**\\n\\nIn english, this means you should convert end to start or start to end.\\nBut official solution fails this input \"LX\", \"XL\".\\n\\n"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "No not really"
                    },
                    {
                        "username": "romangrigorii",
                        "content": "The official solution fails on many obvious cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "How this\\n\"LXXLXRLXXL\"\\ncan\\'t go to\\n\"XLLXRXLXLX\"\\n??\\n\"LXXLXRLXXL\"\\n  XLLXRX    LX\\n\\n??????????????????"
                    },
                    {
                        "username": "feng3245",
                        "content": "Ohhhhhhh it only works with one direction...."
                    },
                    {
                        "username": "ishitatrivedidocs",
                        "content": "I feel the problem description is quite incomplete, problem-solving doesn\\'t involve guessing incomplete problems."
                    }
                ]
            },
            {
                "id": 1570387,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Misleading description; the sentence \"return True if and only if there exists a sequence of moves to transform **one string to the other**.\" may infer \"return True if **either** A can be transformed to B **or** B can be transformed to A\""
                    },
                    {
                        "username": "abhiarya329",
                        "content": "start = \"XXXXXXXXLXXXXXXRXXXX\"\\nend = \"XXXXXXXXXLXXXXXRXXXX\"\\n\\nMy solution give True ans \"End\" can be transformed to \"Start\"\\n\\nbut  it\\'s expected answer is False \\n\\nhow can you explain it "
                    },
                    {
                        "username": "redblue2017",
                        "content": "start=\"RLX\"\\nend=\"XLR\"\\nMy code passed this problem\\'s test cases, but failed the above one. Its answer should be false.\\nThere are some similar solutions that will also fail this test case, such as this one https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/114737/Simple-Java-Solution\\n"
                    },
                    {
                        "username": "limeybear7",
                        "content": "An important thing to understand the problem description is to pay close attention to the allowed operations.\nStart and end are not interchangeable, as the operations are not bidirectional.\n\nA move could more clearly be described as \"move L to the left, across X\" and \"move R to the right, across X\".\n\nAs such, the common issue of transforming end with the given operations to form start results in start needing to do the inverse, moving L right and R left, which is not allowed."
                    },
                    {
                        "username": "hana_y",
                        "content": "\"XXRXXLXXXX\"\\n\"XXXXRXXLXX\"\\n\\nI failed above case and I\\'m wondering why. The right answer is false\\n\\ncould we turn start to end in the following way:\\nXXXRXLXXXX ->\\nXXXXRLXXXX ->\\nXXXXRXLXXX -> \\nXXXXRXXLXX"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "No, because you are replacing \"LX\" with \"XL\" in this case which is not allowed. It must be the other way around.\nThis is happening here:\nXXXXRLXXXX ->\nXXXXRXLXXX ->"
                    },
                    {
                        "username": "RajathGoku",
                        "content": "for test case, \"XXXXXLXXXX\" \"LXXXXXXXXX\" ....It should return false since no move, or sequence of moves can make first string equal to second.But i see both OJ and your code returns true. How is this possible?"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "The possible sequence:\\nXXXXXLXXXX\\nXXXXLXXXXX\\nXXXLXXXXXX\\nXXLXXXXXXX\\nXLXXXXXXXX\\nLXXXXXXXXX"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "it\\'s like two way street, either start/end can be the final reference, the problem desc is really unable to easily grasp, i failed in some other cases which i don\\'t even know why, damn it"
                    },
                    {
                        "username": "ajaysaiva",
                        "content": "**if and only if there exists a sequence of moves to transform one string to the other**\\n\\nIn english, this means you should convert end to start or start to end.\\nBut official solution fails this input \"LX\", \"XL\".\\n\\n"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "No not really"
                    },
                    {
                        "username": "romangrigorii",
                        "content": "The official solution fails on many obvious cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "How this\\n\"LXXLXRLXXL\"\\ncan\\'t go to\\n\"XLLXRXLXLX\"\\n??\\n\"LXXLXRLXXL\"\\n  XLLXRX    LX\\n\\n??????????????????"
                    },
                    {
                        "username": "feng3245",
                        "content": "Ohhhhhhh it only works with one direction...."
                    },
                    {
                        "username": "ishitatrivedidocs",
                        "content": "I feel the problem description is quite incomplete, problem-solving doesn\\'t involve guessing incomplete problems."
                    }
                ]
            },
            {
                "id": 2075345,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Misleading description; the sentence \"return True if and only if there exists a sequence of moves to transform **one string to the other**.\" may infer \"return True if **either** A can be transformed to B **or** B can be transformed to A\""
                    },
                    {
                        "username": "abhiarya329",
                        "content": "start = \"XXXXXXXXLXXXXXXRXXXX\"\\nend = \"XXXXXXXXXLXXXXXRXXXX\"\\n\\nMy solution give True ans \"End\" can be transformed to \"Start\"\\n\\nbut  it\\'s expected answer is False \\n\\nhow can you explain it "
                    },
                    {
                        "username": "redblue2017",
                        "content": "start=\"RLX\"\\nend=\"XLR\"\\nMy code passed this problem\\'s test cases, but failed the above one. Its answer should be false.\\nThere are some similar solutions that will also fail this test case, such as this one https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/114737/Simple-Java-Solution\\n"
                    },
                    {
                        "username": "limeybear7",
                        "content": "An important thing to understand the problem description is to pay close attention to the allowed operations.\nStart and end are not interchangeable, as the operations are not bidirectional.\n\nA move could more clearly be described as \"move L to the left, across X\" and \"move R to the right, across X\".\n\nAs such, the common issue of transforming end with the given operations to form start results in start needing to do the inverse, moving L right and R left, which is not allowed."
                    },
                    {
                        "username": "hana_y",
                        "content": "\"XXRXXLXXXX\"\\n\"XXXXRXXLXX\"\\n\\nI failed above case and I\\'m wondering why. The right answer is false\\n\\ncould we turn start to end in the following way:\\nXXXRXLXXXX ->\\nXXXXRLXXXX ->\\nXXXXRXLXXX -> \\nXXXXRXXLXX"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "No, because you are replacing \"LX\" with \"XL\" in this case which is not allowed. It must be the other way around.\nThis is happening here:\nXXXXRLXXXX ->\nXXXXRXLXXX ->"
                    },
                    {
                        "username": "RajathGoku",
                        "content": "for test case, \"XXXXXLXXXX\" \"LXXXXXXXXX\" ....It should return false since no move, or sequence of moves can make first string equal to second.But i see both OJ and your code returns true. How is this possible?"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "The possible sequence:\\nXXXXXLXXXX\\nXXXXLXXXXX\\nXXXLXXXXXX\\nXXLXXXXXXX\\nXLXXXXXXXX\\nLXXXXXXXXX"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "it\\'s like two way street, either start/end can be the final reference, the problem desc is really unable to easily grasp, i failed in some other cases which i don\\'t even know why, damn it"
                    },
                    {
                        "username": "ajaysaiva",
                        "content": "**if and only if there exists a sequence of moves to transform one string to the other**\\n\\nIn english, this means you should convert end to start or start to end.\\nBut official solution fails this input \"LX\", \"XL\".\\n\\n"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "No not really"
                    },
                    {
                        "username": "romangrigorii",
                        "content": "The official solution fails on many obvious cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "How this\\n\"LXXLXRLXXL\"\\ncan\\'t go to\\n\"XLLXRXLXLX\"\\n??\\n\"LXXLXRLXXL\"\\n  XLLXRX    LX\\n\\n??????????????????"
                    },
                    {
                        "username": "feng3245",
                        "content": "Ohhhhhhh it only works with one direction...."
                    },
                    {
                        "username": "ishitatrivedidocs",
                        "content": "I feel the problem description is quite incomplete, problem-solving doesn\\'t involve guessing incomplete problems."
                    }
                ]
            },
            {
                "id": 2064518,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Misleading description; the sentence \"return True if and only if there exists a sequence of moves to transform **one string to the other**.\" may infer \"return True if **either** A can be transformed to B **or** B can be transformed to A\""
                    },
                    {
                        "username": "abhiarya329",
                        "content": "start = \"XXXXXXXXLXXXXXXRXXXX\"\\nend = \"XXXXXXXXXLXXXXXRXXXX\"\\n\\nMy solution give True ans \"End\" can be transformed to \"Start\"\\n\\nbut  it\\'s expected answer is False \\n\\nhow can you explain it "
                    },
                    {
                        "username": "redblue2017",
                        "content": "start=\"RLX\"\\nend=\"XLR\"\\nMy code passed this problem\\'s test cases, but failed the above one. Its answer should be false.\\nThere are some similar solutions that will also fail this test case, such as this one https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/114737/Simple-Java-Solution\\n"
                    },
                    {
                        "username": "limeybear7",
                        "content": "An important thing to understand the problem description is to pay close attention to the allowed operations.\nStart and end are not interchangeable, as the operations are not bidirectional.\n\nA move could more clearly be described as \"move L to the left, across X\" and \"move R to the right, across X\".\n\nAs such, the common issue of transforming end with the given operations to form start results in start needing to do the inverse, moving L right and R left, which is not allowed."
                    },
                    {
                        "username": "hana_y",
                        "content": "\"XXRXXLXXXX\"\\n\"XXXXRXXLXX\"\\n\\nI failed above case and I\\'m wondering why. The right answer is false\\n\\ncould we turn start to end in the following way:\\nXXXRXLXXXX ->\\nXXXXRLXXXX ->\\nXXXXRXLXXX -> \\nXXXXRXXLXX"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "No, because you are replacing \"LX\" with \"XL\" in this case which is not allowed. It must be the other way around.\nThis is happening here:\nXXXXRLXXXX ->\nXXXXRXLXXX ->"
                    },
                    {
                        "username": "RajathGoku",
                        "content": "for test case, \"XXXXXLXXXX\" \"LXXXXXXXXX\" ....It should return false since no move, or sequence of moves can make first string equal to second.But i see both OJ and your code returns true. How is this possible?"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "The possible sequence:\\nXXXXXLXXXX\\nXXXXLXXXXX\\nXXXLXXXXXX\\nXXLXXXXXXX\\nXLXXXXXXXX\\nLXXXXXXXXX"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "it\\'s like two way street, either start/end can be the final reference, the problem desc is really unable to easily grasp, i failed in some other cases which i don\\'t even know why, damn it"
                    },
                    {
                        "username": "ajaysaiva",
                        "content": "**if and only if there exists a sequence of moves to transform one string to the other**\\n\\nIn english, this means you should convert end to start or start to end.\\nBut official solution fails this input \"LX\", \"XL\".\\n\\n"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "No not really"
                    },
                    {
                        "username": "romangrigorii",
                        "content": "The official solution fails on many obvious cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "How this\\n\"LXXLXRLXXL\"\\ncan\\'t go to\\n\"XLLXRXLXLX\"\\n??\\n\"LXXLXRLXXL\"\\n  XLLXRX    LX\\n\\n??????????????????"
                    },
                    {
                        "username": "feng3245",
                        "content": "Ohhhhhhh it only works with one direction...."
                    },
                    {
                        "username": "ishitatrivedidocs",
                        "content": "I feel the problem description is quite incomplete, problem-solving doesn\\'t involve guessing incomplete problems."
                    }
                ]
            },
            {
                "id": 1980556,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Misleading description; the sentence \"return True if and only if there exists a sequence of moves to transform **one string to the other**.\" may infer \"return True if **either** A can be transformed to B **or** B can be transformed to A\""
                    },
                    {
                        "username": "abhiarya329",
                        "content": "start = \"XXXXXXXXLXXXXXXRXXXX\"\\nend = \"XXXXXXXXXLXXXXXRXXXX\"\\n\\nMy solution give True ans \"End\" can be transformed to \"Start\"\\n\\nbut  it\\'s expected answer is False \\n\\nhow can you explain it "
                    },
                    {
                        "username": "redblue2017",
                        "content": "start=\"RLX\"\\nend=\"XLR\"\\nMy code passed this problem\\'s test cases, but failed the above one. Its answer should be false.\\nThere are some similar solutions that will also fail this test case, such as this one https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/114737/Simple-Java-Solution\\n"
                    },
                    {
                        "username": "limeybear7",
                        "content": "An important thing to understand the problem description is to pay close attention to the allowed operations.\nStart and end are not interchangeable, as the operations are not bidirectional.\n\nA move could more clearly be described as \"move L to the left, across X\" and \"move R to the right, across X\".\n\nAs such, the common issue of transforming end with the given operations to form start results in start needing to do the inverse, moving L right and R left, which is not allowed."
                    },
                    {
                        "username": "hana_y",
                        "content": "\"XXRXXLXXXX\"\\n\"XXXXRXXLXX\"\\n\\nI failed above case and I\\'m wondering why. The right answer is false\\n\\ncould we turn start to end in the following way:\\nXXXRXLXXXX ->\\nXXXXRLXXXX ->\\nXXXXRXLXXX -> \\nXXXXRXXLXX"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "No, because you are replacing \"LX\" with \"XL\" in this case which is not allowed. It must be the other way around.\nThis is happening here:\nXXXXRLXXXX ->\nXXXXRXLXXX ->"
                    },
                    {
                        "username": "RajathGoku",
                        "content": "for test case, \"XXXXXLXXXX\" \"LXXXXXXXXX\" ....It should return false since no move, or sequence of moves can make first string equal to second.But i see both OJ and your code returns true. How is this possible?"
                    },
                    {
                        "username": "ST1LLY",
                        "content": "The possible sequence:\\nXXXXXLXXXX\\nXXXXLXXXXX\\nXXXLXXXXXX\\nXXLXXXXXXX\\nXLXXXXXXXX\\nLXXXXXXXXX"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "it\\'s like two way street, either start/end can be the final reference, the problem desc is really unable to easily grasp, i failed in some other cases which i don\\'t even know why, damn it"
                    },
                    {
                        "username": "ajaysaiva",
                        "content": "**if and only if there exists a sequence of moves to transform one string to the other**\\n\\nIn english, this means you should convert end to start or start to end.\\nBut official solution fails this input \"LX\", \"XL\".\\n\\n"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "No not really"
                    },
                    {
                        "username": "romangrigorii",
                        "content": "The official solution fails on many obvious cases."
                    },
                    {
                        "username": "feng3245",
                        "content": "How this\\n\"LXXLXRLXXL\"\\ncan\\'t go to\\n\"XLLXRXLXLX\"\\n??\\n\"LXXLXRLXXL\"\\n  XLLXRX    LX\\n\\n??????????????????"
                    },
                    {
                        "username": "feng3245",
                        "content": "Ohhhhhhh it only works with one direction...."
                    },
                    {
                        "username": "ishitatrivedidocs",
                        "content": "I feel the problem description is quite incomplete, problem-solving doesn\\'t involve guessing incomplete problems."
                    }
                ]
            }
        ]
    }
]